/*
	WebMolKit

	(c) 2010-2018 Molecular Materials Informatics, Inc.

	All rights reserved

	http://molmatinf.com

	[PKG=webmolkit]
*/

///<reference path='../decl/corrections.d.ts'/>
///<reference path='../util/util.ts'/>
///<reference path='../data/Molecule.ts'/>
///<reference path='../data/MolUtil.ts'/>
///<reference path='../data/DataSheet.ts'/>
///<reference path='../data/BondArtifact.ts'/>

namespace WebMolKit /* BOF */ {

/*
	MDL Molfile writer: convert the native structure format to MDL Molfile, V2000. Note that the destination format has legacy
	problems out the wazoo, and even retroactive improvements (e.g. V3000) tend to be not supported by most implementations. The
	bottom line is that the best strategy is generally to stick with a lowest common denominator subset, and try to transition away
	from the format.

	MDL SDfile writer: including non-molecule fields in collections. The SDfile format is problematic for as many reasons as the
	molecules; the best strategy is to avoid using it whenever possible, but it is so often not.
*/

export class MDLMOLWriter
{
	// options
	public includeHeader = true; // if on, the 3 line header will be included
	public enhancedFields = true; // if on, non-standard MDL fields may be added
	public chargeSeparate = false; // if on, zero bonds will be split out
	public abbrevSgroups = true; // if on, abbreviations will be written as Sgroups when possible
	public molName = ''; // optional name to include in the header (if any)

	// some number of superatom abbreviation groups, each of which is a list of atom indices
	private sgroupNames:string[] = [];
	private sgroupAtoms:number[][] = [];

	// content in progress
	private lines:string[] = [];

	// ----------------- public methods -----------------

	constructor(public mol:Molecule)
	{
	}

	// write out the MDL content
	public write():string
	{
		if (this.includeHeader)
		{
			this.lines.push(this.molName);
			this.lines.push('Generated by WebMolKit');
			this.lines.push('');
			this.writeCTAB();
		}
		return this.lines.join('\n');
	}

	public getResult():string
	{
		return this.lines.join('\n');
	}

	// ----------------- private methods -----------------

	// writes the main block
   	private writeCTAB():void
   	{
		let mol = this.mol;

		/*for (let n = 1; n <= mol.numAtoms; n++) if (MolUtil.hasAbbrev(mol, n))
		{
			mol = mol.clone();
			MolUtil.expandAbbrevs(mol, true);
			break;
		}*/
		// if allowed to write Sgroups, some abbreviations may be retained for the subsequent steps
		if (MolUtil.hasAnyAbbrev(mol))
		{
			mol = this.mol = mol.clone();
			if (this.abbrevSgroups)
			{
				this.partialAbbrevExpansion();
				this.prepareSgroups();
			}
			else MolUtil.expandAbbrevs(mol, true);
		}

		this.lines.push(this.intrpad(mol.numAtoms, 3) + this.intrpad(mol.numBonds, 3) + '  0  0  0  0  0  0  0  0999 V2000');

		// data to record in the following M-block
		let chgidx:number[] = [], chgval:number[] = [];
		let radidx:number[] = [], radval:number[] = [];
		let isoidx:number[] = [], isoval:number[] = [];
		let rgpidx:number[] = [], rgpval:number[] = [];
		let hydidx:number[] = [], hydval:number[] = [];
		let zchidx:number[] = [], zchval:number[] = [];
		let zboidx:number[] = [], zboval:number[] = [];

		// export atoms, and make a few notes along the way
		for (let n = 1; n <= mol.numAtoms; n++)
		{
			let x = mol.atomX(n), y = mol.atomY(n), z = 0;
			let line = this.rpad(x.toFixed(4), 10) + this.rpad(y.toFixed(4), 10) + this.rpad(z.toFixed(4), 10);

			let el = mol.atomElement(n);
			let str = el;
			if (str.length > 3) str = str.substring(0, 3);
			if (str.length > 1 && str.charAt(0) == 'R' && str.charAt(1) >= '0' && str.charAt(1) <= '9')
			{
				rgpidx.push(n);
				rgpval.push(parseInt(str.substring(1)));
				str = 'R#';
			}
			while (str.length < 4) str += ' ';
			line += ' ' + str + '0';

			let chg = mol.atomCharge(n), rad = mol.atomUnpaired(n), mapnum = mol.atomMapNum(n);
			if (chg >= -3 && chg <= -1) chg = 4 - chg;
			else if (chg == 0 && rad == 2) chg = 4;
			else if (chg >= 1 && chg <= 3) chg = 4 - chg;
			else chg = 0;

			let val = this.mdlValence(mol, n, 15);

			line += this.intrpad(chg, 3) + '  0  0  0' + this.intrpad(val, 3) + '  0  0  0' + this.intrpad(mapnum, 3) + '  0  0';

			this.lines.push(line);

			if (mol.atomCharge(n) != 0) {chgidx.push(n); chgval.push(mol.atomCharge(n));}
			if (this.enhancedFields)
			{
				if (mol.atomHExplicit(n) != Molecule.HEXPLICIT_UNKNOWN) {hydidx.push(n); hydval.push(mol.atomHExplicit(n));}
		   	}

			if (mol.atomUnpaired(n) != 0) {radidx.push(n); radval.push(mol.atomUnpaired(n));}
			if (mol.atomIsotope(n) != Molecule.ISOTOPE_NATURAL) {isoidx.push(n); isoval.push(mol.atomIsotope(n));}
		}

		// export bonds
		for (let n = 1; n <= mol.numBonds; n++)
		{
			let order = mol.bondOrder(n), type = order;
			if (type == 0) type = 8; // the "any" type
			else if (type > 3) type = 3; // 4-or-higher bonds are not available

			let stereo = mol.bondType(n);
			if (stereo == Molecule.BONDTYPE_NORMAL) {}
			else if (stereo == Molecule.BONDTYPE_INCLINED)
			{
				stereo = 1;
				//type = 1; ... documentation says that wedges have to be single
			}
			else if (stereo == Molecule.BONDTYPE_DECLINED)
			{
				stereo = 6;
				//type = 1; ... documentation says that wedges have to be single
			}
			else if (stereo == Molecule.BONDTYPE_UNKNOWN)
			{
				if (type == 1) stereo = 4; else stereo = 3;
			}
			else stereo = 0;

			let line = this.intrpad(mol.bondFrom(n), 3) + this.intrpad(mol.bondTo(n), 3) +
					   this.intrpad(type, 3) + this.intrpad(stereo, 3) + '  0  0  0';
			this.lines.push(line);

			if (this.enhancedFields)
			{
				if ((order < 1 || order > 3) || type != order) {zboidx.push(n); zboval.push(order);}
				// these are for retroactive bond separation, not implemented at the moment
				//if (xmol.bondOrder(n) != mol.bondOrder(n)) {zboidx.push(n); zboval.push(xmol.bondOrder(n));}
			}
		}

		// export the additional blocks
		this.writeMBlockPair('CHG', chgidx, chgval);
		this.writeMBlockPair('RAD', radidx, radval);
		this.writeMBlockPair('ISO', isoidx, isoval);
		this.writeMBlockPair('RGP', rgpidx, rgpval);
		this.writeMBlockPair('HYD', hydidx, hydval);
		this.writeMBlockPair('ZCH', zchidx, zchval);
		this.writeMBlockPair('ZBO', zboidx, zboval);

		// write bond artifacts, one line each
		if (this.enhancedFields)
		{
			let artifacts = new BondArtifact(this.mol);
			let idx = 0;
			for (let path of artifacts.getResPaths()) this.writeMBlockFlat('ZPA', ++idx, path.atoms);
			for (let ring of artifacts.getResRings()) this.writeMBlockFlat('ZRI', ++idx, ring.atoms);
			for (let arene of artifacts.getArenes()) this.writeMBlockFlat('ZAR', ++idx, Vec.prepend(arene.atoms, arene.centre));
		}

		// encode Sgroups
		let inSgroup = Vec.booleanArray(false, mol.numAtoms);
		for (let s = 0; s < this.sgroupAtoms.length; s++)
		{
			let sgroup = this.sgroupAtoms[s];
			for (let n of sgroup) inSgroup[n - 1] = true;

			let sidx = this.intrpad(s + 1, 4);
			this.lines.push('M  STY  1' + sidx + ' SUP');
			for (let n = 0; n < sgroup.length; n += 15)
			{
				let sz = Math.min(sgroup.length - n, 15);
				let line = 'M  SAL' + sidx + this.intrpad(sz, 3);
				for (let i = 0; i < sz; i++) line += this.intrpad(sgroup[n + i], 4);
				this.lines.push(line);
			}
			this.lines.push('M  SMT' + sidx + ' ' + this.sgroupNames[s]);
		}

		// export long atom names
		for (let n = 1; n <= mol.numAtoms; n++) if (mol.atomElement(n).length > 2)
		{
			this.lines.push('A  ' + this.intrpad(n, 3));
			this.lines.push(mol.atomElement(n));
		}

		this.lines.push('M  END');
   	}

	// writes a specific sub-block, e.g. M__CHG, etc., where each pair of idx/val is a separate entity
	private writeMBlockPair(token:string, idx:number[], val:number[])
	{
		const sz = idx.length;
		for (let i = 0; i < sz; i += 8)
		{
			let count = Math.min(8, sz - i);
			let line = 'M  ' + token + this.intrpad(count, 3);
			for (let j = 0; j < count; j++) line += this.intrpad(idx[i + j], 4) + this.intrpad(val[i + j], 4);
			this.lines.push(line);
		}
	}

	// writes a specific sub-block, whereby the master index corresponds to some number of values; these are split over multiple
	// lines if necessary
	private writeMBlockFlat(token:string, idx:number, val:number[])
	{
		const sz = val.length;
		for (let i = 0; i < sz; i += 15)
		{
			let count = Math.min(15, sz - i);
			let line = 'M  ' + token + this.intrpad(count, 3);
			line += this.intrpad(idx, 4);
			for (let j = 0; j < count; j++) line += this.intrpad(val[i + j], 4);
			this.lines.push(line);
		}
	}

	// convenient formatting
	private intrpad(num:number, sz:number):string
	{
		return this.rpad(num.toString(), sz);
	}
	private rpad(str:string, sz:number):string
	{
		while (str.length < sz) str = ' ' + str;
		return str;
	}

	// figures out the MDL valence override, if any; a return value of 0 means that the calculated default will suffice; if the value
	// needs to be explicitly zero, the 'zeroVal' parameter is returned (should be 15 for V2000, -1 for V3000)
	private mdlValence(mol:Molecule, atom:number, zeroVal:number):number
	{
		let hyd = mol.atomHydrogens(atom), el = mol.atomElement(atom);
		let options = MDLMOL_VALENCE[el];

		// if no implicit valence, and no hydrogens: no need
		if (options == null && hyd == 0) return 0;

		let chg = mol.atomCharge(atom);
		let chgmod = (el == 'C' || el == 'H') ? Math.abs(chg) : el == 'B' ? -Math.abs(chg) : -chg;
		let bondSum = 0;
		for (let b of mol.atomAdjBonds(atom)) bondSum += mol.bondOrder(b);
		let nativeVal = chgmod + mol.atomUnpaired(atom) + hyd + bondSum;

		// if there are valence options and this is the first one, it should work out
		if (options && options[0] == nativeVal) return 0;

		// NOTE: in cases with multiple valence options, like S[2,4,6], it would be possible to leave the valence unmarked
		// when the previous state is indicated, e.g. for S{val=3} ==> +1 H to get to val=4; or we could just mark the
		// valence, since the first one is always overwhelmingly the default

		let val = nativeVal - chgmod;
		return val <= 0 || val > 14 ? zeroVal : val;
	}

	// processes the structure so that any non-trivial abbreviations (multiple attachment points/different bond orders) are expanded, and also makes
	// sure that any remaining abbreviations have no nesting within them
	private partialAbbrevExpansion():void
	{
		const {mol} = this;
		for (let n = 1; n <= mol.numAtoms; n++) if (MolUtil.hasAbbrev(mol, n))
		{
			let frag = MolUtil.getAbbrev(mol, n);
			if (frag == null || mol.atomAdjCount(n) != 1) {MolUtil.clearAbbrev(mol, n); continue;}

			if (MolUtil.hasAnyAbbrev(frag))
			{
				MolUtil.expandAbbrevs(frag, true);
				MolUtil.setAbbrev(mol, n, frag);
			}

			let order = mol.bondOrder(mol.atomAdjBonds(n)[0]);
			if (frag.atomAdjCount(1) == 1 && order == frag.bondOrder(frag.atomAdjBonds(1)[0])) continue;

			MolUtil.expandOneAbbrev(mol, n, true);
			n--;
		}
	}

	// any remaining abbreviations within the molecule get turned into S-groups
	private prepareSgroups():void
	{
		const {mol} = this;

		// note: using -ve atom mapping numbers to disambiguate
		for (let n = 1; n <= mol.numAtoms; n++) if (mol.atomMapNum(n) < 0) mol.setAtomMapNum(n, 0);
		let next = 0;

		for (let n = 1; n <= mol.numAtoms; n++) if (MolUtil.hasAbbrev(mol, n))
		{
			this.sgroupNames.push(mol.atomElement(n));
			let mask = MolUtil.expandOneAbbrev(mol, n, true);
			if (mask == null) continue;
			next--;
			for (let i = 0; i < mask.length; i++) if (mask[i]) mol.setAtomMapNum(i + 1, next);

			n--;
		}

		// extract the layers one at a time
		for (let idx = -1; idx >= next; idx--)
		{
			let atoms:number[] = [];
			for (let n = 1; n <= mol.numAtoms; n++) if (mol.atomMapNum(n) == idx)
			{
				atoms.push(n);
				mol.setAtomMapNum(n, 0);
			}
			this.sgroupAtoms.push(atoms);
		}
	}
}

export class MDLSDFWriter
{
	// options
	public enhancedFields = true; // if on, non-standard MDL fields may be added
	public chargeSeparate = false; // if on, zero bonds will be split out
	public abbrevSgroups = true; // if on, abbreviations will be written as Sgroups when possible

	// content in progress
	private lines:string[] = [];

	// ----------------- public methods -----------------

	constructor(public ds:DataSheet)
	{
	}

	// write out the MDL content
	public write():string
	{
		let ds = this.ds, lines = this.lines;
		let colMol = this.ds.firstColOfType(DataSheetColumn.Molecule);

		for (let i = 0; i < ds.numRows; i++)
		{
			let mol = colMol < 0 ? null : ds.getMolecule(i, colMol);
			if (mol != null /*MolUtil.notBlank(mol)*/)
			{
				let wtr = new MDLMOLWriter(mol);
				wtr.enhancedFields = this.enhancedFields;
				wtr.chargeSeparate = this.chargeSeparate;
				wtr.abbrevSgroups = this.abbrevSgroups;
				let molstr = wtr.write();
				lines.push(molstr);
			}

			for (let j = 0; j < ds.numCols; j++) if (j != colMol && ds.notNull(i, j))
			{
				let ct = ds.colType(j);
				let val = '';
				if (ct == DataSheetColumn.String) val = ds.getString(i, j);
				else if (ct == DataSheetColumn.Integer) val = ds.getInteger(i, j).toString();
				else if (ct == DataSheetColumn.Real) val = ds.getReal(i, j).toString();
				else if (ct == DataSheetColumn.Boolean) val = ds.getBoolean(i, j) ? 'true' : 'false';

				if (val != '')
				{
					lines.push('> <' + ds.colName(j) + '>');
					lines.push(val);
					lines.push('');
				}
			}

			lines.push('$$$$');
		}

		// !!
		return lines.join('\n');
	}

	public getResult():string
	{
		return this.lines.join('\n');
	}

	// ----------------- private methods -----------------
}

/* EOF */ }