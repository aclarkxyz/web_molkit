/*
	WebMolKit

	(c) 2010-2022 Molecular Materials Informatics, Inc.

	All rights reserved

	http://molmatinf.com

	[PKG=webmolkit]
*/

namespace WebMolKit /* BOF */ {

/*
	MDL Molfile writer: convert the native structure format to MDL Molfile. Both the older (V2000) and newer (V3000) formats are
	supported. The older V2000 format is recommended as the default, since every toolkit ever created supports a common subset of
	its feature set. While the newer V3000 format is well supported, it is not as ubiquitous, and its feature improvements are not
	used by most molecules.

	MDL SDfile writer: including non-molecule fields in collections. The SDfile format is problematic for as many reasons as the
	molecules; the best strategy is to avoid using it whenever possible, but it is so often not.
*/

interface Sgroup
{
	type:string;
	name:string;
	atoms:number[];

	// DAT only
	value?:string;
	unit?:string;
	query?:string;

	// MUL only
	parent?:number;

	// for SCSR templates
	bonds?:number[];
	templateClass?:string;
	natReplace?:string;
	attachPoints?:string[];
}

const VPFX = 'M  V30 ';

export class MDLMOLWriter
{
	// options
	public includeHeader = true; // if on, the 3 line header will be included
	public includeCounts = true; // if on, the subsequent 1 line of counts will be included (V3000 only, ignored in V2000 mode)
	public includeEnd = true; // if on, the final M__END will be included
	public overallStereoAbsolute = true; // from the counts block, overall true=interpret stereo as absolute; false=interpret as relative
	public enhancedFields = true; // if on, non-standard MDL fields may be added
	public chargeSeparate = false; // if on, zero bonds will be split out
	public abbrevSgroups = true; // if on, abbreviations will be written as Sgroups when possible
	public polymerBlocks = true; // write polymer blocks, if any
	public molName = ''; // optional name to include in the header (if any)

	// provide these template definitions if they need to be written out with the molecule
	public scsrTemplates:ForeignMoleculeTemplateDefn[] = null;

	// some number of superatom abbreviation groups, there being several types
	private sgroups:Sgroup[] = [];

	// content in progress
	private lines:string[] = [];

	// ----------------- public methods -----------------

	constructor(public mol:Molecule)
	{
	}

	// write out the MDL content (using V2000 format)
	public write():string
	{
		if (this.includeHeader)
		{
			this.lines.push(this.molName);
			this.lines.push('Generated by WebMolKit');
			this.lines.push('');
			this.writeCTAB();
		}
		return this.lines.join('\n');
	}

	// writes the content using the newer V3000 format
	public writeV3000():string
	{
		if (this.includeHeader)
		{
			this.lines.push(this.molName);
			this.lines.push('Generated by WebMolKit');
			this.lines.push('');
			this.writeCTAB3000();
		}
		return this.lines.join('\n');
	}

	// writes out V3000 if there is metadata that cannot be represented in the older format, V2000 otherwise
	public writeEither():string
	{
		let triggered = StereoGroup.hasStereoGroups(this.mol) || this.mol.numAtoms >= 1000 || this.mol.numBonds >= 1000 || Vec.notBlank(this.scsrTemplates);
		if (!triggered) for (let n = 1; n <= this.mol.numBonds; n++)
			if (this.mol.bondOrder(n) == 0 && QueryUtil.queryBondOrders(this.mol, n) == null) {triggered = true; break;}
		if (triggered) return this.writeV3000(); else return this.write();
	}

	public getResult():string
	{
		return this.lines.join('\n');
	}

	// ----------------- private methods -----------------

	// writes the main block
   	private writeCTAB():void
   	{
		let mol = this.mol = this.mol.clone();
		mol.keepTransient = true;

		// if allowed to write Sgroups, some abbreviations may be retained for the subsequent steps
		if (MolUtil.hasAnyAbbrev(mol) || ForeignMolecule.hasAnySgroupMultiAttach(mol) || ForeignMolecule.hasAnySgroupMultiRepeat(mol) || ForeignMolecule.hasAnySgroupData(mol))
		{
			if (this.abbrevSgroups)
				this.partialAbbrevExpansion();
			else
				MolUtil.expandAbbrevs(mol, true);
			this.prepareSgroups();
		}

		// pre-encode atom lists
		let atomList1:string[] = [], atomList2:string[] = [];
		for (let n = 1; n <= mol.numAtoms; n++)
		{
			let elements:string[] = null;
			let logic = 'F';
			elements = QueryUtil.queryAtomElements(mol, n);
			if (elements == null) {elements = QueryUtil.queryAtomElementsNot(mol, n); logic = 'T';}
			if (elements == null) continue;

			mol.setAtomElement(n, 'L');

			let line = this.intrpad(n, 3) + ' ' + logic + '  ' + this.intrpad(elements.length, 3);
			for (let el of elements) line += this.intrpad(Molecule.elementAtomicNumber(el), 4);
			atomList1.push(line);

			line = 'M  ALS ' + this.intrpad(n, 3) + this.intrpad(elements.length, 3) + ' ' + logic + ' ';
			for (let el of elements) line += this.pad(el, 4);
			atomList2.push(line);
		}

		this.lines.push(this.intrpad(mol.numAtoms, 3) + this.intrpad(mol.numBonds, 3) + this.intrpad(atomList1.length, 3) +
						'  0' + (this.overallStereoAbsolute ? '  1' : '  0') + '  0  0  0  0  0999 V2000');

		// data to record in the following M-block
		let chgidx:number[] = [], chgval:number[] = [];
		let radidx:number[] = [], radval:number[] = [];
		let isoidx:number[] = [], isoval:number[] = [];
		let rgpidx:number[] = [], rgpval:number[] = [];
		let hydidx:number[] = [], hydval:number[] = [];
		let zchidx:number[] = [], zchval:number[] = [];
		let zboidx:number[] = [], zboval:number[] = [];
		let rbcidx:number[] = [], rbcval:number[] = [];
		let subidx:number[] = [], subval:number[] = [];
		let unsidx:number[] = [], unsval:number[] = [];

		// export atoms, and make a few notes along the way
		for (let n = 1; n <= mol.numAtoms; n++)
		{
			let x = mol.atomX(n), y = mol.atomY(n);
			let z = mol.is3D() ? mol.atomZ(n) : 0;
			let line = this.rpad(x.toFixed(4), 10) + this.rpad(y.toFixed(4), 10) + this.rpad(z.toFixed(4), 10);

			let el = mol.atomElement(n);
			let str = el;
			if (str.length > 3) str = str.substring(0, 3);
			if (str.length > 1 && str.charAt(0) == 'R' && str.charAt(1) >= '0' && str.charAt(1) <= '9')
			{
				rgpidx.push(n);
				rgpval.push(parseInt(str.substring(1)));
				str = 'R#';
			}
			while (str.length < 4) str += ' ';
			line += ' ' + str + '0';

			let chg = mol.atomCharge(n), rad = mol.atomUnpaired(n), mapnum = mol.atomMapNum(n);
			if (chg >= -3 && chg <= -1) chg = 4 - chg;
			else if (chg == 0 && rad == 2) chg = 4;
			else if (chg >= 1 && chg <= 3) chg = 4 - chg;
			else chg = 0;

			let qhyd = QueryUtil.queryAtomHydrogens(mol, n);
			let hyd = 0;
			if (Vec.len(qhyd) == 1) hyd = qhyd[0] + 1;

			let val = this.mdlValence(mol, n, 15);

			line += this.intrpad(chg, 3) + '  0' + this.intrpad(hyd, 3) + '  0' + this.intrpad(val, 3) + '  0  0  0' + this.intrpad(mapnum, 3) + '  0  0';

			this.lines.push(line);

			if (mol.atomCharge(n) != 0) {chgidx.push(n); chgval.push(mol.atomCharge(n));}
			if (this.enhancedFields)
			{
				if (mol.atomHExplicit(n) != Molecule.HEXPLICIT_UNKNOWN) {hydidx.push(n); hydval.push(mol.atomHExplicit(n));}
		   	}

			if (rad == 1) {radidx.push(n); radval.push(2);}
			if (rad == 2) {radidx.push(n); radval.push(1);}
			if (mol.atomIsotope(n) != Molecule.ISOTOPE_NATURAL) {isoidx.push(n); isoval.push(mol.atomIsotope(n));}

			let qrbc = QueryUtil.queryAtomRingBonds(mol, n), qsub = QueryUtil.queryAtomAdjacency(mol, n);
			let quns = QueryUtil.queryAtomUnsaturated(mol, n);
			if (Vec.len(qrbc) == 1) {rbcidx.push(n); rbcval.push(qrbc[0] == 0 ? -1 : qrbc[0]);}
			if (Vec.len(qsub) == 1) {subidx.push(n); subval.push(qsub[0] == 0 ? -1 : qsub[0]);}
			if (quns == true) {unsidx.push(n); unsval.push(1);}
		}

		// export bonds
		let maskArom = ForeignMolecule.noteAromaticBonds(mol);
		for (let n = 1; n <= mol.numBonds; n++)
		{
			let order = mol.bondOrder(n), type = order;
			let qbond = Vec.sorted(QueryUtil.queryBondOrders(mol, n) ?? []);
			if (maskArom[n - 1] || Vec.equals(qbond, [-1])) type = 4; // the "aromatic" type
			else if (Vec.equals(qbond, [1, 2])) type = 5; // the "single or double" type
			else if (Vec.equals(qbond, [-1, 1])) type = 6; // the "single or aromatic" type
			else if (Vec.equals(qbond, [-1, 2])) type = 7; // the "double or aromatic" type
			else if (Vec.equals(qbond, [-1, 0, 1, 2, 3])) type = 8; // the "any" type
			else if (type > 3) type = 3; // 4-or-higher bonds are not available

			let stereo = mol.bondType(n);
			if (stereo == Molecule.BONDTYPE_NORMAL) {}
			else if (stereo == Molecule.BONDTYPE_INCLINED)
			{
				stereo = 1;
				//type = 1; ... documentation says that wedges have to be single
			}
			else if (stereo == Molecule.BONDTYPE_DECLINED)
			{
				stereo = 6;
				//type = 1; ... documentation says that wedges have to be single
			}
			else if (stereo == Molecule.BONDTYPE_UNKNOWN)
			{
				if (type == 1) stereo = 4; else stereo = 3;
			}
			else stereo = 0;

			let line = this.intrpad(mol.bondFrom(n), 3) + this.intrpad(mol.bondTo(n), 3) +
					   this.intrpad(type, 3) + this.intrpad(stereo, 3) + '  0  0  0';
			this.lines.push(line);

			if (this.enhancedFields)
			{
				if ((order < 1 || order > 3) || type != order && Vec.isBlank(qbond)) {zboidx.push(n); zboval.push(order);}
				// these are for retroactive bond separation, not implemented at the moment
				//if (xmol.bondOrder(n) != mol.bondOrder(n)) {zboidx.push(n); zboval.push(xmol.bondOrder(n));}
			}
		}

		this.lines.push(...atomList1);
		this.lines.push(...atomList2);

		// export the additional blocks
		this.writeMBlockPair('CHG', chgidx, chgval);
		this.writeMBlockPair('RAD', radidx, radval);
		this.writeMBlockPair('ISO', isoidx, isoval);
		this.writeMBlockPair('RGP', rgpidx, rgpval);
		this.writeMBlockPair('HYD', hydidx, hydval);
		this.writeMBlockPair('ZCH', zchidx, zchval);
		this.writeMBlockPair('ZBO', zboidx, zboval);
		this.writeMBlockPair('RBC', rbcidx, rbcval);
		this.writeMBlockPair('SUB', subidx, subval);
		this.writeMBlockPair('UNS', unsidx, unsval);

		// write bond artifacts, one line each
		if (this.enhancedFields)
		{
			let artifacts = new BondArtifact(this.mol);
			let idx = 0;
			for (let path of artifacts.getResPaths()) this.writeMBlockFlat('ZPA', ++idx, path.atoms);
			for (let ring of artifacts.getResRings()) this.writeMBlockFlat('ZRI', ++idx, ring.atoms);
			for (let arene of artifacts.getArenes()) this.writeMBlockFlat('ZAR', ++idx, Vec.prepend(arene.atoms, arene.centre));
		}

		// encode Sgroups
		let inSgroup = Vec.booleanArray(false, mol.numAtoms);
		for (let s = 0; s < this.sgroups.length; s++)
		{
			let sg = this.sgroups[s];
			for (let n of sg.atoms) inSgroup[n - 1] = true;

			let sidx = this.intrpad(s + 1, 4);
			this.lines.push('M  STY  1' + sidx + ' ' + sg.type);
			for (let n = 0; n < sg.atoms.length; n += 15)
			{
				let sz = Math.min(sg.atoms.length - n, 15);
				let line = 'M  SAL' + sidx + this.intrpad(sz, 3);
				for (let i = 0; i < sz; i++) line += this.intrpad(sg.atoms[n + i], 4);
				this.lines.push(line);
			}
			if (sg.type != 'DAT') this.lines.push('M  SMT' + sidx + ' ' + sg.name);
			if (sg.type == 'MUL')
			{
				let mult = parseInt(sg.name), unit = sg.atoms.length / mult;
				for (let n = 0; n < unit; n += 15)
				{
					let sz = Math.min(unit - n, 15);
					let line = 'M  SPA' + sidx + this.intrpad(sz, 3);
					for (let i = 0; i < sz; i++) line += this.intrpad(sg.atoms[n + i], 4);
					this.lines.push(line);
				}
				if (sg.parent > 0) this.lines.push('M  SPL    1' + sidx + this.intrpad(sg.parent, 4));
			}
			if (sg.type == 'DAT')
			{
				this.lines.push('M  SDT' + sidx + ' ' + this.pad(sg.name, 32) + this.pad(sg.unit, 20) + sg.query);
				this.lines.push('M  SED' + sidx + ' ' + sg.value);
			}
		}

		if (this.polymerBlocks) this.encodePolymerBlocks(this.sgroups.length);

		// export long atom names
		for (let n = 1; n <= mol.numAtoms; n++) if (mol.atomElement(n).length > 2)
		{
			this.lines.push('A  ' + this.intrpad(n, 3));
			this.lines.push(mol.atomElement(n));
		}

		if (!this.includeEnd) this.lines.push('M  END');
   	}

	// writes a specific sub-block, e.g. M__CHG, etc., where each pair of idx/val is a separate entity
	private writeMBlockPair(token:string, idx:number[], val:number[])
	{
		const sz = idx.length;
		for (let i = 0; i < sz; i += 8)
		{
			let count = Math.min(8, sz - i);
			let line = 'M  ' + token + this.intrpad(count, 3);
			for (let j = 0; j < count; j++) line += this.intrpad(idx[i + j], 4) + this.intrpad(val[i + j], 4);
			this.lines.push(line);
		}
	}

	// writes a specific sub-block, whereby the master index corresponds to some number of values; these are split over multiple
	// lines if necessary
	private writeMBlockFlat(token:string, idx:number, val:number[])
	{
		const sz = val.length;
		for (let i = 0; i < sz; i += 15)
		{
			let count = Math.min(15, sz - i);
			let line = 'M  ' + token + this.intrpad(count, 3) + this.intrpad(idx, 4);
			for (let j = 0; j < count; j++) line += this.intrpad(val[i + j], 4);
			this.lines.push(line);
		}
	}
	private writeMBlockFlatIdxFirst(token:string, idx:number, val:number[])
	{
		const sz = val.length;
		for (let i = 0; i < sz; i += 15)
		{
			let count = Math.min(15, sz - i);
			let line = 'M  ' + token + this.intrpad(idx, 4) + this.intrpad(count, 3);
			for (let j = 0; j < count; j++) line += this.intrpad(val[i + j], 4);
			this.lines.push(line);
		}
	}

	// convenient formatting
	private intrpad(num:number, sz:number):string
	{
		return this.rpad(num.toString(), sz);
	}
	private rpad(str:string, sz:number):string
	{
		while (str.length < sz) str = ' ' + str;
		return str;
	}
	private pad(str:string, sz:number):string
	{
		while (str.length < sz) str += ' ';
		return str;
	}

	// figures out the MDL valence override, if any; a return value of 0 means that the calculated default will suffice; if the value
	// needs to be explicitly zero, the 'zeroVal' parameter is returned (should be 15 for V2000, -1 for V3000)
	private mdlValence(mol:Molecule, atom:number, zeroVal:number):number
	{
		let marked = ForeignMolecule.noteExplicitValence(mol, atom);
		if (marked != null) return marked > 0 ? marked : zeroVal;

		let hyd = mol.atomHydrogens(atom), el = mol.atomElement(atom);
		let options = MDLMOL_VALENCE[el];

		// if no implicit valence, and no hydrogens: no need
		if (options == null && hyd == 0) return 0;

		let chg = mol.atomCharge(atom);
		let chgmod = (el == 'C' || el == 'H') ? Math.abs(chg) : el == 'B' ? -Math.abs(chg) : -chg;
		let bondSum = 0;
		for (let b of mol.atomAdjBonds(atom)) bondSum += mol.bondOrder(b);
		let nativeVal = chgmod + /*mol.atomUnpaired(atom) +*/ hyd + bondSum;

		// if this is consistent with an existing valence option, no need
		if (options?.includes(nativeVal)) return 0;

		// NOTE: in cases with multiple valence options, like S[2,4,6], it would be possible to leave the valence unmarked
		// when the previous state is indicated, e.g. for S{val=3} ==> +1 H to get to val=4; or we could just mark the
		// valence, since the first one is always overwhelmingly the default

		let val = nativeVal - chgmod;
		return val <= 0 || val > 14 ? zeroVal : val;
	}

	// processes the structure so that any non-trivial abbreviations (multiple attachment points/different bond orders) are expanded, and also makes
	// sure that any remaining abbreviations have no nesting within them
	private partialAbbrevExpansion():void
	{
		const {mol} = this;
		for (let n = 1; n <= mol.numAtoms; n++) if (MolUtil.hasAbbrev(mol, n))
		{
			let frag = MolUtil.getAbbrev(mol, n);
			if (frag == null || mol.atomAdjCount(n) != 1) {MolUtil.clearAbbrev(mol, n); continue;}

			if (MolUtil.hasAnyAbbrev(frag))
			{
				MolUtil.expandAbbrevs(frag, true);
				MolUtil.setAbbrev(mol, n, frag);
			}

			let order = mol.bondOrder(mol.atomAdjBonds(n)[0]);
			if (frag.atomAdjCount(1) == 1 && order == frag.bondOrder(frag.atomAdjBonds(1)[0])) continue;

			MolUtil.expandOneAbbrev(mol, n, true);
			n--;
		}
	}

	// any remaining abbreviations within the molecule get turned into S-groups
	private prepareSgroups():void
	{
		const {mol} = this;

		// note: using -ve atom mapping numbers to disambiguate
		for (let n = 1; n <= mol.numAtoms; n++) if (mol.atomMapNum(n) < 0) mol.setAtomMapNum(n, 0);
		let next = 0;

		for (let n = 1; n <= mol.numAtoms; n++) if (MolUtil.hasAbbrev(mol, n))
		{
			this.sgroups.push({type: 'SUP', name: mol.atomElement(n), atoms: null});
			let mask = MolUtil.expandOneAbbrev(mol, n, true);
			if (mask == null) continue;
			next--;
			for (let i = 0; i < mask.length; i++) if (mask[i]) mol.setAtomMapNum(i + 1, next);

			n--;
		}

		// extract the layers one at a time
		for (let idx = -1, p = 0; idx >= next; idx--, p++)
		{
			let atoms:number[] = [];
			for (let n = 1; n <= mol.numAtoms; n++) if (mol.atomMapNum(n) == idx)
			{
				atoms.push(n);
				mol.setAtomMapNum(n, 0);
			}
			this.sgroups[p].atoms = atoms;
		}

		// also encode foreign-annotated Sgroups
		for (let ma of ForeignMolecule.noteAllSgroupMultiAttach(mol)) 
		{
			let sg:Sgroup = {type: 'SUP', name: ma.name, atoms: ma.atoms};

			let str = ma.keyval['bonds'];
			if (str) sg.bonds = str.split(' ').map((v) => parseInt(v));

			sg.templateClass = ma.keyval['templateClass'] ;
			sg.natReplace = ma.keyval['natReplace'];

			str = ma.keyval['attachPoints'];
			if (str) sg.attachPoints = str.split(' ');

			this.sgroups.push(sg);
		}
		for (let mr of ForeignMolecule.noteAllSgroupMultiRepeat(mol)) this.sgroups.push({type: 'MUL', name: mr.mult.toString(), atoms: mr.atoms});
		for (let dat of ForeignMolecule.noteAllSgroupData(mol)) this.sgroups.push({type: 'DAT', name: dat.name, value: dat.value, unit: dat.unit, query: dat.query, atoms: dat.atoms});

		// whenever a MUL group is subsumed by another, need to name that as the parent
		for (let n = 0; n < this.sgroups.length; n++)
		{
			let sg = this.sgroups[n];
			if (sg.type != 'MUL') continue;
			let bestIdx = -1, bestSize = Number.MAX_SAFE_INTEGER;
			skip: for (let i = 0; i < this.sgroups.length; i++) if (i != n)
			{
				let look = this.sgroups[i];
				if (look.type != 'MUL' || look.atoms.length >= bestSize) continue;
				for (let a of sg.atoms) if (!look.atoms.includes(a)) continue skip;
				bestIdx = i;
				bestSize = look.atoms.length;
			}
			if (bestIdx >= 0) sg.parent = bestIdx + 1;
		}
	}

	// use a variant of Sgroups for any polymer blocks
	private encodePolymerBlocks(idx:number):void
	{
		let polymers = new PolymerBlock(this.mol);
		for (let id of polymers.getIDList())
		{
			let unit = polymers.getUnit(id);
			let sidx = this.intrpad(++idx, 4);
			this.lines.push('M  STY  1' + sidx + ' SRU');

			if (unit.connect == PolymerBlockConnectivity.HeadToTail) this.lines.push('M  SCN  1' + sidx + ' HT ');
			else if (unit.connect == PolymerBlockConnectivity.HeadToHead) this.lines.push('M  SCN  1' + sidx + ' HH ');
			else if (unit.connect == PolymerBlockConnectivity.Random) this.lines.push('M  SCN  1' + sidx + ' EU ');

			this.writeMBlockFlatIdxFirst('SAL', idx, unit.atoms);

			let bonds:number[] = null;
			for (let n = 1; n <= this.mol.numBonds; n++)
			{
				let fl1 = unit.atoms.indexOf(this.mol.bondFrom(n)) >= 0, fl2 = unit.atoms.indexOf(this.mol.bondTo(n)) >= 0;
				if ((fl1 && !fl2) || (!fl1 && fl2)) bonds = Vec.append(bonds, n);
			}
			if (bonds != null) this.writeMBlockFlatIdxFirst('SBL', idx, bonds);

			if (Vec.len(unit.bondConn) == 4)
			{
				let bcrs = [unit.bondConn[0], unit.bondConn[2], unit.bondConn[1]];
				this.writeMBlockFlatIdxFirst('CRS', idx, bcrs);
			}

			this.lines.push('M  SMT' + sidx + ' n');
		}
	}

	public writeCTAB3000():void
	{
		let mol = this.mol;

		// if allowed to write Sgroups, some abbreviations may be retained for the subsequent steps
		if (MolUtil.hasAnyAbbrev(mol) || ForeignMolecule.hasAnySgroupMultiAttach(mol) || ForeignMolecule.hasAnySgroupMultiRepeat(mol) || ForeignMolecule.hasAnySgroupData(mol))
		{
			mol = this.mol = mol.clone();
			mol.keepTransient = true;
			if (this.abbrevSgroups)
				this.partialAbbrevExpansion();
			else
				MolUtil.expandAbbrevs(mol, true);
			this.prepareSgroups();
		}

		let sgroupText = this.populateV3000Sgroups();

		if (this.includeCounts) this.lines.push('  0  0  0     0  0            999 V3000');
		this.lines.push(VPFX + 'BEGIN CTAB');

		this.lines.push(VPFX + `COUNTS ${mol.numAtoms} ${mol.numBonds} ${sgroupText.length} 0 ${this.overallStereoAbsolute ? 1 : 0}`);

		this.lines.push(VPFX + 'BEGIN ATOM');

		for (let n = 1; n <= mol.numAtoms; n++)
		{
			let label = mol.atomElement(n);

			let qel = QueryUtil.queryAtomElements(mol, n);
			if (qel != null) label = '[' + qel.join(',') + ']';
			else
			{
				qel = QueryUtil.queryAtomElementsNot(mol, n);
				if (qel != null) label = 'NOT [' + qel.join(',') + ']';
			}

			if (label.includes(' ')) label = `"${label}"`;
			let x = mol.atomX(n), y = mol.atomY(n);
			let z = mol.is3D() ? mol.atomZ(n) : 0;
			let mapnum = mol.atomMapNum(n), chg = mol.atomCharge(n), unp = mol.atomUnpaired(n);
			let isotope = mol.atomIsotope(n), val = this.mdlValence(mol, n, -1);

			let line = `${VPFX}${n} ${label} ${x.toFixed(4)} ${y.toFixed(4)} ${z.toFixed(4)} ${mapnum}`;

			if (chg != 0) line += ' CHG=' + chg;
			if (unp == 1) line += ' RAD=2';
			else if (unp == 2) line += ' RAD=1';
			if (isotope != 0) line += ' MASS=' + isotope;
			if (val != 0) line += ' VAL=' + val;

			let qhyd = QueryUtil.queryAtomHydrogens(mol, n), qrbc = QueryUtil.queryAtomRingBonds(mol, n), qsub = QueryUtil.queryAtomAdjacency(mol, n);
			let quns = QueryUtil.queryAtomUnsaturated(mol, n);
			if (Vec.len(qhyd) == 1) line += ' HCOUNT=' + (qhyd[0] == 0 ? -1 : qhyd[0]);
			if (Vec.len(qrbc) == 1) line += ' RBCNT=' + (qrbc[0] == 0 ? -1 : qrbc[0]);
			if (Vec.len(qsub) == 1) line += ' SUBST=' + (qsub[0] == 0 ? -1 : qsub[0]);
			if (quns == true) line += ' UNSAT=1';

			for (let trans of mol.atomTransient(n))
			{
				if (trans.startsWith(ForeignMoleculeTransient.AtomSCSRClass)) line += ' CLASS=' + trans.substring(ForeignMoleculeTransient.AtomSCSRClass.length + 1);
				else if (trans.startsWith(ForeignMoleculeTransient.AtomSCSRSeqID)) line += ' SEQID=' + trans.substring(ForeignMoleculeTransient.AtomSCSRSeqID.length + 1);
				else if (trans.startsWith(ForeignMoleculeTransient.AtomSCSRAttchOrd)) 
				{
					let bits = trans.substring(ForeignMoleculeTransient.AtomSCSRAttchOrd.length + 1).split(',');
					line += ' ATTCHORD=' + this.packV3000Strings(bits);
				}
			}


			this.lines.push(line);
		}

		this.lines.push(VPFX + 'END ATOM');

		if (mol.numBonds > 0)
		{
			this.lines.push(VPFX + 'BEGIN BOND');

			let maskArom = ForeignMolecule.noteAromaticBonds(mol);
			for (let n = 1; n <= mol.numBonds; n++)
			{
				let bfr = mol.bondFrom(n), bto = mol.bondTo(n);
				let order = mol.bondOrder(n), type = order;
				let qbond = Vec.sorted(QueryUtil.queryBondOrders(mol, n) ?? []);
				if (maskArom[n - 1] || Vec.equals(qbond, [-1])) type = 4; // the "aromatic" type
				else if (Vec.equals(qbond, [1, 2])) type = 5; // the "single or double" type
				else if (Vec.equals(qbond, [-1, 1])) type = 6; // the "single or aromatic" type
				else if (Vec.equals(qbond, [-1, 2])) type = 7; // the "double or aromatic" type
				else if (Vec.equals(qbond, [-1, 0, 1, 2, 3])) type = 8; // the "double or aromatic" type
				else if (type == 0) type = 9; // the "coordination" type (zero bonds may get stripped out earlier)
				else if (type > 3) type = 3; // 4-or-higher bonds are not available

				let stereo = mol.bondType(n);

				let line = `${VPFX}${n} ${type} ${bfr} ${bto}`;

				if (stereo == Molecule.BONDTYPE_INCLINED) line += ' CFG=1';
				else if (stereo == Molecule.BONDTYPE_DECLINED) line += ' CFG=3';
				else if (stereo == Molecule.BONDTYPE_UNKNOWN) line += ' CFG=2';

				if (order == 0) line += ' DISP=COORD';

				this.lines.push(line);
			}

			this.lines.push(VPFX + 'END BOND');
		}

		if (sgroupText.length > 0)
		{
			this.lines.push(VPFX + 'BEGIN SGROUP');
			this.lines.push(...sgroupText);
			this.lines.push(VPFX + 'END SGROUP');
		}

		let collections:string[] = [];

		let stereoGroup = new StereoGroup(mol);
		let racidx = 0, relidx = 0;
		for (let atoms of stereoGroup.getRacemicAtoms()) collections.push(VPFX + 'MDLV30/STERAC' + (++racidx) + ' ATOMS=' + this.packV3000List(atoms));
		for (let atoms of stereoGroup.getRelativeAtoms()) collections.push(VPFX + 'MDLV30/STEREL' + (++relidx) + ' ATOMS=' + this.packV3000List(atoms));

		if (collections.length > 0)
		{
			this.lines.push(VPFX + 'BEGIN COLLECTION');
			this.lines.push(...collections);
			this.lines.push(VPFX + 'END COLLECTION');
		}

		this.lines.push(VPFX + 'END CTAB');

		if (Vec.notBlank(this.scsrTemplates)) this.populateSCSRTemplates();

		if (!this.includeEnd) this.lines.push('M  END');
	}

	private populateV3000Sgroups():string[]
	{
		let mol = this.mol;
		let lines:string[] = [];

		for (let s = 0; s < this.sgroups.length; s++)
		{
			let sg = this.sgroups[s];
			let sid = lines.length + 1;

			let txt = `${VPFX}${sid} ${sg.type} 0`;
			if (sg.type == 'SUP')
			{
				txt += ' LABEL=' + (sg.name.includes(' ') ? `"${sg.name}"` : sg.name);
				txt += ' ATOMS=' + this.packV3000List(sg.atoms);
			}
			else if (sg.type == 'MUL')
			{
				let mult = parseInt(sg.name), unit = sg.atoms.length / mult;
				txt += ' MULT=' + sg.name;
				txt += ' ATOMS=' + this.packV3000List(sg.atoms);
				txt += ' PATOMS=' + this.packV3000List(sg.atoms.slice(0, unit));
				if (sg.parent > 0) txt += ' PARENT=' + sg.parent;
			}
			else if (sg.type == 'DAT')
			{
				txt += ' ATOMS=' + this.packV3000List(sg.atoms);
				txt += ' FIELDNAME=' + (sg.name.includes(' ') ? `"${sg.name}"` : sg.name);
				txt += ' FIELDDATA=' + (sg.value.includes(' ') ? `"${sg.value}"` : sg.value);
			}
			lines.push(txt);
		}

		if (this.polymerBlocks)
		{
			let polymers = new PolymerBlock(mol);
			for (let id of polymers.getIDList())
			{
				let sid = lines.length + 1;
				let unit = polymers.getUnit(id);

				let txt = `${VPFX}${sid} SRU 0`;

				txt += ' ATOMS=' + this.packV3000List(unit.atoms);

				if (unit.connect == PolymerBlockConnectivity.HeadToTail) txt += ' CONNECT=HT';
				else if (unit.connect == PolymerBlockConnectivity.HeadToHead) txt += ' CONNECT=HH';
				else if (unit.connect == PolymerBlockConnectivity.Random) txt += ' CONNECT=EU';

				let bonds:number[] = [];
				for (let n = 1; n <= mol.numBonds; n++)
				{
					let fl1 = unit.atoms.includes(mol.bondFrom(n)), fl2 = unit.atoms.includes(mol.bondTo(n));
					if ((fl1 && !fl2) || (!fl1 && fl2)) bonds.push(n);
				}
				if (bonds.length > 0) txt += ' BONDS=' + this.packV3000List(bonds);

				if (unit.bondConn != null) txt += ' XBCORR=' + this.packV3000List(unit.bondConn);

				lines.push(txt);
			}
		}

		return lines;
	}

	private populateSCSRTemplates():void
	{
		this.lines.push(VPFX + 'BEGIN TEMPLATE');
		for (let n = 0; n < this.scsrTemplates.length; n++)
		{
			var defn = this.scsrTemplates[n];
			let line = VPFX + 'TEMPLATE ' + (n + 1) + ' ' + defn.name;
			if (defn.natReplace) line += ' NATREPLACE=' + defn.natReplace;
			this.lines.push(line);
			
			var tmdl = new MDLMOLWriter(defn.mol);
			tmdl.includeHeader = false;
			tmdl.includeCounts = false;
			tmdl.includeEnd = false;
			let molfile = tmdl.writeV3000();
			for (line of molfile.trimEnd().split('\n')) this.lines.push(line);
		}
		this.lines.push(VPFX + 'END TEMPLATE');
	}

	private packV3000List(values:number[]):string
	{
		let str = '(' + values.length;
		for (let v of values) str += ' ' + v;
		return str + ')';
	}
	private packV3000Strings(values:string[]):string
	{
		let str = '(' + values.length;
		for (let v of values) str += ' ' + v;
		return str + ')';
	}
}

export class MDLSDFWriter
{
	// options
	public enhancedFields = true; // if on, non-standard MDL fields may be added
	public chargeSeparate = false; // if on, zero bonds will be split out
	public abbrevSgroups = true; // if on, abbreviations will be written as Sgroups when possible

	// content in progress
	private lines:string[] = [];

	// ----------------- public methods -----------------

	constructor(public ds:DataSheet)
	{
	}

	// write out the MDL content
	public write():string
	{
		let ds = this.ds, lines = this.lines;
		let colMol = this.ds.firstColOfType(DataSheetColumn.Molecule);

		for (let i = 0; i < ds.numRows; i++)
		{
			let mol = colMol < 0 ? null : ds.getMolecule(i, colMol);
			if (mol != null /*MolUtil.notBlank(mol)*/)
			{
				let wtr = new MDLMOLWriter(mol);
				wtr.enhancedFields = this.enhancedFields;
				wtr.chargeSeparate = this.chargeSeparate;
				wtr.abbrevSgroups = this.abbrevSgroups;
				let molstr = wtr.write();
				lines.push(molstr);
			}

			for (let j = 0; j < ds.numCols; j++) if (j != colMol && ds.notNull(i, j))
			{
				let ct = ds.colType(j);
				let val = '';
				if (ct == DataSheetColumn.String) val = ds.getString(i, j);
				else if (ct == DataSheetColumn.Integer) val = ds.getInteger(i, j).toString();
				else if (ct == DataSheetColumn.Real) val = ds.getReal(i, j).toString();
				else if (ct == DataSheetColumn.Boolean) val = ds.getBoolean(i, j) ? 'true' : 'false';

				if (val != '')
				{
					lines.push('> <' + ds.colName(j) + '>');
					lines.push(val);
					lines.push('');
				}
			}

			lines.push('$$$$');
		}

		return lines.join('\n');
	}

	public getResult():string
	{
		return this.lines.join('\n');
	}

	// ----------------- private methods -----------------

}

/* EOF */ }