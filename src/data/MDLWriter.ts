/*
    WebMolKit

    (c) 2010-2016 Molecular Materials Informatics, Inc.

    All rights reserved
    
    http://molmatinf.com

	[PKG=webmolkit]
*/

///<reference path='../decl/corrections.d.ts'/>
///<reference path='../util/util.ts'/>
///<reference path='../data/Molecule.ts'/>
///<reference path='../data/MolUtil.ts'/>
///<reference path='../data/DataSheet.ts'/>

/*
	MDL Molfile writer: convert the native structure format to MDL Molfile, V2000. Note that the destination format has legacy
	problems out the wazoo, and even retroactive improvements (e.g. V3000) tend to be not supported by most implementations. The
	bottom line is that the best strategy is generally to stick with a lowest common denominator subset, and try to transition away
	from the format.

	MDL SDfile writer: including non-molecule fields in collections. The SDfile format is problematic for as many reasons as the
	molecules; the best strategy is to avoid using it whenever possible, but it is so often not.
*/

class MDLMOLWriter
{
	// options
	public includeHeader = true; // if on, the 3 line header will be included
	public enhancedFields = true; // if on, non-standard MDL fields may be added
	public chargeSeparate = true; // if on, zero bonds will be split out
	public molName = ''; // optional name to include in the header (if any)

	// content in progress
	private lines:string[] = [];

	// ----------------- public methods -----------------

	constructor(public mol:Molecule)
	{
	}

	// write out the MDL content
	public write():string
	{
		if (this.includeHeader)
		{
			this.lines.push(this.molName);
			this.lines.push('Generated by WebMolKit');
			this.lines.push('');
			this.writeCTAB();
		}
		return this.lines.join('\n');
	}

	public getResult():string
	{
		return this.lines.join('\n');
	}
	
	// ----------------- private methods -----------------
	
	// writes the main block
   	private writeCTAB():void
   	{
		let mol = this.mol;

		for (let n = 1; n <= mol.numAtoms; n++) if (MolUtil.hasAbbrev(mol, n))
		{
			mol = mol.clone();
			MolUtil.expandAbbrevs(mol, true);
			break;
		}
   	
		this.lines.push(this.intrpad(mol.numAtoms, 3) + this.intrpad(mol.numBonds, 3) + '  0  0  0  0  0  0  0  0999 V2000');
		
		// data to record in the following M-block
		let chgidx:number[] = [], chgval:number[] = [];
		let radidx:number[] = [], radval:number[] = [];
		let isoidx:number[] = [], isoval:number[] = [];
		let rgpidx:number[] = [], rgpval:number[] = [];
		let hydidx:number[] = [], hydval:number[] = [];
		let zchidx:number[] = [], zchval:number[] = [];
		let zboidx:number[] = [], zboval:number[] = [];

		// store the original molecule in 'xmol'; after this point, 'mol' will be dumbed down to fit in standard MDL fields
		/* TODO....
		let xmol = mol;
		if (chargeSeparate && ChargeSeparator.anyZeroBonds(mol))
		{
			ChargeSeparator sep = new ChargeSeparator(mol);
			sep.process();
			mol = sep.getResult();
		}
		Molecule rmol = MolUtil.reduceBondTypes(mol);
		if (rmol != null) mol = rmol;*/

    	// export atoms, and make a few notes along the way
		for (let n = 1; n <= mol.numAtoms; n++)
		{
			let x = mol.atomX(n), y = mol.atomY(n), z = 0;
			let line = this.rpad(x.toFixed(4), 10) + this.rpad(y.toFixed(4), 10) + this.rpad(z.toFixed(4), 10);

			let str = mol.atomElement(n);
			if (str.length > 3) str = str.substring(0, 3);
			if (str.length > 1 && str.charAt(0) == 'R' && str.charAt(1) >= '0' && str.charAt(1) <= '9')
			{
				rgpidx.push(n);
				rgpval.push(parseInt(str.substring(1)));
				str = 'R#';
			}
			while (str.length < 4) str += ' ';
			line += ' ' + str + '0';

			let chg = mol.atomCharge(n), rad = mol.atomUnpaired(n), mapnum = mol.atomMapNum(n);
			if (chg >= -3 && chg <= -1) chg = 4 - chg;
			else if (chg == 0 && rad == 2) chg = 4;
			else if (chg >= 1 && chg <= 3) chg = 4 - chg;
			else chg = 0;
			line += this.intrpad(chg, 3) + '  0  0  0  0  0  0  0' + this.intrpad(mapnum, 3) + '  0  0';

			this.lines.push(line);

			if (mol.atomCharge(n) != 0) {chgidx.push(n); chgval.push(mol.atomCharge(n));}
			/*if (this.enhancedFields)
			{
    	    	if (xmol.atomCharge(n) != mol.atomCharge(n)) {zchidx.add(n); zchval.add(xmol.atomCharge(n));}
	    	    if (xmol.atomHExplicit(n) != Molecule.HEXPLICIT_UNKNOWN) {hydidx.add(n); hydval.add(xmol.atomHExplicit(n));}
    	   	}*/

    	    if (mol.atomUnpaired(n) != 0) {radidx.push(n); radval.push(mol.atomUnpaired(n));}
    	    if (mol.atomIsotope(n) != Molecule.ISOTOPE_NATURAL) {isoidx.push(n); isoval.push(mol.atomIsotope(n));}
    	}

    	// export bonds
		for (let n = 1; n <= mol.numBonds; n++)
		{
			let type = mol.bondOrder(n);
			let stereo = mol.bondType(n);
			if (stereo == Molecule.BONDTYPE_NORMAL) {}
    	    else if (stereo == Molecule.BONDTYPE_INCLINED) {stereo = 1; type = 1;}
    	    else if (stereo == Molecule.BONDTYPE_DECLINED) {stereo = 6; type = 1;}
    	    else if (stereo == Molecule.BONDTYPE_UNKNOWN) {stereo = 4; type = 1;}
    	    else stereo = 0;

			let line = this.intrpad(mol.bondFrom(n), 3) + this.intrpad(mol.bondTo(n), 3) + 
					   this.intrpad(type, 3) + this.intrpad(stereo, 3) + '  0  0  0';
			this.lines.push(line);
			
			/*if (enhancedFields)
			{
				if (xmol.bondOrder(n) != mol.bondOrder(n)) {zboidx.add(n); zboval.add(xmol.bondOrder(n));}
			}*/
    	}

		// export the additional blocks
		this.writeMBlock('CHG', chgidx, chgval);
		this.writeMBlock('RAD', radidx, radval);
		this.writeMBlock('ISO', isoidx, isoval);
		this.writeMBlock('RGP', rgpidx, rgpval);
		this.writeMBlock('HYD', hydidx, hydval);
		this.writeMBlock('ZCH', zchidx, zchval);
		this.writeMBlock('ZBO', zboidx, zboval);

    	// export long atom names
		for (let n = 1; n <= mol.numAtoms; n++) if (mol.atomElement(n).length > 2)
		{
			this.lines.push('A  ' + this.intrpad(n, 3));
			this.lines.push(mol.atomElement(n));
		}

    	this.lines.push('M  END');
   	}

    // writes a specific sub-block, e.g. M__CHG, etc.
	private writeMBlock(token:string, idx:number[], val:number[])
	{
		const sz = idx.length;
		for (let i = 0; i < sz; i += 8)
		{
			let count = Math.min(8, sz - i);
			let line = "M  " + token + this.intrpad(count, 3);
			for (let j = 0; j < count; j++) line += this.intrpad(idx[i + j], 4) + this.intrpad(val[i + j], 4);
			this.lines.push(line);
		}
    }

	// convenient formatting
	private intrpad(num:number, sz:number):string
	{
		return this.rpad(num.toString(), sz);
	}
	private rpad(str:string, sz:number):string
	{
		while (str.length < sz) str = ' ' + str;
		return str;
	}
}

class MDLSDFWriter
{
	// options

	// content in progress
	private lines:string[] = [];

	// ----------------- public methods -----------------

	constructor(public ds:DataSheet)
	{
	}

	// write out the MDL content
	public write():string
	{
		let ds = this.ds, lines = this.lines;
		let colMol = this.ds.firstColOfType(DataSheet.COLTYPE_MOLECULE);

		for (let i = 0; i < ds.numRows; i++)
		{
			let mol = colMol < 0 ? null : ds.getMolecule(i, colMol);
			if (MolUtil.notBlank(mol))
			{
				let molstr = new MDLMOLWriter(mol).write();
				lines.push(molstr);
			}
			
			for (let j = 0; j < ds.numCols; j++) if (j != colMol && ds.notNull(i, j))
			{
				let ct = ds.colType(j);
				let val = '';
				if (ct == DataSheet.COLTYPE_STRING) val = ds.getString(i, j);
				else if (ct == DataSheet.COLTYPE_INTEGER) val = ds.getInteger(i, j).toString();
				else if (ct == DataSheet.COLTYPE_REAL) val = ds.getReal(i, j).toString();
				else if (ct == DataSheet.COLTYPE_BOOLEAN) val = ds.getBoolean(i, j) ? 'true' : 'false';
				
				if (val != '')
				{
					lines.push('> <' + ds.colName(j) + '>');
					lines.push(val);
					lines.push('');
				}
			}

			lines.push('$$$$');
		}

		// !!
		return lines.join('\n');
	}

	public getResult():string
	{
		return this.lines.join('\n');
	}
	
	// ----------------- private methods -----------------
	
	
}