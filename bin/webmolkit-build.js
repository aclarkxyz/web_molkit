var WebMolKit;
(function (WebMolKit) {
    class Vec {
        static isBlank(arr) { return arr == null || arr.length == 0; }
        static notBlank(arr) { return arr != null && arr.length > 0; }
        static safeArray(arr) { return arr == null ? [] : arr; }
        static arrayLength(arr) { return arr == null ? 0 : arr.length; }
        static anyTrue(arr) {
            if (arr == null)
                return false;
            for (let v of arr)
                if (v)
                    return true;
            return false;
        }
        static allTrue(arr) {
            if (arr == null)
                return true;
            for (let v of arr)
                if (!v)
                    return false;
            return true;
        }
        static anyFalse(arr) {
            if (arr == null)
                return false;
            for (let v of arr)
                if (!v)
                    return true;
            return false;
        }
        static allFalse(arr) {
            if (arr == null)
                return true;
            for (let v of arr)
                if (v)
                    return false;
            return true;
        }
        static swap(arr, idx1, idx2) {
            let v = arr[idx1];
            arr[idx1] = arr[idx2];
            arr[idx2] = v;
        }
        static append(arr, item) {
            if (arr == null || arr.length == 0)
                return [item];
            arr = arr.slice(0);
            arr.push(item);
            return arr;
        }
        static prepend(arr, item) {
            if (arr == null || arr.length == 0)
                return [item];
            arr = arr.slice(0);
            arr.unshift(item);
            return arr;
        }
        static concat(arr1, arr2) {
            if (arr1 == null && arr2 == null)
                return [];
            if (arr1 == null)
                return arr2.slice(0);
            if (arr2 == null)
                return arr1.slice(0);
            return arr1.concat(arr2);
        }
        static remove(arr, idx) {
            arr = arr.slice(0);
            arr.splice(idx, 1);
            return arr;
        }
        static equals(arr1, arr2) {
            if (arr1 == null && arr2 == null)
                return true;
            if (arr1 == null || arr2 == null)
                return false;
            if (arr1.length != arr2.length)
                return false;
            for (let n = 0; n < arr1.length; n++)
                if (arr1[n] != arr2[n])
                    return false;
            return true;
        }
        static equivalent(arr1, arr2) {
            const len1 = arr1 == null ? 0 : arr1.length, len2 = arr2 == null ? 0 : arr2.length;
            if (len1 != len2)
                return false;
            for (let n = 0; n < len1; n++)
                if (arr1[n] != arr2[n])
                    return false;
            return true;
        }
        static booleanArray(val, sz) {
            let arr = new Array(sz);
            for (let n = sz - 1; n >= 0; n--)
                arr[n] = val;
            return arr;
        }
        static numberArray(val, sz) {
            let arr = new Array(sz);
            for (let n = sz - 1; n >= 0; n--)
                arr[n] = val;
            return arr;
        }
        static stringArray(val, sz) {
            let arr = new Array(sz);
            for (let n = sz - 1; n >= 0; n--)
                arr[n] = val;
            return arr;
        }
        static anyArray(val, sz) {
            let arr = new Array(sz);
            for (let n = sz - 1; n >= 0; n--)
                arr[n] = val;
            return arr;
        }
        static min(arr) {
            if (arr == null || arr.length == 0)
                return Number.MAX_VALUE;
            let v = arr[0];
            for (let n = 1; n < arr.length; n++)
                v = Math.min(v, arr[n]);
            return v;
        }
        static max(arr) {
            if (arr == null || arr.length == 0)
                return Number.MIN_VALUE;
            let v = arr[0];
            for (let n = 1; n < arr.length; n++)
                v = Math.max(v, arr[n]);
            return v;
        }
        static idxMin(arr) {
            if (arr == null || arr.length == 0)
                return -1;
            let idx = 0;
            for (let n = 1; n < arr.length; n++)
                if (arr[n] < arr[idx])
                    idx = n;
            return idx;
        }
        static idxMax(arr) {
            if (arr == null || arr.length == 0)
                return -1;
            let idx = 0;
            for (let n = 1; n < arr.length; n++)
                if (arr[n] > arr[idx])
                    idx = n;
            return idx;
        }
        static range(arr) {
            if (arr == null || arr.length == 0)
                return 0;
            let lo = arr[0], hi = arr[0];
            for (let n = 1; n < arr.length; n++) {
                if (arr[n] < lo)
                    lo = arr[n];
                if (arr[n] > hi)
                    hi = arr[n];
            }
            return hi - lo;
        }
        static reverse(arr) {
            let ret = [];
            for (let n = arr.length - 1; n >= 0; n--)
                ret.push(arr[n]);
            return ret;
        }
        static identity0(sz) {
            let ret = new Array(sz);
            for (let n = 0; n < sz; n++)
                ret[n] = n;
            return ret;
        }
        static identity1(sz) {
            let ret = new Array(sz);
            for (let n = 0; n < sz; n++)
                ret[n] = n + 1;
            return ret;
        }
        static notMask(mask) {
            let ret = new Array(mask.length);
            for (let n = mask.length - 1; n >= 0; n--)
                ret[n] = !mask[n];
            return ret;
        }
        static idxGet(arr, idx) {
            let ret = [];
            for (let n = 0; n < idx.length; n++)
                ret.push(arr[idx[n]]);
            return ret;
        }
        static maskCount(mask) {
            let c = 0;
            for (let n = mask.length - 1; n >= 0; n--)
                if (mask[n])
                    c++;
            return c;
        }
        static maskIdx(mask) {
            let idx = [];
            for (let n = 0; n < mask.length; n++)
                if (mask[n])
                    idx.push(n);
            return idx;
        }
        static idxMask(idx, sz) {
            let mask = Vec.booleanArray(false, sz);
            for (let n of idx)
                mask[n] = true;
            return mask;
        }
        static maskMap(mask) {
            let ret = [];
            for (let n = 0, pos = 0; n < mask.length; n++)
                ret.push(mask[n] ? pos++ : -1);
            return ret;
        }
        static maskGet(arr, mask) {
            let ret = [];
            for (let n = 0, p = 0; n < arr.length; n++)
                if (mask[n])
                    ret.push(arr[n]);
            return ret;
        }
        static maskEqual(arr1, val) {
            let ret = [];
            if (val.constructor === Array) {
                let arr2 = val;
                for (let n = 0; n < arr1.length; n++)
                    ret.push(arr1[n] == arr2[n]);
            }
            else {
                for (let n = 0; n < arr1.length; n++)
                    ret.push(arr1[n] == val);
            }
            return ret;
        }
        static sum(arr) {
            if (arr == null || arr.length == 0)
                return 0;
            let t = arr[0];
            for (let n = 1; n < arr.length; n++)
                t += arr[n];
            return t;
        }
        static add(arr1, val) {
            let ret = [];
            if (val.constructor === Array) {
                let arr2 = val;
                for (let n = 0; n < arr1.length; n++)
                    ret.push(arr1[n] + arr2[n]);
            }
            else {
                for (let n = 0; n < arr1.length; n++)
                    ret.push(arr1[n] + val);
            }
            return ret;
        }
        static sub(arr1, val) {
            let ret = [];
            if (val.constructor === Array) {
                let arr2 = val;
                for (let n = 0; n < arr1.length; n++)
                    ret.push(arr1[n] - arr2[n]);
            }
            else {
                for (let n = 0; n < arr1.length; n++)
                    ret.push(arr1[n] - val);
            }
            return ret;
        }
        static mul(arr1, val) {
            let ret = [];
            if (val.constructor === Array) {
                let arr2 = val;
                for (let n = 0; n < arr1.length; n++)
                    ret.push(arr1[n] * arr2[n]);
            }
            else {
                for (let n = 0; n < arr1.length; n++)
                    ret.push(arr1[n] * val);
            }
            return ret;
        }
        static neg(arr) {
            let ret = arr.slice(0);
            for (let n = ret.length - 1; n >= 0; n--)
                ret[n] *= -1;
            return ret;
        }
        static setTo(arr, val) { for (let n = arr == null ? -1 : arr.length - 1; n >= 0; n--)
            arr[n] = val; }
        static addTo(arr, val) { for (let n = arr == null ? -1 : arr.length - 1; n >= 0; n--)
            arr[n] += val; }
        static mulBy(arr, val) { for (let n = arr == null ? -1 : arr.length - 1; n >= 0; n--)
            arr[n] *= val; }
        static addToArray(arr, val) { for (let n = arr == null ? -1 : arr.length - 1; n >= 0; n--)
            arr[n] += val[n]; }
        static subFromArray(arr, val) { for (let n = arr == null ? -1 : arr.length - 1; n >= 0; n--)
            arr[n] -= val[n]; }
        static mulByArray(arr, val) { for (let n = arr == null ? -1 : arr.length - 1; n >= 0; n--)
            arr[n] *= val[n]; }
        static divByArray(arr, val) { for (let n = arr == null ? -1 : arr.length - 1; n >= 0; n--)
            arr[n] /= val[n]; }
        static idxSort(arr) {
            let idx = new Array(arr.length);
            for (let n = 0; n < arr.length; n++)
                idx[n] = n;
            idx.sort((a, b) => arr[a] < arr[b] ? -1 : arr[a] > arr[b] ? 1 : 0);
            return idx;
        }
        static sort(arr) {
            arr.sort((v1, v2) => v1 - v2);
        }
        static sorted(arr) {
            arr = arr.slice(0);
            this.sort(arr);
            return arr;
        }
        static uniqueUnstable(arr) {
            return Array.from(new Set(arr));
        }
        static uniqueStable(arr) {
            let set = new Set(arr), ret = [];
            for (let v of arr)
                if (set.has(v)) {
                    ret.push(v);
                    set.delete(v);
                }
            return ret;
        }
        static maskUnique(arr) {
            let set = new Set(arr), ret = this.booleanArray(false, arr.length);
            for (let n = 0; n < arr.length; n++)
                if (set.has(arr[n])) {
                    ret[n] = true;
                    set.delete(arr[n]);
                }
            return ret;
        }
        static idxUnique(arr) {
            let set = new Set(arr), ret = [];
            for (let n = 0; n < arr.length; n++)
                if (set.has(arr[n])) {
                    ret.push(n);
                    set.delete(arr[n]);
                }
            return ret;
        }
    }
    WebMolKit.Vec = Vec;
    class Permutation {
        static parityPerms(idx) {
            let v = Vec.booleanArray(false, idx.length);
            let p = 0;
            for (let i = idx.length - 1; i >= 0; i--) {
                if (v[i])
                    p++;
                else {
                    let j = i;
                    do {
                        j = idx[j];
                        v[j] = true;
                    } while (j != i);
                }
            }
            return p;
        }
        static parityIdentity(idx) {
            return this.parityPerms(idx) & 1;
        }
        static parityOrder(src) {
            if (src.length <= 1)
                return 0;
            else if (src.length == 2)
                return src[0] < src[1] ? 0 : 1;
            else if (src.length == 3) {
                let p = 1;
                if (src[0] < src[1])
                    p++;
                if (src[0] < src[2])
                    p++;
                if (src[1] < src[2])
                    p++;
                return p & 1;
            }
            else if (src.length == 4) {
                let p = 0;
                if (src[0] < src[1])
                    p++;
                if (src[0] < src[2])
                    p++;
                if (src[0] < src[3])
                    p++;
                if (src[1] < src[2])
                    p++;
                if (src[1] < src[3])
                    p++;
                if (src[2] < src[3])
                    p++;
                return p & 1;
            }
            let idx = [], sorted = src.slice(0);
            sorted.sort();
            for (let n = 0; n < src.length; n++)
                idx.push(sorted.indexOf(src[n]));
            return this.parityIdentity(idx);
        }
        static smallPermutation(sz) {
            if (sz == 1)
                return this.PERM1;
            else if (sz == 2)
                return this.PERM2;
            else if (sz == 3)
                return this.PERM3;
            else if (sz == 4)
                return this.PERM4;
            else
                return null;
        }
        static allPermutations(sz) {
            if (sz <= this.SMALL_PERMS)
                return this.smallPermutation(sz);
            while (this.PERM_CACHE.length < this.MAX_CACHE - this.SMALL_PERMS)
                this.PERM_CACHE.push(null);
            if (sz < this.MAX_CACHE && this.PERM_CACHE[sz - this.SMALL_PERMS] != null)
                return this.PERM_CACHE[sz - this.SMALL_PERMS];
            let nperms = 1;
            for (let n = 2; n <= sz; n++)
                nperms *= n;
            let perms = [];
            let idx = Vec.identity0(sz);
            perms.push(idx.slice(0));
            let mask = Vec.booleanArray(false, sz);
            for (let n = 1; n < nperms; n++) {
                nonunique: while (idx[0] < sz) {
                    idx[sz - 1]++;
                    for (let i = sz - 1; i > 0; i--) {
                        if (idx[i] < sz)
                            break;
                        idx[i] = 0;
                        idx[i - 1]++;
                    }
                    Vec.setTo(mask, false);
                    for (let i of idx) {
                        if (mask[i])
                            continue nonunique;
                        mask[i] = true;
                    }
                    perms[n] = idx.slice(0);
                    break;
                }
            }
            if (sz < this.MAX_CACHE)
                this.PERM_CACHE[sz - this.SMALL_PERMS] = perms;
            return perms;
        }
    }
    Permutation.PERM1 = [[0]];
    Permutation.PERM2 = [[0, 1], [1, 0]];
    Permutation.PERM3 = [[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]];
    Permutation.PERM4 = [
        [0, 1, 2, 3], [0, 1, 3, 2], [0, 2, 1, 3], [0, 2, 3, 1], [0, 3, 1, 2], [0, 3, 2, 1],
        [1, 0, 2, 3], [1, 0, 3, 2], [1, 2, 0, 3], [1, 2, 3, 0], [1, 3, 0, 2], [1, 3, 2, 0],
        [2, 0, 1, 3], [2, 0, 3, 1], [2, 1, 0, 3], [2, 1, 3, 0], [2, 3, 0, 1], [2, 3, 1, 0],
        [3, 0, 1, 2], [3, 0, 2, 1], [3, 1, 0, 2], [3, 1, 2, 0], [3, 2, 0, 1], [3, 2, 1, 0]
    ];
    Permutation.SMALL_PERMS = 4;
    Permutation.MAX_CACHE = 8;
    Permutation.PERM_CACHE = [];
    WebMolKit.Permutation = Permutation;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    function safeInt(str, def = 0) {
        let val = parseInt(str);
        return isNaN(val) ? def : val;
    }
    WebMolKit.safeInt = safeInt;
    function safeFloat(str, def = 0) {
        let val = parseFloat(str);
        return isNaN(val) ? def : val;
    }
    WebMolKit.safeFloat = safeFloat;
    function newElement(parent, tag, attr) {
        let el = $(`<${tag}>`);
        if (attr)
            el.attr(attr);
        $(parent).append(el);
        return el[0];
    }
    WebMolKit.newElement = newElement;
    function addText(parent, text) {
        let el = parent instanceof jQuery ? parent[0] : parent;
        el.appendChild(document.createTextNode(text));
    }
    WebMolKit.addText = addText;
    function setVisible(node, visible) {
        if (visible)
            $(node).show();
        else
            $(node).hide();
    }
    WebMolKit.setVisible = setVisible;
    function plural(count) {
        return count == 1 ? '' : 's';
    }
    WebMolKit.plural = plural;
    function formatDouble(value, sigfig) {
        if (value == null)
            return '';
        let str = value.toPrecision(sigfig);
        if (str.indexOf('.') > 0)
            while (str.endsWith('0') || str.endsWith('.'))
                str = str.substring(0, str.length - 1);
        return str;
    }
    WebMolKit.formatDouble = formatDouble;
    function htmlToRGB(col) {
        if (col == null || col.charAt(0) != '#' || col.length != 7)
            return null;
        return parseInt(col.substring(1), 16);
    }
    WebMolKit.htmlToRGB = htmlToRGB;
    function colourCode(col) {
        var hex = (col & 0xFFFFFF).toString(16);
        while (hex.length < 6)
            hex = '0' + hex;
        return '#' + hex;
    }
    WebMolKit.colourCode = colourCode;
    function colourAlpha(col) {
        var transp = (col >>> 24) & 0xFF;
        return transp == 0 ? 1 : transp == 0xFF ? 0 : 1 - (transp * (1.0 / 255));
    }
    WebMolKit.colourAlpha = colourAlpha;
    const ONE_OVER_255 = 1.0 / 255;
    function colourCanvas(col) {
        if (col == 0xFFFFFF)
            return 'white';
        if (col == 0x000000)
            return 'black';
        if (col == -1)
            return null;
        if (col >= 0 && col <= 0xFFFFFF)
            return colourCode(col);
        const t = ((col >> 24) & 0xFF) * ONE_OVER_255;
        const r = ((col >> 16) & 0xFF);
        const g = ((col >> 8) & 0xFF);
        const b = (col & 0xFF);
        return 'rgba(' + r + ',' + g + ',' + b + ',' + (1 - t) + ')';
    }
    WebMolKit.colourCanvas = colourCanvas;
    function blendRGB(fract, rgb1, rgb2, rgb3) {
        fract = Math.max(0, Math.min(1, fract));
        let r1 = ((rgb1 >> 16) & 0xFF) * ONE_OVER_255, g1 = ((rgb1 >> 8) & 0xFF) * ONE_OVER_255, b1 = (rgb1 & 0xFF) * ONE_OVER_255;
        let r2 = ((rgb2 >> 16) & 0xFF) * ONE_OVER_255, g2 = ((rgb2 >> 8) & 0xFF) * ONE_OVER_255, b2 = (rgb2 & 0xFF) * ONE_OVER_255;
        let R, G, B;
        if (rgb3 == null) {
            let f1 = 1 - fract, f2 = fract;
            R = Math.round(0xFF * (f1 * r1 + f2 * r2));
            G = Math.round(0xFF * (f1 * g1 + f2 * g2));
            B = Math.round(0xFF * (f1 * b1 + f2 * b2));
        }
        else {
            let r3 = ((rgb3 >> 16) & 0xFF) * ONE_OVER_255, g3 = ((rgb3 >> 8) & 0xFF) * ONE_OVER_255, b3 = (rgb3 & 0xFF) * ONE_OVER_255;
            if (fract < 0.5) {
                let f2 = fract * 2, f1 = 1 - f2;
                R = Math.round(0xFF * (f1 * r1 + f2 * r2));
                G = Math.round(0xFF * (f1 * g1 + f2 * g2));
                B = Math.round(0xFF * (f1 * b1 + f2 * b2));
            }
            else {
                let f2 = (fract - 0.5) * 2, f1 = 1 - f2;
                R = Math.round(0xFF * (f1 * r2 + f2 * r3));
                G = Math.round(0xFF * (f1 * g2 + f2 * g3));
                B = Math.round(0xFF * (f1 * b2 + f2 * b3));
            }
        }
        return (R << 16) | (G << 8) | B;
    }
    WebMolKit.blendRGB = blendRGB;
    function nodeText(node) {
        var ret = '';
        if (!node)
            return;
        node = node.firstChild;
        while (node) {
            if (node.nodeType == 3 || node.nodeType == 4)
                ret += node.nodeValue;
            node = node.nextSibling;
        }
        return ret;
    }
    WebMolKit.nodeText = nodeText;
    function isDef(v) {
        return !(v === null || typeof v === 'undefined');
    }
    WebMolKit.isDef = isDef;
    function notDef(v) {
        return v === null || typeof v === 'undefined';
    }
    WebMolKit.notDef = notDef;
    function eventCoords(event, container) {
        var parentOffset = $(container).offset();
        var relX = event.pageX - parentOffset.left;
        var relY = event.pageY - parentOffset.top;
        return [relX, relY];
    }
    WebMolKit.eventCoords = eventCoords;
    function norm_xy(dx, dy) {
        return Math.sqrt(dx * dx + dy * dy);
    }
    WebMolKit.norm_xy = norm_xy;
    function norm_xyz(dx, dy, dz) {
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }
    WebMolKit.norm_xyz = norm_xyz;
    function norm2_xy(dx, dy) {
        return dx * dx + dy * dy;
    }
    WebMolKit.norm2_xy = norm2_xy;
    function norm2_xyz(dx, dy, dz) {
        return dx * dx + dy * dy + dz * dz;
    }
    WebMolKit.norm2_xyz = norm2_xyz;
    function sqr(v) {
        return v * v;
    }
    WebMolKit.sqr = sqr;
    function invZ(v) { return v == 0 ? 0 : 1.0 / v; }
    WebMolKit.invZ = invZ;
    function fltEqual(v1, v2) { return v1 == v2 || Math.abs(v1 - v2) <= 1E-7 * Math.max(v1, v2); }
    WebMolKit.fltEqual = fltEqual;
    function realEqual(v1, v2) { return v1 == v2 || Math.abs(v1 - v2) <= 1E-14 * Math.max(v1, v2); }
    WebMolKit.realEqual = realEqual;
    function randomInt(size) {
        if (size <= 1)
            return 0;
        return Math.floor(Math.random() * size);
    }
    WebMolKit.randomInt = randomInt;
    WebMolKit.TWOPI = 2 * Math.PI;
    WebMolKit.INV_TWOPI = 1.0 / WebMolKit.TWOPI;
    WebMolKit.DEGRAD = Math.PI / 180;
    WebMolKit.RADDEG = 180 / Math.PI;
    function angleNorm(th) {
        if (th == -Math.PI)
            return Math.PI;
        if (th < -Math.PI) {
            let mod = Math.ceil((-th - Math.PI) * WebMolKit.INV_TWOPI);
            return th + mod * WebMolKit.TWOPI;
        }
        if (th > Math.PI) {
            let mod = Math.ceil((th - Math.PI) * WebMolKit.INV_TWOPI);
            return th - mod * WebMolKit.TWOPI;
        }
        return th;
    }
    WebMolKit.angleNorm = angleNorm;
    function angleDiff(th1, th2) {
        let theta = angleNorm(th1) - angleNorm(th2);
        return theta - (theta > Math.PI ? WebMolKit.TWOPI : 0) + (theta <= -Math.PI ? WebMolKit.TWOPI : 0);
    }
    WebMolKit.angleDiff = angleDiff;
    function angleDiffPos(th1, th2) {
        let theta = angleNorm(th1) - angleNorm(th2);
        return theta + (theta < 0 ? WebMolKit.TWOPI : 0);
    }
    WebMolKit.angleDiffPos = angleDiffPos;
    function sortAngles(theta) {
        if (theta == null || theta.length < 2)
            return theta;
        theta = theta.slice(0);
        for (let n = 0; n < theta.length; n++)
            theta[n] = angleNorm(theta[n]);
        WebMolKit.Vec.sort(theta);
        while (true) {
            let a = theta[theta.length - 1], b = theta[0], c = theta[1];
            if (angleDiff(b, a) <= angleDiff(c, b))
                break;
            for (let n = theta.length - 1; n > 0; n--)
                theta[n] = theta[n - 1];
            theta[0] = a;
        }
        return theta;
    }
    WebMolKit.sortAngles = sortAngles;
    function uniqueAngles(theta, threshold) {
        theta = sortAngles(theta);
        for (let n = 1; n < theta.length; n++) {
            if (Math.abs(angleDiff(theta[n], theta[n - 1])) <= threshold) {
                theta.splice(n, 1);
                n--;
            }
        }
        return theta;
    }
    WebMolKit.uniqueAngles = uniqueAngles;
    function minArray(a) {
        if (a == null || a.length == 0)
            return 0;
        var v = a[0];
        for (var n = 1; n < a.length; n++)
            v = Math.min(v, a[n]);
        return v;
    }
    WebMolKit.minArray = minArray;
    function maxArray(a) {
        if (a == null || a.length == 0)
            return 0;
        var v = a[0];
        for (var n = 1; n < a.length; n++)
            v = Math.max(v, a[n]);
        return v;
    }
    WebMolKit.maxArray = maxArray;
    function findNode(parent, name) {
        if (parent == null)
            return null;
        var node = parent.firstChild;
        while (node) {
            if (node.nodeType == Node.ELEMENT_NODE && node.nodeName == name)
                return node;
            node = node.nextSibling;
        }
        return null;
    }
    WebMolKit.findNode = findNode;
    function findNodes(parent, name) {
        if (parent == null)
            return null;
        var node = parent.firstChild;
        var list = [];
        while (node) {
            if (node.nodeType == Node.ELEMENT_NODE && node.nodeName == name)
                list.push(node);
            node = node.nextSibling;
        }
        return list;
    }
    WebMolKit.findNodes = findNodes;
    function pathRoundedRect(x1, y1, x2, y2, rad) {
        var path = new Path2D();
        path.moveTo(x2 - rad, y1);
        path.quadraticCurveTo(x2, y1, x2, y1 + rad);
        path.lineTo(x2, y2 - rad);
        path.quadraticCurveTo(x2, y2, x2 - rad, y2);
        path.lineTo(x1 + rad, y2);
        path.quadraticCurveTo(x1, y2, x1, y2 - rad);
        path.lineTo(x1, y1 + rad);
        path.quadraticCurveTo(x1, y1, x1 + rad, y1);
        path.closePath();
        return path;
    }
    WebMolKit.pathRoundedRect = pathRoundedRect;
    function drawLine(ctx, x1, y1, x2, y2) {
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
    }
    WebMolKit.drawLine = drawLine;
    WebMolKit.ASCENT_FUDGE = 1.4;
    function fontSansSerif(ascent) { return `${ascent * WebMolKit.ASCENT_FUDGE}px sans-serif`; }
    WebMolKit.fontSansSerif = fontSansSerif;
    function pixelDensity() {
        if ('devicePixelRatio' in window && window.devicePixelRatio > 1)
            return window.devicePixelRatio;
        return 1;
    }
    WebMolKit.pixelDensity = pixelDensity;
    function clone(data) {
        if (data == null)
            return null;
        if (Array.isArray(data))
            return data.slice(0);
        if (typeof data != 'object')
            return data;
        let result = {};
        for (let key in data)
            result[key] = data[key];
        return result;
    }
    WebMolKit.clone = clone;
    function deepClone(data) {
        if (data == null)
            return null;
        if (typeof data == 'function')
            return null;
        if (typeof data != 'object')
            return data;
        let result = Array.isArray(data) ? [] : {};
        for (let key in data) {
            let val = data[key];
            result[key] = typeof val === 'object' ? deepClone(val) : val;
        }
        return result;
    }
    WebMolKit.deepClone = deepClone;
    function escapeHTML(text) {
        if (!text)
            return '';
        const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
        return text.replace(/[&<>"']/g, (m) => map[m]);
    }
    WebMolKit.escapeHTML = escapeHTML;
    function orBlank(str) { return str == null ? '' : str; }
    WebMolKit.orBlank = orBlank;
    function dictValues(dict) {
        let list = [];
        for (let key in dict)
            list.push(dict[key]);
        return list;
    }
    WebMolKit.dictValues = dictValues;
    function toUTF8(str) {
        let data = [], stripe = '';
        const sz = str.length;
        for (let n = 0; n < sz; n++) {
            var charcode = str.charCodeAt(n);
            if (charcode < 0x80)
                stripe += str.charAt(n);
            else if (charcode < 0x800) {
                stripe += String.fromCharCode(0xc0 | (charcode >> 6));
                stripe += String.fromCharCode(0x80 | (charcode & 0x3F));
            }
            else if (charcode < 0xd800 || charcode >= 0xe000) {
                stripe += String.fromCharCode(0xe0 | (charcode >> 12));
                stripe += String.fromCharCode(0x80 | ((charcode >> 6) & 0x3F));
                stripe += String.fromCharCode(0x80 | (charcode & 0x3F));
            }
            else {
                n++;
                charcode = 0x10000 + (((charcode & 0x3FF) << 10) | (str.charCodeAt(n) & 0x3FF));
                stripe += String.fromCharCode(0xf0 | (charcode >> 18));
                stripe += String.fromCharCode(0x80 | ((charcode >> 12) & 0x3F));
                stripe += String.fromCharCode(0x80 | ((charcode >> 6) & 0x3F));
                stripe += String.fromCharCode(0x80 | (charcode & 0x3F));
            }
            if (stripe.length > 100) {
                data.push(stripe);
                stripe = '';
            }
        }
        data.push(stripe);
        return data.join('');
    }
    WebMolKit.toUTF8 = toUTF8;
    function fromUTF8(str) {
        let data = [], stripe = '';
        const sz = str.length;
        for (let n = 0; n < sz; n++) {
            let value = str.charCodeAt(n);
            if (value < 0x80)
                stripe += str.charAt(n);
            else if (value > 0xBF && value < 0xE0) {
                stripe += String.fromCharCode((value & 0x1F) << 6 | str.charCodeAt(n + 1) & 0x3F);
                n++;
            }
            else if (value > 0xDF && value < 0xF0) {
                str += String.fromCharCode((value & 0x0F) << 12 | (str.charCodeAt(n + 1) & 0x3F) << 6 | str.charCodeAt(n + 2) & 0x3F);
                n += 2;
            }
            else {
                let charCode = ((value & 0x07) << 18 | (str.charCodeAt(n + 1) & 0x3F) << 12 | (str.charCodeAt(n + 2) & 0x3F) << 6 | str.charCodeAt(n + 3) & 0x3F) - 0x010000;
                stripe += String.fromCharCode(charCode >> 10 | 0xD800, charCode & 0x03FF | 0xDC00);
                n += 3;
            }
            if (stripe.length > 100) {
                data.push(stripe);
                stripe = '';
            }
        }
        data.push(stripe);
        return data.join('');
    }
    WebMolKit.fromUTF8 = fromUTF8;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class DataSheet {
        constructor(data) {
            if (!data)
                data = {};
            if (!data.title)
                data.title = '';
            if (!data.description)
                data.description = '';
            if (data.numCols == null)
                data.numCols = 0;
            if (data.numRows == null)
                data.numRows = 0;
            if (data.numExtens == null)
                data.numExtens = 0;
            if (data.colData == null)
                data.colData = [];
            if (data.rowData == null)
                data.rowData = [];
            if (data.extData == null)
                data.extData = [];
            this.data = data;
        }
        clone() {
            return new DataSheet($.extend(true, {}, this.data));
        }
        getData() {
            return this.data;
        }
        get numCols() {
            return this.data.numCols;
        }
        get numRows() {
            return this.data.numRows;
        }
        getTitle() {
            return this.data.title;
        }
        getDescription() {
            return this.data.description;
        }
        setTitle(val) {
            this.data.title = val;
        }
        setDescription(val) {
            this.data.description = val;
        }
        get numExtensions() {
            return this.data.numExtens;
        }
        getExtName(idx) {
            return this.data.extData[idx].name;
        }
        getExtType(idx) {
            return this.data.extData[idx].type;
        }
        getExtData(idx) {
            return this.data.extData[idx].data;
        }
        setExtName(idx, val) {
            this.data.extData[idx].name = val;
        }
        setExtType(idx, val) {
            this.data.extData[idx].type = val;
        }
        setExtData(idx, val) {
            this.data.extData[idx].data = val;
        }
        appendExtension(name, type, data) {
            this.data.numExtens++;
            this.data.extData.push({ 'name': name, 'type': type, 'data': data });
            return this.data.numExtens - 1;
        }
        deleteExtension(idx) {
            this.data.extData.splice(idx, 1);
        }
        colName(col) {
            return this.data.colData[col].name;
        }
        colType(col) {
            return this.data.colData[col].type;
        }
        colDescr(col) {
            return this.data.colData[col].descr;
        }
        isNull(row, col) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return null;
            return this.data.rowData[row][col] == null;
        }
        notNull(row, col) { return !this.isNull(row, col); }
        getObject(row, col) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            return this.data.rowData[row][col];
        }
        getMolecule(row, col) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return null;
            let datum = this.data.rowData[row][col];
            if (datum == null)
                return null;
            if (typeof datum === 'string') {
                datum = WebMolKit.Molecule.fromString(datum);
                this.data.rowData[row][col] = datum;
            }
            return datum;
        }
        getString(row, col) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return null;
            let str = this.data.rowData[row][col];
            return str == null ? '' : str;
        }
        getInteger(row, col) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return null;
            return this.data.rowData[row][col];
        }
        getReal(row, col) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return null;
            return this.data.rowData[row][col];
        }
        getBoolean(row, col) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return null;
            return this.data.rowData[row][col];
        }
        getExtend(row, col) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return null;
            return this.data.rowData[row][col];
        }
        setToNull(row, col) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return;
            this.data.rowData[row][col] = null;
        }
        setObject(row, col, val) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return;
            this.data.rowData[row][col] = val;
        }
        setMolecule(row, col, mol) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return;
            this.data.rowData[row][col] = mol.clone();
        }
        setString(row, col, val) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return;
            this.data.rowData[row][col] = val;
        }
        setInteger(row, col, val) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return;
            this.data.rowData[row][col] = val;
        }
        setReal(row, col, val) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return;
            this.data.rowData[row][col] = val;
        }
        setBoolean(row, col, val) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return;
            this.data.rowData[row][col] = val;
        }
        setExtend(row, col, val) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return;
            this.data.rowData[row][col] = val;
        }
        isEqualMolecule(row, col, mol) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (this.isNull(row, col) != (mol == null))
                return false;
            if (mol == null)
                return true;
            return this.getMolecule(row, col).compareTo(mol) == 0;
        }
        isEqualString(row, col, val) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (this.isNull(row, col) != (val == null || val == ''))
                return false;
            if (val == null || val == '')
                return true;
            return this.getString(row, col) == val;
        }
        isEqualInteger(row, col, val) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (this.isNull(row, col) != (val == null))
                return false;
            if (val == null)
                return true;
            return this.getInteger(row, col) == val;
        }
        isEqualReal(row, col, val) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (this.isNull(row, col) != (val == null))
                return false;
            if (val == null)
                return true;
            return this.getReal(row, col) == val;
        }
        isEqualBoolean(row, col, val) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (this.isNull(row, col) != (val == null))
                return false;
            if (val == null)
                return true;
            return this.getBoolean(row, col) == val;
        }
        appendColumn(name, type, descr) {
            this.data.numCols++;
            this.data.colData.push({ 'name': name, 'type': type, 'descr': descr });
            for (let n = 0; n < this.data.numRows; n++)
                this.data.rowData[n].push(null);
            return this.data.numCols - 1;
        }
        deleteColumn(col) {
            this.data.numCols--;
            this.data.colData.splice(col, 1);
            for (let n = 0; n < this.data.numRows; n++)
                this.data.rowData[n].splice(col, 1);
        }
        changeColumnName(col, name, descr) {
            this.data.colData[col].name = col;
            this.data.colData[col].descr = descr;
        }
        changeColumnType(col, newType) {
            let oldType = this.colType(col);
            if (oldType == newType)
                return;
            let incompatible = oldType == DataSheet.COLTYPE_MOLECULE || newType == DataSheet.COLTYPE_MOLECULE ||
                oldType == DataSheet.COLTYPE_EXTEND || newType == DataSheet.COLTYPE_EXTEND;
            for (let n = this.data.rowData.length - 1; n >= 0; n--) {
                let row = this.data.rowData[n];
                if (row[col] == null)
                    continue;
                if (incompatible) {
                    row[col] = null;
                    continue;
                }
                let val = '';
                if (oldType == DataSheet.COLTYPE_STRING)
                    val = row[col];
                else if (oldType == DataSheet.COLTYPE_INTEGER)
                    val = row[col].toString();
                else if (oldType == DataSheet.COLTYPE_REAL)
                    val = row[col].toString();
                else if (oldType == DataSheet.COLTYPE_BOOLEAN)
                    val = row[col] ? 'true' : 'false';
                row[col] = null;
                if (newType == DataSheet.COLTYPE_STRING)
                    row[col] = val;
                else if (newType == DataSheet.COLTYPE_INTEGER) {
                    let num = parseInt(val);
                    row[col] = isFinite(num) ? num : null;
                }
                else if (newType == DataSheet.COLTYPE_REAL) {
                    let num = parseFloat(val);
                    row[col] = isFinite(num) ? num : null;
                }
                else if (newType == DataSheet.COLTYPE_BOOLEAN)
                    row[col] = val.toLowerCase() == 'true' ? true : false;
            }
            this.data.colData[col].type = newType;
        }
        ensureColumn(name, type, descr) {
            for (let n = 0; n < this.data.numCols; n++)
                if (this.data.colData[n].name == name) {
                    if (this.data.colData[n].type != type)
                        this.changeColumnType(n, type);
                    this.data.colData[n].descr = descr;
                    return n;
                }
            return this.appendColumn(name, type, descr);
        }
        appendRow() {
            this.data.numRows++;
            let row = new Array();
            for (let n = 0; n < this.data.numCols; n++)
                row.push(null);
            this.data.rowData.push(row);
            return this.data.numRows - 1;
        }
        appendRowFrom(srcDS, row) {
            this.data.numRows++;
            this.data.rowData.push(srcDS.data.rowData[row].slice(0));
            return this.data.numRows - 1;
        }
        insertRow(row) {
            this.data.numRows++;
            let data = new Array();
            for (let n = 0; n < this.data.numCols; n++)
                data.push(null);
            this.data.rowData.splice(row, 0, data);
        }
        deleteRow(row) {
            this.data.numRows--;
            this.data.rowData.splice(row, 1);
        }
        deleteAllRows() {
            this.data.numRows = 0;
            this.data.rowData = new Array();
        }
        moveRowUp(row) {
            let data = this.data.rowData[row];
            this.data.rowData[row] = this.data.rowData[row - 1];
            this.data.rowData[row - 1] = data;
        }
        moveRowDown(row) {
            let data = this.data.rowData[row];
            this.data.rowData[row] = this.data.rowData[row + 1];
            this.data.rowData[row + 1] = data;
        }
        exciseSingleRow(row) {
            let newData = {
                'title': this.data.title,
                'description': this.data.description,
                'numCols': this.data.numCols,
                'numRows': 1,
                'numExtens': this.data.numExtens,
                'colData': this.data.colData.slice(0),
                'rowData': [this.data.rowData[row].slice(0)],
                'extData': this.data.extData.slice(0)
            };
            return new DataSheet(newData);
        }
        colIsPrimitive(col) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            let ct = this.data.colData[col].type;
            return ct == 'string' || ct == 'real' || ct == 'integer' || ct == 'boolean';
        }
        findColByName(name, type) {
            for (let n = 0; n < this.data.numCols; n++)
                if (this.data.colData[n].name == name) {
                    if (type == null || this.data.colData[n].type == type)
                        return n;
                }
            return -1;
        }
        firstColOfType(type) {
            for (let n = 0; n < this.data.numCols; n++)
                if (this.data.colData[n].type == type)
                    return n;
            return -1;
        }
        toString(row, col) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            let obj = this.data.rowData[row][col];
            return obj == null ? null : obj.toString();
        }
        toInt(row, col) {
            if (!this.colIsPrimitive(col))
                return null;
            let obj = this.data.rowData[row][col];
            return obj == null ? null : parseInt(obj);
        }
        toReal(row, col) {
            if (!this.colIsPrimitive(col))
                return null;
            let obj = this.data.rowData[row][col];
            return obj == null ? null : parseFloat(obj);
        }
    }
    DataSheet.COLTYPE_MOLECULE = 'molecule';
    DataSheet.COLTYPE_STRING = 'string';
    DataSheet.COLTYPE_REAL = 'real';
    DataSheet.COLTYPE_INTEGER = 'integer';
    DataSheet.COLTYPE_BOOLEAN = 'boolean';
    DataSheet.COLTYPE_EXTEND = 'extend';
    WebMolKit.DataSheet = DataSheet;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class GeomUtil {
        static pointInPolygon(x, y, px, py) {
            if (x < WebMolKit.minArray(px) || x > WebMolKit.maxArray(px) || y < WebMolKit.minArray(py) || y > WebMolKit.maxArray(py))
                return false;
            let sz = px.length;
            for (let n = 0; n < sz; n++)
                if (px[n] == x && py[n] == y)
                    return true;
            let phase = false;
            for (let n = 0; n < sz; n++) {
                let x1 = px[n], y1 = py[n], x2 = px[n + 1 < sz ? n + 1 : 0], y2 = py[n + 1 < sz ? n + 1 : 0];
                if (y > Math.min(y1, y2) && y <= Math.max(y1, y2) && x <= Math.max(x1, x2) && y1 != y2) {
                    let intr = (y - y1) * (x2 - x1) / (y2 - y1) + x1;
                    if (x1 == x2 || x <= intr)
                        phase = !phase;
                }
            }
            return phase;
        }
        static areLinesParallel(x1, y1, x2, y2, x3, y3, x4, y4) {
            let dxa = x2 - x1, dxb = x4 - x3, dya = y2 - y1, dyb = y4 - y3;
            return (WebMolKit.realEqual(dxa, dxb) && WebMolKit.realEqual(dya, dyb)) || (WebMolKit.realEqual(dxa, -dxb) && WebMolKit.realEqual(dya, -dyb));
        }
        static lineIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
            let u = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
            return [x1 + u * (x2 - x1), y1 + u * (y2 - y1)];
        }
        static isPointOnLineSeg(px, py, x1, y1, x2, y2) {
            if (px < Math.min(x1, x2) || px > Math.max(x1, x2) || py < Math.min(y1, y2) || py > Math.max(y1, y2))
                return false;
            if ((px == x1 && py == y1) || (px == x2 && py == y2))
                return true;
            let dx = x2 - x1, dy = y2 - y1;
            if (Math.abs(dx) > Math.abs(dy))
                return WebMolKit.realEqual(py, (dy / dx) * (px - x1) + y1);
            else
                return WebMolKit.realEqual(px, (dx / dy) * (py - y1) + x1);
        }
        static doLineSegsIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
            if (Math.max(x1, x2) < Math.min(x3, x4) || Math.max(y1, y2) < Math.min(y3, y4))
                return false;
            if (Math.min(x1, x2) > Math.max(x3, x4) || Math.min(y1, y2) > Math.max(y3, y4))
                return false;
            if ((x1 == x3 && y1 == y3) || (x1 == x4 && y1 == y4) || (x2 == x3 && y2 == y3) || (x2 == x4 && y2 == y4))
                return true;
            if ((x1 == x2 || x3 == x4) && (x1 == x3 || x1 == x4 || x2 == x3 || x2 == x4))
                return true;
            if ((y1 == y2 || y3 == y4) && (y1 == y3 || y1 == y4 || y2 == y3 || y2 == y4))
                return true;
            let x4_x3 = x4 - x3, y4_y3 = y4 - y3, x2_x1 = x2 - x1, y2_y1 = y2 - y1, x1_x3 = x1 - x3, y1_y3 = y1 - y3;
            let nx = x4_x3 * y1_y3 - y4_y3 * x1_x3;
            let ny = x2_x1 * y1_y3 - y2_y1 * x1_x3;
            let dn = y4_y3 * x2_x1 - x4_x3 * y2_y1;
            if (dn == 0)
                return false;
            if (dn < 0) {
                dn = -dn;
                nx = -nx;
                ny = -ny;
            }
            return nx >= 0 && nx <= dn && ny >= 0 && ny <= dn;
        }
        static rectsIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
            if (x1 <= x2 && x1 + w1 >= x2 + w2 && y1 <= y2 && y1 + h1 >= y2 + h2)
                return true;
            if (x2 <= x1 && x2 + w2 >= x1 + w1 && y2 <= y1 && y2 + h2 >= y1 + h1)
                return true;
            if (x1 + w1 < x2 || x2 + w2 < x1 || y1 + h1 < y2 || y2 + h2 < y1)
                return false;
            return true;
        }
        static sortAngles(theta) {
            if (theta == null || theta.length < 2)
                return theta;
            theta = theta.slice(0);
            for (let n = 0; n < theta.length; n++)
                theta[n] = WebMolKit.angleNorm(theta[n]);
            WebMolKit.Vec.sort(theta);
            if (theta.length == 2)
                return theta;
            while (true) {
                let a = theta[theta.length - 1], b = theta[0], c = theta[1];
                if (WebMolKit.angleDiff(b, a) <= WebMolKit.angleDiff(c, b))
                    break;
                for (let n = theta.length - 1; n > 0; n--)
                    theta[n] = theta[n - 1];
                theta[0] = a;
            }
            return theta;
        }
        static uniqueAngles(theta, threshold) {
            let ang = GeomUtil.sortAngles(theta), ret = [];
            ret.push(ang[0]);
            for (let n = 1; n < ang.length; n++) {
                if (Math.abs(WebMolKit.angleDiff(ang[n], ang[n - 1])) > threshold)
                    ret.push(ang[n]);
            }
            return ret;
        }
        static thetaObtuse(th1, th2) {
            let dth = th2 - th1;
            while (dth < -Math.PI)
                dth += 2 * Math.PI;
            while (dth > Math.PI)
                dth -= 2 * Math.PI;
            return dth > 0 ? th1 - 0.5 * (2 * Math.PI - dth) : th1 + 0.5 * (2 * Math.PI + dth);
        }
        static emergentAngle(theta) {
            let len = theta.length;
            if (len == 1)
                return theta[0];
            if (len == 2)
                return 0.5 * (theta[0] + theta[1]);
            WebMolKit.Vec.sort(theta);
            let bottom = 0;
            let behind = WebMolKit.angleDiffPos(theta[0], theta[len - 1]);
            for (let n = 1; n < len; n++) {
                let delta = WebMolKit.angleDiffPos(theta[n], theta[n - 1]);
                if (delta > behind) {
                    bottom = n;
                    behind = delta;
                }
            }
            let sum = 0;
            for (let n = 0; n < len; n++) {
                let delta = theta[n] - theta[bottom];
                if (delta < 0)
                    delta += WebMolKit.TWOPI;
                sum += delta;
            }
            return sum / len + theta[bottom];
        }
        static dotProduct(v1, v2) {
            return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
        }
        static crossProduct(v1, v2) {
            const x = v1[1] * v2[2] - v1[2] * v2[1];
            const y = v1[2] * v2[0] - v1[0] * v2[2];
            const z = v1[0] * v2[1] - v1[1] * v2[0];
            return [x, y, z];
        }
        static magnitude2(v) {
            return v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
        }
        static magnitude(v) {
            return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
        }
        static dist2(v1, v2) {
            let dx = v1[0] - v2[0], dy = v1[1] - v2[1], dz = v1[2] - v2[2];
            return dx * dx + dy * dy + dz * dz;
        }
        static dist(v1, v2) {
            let dx = v1[0] - v2[0], dy = v1[1] - v2[1], dz = v1[2] - v2[2];
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }
        static normalise(v) {
            const dsq = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
            if (dsq == 0)
                return;
            const inv = 1.0 / Math.sqrt(dsq);
            v[0] *= inv;
            v[1] *= inv;
            v[2] *= inv;
        }
        static normalised(v) {
            let ret = v.slice(0);
            this.normalise(ret);
            return ret;
        }
        static acuteAngle(v1, v2) {
            let mag1 = this.magnitude(v1), mag2 = this.magnitude(v2);
            if (mag1 == 0 || mag2 == 0)
                return 0;
            let dot = this.dotProduct(v1, v2);
            let cosTheta = dot / (mag1 * mag2);
            cosTheta = Math.max(-1, Math.min(1, cosTheta));
            return Math.acos(cosTheta);
        }
        static arcControlPoints(rad, x1, y1, x2, y2) {
            let t1x = -y1, t1y = x1;
            let t2x = y2, t2y = -x2;
            let dx = 0.5 * (x1 + x2);
            let dy = 0.5 * (y1 + y2);
            let tx = 3 / 8 * (t1x + t2x);
            let ty = 3 / 8 * (t1y + t2y);
            let a = tx * tx + ty * ty;
            let b = dx * tx + dy * ty;
            let c = dx * dx + dy * dy - rad * rad;
            let D = b * b - a * c;
            let k = (Math.sqrt(D) - b) / a;
            return [x1 + k * t1x, y1 + k * t1y, x2 + k * t2x, y2 + k * t2y];
        }
        static fitCircle(x, y) {
            let dsq = Number.POSITIVE_INFINITY;
            for (let n = 0; n < x.length; n++)
                dsq = Math.min(dsq, WebMolKit.norm2_xy(x[n], y[n]));
            return Math.sqrt(dsq);
        }
        static fitEllipse(px, py, minX, minY, maxX, maxY) {
            let bestW = 0.5 * this.fitCircle(px, py), bestH = bestW, bestScore = bestW * bestH;
            let x = WebMolKit.Vec.concat(px, [minX, maxX, 0, 0]);
            let y = WebMolKit.Vec.concat(py, [0, 0, minY, maxY]);
            const sz = x.length;
            let shrinkToFit = (whs) => {
                let dmin = Number.POSITIVE_INFINITY;
                let invW2 = 1.0 / (whs[0] * whs[0]), invH2 = 1.0 / (whs[1] * whs[1]);
                for (let n = 0; n < sz; n++)
                    dmin = Math.min(dmin, Math.sqrt(x[n] * x[n] * invW2 + y[n] * y[n] * invH2));
                if (dmin < 1) {
                    whs[0] *= dmin;
                    whs[1] *= dmin;
                }
                whs[2] = whs[0] * whs[1];
            };
            let mul = 1;
            let whsX = [0, 0, 0], whsY = [0, 0, 0];
            while (mul > 0.001) {
                whsX[0] = bestW * (1 + mul);
                whsX[1] = bestH;
                shrinkToFit(whsX);
                whsY[0] = bestW;
                whsY[1] = bestH * (1 + mul);
                shrinkToFit(whsY);
                let anything = false;
                if (whsX[2] > bestScore) {
                    bestW = whsX[0];
                    bestH = whsX[1];
                    bestScore = whsX[2];
                    anything = true;
                }
                if (whsY[2] > bestScore) {
                    bestW = whsY[0];
                    bestH = whsY[1];
                    bestScore = whsY[2];
                    anything = true;
                }
                if (!anything)
                    mul *= 0.6;
            }
            return [bestW, bestH];
        }
    }
    WebMolKit.GeomUtil = GeomUtil;
    class QuickHull {
        constructor(x, y, threshSq) {
            this.x = x;
            this.y = y;
            this.threshSq = threshSq;
            this.hsz = 0;
            this.hullX = [];
            this.hullY = [];
            const sz = x.length;
            let l = 0, r = 0;
            for (let n = 0; n < sz; n++) {
                if (x[r] > x[n] || (x[r] == x[n] && y[r] > y[n]))
                    r = n;
                if (x[l] < x[n] || (x[l] == x[n] && y[l] < y[n]))
                    l = n;
            }
            let al1 = [], al2 = [];
            for (let n = 0; n < sz; n++) {
                if (n != l && n != r) {
                    if (this.right(r, l, n) > 0)
                        al1.push(n);
                    else
                        al2.push(n);
                }
            }
            this.hullX.push(x[r]);
            this.hullY.push(y[r]);
            this.quickHull(r, l, al1);
            this.hullX.push(x[l]);
            this.hullY.push(y[l]);
            this.quickHull(l, r, al2);
            for (let n = 0; n < this.hullX.length - 1;) {
                if (WebMolKit.norm2_xy(this.hullX[n] - this.hullY[n + 1], this.hullY[n] - this.hullY[n + 1]) < threshSq) {
                    this.hullX.splice(n + 1, 1);
                    this.hullY.splice(n + 1, 1);
                }
                else
                    n++;
            }
        }
        quickHull(a, b, al) {
            if (al.length == 0)
                return;
            let c = this.furthestPoint(a, b, al);
            let al1 = [], al2 = [];
            for (let n = 0; n < al.length; n++) {
                let p = al[n];
                if (p == a || p == b)
                    continue;
                if (this.right(a, c, p) > 0)
                    al1.push(p);
                else if (this.right(c, b, p) > 0)
                    al2.push(p);
            }
            this.quickHull(a, c, al1);
            this.hullX.push(this.x[c]);
            this.hullY.push(this.y[c]);
            this.quickHull(c, b, al2);
        }
        right(a, b, p) {
            const x = this.x, y = this.y;
            return (x[a] - x[b]) * (y[p] - y[b]) - (x[p] - x[b]) * (y[a] - y[b]);
        }
        distance(a, b, p) {
            const x = this.x, y = this.y;
            let u = ((x[p] - x[a]) * (x[b] - x[a]) + (y[p] - y[a]) * (y[b] - y[a])) / ((x[b] - x[a]) * (x[b] - x[a]) + (y[b] - y[a]) * (y[b] - y[a]));
            let ux = x[a] + u * (x[b] - x[a]);
            let uy = y[a] + u * (y[b] - y[a]);
            return ((ux - x[p]) * (ux - x[p]) + (uy - y[p]) * (uy - y[p]));
        }
        furthestPoint(a, b, al) {
            let maxDist = -1;
            let maxPos = -1;
            for (let n = 0; n < al.length; n++) {
                let p = al[n];
                if (p == a || p == b)
                    continue;
                let dist = this.distance(a, b, p);
                if (dist > maxDist) {
                    maxDist = dist;
                    maxPos = p;
                }
            }
            return maxPos;
        }
    }
    WebMolKit.QuickHull = QuickHull;
    class Pos {
        constructor(x, y) {
            this.x = x == null ? 0 : x;
            this.y = y == null ? 0 : y;
        }
        static zero() { return new Pos(); }
        static fromArray(src) { return new Pos(src[0], src[1]); }
        clone() { return new Pos(this.x, this.y); }
        scaleBy(mag) {
            if (mag == 1)
                return;
            this.x *= mag;
            this.y *= mag;
        }
        offsetBy(dx, dy) {
            this.x += dx;
            this.y += dy;
        }
        toString() { return '[' + this.x + ',' + this.y + ']'; }
    }
    WebMolKit.Pos = Pos;
    class Size {
        constructor(w, h) {
            this.w = w == null ? 0 : w;
            this.h = h == null ? 0 : h;
        }
        static zero() { return new Size(); }
        static fromArray(src) { return new Size(src[0], src[1]); }
        clone() { return new Size(this.w, this.h); }
        scaleBy(mag) {
            if (mag == 1)
                return;
            this.w *= mag;
            this.h *= mag;
        }
        fitInto(maxW, maxH) {
            let scale = 1;
            if (this.w > maxW)
                scale = maxW / this.w;
            if (this.h > maxH)
                scale = Math.min(scale, maxH / this.h);
            if (scale < 1)
                this.scaleBy(scale);
        }
        toString() { return '[' + this.w + ',' + this.h + ']'; }
    }
    WebMolKit.Size = Size;
    class Box {
        constructor(x, y, w, h) {
            this.x = x == null ? 0 : x;
            this.y = y == null ? 0 : y;
            this.w = w == null ? 0 : w;
            this.h = h == null ? 0 : h;
        }
        static zero() { return new Box(); }
        static fromSize(sz) { return new Box(0, 0, sz.w, sz.h); }
        static fromOval(oval) { return new Box(oval.cx - oval.rw, oval.cy - oval.rh, 2 * oval.rw, 2 * oval.rh); }
        static fromArray(src) { return new Box(src[0], src[1], src[2], src[3]); }
        clone() { return new Box(this.x, this.y, this.w, this.h); }
        setPos(pos) {
            this.x = pos.x;
            this.y = pos.y;
        }
        setSize(sz) {
            this.w = sz.w;
            this.h = sz.h;
        }
        minX() { return this.x; }
        minY() { return this.y; }
        midX() { return this.x + 0.5 * this.w; }
        midY() { return this.y + 0.5 * this.h; }
        maxX() { return this.x + this.w; }
        maxY() { return this.y + this.h; }
        scaleBy(mag) {
            if (mag == 1)
                return;
            this.x *= mag;
            this.y *= mag;
            this.w *= mag;
            this.h *= mag;
        }
        offsetBy(dx, dy) {
            this.x += dx;
            this.y += dy;
        }
        intersects(other) {
            return GeomUtil.rectsIntersect(this.x, this.y, this.w, this.h, other.x, other.y, other.w, other.h);
        }
        contains(x, y) {
            return x >= this.x && x < this.x + this.w && y >= this.y && y < this.y + this.h;
        }
        union(other) {
            let x1 = Math.min(this.x, other.x), x2 = Math.max(this.x + this.w, other.x + other.w);
            let y1 = Math.min(this.y, other.y), y2 = Math.max(this.y + this.h, other.y + other.h);
            return new Box(x1, y1, x2 - x1, y2 - y1);
        }
        isEmpty() { return this.w == 0 && this.h == 0; }
        notEmpty() { return this.w > 0 || this.h > 0; }
        toString() { return '[' + this.x + ',' + this.y + ';' + this.w + ',' + this.h + ']'; }
    }
    WebMolKit.Box = Box;
    class Oval {
        constructor(cx, cy, rw, rh) {
            this.cx = cx == null ? 0 : cx;
            this.cy = cy == null ? 0 : cy;
            this.rw = rw == null ? 0 : rw;
            this.rh = rh == null ? 0 : rh;
        }
        static zero() { return new Oval(); }
        static fromBox(box) { return new Oval(box.x + 0.5 * box.w, box.y + 0.5 * box.h, 0.5 * box.w, 0.5 * box.h); }
        static fromArray(src) { return new Oval(src[0], src[1], src[2], src[3]); }
        clone() { return new Oval(this.cx, this.cy, this.rw, this.rh); }
        setCentre(pos) {
            this.cx = pos.x;
            this.cy = pos.y;
        }
        setRadius(sz) {
            this.rw = sz.w;
            this.rh = sz.h;
        }
        minX() { return this.cx - this.rw; }
        minY() { return this.cy - this.rh; }
        maxX() { return this.cx + this.rw; }
        maxY() { return this.cy + this.rh; }
        scaleBy(mag) {
            if (mag == 1)
                return;
            this.cx *= mag;
            this.cy *= mag;
            this.rw *= mag;
            this.rh *= mag;
        }
        offsetBy(dx, dy) {
            this.cx += dx;
            this.cy += dy;
        }
        toString() { return '[' + this.cx + ',' + this.cy + ';' + this.rw + ',' + this.rh + ']'; }
    }
    WebMolKit.Oval = Oval;
    class Line {
        constructor(x1, y1, x2, y2) {
            this.x1 = x1 == null ? 0 : x1;
            this.y1 = y1 == null ? 0 : y1;
            this.x2 = x2 == null ? 0 : x2;
            this.y2 = y2 == null ? 0 : y2;
        }
        static zero() { return new Line(); }
        clone() { return new Line(this.x1, this.y1, this.x2, this.y2); }
        setPos1(pos) {
            this.x1 = pos.x;
            this.y1 = pos.y;
        }
        setPos2(pos) {
            this.x2 = pos.x;
            this.y2 = pos.y;
        }
        minX() { return Math.min(this.x1, this.x2); }
        minY() { return Math.min(this.y1, this.y2); }
        maxX() { return Math.max(this.x1, this.x2); }
        maxY() { return Math.max(this.y1, this.y2); }
        scaleBy(mag) {
            if (mag == 1)
                return;
            this.x1 *= mag;
            this.y1 *= mag;
            this.x2 *= mag;
            this.y2 *= mag;
        }
        offsetBy(dx, dy) {
            this.x1 += dx;
            this.y1 += dy;
            this.x2 += dx;
            this.y2 += dy;
        }
        toString() { return '[' + this.x1 + ',' + this.y1 + ';' + this.x2 + ',' + this.y2 + ']'; }
    }
    WebMolKit.Line = Line;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class FontData {
        constructor() {
            this.UNITS_PER_EM = 2048;
            this.INV_UNITS_PER_EM = 1.0 / this.UNITS_PER_EM;
            this.PANOSE_1 = '2 11 6 4 3 5 4 4 2 4';
            this.ASCENT = 1638;
            this.DESCENT = -410;
            this.MISSING_HORZ = 2048;
            this.MISSING_DATA = 'M256 0v1536h1536v-1536h-1536zM384 128h1280v1280h-1280v-1280z';
            this.ASCENT_FUDGE = 0.75;
            this.UNICODE = [
                ' ', '!', '"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<',
                '=', '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
                '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',
                'x', 'y', 'z', '{', '|', '}', '~', '\u00A0', '\u00A1', '\u00A2', '\u00A3', '\u00A4', '\u00A5', '\u00A6', '\u00A7', '\u00A8', '\u00A9', '\u00AA',
                '\u00AB', '\u00AC', '\u00AD', '\u00AE', '\u00AF', '\u00B0', '\u00B1', '\u00B2', '\u00B3', '\u00B4', '\u00B5', '\u00B6', '\u00B7', '\u00B8', '\u00B9',
                '\u00BA', '\u00BB', '\u00BC', '\u00BD', '\u00BE', '\u00BF', '\u00C0', '\u00C1', '\u00C2', '\u00C3', '\u00C4', '\u00C5', '\u00C6', '\u00C7', '\u00C8',
                '\u00C9', '\u00CA', '\u00CB', '\u00CC', '\u00CD', '\u00CE', '\u00CF', '\u00D0', '\u00D1', '\u00D2', '\u00D3', '\u00D4', '\u00D5', '\u00D6', '\u00D7',
                '\u00D8', '\u00D9', '\u00DA', '\u00DB', '\u00DC', '\u00DD', '\u00DE', '\u00DF', '\u00E0', '\u00E1', '\u00E2', '\u00E3', '\u00E4', '\u00E5', '\u00E6',
                '\u00E7', '\u00E8', '\u00E9', '\u00EA', '\u00EB', '\u00EC', '\u00ED', '\u00EE', '\u00EF', '\u00F0', '\u00F1', '\u00F2', '\u00F3', '\u00F4', '\u00F5',
                '\u00F6', '\u00F7', '\u00F8', '\u00F9', '\u00FA', '\u00FB', '\u00FC', '\u00FD', '\u00FE', '\u037E', '\u0384', '\u0385', '\u0386', '\u0387', '\u0388',
                '\u0389', '\u038A', '\u038C', '\u038E', '\u038F', '\u0390', '\u0391', '\u0392', '\u0393', '\u0394', '\u0395', '\u0396', '\u0397', '\u0398', '\u0399',
                '\u039A', '\u039B', '\u039C', '\u039D', '\u039E', '\u039F', '\u03A0', '\u03A1', '\u03A3', '\u03A4', '\u03A5', '\u03A6', '\u03A7', '\u03A8', '\u03A9',
                '\u03AA', '\u03AB', '\u03AC', '\u03AD', '\u03AE', '\u03AF', '\u03B0', '\u03B1', '\u03B2', '\u03B3', '\u03B4', '\u03B5', '\u03B6', '\u03B7', '\u03B8',
                '\u03B9', '\u03BA', '\u03BB', '\u03BC', '\u03BD', '\u03BE', '\u03BF', '\u03C0', '\u03C1', '\u03C2', '\u03C3', '\u03C4', '\u03C5', '\u03C6', '\u03C7',
                '\u03C8', '\u03C9', '\u03CA', '\u03CB', '\u03CC', '\u03CD', '\u03CE', '\u2202', '\u2206', '\u220F', '\u2211', '\u2212', '\u2215', '\u2219', '\u221A',
                '\u221E', '\u222B', '\u2248', '\u2260', '\u2264', '\u2265'
            ];
            this.HORIZ_ADV_X = [
                720, 806, 940, 1676, 1302, 2204, 1488, 550, 930, 930, 1302, 1676, 745, 930, 745, 930, 1302, 1302, 1302, 1302, 1302, 1302, 1302, 1302, 1302, 1302,
                930, 930, 1676, 1676, 1676, 1117, 2048, 1400, 1404, 1430, 1578, 1295, 1177, 1588, 1539, 862, 931, 1419, 1140, 1726, 1532, 1612, 1235, 1612, 1424,
                1400, 1262, 1499, 1400, 2025, 1403, 1260, 1403, 930, 930, 930, 1676, 1302, 1302, 1230, 1276, 1067, 1276, 1220, 720, 1276, 1296, 562, 705, 1212, 562,
                1992, 1296, 1243, 1276, 1276, 874, 1067, 807, 1296, 1212, 1676, 1212, 1212, 1076, 1300, 930, 1300, 1676, 720, 806, 1302, 1302, 1302, 1302, 930, 1302,
                1302, 2048, 1117, 1320, 1676, 930, 2048, 1302, 1110, 1676, 1110, 1110, 1302, 1314, 1302, 745, 1302, 1110, 1117, 1320, 2048, 2048, 2048, 1117, 1400,
                1400, 1400, 1400, 1400, 1400, 2016, 1430, 1295, 1295, 1295, 1295, 862, 862, 862, 862, 1588, 1532, 1612, 1612, 1612, 1612, 1612, 1676, 1612, 1499,
                1499, 1499, 1499, 1260, 1240, 1270, 1230, 1230, 1230, 1230, 1230, 1230, 1956, 1067, 1220, 1220, 1220, 1220, 562, 562, 562, 562, 1253, 1296, 1243,
                1243, 1243, 1243, 1243, 1676, 1243, 1296, 1296, 1296, 1296, 1212, 1276, 930, 1302, 1302, 1400, 930, 1538, 1782, 1105, 1804, 1543, 1859, 562, 1400,
                1404, 1160, 1440, 1295, 1403, 1539, 1612, 862, 1419, 1404, 1726, 1532, 1329, 1612, 1539, 1235, 1377, 1262, 1260, 1677, 1403, 1783, 1676, 862, 1260,
                1276, 1050, 1296, 562, 1293, 1276, 1270, 1212, 1245, 1050, 937, 1296, 1278, 562, 1212, 1212, 1310, 1212, 1030, 1243, 1305, 1280, 1040, 1291, 1016,
                1293, 1618, 1208, 1683, 1666, 562, 1293, 1243, 1293, 1666, 1302, 1489, 1676, 1489, 1676, 740, 745, 1676, 2048, 1302, 1676, 1676, 1676, 1676
            ];
            this.GLYPH_DATA = [
                '',
                'M515 1489l-26 -1079h-170l-28 1079h224zM505 0h-204v211h204v-211z',
                'M772 1556l-43 -579h-132l-43 579h218zM386 1556l-43 -579h-132l-43 579h218z',
                'M1481 932h-333l-92 -376h308v-135h-343l-104 -421h-129l104 421h-270l-104 -421h-129l104 421h-298v135h333l92 376h-308v135h343l105 422h129l-105 -422h270l105 422h129l-105 -422h298v-135zM1022 934h-274l-94 -380h274z',
                'M1160 380q0 -155 -121 -257.5t-317 -121.5v-362h-118v357q-132 1 -248 25.5t-201 63.5v198h16q19 -14 68 -40.5t95 -43.5q52 -19 121.5 -35.5t148.5 -19.5v433q-40 8 -74 15.5t-63 15.5q-163 41 -234 123.5t-71 203.5q0 148 116.5 250t325.5 119v272h118v-270 q101 -2 207 -24t178 -51v-196h-14q-75 46 -156.5 81.5t-214.5 44.5v-431q30 -5 65 -13.5t61 -13.5q149 -32 230.5 -110t81.5 -213zM604 747v413q-107 -8 -180 -58.5t-73 -140.5q0 -91 54 -137t199 -77zM971 354q0 94 -58.5 137.5t-190.5 68.5v-414q120 12 184.5 61t64.5 147 z',
                'M884 1076q0 -224 -94.5 -333t-272.5 -109q-182 0 -275 109t-93 332q0 224 95 333t273 109q181 0 274 -110t93 -331zM1575 1489l-780 -1489h-165l780 1489h165zM2055 413q0 -224 -95 -333t-273 -109q-181 0 -274 110t-93 331q0 224 94.5 333t272.5 109q182 0 275 -109 t93 -332zM706 1076q0 172 -44.5 240t-144.5 68q-102 0 -146 -68t-44 -241t44 -240.5t146 -67.5q100 0 144.5 67.5t44.5 241.5zM1877 413q0 172 -44.5 240t-144.5 68q-102 0 -146 -68t-44 -241t44 -240.5t146 -67.5q100 0 144.5 67.5t44.5 241.5z',
                'M792 1191q0 95 -56.5 149.5t-144.5 54.5q-92 0 -150 -61.5t-58 -150.5q0 -75 39.5 -133t170.5 -137q98 35 148.5 102.5t50.5 175.5zM986 315l-478 466q-31 -15 -62 -39.5t-62 -66.5q-28 -39 -46 -94t-18 -124q0 -146 85.5 -235.5t242.5 -89.5q93 0 184.5 45.5 t153.5 137.5zM1287 909v-96q0 -96 -25 -216t-85 -229l378 -368h-246l-229 224q-115 -142 -235 -198.5t-247 -56.5q-208 0 -345.5 121.5t-137.5 318.5q0 92 26 159t61 116q35 47 87 88.5t105 72.5q-110 72 -158.5 145t-48.5 184q0 67 26.5 127.5t79.5 110.5q50 48 130.5 78 t177.5 30q173 0 280 -87.5t107 -221.5q0 -44 -12 -99.5t-41 -99.5q-32 -49 -91 -94t-153 -77l371 -362q14 40 21 88t8 100q2 56 1.5 125t-0.5 117h195z',
                'M386 1556l-43 -579h-136l-43 579h222z',
                'M783 -412h-229q-177 203 -275 443t-98 541t98 541t275 443h229v-10q-81 -73 -154.5 -168.5t-136.5 -222.5q-60 -123 -97.5 -271t-37.5 -312q0 -171 36.5 -313t98.5 -270q60 -123 137 -222.5t154 -168.5v-10z',
                'M749 572q0 -301 -98 -541t-275 -443h-229v10q77 69 154.5 168.5t136.5 222.5q62 128 98.5 270t36.5 313q0 164 -37 312t-98 271q-63 127 -136.5 222.5t-154.5 168.5v10h229q177 -203 275 -443t98 -541z',
                'M1137 887l-64 -110l-362 213l6 -360h-129l5 360l-361 -214l-65 110l381 207l-381 207l65 110l362 -213l-6 359h129l-7 -359l363 212l64 -110l-380 -205z',
                'M1466 572h-545v-545h-166v545h-545v160h545v545h166v-545h545v-160z',
                'M575 285l-282 -655h-146l174 655h254z',
                'M777 561h-624v181h624v-181z',
                'M492 0h-239v285h239v-285z',
                'M860 1556l-717 -1860h-173l714 1860h176z',
                'M1167 745q0 -401 -125.5 -588.5t-389.5 -187.5q-268 0 -391.5 190t-123.5 584q0 397 125 586.5t390 189.5q268 0 391.5 -192.5t123.5 -581.5zM904 291q35 81 47.5 190.5t12.5 263.5q0 152 -12.5 264t-48.5 190q-35 77 -95.5 116t-155.5 39q-94 0 -155.5 -39t-97.5 -118 q-34 -74 -46.5 -193t-12.5 -261q0 -156 11 -261t47 -188q33 -78 93.5 -119t160.5 -41q94 0 156 39t96 118z',
                'M1084 0h-806v152h310v998h-310v136q63 0 135 10.5t109 30.5q46 25 72.5 63.5t30.5 103.5h155v-1342h304v-152z',
                'M1169 0h-1008v209q105 90 210.5 180t196.5 179q192 186 263 295.5t71 236.5q0 116 -76.5 181.5t-213.5 65.5q-91 0 -197 -32t-207 -98h-10v210q71 35 189.5 64t229.5 29q229 0 359 -110.5t130 -299.5q0 -85 -21.5 -158.5t-63.5 -139.5q-39 -62 -91.5 -122t-127.5 -133 q-107 -105 -221 -203.5t-213 -182.5h801v-171z',
                'M1038 717q48 -43 79 -108t31 -168q0 -102 -37 -187t-104 -148q-75 -70 -176.5 -103.5t-222.5 -33.5q-124 0 -244 29.5t-197 64.5v209h15q85 -56 200 -93t222 -37q63 0 134 21t115 62q46 44 68.5 97t22.5 134q0 80 -25.5 132.5t-70.5 82.5q-45 31 -109 42.5t-138 11.5h-90 v166h70q152 0 242.5 63.5t90.5 185.5q0 54 -23 94.5t-64 66.5q-43 26 -92 36t-111 10q-95 0 -202 -34t-202 -96h-10v209q71 35 189.5 64.5t229.5 29.5q109 0 192 -20t150 -64q72 -48 109 -116t37 -159q0 -124 -87.5 -216.5t-206.5 -116.5v-14q48 -8 110 -33.5t105 -63.5z ',
                'M1203 419h-221v-419h-192v419h-713v230l721 840h184v-910h221v-160zM790 579v672l-577 -672h577z',
                'M1157 473q0 -104 -38 -199t-104 -160q-72 -70 -171.5 -107.5t-230.5 -37.5q-122 0 -235 25.5t-191 61.5v211h14q82 -52 192 -88.5t216 -36.5q71 0 137.5 20t118.5 70q44 43 66.5 103t22.5 139q0 77 -26.5 130t-73.5 85q-52 38 -126.5 53.5t-166.5 15.5q-88 0 -169.5 -12 t-140.5 -24v767h896v-175h-703v-396q43 4 88 6t78 2q121 0 212 -20.5t167 -72.5q80 -55 124 -142t44 -218z',
                'M1191 483q0 -227 -149.5 -370.5t-366.5 -143.5q-110 0 -200 34t-159 101q-86 83 -132.5 220t-46.5 330q0 198 42.5 351t135.5 272q88 113 227 176.5t324 63.5q59 0 99 -5t81 -18v-191h-10q-28 15 -84.5 28.5t-115.5 13.5q-215 0 -343 -134.5t-149 -363.5 q84 51 165.5 77.5t188.5 26.5q95 0 167.5 -17.5t148.5 -70.5q88 -61 132.5 -154t44.5 -226zM988 475q0 93 -27.5 154t-90.5 106q-46 32 -102 42t-117 10q-85 0 -158 -20t-150 -62q-2 -22 -3 -42.5t-1 -51.5q0 -158 32.5 -249.5t89.5 -144.5q46 -44 99.5 -64.5t116.5 -20.5 q145 0 228 88.5t83 254.5z',
                'M1173 1266l-674 -1266h-214l717 1314h-848v175h1019v-223z',
                'M1180 415q0 -193 -150.5 -321t-378.5 -128q-242 0 -385.5 125t-143.5 320q0 124 72 224.5t203 159.5v6q-120 64 -177.5 140t-57.5 190q0 168 138 280t351 112q223 0 356 -107t133 -272q0 -101 -63 -198.5t-185 -152.5v-6q140 -60 214 -148t74 -224zM943 1142 q0 107 -82.5 170.5t-210.5 63.5q-126 0 -206.5 -60t-80.5 -162q0 -72 40.5 -124.5t122.5 -93.5q37 -18 106.5 -47t135.5 -48q99 66 137 137t38 164zM974 396q0 92 -40.5 147.5t-158.5 111.5q-47 22 -103 41t-149 53q-90 -49 -144.5 -133t-54.5 -190q0 -135 93 -223t236 -88 q146 0 233.5 75t87.5 206z',
                'M1167 834q0 -195 -44.5 -354t-134.5 -271q-91 -114 -228 -176t-322 -62q-52 0 -98 5.5t-82 17.5v191h10q29 -15 82 -28.5t118 -13.5q221 0 346.5 132.5t145.5 365.5q-93 -56 -175 -80t-179 -24q-92 0 -166.5 18t-149.5 70q-88 61 -132.5 155t-44.5 225q0 228 150 371 t366 143q108 0 200 -33.5t161 -100.5q85 -83 131 -213.5t46 -337.5zM965 877q0 155 -32 249t-88 146q-47 45 -101 64.5t-117 19.5q-144 0 -227.5 -90t-83.5 -253q0 -95 27 -155t91 -105q45 -31 99 -41.5t120 -10.5q78 0 158 21t150 61q1 21 2.5 41.5t1.5 52.5z',
                'M585 832h-239v285h239v-285zM585 0h-239v285h239v-285z',
                'M585 832h-239v285h239v-285zM658 285l-282 -655h-146l174 655h254z',
                'M1408 77l-1154 513v124l1154 513v-180l-910 -395l910 -395v-180z',
                'M1431 782h-1186v160h1186v-160zM1431 362h-1186v160h1186v-160z',
                'M1422 590l-1154 -513v180l910 395l-910 395v180l1154 -513v-124z',
                'M1005 1139q0 -98 -35 -174.5t-92 -135.5q-56 -57 -129 -107t-155 -97v-225h-179v305q65 37 140.5 81t123.5 89q58 52 90 107.5t32 141.5q0 113 -76.5 168.5t-197.5 55.5q-108 0 -204.5 -34t-152.5 -69h-10v204q70 27 177.5 48.5t203.5 21.5q215 0 339.5 -104.5 t124.5 -275.5zM610 0h-204v211h204v-211z',
                'M1870 663q0 -139 -40.5 -269t-115.5 -237h-440l-27 116q-74 -60 -142 -92t-156 -32q-168 0 -268.5 127t-100.5 355q0 227 123 362t294 135q73 0 129 -16.5t121 -49.5v48h159v-842h243q42 75 63.5 187.5t21.5 201.5q0 164 -45.5 298t-133.5 230t-218 147.5t-295 51.5 q-160 0 -292.5 -58t-227.5 -156q-96 -98 -150.5 -234.5t-54.5 -290.5q0 -165 52 -301.5t147 -233.5q99 -101 232 -152.5t290 -51.5q86 0 177.5 11t175.5 35v-142q-97 -21 -181 -28.5t-173 -7.5q-186 0 -345 63.5t-273 177.5q-115 115 -179 276t-64 356q0 185 67 344.5 t183 276.5t275 184t340 67q196 0 350 -62t260 -174t162.5 -269.5t56.5 -350.5zM1245 408v518q-63 29 -113 41.5t-107 12.5q-129 0 -202 -90t-73 -256q0 -163 58 -246.5t181 -83.5q67 0 134 31t122 73z',
                'M1374 0h-211l-146 415h-644l-146 -415h-201l542 1489h264zM956 585l-261 731l-262 -731h523z',
                'M1323 458q0 -111 -42 -196t-113 -140q-84 -66 -184.5 -94t-255.5 -28h-528v1489h441q163 0 244 -12t155 -50q82 -43 119 -110.5t37 -161.5q0 -106 -54 -180.5t-144 -119.5v-8q151 -31 238 -132.5t87 -256.5zM990 1129q0 54 -18 91t-58 60q-47 27 -114 33.5t-166 6.5h-236 v-430h256q93 0 148 9.5t102 39.5t66.5 77.5t19.5 112.5zM1117 450q0 90 -27 143t-98 90q-48 25 -116.5 32.5t-166.5 7.5h-311v-554h262q130 0 213 13.5t136 49.5q56 39 82 89t26 129z',
                'M1350 108q-55 -24 -99.5 -45t-116.5 -44q-61 -19 -132.5 -32.5t-157.5 -13.5q-162 0 -294.5 45.5t-230.5 142.5q-96 95 -150 241.5t-54 340.5q0 184 52 329t150 245q95 97 229.5 148t298.5 51q120 0 239.5 -29t265.5 -102v-235h-15q-123 103 -244 150t-259 47 q-113 0 -203.5 -36.5t-161.5 -113.5q-69 -75 -107.5 -189.5t-38.5 -264.5q0 -157 42.5 -270t109.5 -184q70 -74 163.5 -109.5t197.5 -35.5q143 0 268 49t234 147h14v-232z',
                'M1458 743q0 -203 -88.5 -368t-235.5 -256q-102 -63 -227.5 -91t-330.5 -28h-376v1489h372q218 0 346.5 -31.5t217.5 -86.5q152 -95 237 -253t85 -375zM1251 746q0 175 -61 295t-182 189q-88 50 -187 69.5t-237 19.5h-186v-1149h186q143 0 249.5 21t195.5 78 q111 71 166.5 187t55.5 290z',
                'M1181 0h-981v1489h981v-176h-783v-408h783v-176h-783v-553h783v-176z',
                'M1151 1313h-753v-420h647v-176h-647v-717h-198v1489h951v-176z',
                'M1442 110q-122 -56 -266.5 -97.5t-279.5 -41.5q-174 0 -319 48t-247 144q-103 97 -159 242.5t-56 340.5q0 357 208.5 563.5t572.5 206.5q127 0 259.5 -30.5t285.5 -103.5v-235h-18q-31 24 -90 63t-116 65q-69 31 -156.5 51.5t-198.5 20.5q-250 0 -395.5 -160.5 t-145.5 -434.5q0 -289 152 -449.5t414 -160.5q96 0 191.5 19t167.5 49v365h-399v174h595v-639z',
                'M1339 0h-198v729h-743v-729h-198v1489h198v-584h743v584h198v-1489z',
                'M725 0h-588v152h195v1185h-195v152h588v-152h-195v-1185h195v-152z',
                'M746 387q0 -196 -119.5 -302t-320.5 -106q-48 0 -128 8.5t-134 20.5v185h11q41 -14 101 -29t123 -15q92 0 146.5 21t80.5 60q27 40 34.5 98t7.5 134v869h-315v158h513v-1102z',
                'M1397 0h-257l-589 663l-148 -158v-505h-198v1489h198v-777l723 777h240l-665 -700z',
                'M1142 0h-942v1489h198v-1313h744v-176z',
                'M1526 0h-198v1283l-414 -873h-118l-411 873v-1283h-185v1489h270l397 -829l384 829h275v-1489z',
                'M1336 0h-245l-706 1332v-1332h-185v1489h307l644 -1216v1216h185v-1489z',
                'M1310 1318q91 -100 139.5 -245t48.5 -329t-49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5zM1292 744 q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5z',
                'M1174 1039q0 -99 -34.5 -183.5t-96.5 -146.5q-77 -77 -182 -115.5t-265 -38.5h-198v-555h-198v1489h404q134 0 227 -22.5t165 -70.5q85 -57 131.5 -142t46.5 -215zM968 1034q0 77 -27 134t-82 93q-48 31 -109.5 44.5t-155.5 13.5h-196v-595h167q120 0 195 21.5t122 68.5 q47 48 66.5 101t19.5 119z',
                'M1528 -365q-60 -15 -118.5 -21.5t-119.5 -6.5q-174 0 -279.5 95.5t-114.5 273.5q-24 -4 -46.5 -5.5t-43.5 -1.5q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5 q91 -100 139.5 -245t48.5 -329q0 -273 -111.5 -460t-299.5 -262q4 -114 54 -177t182 -63q41 0 97.5 12.5t80.5 22.5h27v-182zM1292 744q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5z',
                'M1432 0h-257l-498 592h-279v-592h-198v1489h417q135 0 225 -17.5t162 -62.5q81 -51 126.5 -128.5t45.5 -196.5q0 -161 -81 -269.5t-223 -163.5zM969 1070q0 64 -22.5 113.5t-74.5 83.5q-43 29 -102 40.5t-139 11.5h-233v-562h200q94 0 164 16.5t119 61.5q45 42 66.5 96.5 t21.5 138.5z',
                'M1282 425q0 -87 -40.5 -172t-113.5 -144q-80 -64 -186.5 -100t-256.5 -36q-161 0 -289.5 30t-261.5 89v248h14q113 -94 261 -145t278 -51q184 0 286.5 69t102.5 184q0 99 -48.5 146t-147.5 73q-75 20 -162.5 33t-185.5 33q-198 42 -293.5 143.5t-95.5 264.5 q0 187 158 306.5t401 119.5q157 0 288 -30t232 -74v-234h-14q-85 72 -223.5 119.5t-283.5 47.5q-159 0 -255.5 -66t-96.5 -170q0 -93 48 -146t169 -81q64 -14 182 -34t200 -41q166 -44 250 -133t84 -249z',
                'M1262 1313h-532v-1313h-198v1313h-532v176h1262v-176z',
                'M1321 598q0 -162 -35.5 -282.5t-116.5 -200.5q-77 -76 -180 -111t-240 -35q-140 0 -244 37t-175 109q-81 82 -116.5 198t-35.5 285v891h198v-901q0 -121 16.5 -191t55.5 -127q44 -65 119.5 -98t181.5 -33q107 0 182 32.5t120 98.5q39 57 55.5 130.5t16.5 182.5v906h198 v-891z',
                'M1374 1489l-542 -1489h-264l-542 1489h212l467 -1310l467 1310h202z',
                'M1933 1489l-387 -1489h-223l-313 1236l-306 -1236h-218l-394 1489h203l313 -1238l308 1238h201l311 -1250l311 1250h194z',
                'M1336 1489l-514 -736l513 -753h-229l-406 613l-416 -613h-216l519 744l-507 745h228l401 -605l410 605h217z',
                'M1254 1489l-524 -836v-653h-198v632l-526 857h219l407 -666l411 666h211z',
                'M1288 0h-1162v184l913 1129h-879v176h1106v-179l-922 -1134h944v-176z',
                'M759 -392h-520v1948h520v-143h-346v-1662h346v-143z',
                'M960 -304h-173l-717 1860h176z',
                'M691 -392h-520v143h346v1662h-346v143h520v-1948z',
                'M1490 684h-198l-455 627l-454 -629h-197l589 807h126z',
                'M1306 -300h-1310v120h1310v-120z',
                'M762 1302h-149l-273 374h243z',
                'M1053 0h-187v119q-25 -17 -67.5 -47.5t-82.5 -48.5q-47 -23 -108 -38.5t-143 -15.5q-151 0 -256 100t-105 255q0 127 54.5 205.5t155.5 123.5q102 45 245 61t307 24v29q0 64 -22.5 106t-64.5 66q-40 23 -96 31t-117 8q-74 0 -165 -19.5t-188 -56.5h-10v191q55 15 159 33 t205 18q118 0 205.5 -19.5t151.5 -66.5q63 -46 96 -119t33 -181v-758zM866 275v311q-86 -5 -202.5 -15t-184.5 -29q-81 -23 -131 -71.5t-50 -133.5q0 -96 58 -144.5t177 -48.5q99 0 181 38.5t152 92.5z',
                'M1168 567q0 -140 -39.5 -252t-106.5 -188q-71 -79 -156 -118.5t-187 -39.5q-95 0 -166 22.5t-140 60.5l-12 -52h-176v1556h188v-556q79 65 168 106.5t200 41.5q198 0 312.5 -152t114.5 -429zM974 562q0 200 -66 303.5t-213 103.5q-82 0 -166 -35.5t-156 -91.5v-640 q80 -36 137.5 -50t130.5 -14q156 0 244.5 102.5t88.5 321.5z',
                'M1011 70q-94 -45 -178.5 -70t-179.5 -25q-121 0 -222 35.5t-173 107.5q-73 72 -113 182t-40 257q0 274 150.5 430t397.5 156q96 0 188.5 -27t169.5 -66v-209h-10q-86 67 -177.5 103t-178.5 36q-160 0 -252.5 -107.5t-92.5 -315.5q0 -202 90.5 -310.5t254.5 -108.5 q57 0 116 15t106 39q41 21 77 44.5t57 40.5h10v-207z',
                'M1091 0h-188v117q-81 -70 -169 -109t-191 -39q-200 0 -317.5 154t-117.5 427q0 142 40.5 253t109.5 189q68 76 158.5 116t187.5 40q88 0 156 -18.5t143 -57.5v484h188v-1556zM903 275v641q-76 34 -136 47t-131 13q-158 0 -246 -110t-88 -312q0 -199 68 -302.5t218 -103.5 q80 0 162 35.5t153 91.5z',
                'M1120 539h-823q0 -103 31 -179.5t85 -125.5q52 -48 123.5 -72t157.5 -24q114 0 229.5 45.5t164.5 89.5h10v-205q-95 -40 -194 -67t-208 -27q-278 0 -434 150.5t-156 427.5q0 274 149.5 435t393.5 161q226 0 348.5 -132t122.5 -375v-102zM937 683q-1 148 -74.5 229 t-223.5 81q-151 0 -240.5 -89t-101.5 -221h640z',
                'M786 1374h-10q-31 9 -81 18.5t-88 9.5q-121 0 -175.5 -53.5t-54.5 -193.5v-38h339v-158h-333v-959h-188v959h-127v158h127v37q0 199 99 305.5t286 106.5q63 0 113.5 -6t92.5 -14v-172z',
                'M1091 127q0 -284 -129 -417t-397 -133q-89 0 -173.5 12.5t-166.5 35.5v192h10q46 -18 146 -44.5t200 -26.5q96 0 159 23t98 64q35 39 50 94t15 123v102q-85 -68 -162.5 -101.5t-197.5 -33.5q-200 0 -317.5 144.5t-117.5 407.5q0 144 40.5 248.5t110.5 180.5 q65 71 158 110.5t185 39.5q97 0 162.5 -19.5t138.5 -59.5l12 48h176v-990zM903 307v609q-75 34 -139.5 48.5t-128.5 14.5q-155 0 -244 -104t-89 -302q0 -188 66 -285t219 -97q82 0 164.5 31.5t151.5 84.5z',
                'M1119 0h-188v636q0 77 -9 144.5t-33 105.5q-25 42 -72 62.5t-122 20.5q-77 0 -161 -38t-161 -97v-834h-188v1556h188v-563q88 73 182 114t193 41q181 0 276 -109t95 -314v-725z',
                'M387 1304h-212v195h212v-195zM375 0h-188v1117h188v-1117z',
                'M533 1304h-212v195h212v-195zM521 -27q0 -196 -100 -296t-268 -100q-40 0 -105.5 8t-109.5 20v179h10q28 -11 75.5 -25t92.5 -14q72 0 116 20t66 60t28.5 96.5t6.5 137.5v900h-233v158h421v-1144z',
                'M1199 0h-248l-448 489l-122 -116v-373h-188v1556h188v-998l543 559h237l-519 -516z',
                'M375 0h-188v1556h188v-1556z',
                'M1815 0h-188v636q0 72 -6.5 139t-27.5 107q-23 43 -66 65t-124 22q-79 0 -158 -39.5t-158 -100.5q3 -23 5 -53.5t2 -60.5v-715h-188v636q0 74 -6.5 140.5t-27.5 106.5q-23 43 -66 64.5t-124 21.5q-77 0 -154.5 -38t-154.5 -97v-834h-188v1117h188v-124q88 73 175.5 114 t186.5 41q114 0 193.5 -48t118.5 -133q114 96 208 138.5t201 42.5q184 0 271.5 -111.5t87.5 -311.5v-725z',
                'M1119 0h-188v636q0 77 -9 144.5t-33 105.5q-25 42 -72 62.5t-122 20.5q-77 0 -161 -38t-161 -97v-834h-188v1117h188v-124q88 73 182 114t193 41q181 0 276 -109t95 -314v-725z',
                'M1137 558q0 -273 -140 -431t-375 -158q-237 0 -376.5 158t-139.5 431t139.5 431.5t376.5 158.5q235 0 375 -158.5t140 -431.5zM943 558q0 217 -85 322.5t-236 105.5q-153 0 -237.5 -105.5t-84.5 -322.5q0 -210 85 -318.5t237 -108.5q150 0 235.5 107.5t85.5 319.5z',
                'M1168 572q0 -136 -39 -248.5t-110 -190.5q-66 -74 -155.5 -114.5t-189.5 -40.5q-87 0 -157.5 19t-143.5 59v-468h-188v1529h188v-117q75 63 168.5 105.5t199.5 42.5q202 0 314.5 -152.5t112.5 -423.5zM974 567q0 202 -69 302t-212 100q-81 0 -163 -35t-157 -92v-633 q80 -36 137.5 -49t130.5 -13q157 0 245 106t88 314z',
                'M1091 -412h-188v538q-87 -75 -173 -111.5t-186 -36.5q-199 0 -317.5 153.5t-118.5 423.5q0 144 41.5 254.5t109.5 185.5q66 73 155 113t188 40q90 0 159.5 -20t141.5 -59l12 48h176v-1529zM903 284v632q-78 35 -138 49t-130 14q-163 0 -248 -110.5t-85 -304.5 q0 -196 68.5 -301.5t215.5 -105.5q82 0 164 35.5t153 91.5z',
                'M882 912h-10q-42 10 -81.5 14.5t-93.5 4.5q-87 0 -168 -38.5t-156 -99.5v-793h-188v1117h188v-165q112 90 197.5 127.5t174.5 37.5q49 0 71 -2.5t66 -9.5v-193z',
                'M983 322q0 -153 -126.5 -251t-345.5 -98q-124 0 -227.5 29.5t-173.5 64.5v211h10q89 -67 198 -106.5t209 -39.5q124 0 194 40t70 126q0 66 -38 100t-146 58q-40 9 -104.5 21t-117.5 26q-147 39 -208.5 114.5t-61.5 185.5q0 69 28.5 130t86.5 109q56 47 142.5 74.5 t193.5 27.5q100 0 202.5 -24.5t170.5 -59.5v-201h-10q-72 53 -175 89.5t-202 36.5q-103 0 -174 -39.5t-71 -117.5q0 -69 43 -104q42 -35 136 -57q52 -12 116.5 -24t107.5 -22q131 -30 202 -103q71 -74 71 -196z',
                'M765 10q-53 -14 -115.5 -23t-111.5 -9q-171 0 -260 92t-89 295v594h-127v158h127v321h188v-321h388v-158h-388v-509q0 -88 4 -137.5t28 -92.5q22 -40 60.5 -58.5t117.5 -18.5q46 0 96 13.5t72 22.5h10v-169z',
                'M1111 0h-188v124q-95 -75 -182 -115t-192 -40q-176 0 -274 107.5t-98 315.5v725h188v-636q0 -85 8 -145.5t34 -103.5q27 -44 70 -64t125 -20q73 0 159.5 38t161.5 97v834h188v-1117z',
                'M1151 1117l-452 -1117h-189l-449 1117h204l346 -889l343 889h197z',
                'M1590 1117l-291 -1117h-174l-287 861l-285 -861h-173l-294 1117h196l205 -865l279 865h155l286 -865l194 865h189z',
                'M1152 0h-237l-317 429l-319 -429h-219l436 557l-432 560h237l315 -422l316 422h220l-439 -550z',
                'M1151 1117l-652 -1529h-201l208 466l-445 1063h204l343 -828l346 828h197z',
                'M995 0h-902v139l651 821h-637v157h871v-134l-654 -824h671v-159z',
                'M1113 -392h-150q-179 0 -290.5 99.5t-111.5 287.5v149q0 169 -83 264.5t-254 95.5h-51v156h51q171 0 254 95.5t83 264.5v149q0 188 111.5 287.5t290.5 99.5h150v-138h-114q-136 0 -197.5 -63t-61.5 -203v-175q0 -139 -77 -233.5t-214 -149.5v-24q137 -55 214 -149.5 t77 -233.5v-175q0 -140 61.5 -203t197.5 -63h114v-138z',
                'M552 -392h-174v1948h174v-1948z',
                'M1127 504h-51q-171 0 -254 -95.5t-83 -264.5v-149q0 -188 -111.5 -287.5t-290.5 -99.5h-150v138h114q136 0 197.5 63t61.5 203v175q0 139 77 233.5t214 149.5v24q-137 55 -214 149.5t-77 233.5v175q0 140 -61.5 203t-197.5 63h-114v138h150q179 0 290.5 -99.5 t111.5 -287.5v-149q0 -169 83 -264.5t254 -95.5h51v-156z',
                'M1489 927q-2 -99 -22.5 -195t-65.5 -171q-46 -77 -111 -121t-165 -44q-94 0 -167 39.5t-157 141.5q-102 125 -148 157t-96 32q-94 0 -144 -87.5t-59 -283.5h-167q2 100 22.5 194.5t64.5 171.5q43 74 112 119.5t165 45.5q93 0 166.5 -38.5t158.5 -142.5q80 -98 131 -143.5 t112 -45.5q103 0 151.5 101t51.5 270h167z',
                '',
                'M505 1278h-204v211h204v-211zM515 0h-224l26 1079h170z',
                'M1120 74q-71 -30 -161 -53.5t-194 -26.5v-355h-118v359q-227 21 -357.5 165t-130.5 394q0 242 133.5 391.5t354.5 171.5v355h118v-351q104 -3 197 -25t158 -53v-203h-11q-55 44 -142 85t-202 50v-839q120 10 206.5 52.5t137.5 83.5h11v-201zM647 142v834 q-135 -20 -216 -125t-81 -294q0 -181 76 -286t221 -129z',
                'M1163 0h-1026v207q118 32 169.5 126.5t51.5 279.5h-176v138h176v310q0 200 126.5 328.5t331.5 128.5q105 0 181 -17t140 -34v-206h-10q-62 42 -138 66t-162 24q-140 0 -209.5 -82.5t-69.5 -226.5v-291h415v-138h-415v-61q0 -126 -62 -219.5t-160 -150.5v-11h837v-171z ',
                'M1168 257l-110 -110l-236 234q-44 -26 -81 -37t-89 -11q-46 0 -89.5 12.5t-79.5 35.5l-236 -236l-109 113l233 234q-23 37 -35 81.5t-12 87.5q0 52 11 88.5t37 79.5l-234 237l111 110l235 -235q36 23 79.5 35.5t88.5 12.5q44 0 88 -12t81 -35l234 234l113 -109l-235 -237 q24 -38 36 -79.5t12 -89.5q0 -45 -12.5 -89t-35.5 -80zM832 661q0 73 -52.5 129t-127.5 56q-73 0 -126.5 -55t-53.5 -130q0 -74 52.5 -129.5t127.5 -55.5q73 0 126.5 54.5t53.5 130.5z',
                'M1191 1489l-448 -831v-94h372v-138h-370v-426h-188v426h-370v138h372v73l-451 852h212l332 -659l336 659h203z',
                'M552 758h-174v798h174v-798zM552 -392h-174v798h174v-798z',
                'M1128 601q0 -106 -59 -187t-158 -136v-7q97 -46 141 -118.5t44 -162.5q0 -77 -33 -146t-98 -119q-72 -56 -169 -83t-221 -27q-87 0 -170.5 13.5t-175.5 44.5v194h10q79 -37 169 -62t198 -25q134 0 215 48.5t81 135.5q0 56 -19.5 88.5t-64.5 57.5q-41 23 -113 41.5 t-154 38.5q-214 52 -296 133q-83 81 -83 210q0 98 57 182.5t159 141.5v7q-101 48 -143 121t-42 162q0 81 32 146.5t99 117.5q64 50 163.5 79t227.5 29q87 0 171 -14t175 -43v-194h-10q-58 27 -152.5 57t-215.5 30q-127 0 -211.5 -46t-84.5 -133q0 -57 21.5 -92.5t64.5 -58.5 t109 -41.5t157 -39.5q200 -46 290 -125q89 -79 89 -218zM881 399q28 33 43 65.5t15 90.5q0 51 -16.5 86t-45.5 58q-28 24 -67 39.5t-83 27.5q-39 11 -85.5 21.5t-116.5 30.5q-18 -9 -49 -31.5t-53 -46.5q-24 -26 -43 -69t-19 -92q0 -50 15.5 -85t44.5 -59q27 -23 67.5 -39 t84.5 -27q38 -10 86 -22t115 -31q20 11 53 34.5t54 48.5z',
                'M958 1304h-199v195h199v-195zM545 1304h-199v195h199v-195z',
                'M1889 655q0 -358 -253.5 -611.5t-611.5 -253.5t-611.5 253.5t-253.5 611.5t253.5 611.5t611.5 253.5t611.5 -253.5t253.5 -611.5zM1773 655q0 310 -219.5 532t-529.5 222t-529.5 -222t-219.5 -532t219.5 -532t529.5 -222t529.5 222t219.5 532zM1375 258 q-86 -39 -165.5 -58.5t-157.5 -19.5q-227 0 -359 123t-132 357q0 225 134.5 354t356.5 129q89 0 175 -24t148 -52v-181h-16q-54 40 -138.5 75t-173.5 35q-142 0 -221.5 -85.5t-79.5 -250.5q0 -159 76.5 -246t224.5 -87q83 0 161.5 29t150.5 81h16v-179z',
                'M944 554h-170v94q-28 -20 -52.5 -38.5t-68.5 -37.5q-45 -20 -85.5 -30.5t-113.5 -10.5q-128 0 -215.5 85t-87.5 217q0 106 46.5 173.5t123.5 103.5q78 36 197.5 51.5t255.5 21.5v18q0 53 -18 85t-51 51q-34 18 -77.5 23t-91.5 5q-84 0 -168 -24t-123 -38h-14v172 q45 13 137 29t169 16q217 0 312 -84.5t95 -243.5v-638zM774 796v245q-69 -4 -160.5 -12t-145.5 -23q-64 -18 -103 -56.5t-39 -106.5q0 -76 45.5 -114t139.5 -38q82 0 147.5 33.5t115.5 71.5z',
                'M1146 191l-528 419v85l528 418v-188l-357 -273l357 -273v-188zM716 162l-550 446v89l550 445v-196l-371 -294l371 -294v-196z',
                'M1456 57h-171v545h-1075v160h1246v-705z',
                'M777 561h-624v181h624v-181z',
                'M1889 655q0 -358 -253.5 -611.5t-611.5 -253.5t-611.5 253.5t-253.5 611.5t253.5 611.5t611.5 253.5t611.5 -253.5t253.5 -611.5zM1773 655q0 310 -219.5 532t-529.5 222t-529.5 -222t-219.5 -532t219.5 -532t529.5 -222t529.5 222t219.5 532zM1581 215h-223l-331 355 h-162v-355h-165v915h312q94 0 155 -8t120 -39q63 -34 92.5 -82.5t29.5 -121.5q0 -97 -56.5 -161.5t-155.5 -102.5zM1229 868q0 36 -14 64t-47 46q-31 17 -66 22t-88 5h-149v-309h127q62 0 107 9.5t74 32.5q31 25 43.5 55t12.5 75z',
                'M1306 1668h-1305l-5 120h1310v-120z',
                'M956 1116q0 -168 -116 -284t-285 -116t-285 115.5t-116 284.5q0 168 116 284t285 116q170 0 285.5 -116t115.5 -284zM791 1116q0 102 -67 171.5t-169 69.5t-169 -69.5t-67 -171.5q0 -104 68.5 -172.5t167.5 -68.5q102 0 169 70t67 171z',
                'M1461 179h-1246v158h540v422h-540v158h540v545h166v-545h540v-158h-540v-422h540v-158z',
                'M967 566h-760v156q100 62 183.5 117t134.5 96q131 103 168 154.5t37 135.5q0 69 -53.5 107t-143.5 38q-89 0 -175 -30.5t-134 -61.5h-13v180q71 26 158.5 43.5t174.5 17.5q180 0 273.5 -78.5t93.5 -203.5q0 -99 -48.5 -174.5t-163.5 -165.5q-55 -43 -132.5 -94 t-143.5 -92h544v-145z',
                'M956 817q0 -75 -33 -131.5t-89 -90.5q-57 -35 -131 -51.5t-163 -16.5q-94 0 -176.5 15t-156.5 43v179h14q41 -36 138.5 -65.5t190.5 -29.5q100 0 166.5 35.5t66.5 110.5q0 85 -59 115t-171 30h-143v141h128q112 0 165.5 38.5t53.5 106.5q0 61 -49.5 96.5t-153.5 35.5 q-77 0 -174.5 -31t-141.5 -67h-14v178q74 27 160.5 44.5t176.5 17.5q175 0 271.5 -68t96.5 -174q0 -89 -55 -146t-144 -83v-8q95 -17 160.5 -72.5t65.5 -151.5z',
                'M963 1676l-273 -374h-149l179 374h243z',
                'M1124 0h-178l-10 118q-59 -65 -123.5 -102t-155.5 -37q-86 0 -149.5 35t-129.5 99v-525h-188v1529h188v-838q32 -39 109.5 -80t168.5 -41q93 0 159.5 33.5t120.5 93.5v832h188v-1117z',
                'M1106 -363h-148v1722h-214v-1722h-149v956q-206 5 -332 129t-126 328q0 207 130 323t373 116h466v-1852z',
                'M492 511h-239v283h239v-283z',
                'M880 -89q0 -162 -91.5 -248t-237.5 -86q-37 0 -95 7t-103 19v160h9q26 -10 70 -23t94 -13q104 0 153 39t49 127q0 29 -3 65.5t-6 61.5h153q2 -19 5 -45t3 -64z',
                'M914 566h-615v122h234v568h-242v112q45 0 99 6.5t84 18.5q37 16 59 38t25 62h135v-805h221v-122z',
                'M996 1025q0 -235 -122 -364.5t-315 -129.5q-201 0 -319.5 132.5t-118.5 361.5t118.5 362t319.5 133q193 0 315 -130t122 -365zM814 1025q0 172 -67.5 258t-187.5 86q-122 0 -189 -87t-67 -257t67 -256.5t189 -86.5q120 0 187.5 85.5t67.5 257.5z',
                'M1154 608l-550 -446v196l371 294l-371 294v196l550 -445v-89zM702 610l-528 -419v188l357 273l-357 273v188l528 -418v-85z',
                'M545 565h-165v681h-209v117q102 0 165 22t72 108h137v-928zM1410 1489l-780 -1489h-165l780 1489h165zM1857 220h-163v-220h-150v220h-465v185l466 539h149v-591h163v-133zM1548 353v400l-353 -400h353z',
                'M545 565h-165v681h-209v117q102 0 165 22t72 108h137v-928zM1410 1489l-780 -1489h-165l780 1489h165zM1955 0h-688v148q91 69 158 121t106 89q109 103 141 157.5t32 136.5q0 70 -44 107t-120 37q-70 0 -141.5 -30t-112.5 -62h-15v179q65 27 140.5 44t152.5 17 q157 0 241.5 -79t84.5 -201q0 -93 -41 -167t-147 -168q-49 -43 -119.5 -96t-125.5 -94h498v-139z',
                'M793 826q0 -71 -30 -127t-78 -90q-53 -37 -114.5 -53t-140.5 -16q-82 0 -153.5 15t-136.5 43v175h17q37 -35 114 -64.5t156 -29.5q84 0 139 36.5t55 108.5q0 83 -50 112.5t-141 29.5h-140v139h125q87 0 134.5 38t47.5 104q0 60 -41 95.5t-128 35.5q-66 0 -142.5 -31 t-113.5 -66h-17v175q64 27 139 44t154 17q152 0 237 -70t85 -168q0 -87 -48.5 -143.5t-125.5 -82.5v-8q80 -16 138.5 -70.5t58.5 -148.5zM1500 1489l-780 -1489h-165l780 1489h165zM1913 220h-163v-220h-150v220h-465v185l466 539h149v-591h163v-133zM1604 353v400 l-353 -400h353z',
                'M712 1278h-204v211h204v-211zM958 40q-83 -30 -176 -50t-205 -20q-215 0 -339.5 104.5t-124.5 275.5q0 98 34.5 173t93.5 137q58 62 136.5 112.5t146.5 91.5v225h179v-305q-60 -33 -139 -81.5t-125 -88.5q-54 -47 -88 -109t-34 -140q0 -113 76.5 -168.5t197.5 -55.5 q103 0 201.5 33t155.5 70h10v-204z',
                'M1374 0h-211l-146 415h-644l-146 -415h-201l542 1489h264zM956 585l-261 731l-262 -731h523zM862 1675h-149l-273 374h243z',
                'M1374 0h-211l-146 415h-644l-146 -415h-201l542 1489h264zM956 585l-261 731l-262 -731h523zM955 2049l-273 -374h-149l179 374h243z',
                'M1374 0h-211l-146 415h-644l-146 -415h-201l542 1489h264zM956 585l-261 731l-262 -731h523zM1033 1670h-159l-185 256l-184 -256h-155l228 379h227z',
                'M1374 0h-211l-146 415h-644l-146 -415h-201l542 1489h264zM956 585l-261 731l-262 -731h523zM1119 1992q-11 -152 -77 -229t-177 -77q-54 0 -100 19.5t-87 56.5q-47 43 -79.5 64.5t-71.5 21.5q-52 0 -78 -45t-30 -121h-131q8 151 79 228t174 77q50 0 96.5 -19.5 t88.5 -55.5q47 -41 83.5 -61.5t69.5 -20.5q51 0 79.5 46t31.5 116h129z',
                'M1374 0h-211l-146 415h-644l-146 -415h-201l542 1489h264zM956 585l-261 731l-262 -731h523zM1005 1677h-199v195h199v-195zM592 1677h-199v195h199v-195z',
                'M1374 0h-211l-148 415h-640l-148 -415h-201l519 1407q-89 44 -142.5 123.5t-53.5 181.5q0 143 102 240t248 97q147 0 248.5 -97t101.5 -240q0 -100 -52.5 -181.5t-141.5 -123.5zM899 1710q0 86 -57 143.5t-143 57.5t-143 -58t-57 -143q0 -86 57.5 -143.5t142.5 -57.5 q86 0 143 57.5t57 143.5zM953 585l-258 715l-259 -715h517z',
                'M1901 0h-944v556h-524l-212 -556h-207l594 1489h1293v-176h-749v-408h749v-176h-749v-553h749v-176zM957 723v601h-219l-239 -601h458z',
                'M1350 108q-55 -24 -99.5 -45t-116.5 -44q-11 -3 -24 -7.5t-31 -7.5q2 -19 3.5 -44.5t1.5 -48.5q0 -162 -93.5 -248t-240.5 -86q-38 0 -97.5 7t-104.5 19v162h9q26 -10 71.5 -24t95.5 -14q106 0 155 40t49 126q0 19 -1 41.5t-3 42.5q-19 -2 -40.5 -3t-39.5 -1 q-162 0 -294.5 45.5t-230.5 142.5q-96 95 -150 241.5t-54 340.5q0 184 52 329t150 245q95 97 229.5 148t298.5 51q120 0 239.5 -29t265.5 -102v-235h-15q-123 103 -244 150t-259 47q-113 0 -203.5 -36.5t-161.5 -113.5q-69 -75 -107.5 -189.5t-38.5 -264.5q0 -157 42.5 -270 t109.5 -184q70 -74 163.5 -109.5t197.5 -35.5q143 0 268 49t234 147h14v-232z',
                'M1181 0h-981v1489h981v-176h-783v-408h783v-176h-783v-553h783v-176zM822 1675h-149l-273 374h243z',
                'M1181 0h-981v1489h981v-176h-783v-408h783v-176h-783v-553h783v-176zM993 2049l-273 -374h-149l179 374h243z',
                'M1181 0h-981v1489h981v-176h-783v-408h783v-176h-783v-553h783v-176zM1031 1670h-159l-185 256l-184 -256h-155l228 379h227z',
                'M1181 0h-981v1489h981v-176h-783v-408h783v-176h-783v-553h783v-176zM1038 1677h-199v195h199v-195zM625 1677h-199v195h199v-195z',
                'M725 0h-588v152h195v1185h-195v152h588v-152h-195v-1185h195v-152zM568 1675h-149l-273 374h243z',
                'M725 0h-588v152h195v1185h-195v152h588v-152h-195v-1185h195v-152zM725 2049l-273 -374h-149l179 374h243z',
                'M725 0h-588v152h195v1185h-195v152h588v-152h-195v-1185h195v-152zM776 1670h-159l-185 256l-184 -256h-155l228 379h227z',
                'M725 0h-588v152h195v1185h-195v152h588v-152h-195v-1185h195v-152zM738 1677h-199v195h199v-195zM325 1677h-199v195h199v-195z',
                'M1468 743q0 -203 -88.5 -368t-235.5 -256q-102 -63 -227.5 -91t-330.5 -28h-376v740h-196v143h196v606h372q218 0 347 -31.5t217 -86.5q152 -95 237 -253t85 -375zM1261 746q0 175 -61 295t-182 189q-88 50 -187 69.5t-237 19.5h-188v-436h361v-143h-361v-570h188 q143 0 249.5 21t195.5 78q111 71 166.5 187t55.5 290z',
                'M1336 0h-245l-706 1332v-1332h-185v1489h307l644 -1216v1216h185v-1489zM1208 1992q-11 -152 -77 -229t-177 -77q-54 0 -100 19.5t-87 56.5q-47 43 -79.5 64.5t-71.5 21.5q-52 0 -78 -45t-30 -121h-131q8 151 79 228t174 77q50 0 96.5 -19.5t88.5 -55.5 q47 -41 83.5 -61.5t69.5 -20.5q51 0 79.5 46t31.5 116h129z',
                'M1310 1318q91 -100 139.5 -245t48.5 -329t-49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5zM1292 744 q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5zM932 1675h-149l-273 374h243z',
                'M1310 1318q91 -100 139.5 -245t48.5 -329t-49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5zM1292 744 q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5zM1083 2049l-273 -374h-149l179 374h243z',
                'M1310 1318q91 -100 139.5 -245t48.5 -329t-49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5zM1292 744 q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5zM1136 1670h-159l-185 256l-184 -256h-155l228 379h227z',
                'M1310 1318q91 -100 139.5 -245t48.5 -329t-49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5zM1292 744 q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5zM1207 1992q-11 -152 -77 -229t-177 -77q-54 0 -100 19.5t-87 56.5q-47 43 -79.5 64.5t-71.5 21.5q-52 0 -78 -45t-30 -121h-131q8 151 79 228 t174 77q50 0 96.5 -19.5t88.5 -55.5q47 -41 83.5 -61.5t69.5 -20.5q51 0 79.5 46t31.5 116h129z',
                'M1307 1318q91 -100 139.5 -245t48.5 -329t-49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5zM1289 744 q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5zM1108 1677h-199v195h199v-195zM695 1677h-199v195h199v-195z',
                'M1385 216l-111 -111l-436 440l-436 -440l-111 111l440 436l-440 436l111 111l436 -440l436 440l111 -111l-440 -436z',
                'M1498 744q0 -184 -49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-115 0 -215.5 29t-179.5 84l-159 -228h-132l205 294q-101 100 -155.5 250t-54.5 346q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q118 0 215 -27.5t179 -82.5l142 201h132 l-188 -268q101 -100 156.5 -248.5t55.5 -350.5zM1097 1260q-57 46 -129 68.5t-161 22.5q-110 0 -200 -38.5t-156 -116.5q-64 -76 -98.5 -190.5t-34.5 -261.5q0 -140 29.5 -252t87.5 -188zM1295 744q0 139 -30 253t-88 189l-664 -957q60 -45 132.5 -68t161.5 -23 q110 0 201.5 40t153.5 116q67 82 100 194.5t33 255.5z',
                'M1321 598q0 -162 -35.5 -282.5t-116.5 -200.5q-77 -76 -180 -111t-240 -35q-140 0 -244 37t-175 109q-81 82 -116.5 198t-35.5 285v891h198v-901q0 -121 16.5 -191t55.5 -127q44 -65 119.5 -98t181.5 -33q107 0 182 32.5t120 98.5q39 57 55.5 130.5t16.5 182.5v906h198 v-891zM932 1675h-149l-273 374h243z',
                'M1321 598q0 -162 -35.5 -282.5t-116.5 -200.5q-77 -76 -180 -111t-240 -35q-140 0 -244 37t-175 109q-81 82 -116.5 198t-35.5 285v891h198v-901q0 -121 16.5 -191t55.5 -127q44 -65 119.5 -98t181.5 -33q107 0 182 32.5t120 98.5q39 57 55.5 130.5t16.5 182.5v906h198 v-891zM1073 2049l-273 -374h-149l179 374h243z',
                'M1321 598q0 -162 -35.5 -282.5t-116.5 -200.5q-77 -76 -180 -111t-240 -35q-140 0 -244 37t-175 109q-81 82 -116.5 198t-35.5 285v891h198v-901q0 -121 16.5 -191t55.5 -127q44 -65 119.5 -98t181.5 -33q107 0 182 32.5t120 98.5q39 57 55.5 130.5t16.5 182.5v906h198 v-891zM1084 1670h-159l-185 256l-184 -256h-155l228 379h227z',
                'M1321 598q0 -162 -35.5 -282.5t-116.5 -200.5q-77 -76 -180 -111t-240 -35q-140 0 -244 37t-175 109q-81 82 -116.5 198t-35.5 285v891h198v-901q0 -121 16.5 -191t55.5 -127q44 -65 119.5 -98t181.5 -33q107 0 182 32.5t120 98.5q39 57 55.5 130.5t16.5 182.5v906h198 v-891zM1056 1677h-199v195h199v-195zM643 1677h-199v195h199v-195z',
                'M1254 1489l-524 -836v-653h-198v632l-526 857h219l407 -666l411 666h211zM935 2049l-273 -374h-149l179 374h243z',
                'M1174 787q0 -92 -35 -176.5t-95 -141.5q-78 -75 -187.5 -111t-260.5 -36h-198v-322h-198v1489h198v-270h205q133 0 230 -22.5t164 -66.5q83 -53 130 -138t47 -205zM968 782q0 72 -26 125.5t-82 88.5q-48 30 -112 42.5t-154 12.5h-196v-563h167q119 0 195 20.5t123 65.5 q44 41 64.5 92t20.5 116z',
                'M1165 481q0 -214 -135.5 -359.5t-354.5 -145.5q-44 0 -101.5 7.5t-93.5 20.5v165h10q42 -24 91.5 -33t105.5 -9q74 0 129 29t88 78q35 52 50.5 115.5t15.5 139.5q0 166 -105.5 250.5t-303.5 84.5v150q157 0 234 59.5t77 188.5q0 35 -11 68t-41 64q-27 29 -71 46.5 t-105 17.5q-57 0 -103 -14.5t-86 -53.5q-37 -36 -59.5 -102t-22.5 -161v-1087h-188v1080q0 124 36 215.5t100 153.5q60 58 149.5 87.5t183.5 29.5q183 0 297.5 -87t114.5 -238q0 -112 -71 -201t-184 -121v-9q164 -37 259 -148.5t95 -280.5z',
                'M1053 0h-187v119q-25 -17 -67.5 -47.5t-82.5 -48.5q-47 -23 -108 -38.5t-143 -15.5q-151 0 -256 100t-105 255q0 127 54.5 205.5t155.5 123.5q102 45 245 61t307 24v29q0 64 -22.5 106t-64.5 66q-40 23 -96 31t-117 8q-74 0 -165 -19.5t-188 -56.5h-10v191q55 15 159 33 t205 18q118 0 205.5 -19.5t151.5 -66.5q63 -46 96 -119t33 -181v-758zM866 275v311q-86 -5 -202.5 -15t-184.5 -29q-81 -23 -131 -71.5t-50 -133.5q0 -96 58 -144.5t177 -48.5q99 0 181 38.5t152 92.5zM738 1302h-149l-273 374h243z',
                'M1053 0h-187v119q-25 -17 -67.5 -47.5t-82.5 -48.5q-47 -23 -108 -38.5t-143 -15.5q-151 0 -256 100t-105 255q0 127 54.5 205.5t155.5 123.5q102 45 245 61t307 24v29q0 64 -22.5 106t-64.5 66q-40 23 -96 31t-117 8q-74 0 -165 -19.5t-188 -56.5h-10v191q55 15 159 33 t205 18q118 0 205.5 -19.5t151.5 -66.5q63 -46 96 -119t33 -181v-758zM866 275v311q-86 -5 -202.5 -15t-184.5 -29q-81 -23 -131 -71.5t-50 -133.5q0 -96 58 -144.5t177 -48.5q99 0 181 38.5t152 92.5zM934 1676l-273 -374h-149l179 374h243z',
                'M1053 0h-187v119q-25 -17 -67.5 -47.5t-82.5 -48.5q-47 -23 -108 -38.5t-143 -15.5q-151 0 -256 100t-105 255q0 127 54.5 205.5t155.5 123.5q102 45 245 61t307 24v29q0 64 -22.5 106t-64.5 66q-40 23 -96 31t-117 8q-74 0 -165 -19.5t-188 -56.5h-10v191q55 15 159 33 t205 18q118 0 205.5 -19.5t151.5 -66.5q63 -46 96 -119t33 -181v-758zM866 275v311q-86 -5 -202.5 -15t-184.5 -29q-81 -23 -131 -71.5t-50 -133.5q0 -96 58 -144.5t177 -48.5q99 0 181 38.5t152 92.5zM961 1297h-159l-185 256l-184 -256h-155l228 379h227z',
                'M1053 0h-187v119q-25 -17 -67.5 -47.5t-82.5 -48.5q-47 -23 -108 -38.5t-143 -15.5q-151 0 -256 100t-105 255q0 127 54.5 205.5t155.5 123.5q102 45 245 61t307 24v29q0 64 -22.5 106t-64.5 66q-40 23 -96 31t-117 8q-74 0 -165 -19.5t-188 -56.5h-10v191q55 15 159 33 t205 18q118 0 205.5 -19.5t151.5 -66.5q63 -46 96 -119t33 -181v-758zM866 275v311q-86 -5 -202.5 -15t-184.5 -29q-81 -23 -131 -71.5t-50 -133.5q0 -96 58 -144.5t177 -48.5q99 0 181 38.5t152 92.5zM1038 1619q-11 -152 -77 -229t-177 -77q-54 0 -100 19.5t-87 56.5 q-47 43 -79.5 64.5t-71.5 21.5q-52 0 -78 -45t-30 -121h-131q8 151 79 228t174 77q50 0 96.5 -19.5t88.5 -55.5q47 -41 83.5 -61.5t69.5 -20.5q51 0 79.5 46t31.5 116h129z',
                'M1053 0h-187v119q-25 -17 -67.5 -47.5t-82.5 -48.5q-47 -23 -108 -38.5t-143 -15.5q-151 0 -256 100t-105 255q0 127 54.5 205.5t155.5 123.5q102 45 245 61t307 24v29q0 64 -22.5 106t-64.5 66q-40 23 -96 31t-117 8q-74 0 -165 -19.5t-188 -56.5h-10v191q55 15 159 33 t205 18q118 0 205.5 -19.5t151.5 -66.5q63 -46 96 -119t33 -181v-758zM866 275v311q-86 -5 -202.5 -15t-184.5 -29q-81 -23 -131 -71.5t-50 -133.5q0 -96 58 -144.5t177 -48.5q99 0 181 38.5t152 92.5zM926 1304h-199v195h199v-195zM513 1304h-199v195h199v-195z',
                'M1053 0h-187v119q-25 -17 -67.5 -47.5t-82.5 -48.5q-47 -23 -108 -38.5t-143 -15.5q-151 0 -256 100t-105 255q0 127 54.5 205.5t155.5 123.5q102 45 245 61t307 24v29q0 64 -22.5 106t-64.5 66q-40 23 -96 31t-117 8q-74 0 -165 -19.5t-188 -56.5h-10v191q55 15 159 33 t205 18q118 0 205.5 -19.5t151.5 -66.5q63 -46 96 -119t33 -181v-758zM866 275v311q-86 -5 -202.5 -15t-184.5 -29q-81 -23 -131 -71.5t-50 -133.5q0 -96 58 -144.5t177 -48.5q99 0 181 38.5t152 92.5zM956 1630q0 -143 -102 -242t-248 -99q-144 0 -247 98.5t-103 242.5 q0 143 102 241t248 98q147 0 248.5 -98t101.5 -241zM811 1630q0 86 -58.5 145.5t-146.5 59.5t-146.5 -59t-58.5 -146t59 -146t146 -59q88 0 146.5 59t58.5 146z',
                'M1855 559h-819q0 -114 30 -195t85 -133q52 -48 123 -70.5t157 -22.5q111 0 217.5 41.5t172.5 93.5h12v-205q-78 -35 -184.5 -64.5t-215.5 -29.5q-166 0 -284.5 52t-194.5 155q-21 -19 -67 -59t-96 -68q-63 -36 -137 -59.5t-189 -23.5q-150 0 -255.5 97t-105.5 249 q0 124 54 200.5t155 118.5q95 39 241 53t308 17v61q0 65 -23 107.5t-64 65.5q-40 23 -96 31.5t-116 8.5q-79 0 -168.5 -21t-179.5 -57h-13v191q55 15 158 34t204 19q159 0 264.5 -46.5t162.5 -137.5q69 82 170 134t226 52q217 0 342.5 -128t125.5 -379v-82zM1673 703 q-5 68 -23.5 119t-50.5 88q-34 39 -88.5 61t-133.5 22q-133 0 -223 -75t-115 -215h634zM894 298q-20 53 -30.5 119t-10.5 141q-105 -3 -201 -7.5t-178 -25.5q-79 -20 -127.5 -65.5t-48.5 -128.5q0 -95 58 -141t176 -46q99 0 195.5 43t166.5 111z',
                'M1011 70q-33 -15 -71.5 -30.5t-67.5 -24.5q3 -19 5.5 -47.5t2.5 -56.5q0 -162 -91.5 -248t-237.5 -86q-37 0 -95 7t-103 19v160h9q26 -10 70 -23t94 -13q104 0 153 39t49 127q0 22 -1.5 45t-3.5 43q-16 -2 -30.5 -4t-39.5 -2q-121 0 -222 35.5t-173 107.5 q-73 72 -113 182t-40 257q0 274 150.5 430t397.5 156q96 0 188.5 -27t169.5 -66v-209h-10q-86 67 -177.5 103t-178.5 36q-160 0 -252.5 -107.5t-92.5 -315.5q0 -202 90.5 -310.5t254.5 -108.5q57 0 116 15t106 39q41 21 77 44.5t57 40.5h10v-207z',
                'M1120 539h-823q0 -103 31 -179.5t85 -125.5q52 -48 123.5 -72t157.5 -24q114 0 229.5 45.5t164.5 89.5h10v-205q-95 -40 -194 -67t-208 -27q-278 0 -434 150.5t-156 427.5q0 274 149.5 435t393.5 161q226 0 348.5 -132t122.5 -375v-102zM937 683q-1 148 -74.5 229 t-223.5 81q-151 0 -240.5 -89t-101.5 -221h640zM759 1302h-149l-273 374h243z',
                'M1120 539h-823q0 -103 31 -179.5t85 -125.5q52 -48 123.5 -72t157.5 -24q114 0 229.5 45.5t164.5 89.5h10v-205q-95 -40 -194 -67t-208 -27q-278 0 -434 150.5t-156 427.5q0 274 149.5 435t393.5 161q226 0 348.5 -132t122.5 -375v-102zM937 683q-1 148 -74.5 229 t-223.5 81q-151 0 -240.5 -89t-101.5 -221h640zM960 1676l-273 -374h-149l179 374h243z',
                'M1120 539h-823q0 -103 31 -179.5t85 -125.5q52 -48 123.5 -72t157.5 -24q114 0 229.5 45.5t164.5 89.5h10v-205q-95 -40 -194 -67t-208 -27q-278 0 -434 150.5t-156 427.5q0 274 149.5 435t393.5 161q226 0 348.5 -132t122.5 -375v-102zM937 683q-1 148 -74.5 229 t-223.5 81q-151 0 -240.5 -89t-101.5 -221h640zM986 1297h-159l-185 256l-184 -256h-155l228 379h227z',
                'M1120 539h-823q0 -103 31 -179.5t85 -125.5q52 -48 123.5 -72t157.5 -24q114 0 229.5 45.5t164.5 89.5h10v-205q-95 -40 -194 -67t-208 -27q-278 0 -434 150.5t-156 427.5q0 274 149.5 435t393.5 161q226 0 348.5 -132t122.5 -375v-102zM937 683q-1 148 -74.5 229 t-223.5 81q-151 0 -240.5 -89t-101.5 -221h640zM951 1304h-199v195h199v-195zM538 1304h-199v195h199v-195z',
                'M375 0h-188v1117h188v-1117zM401 1302h-149l-273 374h243z',
                'M375 0h-188v1117h188v-1117zM582 1676l-273 -374h-149l179 374h243z',
                'M572 1297h-151l-143 267l-142 -267h-147l178 379h227zM375 0h-188v1117h188v-1117z',
                'M557 1304h-189v195h189v-195zM194 1304h-189v195h189v-195zM375 0h-188v1117h188v-1117z',
                'M1137 637q0 -324 -142 -496t-383 -172q-229 0 -367.5 135t-138.5 380q0 226 137 358t339 132q108 0 185.5 -26.5t163.5 -79.5q-32 112 -99.5 219t-154.5 181l-264 -162l-66 97l237 142q-84 67 -156 107.5t-165 87.5v16h295q35 -25 84 -58.5t86 -59.5l210 128l66 -97 l-186 -109q153 -147 236 -325.5t83 -397.5zM847 226q49 59 75 143.5t26 234.5q0 32 -1.5 59.5t-3.5 57.5q-75 45 -157.5 66.5t-168.5 21.5q-147 0 -231.5 -87.5t-84.5 -239.5q0 -180 84.5 -267t227.5 -87q66 0 127.5 22t106.5 76z',
                'M1119 0h-188v636q0 77 -9 144.5t-33 105.5q-25 42 -72 62.5t-122 20.5q-77 0 -161 -38t-161 -97v-834h-188v1117h188v-124q88 73 182 114t193 41q181 0 276 -109t95 -314v-725zM1075 1619q-11 -152 -77 -229t-177 -77q-54 0 -100 19.5t-87 56.5q-47 43 -79.5 64.5 t-71.5 21.5q-52 0 -78 -45t-30 -121h-131q8 151 79 228t174 77q50 0 96.5 -19.5t88.5 -55.5q47 -41 83.5 -61.5t69.5 -20.5q51 0 79.5 46t31.5 116h129z',
                'M1137 558q0 -273 -140 -431t-375 -158q-237 0 -376.5 158t-139.5 431t139.5 431.5t376.5 158.5q235 0 375 -158.5t140 -431.5zM943 558q0 217 -85 322.5t-236 105.5q-153 0 -237.5 -105.5t-84.5 -322.5q0 -210 85 -318.5t237 -108.5q150 0 235.5 107.5t85.5 319.5z M732 1302h-149l-273 374h243z',
                'M1137 558q0 -273 -140 -431t-375 -158q-237 0 -376.5 158t-139.5 431t139.5 431.5t376.5 158.5q235 0 375 -158.5t140 -431.5zM943 558q0 217 -85 322.5t-236 105.5q-153 0 -237.5 -105.5t-84.5 -322.5q0 -210 85 -318.5t237 -108.5q150 0 235.5 107.5t85.5 319.5z M933 1676l-273 -374h-149l179 374h243z',
                'M1137 558q0 -273 -140 -431t-375 -158q-237 0 -376.5 158t-139.5 431t139.5 431.5t376.5 158.5q235 0 375 -158.5t140 -431.5zM943 558q0 217 -85 322.5t-236 105.5q-153 0 -237.5 -105.5t-84.5 -322.5q0 -210 85 -318.5t237 -108.5q150 0 235.5 107.5t85.5 319.5z M963 1297h-159l-185 256l-184 -256h-155l228 379h227z',
                'M1137 558q0 -273 -140 -431t-375 -158q-237 0 -376.5 158t-139.5 431t139.5 431.5t376.5 158.5q235 0 375 -158.5t140 -431.5zM943 558q0 217 -85 322.5t-236 105.5q-153 0 -237.5 -105.5t-84.5 -322.5q0 -210 85 -318.5t237 -108.5q150 0 235.5 107.5t85.5 319.5z M1038 1619q-11 -152 -77 -229t-177 -77q-54 0 -100 19.5t-87 56.5q-47 43 -79.5 64.5t-71.5 21.5q-52 0 -78 -45t-30 -121h-131q8 151 79 228t174 77q50 0 96.5 -19.5t88.5 -55.5q47 -41 83.5 -61.5t69.5 -20.5q51 0 79.5 46t31.5 116h129z',
                'M1137 558q0 -273 -140 -431t-375 -158q-237 0 -376.5 158t-139.5 431t139.5 431.5t376.5 158.5q235 0 375 -158.5t140 -431.5zM943 558q0 217 -85 322.5t-236 105.5q-153 0 -237.5 -105.5t-84.5 -322.5q0 -210 85 -318.5t237 -108.5q150 0 235.5 107.5t85.5 319.5z M928 1304h-199v195h199v-195zM515 1304h-199v195h199v-195z',
                'M957 1022h-238v275h238v-275zM1466 572h-1256v160h1256v-160zM957 7h-238v275h238v-275z',
                'M1137 558q0 -273 -140 -431t-375 -158q-84 0 -155.5 21t-130.5 60l-133 -198h-110l171 256q-75 77 -116.5 190t-41.5 260q0 273 139.5 431.5t376.5 158.5q87 0 158 -22t125 -57l116 172h111l-155 -231q76 -76 118 -188t42 -264zM813 930q-37 29 -86.5 43.5t-104.5 14.5 q-155 0 -240 -110t-85 -320q0 -97 17 -171t52 -128zM946 558q0 97 -17.5 173t-51.5 130l-448 -671q39 -31 86.5 -46t106.5 -15q150 0 237 108.5t87 320.5z',
                'M1111 0h-188v124q-95 -75 -182 -115t-192 -40q-176 0 -274 107.5t-98 315.5v725h188v-636q0 -85 8 -145.5t34 -103.5q27 -44 70 -64t125 -20q73 0 159.5 38t161.5 97v834h188v-1117zM764 1302h-149l-273 374h243z',
                'M1111 0h-188v124q-95 -75 -182 -115t-192 -40q-176 0 -274 107.5t-98 315.5v725h188v-636q0 -85 8 -145.5t34 -103.5q27 -44 70 -64t125 -20q73 0 159.5 38t161.5 97v834h188v-1117zM945 1676l-273 -374h-149l179 374h243z',
                'M1111 0h-188v124q-95 -75 -182 -115t-192 -40q-176 0 -274 107.5t-98 315.5v725h188v-636q0 -85 8 -145.5t34 -103.5q27 -44 70 -64t125 -20q73 0 159.5 38t161.5 97v834h188v-1117zM985 1297h-159l-185 256l-184 -256h-155l228 379h227z',
                'M1111 0h-188v124q-95 -75 -182 -115t-192 -40q-176 0 -274 107.5t-98 315.5v725h188v-636q0 -85 8 -145.5t34 -103.5q27 -44 70 -64t125 -20q73 0 159.5 38t161.5 97v834h188v-1117zM955 1304h-199v195h199v-195zM542 1304h-199v195h199v-195z',
                'M1151 1117l-652 -1529h-201l208 466l-445 1063h204l343 -828l346 828h197zM928 1676l-273 -374h-149l179 374h243z',
                'M1168 572q0 -136 -39 -248.5t-110 -190.5q-66 -74 -155.5 -114.5t-189.5 -40.5q-87 0 -157.5 19t-143.5 59v-468h-188v1968h188v-556q75 63 168.5 105.5t199.5 42.5q202 0 314.5 -152.5t112.5 -423.5zM974 567q0 202 -69 302t-212 100q-81 0 -163 -35t-157 -92v-633 q80 -36 137.5 -49t130.5 -13q157 0 245 106t88 314z',
                'M585 832h-239v285h239v-285zM658 285l-282 -655h-146l174 655h254z',
                'M773 1676l-49 -384h-145l-49 384h243z',
                'M765 1676l-49 -384h-128l-49 384h226zM1048 1304h-191v195h191v-195zM447 1304h-191v195h191v-195z',
                'M1374 0h-211l-146 415h-644l-146 -415h-201l542 1489h264zM956 585l-261 731l-262 -731h523zM250 1489l-49 -384h-145l-49 384h243z',
                'M585 832h-239v285h239v-285z',
                'M1424 0h-981v1489h981v-176h-783v-408h783v-176h-783v-553h783v-176zM243 1489l-49 -384h-145l-49 384h243z',
                'M1582 0h-198v729h-743v-729h-198v1489h198v-584h743v584h198v-1489zM243 1489l-49 -384h-145l-49 384h243z',
                'M968 0h-588v152h195v1185h-195v152h588v-152h-195v-1185h195v-152zM243 1489l-49 -384h-145l-49 384h243z',
                'M1501 1318q91 -100 139.5 -245t48.5 -329t-49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5zM1483 744 q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5zM243 1489l-49 -384h-145l-49 384h243z',
                'M1537 1489l-524 -836v-653h-198v632l-526 857h219l407 -666l411 666h211zM243 1489l-49 -384h-145l-49 384h243z',
                'M1751 0h-576v387q60 38 119.5 82t103.5 101q45 59 71 138.5t26 185.5q0 206 -127 330.5t-347 124.5t-347 -124.5t-127 -330.5q0 -106 26 -185.5t71 -138.5q45 -57 104 -101t119 -82v-387h-576v174h410v124q-157 90 -258.5 246t-101.5 350q0 276 187.5 451t492.5 175 t492.5 -175t187.5 -451q0 -194 -101.5 -350t-258.5 -246v-124h410v-174zM243 1489l-49 -384h-145l-49 384h243z',
                'M375 0h-188v1117h188v-1117zM379 1676l-56 -384h-84l-56 384h196zM615 1304h-171v195h171v-195zM118 1304h-171v195h171v-195z',
                'M1374 0h-211l-146 415h-644l-146 -415h-201l542 1489h264zM956 585l-261 731l-262 -731h523z',
                'M1323 458q0 -111 -42 -196t-113 -140q-84 -66 -184.5 -94t-255.5 -28h-528v1489h441q163 0 244 -12t155 -50q82 -43 119 -110.5t37 -161.5q0 -106 -54 -180.5t-144 -119.5v-8q151 -31 238 -132.5t87 -256.5zM990 1129q0 54 -18 91t-58 60q-47 27 -114 33.5t-166 6.5h-236 v-430h256q93 0 148 9.5t102 39.5t66.5 77.5t19.5 112.5zM1117 450q0 90 -27 143t-98 90q-48 25 -116.5 32.5t-166.5 7.5h-311v-554h262q130 0 213 13.5t136 49.5q56 39 82 89t26 129z',
                'M1162 1313h-764v-1313h-198v1489h962v-176z',
                'M1414 0h-1388l562 1489h264zM1147 168l-432 1147l-431 -1147h863z',
                'M1181 0h-981v1489h981v-176h-783v-408h783v-176h-783v-553h783v-176z',
                'M1288 0h-1162v184l913 1129h-879v176h1106v-179l-922 -1134h944v-176z',
                'M1339 0h-198v729h-743v-729h-198v1489h198v-584h743v584h198v-1489z',
                'M1310 1318q91 -100 139.5 -245t48.5 -329t-49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5zM1292 744 q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5zM1120 713h-627v179h627v-179z',
                'M725 0h-588v152h195v1185h-195v152h588v-152h-195v-1185h195v-152z',
                'M1397 0h-257l-589 663l-148 -158v-505h-198v1489h198v-777l723 777h240l-665 -700z',
                'M1378 0h-213l-468 1285l-468 -1285h-203l556 1489h240z',
                'M1526 0h-198v1283l-414 -873h-118l-411 873v-1283h-185v1489h270l397 -829l384 829h275v-1489z',
                'M1336 0h-245l-706 1332v-1332h-185v1489h307l644 -1216v1216h185v-1489z',
                'M1215 1313h-1101v176h1101v-176zM1163 729h-997v176h997v-176zM1215 0h-1101v176h1101v-176z',
                'M1310 1318q91 -100 139.5 -245t48.5 -329t-49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5zM1292 744 q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5z',
                'M1339 0h-198v1313h-743v-1313h-198v1489h1139v-1489z',
                'M1174 1039q0 -99 -34.5 -183.5t-96.5 -146.5q-77 -77 -182 -115.5t-265 -38.5h-198v-555h-198v1489h404q134 0 227 -22.5t165 -70.5q85 -57 131.5 -142t46.5 -215zM968 1034q0 77 -27 134t-82 93q-48 31 -109.5 44.5t-155.5 13.5h-196v-595h167q120 0 195 21.5t122 68.5 q47 48 66.5 101t19.5 119z',
                'M1280 0h-1162v184l620 600l-600 526v179h1096v-176h-832l586 -506v-26l-630 -605h922v-176z',
                'M1262 1313h-532v-1313h-198v1313h-532v176h1262v-176z',
                'M1254 1489l-524 -836v-653h-198v632l-526 857h219l407 -666l411 666h211z',
                'M1572 755q0 -140 -44.5 -248.5t-123.5 -181.5q-85 -79 -207 -125.5t-260 -49.5v-166h-197v166q-134 3 -257 48t-210 127q-79 74 -123.5 182t-44.5 248q0 136 43 238t119 178q81 81 202.5 128t270.5 51v155h197v-155q148 -3 271 -52t202 -127q75 -73 118.5 -177t43.5 -239 zM1366 763q0 99 -32 182t-91 140q-58 56 -129 82t-177 28v-890q94 2 171 30.5t127 75.5q65 60 98 147t33 205zM740 305v890q-106 -1 -177 -28t-129 -82t-90.5 -140t-32.5 -182q0 -112 33.5 -203t97.5 -149q49 -45 126.5 -75t171.5 -31z',
                'M1336 1489l-514 -736l513 -753h-229l-406 613l-416 -613h-216l519 744l-507 745h228l401 -605l410 605h217z',
                'M1604 910q0 -157 -40.5 -264.5t-117.5 -174.5q-80 -69 -192.5 -104t-263.5 -45v-322h-197v322q-154 11 -267 47t-188 102q-78 69 -118.5 176t-40.5 263v579h198v-602q0 -109 29.5 -180t81.5 -115q53 -45 130 -68.5t175 -30.5v996h197v-996q97 8 175 30.5t131 68.5 q56 49 83 115.5t27 179.5v602h198v-579z',
                'M1568 0h-576v387q60 38 119.5 82t103.5 101q45 59 71 138.5t26 185.5q0 206 -127 330.5t-347 124.5t-347 -124.5t-127 -330.5q0 -106 26 -185.5t71 -138.5q45 -57 104 -101t119 -82v-387h-576v174h410v124q-157 90 -258.5 246t-101.5 350q0 276 187.5 451t492.5 175 t492.5 -175t187.5 -451q0 -194 -101.5 -350t-258.5 -246v-124h410v-174z',
                'M725 0h-588v152h195v1185h-195v152h588v-152h-195v-1185h195v-152zM738 1677h-199v195h199v-195zM325 1677h-199v195h199v-195z',
                'M1254 1489l-524 -836v-653h-198v632l-526 857h219l407 -666l411 666h211zM939 1677h-199v195h199v-195zM526 1677h-199v195h199v-195z',
                'M1091 0h-188v117q-81 -70 -169 -109t-191 -39q-200 0 -317.5 154t-117.5 427q0 142 40.5 253t109.5 189q68 76 158.5 116t187.5 40q88 0 156 -22t143 -61v52h188v-1117zM903 275v636q-76 34 -136 49.5t-131 15.5q-158 0 -246 -110t-88 -312q0 -199 68 -302.5t218 -103.5 q80 0 162 35.5t153 91.5zM743 1676l-49 -384h-145l-49 384h243z',
                'M1006 64q-107 -48 -210 -69t-218 -21q-79 0 -161 16t-152 56q-69 39 -112.5 102.5t-43.5 157.5q0 96 56.5 168t177.5 110v7q-91 24 -145 90t-54 158q0 89 47.5 147.5t112.5 92.5q64 33 145 49t160 16q98 0 180 -16.5t172 -44.5v-207h-13q-66 51 -163.5 79t-197.5 28 q-45 0 -84 -5.5t-81 -25.5q-35 -15 -60.5 -48.5t-25.5 -77.5q0 -61 28 -95t76 -49q45 -14 97 -15.5t105 -1.5h111v-166h-158q-62 0 -112 -4.5t-92 -21.5q-41 -17 -65.5 -54t-24.5 -96q0 -53 26 -90t67 -58q37 -19 87.5 -29t106.5 -10q102 0 218 36t187 98h13v-206zM721 1676 l-49 -384h-145l-49 384h243z',
                'M1119 -412h-188v1048q0 77 -9 144.5t-33 105.5q-25 42 -72 62.5t-122 20.5q-77 0 -161 -38t-161 -97v-834h-188v1117h188v-124q88 73 182 114t193 41q181 0 276 -109t95 -314v-1137zM802 1676l-49 -384h-145l-49 384h243z',
                'M375 0h-188v1117h188v-1117zM403 1676l-49 -384h-145l-49 384h243z',
                'M1116 407q0 -218 -122 -327.5t-348 -109.5q-223 0 -346 107.5t-123 329.5v710h188v-641q0 -93 10 -153t42 -106q31 -43 84.5 -64.5t145.5 -21.5q86 0 143.5 22t87.5 66q29 44 39.5 105.5t10.5 151.5v641h188v-710zM760 1676l-49 -384h-128l-49 384h226zM1043 1304h-191 v195h191v-195zM442 1304h-191v195h191v-195z',
                'M1091 0h-188v117q-81 -70 -169 -109t-191 -39q-200 0 -317.5 154t-117.5 427q0 142 40.5 253t109.5 189q68 76 158.5 116t187.5 40q88 0 156 -22t143 -61v52h188v-1117zM903 275v636q-76 34 -136 49.5t-131 15.5q-158 0 -246 -110t-88 -312q0 -199 68 -302.5t218 -103.5 q80 0 162 35.5t153 91.5z',
                'M1165 444q0 -202 -134.5 -334t-339.5 -132q-79 0 -167 22t-151 64v-476h-188v1490q0 224 126.5 351t349.5 127q90 0 164.5 -21.5t133.5 -67.5q57 -43 91 -112t34 -160q0 -127 -69.5 -221.5t-196.5 -131.5v-17q159 -26 253 -125.5t94 -255.5zM971 449q0 89 -34.5 144.5 t-92.5 86.5q-59 32 -132 43t-146 11h-36v160h36q66 0 131 14.5t104 44.5q46 34 68.5 83t22.5 134q0 112 -69 170t-178 58q-73 0 -125 -26.5t-85 -70.5q-32 -44 -47 -102.5t-15 -120.5v-862q66 -38 141 -53.5t147 -15.5q149 0 229.5 78.5t80.5 223.5z',
                'M1151 1117l-457 -1061v-468h-188v468l-445 1061h204l343 -828l346 828h197z',
                'M1139 551q0 -272 -138.5 -427t-376.5 -155q-241 0 -379.5 151.5t-138.5 413.5q0 141 43 239.5t107 162.5q69 72 159 113t182 58q-76 63 -166 130.5t-192 139.5v179h810v-158h-561v-10q68 -46 179 -124t204 -162q150 -136 209 -261.5t59 -289.5zM945 551q0 135 -55 249 t-165 200q-66 -8 -138.5 -32t-138.5 -77q-63 -50 -105.5 -137t-42.5 -214q0 -201 85 -305t241 -104q153 0 236 105.5t83 314.5z',
                'M1006 64q-107 -48 -210 -69t-218 -21q-79 0 -161 16t-152 56q-69 39 -112.5 102.5t-43.5 157.5q0 96 56.5 168t177.5 110v7q-91 24 -145 90t-54 158q0 89 47.5 147.5t112.5 92.5q64 33 145 49t160 16q98 0 180 -16.5t172 -44.5v-207h-13q-66 51 -163.5 79t-197.5 28 q-45 0 -84 -5.5t-81 -25.5q-35 -15 -60.5 -48.5t-25.5 -77.5q0 -61 28 -95t76 -49q45 -14 97 -15.5t105 -1.5h111v-166h-158q-62 0 -112 -4.5t-92 -21.5q-41 -17 -65.5 -54t-24.5 -96q0 -53 26 -90t67 -58q37 -19 87.5 -29t106.5 -10q102 0 218 36t187 98h13v-206z',
                'M922 75q32 -40 46 -85.5t14 -85.5q0 -84 -45 -168.5t-112 -147.5h-179v14q90 79 128 138.5t38 128.5q0 57 -30.5 95t-77.5 38h-145q-229 0 -340 116t-111 345q0 140 46 268t124 247q75 112 173.5 214.5t206.5 196.5v9h-460v158h744v-135q-117 -78 -231.5 -181 t-204.5 -223q-89 -117 -146 -257t-57 -283q0 -34 3 -70t15 -76q10 -38 34.5 -75.5t63.5 -61.5q36 -22 96.5 -24.5t116.5 -2.5h86q71 0 122 -26t82 -66z',
                'M1119 -412h-188v1048q0 77 -9 144.5t-33 105.5q-25 42 -72 62.5t-122 20.5q-77 0 -161 -38t-161 -97v-834h-188v1117h188v-124q88 73 182 114t193 41q181 0 276 -109t95 -314v-1137z',
                'M1141 768q0 -190 -23 -316.5t-59 -210.5q-58 -135 -163 -203.5t-257 -68.5t-257 68.5t-163 203.5q-37 84 -59.5 210.5t-22.5 316.5q0 174 22.5 305.5t60.5 214.5q57 130 162.5 199t256.5 69t256.5 -69t162.5 -199q37 -84 60 -215t23 -305zM952 858q-4 143 -28.5 250 t-56.5 161q-41 70 -95 98.5t-133 28.5t-133 -28.5t-95 -98.5q-34 -55 -57.5 -161.5t-27.5 -249.5h626zM952 697h-626q0 -142 23 -258.5t59 -178.5q40 -69 96 -100t135 -31t135 31t96 100q36 62 59 178.5t23 258.5z',
                'M375 0h-188v1117h188v-1117z',
                'M1192 0h-248l-451 489l-112 -109v-380h-188v1117h188v-550l384 417q72 79 135.5 107t126.5 28q28 0 58 -1t37 -1v-166h-11q-16 2 -39.5 3t-36.5 1q-47 0 -85.5 -23.5t-67.5 -56.5l-251 -271z',
                'M1151 0h-205l-328 829l-361 -829h-196l465 1056l-215 500h211z',
                'M1125 0h-186v118q-74 -78 -141.5 -108.5t-145.5 -30.5q-75 0 -135 27t-144 107v-525h-188v1529h188v-838q32 -39 111 -80t170 -41q93 0 161 33.5t122 93.5v832h188v-1117z',
                'M1151 1117l-452 -1117h-189l-449 1117h204l346 -889l343 889h197z',
                'M1041 -96q0 -85 -45.5 -169t-111.5 -147h-180v14q92 79 129.5 139t37.5 128q0 55 -29 94t-75 39h-140q-140 0 -232.5 27t-155.5 84q-66 60 -100.5 135.5t-34.5 163.5q0 78 25 144t73 119q44 49 112.5 83.5t144.5 53.5v11q-125 28 -200 110.5t-75 186.5q0 83 43.5 150.5 t133.5 125.5v6h-228v154h824v-158h-256q-68 0 -122.5 -14.5t-102.5 -48.5q-45 -32 -72 -83t-27 -118q0 -79 32.5 -128t83.5 -75q45 -23 104 -34t139 -11h170v-165h-295q-66 0 -118.5 -20t-99.5 -59q-43 -37 -68.5 -90t-25.5 -112q0 -102 37.5 -159t101.5 -82 q63 -25 139.5 -28.5t166.5 -3.5h28q68 0 119.5 -23.5t84.5 -60.5q31 -35 48 -82.5t17 -96.5z',
                'M1137 558q0 -273 -140 -431t-375 -158q-237 0 -376.5 158t-139.5 431t139.5 431.5t376.5 158.5q235 0 375 -158.5t140 -431.5zM943 558q0 217 -85 322.5t-236 105.5q-153 0 -237.5 -105.5t-84.5 -322.5q0 -210 85 -318.5t237 -108.5q150 0 235.5 107.5t85.5 319.5z',
                'M1120 0h-188v955h-559v-955h-188v1117h935v-1117z',
                'M1172 577q0 -258 -138.5 -428.5t-360.5 -170.5q-65 0 -146.5 18t-153.5 61v-469h-188v1058q0 123 35.5 215.5t101.5 158.5q62 62 155.5 95t195.5 33q243 0 371 -147t128 -424zM978 565q0 218 -80 320t-226 102q-158 0 -228.5 -96t-70.5 -278v-403q73 -34 132.5 -48.5 t134.5 -14.5q162 0 250 111t88 307z',
                'M1018 -96q0 -87 -47 -172t-109 -144h-177v14q86 75 124.5 135.5t38.5 131.5q0 54 -30 93.5t-75 39.5h-92q-117 0 -216 30t-174 97q-73 66 -114.5 170t-41.5 250q0 270 155.5 432t414.5 162q84 0 164 -18.5t147 -45.5v-211h-12q-94 62 -172.5 87t-146.5 25 q-166 0 -260.5 -119t-94.5 -312q0 -112 28.5 -183t78.5 -116q50 -44 114.5 -63.5t139.5 -19.5h100q115 0 186 -76.5t71 -186.5z',
                'M1137 558q0 -281 -140.5 -435t-373.5 -154q-241 0 -379 158t-138 431q0 275 141 432.5t378 157.5q55 0 108 -11t82 -20h480v-165h-288q62 -73 96 -170t34 -224zM943 558q0 215 -82 322t-236 107q-161 0 -243 -112t-82 -317q0 -209 83.5 -318t239.5 -109q152 0 236 107.5 t84 319.5z',
                'M1006 952h-404v-952h-188v952h-404v165h996v-165z',
                'M1116 407q0 -218 -122 -327.5t-348 -109.5q-223 0 -346 107.5t-123 329.5v710h188v-641q0 -93 10 -153t42 -106q31 -43 84.5 -64.5t145.5 -21.5q86 0 143.5 22t87.5 66q29 44 39.5 105.5t10.5 151.5v641h188v-710z',
                'M1514 576q0 -259 -171.5 -417t-440.5 -173v-398h-187v398q-130 6 -240.5 46.5t-191.5 109.5q-85 74 -132 172t-47 232q0 159 59 296t192 275h229v-17q-136 -99 -210 -232t-74 -300q0 -189 112.5 -304t301.5 -121v1000q33 2 70.5 2.5t76.5 0.5q304 0 478.5 -149.5 t174.5 -420.5zM1319 586q0 184 -112 293.5t-305 109.5v-846q206 10 311.5 126t105.5 317z',
                'M1160 -412h-213l-346 619l-350 -619h-203l444 770l-433 759h213l335 -600l339 600h203l-433 -751z',
                'M1507 446q0 -114 -48 -198t-127 -137q-82 -55 -182 -82.5t-215 -32.5v-408h-187v408q-115 6 -214.5 32t-182.5 83q-80 54 -127.5 137.5t-47.5 197.5v671h188v-612q0 -113 37.5 -180.5t89.5 -102.5q56 -38 123 -53t134 -19v967h187v-967q67 5 134 19t123 53 q59 40 93 101.5t34 181.5v612h188v-671z',
                'M1553 503q0 -96 -23.5 -192.5t-74.5 -171.5q-55 -80 -133.5 -124.5t-193.5 -44.5q-96 0 -177 49.5t-118 116.5h-6q-39 -68 -113 -117t-176 -49q-113 0 -194.5 46.5t-132.5 122.5t-74.5 171.5t-23.5 192.5q0 170 57 308.5t201 305.5h228v-17q-135 -108 -214.5 -262 t-79.5 -337q0 -66 8 -122.5t38 -119.5q26 -55 72.5 -91.5t117.5 -36.5q51 0 86.5 12.5t55.5 29.5q22 18 36.5 40t20.5 37v584h186v-584q9 -17 23 -39t35 -39q24 -19 52.5 -30t86.5 -11q70 0 117 35.5t74 92.5q25 55 36 116t11 126q0 182 -78.5 336t-215.5 263v17h228 q144 -167 201 -305.5t57 -308.5z',
                'M557 1304h-189v195h189v-195zM194 1304h-189v195h189v-195zM375 0h-188v1117h188v-1117z',
                'M1116 407q0 -218 -122 -327.5t-348 -109.5q-223 0 -346 107.5t-123 329.5v710h188v-641q0 -93 10 -153t42 -106q31 -43 84.5 -64.5t145.5 -21.5q86 0 143.5 22t87.5 66q29 44 39.5 105.5t10.5 151.5v641h188v-710zM953 1304h-199v195h199v-195zM540 1304h-199v195h199 v-195z',
                'M1137 558q0 -273 -140 -431t-375 -158q-237 0 -376.5 158t-139.5 431t139.5 431.5t376.5 158.5q235 0 375 -158.5t140 -431.5zM943 558q0 217 -85 322.5t-236 105.5q-153 0 -237.5 -105.5t-84.5 -322.5q0 -210 85 -318.5t237 -108.5q150 0 235.5 107.5t85.5 319.5z M743 1676l-49 -384h-145l-49 384h243z',
                'M1116 407q0 -218 -122 -327.5t-348 -109.5q-223 0 -346 107.5t-123 329.5v710h188v-641q0 -93 10 -153t42 -106q31 -43 84.5 -64.5t145.5 -21.5q86 0 143.5 22t87.5 66q29 44 39.5 105.5t10.5 151.5v641h188v-710zM768 1676l-49 -384h-145l-49 384h243z',
                'M1553 503q0 -96 -23.5 -192.5t-74.5 -171.5q-55 -80 -133.5 -124.5t-193.5 -44.5q-96 0 -177 49.5t-118 116.5h-6q-39 -68 -113 -117t-176 -49q-113 0 -194.5 46.5t-132.5 122.5t-74.5 171.5t-23.5 192.5q0 170 57 308.5t201 305.5h228v-17q-135 -108 -214.5 -262 t-79.5 -337q0 -66 8 -122.5t38 -119.5q26 -55 72.5 -91.5t117.5 -36.5q51 0 86.5 12.5t55.5 29.5q22 18 36.5 40t20.5 37v584h186v-584q9 -17 23 -39t35 -39q24 -19 52.5 -30t86.5 -11q70 0 117 35.5t74 92.5q25 55 36 116t11 126q0 182 -78.5 336t-215.5 263v17h228 q144 -167 201 -305.5t57 -308.5zM955 1676l-49 -384h-145l-49 384h243z',
                'M1145 837q0 -164 -39 -344t-121 -303q-85 -124 -186.5 -173t-214.5 -49q-192 0 -313.5 126.5t-121.5 329.5q0 228 134.5 372.5t336.5 144.5q90 0 169.5 -26t158.5 -91q2 26 3 55.5t1 55.5q0 217 -79 318t-231 101q-78 0 -169.5 -31.5t-169.5 -86.5h-11v194 q81 44 181.5 66.5t196.5 22.5q137 0 239.5 -54.5t164.5 -178.5q42 -86 56.5 -189t14.5 -260zM942 678q-60 47 -136 74t-148 27q-141 0 -225 -91t-84 -261q0 -145 67.5 -221.5t179.5 -76.5q128 0 209.5 97t115.5 287q6 33 11.5 73t9.5 92z',
                'M1438 0h-1388l562 1489h264zM1171 168l-432 1147l-431 -1147h863z',
                'M1532 1315h-200v-1508h-198v1508h-592v-1508h-198v1508h-200v174h1388v-174z',
                'M1369 -189h-1182v191l673 668l-663 631v188h1133v-176h-891l648 -601v-72l-666 -653h948v-176z',
                'M1456 572h-1236v160h1236v-160z',
                'M843 1489l-780 -1489h-165l780 1489h165z',
                'M492 511h-239v283h239v-283z',
                'M1737 1788l-880 -1939h-102l-384 993h-237v139h393l313 -821l730 1628h167z',
                'M1887 663q0 -239 -122.5 -372.5t-329.5 -133.5q-133 0 -244 76.5t-180 222.5q-79 -151 -184.5 -225t-248.5 -74q-191 0 -304 135.5t-113 349.5q0 238 125 372t327 134q134 0 245 -77t179 -222q79 150 185.5 224.5t247.5 74.5q191 0 304 -135.5t113 -349.5zM967 729 q-63 117 -155 175.5t-188 58.5q-138 0 -216 -83.5t-78 -237.5q0 -133 63.5 -216t182.5 -83q110 0 172 48.5t119 142.5q34 57 52.5 92.5t47.5 102.5zM1718 663q0 134 -64 216.5t-182 82.5q-88 0 -152.5 -35.5t-138.5 -155.5q-30 -48 -55.5 -99.5t-44.5 -95.5 q60 -115 153.5 -174.5t189.5 -59.5q138 0 216 83t78 238z',
                'M1168 1367h-10q-32 8 -89.5 18.5t-89.5 10.5q-129 0 -181 -61q-53 -61 -53 -210v-1123q0 -206 -104 -315q-105 -110 -293 -110q-52 0 -106.5 5.5t-103.5 15.5v178h10q33 -8 87 -18.5t88 -10.5q129 0 182 61q52 61 52 210v1123q0 204 104 315q104 110 293 110 q58 0 109 -5.5t105 -15.5v-178z',
                'M1431 1104q-20 -194 -111 -293t-249 -99q-77 0 -147 37.5t-126 82.5q-65 52 -117 79.5t-96 27.5q-75 0 -117 -48t-70 -172h-155q23 182 112.5 280t248.5 98q72 0 143 -37t130 -83q61 -48 114.5 -77.5t98.5 -29.5q76 0 120.5 54.5t63.5 179.5h157zM1432 588 q-25 -184 -112 -281.5t-250 -97.5q-72 0 -144 37.5t-129 82.5q-39 31 -103 69t-110 38q-78 0 -121 -55t-63 -179h-157q19 192 110.5 292t249.5 100q77 0 146 -37t127 -83q35 -28 97 -67.5t116 -39.5q75 0 117 49.5t69 171.5h157z',
                'M1431 362h-608l-104 -335h-153l104 335h-425v156h474l84 268h-558v156h606l105 335h153l-105 -335h427v-156h-476l-83 -268h559v-156z',
                'M1408 303l-1154 483v124l1154 483v-183l-889 -362l889 -362v-183zM1408 0h-1154v160h1154v-160z',
                'M1422 786l-1154 -483v183l889 362l-889 362v183l1154 -483v-124zM1422 0h-1154v160h1154v-160z'
            ];
            this.OUTLINE_X = [
                [], [291, 301, 505, 515], [168, 211, 729, 772, 554], [195, 389, 917, 1364, 1481, 1481, 1288, 760, 312, 195],
                [155, 604, 722, 1129.8, 1160, 1107, 722, 604, 278.5, 191.1, 162, 155], [149, 172.3, 242, 630, 1687, 1844.3, 1960, 2031.3, 2055, 2031.8, 1962, 1575, 517, 359.8, 244, 172.8],
                [115, 149.4, 252.5, 407.6, 598, 1555, 1287, 961.3, 881, 757.5, 601, 423.5, 293, 213.5, 187], [164, 207, 343, 386], [181, 205.5, 279, 554, 783, 783, 554, 279, 205.5],
                [147, 376, 651, 724.5, 749, 724.5, 651, 376, 147], [167, 232, 588, 717, 1073, 1137, 1137, 1073, 717, 588, 232, 167], [210, 755, 921, 1466, 1466, 921, 755, 210],
                [147, 293, 575, 321], [153, 777, 777, 153], [253, 492, 492, 253], [-30, 143, 860, 684],
                [137, 167.9, 260.5, 420.1, 652, 881.4, 1041.5, 1135.6, 1167, 1136.1, 1043.5, 883.9, 652, 422, 262, 168.3], [278, 1084, 1084, 780, 625, 278],
                [161, 1169, 1169, 1106, 1073.5, 976, 821.3, 617, 387.5, 198, 161], [167, 364, 608, 830.5, 1007, 1111, 1148, 1117, 1080, 971, 821, 629, 399.5, 210, 167],
                [77, 790, 982, 1203, 1203, 982, 798, 77], [187, 378, 613, 843.5, 1015, 1119, 1157, 1147, 251, 187],
                [137, 183.5, 316, 475, 675, 875.1, 1041.5, 1153.6, 1191, 1046, 965, 866, 542, 315, 179.5], [154, 285, 499, 1173, 1173, 154],
                [122, 157.9, 265.5, 433.6, 651, 859.6, 1029.5, 1142.4, 1180, 1140, 1106.8, 1007, 851.5, 651, 456.8, 300, 196.5, 162],
                [113, 258, 340, 438, 760, 988, 1122.5, 1167, 1121, 990, 829, 629, 429.5, 263, 150.5], [346, 585, 585, 346], [230, 376, 658, 585, 346], [254, 1408, 1408, 254],
                [245, 1431, 1431, 245], [268, 1422, 1422, 268], [160, 406, 610, 970, 1005, 973.9, 880.5, 733.4, 541, 337.5, 160],
                [176, 240, 419, 692, 1037, 1210, 1391, 1714, 1829.5, 1870, 1813.5, 1651, 1391, 1041, 701, 426, 243], [26, 1374, 832, 568],
                [200, 728, 983.5, 1168, 1281, 1323, 1196, 1159, 1040, 885, 641, 200], [115, 169, 319, 549.5, 844, 1001.5, 1134, 1250.5, 1350, 1350, 1084.5, 845, 546.5, 317, 167],
                [200, 576, 906.5, 1134, 1369.5, 1458, 1373, 1136, 918.5, 572, 200], [200, 1181, 1181, 200], [200, 398, 1045, 1151, 1151, 200],
                [115, 171, 330, 577, 896, 1175.5, 1442, 1442, 1441, 1155.5, 896, 570.9, 323.5, 167.1], [200, 1339, 1339, 200], [137, 725, 725, 137],
                [44, 178, 306, 486.6, 626.5, 716.1, 746, 746, 233, 44], [205, 1397, 1366, 205], [200, 1142, 1142, 398, 200], [200, 1526, 1526, 200], [200, 1336, 1336, 200],
                [115, 163.5, 302, 520.5, 806, 1092.5, 1310, 1448.5, 1498, 1449.5, 1310, 1093.5, 806, 521.5, 303, 163], [200, 398, 1043, 1139.5, 1174, 1127.5, 996, 831, 604, 200],
                [115, 163.5, 302, 520.5, 1010.5, 1133.1, 1290, 1409.5, 1528, 1528, 1498, 1449.5, 1310, 1093.5, 806, 521.5, 303, 163], [200, 1432, 1130.5, 1004, 842, 617, 200],
                [134, 395.5, 685, 941.5, 1128, 1241.5, 1282, 1222, 990, 702, 480.3, 301, 182.5, 143, 134], [0, 532, 730, 1262, 1262, 0],
                [178, 213.5, 330, 505, 749, 989, 1169, 1285.5, 1321, 1321, 178], [26, 568, 832, 1374, 238], [92, 486, 1546, 1933, 295], [68, 1335, 1336, 80], [6, 532, 730, 1254, 225],
                [126, 1288, 1288, 1266, 160, 126], [239, 759, 759, 239], [70, 787, 960, 246], [171, 691, 691, 171], [186, 383, 1490, 901, 775], [-4, 1306, 1306, -4], [340, 613, 762, 583],
                [104, 130.3, 209, 325.5, 465, 1053, 1053, 1020, 924, 772.5, 567, 362, 203], [185, 679, 866, 1022, 1128.5, 1168, 1139.4, 1053.5, 918.1, 373, 185],
                [105, 145, 258, 431, 653, 832.5, 1011, 1011, 841.5, 653, 430.1, 255.5, 142.6], [108, 137.4, 225.5, 363.6, 543, 1091, 1091, 903, 258, 148.5],
                [106, 145, 262, 448.5, 696, 904, 1098, 1120, 1120, 1089.4, 997.5, 849.1, 649, 428.6, 255.5, 143.4], [68, 195, 383, 716, 786, 786, 693.5, 580, 415, 294, 68],
                [108, 225, 391.5, 565, 798.3, 962, 1058.8, 1091, 1091, 602, 417, 259, 148.5], [185, 1119, 1119, 1095.3, 1024, 373, 185], [175, 187, 375, 387, 387, 175],
                [-62, 47.5, 153, 304, 421, 496, 521, 533, 533, 321, 100, -62], [193, 1199, 1161, 381, 193], [187, 375, 375, 187], [185, 1815, 1815, 1793.1, 1727.5, 1615.9, 1456, 735, 185],
                [185, 1119, 1119, 1095.3, 1024, 907.5, 748, 185], [106, 140.9, 245.5, 409.4, 622, 833.3, 997, 1102, 1137, 1102, 997, 833.3, 622, 409.4, 245.5, 140.9],
                [185, 373, 1019, 1129, 1168, 1139.9, 1055.5, 920.6, 741, 185], [108, 137.6, 226.5, 365.1, 903, 1091, 1091, 602, 414, 259, 149.5], [185, 373, 882, 882, 816, 745, 185],
                [110, 283.5, 511, 706.9, 856.5, 951.4, 983, 939, 768.5, 566, 372.5, 230, 143.5, 115, 110], [62, 211.3, 278, 387.5, 538, 649.5, 765, 765, 377, 189, 62],
                [177, 201.5, 275, 392.5, 549, 1111, 1111, 177], [61, 510, 699, 1151, 265], [86, 380, 1299, 1590, 766], [60, 1152, 1152, 64], [61, 298, 499, 1151, 265],
                [93, 995, 995, 978, 107, 93], [173, 588.9, 672.5, 800.9, 963, 1113, 1113, 963, 800.9, 672.5, 588.9, 173], [378, 552, 552, 378],
                [187, 337, 499.1, 627.5, 711.1, 1127, 1127, 711.1, 627.5, 499.1, 337, 187], [187, 354, 1125, 1290, 1401, 1466.5, 1489, 1322, 551, 386, 274, 209.5], [], [291, 515, 505, 301],
                [159, 191.6, 289.5, 647, 765, 1120, 1120, 765, 647, 292.5, 192.4], [137, 1163, 1163, 1137, 997, 816, 630.6, 484.5, 389.6, 182, 137],
                [138, 247, 1058, 1168, 1168, 1055, 249, 138], [108, 187, 557, 745, 1115, 1191, 320], [378, 552, 552, 378],
                [172, 229, 404.5, 575, 796, 965, 1063, 1096, 1128, 1071, 896, 725, 497.5, 334, 235, 203], [346, 958, 958, 346],
                [159, 222.4, 412.5, 692.1, 1024, 1355.9, 1635.5, 1825.6, 1889, 1825.6, 1635.5, 1355.9, 1024, 692.1, 412.5, 222.4],
                [151, 238.5, 454, 944, 944, 920.3, 849, 723.5, 537, 368, 231], [166, 716, 1146, 1146, 716, 166], [210, 1285, 1456, 1456, 210], [153, 777, 777, 153],
                [159, 222.4, 412.5, 692.1, 1024, 1355.9, 1635.5, 1825.6, 1889, 1825.6, 1635.5, 1355.9, 1024, 692.1, 412.5, 222.4], [-4, 1, 1306, 1306],
                [154, 183, 270, 399.3, 555, 710.8, 840, 927, 956, 927.1, 840.5, 711.4, 555, 399.3, 270, 183], [215, 1461, 1461, 921, 755, 215],
                [207, 967, 967, 911, 887.6, 817.5, 544, 369.5, 211, 207], [207, 363.5, 540, 703, 834, 923, 956, 929, 904.9, 832.5, 561, 384.5, 224, 207], [541, 690, 963, 720],
                [190, 378, 1124, 1124, 190], [137, 168.5, 595, 1106, 1106, 640, 425.3, 267, 169.5], [253, 492, 492, 253], [353, 456, 551, 788.5, 857.1, 880, 877, 872, 719, 353],
                [291, 299, 914, 914, 693, 558, 291], [121, 150.6, 239.5, 378.6, 559, 734.3, 874, 965.5, 996, 965.5, 874, 734.3, 559, 378.6, 239.5, 150.6], [174, 604, 1154, 1154, 604, 174],
                [171, 465, 1694, 1857, 1857, 1694, 1410, 545, 408, 171], [171, 465, 1955, 1955, 1890, 1805.5, 1410, 545, 408, 171], [140, 555, 1750, 1913, 1913, 1750, 1500, 448, 294, 155, 140],
                [113, 144.1, 237.5, 384.6, 577, 782, 958, 958, 712, 508, 147.5], [26, 1374, 862, 683, 440], [26, 1374, 955, 712, 533], [26, 1374, 1033, 805, 578, 350],
                [26, 1374, 1119, 990, 541, 367, 288], [26, 1374, 1005, 806, 393], [26, 1374, 1049, 1023.6, 947.5, 834.6, 699, 564, 451, 374.5, 349], [14, 1901, 1901, 608],
                [115, 169, 548, 652.5, 750, 990.5, 1350, 1350, 1084.5, 845, 546.5, 317, 167], [200, 1181, 1181, 643, 400, 200], [200, 1181, 1181, 993, 750, 200],
                [200, 1181, 1181, 803, 576, 200], [200, 1181, 1181, 1038, 426, 200], [137, 725, 725, 389, 146, 137], [137, 725, 725, 482, 137], [93, 137, 725, 776, 548, 321],
                [126, 137, 725, 738, 738, 126], [14, 210, 586, 916.5, 1144, 1379.5, 1468, 1383, 1146, 929, 582, 210, 14], [200, 1336, 1336, 1208, 1079, 630, 456, 200],
                [115, 163.5, 302, 520.5, 806, 1092.5, 1310, 1448.5, 1498, 1449.5, 1310, 753, 510, 163], [115, 163.5, 302, 520.5, 806, 1092.5, 1310, 1448.5, 1498, 1449.5, 1083, 840, 303, 163],
                [115, 163.5, 302, 520.5, 806, 1092.5, 1310, 1448.5, 1498, 1449.5, 1136, 908, 681, 453, 163],
                [115, 163.5, 302, 520.5, 806, 1092.5, 1310, 1448.5, 1498, 1449.5, 1207, 1078, 629, 455, 163],
                [112, 160.5, 299, 517.5, 803, 1089.5, 1307, 1445.5, 1495, 1446.5, 1108, 909, 496, 160], [291, 402, 1274, 1385, 1385, 1274, 402, 291],
                [115, 120, 252, 1092.5, 1310, 1448.5, 1498, 1474, 1342, 806, 521.5, 303, 163], [178, 213.5, 330, 505, 749, 989, 1169, 1285.5, 1321, 1321, 753, 510, 178],
                [178, 213.5, 330, 505, 749, 989, 1169, 1285.5, 1321, 1321, 1073, 830, 178], [178, 213.5, 330, 505, 749, 989, 1169, 1285.5, 1321, 1321, 856, 629, 178],
                [178, 213.5, 330, 505, 749, 989, 1169, 1285.5, 1321, 1321, 1056, 444, 178], [6, 532, 730, 1254, 935, 692], [200, 398, 1044, 1139, 1174, 1127, 997, 398, 200],
                [185, 675, 873.1, 1029.5, 1131.1, 1165, 1066, 1037.4, 951.5, 819.9, 654, 470.5, 321, 221, 185], [104, 130.3, 209, 325.5, 465, 1053, 1053, 1020, 559, 316, 203],
                [104, 130.3, 209, 325.5, 465, 1053, 1053, 934, 691, 203], [104, 130.3, 209, 325.5, 465, 1053, 1053, 961, 733, 506, 278, 203],
                [104, 130.3, 209, 325.5, 465, 1053, 1053, 1038, 909, 460, 286, 207], [104, 130.3, 209, 325.5, 465, 1053, 1053, 926, 314, 203],
                [104, 130.3, 209, 325.5, 465, 1053, 1053, 956, 930.6, 854.5, 741.6, 606, 471, 358, 281.5, 256],
                [104, 130.4, 209.5, 326.1, 465, 1433, 1648.5, 1833, 1855, 1855, 1823.6, 1729.5, 1581.1, 1387, 564, 360, 202],
                [105, 145, 353, 456, 551, 788.5, 857.1, 1011, 1011, 841.5, 653, 430.1, 255.5, 142.6], [106, 145, 262, 448.5, 696, 904, 1098, 1120, 1120, 1089.4, 997.5, 580, 337, 143.4],
                [106, 145, 262, 448.5, 696, 904, 1098, 1120, 1120, 1089.4, 960, 717, 255.5, 143.4], [106, 145, 262, 448.5, 696, 904, 1098, 1120, 1120, 1089.4, 986, 758, 531, 303, 143.4],
                [106, 145, 262, 448.5, 696, 904, 1098, 1120, 1120, 1089.4, 951, 339, 143.4], [-21, 187, 375, 401, 222], [160, 187, 375, 582, 339], [-11, 187, 375, 572, 394, 167],
                [5, 187, 375, 557, 557, 5], [106, 140.6, 244.5, 405.6, 612, 828.3, 995, 1101.5, 1137, 1004, 938, 263], [185, 1119, 1119, 1075, 946, 497, 323, 244, 185],
                [106, 140.9, 245.5, 409.4, 622, 833.3, 997, 1102, 1137, 1102, 997, 553, 310, 140.9], [106, 140.9, 245.5, 409.4, 622, 833.3, 997, 1102, 1137, 1102, 933, 690, 245.5, 140.9],
                [106, 140.9, 245.5, 409.4, 622, 833.3, 997, 1102, 1137, 1102, 963, 735, 508, 280, 140.9], [106, 140.9, 245.5, 409.4, 622, 833.3, 997, 1102, 1137, 1038, 909, 460, 286, 207],
                [106, 140.9, 245.5, 409.4, 622, 833.3, 997, 1102, 1137, 1102, 928, 729, 316, 140.9], [210, 719, 957, 1466, 1466, 957, 719, 210],
                [93, 203, 833.3, 997, 1102, 1137, 1132, 1021, 409.4, 245.5, 140.9, 106], [177, 201.5, 275, 392.5, 549, 1111, 1111, 585, 342, 177],
                [177, 201.5, 275, 392.5, 549, 1111, 1111, 945, 702, 177], [177, 201.5, 275, 392.5, 549, 1111, 1111, 757, 530, 177], [177, 201.5, 275, 392.5, 549, 1111, 1111, 955, 343, 177],
                [61, 298, 499, 1151, 928, 685], [185, 373, 1019, 1129, 1168, 1139.9, 1055.5, 920.6, 373, 185], [230, 376, 658, 585, 346], [530, 579, 724, 773],
                [256, 588, 716, 1048, 1048, 765, 539, 256], [7, 26, 1374, 832], [346, 585, 585, 346], [0, 49, 443, 1424, 1424, 443], [0, 49, 443, 1582, 1582, 443], [0, 49, 380, 968, 968, 380],
                [0, 49, 354.5, 493, 711.5, 997, 1283.5, 1501, 1639.5, 1689, 1640.5, 1501, 1284.5, 997], [0, 49, 815, 1013, 1537, 289],
                [0, 49, 291, 1751, 1751, 1701, 1654.1, 1513.5, 1296.6, 1021], [-53, 187, 375, 615, 615, 379, 183, -53], [26, 1374, 832, 568],
                [200, 728, 983.5, 1168, 1281, 1323, 1196, 1159, 1040, 885, 641, 200], [200, 398, 1162, 1162, 200], [26, 1414, 852, 588], [200, 1181, 1181, 200],
                [126, 1288, 1288, 1266, 160, 126], [200, 1339, 1339, 200], [115, 163.5, 302, 520.5, 806, 1092.5, 1310, 1448.5, 1498, 1449.5, 1310, 1093.5, 806, 521.5, 303, 163],
                [137, 725, 725, 137], [205, 1397, 1366, 205], [26, 1378, 822, 582], [200, 1526, 1526, 200], [200, 1336, 1336, 200], [114, 1215, 1215, 114],
                [115, 163.5, 302, 520.5, 806, 1092.5, 1310, 1448.5, 1498, 1449.5, 1310, 1093.5, 806, 521.5, 303, 163], [200, 1339, 1339, 200],
                [200, 398, 1043, 1139.5, 1174, 1127.5, 996, 831, 604, 200], [118, 1280, 1280, 1234, 138, 118], [0, 532, 730, 1262, 1262, 0], [6, 532, 730, 1254, 225],
                [105, 149.5, 273, 740, 937, 1404, 1527.5, 1572, 1528.5, 1410, 937, 740, 267, 148], [68, 1335, 1336, 80], [179, 219.5, 338, 793, 990, 1446, 1563.5, 1604, 1604, 179],
                [108, 1568, 1568, 1518, 1471.1, 1330.5, 1113.6, 838, 562.4, 345.5, 204.9, 158, 108], [126, 137, 725, 738, 738, 126], [6, 532, 730, 1254, 939, 740, 327],
                [108, 137.4, 225.5, 363.6, 543, 1091, 1091, 743, 500, 148.5], [109, 152.5, 265, 417, 578, 796, 1006, 1006, 961, 721, 478, 191.5, 144],
                [185, 931, 1119, 1119, 1095.3, 802, 559, 185], [160, 187, 375, 403], [177, 207.8, 300, 448, 646, 846, 994, 1085.5, 1116, 1116, 1043, 760, 534, 251, 177],
                [108, 137.4, 225.5, 363.6, 543, 1091, 1091, 604, 416.5, 258, 148.5], [185, 373, 1030.5, 1131.4, 1165, 1084, 1050, 959, 825.5, 661, 462.1, 311.5, 216.6, 185],
                [61, 506, 694, 1151, 265], [106, 140.6, 244.5, 408.6, 624, 837.1, 1000.5, 1104.4, 1139, 1049, 239],
                [109, 152.5, 265, 417, 578, 796, 1006, 1006, 961, 789, 609, 449, 304, 191.5, 144], [108, 135.8, 219, 646, 825, 937, 982, 942, 198],
                [185, 931, 1119, 1119, 1095.3, 1024, 907.5, 748, 185], [137, 159.5, 219, 382, 639, 896, 1059, 1118, 1141, 1118, 1058, 895.5, 639, 382.5, 220, 159.5], [187, 375, 375, 187],
                [193, 1192, 1122, 1085, 1027, 193], [61, 1151, 522, 311], [185, 373, 1125, 1125, 185], [61, 510, 699, 1151, 265], [104, 138.5, 239, 704, 884, 995.5, 1041, 957, 133],
                [106, 140.9, 245.5, 409.4, 622, 833.3, 997, 1102, 1137, 1102, 997, 833.3, 622, 409.4, 245.5, 140.9], [185, 1120, 1120, 185],
                [185, 373, 1033.5, 1137.4, 1172, 1140, 1044, 887.3, 673, 477.5, 322, 220.5, 185], [105, 146.5, 261, 685, 862, 971, 1018, 986, 839, 675, 441.9, 260.5, 143.9],
                [106, 140.5, 244, 407.8, 623, 832.9, 996.5, 1101.9, 1295, 1295, 625, 412, 247, 141.3], [10, 414, 602, 1006, 1006, 10],
                [177, 207.8, 300, 448, 646, 846, 994, 1085.5, 1116, 1116, 177], [104, 151, 283, 715, 902, 1342.5, 1471.1, 1514, 1470.4, 1339.5, 1132.6, 861, 784.5, 714, 355, 163],
                [48, 1160, 1149, 59], [176, 223.5, 748, 935, 1459, 1507, 1507, 176], [113, 136.5, 211, 343.5, 538, 1128, 1321.5, 1455, 1529.5, 1553, 1496, 1295, 371, 170],
                [5, 187, 375, 557, 557, 5], [177, 207.8, 300, 448, 646, 846, 994, 1085.5, 1116, 1116, 953, 341, 177],
                [106, 140.9, 245.5, 409.4, 622, 833.3, 997, 1102, 1137, 1102, 743, 500, 140.9], [177, 207.8, 300, 448, 646, 846, 994, 1085.5, 1116, 1116, 768, 525, 177],
                [113, 136.5, 211, 343.5, 538, 1128, 1321.5, 1455, 1529.5, 1553, 1496, 955, 712, 170],
                [149, 179.4, 270.5, 409.6, 584, 798.5, 985, 1106, 1145, 1130.5, 1074, 909.5, 670, 473.5, 292], [50, 1438, 876, 612], [144, 344, 1332, 1532, 1532, 144],
                [187, 1369, 1369, 1330, 197, 187], [220, 1456, 1456, 220], [-102, 63, 843, 678], [253, 492, 492, 253], [134, 755, 857, 1737, 1570, 134],
                [161, 189.3, 274, 406.5, 578, 1435, 1620.9, 1764.5, 1856.4, 1887, 1858.8, 1774, 1641.5, 1470, 613, 430.3, 286, 192.3],
                [138, 241.5, 348, 515.3, 641, 719, 1168, 1168, 1063, 954, 786.3, 661, 583, 138], [243, 400, 1070, 1214, 1320, 1432, 1431, 1274, 604, 462.4, 355.5, 243],
                [245, 566, 719, 1431, 1431, 1109, 956, 245], [254, 1408, 1408, 254], [268, 1422, 1422, 268]
            ];
            this.OUTLINE_Y = [
                [], [1489, 0, 0, 1489], [1556, 977, 977, 1556, 1556], [421, 0, 0, 421, 932, 1067, 1489, 1489, 1067, 556],
                [85, -361, -361, 238.1, 380, 1231, 1576, 1576, 1185, 1071.5, 935, 283], [1075, 880.5, 743, 0, -29, -1.8, 80, 217.8, 413, 607.5, 745, 1489, 1517, 1489.8, 1408, 1270.3],
                [409, 230.9, 90.5, -0.6, -31, 0, 909, 1333.4, 1432.5, 1498.1, 1520, 1490, 1412, 1301.5, 1174], [1556, 977, 977, 1556], [572, 286.3, 31, -412, -412, 1556, 1556, 1113, 857.8],
                [-412, -412, 31, 286.3, 572, 857.8, 1113, 1556, 1556], [886, 776, 630, 630, 777, 887, 1299, 1409, 1556, 1556, 1410, 1300], [572, 27, 27, 572, 732, 1277, 1277, 732],
                [-370, -370, 285, 285], [561, 561, 742, 742], [0, 0, 285, 285], [-304, -304, 1556, 1556],
                [743, 400, 159, 16.5, -31, 15.9, 156.5, 397.4, 745, 1084.9, 1326.5, 1470.9, 1519, 1471.6, 1329.5, 1088.1], [0, 0, 152, 1494, 1494, 1286],
                [0, 0, 171, 1110, 1279.4, 1409.5, 1492.4, 1520, 1491, 1427, 209], [63, -1.5, -31, 2.5, 106, 254, 441, 1161, 1320, 1436, 1500, 1520, 1490.5, 1426, 272],
                [419, 0, 0, 419, 579, 1489, 1489, 649], [56, -5.5, -31, 6.5, 114, 274, 473, 1489, 1489, 267],
                [654, 324, 104, 3, -31, 4.9, 112.5, 276.9, 483, 1494, 1512, 1517, 1453.5, 1277, 1005], [1314, 0, 0, 1266, 1489, 1489],
                [411, 233.5, 91, -2.8, -34, -2, 94, 238.3, 415, 1144, 1294.5, 1416, 1496.3, 1523, 1495, 1411, 1285, 1131],
                [1005, -6, -23.5, -29, 33, 209, 480, 834, 1171.5, 1385, 1485.5, 1519, 1483.3, 1376, 1211.8], [0, 0, 1117, 1117], [-370, -370, 285, 1117, 1117], [590, 77, 1227, 714],
                [362, 362, 942, 942], [77, 590, 714, 1227], [1245, 0, 0, 964.5, 1139, 1293.4, 1414.5, 1492.9, 1519, 1497.5, 1449],
                [647, 291, 15, -162.5, -226, -218.5, -190, 157, 394, 663, 1013.5, 1283, 1457, 1519, 1452, 1268, 991.5], [0, 0, 1489, 1489],
                [0, 0, 28, 122, 262, 458, 1155, 1316.5, 1427, 1477, 1489, 1489], [743, 402.5, 161, 18.5, -27, -13.5, 19, 63, 108, 1385, 1487, 1516, 1465, 1317, 1072],
                [0, 0, 28, 119, 375, 743, 1118, 1371, 1457.5, 1489, 1489], [0, 0, 1489, 1489], [0, 0, 717, 1313, 1489, 1489],
                [746, 405.5, 163, 19, -29, 12.5, 110, 749, 1382, 1485.5, 1516, 1464.4, 1309.5, 1065.4], [0, 0, 1489, 1489], [0, 0, 1489, 1489],
                [8, -12.5, -21, 5.5, 85, 213.5, 387, 1489, 1489, 193], [0, 0, 1489, 1489], [0, 0, 176, 1489, 1489], [0, 0, 1489, 1489], [0, 0, 1489, 1489],
                [744, 415, 172, 21, -31, 20, 172, 414.5, 744, 1073, 1318, 1467.5, 1520, 1468, 1318, 1070.5], [0, 0, 709, 855.5, 1039, 1254, 1396, 1466.5, 1489, 1489],
                [744, 415, 172, 21, -297.5, -369.1, -393, -386.5, -365, -183, 744, 1073, 1318, 1467.5, 1520, 1468, 1318, 1070.5], [0, 0, 1280.5, 1409, 1471.5, 1489, 1489],
                [92, 3, -27, 9, 109, 253, 425, 1412, 1486, 1516, 1486.1, 1396.5, 1260.1, 1090, 340], [1313, 0, 0, 1313, 1489, 1489], [598, 313, 115, 6, -31, 4, 115, 315.5, 598, 1489, 1489],
                [1489, 0, 0, 1489, 1489], [1489, 0, 0, 1489, 1489], [0, 0, 1489, 1489], [1489, 0, 0, 1489, 1489], [0, 0, 176, 1489, 1489, 184], [-392, -392, 1556, 1556],
                [1556, -304, -304, 1556], [-392, -392, 1556, 1556], [682, 682, 684, 1489, 1489], [-300, -300, -180, -180], [1676, 1302, 1302, 1676],
                [324, 182.8, 69, -6, -31, 0, 758, 939, 1058, 1124.5, 1144, 1126, 1093], [0, -31, 8.5, 127, 315, 567, 812.8, 996, 1110, 1556, 1556],
                [557, 300, 118, 10.5, -25, 0, 70, 1050, 1116, 1143, 1104, 987, 801.5], [550, 306.8, 123, 7.5, -31, 0, 1556, 1556, 992, 803],
                [552, 306.6, 124.5, 11.6, -26, 1, 68, 539, 641, 856.3, 1016, 1115, 1148, 1107.8, 987, 797.8], [959, 0, 0, 959, 1374, 1546, 1560, 1566, 1539.4, 1459.5, 1117],
                [569, -375, -410.5, -423, -389.8, -290, -119.3, 127, 1117, 1148, 1108.5, 998, 817.5], [0, 0, 725, 906, 1039, 1556, 1556], [1304, 0, 0, 1304, 1499, 1499],
                [-395, -415, -423, -398, -323, -199, -27, 1304, 1499, 1499, 1117, -216], [0, 0, 1117, 1556, 1556], [0, 0, 1556, 1556], [0, 0, 725, 902.9, 1036.5, 1120.1, 1148, 1148, 1117],
                [0, 0, 725, 906, 1039, 1120.8, 1148, 1117], [558, 313.8, 127, 8.5, -31, 8.5, 127, 313.8, 558, 802.4, 989.5, 1108.4, 1148, 1108.4, 989.5, 802.4],
                [-412, -412, 133, 323.5, 572, 813.4, 995.5, 1109.9, 1148, 1117], [555, 314.1, 131.5, 16.4, -412, -412, 1117, 1148, 1108, 995, 809.5], [0, 0, 912, 1105, 1114.5, 1117, 1117],
                [67, 2.5, -27, -2.5, 71, 182.8, 322, 1060, 1119.5, 1144, 1116.5, 1042, 933, 803, 278], [959, 189.8, 70, 1, -22, -13, 10, 1117, 1438, 1438, 1117],
                [392, 209.1, 76.5, -4.1, -31, 0, 1117, 1117], [1117, 0, 0, 1117, 1117], [1117, 0, 0, 1117, 1117], [0, 0, 1117, 1117], [1117, -412, -412, 1117, 1117],
                [0, 0, 159, 1117, 1117, 139], [504, -170.9, -292.5, -367.1, -392, -392, 1556, 1556, 1531.1, 1456.5, 1334.9, 660], [-392, -392, 1556, 1556],
                [-392, -392, -367.1, -292.5, -170.9, 504, 660, 1334.9, 1456.5, 1531.1, 1556, 1556], [395, 395, 396, 440, 561, 732, 927, 927, 926, 880.5, 761, 589.5], [], [0, 0, 1489, 1489],
                [557, 333.5, 163, -361, -361, 74, 1046, 1475, 1475, 948.5, 775.9], [0, 0, 171, 1467, 1501, 1518, 1485.9, 1389.5, 1243.1, 751, 207],
                [258, 145, 147, 257, 1067, 1176, 1176, 1066], [1489, 426, 0, 0, 426, 1489, 1489], [-392, -392, 1556, 1556],
                [533, -327, -371.5, -385, -358, -275, -156, -10, 601, 1462, 1505, 1519, 1490, 1411, 1293.5, 1147], [1304, 1304, 1499, 1499],
                [655, 323.1, 43.5, -146.6, -210, -146.6, 43.5, 323.1, 655, 986.9, 1266.5, 1456.6, 1520, 1456.6, 1266.5, 986.9],
                [833, 616, 531, 554, 1192, 1332.4, 1435.5, 1498.9, 1520, 1504, 1475], [608, 162, 191, 1113, 1142, 697], [602, 57, 57, 762, 762], [561, 561, 742, 742],
                [655, 323.1, 43.5, -146.6, -210, -146.6, 43.5, 323.1, 655, 986.9, 1266.5, 1456.6, 1520, 1456.6, 1266.5, 986.9], [1788, 1668, 1668, 1788],
                [1116, 960.4, 831.5, 744.9, 716, 745, 832, 961, 1116, 1271, 1400, 1487, 1516, 1487, 1400, 1271], [179, 179, 917, 1462, 1462, 917],
                [566, 566, 711, 1237, 1350.4, 1440.5, 1519, 1501.5, 1458, 722], [585, 542, 527, 543.5, 595, 685.5, 817, 1278, 1374.5, 1452, 1520, 1502.5, 1458, 764],
                [1302, 1302, 1676, 1676], [-412, -412, 0, 1117, 1117], [1050, 866, -363, -363, 1489, 1489, 1460, 1373, 1234.3], [511, 511, 794, 794],
                [-397, -416, -423, -337, -232, -89, -25, 20, 20, -237], [1256, 566, 566, 688, 1493, 1493, 1368],
                [1025, 820.1, 663.5, 564.1, 531, 563.4, 660.5, 816.4, 1025, 1233.8, 1390, 1487.5, 1520, 1486.8, 1387, 1230], [191, 162, 608, 697, 1142, 1113],
                [1246, 0, 0, 220, 353, 944, 1489, 1493, 1493, 1363], [1246, 0, 0, 139, 664, 865, 1489, 1493, 1493, 1363], [598, 0, 0, 220, 353, 944, 1489, 1517, 1500, 1456, 773],
                [350, 195.6, 74.5, -3.9, -30, -10, 40, 244, 1489, 1489, 523], [0, 0, 1675, 2049, 2049], [0, 0, 2049, 2049, 1675], [0, 0, 1670, 2049, 2049, 1670],
                [0, 0, 1992, 1992, 1987, 1910, 1682], [0, 0, 1872, 1872, 1872], [0, 0, 1712, 1843.5, 1952, 2024.8, 2049, 2024.8, 1952, 1843.5, 1712], [0, 0, 1489, 1489],
                [743, 402.5, -397, -416, -423, -337, 108, 1385, 1487, 1516, 1465, 1317, 1072], [0, 0, 1489, 2049, 2049, 1489], [0, 0, 1489, 2049, 2049, 1489], [0, 0, 1489, 2049, 2049, 1489],
                [0, 0, 1489, 1872, 1872, 1489], [0, 0, 1489, 2049, 2049, 1489], [0, 0, 2049, 2049, 1489], [1670, 0, 0, 1670, 2049, 2049], [1677, 0, 0, 1677, 1872, 1872],
                [740, 0, 0, 28, 119, 375, 743, 1118, 1371, 1457.5, 1489, 1489, 883], [0, 0, 1489, 1992, 1992, 1987, 1910, 1489],
                [744, 415, 172, 21, -31, 20, 172, 414.5, 744, 1073, 1318, 2049, 2049, 1070.5], [744, 415, 172, 21, -31, 20, 172, 414.5, 744, 1073, 2049, 2049, 1318, 1070.5],
                [744, 415, 172, 21, -31, 20, 172, 414.5, 744, 1073, 1670, 2049, 2049, 1670, 1070.5], [744, 415, 172, 21, -31, 20, 172, 414.5, 744, 1073, 1992, 1992, 1987, 1910, 1070.5],
                [744, 415, 172, 21, -31, 20, 172, 414.5, 744, 1073, 1872, 1872, 1872, 1070.5], [216, 105, 105, 216, 1088, 1199, 1199, 1088],
                [744, -146, -146, 20, 172, 414.5, 744, 1611, 1611, 1520, 1468, 1318, 1070.5], [598, 313, 115, 6, -31, 4, 115, 315.5, 598, 1489, 2049, 2049, 1489],
                [598, 313, 115, 6, -31, 4, 115, 315.5, 598, 1489, 2049, 2049, 1489], [598, 313, 115, 6, -31, 4, 115, 315.5, 598, 1489, 2049, 2049, 1489],
                [598, 313, 115, 6, -31, 4, 115, 315.5, 598, 1489, 1872, 1872, 1489], [1489, 0, 0, 1489, 2049, 2049], [0, 0, 469, 610.5, 787, 992, 1130, 1489, 1489],
                [0, -24, 12.4, 121.5, 284.1, 481, 1241, 1376, 1479, 1544.3, 1566, 1536.5, 1449, 1295.5, 1080], [324, 182.8, 69, -6, -31, 0, 758, 939, 1676, 1676, 1093],
                [324, 182.8, 69, -6, -31, 0, 758, 1676, 1676, 1093], [324, 182.8, 69, -6, -31, 0, 758, 1297, 1676, 1676, 1297, 1093],
                [324, 182.8, 69, -6, -31, 0, 758, 1619, 1619, 1614, 1537, 1309], [324, 182.8, 69, -6, -31, 0, 758, 1499, 1499, 1093],
                [324, 182.8, 69, -6, -31, 0, 758, 1630, 1761.8, 1871, 1944.5, 1969, 1944.5, 1871, 1761.8, 1630],
                [317, 178.8, 68, -4.8, -29, -26, 3.5, 68, 559, 641, 861.3, 1020, 1116, 1148, 1146, 1127, 1093], [557, 300, -397, -416, -423, -337, -232, 70, 1050, 1116, 1143, 1104, 987, 801.5],
                [552, 306.6, 124.5, 11.6, -26, 1, 68, 539, 641, 856.3, 1016, 1676, 1676, 797.8], [552, 306.6, 124.5, 11.6, -26, 1, 68, 539, 641, 856.3, 1676, 1676, 987, 797.8],
                [552, 306.6, 124.5, 11.6, -26, 1, 68, 539, 641, 856.3, 1297, 1676, 1676, 1297, 797.8], [552, 306.6, 124.5, 11.6, -26, 1, 68, 539, 641, 856.3, 1499, 1499, 797.8],
                [1676, 0, 0, 1302, 1676], [1302, 0, 0, 1676, 1676], [1297, 0, 0, 1297, 1676, 1676], [1304, 0, 0, 1304, 1499, 1499],
                [484, 266.5, 104, 2.8, -31, 12, 141, 351, 637, 1469, 1566, 1556], [0, 0, 725, 1619, 1619, 1614, 1537, 1309, 1117],
                [558, 313.8, 127, 8.5, -31, 8.5, 127, 313.8, 558, 802.4, 989.5, 1676, 1676, 802.4], [558, 313.8, 127, 8.5, -31, 8.5, 127, 313.8, 558, 802.4, 1676, 1676, 989.5, 802.4],
                [558, 313.8, 127, 8.5, -31, 8.5, 127, 313.8, 558, 802.4, 1297, 1676, 1676, 1297, 802.4], [558, 313.8, 127, 8.5, -31, 8.5, 127, 313.8, 558, 1619, 1619, 1614, 1537, 1309],
                [558, 313.8, 127, 8.5, -31, 8.5, 127, 313.8, 558, 802.4, 1499, 1499, 1499, 802.4], [572, 7, 7, 572, 732, 1297, 1297, 732],
                [-148, -148, 8.5, 127, 313.8, 558, 1241, 1241, 1108.4, 989.5, 802.4, 558], [392, 209.1, 76.5, -4.1, -31, 0, 1117, 1676, 1676, 1117],
                [392, 209.1, 76.5, -4.1, -31, 0, 1117, 1676, 1676, 1117], [392, 209.1, 76.5, -4.1, -31, 0, 1117, 1676, 1676, 1117], [392, 209.1, 76.5, -4.1, -31, 0, 1117, 1499, 1499, 1117],
                [1117, -412, -412, 1117, 1676, 1676], [-412, -412, 133, 323.5, 572, 813.4, 995.5, 1109.9, 1556, 1556], [-370, -370, 285, 1117, 1117], [1676, 1292, 1292, 1676],
                [1304, 1292, 1292, 1304, 1499, 1676, 1676, 1499], [1489, 0, 0, 1489], [832, 832, 1117, 1117], [1489, 1105, 0, 0, 1489, 1489], [1489, 1105, 0, 0, 1489, 1489],
                [1489, 1105, 0, 0, 1489, 1489], [1489, 1105, 415, 172, 21, -31, 20, 172, 414.5, 744, 1073, 1318, 1467.5, 1520], [1489, 1105, 0, 0, 1489, 1489],
                [1489, 1105, 0, 0, 174, 894, 1144.8, 1345, 1476.3, 1520], [1304, 0, 0, 1304, 1499, 1676, 1676, 1499], [0, 0, 1489, 1489],
                [0, 0, 28, 122, 262, 458, 1155, 1316.5, 1427, 1477, 1489, 1489], [0, 0, 1313, 1489, 1489], [0, 0, 1489, 1489], [0, 0, 1489, 1489], [0, 0, 176, 1489, 1489, 184],
                [0, 0, 1489, 1489], [744, 415, 172, 21, -31, 20, 172, 414.5, 744, 1073, 1318, 1467.5, 1520, 1468, 1318, 1070.5], [0, 0, 1489, 1489], [0, 0, 1489, 1489], [0, 0, 1489, 1489],
                [0, 0, 1489, 1489], [0, 0, 1489, 1489], [0, 0, 1489, 1489], [744, 415, 172, 21, -31, 20, 172, 414.5, 744, 1073, 1318, 1467.5, 1520, 1468, 1318, 1070.5], [0, 0, 1489, 1489],
                [0, 0, 709, 855.5, 1039, 1254, 1396, 1466.5, 1489, 1489], [0, 0, 176, 1489, 1489, 184], [1313, 0, 0, 1313, 1489, 1489], [1489, 0, 0, 1489, 1489],
                [755, 507, 325, -16, -16, 325, 506.5, 755, 994, 1171, 1505, 1505, 1171, 993], [0, 0, 1489, 1489], [910, 647, 471, 0, 0, 471, 645.5, 910, 1489, 1489],
                [0, 0, 174, 894, 1144.8, 1345, 1476.3, 1520, 1476.3, 1345, 1144.8, 894, 174], [1677, 0, 0, 1677, 1872, 1872], [1489, 0, 0, 1489, 1872, 1872, 1872],
                [550, 306.8, 123, 7.5, -31, 0, 1117, 1676, 1676, 803], [306, 148.5, 46, -10, -26, -5, 64, 270, 1083, 1676, 1676, 986.5, 839], [0, -412, -412, 725, 906, 1676, 1676, 1117],
                [1676, 0, 0, 1676], [407, 213.6, 77.5, -3.1, -30, -2.6, 79.5, 216.1, 407, 1117, 1499, 1676, 1676, 1499, 1117], [550, 306.8, 123, 7.5, -31, 0, 1117, 1148, 1108, 992, 803],
                [-412, -412, 110, 259.5, 444, 1195, 1355, 1467, 1534.5, 1556, 1524.3, 1429, 1277.8, 1078], [1117, -412, -412, 1117, 1117],
                [534, 299.6, 120.5, 6.9, -31, 7.8, 124, 308.3, 551, 1556, 1556], [306, 148.5, 46, -10, -26, -5, 64, 270, 1083, 1127.5, 1144, 1128, 1079, 986.5, 839],
                [463, 262.3, 118, -412, -412, -264.5, -96, 1556, 1556], [0, -412, -412, 725, 906, 1039, 1120.8, 1148, 1117],
                [768, 451.5, 241, 37.5, -31, 37.5, 241, 451.5, 768, 1073, 1288, 1487, 1556, 1487, 1288, 1073.5], [0, 0, 1117, 1117], [0, 0, 1117, 1118, 1119, 1117], [0, 0, 1556, 1556],
                [-412, -412, 0, 1117, 1117], [1117, 0, 0, 1117, 1117], [412, 248.5, 113, -412, -412, -265, -96, 1556, 1556],
                [558, 313.8, 127, 8.5, -31, 8.5, 127, 313.8, 558, 802.4, 989.5, 1108.4, 1148, 1108.4, 989.5, 802.4], [0, 0, 1117, 1117],
                [-412, -412, 148.5, 340.9, 577, 821.5, 1001, 1111.3, 1148, 1115, 1020, 861.5, 646], [549, 299, 129, -412, -412, -268, -96, 1079, 1124.5, 1143, 1102.5, 981, 792],
                [558, 313.8, 127, 8.5, -31, 7.5, 123, 308.8, 952, 1117, 1148, 1108.6, 990.5, 803.6], [952, 0, 0, 952, 1117, 1117],
                [407, 213.6, 77.5, -3.1, -30, -2.6, 79.5, 216.1, 407, 1117, 1117], [546, 314, 142, -412, -412, 159, 342.3, 576, 816.6, 996.5, 1108.6, 1146, 1145.5, 1143, 1117, 842],
                [-412, -412, 1117, 1117], [446, 248.5, -412, -412, 248, 446, 1117, 1117], [503, 310.5, 139, 16.5, -30, -30, 14.5, 139, 310.5, 503, 811.5, 1117, 1117, 811.5],
                [1304, 0, 0, 1304, 1499, 1499], [407, 213.6, 77.5, -3.1, -30, -2.6, 79.5, 216.1, 407, 1117, 1499, 1499, 1117],
                [558, 313.8, 127, 8.5, -31, 8.5, 127, 313.8, 558, 802.4, 1676, 1676, 802.4], [407, 213.6, 77.5, -3.1, -30, -2.6, 79.5, 216.1, 407, 1117, 1676, 1676, 1117],
                [503, 310.5, 139, 16.5, -30, -30, 14.5, 139, 310.5, 503, 811.5, 1676, 1676, 811.5], [424, 240.1, 94.5, -0.4, -32, 17, 190, 493, 837, 1097, 1286, 1464.5, 1519, 1496.5, 1430],
                [0, 0, 1489, 1489], [1315, -193, -193, 1315, 1489, 1489], [-189, -189, -13, 1489, 1489, 2], [572, 572, 732, 732], [0, 0, 1489, 1489], [511, 511, 794, 794],
                [842, -151, -151, 1788, 1788, 981], [642, 447.6, 292.5, 190.9, 157, 157, 190.4, 290.5, 450.4, 663, 857.4, 1012.5, 1114.1, 1148, 1148, 1114.5, 1014, 854],
                [-402, -417.5, -423, -395.5, -313, -179.8, 1367, 1545, 1560.5, 1566, 1538.5, 1456, 1321.8, -224], [202, 202, 209, 233.4, 306.5, 588, 1104, 1104, 1097, 1072.5, 999, 719],
                [362, 27, 27, 362, 942, 1277, 1277, 942], [0, 0, 1393, 910], [0, 0, 910, 1393]
            ];
            this.KERN_C1 = [
                '\'', '\'', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '.', '.', 'A', 'A', 'A', 'A', 'A', 'A', 'A',
                'A', 'A', 'A', 'A', 'A', 'B', 'B', 'B', 'B', 'C', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F',
                'I', 'J', 'J', 'J', 'J', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',
                'L', 'O', 'O', 'O', 'O', 'O', 'O', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'Q', 'Q', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'S',
                'S', 'S', 'S', 'S', 'S', 'S', 'S', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T',
                'T', 'T', 'T', 'T', 'T', 'T', 'U', 'U', 'U', 'U', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'W', 'W', 'W', 'W', 'W', 'W',
                'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y',
                'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z',
                'a', 'a', 'a', 'b', 'b', 'b', 'c', 'c', 'e', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'h', 'h', 'h', 'k', 'k', 'k', 'k', 'm', 'm',
                'm', 'n', 'n', 'n', 'o', 'o', 'o', 'o', 'o', 'p', 'p', 'p', 'r', 'r', 'r', 'r', 'r', 't', 't', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'w', 'w', 'w',
                'w', 'w', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'y', 'y', 'y', 'y', 'y', 'y', 'y', 'y', 'y', 'y', 'y', 'y', 'y', 'z', 'z', 'z', 'z', 'z', 'z', 'z',
                'z', 'z', '\u00C7', '\u00E7', '\u00D8', '\u00D8', '\u00D8', '\u00D8', '\u00D8', '\u00D8', '\u00F8', '\u00F8', '\u00F8', '\u00F8', '\u00F8'
            ];
            this.KERN_C2 = [
                '\u00C6', 'A', '\u00E6', '\u00C6', 'z', 'y', 'x', 'w', 'v', 'a', 'Z', 'Y', 'X', 'W', 'V', 'T', 'S', 'J', 'I', 'A', '-', ',', 'y', 'w', 'v', 'u', 't',
                'Y', 'W', 'V', 'U', 'T', 'S', '-', 'T', '.', '-', ',', '-', 'Z', 'Y', 'X', 'W', 'T', '.', ',', '\u00F8', '\u00E6', '\u00C6', 'o', 'e', 'a', 'T', 'A',
                '?', ';', ':', '.', ',', '-', '\u00C6', 'A', '.', ',', '\u00F8', '\u00E6', '\u00D8', 'y', 'w', 'v', 'u', 'o', 'e', 'a', 'O', '-', '\u00D8', '\u00C7',
                'y', 'v', 'Y', 'W', 'V', 'T', 'O', 'J', 'G', 'C', '-', '\'', 'Z', 'Y', 'X', 'T', '.', ',', '\u00F8', '\u00E6', '\u00C6', 'o', 'e', 'a', 'Y', 'A',
                '.', ',', '.', ',', '\u00F8', '\u00E6', 'y', 'u', 'o', 'e', 'a', 'Y', 'T', '-', '\u00C6', 'y', 'w', 'v', 'S', 'A', '.', ',', '\u00F8', '\u00E6',
                '\u00D8', '\u00C6', '\u00C7', 'z', 'y', 'w', 'v', 'u', 's', 'r', 'o', 'g', 'e', 'c', 'a', 'T', 'S', 'O', 'G', 'C', 'A', '?', ';', ':', '.', '-', ',',
                '\u00C6', 'A', '.', ',', '\u00F8', '\u00E6', '\u00C6', 'y', 'u', 'o', 'e', 'a', 'A', ';', ':', '.', '-', ',', '\u00F8', '\u00E6', '\u00C6', 'y', 'u',
                'r', 'o', 'e', 'a', 'A', ';', ':', '.', '-', ',', '\u00F8', '\u00E6', '\u00D8', '\u00C7', 'y', 'u', 'o', 'e', 'a', 'O', 'G', 'C', '-', '\u00F8',
                '\u00E6', '\u00D8', '\u00C6', 'v', 'u', 's', 'r', 'q', 'p', 'o', 'n', 'm', 'g', 'e', 'd', 'a', 'O', 'A', ';', ':', '.', '-', ',', '\u00F8', '\u00E6',
                '\u00D8', '\u00C7', 'y', 'w', 'o', 'e', 'a', 'Z', 'O', 'G', 'C', '-', 'y', 'w', 'v', 'y', '.', ',', 'T', '-', 'T', '}', 'y', ']', '\\', '?', '.',
                '-', ',', '*', ')', '\'', '"', 'y', 'w', 'v', '\u00F8', 'o', 'e', '-', 'y', 'w', 'v', 'y', 'w', 'v', 'y', 'x', 'v', '.', ',', 'y', '.', ',',
                '\u00E6', 'a', '.', '-', ',', 'y', '-', '\u00F8', '\u00E6', 'o', 'e', 'a', '.', '-', ',', '\u00E6', 'a', '.', '-', ',', '\u00F8', '\u00E7', 'o', 'g',
                'e', 'd', 'c', '-', '\u00F8', '\u00E6', '\u00E7', 'q', 'o', 'g', 'e', 'd', 'c', 'a', '.', '-', ',', '\u00F8', '\u00E7', 'q', 'o', 'g', 'e', 'd', 'c',
                '-', '-', '-', 'Z', 'Y', 'X', 'T', '.', ',', 'y', 'x', 'v', '.', ','
            ];
            this.KERN_K = [
                100, 100, 20, 50, 40, 40, 50, 20, 40, 20, 30, 140, 80, 50, 50, 150, 20, 100, 30, 50, 160, 130, 50, 30, 50, 10, 20, 80, 50, 60, 10, 120, 10, 50, 60,
                20, -10, 20, 50, 20, 20, 10, 20, 50, 50, 50, 50, 100, 110, 50, 50, 100, -30, 100, -60, 60, 60, 300, 300, 30, 10, 10, 20, 20, 70, 60, 20, 80, 70, 80,
                50, 70, 70, 60, 20, 110, 20, 20, 110, 110, 160, 100, 110, 170, 20, -100, 20, 20, 160, 120, 20, 20, 10, 50, 30, 30, 50, 50, 70, 50, 50, 50, -20, 50,
                300, 300, 30, 30, 50, 50, 55, 20, 50, 50, 40, 20, 60, 100, 20, 30, 20, 30, 22, 20, 20, 20, 220, 240, 50, 130, 40, 170, 200, 200, 200, 200, 180, 200,
                220, 210, 220, 220, 240, 70, 12, 50, 40, 40, 120, -60, 200, 200, 290, 150, 290, 20, 10, 20, 20, 100, 100, 70, 65, 60, 100, 100, 100, 60, 80, 80, 290,
                50, 290, 100, 100, 60, 65, 60, 60, 100, 100, 100, 50, 80, 80, 220, 50, 290, 60, 50, 10, 10, 80, 30, 60, 60, 50, 10, 10, 10, 80, 130, 140, 20, 80,
                100, 110, 110, 100, 130, 100, 130, 100, 100, 130, 130, 120, 140, 20, 80, 200, 200, 290, 140, 290, 60, 50, 20, 20, 65, 40, 60, 60, 50, 10, 20, 20, 20,
                60, 16, 10, 16, 5, 20, 30, 60, 20, 140, -100, 10, -100, -100, -110, 120, 50, 130, -50, -100, -60, -60, 20, 10, 20, 20, 20, 20, 100, 20, 10, 20, 20,
                10, 20, 15, 20, 15, 20, 30, 5, 20, 30, 40, 36, 290, 20, 290, 10, 40, 18, 40, 18, 18, 40, 180, 40, 180, 20, 20, 70, 20, 70, 24, 20, 24, 10, 24, 10,
                20, 50, 18, 40, 18, 10, 18, 10, 18, 10, 18, 40, 190, 40, 190, 12, 10, 10, 12, 10, 12, 10, 10, 20, 50, 20, 20, 20, 10, 50, 30, 30, 15, 20, 15, 20, 30
            ];
            this.pathCache = [];
            this.pathMissing = null;
            for (var n = this.GLYPH_DATA.length - 1; n >= 0; n--)
                this.pathCache[n] = null;
        }
        getKerning(ch1, ch2) {
            const sz = this.KERN_K.length;
            for (let n = 0; n < sz; n++)
                if (this.KERN_C1[n] == ch1 && this.KERN_C2[n] == ch2)
                    return this.KERN_K[n];
            return 0;
        }
        static measureText(txt, size) { return this.main.measureText(txt, size); }
        measureText(txt, size) {
            let font = FontData.main;
            let scale = size / font.UNITS_PER_EM;
            let dx = 0;
            for (let n = 0; n < txt.length; n++) {
                let ch = txt.charAt(n);
                let i = this.getIndex(ch);
                if (i < 0) {
                    dx += font.MISSING_HORZ;
                    continue;
                }
                dx += font.HORIZ_ADV_X[i];
                if (n < txt.length - 1)
                    dx += font.getKerning(ch, txt.charAt(n + 1));
            }
            return [dx * scale, font.ASCENT * scale * font.ASCENT_FUDGE, -font.DESCENT * scale];
        }
        getIndex(ch) {
            return this.UNICODE.indexOf(ch);
        }
        getRawGlyph(idx) {
            return this.GLYPH_DATA[idx];
        }
        ;
        getGlyphPath(idx) {
            path = this.pathCache[idx];
            if (path != null)
                return path;
            var path = new Path2D(this.GLYPH_DATA[idx]);
            this.pathCache[idx] = path;
            return path;
        }
        getMissingPath() {
            if (!this.pathMissing)
                this.pathMissing = new Path2D(this.MISSING_DATA);
            return this.pathMissing;
        }
        getOutlineX(idx) { return this.OUTLINE_X[idx].slice(0); }
        getOutlineY(idx) { return this.OUTLINE_Y[idx].slice(0); }
    }
    FontData.main = new FontData();
    WebMolKit.FontData = FontData;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let TextAlign;
    (function (TextAlign) {
        TextAlign[TextAlign["Centre"] = 0] = "Centre";
        TextAlign[TextAlign["Left"] = 1] = "Left";
        TextAlign[TextAlign["Right"] = 2] = "Right";
        TextAlign[TextAlign["Baseline"] = 0] = "Baseline";
        TextAlign[TextAlign["Middle"] = 4] = "Middle";
        TextAlign[TextAlign["Top"] = 8] = "Top";
        TextAlign[TextAlign["Bottom"] = 16] = "Bottom";
    })(TextAlign = WebMolKit.TextAlign || (WebMolKit.TextAlign = {}));
    class MetaVector {
        constructor(vec) {
            this.PRIM_LINE = 1;
            this.PRIM_RECT = 2;
            this.PRIM_OVAL = 3;
            this.PRIM_PATH = 4;
            this.PRIM_TEXT = 5;
            this.ONE_THIRD = 1.0 / 3;
            this.types = [];
            this.prims = [];
            this.width = 0;
            this.height = 0;
            this.offsetX = 0;
            this.offsetY = 0;
            this.scale = 1;
            this.density = 1;
            this.charMissing = false;
            this.lowX = null;
            this.lowY = null;
            this.highX = null;
            this.highY = null;
            const font = WebMolKit.FontData.main;
            this.charMask = WebMolKit.Vec.booleanArray(false, font.UNICODE.length);
            if (vec != null) {
                if (vec.size != null) {
                    this.width = vec.size[0];
                    this.height = vec.size[1];
                }
                if (vec.types != null)
                    this.types = vec.types;
                if (vec.prims != null)
                    this.prims = vec.prims;
                for (let p of this.prims)
                    if (p[0] == this.PRIM_TEXT) {
                        let txt = p[4];
                        for (let n = 0; n < txt.length; n++) {
                            let i = font.getIndex(txt.charAt(n));
                            if (i >= 0)
                                this.charMask[i] = true;
                            else
                                this.charMissing = true;
                        }
                    }
            }
        }
        drawLine(x1, y1, x2, y2, colour, thickness) {
            if (thickness == null)
                thickness = 1;
            let typeidx = this.findOrCreateType([this.PRIM_LINE, thickness, colour]);
            const bump = 0.5 * thickness;
            this.updateBounds(Math.min(x1, x2) - bump, Math.min(y1, y2) - bump);
            this.updateBounds(Math.max(x1, x2) + bump, Math.max(y1, y2) + bump);
            this.prims.push([this.PRIM_LINE, typeidx, x1, y1, x2, y2]);
        }
        drawRect(x, y, w, h, edgeCol, thickness, fillCol) {
            if (edgeCol == null)
                edgeCol = -1;
            if (fillCol == null)
                fillCol = -1;
            if (thickness == null)
                thickness = 1;
            let typeidx = this.findOrCreateType([this.PRIM_RECT, edgeCol, fillCol, thickness]);
            const bump = 0.5 * thickness;
            this.updateBounds(x - bump, y - bump);
            this.updateBounds(x + w + bump, y + h + bump);
            this.prims.push([this.PRIM_RECT, typeidx, x, y, w, h]);
        }
        drawOval(cx, cy, rw, rh, edgeCol, thickness, fillCol) {
            if (edgeCol == null)
                edgeCol = -1;
            if (fillCol == null)
                fillCol = -1;
            if (thickness == null)
                thickness = 1;
            const bump = 0.5 * thickness;
            this.updateBounds(cx - rw - bump, cy - rh - bump);
            this.updateBounds(cx + rw + bump, cy + rh + bump);
            let typeidx = this.findOrCreateType([this.PRIM_OVAL, edgeCol, fillCol, thickness]);
            this.prims.push([this.PRIM_OVAL, typeidx, cx, cy, rw, rh]);
        }
        drawPath(xpoints, ypoints, ctrlFlags, isClosed, edgeCol, thickness, fillCol, hardEdge) {
            if (edgeCol == null)
                edgeCol = -1;
            if (fillCol == null)
                fillCol = -1;
            if (thickness == null)
                thickness = 1;
            if (hardEdge == null)
                hardEdge = false;
            const bump = 0.5 * thickness;
            for (let n = 0; n < xpoints.length; n++) {
                this.updateBounds(xpoints[n] - bump, ypoints[n] - bump);
                if (bump != 0)
                    this.updateBounds(xpoints[n] + bump, ypoints[n] + bump);
            }
            let typeidx = this.findOrCreateType([this.PRIM_PATH, edgeCol, fillCol, thickness, hardEdge]);
            this.prims.push([this.PRIM_PATH, typeidx, xpoints.length, WebMolKit.clone(xpoints), WebMolKit.clone(ypoints), WebMolKit.clone(ctrlFlags), isClosed]);
        }
        drawPoly(xpoints, ypoints, edgeCol, thickness, fillCol, hardEdge) {
            this.drawPath(xpoints, ypoints, null, true, edgeCol, thickness, fillCol, hardEdge);
        }
        drawText(x, y, txt, size, colour, align) {
            if (align == null)
                align = TextAlign.Left | TextAlign.Baseline;
            const font = WebMolKit.FontData.main;
            for (let n = 0; n < txt.length; n++) {
                let i = font.getIndex(txt.charAt(n));
                if (i >= 0)
                    this.charMask[i] = true;
                else
                    this.charMissing = true;
            }
            let metrics = font.measureText(txt, size);
            let bx = 0, by = 0;
            if ((align & TextAlign.Left) != 0) { }
            else if ((align & TextAlign.Right) != 0)
                bx = -metrics[0];
            else
                bx = -0.5 * metrics[0];
            if ((align & TextAlign.Middle) != 0)
                by += 0.5 * metrics[1];
            else if ((align & TextAlign.Top) != 0)
                by += metrics[1];
            else if ((align & TextAlign.Bottom) != 0)
                by -= metrics[2];
            let x1 = 0, y1 = 0, x2 = 0, y2 = 0;
            let dx = 0;
            for (let n = 0; n < txt.length; n++) {
                let ch = txt.charAt(n);
                let i = font.getIndex(ch);
                if (i >= 0) {
                    let outlineX = font.getOutlineX(i), outlineY = font.getOutlineY(i);
                    x1 = Math.min(x1, dx + WebMolKit.Vec.min(outlineX));
                    x2 = Math.max(x2, dx + WebMolKit.Vec.max(outlineX));
                    y1 = Math.min(y1, -WebMolKit.Vec.max(outlineY));
                    y2 = Math.max(y2, -WebMolKit.Vec.min(outlineY));
                    dx += font.HORIZ_ADV_X[i];
                    if (n < txt.length - 1)
                        dx += font.getKerning(ch, txt.charAt(n + 1));
                }
                else
                    dx += font.MISSING_HORZ;
            }
            const mscale = size * font.INV_UNITS_PER_EM;
            this.updateBounds(x + bx + x1 * mscale, y + by + y1 * mscale);
            this.updateBounds(x + bx + x2 * mscale, y + by + y2 * mscale);
            let typeidx = this.findOrCreateType([this.PRIM_TEXT, size, colour]);
            this.prims.push([this.PRIM_TEXT, typeidx, x + bx, y + by, txt]);
        }
        boundLowX() { return this.lowX; }
        boundLowY() { return this.lowY; }
        boundHighX() { return this.highX; }
        boundHighY() { return this.highY; }
        measure() {
            this.width = Math.ceil(this.highX - this.lowX);
            this.height = Math.ceil(this.highY - this.lowY);
        }
        normalise() {
            if (this.lowX != 0 || this.lowY != 0)
                this.transformPrimitives(-this.lowX, -this.lowY, 1, 1);
            this.width = Math.ceil(this.highX - this.lowX);
            this.height = Math.ceil(this.highY - this.lowY);
        }
        setSize(width, height) { this.width = width; this.height = height; }
        transformIntoBox(box) {
            this.transformPrimitives(-this.lowX, -this.lowY, 1, 1);
            let nw = Math.ceil(this.highX - this.lowX), nh = Math.ceil(this.highY - this.lowY);
            let scale = 1;
            if (nw > box.w) {
                let mod = box.w / nw;
                nw = box.w;
                nh *= mod;
                scale *= mod;
            }
            if (nh > box.h) {
                let mod = box.h / nh;
                nh = box.h;
                nw *= mod;
                scale *= mod;
            }
            let ox = 0.5 * (box.w - nw), oy = 0.5 * (box.h - nh);
            this.transformPrimitives(box.x + ox, box.y + oy, scale, scale);
        }
        transformPrimitives(ox, oy, sw, sh) {
            if (ox == 0 && oy == 0 && sw == 1 && sh == 1)
                return;
            for (let a of this.prims) {
                const type = a[0];
                if (type == this.PRIM_LINE) {
                    a[2] = ox + ((a[2] - this.lowX) * sw + this.lowX);
                    a[3] = oy + ((a[3] - this.lowY) * sh + this.lowY);
                    a[4] = ox + ((a[4] - this.lowX) * sw + this.lowX);
                    a[5] = oy + ((a[5] - this.lowY) * sh + this.lowY);
                }
                else if (type == this.PRIM_RECT) {
                    a[2] = ox + ((a[2] - this.lowX) * sw + this.lowX);
                    a[3] = oy + ((a[3] - this.lowY) * sh + this.lowY);
                    a[4] = a[4] * sw;
                    a[5] = a[5] * sh;
                }
                else if (type == this.PRIM_OVAL) {
                    a[2] = ox + ((a[2] - this.lowX) * sw + this.lowX);
                    a[3] = oy + ((a[3] - this.lowY) * sh + this.lowY);
                    a[4] *= sw;
                    a[5] *= sh;
                }
                else if (type == this.PRIM_PATH) {
                    let sz = a[2], px = a[3], py = a[4];
                    for (let n = 0; n < sz; n++) {
                        px[n] = ox + ((px[n] - this.lowX) * sw + this.lowX);
                        py[n] = oy + ((py[n] - this.lowY) * sh + this.lowY);
                    }
                }
                else if (type == this.PRIM_TEXT) {
                    a[2] = ox + ((a[2] - this.lowX) * sw + this.lowX);
                    a[3] = oy + ((a[3] - this.lowY) * sh + this.lowY);
                }
            }
            let swsh = 0.5 * (sw + sh);
            if (swsh != 1)
                for (let t of this.types) {
                    const type = t[0];
                    if (type == this.PRIM_LINE)
                        t[1] *= swsh;
                    else if (type == this.PRIM_RECT)
                        t[3] *= swsh;
                    else if (type == this.PRIM_OVAL)
                        t[3] *= swsh;
                    else if (type == this.PRIM_PATH)
                        t[3] *= swsh;
                    else if (type == this.PRIM_TEXT)
                        t[1] *= swsh;
                }
            this.highX = ox + this.lowX + (this.highX - this.lowX) * sw;
            this.highY = oy + this.lowY + (this.highY - this.lowY) * sh;
            this.lowX += ox;
            this.lowY += oy;
        }
        renderInto(parent) {
            let canvas = WebMolKit.newElement(parent, 'canvas', { 'width': this.width, 'height': this.height });
            this.renderCanvas(canvas);
            return canvas;
        }
        renderCanvas(canvas, clearFirst) {
            let ctx = canvas.getContext('2d');
            if (clearFirst)
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            let w = canvas.style.width ? parseInt(canvas.style.width) : canvas.width / this.density;
            let h = canvas.style.height ? parseInt(canvas.style.height) : canvas.height / this.density;
            this.density = WebMolKit.pixelDensity();
            canvas.style.width = w + 'px';
            canvas.style.height = h + 'px';
            canvas.width = w * this.density;
            canvas.height = h * this.density;
            this.renderContext(ctx);
        }
        renderContext(ctx) {
            ctx.save();
            ctx.scale(this.density, this.density);
            this.typeObj = [];
            for (let n = 0; n < this.types.length; n++) {
                let t = this.types[n];
                if (t[0] == this.PRIM_LINE)
                    this.typeObj[n] = this.setupTypeLine(t);
                else if (t[0] == this.PRIM_RECT)
                    this.typeObj[n] = this.setupTypeRect(t);
                else if (t[0] == this.PRIM_OVAL)
                    this.typeObj[n] = this.setupTypeOval(t);
                else if (t[0] == this.PRIM_PATH)
                    this.typeObj[n] = this.setupTypePath(t);
                else if (t[0] == this.PRIM_TEXT)
                    this.typeObj[n] = this.setupTypeText(t);
            }
            for (let n = 0; n < this.prims.length; n++) {
                let p = this.prims[n];
                if (p[0] == this.PRIM_LINE)
                    this.renderLine(ctx, p);
                else if (p[0] == this.PRIM_RECT)
                    this.renderRect(ctx, p);
                else if (p[0] == this.PRIM_OVAL)
                    this.renderOval(ctx, p);
                else if (p[0] == this.PRIM_PATH)
                    this.renderPath(ctx, p);
                else if (p[0] == this.PRIM_TEXT)
                    this.renderText(ctx, p);
            }
            ctx.restore();
        }
        createSVG() {
            let svg = $('<svg></svg>');
            svg.attr('xmlns', 'http://www.w3.org/2000/svg');
            svg.attr('xmlns:xlink', 'http://www.w3.org/1999/xlink');
            svg.attr('width', this.width);
            svg.attr('height', this.height);
            svg.attr('viewBox', '0 0 ' + this.width + ' ' + this.height);
            this.renderSVG(svg);
            let tmp = $('<tmp></tmp>');
            tmp.append(svg);
            return tmp.html();
        }
        renderSVG(svg) {
            this.typeObj = [];
            const font = WebMolKit.FontData.main;
            let defs = $('<defs></defs>').appendTo(svg);
            if (this.charMissing) {
                let path = $('<path></path>').appendTo(defs);
                path.attr('id', 'missing');
                path.attr('d', font.MISSING_DATA);
                path.attr('edge', 'none');
            }
            for (let n = 0; n < font.UNICODE.length; n++)
                if (this.charMask[n]) {
                    let path = $('<path></path>').appendTo(defs);
                    path.attr('id', 'char' + n);
                    path.attr('d', font.GLYPH_DATA[n]);
                    path.attr('edge', 'none');
                }
            for (let n = 0; n < this.types.length; n++) {
                let t = this.types[n];
                if (t[0] == this.PRIM_LINE)
                    this.typeObj[n] = this.setupTypeLine(t);
                else if (t[0] == this.PRIM_RECT)
                    this.typeObj[n] = this.setupTypeRect(t);
                else if (t[0] == this.PRIM_OVAL)
                    this.typeObj[n] = this.setupTypeOval(t);
                else if (t[0] == this.PRIM_PATH)
                    this.typeObj[n] = this.setupTypePath(t);
                else if (t[0] == this.PRIM_TEXT)
                    this.typeObj[n] = this.setupTypeText(t);
            }
            for (let n = 0; n < this.prims.length;) {
                let p = this.prims[n], num = 1;
                if (p[0] != this.PRIM_PATH && p[0] != this.PRIM_TEXT) {
                    for (; n + num < this.prims.length; num++)
                        if (this.prims[n + num][0] != p[0] || this.prims[n + num][1] != p[1])
                            break;
                }
                if (p[0] == this.PRIM_LINE) {
                    if (num == 1)
                        this.svgLine1(svg, p);
                    else
                        this.svgLineN(svg, p, n, num);
                }
                else if (p[0] == this.PRIM_RECT) {
                    if (num == 1)
                        this.svgRect1(svg, p);
                    else
                        this.svgRectN(svg, p, n, num);
                }
                else if (p[0] == this.PRIM_OVAL) {
                    if (num == 1)
                        this.svgOval1(svg, p);
                    else
                        this.svgOvalN(svg, p, n, num);
                }
                else if (p[0] == this.PRIM_PATH)
                    this.svgPath(svg, p);
                else if (p[0] == this.PRIM_TEXT)
                    this.svgText(svg, p);
                n += num;
            }
        }
        setupTypeLine(t) {
            let thickness = t[1] * this.scale;
            let colour = t[2];
            return { 'thickness': thickness, 'colour': WebMolKit.colourCanvas(colour) };
        }
        setupTypeRect(t) {
            let edgeCol = t[1];
            let fillCol = t[2];
            let thickness = t[3] * this.scale;
            return { 'edgeCol': WebMolKit.colourCanvas(edgeCol), 'fillCol': WebMolKit.colourCanvas(fillCol), 'thickness': thickness };
        }
        setupTypeOval(t) {
            let edgeCol = t[1];
            let fillCol = t[2];
            let thickness = t[3] * this.scale;
            return { 'edgeCol': WebMolKit.colourCanvas(edgeCol), 'fillCol': WebMolKit.colourCanvas(fillCol), 'thickness': thickness };
        }
        setupTypePath(t) {
            let edgeCol = t[1];
            let fillCol = t[2];
            let thickness = t[3] * this.scale;
            let hardEdge = t[4];
            return { 'edgeCol': WebMolKit.colourCanvas(edgeCol), 'fillCol': WebMolKit.colourCanvas(fillCol), 'thickness': thickness, 'hardEdge': hardEdge };
        }
        setupTypeText(t) {
            let sz = t[1] * this.scale;
            let colour = t[2];
            return { 'colour': WebMolKit.colourCanvas(colour), 'size': sz };
        }
        renderLine(ctx, p) {
            let type = this.typeObj[p[1]];
            let x1 = p[2], y1 = p[3];
            let x2 = p[4], y2 = p[5];
            x1 = this.offsetX + this.scale * x1;
            y1 = this.offsetY + this.scale * y1;
            x2 = this.offsetX + this.scale * x2;
            y2 = this.offsetY + this.scale * y2;
            if (type.colour != null) {
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.strokeStyle = type.colour;
                ctx.lineWidth = type.thickness;
                ctx.lineCap = 'round';
                ctx.stroke();
            }
        }
        renderRect(ctx, p) {
            let type = this.typeObj[p[1]];
            let x = p[2], y = p[3];
            let w = p[4], h = p[5];
            x = this.offsetX + this.scale * x;
            y = this.offsetY + this.scale * y;
            w *= this.scale;
            h *= this.scale;
            if (type.fillCol != null) {
                ctx.fillStyle = type.fillCol;
                ctx.fillRect(x, y, w, h);
            }
            if (type.edgeCol != null) {
                ctx.strokeStyle = type.edgeCol;
                ctx.lineWidth = type.thickness;
                ctx.lineCap = 'square';
                ctx.strokeRect(x, y, w, h);
            }
        }
        renderOval(ctx, p) {
            let type = this.typeObj[p[1]];
            let cx = p[2], cy = p[3];
            let rw = p[4], rh = p[5];
            cx = this.offsetX + this.scale * cx;
            cy = this.offsetY + this.scale * cy;
            rw *= this.scale;
            rh *= this.scale;
            if (type.fillCol != null) {
                ctx.fillStyle = type.fillCol;
                ctx.beginPath();
                ctx.ellipse(cx, cy, rw, rh, 0, 0, 2 * Math.PI, true);
                ctx.fill();
            }
            if (type.edgeCol != null) {
                ctx.strokeStyle = type.edgeCol;
                ctx.lineWidth = type.thickness;
                ctx.beginPath();
                ctx.ellipse(cx, cy, rw, rh, 0, 0, 2 * Math.PI, true);
                ctx.stroke();
            }
        }
        renderPath(ctx, p) {
            let type = this.typeObj[p[1]];
            let npts = p[2];
            if (npts == 0)
                return;
            let x = p[3], y = p[4];
            let ctrl = p[5];
            let isClosed = p[6];
            for (let n = 0; n < npts; n++) {
                x[n] = this.offsetX + this.scale * x[n];
                y[n] = this.offsetY + this.scale * y[n];
            }
            for (let layer = 1; layer <= 2; layer++) {
                if (layer == 1 && type.fillCol == null)
                    continue;
                if (layer == 2 && type.edgeCol == null)
                    continue;
                ctx.beginPath();
                ctx.moveTo(x[0], y[0]);
                for (let i = 1; i < npts; i++) {
                    if (!ctrl || !ctrl[i]) {
                        ctx.lineTo(x[i], y[i]);
                    }
                    else if (i < npts - 1 && !ctrl[i + 1]) {
                        ctx.quadraticCurveTo(x[i], y[i], x[i + 1], y[i + 1]);
                        i++;
                    }
                    else if (i < npts - 1 && !ctrl[i + 2]) {
                        ctx.bezierCurveTo(x[i], y[i], x[i + 1], y[i + 1], x[i + 2], y[i + 2]);
                        i += 2;
                    }
                }
                if (isClosed)
                    ctx.closePath();
                if (layer == 1) {
                    ctx.fillStyle = type.fillCol;
                    ctx.fill();
                }
                else {
                    ctx.strokeStyle = type.edgeCol;
                    ctx.lineWidth = type.thickness;
                    ctx.lineCap = type.hardEdge ? 'square' : 'round';
                    ctx.lineJoin = type.hardEdge ? 'miter' : 'round';
                    ctx.stroke();
                }
            }
        }
        renderText(ctx, p) {
            let type = this.typeObj[p[1]];
            let x = p[2], y = p[3];
            let txt = p[4];
            let sz = type.size;
            let fill = type.colour;
            x = this.offsetX + this.scale * x;
            y = this.offsetY + this.scale * y;
            let font = WebMolKit.FontData.main;
            let scale = sz / font.UNITS_PER_EM;
            let dx = 0;
            for (let n = 0; n < txt.length; n++) {
                let ch = txt.charAt(n);
                let i = font.getIndex(ch);
                let path = null;
                if (i < 0) {
                    dx += font.MISSING_HORZ;
                    path = font.getMissingPath();
                }
                else
                    path = font.getGlyphPath(i);
                if (path) {
                    ctx.save();
                    ctx.translate(x + dx * scale, y);
                    ctx.scale(scale, -scale);
                    ctx.fillStyle = fill;
                    ctx.fill(path);
                    ctx.restore();
                }
                dx += font.HORIZ_ADV_X[i];
                if (n < txt.length - 1)
                    font.getKerning(ch, txt.charAt(n + 1));
            }
        }
        svgLine1(svg, p) {
            let type = this.typeObj[p[1]];
            let x1 = p[2], y1 = p[3];
            let x2 = p[4], y2 = p[5];
            x1 = this.offsetX + this.scale * x1;
            y1 = this.offsetY + this.scale * y1;
            x2 = this.offsetX + this.scale * x2;
            y2 = this.offsetY + this.scale * y2;
            if (type.colour != null) {
                let line = $('<line></line>').appendTo(svg);
                line.attr('x1', x1);
                line.attr('y1', y1);
                line.attr('x2', x2);
                line.attr('y2', y2);
                line.attr('stroke', type.colour);
                line.attr('stroke-width', type.thickness);
                line.attr('stroke-linecap', 'round');
            }
        }
        svgLineN(svg, p, pos, sz) {
            let type = this.typeObj[p[1]];
            if (type.colour == null)
                return;
            let g = $('<g></g>').appendTo(svg);
            g.attr('stroke', type.colour);
            g.attr('stroke-width', type.thickness);
            g.attr('stroke-linecap', 'round');
            for (let n = 0; n < sz; n++) {
                let p = this.prims[pos + n];
                let x1 = p[2], y1 = p[3];
                let x2 = p[4], y2 = p[5];
                x1 = this.offsetX + this.scale * x1;
                y1 = this.offsetY + this.scale * y1;
                x2 = this.offsetX + this.scale * x2;
                y2 = this.offsetY + this.scale * y2;
                let line = $('<line></line>').appendTo(g);
                line.attr('x1', x1);
                line.attr('y1', y1);
                line.attr('x2', x2);
                line.attr('y2', y2);
            }
        }
        svgRect1(svg, p) {
            let type = this.typeObj[p[1]];
            let x = p[2], y = p[3];
            let w = p[4], h = p[5];
            x = this.offsetX + this.scale * x;
            y = this.offsetY + this.scale * y;
            w *= this.scale;
            h *= this.scale;
            let rect = $('<rect></rect>').appendTo(svg);
            rect.attr('x', x);
            rect.attr('y', y);
            rect.attr('width', w);
            rect.attr('height', h);
            if (type.edgeCol != null) {
                rect.attr('stroke', type.edgeCol);
                rect.attr('stroke-width', type.thickness);
                rect.attr('stroke-linecap', 'square');
            }
            else
                rect.attr('stroke', 'none');
            rect.attr('fill', type.fillCol == null ? 'none' : type.fillCol);
        }
        svgRectN(svg, p, pos, sz) {
            let type = this.typeObj[p[1]];
            let g = $('<g></g>').appendTo(svg);
            if (type.edgeCol != null) {
                g.attr('stroke', type.edgeCol);
                g.attr('stroke-width', type.thickness);
                g.attr('stroke-linecap', 'square');
            }
            else
                g.attr('stroke', 'none');
            g.attr('fill', type.fillCol == null ? 'none' : type.fillCol);
            for (let n = 0; n < sz; n++) {
                let p = this.prims[pos + n];
                let x = p[2], y = p[3];
                let w = p[4], h = p[5];
                x = this.offsetX + this.scale * x;
                y = this.offsetY + this.scale * y;
                w *= this.scale;
                h *= this.scale;
                let rect = $('<rect></rect>').appendTo(g);
                rect.attr('x', x);
                rect.attr('y', y);
                rect.attr('width', w);
                rect.attr('height', h);
            }
        }
        svgOval1(svg, p) {
            let type = this.typeObj[p[1]];
            let cx = p[2], cy = p[3];
            let rw = p[4], rh = p[5];
            cx = this.offsetX + this.scale * cx;
            cy = this.offsetY + this.scale * cy;
            rw *= this.scale;
            rh *= this.scale;
            let oval = $('<ellipse></ellipse>').appendTo(svg);
            oval.attr('cx', cx);
            oval.attr('cy', cy);
            oval.attr('rx', rw);
            oval.attr('ry', rh);
            if (type.edgeCol != null) {
                oval.attr('stroke', type.edgeCol);
                oval.attr('stroke-width', type.thickness);
                oval.attr('stroke-linecap', 'square');
            }
            else
                oval.attr('stroke', 'none');
            oval.attr('fill', type.fillCol == null ? 'none' : type.fillCol);
        }
        svgOvalN(svg, p, pos, sz) {
            let type = this.typeObj[p[1]];
            let x = p[2], y = p[3];
            let w = p[4], h = p[5];
            let g = $('<g></g>').appendTo(svg);
            if (type.edgeCol != null) {
                g.attr('stroke', type.edgeCol);
                g.attr('stroke-width', type.thickness);
                g.attr('stroke-linecap', 'square');
            }
            else
                g.attr('stroke', 'none');
            g.attr('fill', type.fillCol == null ? 'none' : type.fillCol);
            for (let n = 0; n < sz; n++) {
                let p = this.prims[pos + n];
                let cx = p[2], cy = p[3];
                let rw = p[4], rh = p[5];
                cx = this.offsetX + this.scale * cx;
                cy = this.offsetY + this.scale * cy;
                rw *= this.scale;
                rh *= this.scale;
                let oval = $('<ellipse></ellipse>').appendTo(g);
                oval.attr('cx', cx);
                oval.attr('cy', cy);
                oval.attr('rx', rw);
                oval.attr('ry', rh);
            }
        }
        svgPath(svg, p) {
            let type = this.typeObj[p[1]];
            let npts = p[2];
            if (npts == 0)
                return;
            let x = p[3].slice(0), y = p[4].slice(0);
            let ctrl = p[5];
            let isClosed = p[6];
            for (let n = 0; n < npts; n++) {
                x[n] = this.offsetX + this.scale * x[n];
                y[n] = this.offsetY + this.scale * y[n];
            }
            let shape = 'M ' + x[0] + ' ' + y[0];
            let n = 1;
            while (n < npts) {
                if (!ctrl || !ctrl[n]) {
                    shape += ' L ' + x[n] + ' ' + y[n];
                    n++;
                }
                else if (ctrl[n] && n < npts - 1 && !ctrl[n + 1]) {
                    shape += ' Q ' + x[n] + ' ' + y[n] + ' ' + x[n + 1] + ' ' + y[n + 1];
                    n += 2;
                }
                else if (ctrl[n] && n < npts - 2 && ctrl[n + 1] && !ctrl[n + 2]) {
                    shape += ' C ' + x[n] + ' ' + y[n] + ' ' + x[n + 1] + ' ' + y[n + 1] + ' ' + x[n + 2] + ' ' + y[n + 2];
                    n += 3;
                }
                else
                    n++;
            }
            if (isClosed)
                shape += ' Z';
            let path = $('<path></path>').appendTo(svg);
            path.attr('d', shape);
            if (type.edgeCol != null) {
                path.attr('stroke', type.edgeCol);
                path.attr('stroke-width', type.thickness);
                path.attr('stroke-linejoin', type.hardEdge ? 'miter' : 'round');
                path.attr('stroke-linecap', type.hardEdge ? 'square' : 'round');
            }
            else
                path.attr('stroke', 'none');
            path.attr('fill', type.fillCol == null ? 'none' : type.fillCol);
        }
        svgText(svg, p) {
            let type = this.typeObj[p[1]];
            let x = p[2], y = p[3];
            let txt = p[4];
            let sz = type.size;
            let fill = type.colour;
            x = this.offsetX + this.scale * x;
            y = this.offsetY + this.scale * y;
            let font = WebMolKit.FontData.main;
            let scale = sz / font.UNITS_PER_EM;
            let gdelta = $('<g></g>').appendTo(svg);
            gdelta.attr('transform', 'translate(' + x + ',' + y + ')');
            gdelta.attr('fill', fill);
            let gscale = $('<g></g>').appendTo(gdelta);
            gscale.attr('transform', 'scale(' + scale + ',' + (-scale) + ')');
            let dx = 0;
            for (let n = 0; n < txt.length; n++) {
                let ch = txt.charAt(n);
                let i = font.getIndex(ch);
                let use = $('<use></use>').appendTo(gscale);
                let ref = i < 0 ? '#missing' : '#char' + i;
                use.attr('xlink:href', ref);
                use.attr('x', dx);
                if (i >= 0) {
                    dx += font.HORIZ_ADV_X[i];
                    if (n < txt.length - 1)
                        dx += font.getKerning(ch, txt.charAt(n + 1));
                }
                else
                    dx += font.MISSING_HORZ;
            }
        }
        findOrCreateType(typeDef) {
            for (let i = 0; i < this.types.length; i++) {
                if (this.types[i].length != typeDef.length)
                    continue;
                let match = true;
                for (let j = 0; j < typeDef.length; j++)
                    if (typeDef[j] != this.types[i][j]) {
                        match = false;
                        break;
                    }
                if (match)
                    return i;
            }
            this.types.push(typeDef);
            return this.types.length - 1;
        }
        updateBounds(x, y) {
            if (this.lowX == null) {
                this.lowX = x;
                this.lowY = y;
                this.highX = x;
                this.highY = y;
                return;
            }
            this.lowX = Math.min(this.lowX, x);
            this.lowY = Math.min(this.lowY, y);
            this.highX = Math.max(this.highX, x);
            this.highY = Math.max(this.highY, y);
        }
    }
    MetaVector.NOCOLOUR = -1;
    WebMolKit.MetaVector = MetaVector;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class RenderPolicy {
        constructor(data) {
            if (!data) {
                data =
                    {
                        'name': 'default',
                        'pointScale': 20,
                        'resolutionDPI': 100,
                        'fontSize': 0.65,
                        'lineSize': 0.075,
                        'bondSep': 0.2,
                        'defaultPadding': 0.2,
                        'foreground': 0x000000,
                        'background': 0xFFFFFF,
                        'atomCols': new Array(112)
                    };
                for (var n = 0; n <= 111; n++)
                    data.atomCols[n] = 0x000000;
                this.data = data;
            }
            else {
                this.data = WebMolKit.clone(data);
            }
        }
        ;
        static defaultBlackOnWhite() {
            var policy = new RenderPolicy();
            return policy;
        }
        ;
        static defaultWhiteOnBlack() {
            var policy = new RenderPolicy();
            policy.data.foreground = 0xFFFFFF;
            policy.data.background = 0x000000;
            for (var n = 0; n <= 111; n++)
                policy.data.atomCols[n] = 0xFFFFFF;
            return policy;
        }
        ;
        static defaultColourOnWhite() {
            var policy = RenderPolicy.defaultBlackOnWhite();
            policy.data.atomCols[0] = 0x404040;
            policy.data.atomCols[1] = 0x808080;
            policy.data.atomCols[6] = 0x000000;
            policy.data.atomCols[7] = 0x0000FF;
            policy.data.atomCols[8] = 0xFF0000;
            policy.data.atomCols[9] = 0xFF8080;
            policy.data.atomCols[15] = 0xFF8000;
            policy.data.atomCols[16] = 0x808000;
            policy.data.atomCols[17] = 0x00C000;
            policy.data.atomCols[35] = 0xC04000;
            return policy;
        }
        ;
        static defaultColourOnBlack() {
            var policy = RenderPolicy.defaultWhiteOnBlack();
            policy.data.atomCols[0] = 0xA0A0A0;
            policy.data.atomCols[1] = 0x808080;
            policy.data.atomCols[6] = 0xFFFFFF;
            policy.data.atomCols[7] = 0x4040FF;
            policy.data.atomCols[8] = 0xFF4040;
            policy.data.atomCols[9] = 0xFF8080;
            policy.data.atomCols[15] = 0xFF8000;
            policy.data.atomCols[16] = 0xFFFF00;
            policy.data.atomCols[17] = 0x40FF40;
            policy.data.atomCols[35] = 0xFF8040;
            return policy;
        }
        ;
        static defaultPrintedPublication() {
            var policy = RenderPolicy.defaultBlackOnWhite();
            policy.data.pointScale = 9.6;
            policy.data.resolutionDPI = 600;
            policy.data.fontSize = 0.80;
            policy.data.bondSep = 0.27;
            policy.data.lineSize = 0.0625;
            return policy;
        }
        ;
    }
    WebMolKit.RenderPolicy = RenderPolicy;
    class RenderEffects {
        constructor() {
            this.colAtom = {};
            this.colBond = {};
            this.dottedRectOutline = {};
            this.dottedBondCross = {};
            this.hideAtoms = new Set();
            this.hideBonds = new Set();
            this.atomFrameDotSz = [];
            this.atomFrameCol = [];
            this.atomCircleSz = [];
            this.atomCircleCol = [];
            this.atomDecoText = [];
            this.atomDecoCol = [];
            this.atomDecoSize = [];
            this.bondDecoText = [];
            this.bondDecoCol = [];
            this.bondDecoSize = [];
            this.overlapAtoms = [];
        }
    }
    WebMolKit.RenderEffects = RenderEffects;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class Aspect {
        constructor(ds, allowModify) {
            this.allowModify = true;
            this.ds = ds ? ds : new WebMolKit.DataSheet();
            if (allowModify != null)
                this.allowModify = allowModify;
        }
        isColumnReserved(colName) { return false; }
        areColumnsReserved(colNames) {
            let reserved = WebMolKit.Vec.booleanArray(false, colNames.length);
            for (let n = 0; n < colNames.length; n++)
                reserved[n] = this.isColumnReserved(colNames[n]);
            return reserved;
        }
        rowFirstBlock(row) { return true; }
        rowBlockCount(row) { return 1; }
        aspectUnion(other) { }
        numTextRenderings(row) { return 0; }
        produceTextRendering(row, idx) { return null; }
        numGraphicRenderings(row) { return 0; }
        produceGraphicRendering(row, idx, policy) { return [null, null]; }
        numHeaderRenderings() { return 0; }
        produceHeaderRendering(idx) { return null; }
    }
    Aspect.TEXT_PLAIN = 0;
    Aspect.TEXT_LINK = 1;
    Aspect.TEXT_HTML = 2;
    WebMolKit.Aspect = Aspect;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class Chemistry {
    }
    Chemistry.ELEMENTS = [
        null,
        "H", "He",
        "Li", "Be", "B", "C", "N", "O", "F", "Ne",
        "Na", "Mg", "Al", "Si", "P", "S", "Cl", "Ar",
        "K", "Ca", "Sc", "Ti", "V", "Cr", "Mn", "Fe", "Co", "Ni", "Cu", "Zn", "Ga", "Ge", "As", "Se", "Br", "Kr",
        "Rb", "Sr", "Y", "Zr", "Nb", "Mo", "Tc", "Ru", "Rh", "Pd", "Ag", "Cd", "In", "Sn", "Sb", "Te", "I", "Xe",
        "Cs", "Ba",
        "La", "Ce", "Pr", "Nd", "Pm", "Sm", "Eu", "Gd", "Tb", "Dy", "Ho", "Er", "Tm", "Yb",
        "Lu", "Hf", "Ta", "W", "Re", "Os", "Ir", "Pt", "Au", "Hg", "Tl", "Pb", "Bi", "Po", "At", "Rn",
        "Fr", "Ra",
        "Ac", "Th", "Pa", "U", "Np", "Pu", "Am", "Cm", "Bk", "Cf", "Es", "Fm", "Md", "No",
        "Lr", "Rf", "Db", "Sg", "Bh", "Hs", "Mt", "Ds", "Rg", "Cn"
    ];
    Chemistry.ELEMENT_GROUPS = [
        0,
        1, 18,
        1, 2, 13, 14, 15, 16, 17, 18,
        1, 2, 13, 14, 15, 16, 17, 18,
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
        1, 2,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
        1, 2,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 4, 5, 6, 7, 8, 9, 10, 11, 12
    ];
    Chemistry.ELEMENT_ROWS = [
        0,
        1, 1,
        2, 2, 2, 2, 2, 2, 2, 2,
        3, 3, 3, 3, 3, 3, 3, 3,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7
    ];
    Chemistry.ELEMENT_BLOCKS = [
        0,
        1, 2,
        1, 1, 2, 2, 2, 2, 2, 2,
        1, 1, 2, 2, 2, 2, 2, 2,
        1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2,
        1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2,
        1, 1,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2,
        1, 1,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3
    ];
    Chemistry.ELEMENT_VALENCE = [
        0,
        1, 2,
        1, 2, 3, 4, 5, 6, 7, 8,
        1, 2, 3, 4, 5, 6, 7, 8,
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 3, 4, 5, 6, 7, 8,
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 3, 4, 5, 6, 7, 8,
        1, 2,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 3, 4, 5, 6, 7, 8,
        1, 1,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        3, 4, 5, 6, 7, 8, 9, 10, 11, 12
    ];
    Chemistry.ELEMENT_BONDING = [
        0,
        1, 0,
        1, 2, 3, 4, 3, 2, 1, 0,
        1, 2, 3, 4, 3, 2, 1, 0,
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 3, 4, 3, 2, 1, 0,
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 3, 4, 3, 2, 1, 0,
        1, 2,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 3, 4, 3, 2, 1, 0,
        1, 1,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        3, 4, 5, 6, 7, 8, 9, 10, 11, 12
    ];
    Chemistry.ELEMENT_SHELL = [
        0,
        2, 2,
        8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 8, 8, 8, 8, 8, 8,
        8, 8, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 8, 8, 8, 8, 8, 8,
        8, 8,
        18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
        18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
        8, 8,
        18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
        18, 18, 18, 18, 18, 18, 18, 18, 18, 18
    ];
    Chemistry.NATURAL_ATOMIC_WEIGHTS = [
        0, 1.00794, 4.002602, 6.941, 9.012182, 10.811, 12.0107, 14.0067, 15.9994, 18.9984032, 20.1797,
        22.989770, 24.3050, 26.981538, 28.0855, 30.973761, 32.065, 35.453, 39.948, 39.0983, 40.078,
        44.955910, 47.867, 50.9415, 51.9961, 54.938049, 55.845, 58.933200, 58.6934, 63.546, 65.409,
        69.723, 72.64, 74.92160, 78.96, 79.904, 83.798, 85.4678, 87.62, 88.90585, 91.224, 92.90638,
        95.94, 98, 101.07, 102.90550, 106.42, 107.8682, 112.411, 114.818, 118.710, 121.760, 127.60,
        126.90447, 131.293, 132.90545, 137.327, 138.9055, 140.116, 140.90765, 144.24, 145, 150.36,
        151.964, 157.25, 158.92534, 162.500, 164.93032, 167.259, 168.93421, 173.04, 174.967, 178.49,
        180.9479, 183.84, 186.207, 190.23, 192.217, 195.078, 196.96655, 200.59, 204.3833, 207.2, 208.98038,
        209, 210, 222, 223, 226, 227, 230.0331266, 231.03588, 233.039628, 237, 244, 243, 247, 247, 251, 252, 257,
        258, 259, 262, 261, 262, 266, 264, 277, 268, 271, 272, 285
    ];
    Chemistry.ELEMENT_H = 1;
    Chemistry.ELEMENT_He = 2;
    Chemistry.ELEMENT_Li = 3;
    Chemistry.ELEMENT_Be = 4;
    Chemistry.ELEMENT_B = 5;
    Chemistry.ELEMENT_C = 6;
    Chemistry.ELEMENT_N = 7;
    Chemistry.ELEMENT_O = 8;
    Chemistry.ELEMENT_F = 9;
    Chemistry.ELEMENT_Ne = 10;
    Chemistry.ELEMENT_Na = 11;
    Chemistry.ELEMENT_Mg = 12;
    Chemistry.ELEMENT_Al = 13;
    Chemistry.ELEMENT_Si = 14;
    Chemistry.ELEMENT_P = 15;
    Chemistry.ELEMENT_S = 16;
    Chemistry.ELEMENT_Cl = 17;
    Chemistry.ELEMENT_Ar = 18;
    Chemistry.ELEMENT_K = 19;
    Chemistry.ELEMENT_Ca = 20;
    Chemistry.ELEMENT_Sc = 21;
    Chemistry.ELEMENT_Ti = 22;
    Chemistry.ELEMENT_V = 23;
    Chemistry.ELEMENT_Cr = 24;
    Chemistry.ELEMENT_Mn = 25;
    Chemistry.ELEMENT_Fe = 26;
    Chemistry.ELEMENT_Co = 27;
    Chemistry.ELEMENT_Ni = 28;
    Chemistry.ELEMENT_Cu = 29;
    Chemistry.ELEMENT_Zn = 30;
    Chemistry.ELEMENT_Ga = 31;
    Chemistry.ELEMENT_Ge = 32;
    Chemistry.ELEMENT_As = 33;
    Chemistry.ELEMENT_Se = 34;
    Chemistry.ELEMENT_Br = 35;
    Chemistry.ELEMENT_Kr = 36;
    Chemistry.ELEMENT_Rb = 37;
    Chemistry.ELEMENT_Sr = 38;
    Chemistry.ELEMENT_Y = 39;
    Chemistry.ELEMENT_Zr = 40;
    Chemistry.ELEMENT_Nb = 41;
    Chemistry.ELEMENT_Mo = 42;
    Chemistry.ELEMENT_Tc = 43;
    Chemistry.ELEMENT_Ru = 44;
    Chemistry.ELEMENT_Rh = 45;
    Chemistry.ELEMENT_Pd = 46;
    Chemistry.ELEMENT_Ag = 47;
    Chemistry.ELEMENT_Cd = 48;
    Chemistry.ELEMENT_In = 49;
    Chemistry.ELEMENT_Sn = 50;
    Chemistry.ELEMENT_Sb = 51;
    Chemistry.ELEMENT_Te = 52;
    Chemistry.ELEMENT_I = 53;
    Chemistry.ELEMENT_Xe = 54;
    Chemistry.ELEMENT_Cs = 55;
    Chemistry.ELEMENT_Ba = 56;
    Chemistry.ELEMENT_La = 57;
    Chemistry.ELEMENT_Ce = 58;
    Chemistry.ELEMENT_Pr = 59;
    Chemistry.ELEMENT_Nd = 60;
    Chemistry.ELEMENT_Pm = 61;
    Chemistry.ELEMENT_Sm = 62;
    Chemistry.ELEMENT_Eu = 63;
    Chemistry.ELEMENT_Gd = 64;
    Chemistry.ELEMENT_Tb = 65;
    Chemistry.ELEMENT_Dy = 66;
    Chemistry.ELEMENT_Ho = 67;
    Chemistry.ELEMENT_Er = 68;
    Chemistry.ELEMENT_Tm = 69;
    Chemistry.ELEMENT_Yb = 70;
    Chemistry.ELEMENT_Lu = 71;
    Chemistry.ELEMENT_Hf = 72;
    Chemistry.ELEMENT_Ta = 73;
    Chemistry.ELEMENT_W = 74;
    Chemistry.ELEMENT_Re = 75;
    Chemistry.ELEMENT_Os = 76;
    Chemistry.ELEMENT_Ir = 77;
    Chemistry.ELEMENT_Pt = 78;
    Chemistry.ELEMENT_Au = 79;
    Chemistry.ELEMENT_Hg = 80;
    Chemistry.ELEMENT_Tl = 81;
    Chemistry.ELEMENT_Pb = 82;
    Chemistry.ELEMENT_Bi = 83;
    Chemistry.ELEMENT_Po = 84;
    Chemistry.ELEMENT_At = 85;
    Chemistry.ELEMENT_Rn = 86;
    Chemistry.ELEMENT_Fr = 87;
    Chemistry.ELEMENT_Ra = 88;
    Chemistry.ELEMENT_Ac = 89;
    Chemistry.ELEMENT_Th = 90;
    Chemistry.ELEMENT_Pa = 91;
    Chemistry.ELEMENT_U = 92;
    Chemistry.ELEMENT_Np = 93;
    Chemistry.ELEMENT_Pu = 94;
    Chemistry.ELEMENT_Am = 95;
    Chemistry.ELEMENT_Cm = 96;
    Chemistry.ELEMENT_Bk = 97;
    Chemistry.ELEMENT_Cf = 98;
    Chemistry.ELEMENT_Es = 99;
    Chemistry.ELEMENT_Fm = 100;
    Chemistry.ELEMENT_Md = 101;
    Chemistry.ELEMENT_No = 102;
    Chemistry.ELEMENT_Lr = 103;
    Chemistry.ELEMENT_Rf = 104;
    Chemistry.ELEMENT_Db = 105;
    Chemistry.ELEMENT_Sg = 106;
    Chemistry.ELEMENT_Bh = 107;
    Chemistry.ELEMENT_Hs = 108;
    Chemistry.ELEMENT_Mt = 109;
    Chemistry.ELEMENT_Ds = 110;
    Chemistry.ELEMENT_Rg = 111;
    Chemistry.ELEMENT_Cn = 112;
    WebMolKit.Chemistry = Chemistry;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class Atom {
    }
    class Bond {
    }
    class Molecule {
        constructor() {
            this.atoms = [];
            this.bonds = [];
            this.hasZCoord = false;
            this.keepTransient = false;
            this.hasTransient = false;
            this.graph = null;
            this.graphBond = null;
            this.ringID = null;
            this.compID = null;
            this.ring3 = null;
            this.ring4 = null;
            this.ring5 = null;
            this.ring6 = null;
            this.ring7 = null;
        }
        clone() { return Molecule.fromString(this.toString()); }
        static fromString(strData) { return WebMolKit.MoleculeStream.readNative(strData); }
        toString() { return WebMolKit.MoleculeStream.writeNative(this); }
        append(frag) {
            let base = this.atoms.length;
            for (let n = 1; n <= frag.numAtoms; n++) {
                let num = this.addAtom(frag.atomElement(n), frag.atomX(n), frag.atomY(n), frag.atomCharge(n), frag.atomUnpaired(n));
                this.setAtomIsotope(num, frag.atomIsotope(n));
                this.setAtomHExplicit(num, frag.atomHExplicit(n));
                this.setAtomMapNum(num, frag.atomMapNum(n));
                this.setAtomExtra(num, frag.atomExtra(n));
            }
            for (let n = 1; n <= frag.numBonds; n++) {
                let num = this.addBond(frag.bondFrom(n) + base, frag.bondTo(n) + base, frag.bondOrder(n), frag.bondType(n));
                this.setBondExtra(num, frag.bondExtra(n));
            }
            this.trashTransient();
        }
        get numAtoms() { return this.atoms.length; }
        getAtom(idx) {
            if (idx < 1 || idx > this.atoms.length)
                throw `Molecule.getAtom: index ${idx} out of range (#atoms=${this.atoms.length})`;
            return this.atoms[idx - 1];
        }
        atomElement(idx) { return this.getAtom(idx).element; }
        atomX(idx) { return this.getAtom(idx).x; }
        atomY(idx) { return this.getAtom(idx).y; }
        atomCharge(idx) { return this.getAtom(idx).charge; }
        atomUnpaired(idx) { return this.getAtom(idx).unpaired; }
        atomIsotope(idx) { return this.getAtom(idx).isotope; }
        atomHExplicit(idx) { return this.getAtom(idx).hExplicit; }
        atomMapNum(idx) { return this.getAtom(idx).mapNum; }
        atomExtra(idx) { return this.getAtom(idx).extra.slice(0); }
        atomTransient(idx) { return this.getAtom(idx).transient.slice(0); }
        get numBonds() { return this.bonds.length; }
        getBond(idx) {
            if (idx < 1 || idx > this.bonds.length)
                throw `Molecule.getBond: index ${idx} out of range (#bonds=${this.bonds.length})`;
            ;
            return this.bonds[idx - 1];
        }
        bondFrom(idx) { return this.getBond(idx).from; }
        bondTo(idx) { return this.getBond(idx).to; }
        bondOrder(idx) { return this.getBond(idx).order; }
        bondType(idx) { return this.getBond(idx).type; }
        bondExtra(idx) { return this.getBond(idx).extra.slice(0); }
        bondTransient(idx) { return this.getBond(idx).transient.slice(0); }
        addAtom(element, x, y, charge = 0, unpaired = 0) {
            let a = new Atom();
            a.element = element;
            a.x = x;
            a.y = y;
            a.charge = charge;
            a.unpaired = unpaired;
            a.isotope = Molecule.ISOTOPE_NATURAL;
            a.hExplicit = Molecule.HEXPLICIT_UNKNOWN;
            a.mapNum = 0;
            a.extra = [];
            a.transient = [];
            this.atoms.push(a);
            this.trashTransient();
            this.trashGraph();
            return this.atoms.length;
        }
        setAtomElement(idx, element) {
            this.getAtom(idx).element = element;
            this.trashTransient();
        }
        setAtomPos(idx, x, y, z) {
            let a = this.getAtom(idx);
            a.x = x;
            a.y = y;
            a.z = z == null ? 0 : z;
            this.trashTransient();
        }
        setAtomX(idx, x) {
            this.getAtom(idx).x = x;
            this.trashTransient();
        }
        setAtomY(idx, y) {
            this.getAtom(idx).y = y;
            this.trashTransient();
        }
        setAtomCharge(idx, charge) {
            this.getAtom(idx).charge = charge;
            this.trashTransient();
        }
        setAtomUnpaired(idx, unpaired) {
            this.getAtom(idx).unpaired = unpaired;
            this.trashTransient();
        }
        setAtomIsotope(idx, isotope) {
            this.getAtom(idx).isotope = isotope;
            this.trashTransient();
        }
        setAtomHExplicit(idx, hExplicit) {
            this.getAtom(idx).hExplicit = hExplicit;
            this.trashTransient();
        }
        setAtomMapNum(idx, mapNum) {
            this.getAtom(idx).mapNum = mapNum;
            this.trashTransient();
        }
        setAtomExtra(idx, extra) {
            this.getAtom(idx).extra = extra.slice(0);
        }
        setAtomTransient(idx, transi) {
            this.getAtom(idx).transient = transi.slice(0);
            if (transi.length > 0)
                this.hasTransient = true;
        }
        swapAtoms(a1, a2) {
            let a = this.atoms[a1 - 1];
            this.atoms[a1 - 1] = this.atoms[a2 - 1];
            this.atoms[a2 - 1] = a;
            for (let n = 0; n < this.bonds.length; n++) {
                let b = this.bonds[n];
                if (b.from == a2)
                    b.from = a1;
                else if (b.from == a1)
                    b.from = a2;
                if (b.to == a2)
                    b.to = a1;
                else if (b.to == a1)
                    b.to = a2;
            }
            this.trashGraph();
            this.trashTransient();
        }
        addBond(from, to, order, type = Molecule.BONDTYPE_NORMAL) {
            let b = new Bond();
            b.from = from;
            b.to = to;
            b.order = order;
            b.type = type;
            b.extra = [];
            b.transient = [];
            this.bonds.push(b);
            this.trashTransient();
            this.trashGraph();
            return this.bonds.length;
        }
        setBondFrom(idx, bfr) {
            this.getBond(idx).from = bfr;
            this.trashTransient();
            this.trashGraph();
        }
        setBondTo(idx, to) {
            this.getBond(idx).to = to;
            this.trashTransient();
            this.trashGraph();
        }
        setBondFromTo(idx, bfr, bto) {
            this.getBond(idx).from = bfr;
            this.getBond(idx).to = bto;
            this.trashTransient();
            this.trashGraph();
        }
        setBondOrder(idx, order) {
            this.getBond(idx).order = order;
            this.trashTransient();
        }
        setBondType(idx, type) {
            this.getBond(idx).type = type;
            this.trashTransient();
        }
        setBondExtra(idx, extra) {
            this.getBond(idx).extra = extra.slice(0);
        }
        setBondTransient(idx, transi) {
            this.getBond(idx).transient = transi.slice(0);
            if (transi.length > 0)
                this.hasTransient = true;
        }
        deleteAtomAndBonds(idx) {
            for (let n = this.numBonds; n >= 1; n--) {
                if (this.bondFrom(n) == idx || this.bondTo(n) == idx)
                    this.deleteBond(n);
                else {
                    if (this.bondFrom(n) > idx)
                        this.setBondFrom(n, this.bondFrom(n) - 1);
                    if (this.bondTo(n) > idx)
                        this.setBondTo(n, this.bondTo(n) - 1);
                }
            }
            this.atoms.splice(idx - 1, 1);
            this.trashTransient();
            this.trashGraph();
        }
        deleteBond(idx) {
            this.bonds.splice(idx - 1, 1);
            this.trashTransient();
            this.trashGraph();
        }
        atomHydrogens(idx) {
            let hy = this.atomHExplicit(idx);
            if (hy != Molecule.HEXPLICIT_UNKNOWN)
                return hy;
            for (let n = 0; n < Molecule.HYVALENCE_EL.length; n++)
                if (Molecule.HYVALENCE_EL[n] == this.atomElement(idx)) {
                    hy = Molecule.HYVALENCE_VAL[n];
                    break;
                }
            if (hy == Molecule.HEXPLICIT_UNKNOWN)
                return 0;
            let ch = this.atomCharge(idx);
            if (this.atomElement(idx) == 'C')
                ch = -Math.abs(ch);
            hy += ch - this.atomUnpaired(idx);
            let adjBonds = this.atomAdjBonds(idx);
            for (let n = 0; n < adjBonds.length; n++)
                hy -= this.bondOrder(adjBonds[n]);
            return hy < 0 ? 0 : hy;
        }
        findBond(a1, a2) {
            for (let n = 1; n <= this.numBonds; n++) {
                let b1 = this.bondFrom(n), b2 = this.bondTo(n);
                if ((a1 == b1 && a2 == b2) || (a1 == b2 && a2 == b1))
                    return n;
            }
            return 0;
        }
        bondOther(idx, ref) {
            let b1 = this.bondFrom(idx), b2 = this.bondTo(idx);
            if (b1 == ref)
                return b2;
            if (b2 == ref)
                return b1;
            return 0;
        }
        atomExplicit(idx) {
            let a = this.atoms[idx - 1];
            if (a.isotope != Molecule.ISOTOPE_NATURAL)
                return true;
            if (a.element != 'C' || a.charge != 0 || a.unpaired != 0)
                return true;
            if (this.atomAdjCount(idx) == 0)
                return true;
            return false;
        }
        atomRingBlock(idx) {
            if (this.graph == null)
                this.buildGraph();
            if (this.ringID == null)
                this.buildRingID();
            return this.ringID[idx - 1];
        }
        bondInRing(idx) {
            let r1 = this.atomRingBlock(this.bondFrom(idx)), r2 = this.atomRingBlock(this.bondTo(idx));
            return r1 > 0 && r1 == r2;
        }
        atomConnComp(idx) {
            if (this.graph == null)
                this.buildGraph();
            if (this.compID == null)
                this.buildConnComp();
            return this.compID[idx - 1];
        }
        atomAdjCount(idx) {
            this.buildGraph();
            return this.graph[idx - 1].length;
        }
        atomAdjList(idx) {
            this.buildGraph();
            let adj = this.graph[idx - 1].slice(0);
            for (let n = adj.length - 1; n >= 0; n--)
                adj[n]++;
            return adj;
        }
        atomAdjBonds(idx) {
            this.buildGraph();
            return this.graphBond[idx - 1].slice(0);
        }
        findRingsOfSize(size) {
            let rings = null;
            if (size == 3 && this.ring3 != null)
                rings = this.ring3;
            if (size == 4 && this.ring4 != null)
                rings = this.ring4;
            if (size == 5 && this.ring5 != null)
                rings = this.ring5;
            if (size == 6 && this.ring6 != null)
                rings = this.ring6;
            if (size == 7 && this.ring7 != null)
                rings = this.ring7;
            if (rings == null) {
                if (this.graph == null)
                    this.buildGraph();
                if (this.ringID == null)
                    this.buildRingID();
                rings = [];
                for (let n = 1; n <= this.atoms.length; n++) {
                    if (this.ringID[n - 1] > 0) {
                        let path = WebMolKit.Vec.numberArray(0, size);
                        path[0] = n;
                        this.recursiveRingFind(path, 1, size, this.ringID[n - 1], rings);
                    }
                }
                if (size == 3)
                    this.ring3 = rings;
                if (size == 4)
                    this.ring4 = rings;
                if (size == 5)
                    this.ring5 = rings;
                if (size == 6)
                    this.ring6 = rings;
                if (size == 7)
                    this.ring7 = rings;
            }
            let ret = [];
            for (let n = 0; n < rings.length; n++)
                ret.push(rings[n].slice(0));
            return ret;
        }
        boundary() {
            if (this.atoms.length == 0)
                return WebMolKit.Box.zero();
            let x1 = this.atoms[0].x, x2 = x1;
            let y1 = this.atoms[0].y, y2 = y1;
            for (let n = 1; n < this.atoms.length; n++) {
                x1 = Math.min(x1, this.atoms[n].x);
                y1 = Math.min(y1, this.atoms[n].y);
                x2 = Math.max(x2, this.atoms[n].x);
                y2 = Math.max(y2, this.atoms[n].y);
            }
            return new WebMolKit.Box(x1, y1, x2 - x1, y2 - y1);
        }
        atomicNumber(idx) {
            return Molecule.elementAtomicNumber(this.atomElement(idx));
        }
        static elementAtomicNumber(element) {
            return Math.max(0, WebMolKit.Chemistry.ELEMENTS.indexOf(element));
        }
        is3D() { return this.hasZCoord; }
        setIs3D(v) { this.hasZCoord = v; }
        atomZ(idx) { return this.getAtom(idx).z; }
        setAtomZ(idx, z) { this.getAtom(idx).z = z; }
        compareTo(other) {
            if (other == null || other.numAtoms == 0)
                return this.numAtoms == 0 ? 0 : 1;
            if (this.numAtoms < other.numAtoms)
                return -1;
            if (this.numAtoms > other.numAtoms)
                return 1;
            if (this.numBonds < other.numBonds)
                return -1;
            if (this.numBonds > other.numBonds)
                return 1;
            for (let n = 1; n <= this.numAtoms; n++) {
                if (this.atomElement(n) < other.atomElement(n))
                    return -1;
                if (this.atomElement(n) > other.atomElement(n))
                    return 1;
                if (this.atomX(n) < other.atomX(n))
                    return -1;
                if (this.atomX(n) > other.atomX(n))
                    return 1;
                if (this.atomY(n) < other.atomY(n))
                    return -1;
                if (this.atomY(n) > other.atomY(n))
                    return 1;
                if (this.atomCharge(n) < other.atomCharge(n))
                    return -1;
                if (this.atomCharge(n) > other.atomCharge(n))
                    return 1;
                if (this.atomUnpaired(n) < other.atomUnpaired(n))
                    return -1;
                if (this.atomUnpaired(n) > other.atomUnpaired(n))
                    return 1;
                if (this.atomHExplicit(n) < other.atomHExplicit(n))
                    return -1;
                if (this.atomHExplicit(n) > other.atomHExplicit(n))
                    return 1;
                if (this.atomIsotope(n) < other.atomIsotope(n))
                    return -1;
                if (this.atomIsotope(n) > other.atomIsotope(n))
                    return 1;
                if (this.atomMapNum(n) < other.atomMapNum(n))
                    return -1;
                if (this.atomMapNum(n) > other.atomMapNum(n))
                    return 1;
                let tx1 = this.atomExtra(n), tx2 = other.atomExtra(n);
                if (tx1.length < tx2.length)
                    return -1;
                if (tx1.length > tx2.length)
                    return 1;
                for (let i = 0; i < tx1.length; i++)
                    if (tx1[i] < tx2[i])
                        return -1;
                    else if (tx1[i] > tx2[i])
                        return 1;
                tx1 = this.atomTransient(n);
                tx2 = other.atomTransient(n);
                if (tx1.length < tx2.length)
                    return -1;
                if (tx1.length > tx2.length)
                    return 1;
                for (let i = 0; i < tx1.length; i++)
                    if (tx1[i] < tx2[i])
                        return -1;
                    else if (tx1[i] > tx2[i])
                        return 1;
            }
            for (let n = 1; n <= this.numBonds; n++) {
                if (this.bondFrom(n) < other.bondFrom(n))
                    return -1;
                if (this.bondFrom(n) > other.bondFrom(n))
                    return 1;
                if (this.bondTo(n) < other.bondTo(n))
                    return -1;
                if (this.bondTo(n) > other.bondTo(n))
                    return 1;
                if (this.bondOrder(n) < other.bondOrder(n))
                    return -1;
                if (this.bondOrder(n) > other.bondOrder(n))
                    return 1;
                if (this.bondType(n) < other.bondType(n))
                    return -1;
                if (this.bondType(n) > other.bondType(n))
                    return 1;
                let tx1 = this.bondExtra(n), tx2 = other.bondExtra(n);
                if (tx1.length < tx2.length)
                    return -1;
                if (tx1.length > tx2.length)
                    return 1;
                for (let i = 0; i < tx1.length; i++)
                    if (tx1[i] < tx2[i])
                        return -1;
                    else if (tx1[i] > tx2[i])
                        return 1;
                tx1 = this.bondTransient(n);
                tx2 = other.bondTransient(n);
                if (tx1.length < tx2.length)
                    return -1;
                if (tx1.length > tx2.length)
                    return 1;
                for (let i = 0; i < tx1.length; i++)
                    if (tx1[i] < tx2[i])
                        return -1;
                    else if (tx1[i] > tx2[i])
                        return 1;
            }
            return 0;
        }
        trashGraph() {
            this.graph = null;
            this.graphBond = null;
        }
        trashTransient() {
            if (this.keepTransient || !this.hasTransient)
                return;
            for (let a of this.atoms)
                a.transient = [];
            for (let b of this.bonds)
                b.transient = [];
            this.hasTransient = false;
        }
        buildGraph() {
            if (this.graph != null && this.graphBond != null)
                return;
            let graph = [], graphBond = [];
            let na = this.numAtoms, nb = this.numBonds;
            for (let n = 0; n < na; n++) {
                graph.push([]);
                graphBond.push([]);
            }
            for (let n = 1; n <= nb; n++) {
                let b = this.getBond(n);
                graph[b.from - 1].push(b.to - 1);
                graph[b.to - 1].push(b.from - 1);
                graphBond[b.from - 1].push(n);
                graphBond[b.to - 1].push(n);
            }
            this.graph = graph;
            this.graphBond = graphBond;
        }
        buildConnComp() {
            const numAtoms = this.atoms.length;
            this.compID = WebMolKit.Vec.numberArray(0, numAtoms);
            for (let n = 0; n < numAtoms; n++)
                this.compID[n] = 0;
            let comp = 1;
            this.compID[0] = comp;
            while (true) {
                let anything = false;
                for (let n = 0; n < numAtoms; n++)
                    if (this.compID[n] == comp) {
                        for (let i = 0; i < this.graph[n].length; i++) {
                            if (this.compID[this.graph[n][i]] == 0) {
                                this.compID[this.graph[n][i]] = comp;
                                anything = true;
                            }
                        }
                    }
                if (!anything) {
                    for (let n = 0; n < numAtoms; n++) {
                        if (this.compID[n] == 0) {
                            this.compID[n] = ++comp;
                            anything = true;
                            break;
                        }
                    }
                    if (!anything)
                        break;
                }
            }
        }
        buildRingID() {
            const numAtoms = this.atoms.length;
            this.ringID = WebMolKit.Vec.numberArray(0, numAtoms);
            if (numAtoms == 0)
                return;
            let visited = WebMolKit.Vec.booleanArray(false, numAtoms);
            for (let n = 0; n < numAtoms; n++) {
                this.ringID[n] = 0;
                visited[n] = false;
            }
            let path = WebMolKit.Vec.numberArray(0, numAtoms + 1), plen = 0, numVisited = 0;
            while (true) {
                let last, current;
                if (plen == 0) {
                    last = -1;
                    for (current = 0; visited[current]; current++) { }
                }
                else {
                    last = path[plen - 1];
                    current = -1;
                    for (let n = 0; n < this.graph[last].length; n++) {
                        if (!visited[this.graph[last][n]]) {
                            current = this.graph[last][n];
                            break;
                        }
                    }
                }
                if (current >= 0 && plen >= 2) {
                    let back = path[plen - 1];
                    for (let n = 0; n < this.graph[current].length; n++) {
                        let join = this.graph[current][n];
                        if (join != back && visited[join]) {
                            path[plen] = current;
                            for (let i = plen; i == plen || path[i + 1] != join; i--) {
                                let id = this.ringID[path[i]];
                                if (id == 0)
                                    this.ringID[path[i]] = last;
                                else if (id != last) {
                                    for (let j = 0; j < numAtoms; j++)
                                        if (this.ringID[j] == id)
                                            this.ringID[j] = last;
                                }
                            }
                        }
                    }
                }
                if (current >= 0) {
                    visited[current] = true;
                    path[plen++] = current;
                    numVisited++;
                }
                else {
                    plen--;
                }
                if (numVisited == numAtoms)
                    break;
            }
            let nextID = 0;
            for (let i = 0; i < numAtoms; i++) {
                if (this.ringID[i] > 0) {
                    nextID--;
                    for (let j = numAtoms - 1; j >= i; j--)
                        if (this.ringID[j] == this.ringID[i])
                            this.ringID[j] = nextID;
                }
            }
            for (let i = 0; i < numAtoms; i++)
                this.ringID[i] = -this.ringID[i];
        }
        recursiveRingFind(path, psize, capacity, rblk, rings) {
            if (psize < capacity) {
                let last = path[psize - 1];
                for (let n = 0; n < this.graph[last - 1].length; n++) {
                    let adj = this.graph[last - 1][n] + 1;
                    if (this.ringID[adj - 1] != rblk)
                        continue;
                    let fnd = false;
                    for (let i = 0; i < psize; i++) {
                        if (path[i] == adj) {
                            fnd = true;
                            break;
                        }
                    }
                    if (!fnd) {
                        let newPath = path.slice(0);
                        newPath[psize] = adj;
                        this.recursiveRingFind(newPath, psize + 1, capacity, rblk, rings);
                    }
                }
                return;
            }
            let last = path[psize - 1];
            let fnd = false;
            for (let n = 0; n < this.graph[last - 1].length; n++) {
                if (this.graph[last - 1][n] + 1 == path[0]) {
                    fnd = true;
                    break;
                }
            }
            if (!fnd)
                return;
            for (let n = 0; n < path.length; n++) {
                let count = 0, p = path[n] - 1;
                for (let i = 0; i < this.graph[p].length; i++)
                    if (path.indexOf(this.graph[p][i] + 1) >= 0)
                        count++;
                if (count != 2)
                    return;
            }
            let first = 0;
            for (let n = 1; n < psize; n++)
                if (path[n] < path[first])
                    first = n;
            let fm = (first - 1 + psize) % psize, fp = (first + 1) % psize;
            let flip = path[fm] < path[fp];
            if (first != 0 || flip) {
                let newPath = WebMolKit.Vec.numberArray(0, psize);
                for (let n = 0; n < psize; n++)
                    newPath[n] = path[(first + (flip ? psize - n : n)) % psize];
                path = newPath;
            }
            for (let n = 0; n < rings.length; n++) {
                let look = rings[n];
                let same = true;
                for (let i = 0; i < psize; i++) {
                    if (look[i] != path[i]) {
                        same = false;
                        break;
                    }
                }
                if (same)
                    return;
            }
            rings.push(path);
        }
    }
    Molecule.IDEALBOND = 1.5;
    Molecule.HEXPLICIT_UNKNOWN = -1;
    Molecule.ISOTOPE_NATURAL = 0;
    Molecule.BONDTYPE_NORMAL = 0;
    Molecule.BONDTYPE_INCLINED = 1;
    Molecule.BONDTYPE_DECLINED = 2;
    Molecule.BONDTYPE_UNKNOWN = 3;
    Molecule.HYVALENCE_EL = ['C', 'N', 'O', 'S', 'P'];
    Molecule.HYVALENCE_VAL = [4, 3, 2, 2, 3];
    WebMolKit.Molecule = Molecule;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let Geometry;
    (function (Geometry) {
        Geometry[Geometry["Linear"] = 0] = "Linear";
        Geometry[Geometry["Bent"] = 1] = "Bent";
        Geometry[Geometry["Trigonal"] = 2] = "Trigonal";
        Geometry[Geometry["Tetra1"] = 3] = "Tetra1";
        Geometry[Geometry["Tetra2"] = 4] = "Tetra2";
        Geometry[Geometry["SqPlan"] = 5] = "SqPlan";
        Geometry[Geometry["BasePyram"] = 6] = "BasePyram";
        Geometry[Geometry["TrigBip"] = 7] = "TrigBip";
        Geometry[Geometry["Octa1"] = 8] = "Octa1";
        Geometry[Geometry["Octa2"] = 9] = "Octa2";
    })(Geometry = WebMolKit.Geometry || (WebMolKit.Geometry = {}));
    class SketchUtil {
        static placeNewAtom(mol, el) {
            let box = mol.boundary();
            let x = box.maxX() + WebMolKit.Molecule.IDEALBOND, y = box.maxY();
            return mol.addAtom(el, x, y);
        }
        static placeNewFragment(mol, frag) {
            if (frag.numAtoms == 0)
                return;
            let dirX = [1, 0, -1, 1, -1, 1, 0, -1], dirY = [1, 1, 1, 0, 0, -1, -1, -1];
            let dx = WebMolKit.Vec.numberArray(0, 8), dy = WebMolKit.Vec.numberArray(0, 8), score = WebMolKit.Vec.numberArray(0, 8);
            let mbox = mol.boundary(), fbox = frag.boundary();
            for (let n = 0; n < 8; n++) {
                let vx = dirX[n], vy = dirY[n];
                if (n == 0 || n == 3 || n == 5)
                    dx[n] = mbox.minX() - fbox.maxX();
                else if (n == 2 || n == 4 || n == 7)
                    dx[n] = mbox.maxX() - fbox.minX();
                else
                    dx[n] = 0.5 * (mbox.minX() + mbox.maxX() - fbox.minX() - fbox.maxX());
                if (n == 5 || n == 6 || n == 7)
                    dy[n] = mbox.minY() - fbox.maxY();
                else if (n == 0 || n == 1 || n == 2)
                    dy[n] = mbox.maxY() - fbox.minY();
                else
                    dy[n] = 0.5 * (mbox.minY() + mbox.maxY() - fbox.minY() - fbox.maxY());
                dx[n] -= vx;
                dy[n] -= vy;
                score[n] = SketchUtil.fragPosScore(mol, frag, dx[n], dy[n]);
                vx *= 0.25;
                vy *= 0.25;
                for (let iter = 100; iter > 0; iter--) {
                    let iscore = SketchUtil.fragPosScore(mol, frag, dx[n] + vx, dy[n] + vy);
                    if (iscore <= score[n])
                        break;
                    score[n] = iscore;
                    dx[n] += vx;
                    dy[n] += vy;
                }
                for (let iter = 100; iter > 0; iter--)
                    for (let d = 0; d < 8; d++) {
                        vx = dirX[d] * 0.1;
                        vy = dirY[d] * 0.1;
                        let iscore = SketchUtil.fragPosScore(mol, frag, dx[n] + vx, dy[n] + vy);
                        if (iscore <= score[n])
                            break;
                        score[n] = iscore;
                        dx[n] += vx;
                        dy[n] += vy;
                    }
            }
            let best = 0;
            for (let n = 1; n < 8; n++)
                if (score[n] > score[best])
                    best = n;
            frag = frag.clone();
            for (let n = 1; n <= frag.numAtoms; n++)
                frag.setAtomPos(n, frag.atomX(n) + dx[best], frag.atomY(n) + dy[best]);
            mol.append(frag);
        }
        static fragPosScore(mol, frag, dx, dy) {
            let score = 0;
            for (let i = 1; i <= mol.numAtoms; i++)
                for (let j = 1; j <= frag.numAtoms; j++) {
                    let ox = frag.atomX(j) + dx - mol.atomX(i), oy = frag.atomY(j) + dy - mol.atomY(i);
                    let dist2 = ox * ox + oy * oy;
                    if (dist2 < 1)
                        return 0;
                    score += 1 / dist2;
                }
            let mbox = mol.boundary(), fbox = frag.boundary();
            let minX = Math.min(fbox.minX() + dx, mbox.minX()), maxX = Math.max(fbox.maxX() + dx, mbox.maxX());
            let minY = Math.min(fbox.minY() + dy, mbox.minY()), maxY = Math.max(fbox.maxY() + dy, mbox.maxY());
            let rangeX = Math.max(1, maxX - minX), rangeY = Math.max(1, maxY - minY);
            let ratio = Math.max(rangeX / rangeY, rangeY / rangeX);
            return score / ratio;
        }
        static mergeOverlappingAtoms(mol) {
            return SketchUtil.mergeFragmentsDiv(mol, 0);
        }
        static mergeFragmentsDiv(mol, div) {
            const na = mol.numAtoms;
            let omask = WebMolKit.CoordUtil.overlappingAtomMask(mol);
            let chopmask = WebMolKit.Vec.booleanArray(false, na);
            let mx = WebMolKit.MolUtil.arrayAtomX(mol), my = WebMolKit.MolUtil.arrayAtomY(mol);
            let remap = [];
            for (let n = 0; n < na; n++)
                remap.push(n + 1);
            let div1 = div, div2 = div + 1;
            if (div == 0)
                div1 = na;
            for (let i = 1; i <= div1; i++)
                if (omask[i - 1] && !chopmask[i - 1]) {
                    if (div == 0)
                        div2 = i + 1;
                    for (let j = div2; j <= na; j++)
                        if (omask[j - 1] && !chopmask[j - 1]) {
                            if (WebMolKit.norm2_xy(mx[i - 1] - mx[j - 1], my[i - 1] - my[j - 1]) > WebMolKit.CoordUtil.OVERLAP_THRESHOLD_SQ)
                                continue;
                            let oldN = j, newN = i;
                            let exotic = [0, 0];
                            for (let k = 0; k < 2; k++) {
                                let a = k == 0 ? i : j;
                                exotic[k] = (mol.atomElement(a) == 'C' ? 0 : 1)
                                    + (mol.atomElement(a) == 'X' ? -100 : 0)
                                    + (mol.atomCharge(a) != 0 ? 1 : 0)
                                    + (mol.atomUnpaired(a) != 0 ? 1 : 0)
                                    + (mol.atomIsotope(a) != WebMolKit.Molecule.ISOTOPE_NATURAL ? 1 : 0)
                                    + (mol.atomHExplicit(a) != WebMolKit.Molecule.HEXPLICIT_UNKNOWN ? 1 : 0)
                                    + (WebMolKit.MolUtil.hasAbbrev(mol, a) ? 1000 : 0);
                            }
                            if (exotic[1] > exotic[0]) {
                                oldN = i;
                                newN = j;
                            }
                            for (let n = 1; n <= mol.numBonds; n++) {
                                if (mol.bondFrom(n) == oldN)
                                    mol.setBondFrom(n, newN);
                                if (mol.bondTo(n) == oldN)
                                    mol.setBondTo(n, newN);
                            }
                            chopmask[oldN - 1] = true;
                            remap[oldN - 1] = newN;
                        }
                }
            for (let n = na; n >= 1; n--)
                if (chopmask[n - 1]) {
                    if (n <= div)
                        div--;
                    mol.deleteAtomAndBonds(n);
                    for (let i = 0; i < na; i++)
                        if (remap[i] > n)
                            remap[i]--;
                }
            for (let n = mol.numAtoms; n > div; n--)
                if (mol.atomElement(n) == 'X') {
                    mol.deleteAtomAndBonds(n);
                    for (let i = 0; i < na; i++)
                        if (remap[i] > n)
                            remap[i]--;
                }
            WebMolKit.MolUtil.removeDuplicateBonds(mol);
            return remap;
        }
        static mergeFragmentsMask(mol, mask) {
            let chopmask = WebMolKit.Vec.booleanArray(false, mol.numAtoms);
            let na = mol.numAtoms;
            let mx = WebMolKit.MolUtil.arrayAtomX(mol), my = WebMolKit.MolUtil.arrayAtomY(mol);
            for (let i = 1; i <= na; i++)
                if (mask[i - 1])
                    for (let j = 1; j <= na; j++)
                        if (!mask[j - 1] && !chopmask[j - 1])
                            if (WebMolKit.norm2_xy(mx[i - 1] - mx[j - 1], my[i - 1] - my[j - 1]) < WebMolKit.CoordUtil.OVERLAP_THRESHOLD_SQ) {
                                let oldN = j, newN = i;
                                if (mol.atomElement(i) == 'C' && mol.atomElement(j) != 'C' && mol.atomElement(j) != 'X') {
                                    oldN = i;
                                    newN = j;
                                }
                                mol.setAtomExtra(newN, WebMolKit.Vec.concat(mol.atomExtra(oldN), mol.atomExtra(newN)));
                                for (let n = 1; n <= mol.numBonds; n++) {
                                    if (mol.bondFrom(n) == oldN)
                                        mol.setBondFrom(n, newN);
                                    if (mol.bondTo(n) == oldN)
                                        mol.setBondTo(n, newN);
                                }
                                chopmask[oldN - 1] = true;
                            }
            for (let n = chopmask.length; n >= 1; n--)
                if (chopmask[n - 1])
                    mol.deleteAtomAndBonds(n);
            WebMolKit.MolUtil.removeDuplicateBonds(mol);
        }
        static matchAngleGeometry(geom, theta) {
            if (theta.length <= 1)
                return true;
            let match = SketchUtil.GEOM_ANGLES[geom], mtheta = WebMolKit.Vec.numberArray(0, theta.length);
            let hit = WebMolKit.Vec.booleanArray(false, match.length);
            for (let n = 0; n < theta.length; n++)
                for (let s = 1; s >= -1; s -= 2) {
                    for (let i = 0; i < theta.length; i++)
                        mtheta[i] = (theta[i] - theta[0]) * s;
                    WebMolKit.Vec.setTo(hit, false);
                    let gotall = true;
                    for (let i = 0; i < mtheta.length; i++) {
                        let got = false;
                        for (let j = 0; j < match.length; j++)
                            if (!hit[j] && Math.abs(WebMolKit.angleDiff(mtheta[i], match[j])) < 3 * WebMolKit.DEGRAD) {
                                hit[j] = true;
                                got = true;
                                break;
                            }
                        if (!got) {
                            gotall = false;
                            break;
                        }
                    }
                    if (gotall)
                        return true;
                }
            return false;
        }
        static primeDirections(mol, atom) {
            let angles = SketchUtil.calculateNewBondAngles(mol, atom, 1);
            let exits = SketchUtil.exitVectors(mol, atom);
            return WebMolKit.GeomUtil.uniqueAngles(angles.concat(exits), 2 * WebMolKit.DEGRAD);
        }
        static exitVectors(mol, atom) {
            let adj = mol.atomAdjList(atom), sz = adj.length;
            if (sz == 0)
                return [0, 90 * WebMolKit.DEGRAD, 180 * WebMolKit.DEGRAD, -90 * WebMolKit.DEGRAD];
            if (sz == 1)
                return [];
            let ret = [];
            let ang = WebMolKit.GeomUtil.sortAngles(WebMolKit.CoordUtil.atomBondAngles(mol, atom, adj));
            for (let n = 0; n < sz; n++) {
                let nn = n < sz - 1 ? n + 1 : 0;
                ret.push(WebMolKit.angleNorm(ang[n] + 0.5 * WebMolKit.angleDiffPos(ang[nn], ang[n])));
            }
            return ret;
        }
        static calculateNewBondAngles(mol, atom, order) {
            let adj = mol.atomAdjList(atom);
            const sz = adj.length;
            if (sz == 0) {
                let atno = mol.atomicNumber(atom), atblk = WebMolKit.Chemistry.ELEMENT_BLOCKS[atno];
                if (atblk <= 2)
                    return [0, 90 * WebMolKit.DEGRAD, 180 * WebMolKit.DEGRAD, -90 * WebMolKit.DEGRAD];
                else
                    return [90 * WebMolKit.DEGRAD, -90 * WebMolKit.DEGRAD, 30 * WebMolKit.DEGRAD, 150 * WebMolKit.DEGRAD, 210 * WebMolKit.DEGRAD, -30 * WebMolKit.DEGRAD, 180 * WebMolKit.DEGRAD, 0 * WebMolKit.DEGRAD];
            }
            let geom = SketchUtil.guessAtomGeometry(mol, atom, order);
            let ang = WebMolKit.CoordUtil.atomBondAngles(mol, atom, adj);
            for (let n = 0; n < geom.length; n++) {
                let ret = SketchUtil.mapAngleSubstituent(geom[n], ang);
                if (ret != null)
                    return ret;
            }
            return [];
        }
        static guessAtomGeometry(mol, atom, order) {
            let adj = mol.atomAdjList(atom);
            let sz = adj.length, atno = mol.atomicNumber(atom);
            let atblk = WebMolKit.Chemistry.ELEMENT_BLOCKS[atno], elrow = WebMolKit.Chemistry.ELEMENT_ROWS[atno];
            let el = mol.atomElement(atom);
            let adjBO = [], adjAN = [], pri = [];
            let allSingle = true;
            for (let n = 0; n < sz; n++) {
                adjBO.push(mol.bondOrder(mol.findBond(atom, adj[n])));
                adjAN.push(mol.atomicNumber(adj[n]));
                pri.push(adjBO[n] * 200 + adjAN[n]);
                if (adjBO[n] != 1)
                    allSingle = true;
            }
            for (let p = 0; p < sz - 1;) {
                if (pri[p] > pri[p + 1]) {
                    WebMolKit.Vec.swap(adj, p, p + 1);
                    WebMolKit.Vec.swap(adjBO, p, p + 1);
                    WebMolKit.Vec.swap(adjAN, p, p + 1);
                    WebMolKit.Vec.swap(pri, p, p + 1);
                    if (p > 0)
                        p--;
                }
                else
                    p++;
            }
            let ang = WebMolKit.CoordUtil.atomBondAngles(mol, atom, adj);
            if (sz == 1) {
                if (el == 'C' || el == 'N') {
                    if (adjBO[0] == 2 && order == 2)
                        return [Geometry.Linear];
                    if ((adjBO[0] == 3 && order == 1) || (adjBO[0] == 1 && order == 3))
                        return [Geometry.Linear];
                }
                if (atblk > 2)
                    return [Geometry.Octa1, Geometry.Octa2];
                if (order != 0 && (el == 'C' || el == 'N' || el == 'O'))
                    return [Geometry.Trigonal];
                return [Geometry.Trigonal, Geometry.Linear];
            }
            if (sz == 2 && Math.abs(WebMolKit.angleDiff(ang[0], ang[1])) >= 175 * WebMolKit.DEGRAD) {
                if (atblk <= 2)
                    return [Geometry.SqPlan];
                else
                    return [Geometry.Octa1, Geometry.Octa2];
            }
            let geom = [];
            if (atblk == 0)
                geom = [Geometry.Trigonal, Geometry.SqPlan];
            else if (atblk == 1)
                geom = [Geometry.Trigonal, Geometry.SqPlan, Geometry.Octa1, Geometry.Octa2];
            else if (atblk == 2) {
                geom.push(Geometry.Trigonal);
                if (el == 'C' && allSingle) {
                    geom.push(Geometry.Tetra1);
                    geom.push(Geometry.Tetra2);
                    geom.push(Geometry.SqPlan);
                }
                else if (el == 'C' && !allSingle) {
                }
                else if (elrow <= 3) {
                    geom.push(Geometry.Tetra1);
                    geom.push(Geometry.Tetra2);
                    geom.push(Geometry.SqPlan);
                }
                else {
                    geom.push(Geometry.Tetra1);
                    geom.push(Geometry.Tetra2);
                    geom.push(Geometry.SqPlan);
                    geom.push(Geometry.Octa1);
                    geom.push(Geometry.Octa2);
                }
            }
            else {
                geom.push(Geometry.Octa1);
                geom.push(Geometry.Octa2);
            }
            for (let n = geom.length - 1; n >= 0; n--) {
                if (!SketchUtil.matchAngleGeometry(geom[n], ang))
                    geom.splice(n, 1);
            }
            return geom;
        }
        static mapAngleSubstituent(geom, ang) {
            let gtheta = SketchUtil.GEOM_ANGLES[geom];
            const asz = ang.length, gsz = gtheta.length;
            if (asz >= gsz)
                return null;
            if (asz == 0)
                return gtheta.slice(0);
            let vac = [];
            for (let n = 0; n < asz; n++)
                for (let k = 0; k < gsz; k++)
                    for (let s = 1; s >= -1; s -= 2) {
                        let gang = [];
                        for (let i = 0; i < gsz; i++)
                            gang.push(WebMolKit.angleNorm(ang[n] + s * (gtheta[i] - gtheta[k])));
                        let mask = WebMolKit.Vec.booleanArray(false, gsz);
                        let mcount = 0;
                        for (let i = 0; i < gsz; i++)
                            if (!mask[i])
                                for (let j = 0; j < asz; j++)
                                    if (Math.abs(WebMolKit.angleDiff(gang[i], ang[j])) < 3 * WebMolKit.DEGRAD) {
                                        mask[i] = true;
                                        mcount++;
                                        break;
                                    }
                        if (mcount != asz)
                            continue;
                        for (let i = 0; i < gsz; i++)
                            if (!mask[i])
                                vac.push(gang[i]);
                    }
            if (vac.length == 0)
                return null;
            vac = WebMolKit.GeomUtil.sortAngles(vac);
            for (let n = 0; n < vac.length - 1; n++) {
                let th1 = vac[n], th2 = vac[n + 1], dth = WebMolKit.angleDiff(th2, th1);
                if (Math.abs(dth) < 5 * WebMolKit.DEGRAD) {
                    vac[n] = th1 + 0.5 * dth;
                    vac.splice(n + 1, 1);
                    n--;
                }
            }
            return vac;
        }
        static refitAtomGeometry(mol, atom, geom) {
            let gtheta = SketchUtil.GEOM_ANGLES[geom];
            let gsz = gtheta.length;
            let adj = mol.atomAdjList(atom);
            let asz = adj.length;
            if (asz <= 1 || asz > gsz)
                return null;
            let ang = WebMolKit.CoordUtil.atomBondAngles(mol, atom, adj);
            let inRing = WebMolKit.Vec.booleanArray(false, asz);
            let allInRing = true;
            for (let n = 0; n < asz; n++) {
                inRing[n] = mol.bondInRing(mol.findBond(atom, adj[n]));
                if (!inRing[n])
                    allInRing = false;
            }
            if (allInRing)
                return null;
            let bestAng = null;
            let bestScore = 0;
            let ww = WebMolKit.MolUtil.calculateWalkWeight(mol, atom);
            for (let i = 0; i < gsz; i++)
                for (let j = 0; j < asz; j++)
                    for (let s = 1; s >= -1; s -= 2) {
                        let newAng = WebMolKit.Vec.numberArray(0, asz);
                        let mask = WebMolKit.Vec.booleanArray(false, gsz);
                        for (let n1 = 0; n1 < asz; n1++) {
                            let best = -1;
                            let bdiff = 0;
                            for (let n2 = 0; n2 < gsz; n2++)
                                if (!mask[n2]) {
                                    let th = WebMolKit.angleNorm(gtheta[n2] * s - gtheta[i] + ang[j]);
                                    let diff = Math.abs(WebMolKit.angleDiff(th, ang[n1]));
                                    if (best < 0 || diff < bdiff) {
                                        best = n2;
                                        bdiff = diff;
                                        newAng[n1] = th;
                                    }
                                }
                            mask[best] = true;
                        }
                        let ringClash = false;
                        for (let n = 0; n < asz; n++)
                            if (inRing[n] && Math.abs(WebMolKit.angleDiff(newAng[n], ang[n])) > 2 * WebMolKit.DEGRAD) {
                                ringClash = true;
                                break;
                            }
                        if (ringClash)
                            continue;
                        let score = 0;
                        for (let n = 0; n < asz; n++)
                            score += ww[adj[n] - 1] * Math.abs(WebMolKit.angleDiff(newAng[n], ang[n]));
                        if (bestAng == null || score < bestScore) {
                            bestAng = newAng;
                            bestScore = score;
                        }
                    }
            if (bestAng == null)
                return null;
            let same = true;
            for (let n = 0; n < asz; n++)
                if (Math.abs(WebMolKit.angleDiff(bestAng[n], ang[n])) > 2 * WebMolKit.DEGRAD) {
                    same = false;
                    break;
                }
            if (same)
                return null;
            mol = mol.clone();
            for (let n = 0; n < asz; n++)
                if (!inRing[n])
                    WebMolKit.CoordUtil.rotateBond(mol, atom, adj[n], bestAng[n] - ang[n]);
            return mol;
        }
        static switchAtomGeometry(mol, src, dst, geoms) {
            let bestAtom = 0;
            let bestAng = 0, bestX = 0, bestY = 0;
            let adj = mol.atomAdjList(src);
            let ang = WebMolKit.CoordUtil.atomBondAngles(mol, src, adj), theta = WebMolKit.Vec.numberArray(0, ang.length - 1);
            let cx = mol.atomX(src), cy = mol.atomY(src);
            for (let i = 0; i < dst.length; i++) {
                let a = adj.indexOf(dst[i]);
                let curth = ang[a];
                for (let n = 0, p = 0; n < adj.length; n++)
                    if (n != a)
                        theta[p++] = ang[n];
                let r = WebMolKit.norm_xy(mol.atomX(dst[i]) - cx, mol.atomY(dst[i]) - cy);
                for (let j = 0; j < geoms.length; j++) {
                    if (adj.length >= SketchUtil.GEOM_ANGLES[geoms[j]].length)
                        continue;
                    let newAng = SketchUtil.mapAngleSubstituent(geoms[j], theta);
                    if (newAng != null)
                        for (let n = 0; n < newAng.length; n++) {
                            let dth = WebMolKit.angleDiff(newAng[n], curth);
                            if (Math.abs(dth) < 3 * WebMolKit.DEGRAD)
                                continue;
                            if (dth < 0)
                                dth += WebMolKit.TWOPI;
                            if (bestAtom == 0 || dth < bestAng - 2 * WebMolKit.DEGRAD || (dth < bestAng + 2 * WebMolKit.DEGRAD && dst[i] < bestAtom)) {
                                let x = cx + r * Math.cos(newAng[n]);
                                let y = cy + r * Math.sin(newAng[n]);
                                if (WebMolKit.CoordUtil.atomAtPoint(mol, x, y) != 0)
                                    continue;
                                bestAtom = dst[i];
                                bestAng = dth;
                                bestX = x;
                                bestY = y;
                            }
                        }
                    break;
                }
            }
            if (bestAtom == 0)
                return null;
            mol = mol.clone();
            mol.setAtomPos(bestAtom, bestX, bestY);
            return mol;
        }
        static pickAtomsToConnect(mol, aidx) {
            if (aidx.length < 2)
                return null;
            if (aidx.length == 2) {
                if (mol.findBond(aidx[0], aidx[1]) > 0)
                    return null;
                return aidx;
            }
            const AUTO_DSQ = WebMolKit.sqr(WebMolKit.Molecule.IDEALBOND + 0.1);
            let bestDSQ = Number.MAX_VALUE;
            let bestA1 = 0, bestA2 = 0;
            let conn = [];
            for (let i = 0; i < aidx.length - 1; i++)
                for (let j = i + 1; j < aidx.length; j++) {
                    if (mol.findBond(aidx[i], aidx[j]) > 0)
                        continue;
                    let dsq = WebMolKit.norm2_xy(mol.atomX(aidx[i]) - mol.atomX(aidx[j]), mol.atomY(aidx[i]) - mol.atomY(aidx[j]));
                    if (dsq < AUTO_DSQ) {
                        conn.push(aidx[i]);
                        conn.push(aidx[j]);
                    }
                    else if (dsq < bestDSQ) {
                        bestDSQ = dsq;
                        bestA1 = aidx[i];
                        bestA2 = aidx[j];
                    }
                }
            if (conn.length == 0 && bestA1 != 0) {
                conn.push(bestA1);
                conn.push(bestA2);
            }
            return conn.length == 0 ? null : conn;
        }
        static pickNewAtomDirection(mol, atom, theta) {
            if (theta.length == 1)
                return theta[0];
            let bestTheta = theta[0], bestScore = Number.MAX_VALUE;
            for (let n = 0; n < theta.length; n++) {
                let px = mol.atomX(atom) + WebMolKit.Molecule.IDEALBOND * Math.cos(theta[n]);
                let py = mol.atomY(atom) + WebMolKit.Molecule.IDEALBOND * Math.sin(theta[n]);
                let score = WebMolKit.CoordUtil.congestionPoint(mol, px, py);
                if (score > bestScore)
                    continue;
                if (WebMolKit.CoordUtil.overlapsAtom(mol, px, py, 0.2))
                    score += 1E5;
                if (score < bestScore) {
                    bestTheta = theta[n];
                    bestScore = score;
                }
            }
            return bestTheta;
        }
        static joinOverlappingAtoms(mol, mask) {
            mol = mol.clone();
            mask = mask.slice(0);
            const na = mol.numAtoms;
            let mx = WebMolKit.MolUtil.arrayAtomX(mol), my = WebMolKit.MolUtil.arrayAtomY(mol);
            let groups = [];
            let groupX = [], groupY = [];
            for (let i = 0; i < na - 1; i++)
                if (mask[i]) {
                    let g = [i + 1];
                    let x = mx[i], y = my[i];
                    for (let j = i + 1; j < na; j++)
                        if (mask[j]) {
                            if (WebMolKit.norm2_xy(mx[j] - mx[i], my[j] - my[i]) > WebMolKit.CoordUtil.OVERLAP_THRESHOLD_SQ)
                                continue;
                            g.push(j + 1);
                            x += mx[j];
                            y += my[j];
                            let adjb = mol.atomAdjBonds(j + 1);
                            for (let n = 0; n < adjb.length; n++) {
                                if (mol.bondFrom(adjb[n]) == j + 1)
                                    mol.setBondFrom(adjb[n], i + 1);
                                else if (mol.bondTo(adjb[n]) == j + 1)
                                    mol.setBondTo(adjb[n], i + 1);
                            }
                        }
                    if (g.length == 1)
                        continue;
                    groups.push(g);
                    groupX.push(x / g.length);
                    groupY.push(y / g.length);
                }
            if (groups.length == 0)
                return null;
            let keepmask = WebMolKit.Vec.booleanArray(true, na);
            for (let n = 0; n < groups.length; n++) {
                let g = groups[n];
                mol.setAtomPos(g[0], groupX[n], groupY[n]);
                for (let i = 1; i < g.length; i++)
                    keepmask[g[i] - 1] = false;
            }
            mol = WebMolKit.MolUtil.subgraphMask(mol, keepmask);
            WebMolKit.MolUtil.removeDuplicateBonds(mol);
            return mol;
        }
        static moveToEdge(mol, mask, dx, dy) {
            let gotS = false, gotN = false;
            let sx1 = 0, sy1 = 0, sx2 = 0, sy2 = 0;
            let nx1 = 0, ny1 = 0, nx2 = 0, ny2 = 0;
            for (let n = 1; n <= mol.numAtoms; n++) {
                let x = mol.atomX(n), y = mol.atomY(n);
                if (mask[n - 1]) {
                    if (!gotS || x < sx1)
                        sx1 = x;
                    if (!gotS || y < sy1)
                        sy1 = y;
                    if (!gotS || x > sx2)
                        sx2 = x;
                    if (!gotS || y > sy2)
                        sy2 = y;
                    gotS = true;
                }
                else {
                    if (!gotN || x < nx1)
                        nx1 = x;
                    if (!gotN || y < ny1)
                        ny1 = y;
                    if (!gotN || x > nx2)
                        nx2 = x;
                    if (!gotN || y > ny2)
                        ny2 = y;
                    gotN = true;
                }
            }
            const SEPARATE = 1.0, SEPTEST = 0.9;
            if ((dx < 0 && dy == 0 && sx2 <= nx1 - SEPTEST) ||
                (dx > 0 && dy == 0 && sx1 >= nx2 + SEPTEST) ||
                (dx == 0 && dy < 0 && sy2 <= ny1 - SEPTEST) ||
                (dx == 0 && dy > 0 && sy1 >= ny2 + SEPTEST)) {
                return null;
            }
            mol = mol.clone();
            let ox = 0, oy = 0;
            if (dx < 0)
                ox = nx1 - sx2 - SEPARATE;
            if (dx > 0)
                ox = nx2 - sx1 + SEPARATE;
            if (dy < 0)
                oy = ny1 - sy2 - SEPARATE;
            if (dy > 0)
                oy = ny2 - sy1 + SEPARATE;
            for (let n = 1; n <= mol.numAtoms; n++)
                if (mask[n - 1])
                    mol.setAtomPos(n, mol.atomX(n) + ox, mol.atomY(n) + oy);
            return mol;
        }
        static placeAdditionalHydrogens(mol, atom, numH) {
            let base = mol.numAtoms;
            const x0 = mol.atomX(atom), y0 = mol.atomY(atom);
            let adj = mol.atomAdjList(atom);
            if (adj.length == 2 && numH == 2) {
                const th1 = Math.atan2(mol.atomY(adj[0]) - y0, mol.atomX(adj[0]) - x0);
                const th2 = Math.atan2(mol.atomY(adj[1]) - y0, mol.atomX(adj[1]) - x0);
                if (Math.abs(WebMolKit.angleDiff(th1, th2)) < 170 * WebMolKit.DEGRAD) {
                    let theta = 0.5 * (th1 + th2) + Math.PI;
                    let th3 = theta - 30 * WebMolKit.DEGRAD, th4 = theta + 30 * WebMolKit.DEGRAD;
                    mol.addAtom("H", x0 + WebMolKit.Molecule.IDEALBOND * Math.cos(th3), y0 + WebMolKit.Molecule.IDEALBOND * Math.sin(th3));
                    mol.addAtom("H", x0 + WebMolKit.Molecule.IDEALBOND * Math.cos(th4), y0 + WebMolKit.Molecule.IDEALBOND * Math.sin(th4));
                    mol.addBond(atom, base + 1, 1);
                    mol.addBond(atom, base + 2, 1);
                    return;
                }
            }
            if (adj.length == 1 && numH == 3) {
                let th1 = Math.atan2(mol.atomY(adj[0]) - y0, mol.atomX(adj[0]) - x0);
                let th2 = th1 + 90 * WebMolKit.DEGRAD, th3 = th1 + 180 * WebMolKit.DEGRAD, th4 = th1 + 270 * WebMolKit.DEGRAD;
                mol.addAtom("H", x0 + WebMolKit.Molecule.IDEALBOND * Math.cos(th2), y0 + WebMolKit.Molecule.IDEALBOND * Math.sin(th2));
                mol.addAtom("H", x0 + WebMolKit.Molecule.IDEALBOND * Math.cos(th3), y0 + WebMolKit.Molecule.IDEALBOND * Math.sin(th3));
                mol.addAtom("H", x0 + WebMolKit.Molecule.IDEALBOND * Math.cos(th4), y0 + WebMolKit.Molecule.IDEALBOND * Math.sin(th4));
                mol.addBond(atom, base + 1, 1);
                mol.addBond(atom, base + 2, 1);
                mol.addBond(atom, base + 3, 1);
                return;
            }
            let theta = SketchUtil.pickNewAtomDirection(mol, atom, SketchUtil.primeDirections(mol, atom));
            mol.addAtom("H", x0 + WebMolKit.Molecule.IDEALBOND * Math.cos(theta), y0 + WebMolKit.Molecule.IDEALBOND * Math.sin(theta));
            mol.addBond(atom, base + 1, 1);
            if (numH > 1)
                SketchUtil.placeAdditionalHydrogens(mol, atom, numH - 1);
        }
        static allViableDirections(mol, atom, order) {
            if (mol.atomAdjCount(atom) == 0) {
                let angles = [];
                for (let n = 0; n < 12; n++)
                    angles.push(30 * WebMolKit.DEGRAD);
                return angles;
            }
            let adj = mol.atomAdjList(atom);
            let angles = SketchUtil.exitVectors(mol, atom);
            let geom = SketchUtil.guessAtomGeometry(mol, atom, order);
            if (adj.length == 1 && geom.indexOf(Geometry.Linear) < 0)
                geom.push(Geometry.Linear);
            let bndang = WebMolKit.CoordUtil.atomBondAngles(mol, atom, adj);
            for (let g of geom) {
                let map = SketchUtil.mapAngleSubstituent(g, bndang);
                if (map != null)
                    for (let th of map)
                        angles.push(th);
            }
            return WebMolKit.GeomUtil.uniqueAngles(angles, 2 * WebMolKit.DEGRAD);
        }
        static proposeNewRing(mol, rsz, x, y, dx, dy, snap) {
            let theta = Math.atan2(dy, dx);
            if (snap) {
                const chunk = 30 * WebMolKit.DEGRAD;
                theta = Math.round(theta / chunk) * chunk;
            }
            return SketchUtil.positionSimpleRing(mol, rsz, x, y, theta);
        }
        static proposeAtomRing(mol, rsz, atom, dx, dy) {
            let thsnap = [];
            let cx = mol.atomX(atom), cy = mol.atomY(atom);
            if (mol.atomAdjCount(atom) == 0) {
                for (let n = 0; n < 12; n++)
                    thsnap.push(WebMolKit.TWOPI * n / 12);
            }
            else if (mol.atomAdjCount(atom) == 1) {
                let nbr = mol.atomAdjList(atom)[0];
                thsnap.push(WebMolKit.angleNorm(Math.atan2(mol.atomY(nbr) - cy, mol.atomX(nbr) - cx) + Math.PI));
            }
            else {
                let angs = [];
                for (let nbr of mol.atomAdjList(atom))
                    angs.push(Math.atan2(mol.atomY(nbr) - cy, mol.atomX(nbr) - cx));
                angs = WebMolKit.sortAngles(angs);
                for (let n = 0; n < angs.length; n++) {
                    let th1 = angs[n], th2 = angs[n < angs.length - 1 ? n + 1 : 0];
                    thsnap.push(th1 + 0.5 * WebMolKit.angleDiffPos(th2, th1));
                }
            }
            let theta = Math.atan2(dy, dx);
            var bestTheta = 0, bestDelta = Number.MAX_VALUE;
            for (let th of thsnap) {
                let delta = Math.abs(WebMolKit.angleDiff(th, theta));
                if (delta < bestDelta) {
                    bestTheta = th;
                    bestDelta = delta;
                }
            }
            return SketchUtil.positionSimpleRing(mol, rsz, mol.atomX(atom), mol.atomY(atom), bestTheta);
        }
        static proposeBondRing(mol, rsz, bond, dx, dy) {
            let bfr = mol.bondFrom(bond), bto = mol.bondTo(bond);
            let bx = mol.atomX(bto) - mol.atomX(bfr), by = mol.atomY(bto) - mol.atomY(bfr);
            let sign = dx * by - dy * bx;
            let delta = sign > 0 ? -90 * WebMolKit.DEGRAD : 90 * WebMolKit.DEGRAD;
            let theta = Math.atan2(by, bx) + delta;
            let dth = WebMolKit.TWOPI / rsz;
            let rad = WebMolKit.Molecule.IDEALBOND / (2.0 * Math.sin(0.5 * dth)), brad = rad * Math.cos(0.5 * dth);
            let cx = 0.5 * (mol.atomX(bfr) + mol.atomX(bto)) + brad * Math.cos(theta);
            let cy = 0.5 * (mol.atomY(bfr) + mol.atomY(bto)) + brad * Math.sin(theta);
            let rx = [], ry = [];
            for (let n = 0; n < rsz; n++) {
                let th = theta - Math.PI + (n - 0.5) * dth;
                rx.push(cx + Math.cos(th) * rad);
                ry.push(cy + Math.sin(th) * rad);
            }
            let [i1, i2] = sign < 0 ? [bfr, bto] : [bto, bfr];
            rx[0] = mol.atomX(i1);
            ry[0] = mol.atomY(i1);
            rx[1] = mol.atomX(i2);
            ry[1] = mol.atomY(i2);
            return [rx, ry];
        }
        static positionSimpleRing(mol, rsz, x, y, theta) {
            let dth = WebMolKit.TWOPI / rsz;
            let rad = WebMolKit.Molecule.IDEALBOND / (2 * Math.sin(0.5 * dth));
            let cx = x + rad * Math.cos(theta), cy = y + rad * Math.sin(theta);
            let rx = [], ry = [];
            for (let n = 0; n < rsz; n++) {
                let th = theta - Math.PI + n * dth;
                rx.push(cx + Math.cos(th) * rad);
                ry.push(cy + Math.sin(th) * rad);
            }
            return [rx, ry];
        }
        static guidelineSprouts(mol, atom) {
            let sprouts = [];
            let angs = [], ords = [];
            for (let n = 0; n < 3; n++) {
                angs.push(SketchUtil.allViableDirections(mol, atom, n + 1));
                ords.push([n + 1]);
                for (let i = 0; i < n; i++)
                    if (angs[i] != null && WebMolKit.Vec.equals(angs[n], angs[i])) {
                        angs[n] = null;
                        ords[i].push(n + 1);
                    }
            }
            const cx = mol.atomX(atom), cy = mol.atomY(atom);
            for (let n = 0; n < 3; n++)
                if (angs[n] != null) {
                    let sprout = {
                        'atom': atom,
                        'orders': ords[n],
                        'x': [],
                        'y': [],
                    };
                    for (let i = 0; i < angs[n].length; i++) {
                        sprout.x[i] = cx + Math.cos(angs[n][i]) * WebMolKit.Molecule.IDEALBOND;
                        sprout.y[i] = cy + Math.sin(angs[n][i]) * WebMolKit.Molecule.IDEALBOND;
                    }
                    sprouts.push(sprout);
                }
            return sprouts;
        }
    }
    SketchUtil.GEOM_ANGLES = [
        [0, 180 * WebMolKit.DEGRAD],
        [0, 120 * WebMolKit.DEGRAD],
        [0, 120 * WebMolKit.DEGRAD, 240 * WebMolKit.DEGRAD],
        [0, 90 * WebMolKit.DEGRAD, 150 * WebMolKit.DEGRAD, 240 * WebMolKit.DEGRAD],
        [0, 120 * WebMolKit.DEGRAD, 180 * WebMolKit.DEGRAD, 240 * WebMolKit.DEGRAD],
        [0, 90 * WebMolKit.DEGRAD, 180 * WebMolKit.DEGRAD, 270 * WebMolKit.DEGRAD],
        [0, 90 * WebMolKit.DEGRAD, 150 * WebMolKit.DEGRAD, 210 * WebMolKit.DEGRAD, 270 * WebMolKit.DEGRAD],
        [0, 60 * WebMolKit.DEGRAD, 90 * WebMolKit.DEGRAD, 180 * WebMolKit.DEGRAD, 210 * WebMolKit.DEGRAD],
        [0, 60 * WebMolKit.DEGRAD, 120 * WebMolKit.DEGRAD, 180 * WebMolKit.DEGRAD, 240 * WebMolKit.DEGRAD, 300 * WebMolKit.DEGRAD],
        [0, 45 * WebMolKit.DEGRAD, 90 * WebMolKit.DEGRAD, 180 * WebMolKit.DEGRAD, 225 * WebMolKit.DEGRAD, 270 * WebMolKit.DEGRAD]
    ];
    WebMolKit.SketchUtil = SketchUtil;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class MolUtil {
        static isBlank(mol) {
            if (mol == null)
                return true;
            return mol.numAtoms == 0;
        }
        static notBlank(mol) {
            if (mol == null)
                return false;
            return mol.numAtoms > 0;
        }
        static orBlank(mol) { return mol == null ? new WebMolKit.Molecule() : mol; }
        static hasAnyAbbrev(mol) {
            for (let n = 1; n <= mol.numAtoms; n++)
                if (MolUtil.hasAbbrev(mol, n))
                    return true;
            return false;
        }
        static hasAbbrev(mol, atom) {
            let extra = mol.atomExtra(atom);
            for (let n = 0; n < (extra == null ? 0 : extra.length); n++)
                if (extra[n].startsWith('a'))
                    return true;
            return false;
        }
        static getAbbrev(mol, atom) {
            let extra = mol.atomExtra(atom);
            for (let n = 0; n < (extra != null ? extra.length : 0); n++)
                if (extra[n].startsWith("a")) {
                    return WebMolKit.Molecule.fromString(extra[n].substring(1));
                }
            return null;
        }
        static setAbbrev(mol, atom, frag) {
            let attidx = 0;
            for (let n = 1; n <= frag.numAtoms; n++)
                if (frag.atomElement(n) == MolUtil.ABBREV_ATTACHMENT) {
                    if (attidx > 0)
                        throw 'Multiple attachment points indicated: invalid.';
                    attidx = n;
                }
            if (attidx == 0)
                throw 'No attachment points indicated.';
            if (attidx >= 2) {
                frag = frag.clone();
                frag.swapAtoms(attidx, 1);
            }
            let adj = mol.atomAdjList(atom);
            if (adj.length > 1)
                throw 'Setting abbreviation for non-terminal atom.';
            if (frag.atomAdjCount(1) == 1 && mol.atomAdjCount(atom) > 0) {
                let b1 = mol.findBond(atom, mol.atomAdjList(atom)[0]);
                let b2 = frag.findBond(1, frag.atomAdjList(1)[0]);
                mol.setBondOrder(b1, frag.bondOrder(b2));
            }
            let extra = mol.atomExtra(atom);
            let idx = -1;
            for (let n = 0; n < (extra != null ? extra.length : 0); n++)
                if (extra[n].startsWith("a")) {
                    idx = n;
                    break;
                }
            if (idx < 0)
                idx = extra.push(null) - 1;
            extra[idx] = "a" + frag.toString();
            mol.setAtomExtra(atom, extra);
        }
        static validateAbbrevs(mol) {
            for (let n = 1; n <= mol.numAtoms; n++)
                if (MolUtil.hasAbbrev(mol, n)) {
                    if (mol.atomAdjCount(n) > 1)
                        MolUtil.clearAbbrev(mol, n);
                    if (mol.atomCharge(n) != 0)
                        mol.setAtomCharge(n, 0);
                    if (mol.atomUnpaired(n) != 0)
                        mol.setAtomUnpaired(n, 0);
                    if (mol.atomIsotope(n) != 0)
                        mol.setAtomIsotope(n, WebMolKit.Molecule.ISOTOPE_NATURAL);
                    if (mol.atomHExplicit(n) != WebMolKit.Molecule.HEXPLICIT_UNKNOWN)
                        mol.setAtomHExplicit(n, WebMolKit.Molecule.HEXPLICIT_UNKNOWN);
                }
        }
        static convertToAbbrev(mol, srcmask, abbrevName) {
            let junction = 0;
            for (let n = 1; n <= mol.numBonds; n++) {
                let b1 = mol.bondFrom(n), b2 = mol.bondTo(n), atom = 0;
                if (srcmask[b1 - 1] && !srcmask[b2 - 1])
                    atom = b1;
                else if (!srcmask[b1 - 1] && srcmask[b2 - 1])
                    atom = b2;
                if (atom == 0)
                    continue;
                if (junction > 0 && atom != junction)
                    return null;
                junction = atom;
            }
            if (junction == 0)
                return null;
            let na = mol.numAtoms, molidx = 0, fragidx = 0;
            let maskmol = WebMolKit.Vec.booleanArray(false, na), maskfrag = WebMolKit.Vec.booleanArray(false, na);
            for (let n = 0; n < na; n++) {
                maskmol[n] = srcmask[n];
                maskfrag[n] = !srcmask[n] || n + 1 == junction;
                if (maskmol[n] && n + 1 <= junction)
                    molidx++;
                if (maskfrag[n] && n + 1 <= junction)
                    fragidx++;
            }
            let frag = MolUtil.subgraphMask(mol, maskfrag);
            frag.setAtomElement(fragidx, MolUtil.ABBREV_ATTACHMENT);
            frag.setAtomCharge(fragidx, 0);
            frag.setAtomUnpaired(fragidx, 0);
            frag.setAtomHExplicit(fragidx, WebMolKit.Molecule.HEXPLICIT_UNKNOWN);
            frag.setAtomMapNum(fragidx, 0);
            frag.setAtomExtra(fragidx, []);
            frag.setAtomTransient(fragidx, []);
            let adj = frag.atomAdjList(fragidx);
            let x = 0, y = 0, inv = 1.0 / adj.length;
            let bondOrder = 1;
            for (let n = 0; n < adj.length; n++) {
                x += frag.atomX(adj[n]);
                y += frag.atomY(adj[n]);
                let b = frag.findBond(fragidx, adj[n]);
                if (n == 0)
                    bondOrder = frag.bondOrder(b);
                else if (bondOrder != frag.bondOrder(b))
                    bondOrder = 1;
            }
            x *= inv;
            y *= inv;
            let newmol = MolUtil.subgraphMask(mol, maskmol);
            let newatom = newmol.addAtom(abbrevName, x, y);
            newmol.addBond(molidx, newatom, bondOrder);
            MolUtil.setAbbrev(newmol, newatom, frag);
            return newmol;
        }
        static expandAbbrevs(mol, alignCoords) {
            while (true) {
                let anything = false;
                for (let n = 1; n <= mol.numAtoms; n++)
                    if (MolUtil.hasAbbrev(mol, n)) {
                        if (MolUtil.expandOneAbbrev(mol, n, alignCoords))
                            anything = true;
                        n--;
                    }
                if (!anything)
                    break;
            }
        }
        static expandOneAbbrev(mol, atom, alignCoords) {
            let frag = MolUtil.getAbbrev(mol, atom);
            if (frag == null)
                return false;
            if (mol.atomAdjCount(atom) != 1 || frag.numAtoms == 0) {
                MolUtil.clearAbbrev(mol, atom);
                return false;
            }
            let m = mol.atomMapNum(atom);
            if (m > 0)
                for (let n of frag.atomAdjList(1))
                    frag.setAtomMapNum(n, m);
            MolUtil.expandOneAbbrevFrag(mol, atom, frag, alignCoords);
            return true;
        }
        static expandOneAbbrevFrag(mol, atom, frag, alignCoords) {
            let nbr = mol.atomAdjCount(atom) == 1 ? mol.atomAdjList(atom)[0] : 0;
            if (alignCoords) {
                let vx1 = mol.atomX(atom) - mol.atomX(nbr), vy1 = mol.atomY(atom) - mol.atomY(nbr);
                let adj = frag.atomAdjList(1);
                let vx2 = 0, vy2 = 0, inv = 1.0 / adj.length;
                for (let n = 0; n < adj.length; n++) {
                    vx2 += frag.atomX(adj[n]) - frag.atomX(1);
                    vy2 += frag.atomY(adj[n]) - frag.atomY(1);
                }
                vx2 *= inv;
                vy2 *= inv;
                let th1 = Math.atan2(vy1, vx1), th2 = Math.atan2(vy2, vx2);
                WebMolKit.CoordUtil.rotateMolecule(frag, th1 - th2);
                WebMolKit.CoordUtil.translateMolecule(frag, mol.atomX(nbr) - frag.atomX(1), mol.atomY(nbr) - frag.atomY(1));
            }
            let join = mol.numAtoms + 1;
            mol.append(frag);
            for (let n = 1; n <= mol.numBonds; n++) {
                if (mol.bondFrom(n) == join)
                    mol.setBondFrom(n, nbr);
                if (mol.bondTo(n) == join)
                    mol.setBondTo(n, nbr);
            }
            mol.deleteAtomAndBonds(join);
            mol.deleteAtomAndBonds(atom);
        }
        static clearAbbrev(mol, atom) {
            let extra = mol.atomExtra(atom);
            for (let n = 0; n < (extra != null ? extra.length : 0); n++)
                if (extra[n].startsWith("a")) {
                    extra.splice(n, 1);
                    mol.setAtomExtra(atom, extra);
                    mol.setAtomElement(atom, 'C');
                    return;
                }
        }
        static setAtomElement(mol, atom, el) {
            if (mol.atomElement(atom) == el)
                return;
            this.clearAbbrev(mol, atom);
            mol.setAtomElement(atom, el);
        }
        static addBond(mol, bfr, bto, order, type) {
            if (type == null)
                type = WebMolKit.Molecule.BONDTYPE_NORMAL;
            if (mol.atomAdjCount(bfr) >= 1)
                this.clearAbbrev(mol, bfr);
            if (mol.atomAdjCount(bto) >= 1)
                this.clearAbbrev(mol, bto);
            let b = mol.findBond(bfr, bto);
            if (b > 0)
                mol.deleteBond(b);
            return mol.addBond(bfr, bto, order, type);
        }
        static subgraphMask(mol, mask) {
            let invidx = [];
            let sum = 0;
            for (let n = 0; n < mol.numAtoms; n++) {
                if (mask[n])
                    invidx.push(++sum);
                else
                    invidx.push(0);
            }
            if (sum == 0)
                return new WebMolKit.Molecule();
            if (sum == mol.numAtoms)
                return mol.clone();
            let frag = new WebMolKit.Molecule();
            for (let n = 1; n <= mol.numAtoms; n++)
                if (mask[n - 1]) {
                    let num = frag.addAtom(mol.atomElement(n), mol.atomX(n), mol.atomY(n), mol.atomCharge(n), mol.atomUnpaired(n));
                    frag.setAtomIsotope(num, mol.atomIsotope(n));
                    frag.setAtomHExplicit(num, mol.atomHExplicit(n));
                    frag.setAtomMapNum(num, mol.atomMapNum(n));
                    frag.setAtomExtra(num, mol.atomExtra(n));
                }
            for (let n = 1; n <= mol.numBonds; n++) {
                let bfr = invidx[mol.bondFrom(n) - 1], bto = invidx[mol.bondTo(n) - 1];
                if (bfr > 0 && bto > 0) {
                    let num = frag.addBond(bfr, bto, mol.bondOrder(n), mol.bondType(n));
                    frag.setBondExtra(num, mol.bondExtra(n));
                }
            }
            return frag;
        }
        static subgraphIndex(mol, idx) {
            let invidx = WebMolKit.Vec.numberArray(0, mol.numAtoms);
            for (let n = 0; n < invidx.length; n++)
                invidx[n] = 0;
            for (let n = 0; n < idx.length; n++)
                invidx[idx[n] - 1] = n + 1;
            let frag = new WebMolKit.Molecule();
            for (let n = 0; n < idx.length; n++) {
                let num = frag.addAtom(mol.atomElement(idx[n]), mol.atomX(idx[n]), mol.atomY(idx[n]), mol.atomCharge(idx[n]), mol.atomUnpaired(idx[n]));
                frag.setAtomIsotope(num, mol.atomIsotope(idx[n]));
                frag.setAtomHExplicit(num, mol.atomHExplicit(idx[n]));
                frag.setAtomMapNum(num, mol.atomMapNum(idx[n]));
                frag.setAtomExtra(num, mol.atomExtra(idx[n]));
            }
            for (let n = 1; n <= mol.numBonds; n++) {
                let bfr = invidx[mol.bondFrom(n) - 1], bto = invidx[mol.bondTo(n) - 1];
                if (bfr > 0 && bto > 0) {
                    let num = frag.addBond(bfr, bto, mol.bondOrder(n), mol.bondType(n));
                    frag.setBondExtra(num, mol.bondExtra(n));
                }
            }
            return frag;
        }
        static subgraphWithAttachments(mol, mask) {
            let xmask = mask.slice(0);
            for (let n = 1; n <= mol.numBonds; n++) {
                let bfr = mol.bondFrom(n) - 1, bto = mol.bondTo(n) - 1;
                if (mask[bfr] && !mask[bto])
                    xmask[bto] = true;
                else if (mask[bto] && !mask[bfr])
                    xmask[bfr] = true;
            }
            let xmol = mol.clone();
            for (let n = 1; n <= xmol.numAtoms; n++)
                if (xmask[n - 1] && !mask[n - 1])
                    xmol.setAtomElement(n, 'X');
            return MolUtil.subgraphMask(xmol, xmask);
        }
        static append(mol, frag) {
            let boxm = mol.boundary(), boxf = frag.boundary();
            let dx = boxm.maxX() + WebMolKit.Molecule.IDEALBOND - boxm.minX();
            let dy = 0.5 * (boxm.minY() + boxm.maxY() - boxf.minY() - boxf.maxY());
            let top = mol.numAtoms;
            mol.append(frag);
            for (let n = top + 1; n <= mol.numAtoms; n++)
                mol.setAtomPos(n, mol.atomX(n) + dx, mol.atomY(n) + dy);
        }
        static deleteAtoms(mol, idx) {
            let mask = WebMolKit.Vec.booleanArray(true, mol.numAtoms);
            for (let n = 0; n < idx.length; n++)
                mask[idx[n] - 1] = false;
            return MolUtil.subgraphMask(mol, mask);
        }
        static componentList(mol) {
            let sz = mol.numAtoms;
            if (sz == 0)
                return null;
            let g = WebMolKit.Graph.fromMolecule(mol);
            let groups = g.calculateComponentGroups();
            for (let grp of groups)
                WebMolKit.Vec.addTo(grp, 1);
            return groups;
        }
        static getAtomSides(mol, atom) {
            let g = WebMolKit.Graph.fromMolecule(mol);
            let cc = g.calculateComponents();
            let mask = [];
            for (let n = 0; n < cc.length; n++)
                mask.push(cc[n] == cc[atom - 1]);
            mask[atom - 1] = false;
            let oldmap = WebMolKit.Vec.maskIdx(mask);
            g.keepNodesMask(mask);
            cc = g.calculateComponents();
            let ccmax = WebMolKit.Vec.max(cc);
            let grps = [];
            for (let n = 0; n < ccmax; n++)
                grps.push([atom]);
            for (let n = 0; n < cc.length; n++)
                grps[cc[n] - 1].push(oldmap[n] + 1);
            return grps;
        }
        static getBondSides(mol, bond) {
            let bf = mol.bondFrom(bond), bt = mol.bondTo(bond);
            let inRing = mol.bondInRing(bond);
            let g = WebMolKit.Graph.fromMolecule(mol);
            let cc = g.calculateComponents();
            let mask = [];
            for (let n = 0; n < cc.length; n++)
                mask.push(cc[n] == cc[bf - 1]);
            if (!inRing)
                g.removeEdge(bf - 1, bt - 1);
            else {
                mask[bf - 1] = false;
                mask[bt - 1] = false;
            }
            let oldmap = WebMolKit.Vec.maskIdx(mask);
            g.keepNodesMask(mask);
            cc = g.calculateComponents();
            let ccmax = WebMolKit.Vec.max(cc);
            let grps = [];
            for (let n = 0; n < ccmax; n++) {
                grps[n] = [];
                if (inRing) {
                    grps[n].push(bf);
                    grps[n].push(bt);
                }
            }
            for (let n = 0; n < cc.length; n++)
                grps[cc[n] - 1].push(oldmap[n] + 1);
            return grps;
        }
        static arrayAtomX(mol) {
            let x = WebMolKit.Vec.numberArray(0, mol.numAtoms);
            for (let n = x.length - 1; n >= 0; n--)
                x[n] = mol.atomX(n + 1);
            return x;
        }
        static arrayAtomY(mol) {
            let y = WebMolKit.Vec.numberArray(0, mol.numAtoms);
            for (let n = y.length - 1; n >= 0; n--)
                y[n] = mol.atomY(n + 1);
            return y;
        }
        static molecularFormula(mol, punctuation) {
            let puncEnter = '', puncExit = '', puncEnterSuper = '', puncExitSuper = '';
            if (punctuation == true)
                [puncEnter, puncExit] = ['{', '}', '{^', '}'];
            else if (punctuation instanceof Array) {
                puncEnter = punctuation[0];
                puncExit = punctuation[1];
                puncEnterSuper = punctuation[2];
                puncExitSuper = punctuation[3];
            }
            for (let n = 1; n <= mol.numAtoms; n++)
                if (MolUtil.hasAbbrev(mol, n)) {
                    mol = mol.clone();
                    MolUtil.expandAbbrevs(mol, false);
                    break;
                }
            let countC = 0, countH = 0;
            let elements = WebMolKit.Vec.stringArray('', mol.numAtoms);
            for (let n = 1; n <= mol.numAtoms; n++) {
                countH += mol.atomHydrogens(n);
                let el = mol.atomElement(n);
                if (mol.atomIsotope(n) != WebMolKit.Molecule.ISOTOPE_NATURAL)
                    el = puncEnterSuper + mol.atomIsotope(n) + puncExitSuper + el;
                if (el == 'C')
                    countC++;
                else if (el == 'H')
                    countH++;
                else
                    elements[n - 1] = el;
            }
            elements.sort();
            let formula = '';
            if (countC > 0)
                formula += 'C';
            if (countC > 1) {
                if (punctuation)
                    formula += puncEnter;
                formula += countC;
                if (punctuation)
                    formula += puncExit;
            }
            if (countH > 0)
                formula += 'H';
            if (countH > 1) {
                if (punctuation)
                    formula += puncEnter;
                formula += countH;
                if (punctuation)
                    formula += puncExit;
            }
            for (let n = 0; n < elements.length; n++)
                if (elements[n].length > 0) {
                    let count = 1;
                    for (; n + 1 < elements.length && elements[n] == elements[n + 1]; n++)
                        count++;
                    formula += elements[n];
                    if (count > 1) {
                        if (punctuation)
                            formula += puncEnter;
                        formula += count;
                        if (punctuation)
                            formula += puncExit;
                    }
                }
            return formula.toString();
        }
        static molecularWeight(mol) {
            for (let n = 1; n <= mol.numAtoms; n++)
                if (MolUtil.hasAbbrev(mol, n)) {
                    mol = mol.clone();
                    MolUtil.expandAbbrevs(mol, false);
                    break;
                }
            let mw = 0;
            for (let n = 1; n <= mol.numAtoms; n++) {
                mw += mol.atomHydrogens(n) * WebMolKit.Chemistry.NATURAL_ATOMIC_WEIGHTS[1];
                let iso = mol.atomIsotope(n);
                if (iso != WebMolKit.Molecule.ISOTOPE_NATURAL) {
                    mw += iso;
                    continue;
                }
                let an = WebMolKit.Molecule.elementAtomicNumber(mol.atomElement(n));
                if (an > 0 && an < WebMolKit.Chemistry.NATURAL_ATOMIC_WEIGHTS.length)
                    mw += WebMolKit.Chemistry.NATURAL_ATOMIC_WEIGHTS[an];
            }
            return mw;
        }
        static removeDuplicateBonds(mol) {
            let bpri = [];
            for (let n = 1; n <= mol.numBonds; n++) {
                let p = Math.min(mol.bondFrom(n), mol.bondTo(n)) * mol.numAtoms + Math.max(mol.bondFrom(n), mol.bondTo(n));
                bpri.push(p);
            }
            let bidx = WebMolKit.Vec.idxSort(bpri);
            let keepmask = WebMolKit.Vec.booleanArray(false, bidx.length);
            let p = 0;
            while (p < bidx.length) {
                let sz = 1;
                while (p + sz < bidx.length && bpri[bidx[p]] == bpri[bidx[p + sz]])
                    sz++;
                let best = p;
                for (let n = p + 1; n < p + sz; n++) {
                    let b1 = bidx[best] + 1, b2 = bidx[n] + 1;
                    let a1 = mol.bondFrom(b1), a2 = mol.bondTo(b1);
                    let el1 = mol.atomElement(a1), el2 = mol.atomElement(a2);
                    let limit1 = 0, limit2 = 0;
                    if (el1 == 'C' || el1 == 'N')
                        limit1 = 4;
                    else if (el1 == 'O')
                        limit1 = 3;
                    if (el2 == 'C' || el2 == 'N')
                        limit2 = 4;
                    else if (el2 == 'O')
                        limit2 = 3;
                    if (limit1 > 0 || limit2 > 0) {
                        let boB1A1 = 0, boB1A2 = 0, boB2A1 = 0, boB2A2 = 0;
                        for (let i = 1; i <= mol.numBonds; i++) {
                            if (i != b2 && (mol.bondFrom(i) == a1 || mol.bondTo(i) == a1))
                                boB1A1 += mol.bondOrder(i);
                            if (i != b2 && (mol.bondFrom(i) == a2 || mol.bondTo(i) == a2))
                                boB1A2 += mol.bondOrder(i);
                            if (i != b1 && (mol.bondFrom(i) == a1 || mol.bondTo(i) == a1))
                                boB2A1 += mol.bondOrder(i);
                            if (i != b1 && (mol.bondFrom(i) == a2 || mol.bondTo(i) == a2))
                                boB2A2 += mol.bondOrder(i);
                        }
                        let bad1 = 0, bad2 = 0;
                        if (limit1 > 0 && boB1A1 > limit1)
                            bad1++;
                        if (limit2 > 0 && boB1A2 > limit2)
                            bad1++;
                        if (limit1 > 0 && boB2A1 > limit1)
                            bad2++;
                        if (limit2 > 0 && boB2A2 > limit2)
                            bad2++;
                        if (bad1 < bad2)
                            continue;
                        if (bad1 > bad2) {
                            best = n;
                            continue;
                        }
                    }
                    let exotic1 = 2 * mol.bondOrder(b1), exotic2 = 2 * mol.bondOrder(b2);
                    exotic1 += (exotic1 == 0 ? 4 : 0) + (mol.bondType(b1) != WebMolKit.Molecule.BONDTYPE_NORMAL ? 1 : 0);
                    exotic2 += (exotic2 == 0 ? 4 : 0) + (mol.bondType(b2) != WebMolKit.Molecule.BONDTYPE_NORMAL ? 1 : 0);
                    if (exotic2 > exotic1)
                        best = n;
                }
                keepmask[bidx[best]] = true;
                p += sz;
            }
            for (let n = mol.numBonds; n >= 1; n--)
                if (!keepmask[n - 1] || mol.bondFrom(n) == mol.bondTo(n))
                    mol.deleteBond(n);
        }
        static calculateWalkWeight(mol, atom) {
            let ccsz = 0, cc = WebMolKit.Graph.fromMolecule(mol).calculateComponents();
            for (let n = 0; n < cc.length; n++)
                if (cc[n] == cc[atom - 1])
                    ccsz++;
            let w = WebMolKit.Vec.numberArray(1, mol.numAtoms), wn = WebMolKit.Vec.numberArray(0, mol.numAtoms);
            w[atom - 1] = 0;
            for (; ccsz > 0; ccsz--) {
                for (let n = 0; n < mol.numAtoms; n++)
                    wn[n] = w[n];
                for (let n = 1; n <= mol.numBonds; n++) {
                    let a1 = mol.bondFrom(n) - 1, a2 = mol.bondTo(n) - 1;
                    w[a1] += wn[a2] * 0.1;
                    w[a2] += wn[a1] * 0.1;
                }
                w[atom - 1] = 0;
            }
            return w;
        }
        static totalHydrogens(mol, atom) {
            let hc = mol.atomHydrogens(atom);
            let adj = mol.atomAdjList(atom);
            for (let n = 0; n < adj.length; n++)
                if (mol.atomElement(adj[n]) == 'H')
                    hc++;
            return hc;
        }
        static stripHydrogens(mol, force = false) {
            for (let n = mol.numAtoms; n >= 1; n--) {
                if (mol.atomElement(n) != 'H')
                    continue;
                if (!force) {
                    if (mol.atomCharge(n) != 0 || mol.atomUnpaired(n) != 0)
                        continue;
                    if (mol.atomIsotope(n) != WebMolKit.Molecule.ISOTOPE_NATURAL)
                        continue;
                    if (WebMolKit.Vec.notBlank(mol.atomExtra(n)) || WebMolKit.Vec.notBlank(mol.atomTransient(n)))
                        continue;
                    if (mol.atomAdjCount(n) != 1)
                        continue;
                    let other = mol.atomAdjList(n)[0];
                    if (mol.atomElement(other) == 'H')
                        continue;
                    let bond = mol.atomAdjBonds(n)[0];
                    if (mol.bondOrder(bond) != 1 || mol.bondType(bond) != WebMolKit.Molecule.BONDTYPE_NORMAL)
                        continue;
                    if (mol.atomHExplicit(other) != WebMolKit.Molecule.HEXPLICIT_UNKNOWN)
                        continue;
                    if (WebMolKit.Molecule.HYVALENCE_EL.indexOf(mol.atomElement(other)) < 0)
                        continue;
                }
                mol.deleteAtomAndBonds(n);
            }
        }
        static createHydrogens(mol, position) {
            if (position == null)
                position = false;
            let na = mol.numAtoms;
            for (let n = 1; n <= na; n++) {
                let hc = mol.atomHydrogens(n);
                if (hc == 0)
                    continue;
                if (mol.atomHExplicit(n) != WebMolKit.Molecule.HEXPLICIT_UNKNOWN)
                    mol.setAtomHExplicit(n, 0);
                if (!position) {
                    for (; hc > 0; hc--) {
                        let a = mol.addAtom("H", mol.atomX(n), mol.atomY(n));
                        mol.addBond(n, a, 1);
                    }
                }
                else
                    WebMolKit.SketchUtil.placeAdditionalHydrogens(mol, n, hc);
            }
            return mol.numAtoms - na;
        }
        static atomVec3(mol, atom) {
            if (mol.is3D())
                return [mol.atomX(atom), mol.atomY(atom), mol.atomZ(atom)];
            else
                return [mol.atomX(atom), mol.atomY(atom), 0];
        }
    }
    MolUtil.TEMPLATE_ATTACHMENT = 'X';
    MolUtil.ABBREV_ATTACHMENT = '*';
    WebMolKit.MolUtil = MolUtil;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class Graph {
        constructor(sz, edge1, edge2) {
            this.nbrs = [];
            this.indices = null;
            this.labels = null;
            this.props = null;
            if (sz != null)
                for (let n = 0; n < sz; n++)
                    this.nbrs.push([]);
            if (edge1 != null && edge2 != null) {
                for (let n = 0; n < edge1.length; n++) {
                    this.nbrs[edge1[n]].push(edge2[n]);
                    this.nbrs[edge2[n]].push(edge1[n]);
                }
            }
        }
        clone() {
            let g = new Graph();
            for (let nbr of this.nbrs)
                g.nbrs.push(nbr.slice(0));
            g.indices = this.indices == null ? null : this.indices.slice(0);
            g.labels = this.labels == null ? null : this.labels.slice(0);
            g.props = this.props == null ? null : this.props.slice(0);
            return g;
        }
        static fromMolecule(mol) {
            let g = new Graph();
            g.indices = [];
            for (let n = 0; n < mol.numAtoms; n++) {
                g.nbrs.push([]);
                g.indices.push(n + 1);
            }
            for (let n = 1; n <= mol.numBonds; n++) {
                let bfr = mol.bondFrom(n) - 1, bto = mol.bondTo(n) - 1;
                g.nbrs[bfr].push(bto);
                g.nbrs[bto].push(bfr);
            }
            return g;
        }
        toString() {
            let buff = '#nodes=' + this.nbrs.length;
            for (let n = 0; n < this.nbrs.length; n++) {
                buff += ' ' + n + ':{' + this.nbrs[n] + '}';
                if (n < WebMolKit.Vec.arrayLength(this.indices))
                    buff += '[i=' + this.indices[n] + ']';
                if (n < WebMolKit.Vec.arrayLength(this.labels))
                    buff += '[l=' + this.labels[n] + ']';
            }
            return buff;
        }
        get numNodes() { return this.nbrs.length; }
        numEdges(node) { return this.nbrs[node].length; }
        getEdge(node, edge) { return this.nbrs[node][edge]; }
        getEdges(node) { return this.nbrs[node]; }
        getIndex(node) { return this.indices == null ? 0 : this.indices[node]; }
        setIndex(node, idx) {
            if (this.indices == null)
                this.indices = WebMolKit.Vec.numberArray(0, this.nbrs.length);
            this.indices[node] = idx;
        }
        getLabel(node) { return this.labels == null ? null : this.labels[node]; }
        setLabel(node, lbl) {
            if (this.labels == null)
                this.labels = WebMolKit.Vec.stringArray('', this.nbrs.length);
            this.labels[node] = lbl;
        }
        getProperty(node) { return this.props == null ? null : this.props[node]; }
        setProperty(node, prp) {
            if (this.props == null)
                this.props = new Array(this.nbrs.length);
            this.props[node] = prp;
        }
        addNode() {
            this.nbrs.push([]);
            if (this.indices != null)
                this.indices.push(0);
            if (this.labels != null)
                this.labels.push('');
            if (this.props != null)
                this.props.push(null);
            return this.nbrs.length - 1;
        }
        hasEdge(node1, node2) {
            if (this.nbrs[node1].length <= this.nbrs[node2].length)
                return this.nbrs[node1].indexOf(node2) >= 0;
            else
                return this.nbrs[node2].indexOf(node1) >= 0;
        }
        addEdge(node1, node2) {
            this.nbrs[node1].push(node2);
            this.nbrs[node2].push(node1);
        }
        removeEdge(node1, node2) {
            let i1 = this.nbrs[node1].indexOf(node2), i2 = this.nbrs[node2].indexOf(node1);
            if (i1 >= 0)
                this.nbrs[node1].splice(i1, 1);
            if (i2 >= 0)
                this.nbrs[node2].splice(i2, 1);
        }
        isolateNode(node) {
            for (let o of this.nbrs[node]) {
                let i = this.nbrs[o].indexOf(node);
                if (i >= 0)
                    this.nbrs[o].splice(i, 1);
            }
            this.nbrs[node] = [];
        }
        keepNodesMask(mask) {
            const oldsz = this.nbrs.length, newsz = WebMolKit.Vec.maskCount(mask);
            if (newsz == oldsz)
                return;
            if (newsz == 0) {
                this.nbrs = [];
                this.indices = null;
                this.labels = null;
                this.props = null;
                return;
            }
            let newmap = WebMolKit.Vec.maskMap(mask);
            let newnbrs = [];
            for (let n = 0; n < newsz; n++)
                newnbrs.push([]);
            for (let n = 0, pos = 0; n < oldsz; n++)
                if (mask[n]) {
                    for (let i of this.nbrs[n])
                        if (mask[i])
                            newnbrs[pos].push(newmap[i]);
                    pos++;
                }
            this.nbrs = newnbrs;
            if (this.indices != null)
                this.indices = WebMolKit.Vec.maskGet(this.indices, mask);
            if (this.labels != null)
                this.labels = WebMolKit.Vec.maskGet(this.labels, mask);
            if (this.props != null)
                this.props = WebMolKit.Vec.maskGet(this.props, mask);
        }
        keepNodesIndex(idx) { this.keepNodesMask(WebMolKit.Vec.idxMask(idx, this.numNodes)); }
        removeNodesMask(mask) { this.keepNodesMask(WebMolKit.Vec.notMask(mask)); }
        removeNodesIndex(idx) { this.removeNodesMask(WebMolKit.Vec.idxMask(idx, this.numNodes)); }
        subgraphIndex(idx) {
            const nsz = idx.length;
            let g = new Graph(nsz);
            if (this.indices != null || this.labels != null || this.props != null)
                for (let n = 0; n < nsz; n++) {
                    if (this.indices != null)
                        g.setIndex(n, this.indices[idx[n]]);
                    if (this.labels != null)
                        g.setLabel(n, this.labels[idx[n]]);
                    if (this.props != null)
                        g.setProperty(n, this.props[idx[n]]);
                }
            for (let i = 0; i < nsz; i++) {
                for (let n of this.nbrs[idx[i]]) {
                    let j = idx.indexOf(n);
                    if (j > i)
                        g.addEdge(i, j);
                }
            }
            return g;
        }
        subgraphMask(mask) {
            let g = this.clone();
            g.keepNodesMask(mask);
            return g;
        }
        calculateComponents() {
            const sz = this.nbrs.length;
            if (sz == 0)
                return [];
            let cc = WebMolKit.Vec.numberArray(0, sz);
            cc[0] = 1;
            let first = 1, high = 1;
            while (true) {
                while (first < sz && cc[first] > 0) {
                    first++;
                }
                if (first >= sz)
                    break;
                let anything = false;
                for (let i = first; i < sz; i++)
                    if (cc[i] == 0) {
                        for (let j = 0; j < this.nbrs[i].length; j++) {
                            if (cc[this.nbrs[i][j]] != 0) {
                                cc[i] = cc[this.nbrs[i][j]];
                                anything = true;
                            }
                        }
                    }
                if (!anything)
                    cc[first] = ++high;
            }
            return cc;
        }
        calculateComponentGroups() {
            if (this.nbrs.length == 0)
                return [];
            let cc = this.calculateComponents();
            let sz = WebMolKit.Vec.max(cc);
            let grp = [];
            for (let n = 0; n < sz; n++)
                grp.push([]);
            for (let n = 0; n < cc.length; n++)
                grp[cc[n] - 1].push(n);
            return grp;
        }
        calculateBFS(idx) {
            let ret = WebMolKit.Vec.numberArray(-1, this.numNodes);
            ret[idx] = 0;
            let curnum = 0, lsz = 1, watermark = 0;
            let list = WebMolKit.Vec.numberArray(0, this.numNodes);
            list[0] = idx;
            while (true) {
                let newsz = lsz;
                for (let n = watermark; n < lsz; n++) {
                    for (let i = 0; i < this.nbrs[list[n]].length; i++) {
                        let j = this.nbrs[list[n]][i];
                        if (ret[j] < 0) {
                            ret[j] = curnum + 1;
                            list[newsz++] = j;
                        }
                    }
                }
                if (newsz == lsz)
                    break;
                watermark = lsz;
                lsz = newsz;
                curnum++;
            }
            return ret;
        }
    }
    WebMolKit.Graph = Graph;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class CoordUtil {
        static atomAtPoint(mol, x, y, tolerance) {
            if (tolerance == null)
                tolerance = CoordUtil.OVERLAP_THRESHOLD;
            const tolsq = tolerance * tolerance;
            for (let n = 1; n <= mol.numAtoms; n++)
                if (WebMolKit.norm2_xy(mol.atomX(n) - x, mol.atomY(n) - y) < tolsq)
                    return n;
            return 0;
        }
        static sketchEquivalent(mol1, mol2, tolerance) {
            if (tolerance == null)
                tolerance = CoordUtil.DEFAULT_EQUIV_TOLERANCE;
            const na = mol1.numAtoms, nb = mol1.numBonds;
            if (na != mol2.numAtoms || nb != mol2.numBonds)
                return false;
            const tolsq = tolerance * tolerance;
            let box1 = mol1.boundary(), box2 = mol2.boundary();
            if (Math.abs(box1.minX() - box2.minX()) > tolerance)
                return false;
            if (Math.abs(box1.minY() - box2.minY()) > tolerance)
                return false;
            if (Math.abs(box1.maxX() - box2.maxX()) > tolerance)
                return false;
            if (Math.abs(box1.maxY() - box2.maxY()) > tolerance)
                return false;
            let mx1 = WebMolKit.MolUtil.arrayAtomX(mol1), my1 = WebMolKit.MolUtil.arrayAtomY(mol1);
            let mx2 = WebMolKit.MolUtil.arrayAtomX(mol2), my2 = WebMolKit.MolUtil.arrayAtomY(mol2);
            let map = WebMolKit.Vec.numberArray(0, na);
            let mask = WebMolKit.Vec.booleanArray(false, na);
            for (let i = 0; i < na; i++) {
                let j = -1;
                if (WebMolKit.norm2_xy(mx1[i] - mx2[i], my1[i] - my2[i]) < tolsq)
                    j = i;
                if (j < 0) {
                    let bestdsq = Number.MAX_VALUE;
                    for (let n = 0; n < na; n++)
                        if (!mask[n]) {
                            let dsq = WebMolKit.norm2_xy(mx1[i] - mx2[n], my1[i] - my2[n]);
                            if (dsq < bestdsq) {
                                bestdsq = dsq;
                                j = n;
                            }
                        }
                    if (j < 0 || bestdsq > tolsq)
                        return false;
                }
                map[i] = j + 1;
                mask[j] = true;
                if (mol1.atomElement(i + 1) != mol2.atomElement(j + 1))
                    return false;
                if (mol1.atomCharge(i + 1) != mol2.atomCharge(j + 1))
                    return false;
                if (mol1.atomUnpaired(i + 1) != mol2.atomUnpaired(j + 1))
                    return false;
                if (mol1.atomHExplicit(i + 1) != mol2.atomHExplicit(j + 1) &&
                    mol1.atomHExplicit(i + 1) != WebMolKit.Molecule.HEXPLICIT_UNKNOWN &&
                    mol2.atomHExplicit(j + 1) != WebMolKit.Molecule.HEXPLICIT_UNKNOWN)
                    return false;
            }
            for (let i = 1; i <= nb; i++) {
                let i1 = mol1.bondFrom(i), i2 = mol1.bondTo(i), j1 = map[i1 - 1], j2 = map[i2 - 1];
                let j = mol2.findBond(j1, j2);
                if (j == 0)
                    return false;
                if (mol1.bondOrder(i) != mol2.bondOrder(j) || mol1.bondType(i) != mol2.bondType(j))
                    return false;
                if (mol2.bondFrom(j) == j1 && mol2.bondTo(j) == j2) { }
                else if (mol2.bondType(j) != WebMolKit.Molecule.BONDTYPE_INCLINED &&
                    mol2.bondType(j) != WebMolKit.Molecule.BONDTYPE_DECLINED &&
                    mol2.bondFrom(j) == j2 && mol2.bondTo(j) == j1) { }
                else
                    return false;
            }
            return true;
        }
        static sketchMappable(mol1, mol2, tolerance) {
            if (tolerance == null)
                tolerance = CoordUtil.DEFAULT_EQUIV_TOLERANCE;
            let box1 = mol1.boundary(), box2 = mol2.boundary();
            let dx = box1.minX() - box2.minX(), dy = box1.minY() - box2.minY();
            if (Math.abs(dx) > tolerance * 0.1 || Math.abs(dy) > tolerance * 0.1) {
                mol2 = mol2.clone();
                for (let n = 1; n <= mol2.numAtoms; n++)
                    mol2.setAtomPos(n, mol2.atomX(n) + dx, mol2.atomY(n) + dy);
            }
            return CoordUtil.sketchEquivalent(mol1, mol2, tolerance);
        }
        static atomBondAngles(mol, atom, adj) {
            if (adj == null)
                adj = mol.atomAdjList(atom);
            let bndang = [];
            let cx = mol.atomX(atom), cy = mol.atomY(atom);
            for (let a of adj)
                bndang.push(Math.atan2(mol.atomY(a) - cy, mol.atomX(a) - cx));
            return bndang;
        }
        static overlapsAtom(mol, x, y, tol) {
            const tolsq = tol * tol;
            for (let n = 1; n <= mol.numAtoms; n++)
                if (WebMolKit.norm2_xy(mol.atomX(n) - x, mol.atomY(n) - y) < tolsq)
                    return true;
            return false;
        }
        static overlappingAtomMask(mol, thresh) {
            if (thresh == null)
                thresh = CoordUtil.OVERLAP_THRESHOLD;
            const sz = mol.numAtoms;
            let box = mol.boundary();
            let p1, p2;
            if (box.w > box.h) {
                p1 = WebMolKit.MolUtil.arrayAtomX(mol);
                p2 = WebMolKit.MolUtil.arrayAtomY(mol);
            }
            else {
                p1 = WebMolKit.MolUtil.arrayAtomY(mol);
                p2 = WebMolKit.MolUtil.arrayAtomX(mol);
            }
            let omask = WebMolKit.Vec.booleanArray(false, sz);
            let idx = WebMolKit.Vec.idxSort(p1);
            const threshSQ = thresh * thresh;
            for (let i = 1; i < sz - 1; i++) {
                for (let j = i - 1; j >= 0; j--) {
                    let d1 = p1[idx[i]] - p1[idx[j]];
                    if (d1 > thresh)
                        break;
                    if (WebMolKit.norm2_xy(d1, p2[idx[i]] - p2[idx[j]]) < threshSQ) {
                        omask[idx[i]] = true;
                        omask[idx[j]] = true;
                    }
                }
                for (let j = i + 1; j < sz; j++) {
                    let d1 = p1[idx[j]] - p1[idx[i]];
                    if (d1 > thresh)
                        break;
                    if (WebMolKit.norm2_xy(d1, p2[idx[j]] - p2[idx[i]]) < threshSQ) {
                        omask[idx[i]] = true;
                        omask[idx[j]] = true;
                    }
                }
            }
            return omask;
        }
        static overlappingAtomList(mol, thresh) {
            if (thresh == null)
                thresh = CoordUtil.OVERLAP_THRESHOLD;
            return WebMolKit.Vec.add(WebMolKit.Vec.maskIdx(CoordUtil.overlappingAtomMask(mol, thresh)), 1);
        }
        static congestionPoint(mol, x, y, approach) {
            if (approach == null)
                approach = 1E-5;
            let score = 0;
            let na = mol.numAtoms;
            for (let n = 1; n <= na; n++)
                score += 1.0 / (approach + WebMolKit.norm2_xy(mol.atomX(n) - x, mol.atomY(n) - y));
            return score;
        }
        static congestionMolecule(mol, approach) {
            if (approach == null)
                approach = 1E-5;
            let score = 0;
            const na = mol.numAtoms;
            let mx = WebMolKit.MolUtil.arrayAtomX(mol), my = WebMolKit.MolUtil.arrayAtomY(mol);
            for (let i = 0; i < na - 1; i++)
                for (let j = i + 1; j < na; j++)
                    score += 1.0 / (approach + WebMolKit.norm2_xy(mx[i] - mx[j], my[i] - my[j]));
            return score;
        }
        static translateMolecule(mol, ox, oy) {
            for (let n = 1; n <= mol.numAtoms; n++)
                mol.setAtomPos(n, mol.atomX(n) + ox, mol.atomY(n) + oy);
        }
        static rotateMolecule(mol, theta, cx, cy) {
            if (cx == null || cy == null) {
                let box = mol.boundary();
                cx = box.midX();
                cy = box.midY();
            }
            let cosTheta = Math.cos(theta), sinTheta = Math.sin(theta);
            for (let n = 1; n <= mol.numAtoms; n++) {
                let x = mol.atomX(n) - cx, y = mol.atomY(n) - cy;
                mol.setAtomPos(n, cx + x * cosTheta - y * sinTheta, cy + x * sinTheta + y * cosTheta);
            }
        }
        static rotateBond(mol, centre, atom, theta) {
            theta = WebMolKit.angleNorm(theta);
            if (Math.abs(theta) < 0.1 * WebMolKit.DEGRAD)
                return;
            let g = WebMolKit.Graph.fromMolecule(mol);
            g.isolateNode(centre - 1);
            let cc = g.calculateComponents();
            let cx = mol.atomX(centre), cy = mol.atomY(centre);
            let cosTheta = Math.cos(theta), sinTheta = Math.sin(theta);
            for (let n = 1; n <= mol.numAtoms; n++)
                if (cc[n - 1] == cc[atom - 1]) {
                    let x = mol.atomX(n) - cx, y = mol.atomY(n) - cy;
                    mol.setAtomPos(n, cx + x * cosTheta - y * sinTheta, cy + x * sinTheta + y * cosTheta);
                }
        }
        static rotateAtoms(mol, mask, cx, cy, theta) {
            let cosTheta = Math.cos(theta), sinTheta = Math.sin(theta);
            for (let n = 1; n <= mol.numAtoms; n++)
                if (mask[n - 1]) {
                    let x = mol.atomX(n) - cx, y = mol.atomY(n) - cy;
                    mol.setAtomPos(n, cx + x * cosTheta - y * sinTheta, cy + x * sinTheta + y * cosTheta);
                }
        }
        static angleNeighbours(mol, atom) {
            let adj = mol.atomAdjList(atom);
            if (adj.length <= 1)
                return null;
            let th = [];
            for (let n = 0; n < adj.length; n++)
                th.push(Math.atan2(mol.atomY(adj[n]) - mol.atomY(atom), mol.atomX(adj[n]) - mol.atomX(atom)));
            if (adj.length == 2) {
                if (WebMolKit.angleDiff(th[1], th[0]) > 0)
                    return adj;
                return [adj[1], adj[0]];
            }
            let idx = WebMolKit.Vec.idxSort(th);
            return WebMolKit.Vec.idxGet(adj, idx);
        }
        static mergeAtoms(mol, oldN, newN) {
            for (let n = 1; n <= mol.numBonds; n++) {
                if (mol.bondFrom(n) == oldN)
                    mol.setBondFrom(n, newN);
                if (mol.bondTo(n) == oldN)
                    mol.setBondTo(n, newN);
            }
            mol.deleteAtomAndBonds(oldN);
        }
        static normaliseBondDistances(mol) {
            const nb = mol.numBonds;
            if (nb == 0)
                return;
            let dsq = [];
            for (let n = 1; n <= nb; n++) {
                let bfr = mol.bondFrom(n), bto = mol.bondTo(n);
                dsq.push(WebMolKit.norm2_xy(mol.atomX(bto) - mol.atomX(bfr), mol.atomY(bto) - mol.atomY(bfr)));
            }
            WebMolKit.Vec.sort(dsq);
            let median = (nb & 1) == 1 ? Math.sqrt(dsq[nb >> 1]) : 0.5 * (Math.sqrt(dsq[nb >> 1]) + Math.sqrt(dsq[(nb >> 1) - 1]));
            if (median < 0.1 || (median > WebMolKit.Molecule.IDEALBOND * 0.9 && median < WebMolKit.Molecule.IDEALBOND * 1.1))
                return;
            let box = mol.boundary();
            let cx = box.midX(), cy = box.midY();
            let scale = WebMolKit.Molecule.IDEALBOND / median;
            for (let n = mol.numAtoms; n >= 1; n--) {
                let x = (mol.atomX(n) - cx) * scale + cx;
                let y = (mol.atomY(n) - cy) * scale + cy;
                mol.setAtomPos(n, x, y);
            }
        }
        static mirrorImage(mol) {
            mol = mol.clone();
            for (let n = 1; n <= mol.numAtoms; n++)
                mol.setAtomX(n, -mol.atomX(n));
            for (let n = 1; n <= mol.numBonds; n++) {
                if (mol.bondType(n) == WebMolKit.Molecule.BONDTYPE_DECLINED)
                    mol.setBondType(n, WebMolKit.Molecule.BONDTYPE_INCLINED);
                else if (mol.bondType(n) == WebMolKit.Molecule.BONDTYPE_INCLINED)
                    mol.setBondType(n, WebMolKit.Molecule.BONDTYPE_DECLINED);
            }
            return mol;
        }
        static alignOrientFlip(mol1, idx1, mol2, idx2) {
            if (idx1.length < 2 || idx1.length != idx2.length)
                throw 'Invalid mapping indices.';
            let x0 = mol1.atomX(idx1[0]), y0 = mol1.atomY(idx1[0]);
            CoordUtil.translateMolecule(mol2, x0 - mol2.atomX(idx2[0]), y0 - mol2.atomY(idx2[0]));
            const sz = idx1.length - 1;
            let th1 = [], th2 = [];
            let deltaA = 0, deltaB = 0;
            for (let n = 0; n < sz; n++) {
                th1.push(Math.atan2(mol1.atomY(idx1[n + 1]) - y0, mol1.atomX(idx1[n + 1]) - x0));
                th2.push(Math.atan2(mol2.atomY(idx2[n + 1]) - y0, mol2.atomX(idx2[n + 1]) - x0));
                let dthA = WebMolKit.angleDiff(th1[n], th2[n]), dthB = WebMolKit.angleDiff(th1[n], -th2[n]);
                if (dthA < -175 * WebMolKit.DEGRAD && deltaA > 0)
                    dthA += WebMolKit.TWOPI;
                else if (dthA > 175 * WebMolKit.DEGRAD && deltaA < 0)
                    dthA -= WebMolKit.TWOPI;
                if (dthB < -175 * WebMolKit.DEGRAD && deltaB > 0)
                    dthB += WebMolKit.TWOPI;
                else if (dthB > 175 * WebMolKit.DEGRAD && deltaB < 0)
                    dthB -= WebMolKit.TWOPI;
                deltaA += dthA;
                deltaB += dthB;
            }
            if (sz > 1) {
                let inv = 1.0 / sz;
                deltaA *= inv;
                deltaB *= inv;
            }
            let scoreA = 0, scoreB = 0;
            for (let n = 0; n < sz; n++) {
                scoreA += Math.abs(WebMolKit.angleDiff(th1[n], th2[n] + deltaA));
                scoreB += Math.abs(WebMolKit.angleDiff(th1[n], -th2[n] + deltaB));
            }
            if (scoreB < scoreA) {
                for (let n = 1; n <= mol2.numAtoms; n++)
                    mol2.setAtomY(n, 2 * y0 - mol2.atomY(n));
                for (let n = 1; n <= mol2.numBonds; n++) {
                    if (mol2.bondType(n) == WebMolKit.Molecule.BONDTYPE_DECLINED)
                        mol2.setBondType(n, WebMolKit.Molecule.BONDTYPE_INCLINED);
                    else if (mol2.bondType(n) == WebMolKit.Molecule.BONDTYPE_INCLINED)
                        mol2.setBondType(n, WebMolKit.Molecule.BONDTYPE_DECLINED);
                }
                CoordUtil.rotateMolecule(mol2, x0, y0, deltaB);
            }
            else
                CoordUtil.rotateMolecule(mol2, x0, y0, deltaA);
        }
    }
    CoordUtil.OVERLAP_THRESHOLD = 0.2;
    CoordUtil.OVERLAP_THRESHOLD_SQ = CoordUtil.OVERLAP_THRESHOLD * CoordUtil.OVERLAP_THRESHOLD;
    CoordUtil.DEFAULT_EQUIV_TOLERANCE = 0.2;
    WebMolKit.CoordUtil = CoordUtil;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let OpenMolType;
    (function (OpenMolType) {
        OpenMolType[OpenMolType["None"] = 0] = "None";
        OpenMolType[OpenMolType["AtomCount1000"] = 1] = "AtomCount1000";
        OpenMolType[OpenMolType["BondCount1000"] = 2] = "BondCount1000";
        OpenMolType[OpenMolType["InlineAbbreviations"] = 3] = "InlineAbbreviations";
        OpenMolType[OpenMolType["ZeroOrderBonds"] = 4] = "ZeroOrderBonds";
        OpenMolType[OpenMolType["HydrogenCounting"] = 5] = "HydrogenCounting";
        OpenMolType[OpenMolType["MoleculeName"] = 6] = "MoleculeName";
        OpenMolType[OpenMolType["QueryResonance"] = 7] = "QueryResonance";
        OpenMolType[OpenMolType["QueryHCount"] = 8] = "QueryHCount";
    })(OpenMolType = WebMolKit.OpenMolType || (WebMolKit.OpenMolType = {}));
    const OPENMOL_LEVEL_1_1 = [
        OpenMolType.AtomCount1000,
        OpenMolType.BondCount1000,
    ];
    const OPENMOL_LEVEL_1_2 = [
        OpenMolType.InlineAbbreviations,
    ];
    const OPENMOL_LEVEL_1_3 = [
        OpenMolType.ZeroOrderBonds,
        OpenMolType.HydrogenCounting,
    ];
    const OPENMOL_INVALID = [
        OpenMolType.QueryResonance,
        OpenMolType.QueryHCount,
    ];
    class OpenMolSpec {
        constructor() {
            this.level = 1.0;
            this.invalid = false;
            this.notes = [];
        }
        add(type, atoms, bonds, source) {
            this.addNote({ 'type': type, 'atoms': atoms, 'bonds': bonds, 'source': source });
        }
        addNote(note) {
            this.notes.push(note);
            note.level = 1.0;
            if (OPENMOL_LEVEL_1_1.indexOf(note.type) >= 0)
                note.level = 1.1;
            else if (OPENMOL_LEVEL_1_2.indexOf(note.type) >= 0)
                note.level = 1.2;
            else if (OPENMOL_LEVEL_1_3.indexOf(note.type) >= 0)
                note.level = 1.3;
            this.level = Math.max(this.level, note.level);
            this.invalid = this.invalid || OPENMOL_INVALID.indexOf(note.type) >= 0;
        }
        addJoin(type, atoms, bonds, source) {
            for (let note of this.notes)
                if (note.type == type) {
                    if (atoms && note.atoms)
                        note.atoms = note.atoms.concat(atoms);
                    else if (atoms)
                        note.atoms = atoms;
                    if (bonds && note.bonds)
                        note.bonds = note.bonds.concat(bonds);
                    else if (bonds)
                        note.bonds = bonds;
                    if (source && note.source)
                        note.source = note.source.concat(source);
                    else if (source)
                        note.source = source;
                    return;
                }
            this.add(type, atoms, bonds, source);
        }
        derive(mol) {
            if (mol.numAtoms >= 1000)
                this.add(OpenMolType.AtomCount1000);
            if (mol.numBonds >= 1000)
                this.add(OpenMolType.BondCount1000);
        }
    }
    WebMolKit.OpenMolSpec = OpenMolSpec;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    WebMolKit.MDLMOL_VALENCE = {
        'H': [1],
        'B': [3],
        'C': [4],
        'Si': [4],
        'N': [3],
        'P': [3, 5],
        'As': [3, 5],
        'O': [2],
        'S': [2, 4, 6],
        'Se': [2, 4, 6],
        'Te': [2, 4, 6],
        'F': [1],
        'Cl': [1, 3, 5, 7],
        'Br': [1],
        'I': [1, 3, 5, 7],
        'At': [1, 3, 5, 7],
    };
    class MDLMOLReader {
        constructor(strData) {
            this.parseHeader = true;
            this.parseExtended = true;
            this.allowV3000 = true;
            this.considerRescale = true;
            this.relaxed = false;
            this.keepAromatic = false;
            this.keepParity = false;
            this.mol = null;
            this.molName = '';
            this.openmol = new WebMolKit.OpenMolSpec();
            this.atomHyd = null;
            this.resBonds = null;
            this.pos = 0;
            this.lines = strData.split(/\r?\n/);
        }
        parse() {
            if (this.parseHeader) {
                this.molName = this.lines[0];
                if (this.molName) {
                    let src = { 'row': 0, 'col': 0, 'len': this.molName.length };
                    this.openmol.add(WebMolKit.OpenMolType.MoleculeName, null, null, [src]);
                }
                this.pos = 3;
            }
            this.parseCTAB();
            return this.mol;
        }
        nextLine() {
            if (this.pos >= this.lines.length)
                throw 'MDL Molfile parser: premature end, at line ' + (this.pos + 1);
            return this.lines[this.pos++];
        }
        parseCTAB() {
            this.mol = new WebMolKit.Molecule();
            this.mol.keepTransient = true;
            let line = this.nextLine();
            if (!this.relaxed) {
                let version = line.length >= 39 ? line.substring(34, 39) : '';
                if (this.allowV3000 && version == 'V3000') {
                    this.parseV3000();
                    this.openmol.derive(this.mol);
                    return;
                }
                if (version != 'V2000')
                    throw 'Invalid MDL MOL: no Vx000 tag.';
            }
            let numAtoms = parseInt(line.substring(0, 3).trim());
            let numBonds = parseInt(line.substring(3, 6).trim());
            let explicitValence = [];
            for (let n = 0; n < numAtoms; n++) {
                line = this.nextLine();
                if (line.length < 39)
                    throw 'Invalid MDL MOL: atom line' + (n + 1);
                let x = parseFloat(line.substring(0, 10).trim());
                let y = parseFloat(line.substring(10, 20).trim());
                let z = parseFloat(line.substring(20, 30).trim());
                let el = line.substring(31, 34).trim();
                let chg = parseInt(line.substring(36, 39).trim()), rad = 0;
                let stereo = line.length < 42 ? 0 : parseInt(line.substring(39, 42).trim());
                let hyd = line.length < 45 ? 0 : parseInt(line.substring(42, 45).trim());
                let val = line.length < 51 ? 0 : parseInt(line.substring(48, 51).trim());
                let mapnum = line.length < 63 ? 0 : parseInt(line.substring(60, 63).trim());
                if (chg >= 1 && chg <= 3)
                    chg = 4 - chg;
                else if (chg == 4) {
                    chg = 0;
                    rad = 2;
                }
                else if (chg >= 5 && chg <= 7)
                    chg = 4 - chg;
                else
                    chg = 0;
                let a = this.mol.addAtom(el, x, y, chg, rad);
                if (z != 0) {
                    this.mol.setAtomZ(a, z);
                    this.mol.setIs3D(true);
                }
                this.mol.setAtomMapNum(a, mapnum);
                if (hyd > 0) {
                    this.openmol.addJoin(WebMolKit.OpenMolType.QueryHCount, [a]);
                    if (this.atomHyd == null)
                        this.atomHyd = WebMolKit.Vec.numberArray(WebMolKit.Molecule.HEXPLICIT_UNKNOWN, numAtoms);
                    this.atomHyd[n] = hyd - 1;
                }
                if (stereo > 0 && this.keepParity) {
                }
                explicitValence.push(val);
            }
            for (let n = 0; n < numBonds; n++) {
                line = this.nextLine();
                if (line.length < 12)
                    throw 'Invalid MDL MOL: bond line' + (n + 1);
                let bfr = parseInt(line.substring(0, 3).trim()), bto = parseInt(line.substring(3, 6).trim());
                let type = parseInt(line.substring(6, 9).trim()), stereo = parseInt(line.substring(9, 12).trim());
                if (bfr == bto || bfr < 1 || bfr > numAtoms || bto < 1 || bto > numAtoms)
                    throw 'Invalid MDL MOL: bond line' + (n + 1);
                let order = type >= 1 && type <= 3 ? type : 1;
                let style = WebMolKit.Molecule.BONDTYPE_NORMAL;
                if (stereo == 1)
                    style = WebMolKit.Molecule.BONDTYPE_INCLINED;
                else if (stereo == 6)
                    style = WebMolKit.Molecule.BONDTYPE_DECLINED;
                else if (stereo == 4)
                    style = WebMolKit.Molecule.BONDTYPE_UNKNOWN;
                let b = this.mol.addBond(bfr, bto, order, style);
                if (type == 4) {
                    let src = { 'row': this.pos - 1, 'col': 6, 'len': 3 };
                    this.openmol.addJoin(WebMolKit.OpenMolType.QueryResonance, null, [b], [src]);
                }
            }
            const MBLK_CHG = 1, MBLK_RAD = 2, MBLK_ISO = 3, MBLK_RGP = 4, MBLK_HYD = 5, MBLK_ZCH = 6, MBLK_ZBO = 7, MBLK_ZPA = 8, MBLK_ZRI = 9, MBLK_ZAR = 10;
            let resPaths = new Map(), resRings = new Map(), arenes = new Map();
            while (true) {
                line = this.nextLine();
                if (line.startsWith('M  END'))
                    break;
                let type = 0;
                if (line.startsWith('M  CHG'))
                    type = MBLK_CHG;
                else if (line.startsWith('M  RAD'))
                    type = MBLK_RAD;
                else if (line.startsWith('M  ISO'))
                    type = MBLK_ISO;
                else if (line.startsWith('M  RGP'))
                    type = MBLK_RGP;
                else if (this.parseExtended && line.startsWith('M  HYD'))
                    type = MBLK_HYD;
                else if (this.parseExtended && line.startsWith('M  ZCH'))
                    type = MBLK_ZCH;
                else if (this.parseExtended && line.startsWith('M  ZBO'))
                    type = MBLK_ZBO;
                else if (this.parseExtended && line.startsWith('M  ZPA'))
                    type = MBLK_ZPA;
                else if (this.parseExtended && line.startsWith('M  ZRI'))
                    type = MBLK_ZRI;
                else if (this.parseExtended && line.startsWith('M  ZAR'))
                    type = MBLK_ZAR;
                else if (line.startsWith('A  ') && line.length >= 6) {
                    let anum = parseInt(line.substring(3, 6).trim());
                    if (anum >= 1 && anum <= this.mol.numAtoms) {
                        line = this.nextLine();
                        if (line == null)
                            break;
                        this.mol.setAtomElement(anum, line);
                        continue;
                    }
                }
                if (type == MBLK_ZPA || type == MBLK_ZRI || type == MBLK_ZAR) {
                    let len = parseInt(line.substring(6, 9).trim()), blk = parseInt(line.substring(9, 13).trim());
                    let map = type == MBLK_ZPA ? resPaths : type == MBLK_ZRI ? resRings : arenes;
                    for (let n = 0; n < len; n++) {
                        let val = parseInt(line.substring(13 + 4 * n, 17 + 4 * n).trim());
                        if (val < 1 || val > numAtoms)
                            throw 'Invalid MDL MOL: M-block';
                        let atoms = map.get(blk);
                        if (!atoms)
                            map.set(blk, atoms = []);
                        atoms.push(val);
                    }
                }
                else if (type > 0) {
                    let len = parseInt(line.substring(6, 9).trim());
                    for (let n = 0; n < len; n++) {
                        let pos = parseInt(line.substring(9 + 8 * n, 13 + 8 * n).trim());
                        let val = parseInt(line.substring(13 + 8 * n, 17 + 8 * n).trim());
                        if (pos < 1)
                            throw 'Invalid MDL MOL: M-block';
                        if (type == MBLK_CHG)
                            this.mol.setAtomCharge(pos, val);
                        else if (type == MBLK_RAD)
                            this.mol.setAtomUnpaired(pos, val);
                        else if (type == MBLK_ISO)
                            this.mol.setAtomIsotope(pos, val);
                        else if (type == MBLK_RGP)
                            this.mol.setAtomElement(pos, "R" + val);
                        else if (type == MBLK_HYD) {
                            this.mol.setAtomHExplicit(pos, val);
                            let src = { 'row': this.pos - 1, 'col': 9 + 8 * n, 'len': 8 };
                            this.openmol.addJoin(WebMolKit.OpenMolType.HydrogenCounting, [pos], null, [src]);
                        }
                        else if (type == MBLK_ZCH)
                            this.mol.setAtomCharge(pos, val);
                        else if (type == MBLK_ZBO) {
                            this.mol.setBondOrder(pos, val);
                            let src = { 'row': this.pos - 1, 'col': 9 + 8 * n, 'len': 8 };
                            this.openmol.addJoin(WebMolKit.OpenMolType.ZeroOrderBonds, null, [pos], [src]);
                        }
                    }
                }
            }
            this.postFix(explicitValence);
            if (this.parseExtended) {
                let artifacts = new WebMolKit.BondArtifact(this.mol);
                for (let atoms of resPaths.values())
                    artifacts.createPath(atoms);
                for (let atoms of resRings.values())
                    artifacts.createRing(atoms);
                for (let atoms of arenes.values())
                    artifacts.createArene(atoms);
                artifacts.rewriteMolecule();
            }
            this.openmol.derive(this.mol);
        }
        postFix(explicitValence) {
            const mol = this.mol;
            for (let n = 1; n <= mol.numAtoms; n++) {
                let el = mol.atomElement(n);
                if (el == 'D') {
                    mol.setAtomElement(n, 'H');
                    mol.setAtomIsotope(n, 2);
                }
                else if (el == 'T') {
                    mol.setAtomElement(n, 'H');
                    mol.setAtomIsotope(n, 3);
                }
                let valence = explicitValence[n - 1], options = WebMolKit.MDLMOL_VALENCE[el];
                if (valence != 0) {
                    let hcount = valence < 0 || valence > 14 ? 0 : valence;
                    for (let b of mol.atomAdjBonds(n))
                        hcount -= mol.bondOrder(b);
                    if (hcount != mol.atomHydrogens(n))
                        mol.setAtomHExplicit(n, hcount);
                }
                else if (options) {
                    let chg = mol.atomCharge(n);
                    let chgmod = (el == 'C' || el == 'H') ? Math.abs(chg) : el == 'B' ? -Math.abs(chg) : -chg;
                    let usedValence = chgmod + mol.atomUnpaired(n);
                    for (let b of mol.atomAdjBonds(n))
                        usedValence += mol.bondOrder(b);
                    for (let v of options)
                        if (usedValence <= v) {
                            let hcount = v - usedValence;
                            if (hcount != mol.atomHydrogens(n))
                                mol.setAtomHExplicit(n, hcount);
                            break;
                        }
                }
            }
            if (this.considerRescale)
                WebMolKit.CoordUtil.normaliseBondDistances(mol);
            mol.keepTransient = false;
        }
        parseV3000() {
            let inCTAB = false, inAtom = false, inBond = false;
            let lineCounts = null;
            let lineAtoms = [], lineBonds = [];
            const ERRPFX = 'Invalid MDL MOL V3000: ';
            while (true) {
                let line = this.nextLine();
                if (line == 'M  END')
                    break;
                if (!line.startsWith('M  V30 '))
                    continue;
                line = line.substring(7);
                if (line.startsWith('COUNTS '))
                    lineCounts = line.substring(7);
                else if (line.startsWith('BEGIN CTAB'))
                    inCTAB = true;
                else if (line.startsWith('END CTAB'))
                    inCTAB = false;
                else if (line.startsWith('BEGIN ATOM'))
                    inAtom = true;
                else if (line.startsWith('END ATOM'))
                    inAtom = false;
                else if (line.startsWith('BEGIN BOND'))
                    inBond = true;
                else if (line.startsWith('END BOND'))
                    inBond = false;
                else if (inCTAB && inAtom && !inBond)
                    lineAtoms.push(line);
                else if (inCTAB && inBond && !inAtom)
                    lineBonds.push(line);
            }
            let counts = lineCounts.split('\\s+');
            if (counts.length < 2)
                throw ERRPFX + 'counts line malformatted';
            let numAtoms = parseInt(counts[0]), numBonds = parseInt(counts[1]);
            if (numAtoms < 0 || numAtoms > lineAtoms.length)
                throw ERRPFX + 'unreasonable atom count: ' + numAtoms;
            if (numBonds < 0 || numBonds > lineBonds.length)
                throw ERRPFX + 'unreasonable bond count: ' + numBonds;
            let atomBits = [], bondBits = [];
            for (let n = 0; n < lineAtoms.length; n++) {
                let line = lineAtoms[n];
                while (n < lineAtoms.length - 1 && line.endsWith('-')) {
                    n++;
                    line = line.substring(0, line.length - 1) + lineAtoms[n];
                }
                let bits = this.splitWithQuotes(line);
                if (bits.length < 6)
                    throw ERRPFX + 'atom line has too few components: ' + line;
                let idx = parseInt(bits[0], 0);
                if (idx < 1 || idx > numAtoms)
                    throw ERRPFX + 'invalid atom index: ' + bits[0];
                if (atomBits[idx - 1] != null)
                    throw ERRPFX + 'duplicate atom index: ' + idx;
                atomBits[idx - 1] = bits;
            }
            for (let n = 0; n < lineBonds.length; n++) {
                let line = lineBonds[n];
                while (n < lineBonds.length - 1 && line.endsWith('-')) {
                    n++;
                    line = line.substring(0, line.length - 1) + lineBonds[n];
                }
                let bits = this.splitWithQuotes(line);
                if (bits.length < 4)
                    throw ERRPFX + 'bond line has too few components: ' + line;
                let idx = parseInt(bits[0], 0);
                if (idx < 1 || idx > numBonds)
                    throw ERRPFX + 'invalid bond index: ' + bits[0];
                if (bondBits[idx - 1] != null)
                    throw ERRPFX + 'duplicate bond index: ' + idx;
                bondBits[idx - 1] = bits;
            }
            let explicitValence = WebMolKit.Vec.numberArray(0, numAtoms);
            for (let n = 1; n <= numAtoms; n++) {
                let bits = atomBits[n - 1];
                if (bits == null)
                    throw ERRPFX + 'atom definition missing for #' + n;
                let type = bits[1];
                let x = parseFloat(bits[2]), y = parseFloat(bits[3]), z = parseFloat(bits[4]);
                let map = parseInt(bits[5]);
                this.mol.addAtom(type, x, y);
                this.mol.setAtomMapNum(n, map);
                for (let i = 6; i < bits.length; i++) {
                    let eq = bits[i].indexOf('=');
                    if (eq < 0)
                        continue;
                    let key = bits[i].substring(0, eq), val = bits[i].substring(eq + 1);
                    if (key == 'CHG')
                        this.mol.setAtomCharge(n, parseInt(val));
                    else if (key == 'RAD')
                        this.mol.setAtomUnpaired(n, parseInt(val));
                    else if (key == 'MASS')
                        this.mol.setAtomIsotope(n, parseInt(val));
                    else if (key == 'CFG') {
                        let stereo = parseInt(val);
                        if (stereo > 0 && this.keepParity) {
                        }
                    }
                    else if (key == 'VAL')
                        explicitValence[n - 1] = parseInt(val);
                }
            }
            for (let n = 1; n <= numBonds; n++) {
                let bits = bondBits[n - 1];
                if (bits == null)
                    throw ERRPFX + 'bond definition missing for #' + n;
                let type = parseInt(bits[1]), bfr = parseInt(bits[2]), bto = parseInt(bits[3]);
                let order = type >= 1 && type <= 3 ? type : 1;
                this.mol.addBond(bfr, bto, order);
                if (type == 4) {
                }
                for (let i = 4; i < bits.length; i++) {
                    let eq = bits[i].indexOf('=');
                    if (eq < 0)
                        continue;
                    let key = bits[i].substring(0, eq), val = bits[i].substring(eq + 1);
                    if (key == 'CFG') {
                        let dir = parseInt(val);
                        this.mol.setBondType(n, dir == 1 ? WebMolKit.Molecule.BONDTYPE_INCLINED :
                            dir == 2 ? WebMolKit.Molecule.BONDTYPE_UNKNOWN :
                                dir == 3 ? WebMolKit.Molecule.BONDTYPE_DECLINED : WebMolKit.Molecule.BONDTYPE_NORMAL);
                    }
                }
            }
            this.postFix(explicitValence);
        }
        splitWithQuotes(line) {
            return line.split('\\s+');
        }
    }
    WebMolKit.MDLMOLReader = MDLMOLReader;
    class MDLSDFReader {
        constructor(strData) {
            this.ds = new WebMolKit.DataSheet();
            this.upcastColumns = true;
            this.pos = 0;
            this.lines = strData.split(/\r?\n/);
        }
        parse() {
            this.parseStream();
            if (this.upcastColumns)
                this.upcastStringColumns();
            return this.ds;
        }
        parseStream() {
            let ds = this.ds;
            ds.appendColumn('Molecule', WebMolKit.DataSheet.COLTYPE_MOLECULE, 'Molecular structure');
            let colName = -1;
            let entry = [];
            while (this.pos < this.lines.length) {
                let line = this.lines[this.pos++];
                if (!line.startsWith('$$$$')) {
                    entry.push(line);
                    continue;
                }
                let rn = ds.appendRow();
                let molstr = '';
                let pos = 0;
                while (pos < entry.length) {
                    line = entry[pos];
                    if (line.startsWith('> '))
                        break;
                    molstr += line + '\n';
                    pos++;
                    if (line.startsWith('M	END'))
                        break;
                }
                let mol = null, name = null;
                try {
                    if (molstr.length > 0) {
                        let mdl = new MDLMOLReader(molstr);
                        mdl.parse();
                        mol = mdl.mol;
                        name = mdl.molName;
                    }
                }
                catch (ex) {
                }
                if (mol != null)
                    ds.setMolecule(rn, 0, mol);
                if (name) {
                    if (colName < 0)
                        colName = ds.appendColumn('Name', WebMolKit.DataSheet.COLTYPE_STRING, 'Molecule name');
                    ds.setString(rn, colName, name);
                }
                if (rn == 0 && mol != null) {
                    let str1 = entry[0], str3 = entry[2];
                    if (str1.length >= 7 && str1.startsWith('$name=')) {
                        ds.changeColumnName(0, str1.substring(6), ds.colDescr(0));
                    }
                    if (str3.length >= 8 && str3.startsWith('$title=')) {
                        ds.setTitle(str3.substring(7));
                    }
                }
                for (; pos + 1 < entry.length; pos += 3) {
                    let key = entry[pos], val = entry[pos + 1];
                    if (!key.startsWith('>'))
                        continue;
                    let z = key.indexOf('<');
                    if (z < 0)
                        continue;
                    key = key.substring(z + 1);
                    z = key.indexOf('>');
                    if (z < 0)
                        continue;
                    key = key.substring(0, z);
                    if (key.length == 0)
                        continue;
                    while (pos + 2 < entry.length && entry[pos + 2].length > 0) {
                        val += '\n' + entry[pos + 2];
                        pos++;
                    }
                    let cn = ds.findColByName(key);
                    if (cn < 0)
                        cn = ds.appendColumn(key, WebMolKit.DataSheet.COLTYPE_STRING, '');
                    if (val.length == 0)
                        ds.setToNull(rn, cn);
                    else
                        ds.setString(rn, cn, val);
                }
                entry = [];
            }
            if (ds.numRows == 0)
                this.ds = null;
        }
        upcastStringColumns() {
            let ds = this.ds;
            for (let i = 0; i < ds.numCols; i++)
                if (ds.colType(i) == WebMolKit.DataSheet.COLTYPE_STRING) {
                    let allnull = true, allreal = true, allint = true, allbool = true;
                    for (let j = 0; j < ds.numRows; j++) {
                        if (!allreal && !allint && !allbool)
                            break;
                        if (ds.isNull(j, i))
                            continue;
                        allnull = false;
                        let val = ds.getString(j, i);
                        if (allbool) {
                            let lc = val.toLowerCase();
                            if (lc != 'true' && lc != 'false')
                                allbool = false;
                        }
                        if (allint) {
                            let int = parseInt(val);
                            if (!isFinite(int) || int != parseFloat(val))
                                allint = false;
                        }
                        if (allreal) {
                            if (!isFinite(parseFloat(val)))
                                allreal = false;
                        }
                    }
                    if (allnull) { }
                    else if (allint)
                        ds.changeColumnType(i, WebMolKit.DataSheet.COLTYPE_INTEGER);
                    else if (allreal)
                        ds.changeColumnType(i, WebMolKit.DataSheet.COLTYPE_REAL);
                    else if (allbool)
                        ds.changeColumnType(i, WebMolKit.DataSheet.COLTYPE_BOOLEAN);
                }
        }
    }
    WebMolKit.MDLSDFReader = MDLSDFReader;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    WebMolKit.BONDARTIFACT_EXTRA_RESPATH = 'xRESPATH:';
    WebMolKit.BONDARTIFACT_EXTRA_RESRING = 'xRESRING:';
    WebMolKit.BONDARTIFACT_EXTRA_ARENE = 'xARENE:';
    class BondArtifact {
        constructor(mol) {
            this.mol = mol;
            this.resPaths = new Map();
            this.resRings = new Map();
            this.arenes = new Map();
            for (let n = 1; n <= this.mol.numAtoms; n++) {
                for (let str of this.mol.atomExtra(n)) {
                    if (str.startsWith(WebMolKit.BONDARTIFACT_EXTRA_RESPATH))
                        this.appendResPath(n, str.substring(WebMolKit.BONDARTIFACT_EXTRA_RESPATH.length).split(':'));
                    else if (str.startsWith(WebMolKit.BONDARTIFACT_EXTRA_RESRING))
                        this.appendResRing(n, str.substring(WebMolKit.BONDARTIFACT_EXTRA_RESRING.length).split(':'));
                    else if (str.startsWith(WebMolKit.BONDARTIFACT_EXTRA_ARENE))
                        this.appendArene(n, str.substring(WebMolKit.BONDARTIFACT_EXTRA_ARENE.length).split(':'));
                }
            }
            for (let [blk, res] of this.resPaths.entries()) {
                res.atoms = this.pack(res.atoms);
                if (!this.pathify(res.atoms, false))
                    this.resPaths.delete(blk);
            }
            for (let [blk, res] of this.resRings.entries()) {
                res.atoms = this.pack(res.atoms);
                if (!this.pathify(res.atoms, true))
                    this.resRings.delete(blk);
            }
            for (let [blk, res] of this.arenes.entries()) {
                res.atoms = this.pack(res.atoms);
                if (res.atoms.length > 1)
                    res.centre = res.atoms.shift();
                if (!this.pathify(res.atoms, false))
                    this.arenes.delete(blk);
            }
        }
        getPathBlocks() { return Array.from(this.resPaths.keys()); }
        getRingBlocks() { return Array.from(this.resRings.keys()); }
        getAreneBlocks() { return Array.from(this.arenes.keys()); }
        getResPaths() { return Array.from(this.resPaths.values()); }
        getResRings() { return Array.from(this.resRings.values()); }
        getArenes() { return Array.from(this.arenes.values()); }
        rewriteMolecule() {
            const mol = this.mol;
            for (let n = 1; n <= mol.numAtoms; n++) {
                var extra = mol.atomExtra(n), modified = false;
                for (let i = extra.length - 1; i >= 0; i--) {
                    if (extra[i].startsWith(WebMolKit.BONDARTIFACT_EXTRA_RESPATH) || extra[i].startsWith(WebMolKit.BONDARTIFACT_EXTRA_RESRING) || extra[i].startsWith(WebMolKit.BONDARTIFACT_EXTRA_ARENE)) {
                        extra.splice(i);
                        modified = true;
                    }
                }
                if (modified)
                    mol.setAtomExtra(n, extra);
            }
            for (let [blk, path] of this.resPaths.entries()) {
                for (let n = 0; n < path.atoms.length; n++) {
                    let extra = mol.atomExtra(path.atoms[n]);
                    extra.push(WebMolKit.BONDARTIFACT_EXTRA_RESPATH + blk + ':' + (n + 1));
                    mol.setAtomExtra(path.atoms[n], extra);
                }
            }
            for (let [blk, ring] of this.resRings.entries()) {
                for (let n = 0; n < ring.atoms.length; n++) {
                    let extra = mol.atomExtra(ring.atoms[n]);
                    extra.push(WebMolKit.BONDARTIFACT_EXTRA_RESRING + blk + ':' + (n + 1));
                    mol.setAtomExtra(ring.atoms[n], extra);
                }
            }
            for (let [blk, arene] of this.arenes.entries()) {
                for (let n = -1; n < arene.atoms.length; n++) {
                    let atom = n < 0 ? arene.centre : arene.atoms[n];
                    let extra = mol.atomExtra(atom);
                    extra.push(WebMolKit.BONDARTIFACT_EXTRA_ARENE + blk + ':' + (n + 2));
                    mol.setAtomExtra(atom, extra);
                }
            }
        }
        harmoniseNumbering(other) {
            let blocks = other.getPathBlocks();
            let stashPaths = this.getResPaths();
            this.resPaths.clear();
            for (let path of stashPaths) {
                let blk = this.nextIdentifier(blocks);
                this.resPaths.set(blk, path);
                blocks.push(blk);
            }
            blocks = other.getRingBlocks();
            let stashRings = this.getResRings();
            this.resRings.clear();
            for (let ring of stashRings) {
                let blk = this.nextIdentifier(blocks);
                this.resRings.set(blk, ring);
                blocks.push(blk);
            }
            blocks = other.getAreneBlocks();
            let stashArenes = this.getArenes();
            this.arenes.clear();
            for (let arene of stashArenes) {
                let blk = this.nextIdentifier(blocks);
                this.arenes.set(blk, arene);
                blocks.push(blk);
            }
        }
        createPath(atoms) {
            if (this.alreadyExists(atoms))
                return false;
            let path = this.atomsAsPath(atoms);
            if (path) {
                let id = this.nextIdentifier(Array.from(this.resPaths.keys()));
                this.resPaths.set(id, path);
                return true;
            }
            return false;
        }
        createRing(atoms) {
            if (this.alreadyExists(atoms))
                return false;
            let ring = this.atomsAsRing(atoms);
            if (ring) {
                let id = this.nextIdentifier(Array.from(this.resRings.keys()));
                this.resRings.set(id, ring);
                return true;
            }
            return false;
        }
        createArene(atoms) {
            if (this.alreadyExists(atoms))
                return false;
            let arene = this.atomsAsArene(atoms);
            if (arene) {
                let id = this.nextIdentifier(Array.from(this.arenes.keys()));
                this.arenes.set(id, arene);
                return true;
            }
            return false;
        }
        removeArtifact(atoms) {
            let type = 0, pick = 0, overlap = 0;
            for (let [blk, path] of this.resPaths.entries()) {
                let count = 0;
                for (let a of path.atoms)
                    if (atoms.indexOf(a) >= 0)
                        count++;
                if (count > overlap) {
                    type = 1;
                    pick = blk;
                    overlap = count;
                }
            }
            for (let [blk, ring] of this.resRings.entries()) {
                let count = 0;
                for (let a of ring.atoms)
                    if (atoms.indexOf(a) >= 0)
                        count++;
                if (count > overlap) {
                    type = 2;
                    pick = blk;
                    overlap = count;
                }
            }
            for (let [blk, arene] of this.arenes.entries()) {
                let count = atoms.indexOf(arene.centre) >= 0 ? 1 : 0;
                for (let a of arene.atoms)
                    if (atoms.indexOf(a) >= 0)
                        count++;
                if (count > overlap) {
                    type = 3;
                    pick = blk;
                    overlap = count;
                }
            }
            if (type == 0)
                return false;
            else if (type == 1)
                this.resPaths.delete(pick);
            else if (type == 2)
                this.resRings.delete(pick);
            else if (type == 3)
                this.arenes.delete(pick);
            return true;
        }
        appendResPath(atom, bits) {
            let blk = WebMolKit.safeInt(bits[0], 0);
            if (blk <= 0)
                return;
            let res = this.resPaths.get(blk);
            if (res == null)
                this.resPaths.set(blk, res = { 'atoms': WebMolKit.Vec.numberArray(0, this.mol.numAtoms) });
            let idx = bits.length >= 2 ? WebMolKit.safeInt(bits[1], 0) : 0;
            if (res.atoms.indexOf(atom) >= 0)
                return;
            if (idx >= 1 && idx <= this.mol.numAtoms)
                res.atoms[idx - 1] = atom;
            else
                res.atoms.push(atom);
        }
        appendResRing(atom, bits) {
            let blk = WebMolKit.safeInt(bits[0], 0);
            if (blk <= 0)
                return;
            let res = this.resRings.get(blk);
            if (res == null)
                this.resRings.set(blk, res = { 'atoms': WebMolKit.Vec.numberArray(0, this.mol.numAtoms) });
            let idx = bits.length >= 2 ? WebMolKit.safeInt(bits[1], 0) : 0;
            if (res.atoms.indexOf(atom) >= 0)
                return;
            if (idx >= 1 && idx <= this.mol.numAtoms)
                res.atoms[idx - 1] = atom;
            else
                res.atoms.push(atom);
        }
        appendArene(atom, bits) {
            let blk = WebMolKit.safeInt(bits[0], 0);
            if (blk <= 0)
                return;
            let res = this.arenes.get(blk);
            if (res == null)
                this.arenes.set(blk, res = { 'centre': 0, 'atoms': WebMolKit.Vec.numberArray(0, this.mol.numAtoms) });
            let idx = bits.length >= 2 ? WebMolKit.safeInt(bits[1], 0) : 0;
            if (res.atoms.indexOf(atom) >= 0)
                return;
            if (idx >= 1 && idx <= this.mol.numAtoms)
                res.atoms[idx - 1] = atom;
            else
                res.atoms.push(atom);
        }
        pack(arr) {
            let ret = [];
            for (let v of arr)
                if (v != 0)
                    ret.push(v);
            return ret;
        }
        pathify(atoms, requireRing) {
            let sz = atoms.length;
            if (sz < 2)
                return false;
            let g = WebMolKit.Graph.fromMolecule(this.mol);
            for (let n = 0; n < this.mol.numAtoms; n++)
                g.setIndex(n, n + 1);
            g = g.subgraphIndex(WebMolKit.Vec.add(atoms, -1));
            let pos = 0;
            for (let n = 1; n < sz; n++)
                if (g.numEdges(n) < g.numEdges(pos))
                    pos = n;
            WebMolKit.Vec.setTo(atoms, -1);
            for (let n = 0; n < sz; n++) {
                atoms[n] = pos;
                if (n == sz - 1) {
                    if (requireRing)
                        if (g.getEdges(pos).indexOf(atoms[0]) < 0)
                            return false;
                }
                else {
                    let next = sz;
                    for (let i of g.getEdges(pos))
                        if (atoms.indexOf(i) < 0 && i < next)
                            next = i;
                    if (next == sz)
                        return false;
                    pos = next;
                }
            }
            for (let n = 0; n < sz; n++)
                atoms[n] = g.getIndex(atoms[n]);
            return true;
        }
        alreadyExists(atoms) {
            atoms = WebMolKit.Vec.sorted(atoms);
            for (let path of this.resPaths.values()) {
                if (WebMolKit.Vec.equals(atoms, WebMolKit.Vec.sorted(path.atoms)))
                    return true;
            }
            for (let ring of this.resRings.values()) {
                if (WebMolKit.Vec.equals(atoms, WebMolKit.Vec.sorted(ring.atoms)))
                    return true;
            }
            for (let arene of this.arenes.values()) {
                let areneAtoms = WebMolKit.Vec.append(arene.atoms, arene.centre);
                if (WebMolKit.Vec.equals(atoms, WebMolKit.Vec.sorted(areneAtoms)))
                    return true;
            }
            return false;
        }
        atomsAsPath(atoms) {
            if (atoms.length < 2)
                return null;
            let path = { 'atoms': atoms };
            if (!this.pathify(path.atoms, false))
                return null;
            return path;
        }
        atomsAsRing(atoms) {
            if (atoms.length < 3)
                return null;
            let ring = { 'atoms': atoms };
            if (!this.pathify(ring.atoms, true))
                return null;
            return ring;
        }
        atomsAsArene(atoms) {
            const sz = atoms.length;
            if (sz < 3)
                return null;
            let g = WebMolKit.Graph.fromMolecule(this.mol).subgraphIndex(WebMolKit.Vec.add(atoms, -1));
            let best = 0;
            if (sz == 3) {
                let bsum = [0, 0, 0];
                for (let n = 0; n < sz; n++) {
                    if (g.numEdges(n) != 2)
                        return null;
                    for (let e of g.getEdges(n))
                        bsum[n] += this.mol.bondOrder(this.mol.findBond(atoms[n], atoms[e]));
                    best = WebMolKit.Vec.idxMin(bsum);
                }
            }
            else {
                for (let n = 1; n < sz; n++)
                    if (g.numEdges(n) > g.numEdges(best))
                        best = n;
            }
            let arene = { 'centre': atoms[best], 'atoms': WebMolKit.Vec.remove(atoms, best) };
            if (!this.pathify(arene.atoms, false))
                return null;
            return arene;
        }
        nextIdentifier(inkeys) {
            if (inkeys.length == 0)
                return 1;
            let keys = WebMolKit.Vec.sorted(inkeys);
            for (let n = 0; n < keys.length - 1; n++)
                if (keys[n + 1] != keys[n] + 1)
                    return keys[n] + 1;
            return keys[keys.length - 1] + 1;
        }
    }
    WebMolKit.BondArtifact = BondArtifact;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class MDLMOLWriter {
        constructor(mol) {
            this.mol = mol;
            this.includeHeader = true;
            this.enhancedFields = true;
            this.chargeSeparate = true;
            this.molName = '';
            this.lines = [];
        }
        write() {
            if (this.includeHeader) {
                this.lines.push(this.molName);
                this.lines.push('Generated by WebMolKit');
                this.lines.push('');
                this.writeCTAB();
            }
            return this.lines.join('\n');
        }
        getResult() {
            return this.lines.join('\n');
        }
        writeCTAB() {
            let mol = this.mol;
            for (let n = 1; n <= mol.numAtoms; n++)
                if (WebMolKit.MolUtil.hasAbbrev(mol, n)) {
                    mol = mol.clone();
                    WebMolKit.MolUtil.expandAbbrevs(mol, true);
                    break;
                }
            this.lines.push(this.intrpad(mol.numAtoms, 3) + this.intrpad(mol.numBonds, 3) + '  0  0  0  0  0  0  0  0999 V2000');
            let chgidx = [], chgval = [];
            let radidx = [], radval = [];
            let isoidx = [], isoval = [];
            let rgpidx = [], rgpval = [];
            let hydidx = [], hydval = [];
            let zchidx = [], zchval = [];
            let zboidx = [], zboval = [];
            for (let n = 1; n <= mol.numAtoms; n++) {
                let x = mol.atomX(n), y = mol.atomY(n), z = 0;
                let line = this.rpad(x.toFixed(4), 10) + this.rpad(y.toFixed(4), 10) + this.rpad(z.toFixed(4), 10);
                let el = mol.atomElement(n);
                let str = el;
                if (str.length > 3)
                    str = str.substring(0, 3);
                if (str.length > 1 && str.charAt(0) == 'R' && str.charAt(1) >= '0' && str.charAt(1) <= '9') {
                    rgpidx.push(n);
                    rgpval.push(parseInt(str.substring(1)));
                    str = 'R#';
                }
                while (str.length < 4)
                    str += ' ';
                line += ' ' + str + '0';
                let chg = mol.atomCharge(n), rad = mol.atomUnpaired(n), mapnum = mol.atomMapNum(n);
                if (chg >= -3 && chg <= -1)
                    chg = 4 - chg;
                else if (chg == 0 && rad == 2)
                    chg = 4;
                else if (chg >= 1 && chg <= 3)
                    chg = 4 - chg;
                else
                    chg = 0;
                let val = this.mdlValence(mol, n, 15);
                line += this.intrpad(chg, 3) + '  0  0  0' + this.intrpad(val, 3) + '  0  0  0' + this.intrpad(mapnum, 3) + '  0  0';
                this.lines.push(line);
                if (mol.atomCharge(n) != 0) {
                    chgidx.push(n);
                    chgval.push(mol.atomCharge(n));
                }
                if (this.enhancedFields) {
                    if (mol.atomHExplicit(n) != WebMolKit.Molecule.HEXPLICIT_UNKNOWN) {
                        hydidx.push(n);
                        hydval.push(mol.atomHExplicit(n));
                    }
                }
                if (mol.atomUnpaired(n) != 0) {
                    radidx.push(n);
                    radval.push(mol.atomUnpaired(n));
                }
                if (mol.atomIsotope(n) != WebMolKit.Molecule.ISOTOPE_NATURAL) {
                    isoidx.push(n);
                    isoval.push(mol.atomIsotope(n));
                }
            }
            for (let n = 1; n <= mol.numBonds; n++) {
                let order = mol.bondOrder(n), type = Math.max(1, Math.min(3, order));
                let stereo = mol.bondType(n);
                if (stereo == WebMolKit.Molecule.BONDTYPE_NORMAL) { }
                else if (stereo == WebMolKit.Molecule.BONDTYPE_INCLINED) {
                    stereo = 1;
                    type = 1;
                }
                else if (stereo == WebMolKit.Molecule.BONDTYPE_DECLINED) {
                    stereo = 6;
                    type = 1;
                }
                else if (stereo == WebMolKit.Molecule.BONDTYPE_UNKNOWN) {
                    stereo = 4;
                    type = 1;
                }
                else
                    stereo = 0;
                let line = this.intrpad(mol.bondFrom(n), 3) + this.intrpad(mol.bondTo(n), 3) +
                    this.intrpad(type, 3) + this.intrpad(stereo, 3) + '  0  0  0';
                this.lines.push(line);
                if (this.enhancedFields) {
                    if (order < 1 || order > 3) {
                        zboidx.push(n);
                        zboval.push(order);
                    }
                }
            }
            this.writeMBlockPair('CHG', chgidx, chgval);
            this.writeMBlockPair('RAD', radidx, radval);
            this.writeMBlockPair('ISO', isoidx, isoval);
            this.writeMBlockPair('RGP', rgpidx, rgpval);
            this.writeMBlockPair('HYD', hydidx, hydval);
            this.writeMBlockPair('ZCH', zchidx, zchval);
            this.writeMBlockPair('ZBO', zboidx, zboval);
            if (this.enhancedFields) {
                let artifacts = new WebMolKit.BondArtifact(this.mol);
                let idx = 0;
                for (let path of artifacts.getResPaths())
                    this.writeMBlockFlat('ZPA', ++idx, path.atoms);
                for (let ring of artifacts.getResRings())
                    this.writeMBlockFlat('ZRI', ++idx, ring.atoms);
                for (let arene of artifacts.getArenes())
                    this.writeMBlockFlat('ZAR', ++idx, WebMolKit.Vec.prepend(arene.atoms, arene.centre));
            }
            for (let n = 1; n <= mol.numAtoms; n++)
                if (mol.atomElement(n).length > 2) {
                    this.lines.push('A  ' + this.intrpad(n, 3));
                    this.lines.push(mol.atomElement(n));
                }
            this.lines.push('M  END');
        }
        writeMBlockPair(token, idx, val) {
            const sz = idx.length;
            for (let i = 0; i < sz; i += 8) {
                let count = Math.min(8, sz - i);
                let line = "M  " + token + this.intrpad(count, 3);
                for (let j = 0; j < count; j++)
                    line += this.intrpad(idx[i + j], 4) + this.intrpad(val[i + j], 4);
                this.lines.push(line);
            }
        }
        writeMBlockFlat(token, idx, val) {
            const sz = val.length;
            for (let i = 0; i < sz; i += 15) {
                let count = Math.min(15, sz - i);
                let line = "M  " + token + this.intrpad(count, 3);
                line += this.intrpad(idx, 4);
                for (let j = 0; j < count; j++)
                    line += this.intrpad(val[i + j], 4);
                this.lines.push(line);
            }
        }
        intrpad(num, sz) {
            return this.rpad(num.toString(), sz);
        }
        rpad(str, sz) {
            while (str.length < sz)
                str = ' ' + str;
            return str;
        }
        mdlValence(mol, atom, zeroVal) {
            let hyd = mol.atomHydrogens(atom), el = mol.atomElement(atom);
            let options = WebMolKit.MDLMOL_VALENCE[el];
            if (options == null && hyd == 0)
                return 0;
            let chg = mol.atomCharge(atom);
            let chgmod = (el == 'C' || el == 'H') ? Math.abs(chg) : el == 'B' ? -Math.abs(chg) : -chg;
            let bondSum = 0;
            for (let b of mol.atomAdjBonds(atom))
                bondSum += mol.bondOrder(b);
            let nativeVal = chgmod + mol.atomUnpaired(atom) + hyd + bondSum;
            if (options && options[0] == nativeVal)
                return 0;
            let val = nativeVal - chgmod;
            return val <= 0 || val > 14 ? zeroVal : val;
        }
    }
    WebMolKit.MDLMOLWriter = MDLMOLWriter;
    class MDLSDFWriter {
        constructor(ds) {
            this.ds = ds;
            this.lines = [];
        }
        write() {
            let ds = this.ds, lines = this.lines;
            let colMol = this.ds.firstColOfType(WebMolKit.DataSheet.COLTYPE_MOLECULE);
            for (let i = 0; i < ds.numRows; i++) {
                let mol = colMol < 0 ? null : ds.getMolecule(i, colMol);
                if (mol != null) {
                    let molstr = new MDLMOLWriter(mol).write();
                    lines.push(molstr);
                }
                for (let j = 0; j < ds.numCols; j++)
                    if (j != colMol && ds.notNull(i, j)) {
                        let ct = ds.colType(j);
                        let val = '';
                        if (ct == WebMolKit.DataSheet.COLTYPE_STRING)
                            val = ds.getString(i, j);
                        else if (ct == WebMolKit.DataSheet.COLTYPE_INTEGER)
                            val = ds.getInteger(i, j).toString();
                        else if (ct == WebMolKit.DataSheet.COLTYPE_REAL)
                            val = ds.getReal(i, j).toString();
                        else if (ct == WebMolKit.DataSheet.COLTYPE_BOOLEAN)
                            val = ds.getBoolean(i, j) ? 'true' : 'false';
                        if (val != '') {
                            lines.push('> <' + ds.colName(j) + '>');
                            lines.push(val);
                            lines.push('');
                        }
                    }
                lines.push('$$$$');
            }
            return lines.join('\n');
        }
        getResult() {
            return this.lines.join('\n');
        }
    }
    WebMolKit.MDLSDFWriter = MDLSDFWriter;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class MoleculeStream {
        static readUnknown(strData) {
            let mol = MoleculeStream.readNative(strData);
            if (mol)
                return mol;
            try {
                mol = MoleculeStream.readMDLMOL(strData);
            }
            catch (e) { }
            return mol;
        }
        static readNative(strData) {
            let mol = new WebMolKit.Molecule();
            mol.keepTransient = true;
            let lines = strData.split(/\r?\n/);
            if (lines.length < 2)
                return null;
            if (!lines[0].startsWith('SketchEl!') && lines.length >= 4 && lines[3].indexOf('V2000') >= 0) {
                let i = strData.indexOf('SketchEl!');
                if (i < 0)
                    return null;
                lines = strData.substring(i).split(/r?\n/);
            }
            let bits = lines[0].match(/^SketchEl\!\((\d+)\,(\d+)\)/);
            if (!bits)
                return null;
            let numAtoms = parseInt(bits[1]), numBonds = parseInt(bits[2]);
            if (lines.length < 2 + numAtoms + numBonds)
                return null;
            if (!lines[1 + numAtoms + numBonds].match(/^!End/))
                return null;
            for (let n = 0; n < numAtoms; n++) {
                bits = lines[1 + n].split(/[=,;]/);
                let num = mol.addAtom(bits[0], parseFloat(bits[1]), parseFloat(bits[2]), parseInt(bits[3]), parseInt(bits[4]));
                let extra = [], trans = [];
                for (let i = 5; i < bits.length; i++) {
                    let ch = bits[i].charAt(0);
                    if (bits[i].charAt(0) == 'i') { }
                    else if (bits[i].charAt(0) == 'e')
                        mol.setAtomHExplicit(num, parseInt(bits[i].substring(1)));
                    else if (bits[i].charAt(0) == 'm')
                        mol.setAtomIsotope(num, parseInt(bits[i].substring(1)));
                    else if (bits[i].charAt(0) == 'n')
                        mol.setAtomMapNum(num, parseInt(bits[i].substring(1)));
                    else if (bits[i].charAt(0) == 'x')
                        extra.push(MoleculeStream.sk_unescape(bits[i]));
                    else if (bits[i].charAt(0) == 'y')
                        trans.push(MoleculeStream.sk_unescape(bits[i]));
                    else if (bits[i].charAt(0) == 'z') {
                        mol.setAtomZ(num, parseFloat(bits[i].substring(1)));
                        mol.setIs3D(true);
                    }
                    else
                        extra.push(MoleculeStream.sk_unescape(bits[i]));
                }
                mol.setAtomExtra(num, extra);
                mol.setAtomTransient(num, trans);
            }
            for (let n = 0; n < numBonds; n++) {
                bits = lines[1 + numAtoms + n].split(/[-=,]/);
                let num = mol.addBond(parseInt(bits[0]), parseInt(bits[1]), parseInt(bits[2]), parseInt(bits[3]));
                let extra = new Array(), trans = new Array();
                for (let i = 4; i < bits.length; i++) {
                    let ch = bits[i].charAt(0);
                    if (bits[i].charAt(0) == 'x')
                        extra.push(MoleculeStream.sk_unescape(bits[i]));
                    else if (bits[i].charAt(0) == 'y')
                        trans.push(MoleculeStream.sk_unescape(bits[i]));
                    else
                        extra.push(MoleculeStream.sk_unescape(bits[i]));
                }
                mol.setBondExtra(num, extra);
                mol.setBondTransient(num, trans);
            }
            mol.keepTransient = false;
            return mol;
        }
        static writeNative(mol) {
            let ret = 'SketchEl!(' + mol.numAtoms + ',' + mol.numBonds + ')\n';
            for (let n = 1; n <= mol.numAtoms; n++) {
                let el = mol.atomElement(n), x = mol.atomX(n), y = mol.atomY(n), charge = mol.atomCharge(n), unpaired = mol.atomUnpaired(n);
                let hy = mol.atomHExplicit(n) != WebMolKit.Molecule.HEXPLICIT_UNKNOWN ? ('e' + mol.atomHExplicit(n)) : ('i' + mol.atomHydrogens(n));
                ret += MoleculeStream.sk_escape(el) + '=' + x.toFixed(4) + ',' + y.toFixed(4) + ';' + charge + ',' + unpaired + ',' + hy;
                if (mol.is3D())
                    ret += ',z' + mol.atomZ(n);
                if (mol.atomIsotope(n) != WebMolKit.Molecule.ISOTOPE_NATURAL)
                    ret += ',m' + mol.atomIsotope(n);
                if (mol.atomMapNum(n) > 0)
                    ret += ',n' + mol.atomMapNum(n);
                ret += MoleculeStream.sk_encodeExtra(mol.atomExtra(n));
                ret += MoleculeStream.sk_encodeExtra(mol.atomTransient(n));
                ret += '\n';
            }
            for (let n = 1; n <= mol.numBonds; n++) {
                ret += mol.bondFrom(n) + '-' + mol.bondTo(n) + '=' + mol.bondOrder(n) + ',' + mol.bondType(n);
                ret += MoleculeStream.sk_encodeExtra(mol.bondExtra(n));
                ret += MoleculeStream.sk_encodeExtra(mol.bondTransient(n));
                ret += '\n';
            }
            ret += '!End\n';
            return ret;
        }
        static readMDLMOL(strData) {
            let src = new WebMolKit.MDLMOLReader(strData);
            src.parseHeader = true;
            src.parse();
            return src.mol;
        }
        static writeMDLMOL(mol) {
            return new WebMolKit.MDLMOLWriter(mol).write();
        }
        static sk_unescape(str) {
            let ret = '', match;
            while (match = str.match(/^(.*?)\\([0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f])(.*)/)) {
                ret += match[1] + String.fromCharCode(parseInt("0x" + match[2]));
                str = match[3];
            }
            return ret + str;
        }
        static sk_escape(str) {
            let ret = '';
            for (let n = 0; n < str.length; n++) {
                let ch = str.charAt(n), code = str.charCodeAt(n);
                if (code <= 32 || code > 127 || ch == '\\' || ch == ',' || ch == ';' || ch == '=') {
                    let hex = (code & 0xFFFF).toString(16).toUpperCase();
                    ret += '\\';
                    for (let i = 4 - hex.length; i > 0; i--)
                        ret += '0';
                    ret += hex;
                }
                else
                    ret += ch;
            }
            return ret;
        }
        static sk_encodeExtra(extra) {
            let ret = '';
            for (let n = 0; n < extra.length; n++)
                ret += ',' + MoleculeStream.sk_escape(extra[n]);
            return ret;
        }
        ;
    }
    WebMolKit.MoleculeStream = MoleculeStream;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class SARTable extends WebMolKit.Aspect {
        constructor(ds, allowModify) {
            super(ds, allowModify);
            this.setup();
        }
        static isSARTable(ds) {
            for (let n = 0; n < ds.numExtensions; n++)
                if (ds.getExtType(n) == SARTable.CODE)
                    return true;
            return false;
        }
        getFields() {
            for (let n = 0; n < this.ds.numExtensions; n++)
                if (this.ds.getExtType(n) == SARTable.CODE)
                    return this.parseMetaData(this.ds.getExtData(n));
            return null;
        }
        setFields(fields) {
            let content = this.formatMetaData(fields);
            for (let n = 0; n < this.ds.numExtensions; n++)
                if (this.ds.getExtType(n) == SARTable.CODE) {
                    this.ds.setExtData(n, content);
                    return;
                }
            this.ds.appendExtension(SARTable.NAME, SARTable.CODE, content);
        }
        getEntry(row) {
            let fields = this.getFields();
            let entry = {
                'construct': this.ds.getMolecule(row, fields.construct),
                'locked': !!this.ds.getBoolean(row, fields.locked),
                'scaffold': this.ds.getMolecule(row, fields.scaffold),
                'substNames': [],
                'substituents': []
            };
            for (let subst of fields.substituents) {
                entry.substNames.push(subst);
                entry.substituents.push(this.ds.getMolecule(row, subst));
            }
            return entry;
        }
        setEntry(row, entry) {
            let fields = this.getFields();
            let colConstruct = this.ds.findColByName(fields.construct, WebMolKit.DataSheet.COLTYPE_MOLECULE);
            if (colConstruct >= 0)
                this.ds.setMolecule(row, colConstruct, entry.construct);
            let colLocked = this.ds.findColByName(fields.locked, WebMolKit.DataSheet.COLTYPE_BOOLEAN);
            if (colLocked >= 0)
                this.ds.setBoolean(row, colLocked, entry.locked);
            let colScaffold = this.ds.findColByName(fields.scaffold, WebMolKit.DataSheet.COLTYPE_MOLECULE);
            if (colScaffold >= 0)
                this.ds.setMolecule(row, colScaffold, entry.scaffold);
            for (let n = 0; n < fields.substituents.length; n++) {
                let colSubst = this.ds.findColByName(fields.substituents[n], WebMolKit.DataSheet.COLTYPE_MOLECULE);
                if (colSubst >= 0)
                    this.ds.setMolecule(row, colSubst, entry.substituents[n]);
            }
        }
        createSubstituents(tobeAdded) {
            if (tobeAdded.length == 0)
                return;
            let fields = this.getFields();
            let modified = false;
            for (let name of tobeAdded)
                if (fields.substituents.indexOf(name) < 0) {
                    fields.substituents.push(name);
                    this.ds.ensureColumn(name, WebMolKit.DataSheet.COLTYPE_MOLECULE, SARTable.DESCR_SUBSTITUENT);
                    modified = true;
                }
            if (modified)
                this.setFields(fields);
        }
        static isAttachment(mol, atom) {
            return mol.atomicNumber(atom) == 0 && !WebMolKit.MolUtil.hasAbbrev(mol, atom) && mol.atomAdjCount(atom) == 1;
        }
        setup() {
            this.parseAndCorrect();
        }
        parseAndCorrect() {
            let fields = {
                'construct': 'Molecule',
                'locked': 'Molecule_locked',
                'scaffold': 'Scaffold',
                'substituents': [],
                'metadata': []
            };
            let got = false;
            for (let n = 0; n < this.ds.numExtensions; n++)
                if (this.ds.getExtType(n) == SARTable.CODE) {
                    fields = this.parseMetaData(this.ds.getExtData(n));
                    got = true;
                    break;
                }
            this.ds.ensureColumn(fields.construct, WebMolKit.DataSheet.COLTYPE_MOLECULE, SARTable.DESCR_CONSTRUCT);
            this.ds.ensureColumn(fields.locked, WebMolKit.DataSheet.COLTYPE_BOOLEAN, SARTable.DESCR_LOCKED);
            this.ds.ensureColumn(fields.scaffold, WebMolKit.DataSheet.COLTYPE_MOLECULE, SARTable.DESCR_SCAFFOLD);
            for (let subst of fields.substituents)
                this.ds.ensureColumn(subst, WebMolKit.DataSheet.COLTYPE_MOLECULE, SARTable.DESCR_SUBSTITUENT);
            if (!got) {
                let content = this.formatMetaData(fields);
                this.ds.appendExtension(SARTable.NAME, SARTable.CODE, content);
            }
        }
        parseMetaData(content) {
            let fields = { 'construct': null, 'locked': null, 'scaffold': null, 'substituents': [], metadata: [] };
            for (let line of content.split(/\r?\n/)) {
                let pos = line.indexOf('=');
                if (pos < 0)
                    continue;
                let key = line.substring(0, pos), val = line.substring(pos + 1);
                if (key == 'field') {
                    let bits = val.split(',');
                    if (bits.length >= 3) {
                        let type = bits[0], name = WebMolKit.MoleculeStream.sk_unescape(bits[1]);
                        if (type == 'construct') {
                            fields.construct = name;
                            fields.locked = name + '_locked';
                            continue;
                        }
                        else if (type == 'scaffold') {
                            fields.scaffold = name;
                            continue;
                        }
                        else if (type == 'substituent') {
                            fields.substituents.push(name);
                            continue;
                        }
                    }
                }
                fields.metadata.push(line);
            }
            return fields;
        }
        formatMetaData(fields) {
            let content = '';
            content += 'field=construct,' + WebMolKit.MoleculeStream.sk_escape(fields.construct) + ',\n';
            content += 'field=scaffold,' + WebMolKit.MoleculeStream.sk_escape(fields.scaffold) + ',\n';
            for (let subst of fields.substituents)
                content += 'field=substituent,' + WebMolKit.MoleculeStream.sk_escape(subst) + ',\n';
            for (let meta of fields.metadata)
                content += meta + '\n';
            return content;
        }
        plainHeading() { return SARTable.NAME; }
        isColumnReserved(colName) {
            return this.areColumnsReserved([colName])[0];
        }
        areColumnsReserved(colNames) {
            let fields = this.getFields();
            var used = new Set();
            used.add(fields.construct);
            used.add(fields.locked);
            used.add(fields.scaffold);
            for (let subst of fields.substituents)
                used.add(subst);
            let reserved = WebMolKit.Vec.booleanArray(false, colNames.length);
            for (let n = 0; n < colNames.length; n++)
                reserved[n] = used.has(colNames[n]);
            return reserved;
        }
        numGraphicRenderings(row) {
            let fields = this.getFields();
            return 2 + fields.substituents.length;
        }
        produceGraphicRendering(row, idx, policy) {
            let fields = this.getFields(), ds = this.ds;
            if (idx == SARTable.RENDER_CONSTRUCT) {
                let mol = ds.getMolecule(row, fields.construct);
                let metavec = new WebMolKit.MetaVector();
                if (WebMolKit.MolUtil.notBlank(mol)) {
                    let effects = new WebMolKit.RenderEffects();
                    for (let n = 1; n <= mol.numAtoms; n++)
                        if (mol.atomMapNum(n) > 0)
                            effects.colAtom[n] = 0x096E6F;
                    for (let n = 1; n <= mol.numBonds; n++) {
                        let m1 = mol.atomMapNum(mol.bondFrom(n)), m2 = mol.atomMapNum(mol.bondTo(n));
                        if (m1 > 0 && m2 > 0)
                            effects.colBond[n] = 0x096E6F;
                        else if (m1 > 0 || m2 > 0)
                            effects.dottedBondCross[n] = 0x606060;
                    }
                    let measure = new WebMolKit.OutlineMeasurement(0, 0, policy.data.pointScale);
                    let layout = new WebMolKit.ArrangeMolecule(mol, measure, policy, effects);
                    layout.arrange();
                    new WebMolKit.DrawMolecule(layout, metavec).draw();
                }
                else
                    metavec.drawText(0, 0, '?', 15, 0x000000);
                metavec.normalise();
                return [fields.construct, metavec];
            }
            else if (idx == SARTable.RENDER_SCAFFOLD) {
                let mol = ds.getMolecule(row, fields.scaffold);
                let metavec = new WebMolKit.MetaVector();
                if (WebMolKit.MolUtil.notBlank(mol)) {
                    let effects = new WebMolKit.RenderEffects();
                    for (let n = 1; n <= mol.numAtoms; n++)
                        if (SARTable.isAttachment(mol, n)) {
                            let isDefined = false;
                            let el = mol.atomElement(n);
                            outer: for (let colName of fields.substituents) {
                                let subst = ds.getMolecule(row, colName);
                                if (subst != null)
                                    for (let i = 1; i <= subst.numAtoms; i++)
                                        if (subst.atomElement(i) == el || (subst.atomElement(i) == 'R' && el == colName)) {
                                            isDefined = true;
                                            break outer;
                                        }
                            }
                            effects.colAtom[n] = isDefined ? 0x096E6F : 0xFF0000;
                            effects.dottedRectOutline[n] = isDefined ? 0x808080 : 0xFF0000;
                        }
                    let measure = new WebMolKit.OutlineMeasurement(0, 0, policy.data.pointScale);
                    let layout = new WebMolKit.ArrangeMolecule(mol, measure, policy, effects);
                    layout.arrange();
                    new WebMolKit.DrawMolecule(layout, metavec).draw();
                }
                else
                    metavec.drawText(0, 0, '?', 15, 0x000000);
                metavec.normalise();
                return [fields.scaffold, metavec];
            }
            else if (idx >= SARTable.RENDER_SUBSTITUENT && idx < SARTable.RENDER_SUBSTITUENT + fields.substituents.length) {
                let sidx = idx - SARTable.RENDER_SUBSTITUENT, sname = fields.substituents[sidx];
                let mol = ds.getMolecule(row, sname);
                let metavec = new WebMolKit.MetaVector();
                if (WebMolKit.MolUtil.notBlank(mol)) {
                    let effects = new WebMolKit.RenderEffects();
                    for (let n = 1; n <= mol.numAtoms; n++)
                        if (SARTable.isAttachment(mol, n)) {
                            effects.colAtom[n] = 0x096E6F;
                            effects.dottedRectOutline[n] = 0x808080;
                        }
                    let measure = new WebMolKit.OutlineMeasurement(0, 0, policy.data.pointScale);
                    let layout = new WebMolKit.ArrangeMolecule(mol, measure, policy, effects);
                    layout.arrange();
                    new WebMolKit.DrawMolecule(layout, metavec).draw();
                }
                else {
                    let txt = '?';
                    let scaff = ds.getMolecule(row, fields.scaffold);
                    if (WebMolKit.MolUtil.notBlank(scaff)) {
                        txt = 'n/a';
                        for (let n = 1; n <= scaff.numAtoms; n++)
                            if (scaff.atomElement(n) == sname) {
                                txt = '?';
                                break;
                            }
                        if (txt == '?')
                            for (let n = 0; n < fields.substituents.length; n++)
                                if (n != sidx) {
                                    let subst = ds.getMolecule(row, fields.substituents[n]);
                                    if (WebMolKit.MolUtil.notBlank(subst)) {
                                        for (let i = 1; i <= subst.numAtoms; i++)
                                            if (subst.atomElement(i) == sname) {
                                                txt = 'n/a';
                                                break;
                                            }
                                    }
                                }
                    }
                    metavec.drawText(0, 0, txt, 15, 0x000000);
                }
                metavec.normalise();
                return [sname, metavec];
            }
            return [null, null];
        }
    }
    SARTable.CODE = 'org.mmi.aspect.SARTable';
    SARTable.NAME = 'SAR Table';
    SARTable.DESCR_CONSTRUCT = 'Structure of constructed molecule';
    SARTable.DESCR_LOCKED = 'Whether constructed molecule should be rebuilt';
    SARTable.DESCR_SCAFFOLD = 'Decorated core scaffold of molecule';
    SARTable.DESCR_SUBSTITUENT = 'Substituent fragment to be attached to scaffold';
    SARTable.RENDER_CONSTRUCT = 0;
    SARTable.RENDER_SCAFFOLD = 1;
    SARTable.RENDER_SUBSTITUENT = 2;
    WebMolKit.SARTable = SARTable;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class ExperimentComponent {
        constructor(mol, name) {
            this.mol = null;
            this.name = '';
            this.stoich = '';
            this.mass = null;
            this.volume = null;
            this.moles = null;
            this.density = null;
            this.conc = null;
            this.yield = null;
            this.primary = false;
            this.waste = false;
            this.equiv = null;
            this.mol = mol;
            if (name)
                this.name = name;
        }
        clone() {
            let dup = new ExperimentComponent(this.mol, this.name);
            dup.stoich = this.stoich;
            dup.mass = this.mass;
            dup.volume = this.volume;
            dup.moles = this.moles;
            dup.density = this.density;
            dup.conc = this.conc;
            dup.yield = this.yield;
            dup.primary = this.primary;
            dup.waste = this.waste;
            dup.equiv = this.equiv;
            return dup;
        }
        equals(other) {
            if (this.name != other.name)
                return false;
            if (this.stoich != other.stoich || this.mass != other.mass || this.volume != other.volume || this.moles != other.moles ||
                this.density != other.density || this.conc != other.conc || this.yield != other.yield || this.primary != other.primary ||
                this.waste != other.waste || this.equiv != other.equiv)
                return false;
            if (this.mol === other.mol)
                return true;
            if (this.mol == null || other.mol == null)
                return false;
            return this.mol.compareTo(other.mol) == 0;
        }
        isBlank() {
            return WebMolKit.MolUtil.isBlank(this.mol) && !this.name;
        }
    }
    WebMolKit.ExperimentComponent = ExperimentComponent;
    class ExperimentStep {
        constructor() {
            this.reactants = [];
            this.reagents = [];
            this.products = [];
        }
        contructor() { }
        clone() {
            let dup = new ExperimentStep();
            for (let c of this.reactants)
                dup.reactants.push(c.clone());
            for (let c of this.reagents)
                dup.reagents.push(c.clone());
            for (let c of this.products)
                dup.products.push(c.clone());
            return dup;
        }
        equals(other) {
            if (this.reactants.length != other.reactants.length)
                return false;
            if (this.reagents.length != other.reagents.length)
                return false;
            if (this.products.length != other.products.length)
                return false;
            for (let n = 0; n < this.reactants.length; n++)
                if (!this.reactants[n].equals(other.reactants[n]))
                    return false;
            for (let n = 0; n < this.reagents.length; n++)
                if (!this.reagents[n].equals(other.reagents[n]))
                    return false;
            for (let n = 0; n < this.products.length; n++)
                if (!this.products[n].equals(other.products[n]))
                    return false;
            return true;
        }
    }
    WebMolKit.ExperimentStep = ExperimentStep;
    class ExperimentEntry {
        constructor() {
            this.title = '';
            this.createDate = null;
            this.modifyDate = null;
            this.doi = '';
            this.steps = [];
        }
        clone() {
            let dup = new ExperimentEntry();
            dup.title = this.title;
            dup.createDate = this.createDate;
            dup.modifyDate = this.modifyDate;
            dup.doi = this.doi;
            for (let s of this.steps)
                dup.steps.push(s.clone());
            return dup;
        }
        deepClone() {
            let dup = this.clone();
            for (let step of dup.steps) {
                for (let comp of step.reactants)
                    if (comp.mol != null)
                        comp.mol = comp.mol.clone();
                for (let comp of step.reagents)
                    if (comp.mol != null)
                        comp.mol = comp.mol.clone();
                for (let comp of step.products)
                    if (comp.mol != null)
                        comp.mol = comp.mol.clone();
            }
            return dup;
        }
        equals(other) {
            if (this.title != other.title)
                return false;
            let d1 = this.createDate == null ? 0 : this.createDate.getTime(), d2 = other.createDate == null ? 0 : other.createDate.getTime();
            if (d1 != d2)
                return false;
            let d3 = this.modifyDate == null ? 0 : this.modifyDate.getTime(), d4 = other.modifyDate == null ? 0 : other.modifyDate.getTime();
            if (d3 != d4)
                return false;
            if (this.doi != other.doi)
                return false;
            if (this.steps.length != other.steps.length)
                return false;
            for (let n = 0; n < this.steps.length; n++)
                if (!this.steps[n].equals(other.steps[n]))
                    return false;
            return true;
        }
        getComponent(step, type, idx) {
            if (type == Experiment.REACTANT)
                return this.steps[step].reactants[idx];
            if (type == Experiment.REAGENT)
                return this.steps[step].reagents[idx];
            if (type == Experiment.PRODUCT)
                return this.steps[step].products[idx];
            return new ExperimentComponent();
        }
    }
    WebMolKit.ExperimentEntry = ExperimentEntry;
    class Experiment extends WebMolKit.Aspect {
        constructor(ds, allowModify) {
            super(ds, allowModify);
            if ($.isEmptyObject(Experiment.COLUMN_DESCRIPTIONS)) {
                let v = Experiment.COLUMN_DESCRIPTIONS;
                v[Experiment.COLNAME_EXPERIMENT_TITLE] = 'Title description for the experiment';
                v[Experiment.COLNAME_EXPERIMENT_CREATEDATE] = 'Date the experiment was created (seconds since 1970)';
                v[Experiment.COLNAME_EXPERIMENT_MODIFYDATE] = 'Date the experiment was last modified (seconds since 1970)';
                v[Experiment.COLNAME_EXPERIMENT_DOI] = 'Digital object identifiers (DOI) for the experiment (whitespace separated)';
                v[Experiment.COLNAME_REACTANT_MOL] = 'Molecular structure of reactant';
                v[Experiment.COLNAME_REACTANT_NAME] = 'Name of reactant';
                v[Experiment.COLNAME_REACTANT_STOICH] = 'Stoichiometry of reactant';
                v[Experiment.COLNAME_REACTANT_MASS] = 'Mass quantity of reactant (g)';
                v[Experiment.COLNAME_REACTANT_VOLUME] = 'Volume quantity of reactant (mL)';
                v[Experiment.COLNAME_REACTANT_MOLES] = 'Molar quantity of reactant (mol)';
                v[Experiment.COLNAME_REACTANT_DENSITY] = 'Density of reactant (g/mL)';
                v[Experiment.COLNAME_REACTANT_CONC] = 'Concentration of reactant (mol/L)';
                v[Experiment.COLNAME_REACTANT_PRIMARY] = 'Whether the reactant is used for yield calculation';
                v[Experiment.COLNAME_REAGENT_MOL] = 'Molecular structure of reagent';
                v[Experiment.COLNAME_REAGENT_NAME] = 'Name of reagent';
                v[Experiment.COLNAME_REAGENT_EQUIV] = 'Molar equivalents of reagent';
                v[Experiment.COLNAME_REAGENT_MASS] = 'Mass quantity of reagent (g)';
                v[Experiment.COLNAME_REAGENT_VOLUME] = 'Volume quantity of reagent (mL)';
                v[Experiment.COLNAME_REAGENT_MOLES] = 'Molar quantity of reagent (mol)';
                v[Experiment.COLNAME_REAGENT_DENSITY] = 'Density of reagent (g/mL)';
                v[Experiment.COLNAME_REAGENT_CONC] = 'Concentration of reagent (mol/L)';
                v[Experiment.COLNAME_PRODUCT_MOL] = 'Molecular structure of product';
                v[Experiment.COLNAME_PRODUCT_NAME] = 'Name of product';
                v[Experiment.COLNAME_PRODUCT_STOICH] = 'Stoichiometry of product';
                v[Experiment.COLNAME_PRODUCT_MASS] = 'Mass quantity of reactant (g)';
                v[Experiment.COLNAME_PRODUCT_VOLUME] = 'Volume quantity of reactant (mL)';
                v[Experiment.COLNAME_PRODUCT_MOLES] = 'Molar quantity of reactant (mol)';
                v[Experiment.COLNAME_PRODUCT_DENSITY] = 'Density of reactant (g/mL)';
                v[Experiment.COLNAME_PRODUCT_CONC] = 'Concentration of reactant (mol/L)';
                v[Experiment.COLNAME_PRODUCT_YIELD] = 'Yield of product (%)';
                v[Experiment.COLNAME_PRODUCT_WASTE] = 'Whether the product is an unwanted byproduct';
            }
            this.setup();
        }
        static isExperiment(ds) {
            for (let n = 0; n < ds.numExtensions; n++)
                if (ds.getExtType(n) == Experiment.CODE)
                    return true;
            return false;
        }
        isFirstStep(row) {
            if (this.ds.notNull(row, Experiment.COLNAME_EXPERIMENT_CREATEDATE))
                return true;
            let mol = this.ds.getMolecule(row, Experiment.COLNAME_REACTANT_MOL + '1');
            if (WebMolKit.MolUtil.notBlank(mol))
                return true;
            let name = this.ds.getString(row, Experiment.COLNAME_REACTANT_NAME + '1');
            if (name)
                return true;
            return false;
        }
        numberOfSteps(row) {
            if (row >= this.ds.numRows)
                return 0;
            let steps = 1;
            while (row + steps < this.ds.numRows) {
                if (this.isFirstStep(row + steps))
                    break;
                steps++;
            }
            return steps;
        }
        getEntry(row) {
            let entry = new ExperimentEntry();
            let title = this.ds.getString(row, Experiment.COLNAME_EXPERIMENT_TITLE);
            if (title)
                entry.title = title;
            let createDate = this.ds.getReal(row, Experiment.COLNAME_EXPERIMENT_CREATEDATE);
            if (createDate)
                entry.createDate = new Date(createDate * 1000);
            let modifyDate = this.ds.getReal(row, Experiment.COLNAME_EXPERIMENT_MODIFYDATE);
            if (modifyDate)
                entry.modifyDate = new Date(modifyDate * 1000);
            let doi = this.ds.getString(row, Experiment.COLNAME_EXPERIMENT_DOI);
            if (doi)
                entry.doi = doi;
            let [nreactants, nproducts, nreagents] = this.countComponents();
            for (let pos = row; pos < this.ds.numRows; pos++) {
                if (pos > row && this.isFirstStep(pos))
                    break;
                let step = new ExperimentStep();
                if (pos == row)
                    for (let n = 1; n <= nreactants; n++) {
                        let comp = this.fetchReactant(pos, n);
                        if (comp != null)
                            step.reactants.push(comp);
                        else
                            break;
                    }
                for (let n = 1; n <= nproducts; n++) {
                    let comp = this.fetchProduct(pos, n);
                    if (comp != null)
                        step.products.push(comp);
                    else
                        break;
                }
                for (let n = 1; n <= nreagents; n++) {
                    let comp = this.fetchReagent(pos, n);
                    if (comp != null)
                        step.reagents.push(comp);
                    else
                        break;
                }
                entry.steps.push(step);
            }
            return entry;
        }
        setEntry(row, entry) {
            this.putEntry(row, entry, true);
        }
        addEntry(entry) {
            this.putEntry(this.ds.numRows, entry, false);
        }
        insertEntry(row, entry) {
            this.putEntry(row, entry, false);
        }
        deleteEntry(row) {
            let nsteps = this.numberOfSteps(row);
            for (let n = row + nsteps - 1; n >= row; n--)
                this.ds.deleteRow(n);
        }
        setup() {
            this.parseAndCorrect();
        }
        parseAndCorrect() {
            let ds = this.ds;
            let idxRxn = -1, idxYld = -1, idxExp = -1;
            let extRxn = '', extYld = '', extExp = '';
            for (let n = 0; n < ds.numExtensions; n++) {
                if (ds.getExtType(n) == Experiment.CODE_RXN) {
                    idxRxn = n;
                    extRxn = ds.getExtData(n);
                }
                else if (ds.getExtType(n) == Experiment.CODE_YLD) {
                    idxYld = n;
                    extYld = ds.getExtData(n);
                }
                else if (ds.getExtType(n) == Experiment.CODE) {
                    idxExp = n;
                    extExp = ds.getExtData(n);
                }
            }
            let [nreactants, nproducts, nreagents] = this.parseReactionMetaData(extRxn);
            let meta = `nreactants=${nreactants}\nnproducts=${nproducts}\nnreagents=${nreagents}\n`;
            if (idxRxn >= 0)
                ds.setExtData(idxRxn, meta);
            else
                ds.appendExtension(Experiment.NAME_RXN, Experiment.CODE_RXN, meta);
            if (idxYld >= 0)
                ds.setExtData(idxYld, '');
            else
                ds.appendExtension(Experiment.NAME_YLD, Experiment.CODE_YLD, '');
            if (idxExp >= 0)
                ds.setExtData(idxExp, '');
            else
                ds.appendExtension(Experiment.NAME, Experiment.CODE, '');
            this.forceColumn(Experiment.COLNAME_EXPERIMENT_TITLE, WebMolKit.DataSheet.COLTYPE_STRING);
            this.forceColumn(Experiment.COLNAME_EXPERIMENT_CREATEDATE, WebMolKit.DataSheet.COLTYPE_REAL);
            this.forceColumn(Experiment.COLNAME_EXPERIMENT_MODIFYDATE, WebMolKit.DataSheet.COLTYPE_REAL);
            this.forceColumn(Experiment.COLNAME_EXPERIMENT_DOI, WebMolKit.DataSheet.COLTYPE_STRING);
            for (let n = 1; n <= nreactants; n++)
                this.forceReactantColumns(n);
            for (let n = 1; n <= nreagents; n++)
                this.forceReagentColumns(n);
            for (let n = 1; n <= nproducts; n++)
                this.forceProductColumns(n);
        }
        forceColumn(colName, type, suffix) {
            let useName = colName + (suffix == null ? '' : suffix);
            this.ds.ensureColumn(useName, type, Experiment.COLUMN_DESCRIPTIONS[colName]);
        }
        forceReactantColumns(suffix) {
            this.forceColumn(Experiment.COLNAME_REACTANT_MOL, WebMolKit.DataSheet.COLTYPE_MOLECULE, suffix);
            this.forceColumn(Experiment.COLNAME_REACTANT_NAME, WebMolKit.DataSheet.COLTYPE_STRING, suffix);
            this.forceColumn(Experiment.COLNAME_REACTANT_STOICH, WebMolKit.DataSheet.COLTYPE_STRING, suffix);
            this.forceColumn(Experiment.COLNAME_REACTANT_MASS, WebMolKit.DataSheet.COLTYPE_REAL, suffix);
            this.forceColumn(Experiment.COLNAME_REACTANT_VOLUME, WebMolKit.DataSheet.COLTYPE_REAL, suffix);
            this.forceColumn(Experiment.COLNAME_REACTANT_MOLES, WebMolKit.DataSheet.COLTYPE_REAL, suffix);
            this.forceColumn(Experiment.COLNAME_REACTANT_DENSITY, WebMolKit.DataSheet.COLTYPE_REAL, suffix);
            this.forceColumn(Experiment.COLNAME_REACTANT_CONC, WebMolKit.DataSheet.COLTYPE_REAL, suffix);
            this.forceColumn(Experiment.COLNAME_REACTANT_PRIMARY, WebMolKit.DataSheet.COLTYPE_BOOLEAN, suffix);
        }
        forceReagentColumns(suffix) {
            this.forceColumn(Experiment.COLNAME_REAGENT_MOL, WebMolKit.DataSheet.COLTYPE_MOLECULE, suffix);
            this.forceColumn(Experiment.COLNAME_REAGENT_NAME, WebMolKit.DataSheet.COLTYPE_STRING, suffix);
            this.forceColumn(Experiment.COLNAME_REAGENT_EQUIV, WebMolKit.DataSheet.COLTYPE_REAL, suffix);
            this.forceColumn(Experiment.COLNAME_REAGENT_MASS, WebMolKit.DataSheet.COLTYPE_REAL, suffix);
            this.forceColumn(Experiment.COLNAME_REAGENT_VOLUME, WebMolKit.DataSheet.COLTYPE_REAL, suffix);
            this.forceColumn(Experiment.COLNAME_REAGENT_MOLES, WebMolKit.DataSheet.COLTYPE_REAL, suffix);
            this.forceColumn(Experiment.COLNAME_REAGENT_DENSITY, WebMolKit.DataSheet.COLTYPE_REAL, suffix);
            this.forceColumn(Experiment.COLNAME_REAGENT_CONC, WebMolKit.DataSheet.COLTYPE_REAL, suffix);
        }
        forceProductColumns(suffix) {
            this.forceColumn(Experiment.COLNAME_PRODUCT_MOL, WebMolKit.DataSheet.COLTYPE_MOLECULE, suffix);
            this.forceColumn(Experiment.COLNAME_PRODUCT_NAME, WebMolKit.DataSheet.COLTYPE_STRING, suffix);
            this.forceColumn(Experiment.COLNAME_PRODUCT_STOICH, WebMolKit.DataSheet.COLTYPE_STRING, suffix);
            this.forceColumn(Experiment.COLNAME_PRODUCT_MASS, WebMolKit.DataSheet.COLTYPE_REAL, suffix);
            this.forceColumn(Experiment.COLNAME_PRODUCT_VOLUME, WebMolKit.DataSheet.COLTYPE_REAL, suffix);
            this.forceColumn(Experiment.COLNAME_PRODUCT_MOLES, WebMolKit.DataSheet.COLTYPE_REAL, suffix);
            this.forceColumn(Experiment.COLNAME_PRODUCT_DENSITY, WebMolKit.DataSheet.COLTYPE_REAL, suffix);
            this.forceColumn(Experiment.COLNAME_PRODUCT_CONC, WebMolKit.DataSheet.COLTYPE_REAL, suffix);
            this.forceColumn(Experiment.COLNAME_PRODUCT_YIELD, WebMolKit.DataSheet.COLTYPE_REAL, suffix);
            this.forceColumn(Experiment.COLNAME_PRODUCT_WASTE, WebMolKit.DataSheet.COLTYPE_BOOLEAN, suffix);
        }
        parseReactionMetaData(content) {
            let nreactants = 1, nproducts = 1, nreagents = 0;
            for (let line of content.split(/\r?\n/)) {
                if (line.startsWith('nreactants='))
                    nreactants = Math.max(nreactants, Math.min(100, parseInt(line.substring(11))));
                else if (line.startsWith('nproducts='))
                    nproducts = Math.max(nproducts, Math.min(100, parseInt(line.substring(10))));
                else if (line.startsWith('nreagents='))
                    nreagents = Math.max(nreagents, Math.min(100, parseInt(line.substring(10))));
            }
            return [nreactants, nproducts, nreagents];
        }
        countComponents() {
            let nreactants = 0, nproducts = 0, nreagents = 0;
            for (let n = 0; n < this.ds.numExtensions; n++)
                if (this.ds.getExtType(n) == Experiment.CODE_RXN) {
                    [nreactants, nproducts, nreagents] = this.parseReactionMetaData(this.ds.getExtData(n));
                    break;
                }
            return [nreactants, nproducts, nreagents];
        }
        fetchReactant(row, idx) {
            let mol = this.ds.getMolecule(row, `${Experiment.COLNAME_REACTANT_MOL}${idx}`);
            let name = this.ds.getString(row, `${Experiment.COLNAME_REACTANT_NAME}${idx}`);
            if (WebMolKit.MolUtil.isBlank(mol) && !name)
                return null;
            let comp = new ExperimentComponent(mol, name);
            let stoich = this.ds.getString(row, `${Experiment.COLNAME_REACTANT_STOICH}${idx}`);
            if (stoich)
                comp.stoich = stoich;
            comp.mass = this.ds.getReal(row, `${Experiment.COLNAME_REACTANT_MASS}${idx}`);
            comp.volume = this.ds.getReal(row, `${Experiment.COLNAME_REACTANT_VOLUME}${idx}`);
            comp.moles = this.ds.getReal(row, `${Experiment.COLNAME_REACTANT_MOLES}${idx}`);
            comp.density = this.ds.getReal(row, `${Experiment.COLNAME_REACTANT_DENSITY}${idx}`);
            comp.conc = this.ds.getReal(row, `${Experiment.COLNAME_REACTANT_CONC}${idx}`);
            let primary = this.ds.getBoolean(row, `${Experiment.COLNAME_REACTANT_PRIMARY}${idx}`);
            if (primary != null)
                comp.primary = primary;
            return comp;
        }
        fetchProduct(row, idx) {
            let mol = this.ds.getMolecule(row, `${Experiment.COLNAME_PRODUCT_MOL}${idx}`);
            let name = this.ds.getString(row, `${Experiment.COLNAME_PRODUCT_NAME}${idx}`);
            if (WebMolKit.MolUtil.isBlank(mol) && !name)
                return null;
            let comp = new ExperimentComponent(mol, name);
            let stoich = this.ds.getString(row, `${Experiment.COLNAME_PRODUCT_STOICH}${idx}`);
            if (stoich)
                comp.stoich = stoich;
            comp.mass = this.ds.getReal(row, `${Experiment.COLNAME_PRODUCT_MASS}${idx}`);
            comp.volume = this.ds.getReal(row, `${Experiment.COLNAME_PRODUCT_VOLUME}${idx}`);
            comp.moles = this.ds.getReal(row, `${Experiment.COLNAME_PRODUCT_MOLES}${idx}`);
            comp.density = this.ds.getReal(row, `${Experiment.COLNAME_PRODUCT_DENSITY}${idx}`);
            comp.conc = this.ds.getReal(row, `${Experiment.COLNAME_PRODUCT_CONC}${idx}`);
            let waste = this.ds.getBoolean(row, `${Experiment.COLNAME_PRODUCT_WASTE}${idx}`);
            if (waste != null)
                comp.waste = waste;
            return comp;
        }
        fetchReagent(row, idx) {
            let mol = this.ds.getMolecule(row, `${Experiment.COLNAME_REAGENT_MOL}${idx}`);
            let name = this.ds.getString(row, `${Experiment.COLNAME_REAGENT_NAME}${idx}`);
            if (WebMolKit.MolUtil.isBlank(mol) && !name)
                return null;
            let comp = new ExperimentComponent(mol, name);
            comp.mass = this.ds.getReal(row, `${Experiment.COLNAME_REAGENT_MASS}${idx}`);
            comp.volume = this.ds.getReal(row, `${Experiment.COLNAME_REAGENT_VOLUME}${idx}`);
            comp.moles = this.ds.getReal(row, `${Experiment.COLNAME_REAGENT_MOLES}${idx}`);
            comp.density = this.ds.getReal(row, `${Experiment.COLNAME_REAGENT_DENSITY}${idx}`);
            comp.conc = this.ds.getReal(row, `${Experiment.COLNAME_REAGENT_CONC}${idx}`);
            comp.equiv = this.ds.getReal(row, `${Experiment.COLNAME_REAGENT_EQUIV}${idx}`);
            return comp;
        }
        putEntry(row, entry, replace) {
            let [preactants, pproducts, preagents] = this.countComponents();
            var [nreactants, nproducts, nreagents] = [preactants, pproducts, preagents];
            for (let step of entry.steps) {
                nreactants = Math.max(nreactants, step.reactants.length);
                nproducts = Math.max(nproducts, step.products.length);
                nreagents = Math.max(nreagents, step.reagents.length);
            }
            if (nreactants != preactants || nproducts != pproducts || nreagents != preagents) {
                let meta = `nreactants=${nreactants}\nnproducts=${nproducts}\nnreagents=${nreagents}`;
                let got = false;
                for (let n = 0; n < this.ds.numExtensions; n++)
                    if (this.ds.getExtType(n) == Experiment.CODE_RXN) {
                        this.ds.setExtData(n, meta);
                        got = true;
                        break;
                    }
                if (!got)
                    this.ds.appendExtension(Experiment.NAME_RXN, Experiment.CODE_RXN, meta);
            }
            for (let n = 1; n <= nreactants; n++)
                this.forceReactantColumns(n);
            for (let n = 1; n <= nreagents; n++)
                this.forceReagentColumns(n);
            for (let n = 1; n <= nproducts; n++)
                this.forceProductColumns(n);
            let oldSteps = replace ? this.numberOfSteps(row) : 0, newSteps = entry.steps.length;
            if (oldSteps > newSteps) {
                for (let n = newSteps; n < oldSteps; n++)
                    this.ds.deleteRow(row + newSteps - 1);
            }
            else if (newSteps > oldSteps) {
                for (let n = oldSteps; n < newSteps; n++)
                    this.ds.insertRow(row + oldSteps);
            }
            this.ds.setString(row, Experiment.COLNAME_EXPERIMENT_TITLE, entry.title);
            this.ds.setReal(row, Experiment.COLNAME_EXPERIMENT_CREATEDATE, entry.createDate == null ? null : entry.createDate.getTime() * 1E-3);
            this.ds.setReal(row, Experiment.COLNAME_EXPERIMENT_MODIFYDATE, entry.modifyDate == null ? null : entry.modifyDate.getTime() * 1E-3);
            this.ds.setString(row, Experiment.COLNAME_EXPERIMENT_DOI, entry.doi);
            for (let s = 0; s < entry.steps.length; s++) {
                let r = row + s;
                if (s == 0)
                    for (let n = 0; n < entry.steps[s].reactants.length; n++) {
                        let comp = entry.steps[s].reactants[n], i = n + 1;
                        this.ds.setMolecule(r, `${Experiment.COLNAME_REACTANT_MOL}${i}`, comp.mol);
                        this.ds.setString(r, `${Experiment.COLNAME_REACTANT_NAME}${i}`, comp.name);
                        this.ds.setString(r, `${Experiment.COLNAME_REACTANT_STOICH}${i}`, comp.stoich);
                        this.ds.setReal(r, `${Experiment.COLNAME_REACTANT_MASS}${i}`, comp.mass);
                        this.ds.setReal(r, `${Experiment.COLNAME_REACTANT_VOLUME}${i}`, comp.volume);
                        this.ds.setReal(r, `${Experiment.COLNAME_REACTANT_MOLES}${i}`, comp.moles);
                        this.ds.setReal(r, `${Experiment.COLNAME_REACTANT_DENSITY}${i}`, comp.density);
                        this.ds.setReal(r, `${Experiment.COLNAME_REACTANT_CONC}${i}`, comp.conc);
                        this.ds.setBoolean(r, `${Experiment.COLNAME_REACTANT_PRIMARY}${i}`, comp.primary);
                    }
                for (let n = 0; n < entry.steps[s].reagents.length; n++) {
                    let comp = entry.steps[s].reagents[n], i = n + 1;
                    this.ds.setMolecule(r, `${Experiment.COLNAME_REAGENT_MOL}${i}`, comp.mol);
                    this.ds.setString(r, `${Experiment.COLNAME_REAGENT_NAME}${i}`, comp.name);
                    this.ds.setReal(r, `${Experiment.COLNAME_REAGENT_EQUIV}${i}`, comp.equiv);
                    this.ds.setReal(r, `${Experiment.COLNAME_REAGENT_MASS}${i}`, comp.mass);
                    this.ds.setReal(r, `${Experiment.COLNAME_REAGENT_VOLUME}${i}`, comp.volume);
                    this.ds.setReal(r, `${Experiment.COLNAME_REAGENT_MOLES}${i}`, comp.moles);
                    this.ds.setReal(r, `${Experiment.COLNAME_REAGENT_DENSITY}${i}`, comp.density);
                    this.ds.setReal(r, `${Experiment.COLNAME_REAGENT_CONC}${i}`, comp.conc);
                }
                for (let n = 0; n < entry.steps[s].products.length; n++) {
                    let comp = entry.steps[s].products[n], i = n + 1;
                    this.ds.setMolecule(r, `${Experiment.COLNAME_PRODUCT_MOL}${i}`, comp.mol);
                    this.ds.setString(r, `${Experiment.COLNAME_PRODUCT_NAME}${i}`, comp.name);
                    this.ds.setString(r, `${Experiment.COLNAME_PRODUCT_STOICH}${i}`, comp.stoich);
                    this.ds.setReal(r, `${Experiment.COLNAME_PRODUCT_MASS}${i}`, comp.mass);
                    this.ds.setReal(r, `${Experiment.COLNAME_PRODUCT_VOLUME}${i}`, comp.volume);
                    this.ds.setReal(r, `${Experiment.COLNAME_PRODUCT_MOLES}${i}`, comp.moles);
                    this.ds.setReal(r, `${Experiment.COLNAME_PRODUCT_DENSITY}${i}`, comp.density);
                    this.ds.setReal(r, `${Experiment.COLNAME_PRODUCT_CONC}${i}`, comp.conc);
                    this.ds.setBoolean(r, `${Experiment.COLNAME_PRODUCT_WASTE}${i}`, comp.waste);
                }
            }
            for (let s = 0; s < entry.steps.length; s++) {
                let r = row + s;
                let start = s > 0 ? 0 : entry.steps[s].reactants.length;
                for (let n = start; n < nreactants; n++) {
                    let i = n + 1;
                    this.ds.setToNull(r, `${Experiment.COLNAME_REACTANT_MOL}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REACTANT_NAME}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REACTANT_STOICH}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REACTANT_MASS}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REACTANT_VOLUME}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REACTANT_MOLES}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REACTANT_DENSITY}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REACTANT_CONC}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REACTANT_PRIMARY}${i}`);
                }
                for (let n = entry.steps[s].reagents.length; n < nreagents; n++) {
                    let i = n + 1;
                    this.ds.setToNull(r, `${Experiment.COLNAME_REAGENT_MOL}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REAGENT_NAME}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REAGENT_EQUIV}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REAGENT_MASS}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REAGENT_VOLUME}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REAGENT_MOLES}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REAGENT_DENSITY}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REAGENT_CONC}${i}`);
                }
                for (let n = entry.steps[s].products.length; n < nproducts; n++) {
                    let i = n + 1;
                    this.ds.setToNull(r, `${Experiment.COLNAME_PRODUCT_MOL}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_PRODUCT_NAME}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_PRODUCT_STOICH}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_PRODUCT_MASS}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_PRODUCT_VOLUME}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_PRODUCT_MOLES}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_PRODUCT_DENSITY}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_PRODUCT_CONC}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_PRODUCT_WASTE}${i}`);
                }
            }
        }
        plainHeading() { return Experiment.NAME; }
        rowFirstBlock(row) { return this.isFirstStep(row); }
        rowBlockCount(row) { return this.numberOfSteps(row); }
        isColumnReserved(colName) {
            return this.areColumnsReserved([colName])[0];
        }
        areColumnsReserved(colNames) {
            let LITERALS = [
                Experiment.COLNAME_EXPERIMENT_TITLE,
                Experiment.COLNAME_EXPERIMENT_CREATEDATE,
                Experiment.COLNAME_EXPERIMENT_MODIFYDATE,
                Experiment.COLNAME_EXPERIMENT_DOI
            ];
            let PREFIXES = [
                Experiment.COLNAME_REACTANT_MOL,
                Experiment.COLNAME_REACTANT_NAME,
                Experiment.COLNAME_REACTANT_STOICH,
                Experiment.COLNAME_REACTANT_MASS,
                Experiment.COLNAME_REACTANT_VOLUME,
                Experiment.COLNAME_REACTANT_MOLES,
                Experiment.COLNAME_REACTANT_DENSITY,
                Experiment.COLNAME_REACTANT_CONC,
                Experiment.COLNAME_REACTANT_PRIMARY,
                Experiment.COLNAME_REAGENT_MOL,
                Experiment.COLNAME_REAGENT_NAME,
                Experiment.COLNAME_REAGENT_EQUIV,
                Experiment.COLNAME_REAGENT_MASS,
                Experiment.COLNAME_REAGENT_VOLUME,
                Experiment.COLNAME_REAGENT_MOLES,
                Experiment.COLNAME_REAGENT_DENSITY,
                Experiment.COLNAME_REAGENT_CONC,
                Experiment.COLNAME_PRODUCT_MOL,
                Experiment.COLNAME_PRODUCT_NAME,
                Experiment.COLNAME_PRODUCT_STOICH,
                Experiment.COLNAME_PRODUCT_MASS,
                Experiment.COLNAME_PRODUCT_VOLUME,
                Experiment.COLNAME_PRODUCT_MOLES,
                Experiment.COLNAME_PRODUCT_DENSITY,
                Experiment.COLNAME_PRODUCT_CONC,
                Experiment.COLNAME_PRODUCT_YIELD,
                Experiment.COLNAME_PRODUCT_WASTE
            ];
            let resv = WebMolKit.Vec.booleanArray(false, colNames.length);
            for (let n = 0; n < colNames.length; n++) {
                let name = colNames[n];
                if (LITERALS.indexOf(name) >= 0) {
                    resv[n] = true;
                    continue;
                }
                for (let pfx of PREFIXES)
                    if (name.startsWith(pfx)) {
                        resv[n] = true;
                        break;
                    }
            }
            return resv;
        }
    }
    Experiment.CODE = 'org.mmi.aspect.Experiment';
    Experiment.CODE_RXN = 'org.mmi.aspect.Reaction';
    Experiment.CODE_YLD = 'org.mmi.aspect.Yield';
    Experiment.NAME = 'Experiment';
    Experiment.NAME_RXN = 'Reaction';
    Experiment.NAME_YLD = 'Yield';
    Experiment.REACTANT = 1;
    Experiment.REAGENT = 2;
    Experiment.PRODUCT = 3;
    Experiment.COLNAME_EXPERIMENT_TITLE = 'ExperimentTitle';
    Experiment.COLNAME_EXPERIMENT_CREATEDATE = 'ExperimentCreateDate';
    Experiment.COLNAME_EXPERIMENT_MODIFYDATE = 'ExperimentModifyDate';
    Experiment.COLNAME_EXPERIMENT_DOI = 'ExperimentDOI';
    Experiment.COLNAME_REACTANT_MOL = 'ReactantMol';
    Experiment.COLNAME_REACTANT_NAME = 'ReactantName';
    Experiment.COLNAME_REACTANT_STOICH = 'ReactantStoich';
    Experiment.COLNAME_REACTANT_MASS = 'ReactantMass';
    Experiment.COLNAME_REACTANT_VOLUME = 'ReactantVolume';
    Experiment.COLNAME_REACTANT_MOLES = 'ReactantMoles';
    Experiment.COLNAME_REACTANT_DENSITY = 'ReactantDensity';
    Experiment.COLNAME_REACTANT_CONC = 'ReactantConc';
    Experiment.COLNAME_REACTANT_PRIMARY = 'ReactantPrimary';
    Experiment.COLNAME_REAGENT_MOL = 'ReagentMol';
    Experiment.COLNAME_REAGENT_NAME = 'ReagentName';
    Experiment.COLNAME_REAGENT_EQUIV = 'ReagentEquiv';
    Experiment.COLNAME_REAGENT_MASS = 'ReagentMass';
    Experiment.COLNAME_REAGENT_VOLUME = 'ReagentVolume';
    Experiment.COLNAME_REAGENT_MOLES = 'ReagentMoles';
    Experiment.COLNAME_REAGENT_DENSITY = 'ReagentDensity';
    Experiment.COLNAME_REAGENT_CONC = 'ReagentConc';
    Experiment.COLNAME_PRODUCT_MOL = 'ProductMol';
    Experiment.COLNAME_PRODUCT_NAME = 'ProductName';
    Experiment.COLNAME_PRODUCT_STOICH = 'ProductStoich';
    Experiment.COLNAME_PRODUCT_MASS = 'ProductMass';
    Experiment.COLNAME_PRODUCT_VOLUME = 'ProductVolume';
    Experiment.COLNAME_PRODUCT_MOLES = 'ProductMoles';
    Experiment.COLNAME_PRODUCT_DENSITY = 'ProductDensity';
    Experiment.COLNAME_PRODUCT_CONC = 'ProductConc';
    Experiment.COLNAME_PRODUCT_YIELD = 'ProductYield';
    Experiment.COLNAME_PRODUCT_WASTE = 'ProductWaste';
    Experiment.COLUMN_DESCRIPTIONS = {};
    WebMolKit.Experiment = Experiment;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class AssayProvenanceHeader {
        constructor() {
            this.prefixes = {};
            this.targetName = '';
            this.targetURI = '';
            this.organismName = '';
            this.organismURI = '';
            this.targetTypeName = '';
            this.targetTypeURI = '';
            this.cellName = '';
            this.cellURI = '';
            this.assayTypeName = '';
            this.assayTypeURI = '';
            this.assayDescription = '';
            this.sourceName = '';
            this.sourceURI = '';
            this.sourceVersion = '';
            this.documentName = '';
            this.documentURI = '';
            this.measureTypeName = '';
            this.measureTypeURI = '';
            this.unitNames = [];
            this.unitURIs = [];
        }
    }
    WebMolKit.AssayProvenanceHeader = AssayProvenanceHeader;
    class AssayProvenance extends WebMolKit.Aspect {
        constructor(ds, allowModify) {
            super(ds, allowModify);
            this.setup();
        }
        static isAssayProvenance(ds) {
            for (let n = 0; n < ds.numExtensions; n++)
                if (ds.getExtType(n) == AssayProvenance.CODE)
                    return true;
            return false;
        }
        getHeader() {
            for (let n = 0; n < this.ds.numExtensions; n++)
                if (this.ds.getExtType(n) == AssayProvenance.CODE)
                    return this.parseMetaData(this.ds.getExtData(n));
            return null;
        }
        setHeader(header) {
            let content = this.formatMetaData(header);
            for (let n = 0; n < this.ds.numExtensions; n++)
                if (this.ds.getExtType(n) == AssayProvenance.CODE) {
                    this.ds.setExtData(n, content);
                    return;
                }
            this.ds.appendExtension(AssayProvenance.NAME, AssayProvenance.CODE, content);
        }
        getMolecule(row) {
            let col = this.ds.findColByName(AssayProvenance.COLNAME_MOLECULE);
            return col < 0 ? null : this.ds.getMolecule(row, col);
        }
        getName(row) {
            let col = this.ds.findColByName(AssayProvenance.COLNAME_NAME);
            return col < 0 ? null : this.ds.getString(row, col);
        }
        getValue(row) {
            let col = this.ds.findColByName(AssayProvenance.COLNAME_VALUE);
            return col < 0 ? null : this.ds.isNull(row, col) ? Number.NaN : this.ds.getReal(row, col);
        }
        getError(row) {
            let col = this.ds.findColByName(AssayProvenance.COLNAME_ERROR);
            return col < 0 ? null : this.ds.isNull(row, col) ? Number.NaN : this.ds.getReal(row, col);
        }
        getUnits(row) {
            let col = this.ds.findColByName(AssayProvenance.COLNAME_UNITS);
            return col < 0 ? null : this.ds.getString(row, col);
        }
        getRelation(row) {
            let col = this.ds.findColByName(AssayProvenance.COLNAME_RELATION);
            return col < 0 ? null : this.ds.getString(row, col);
        }
        getSourceURI(row) {
            let col = this.ds.findColByName(AssayProvenance.COLNAME_SOURCEURI);
            return col < 0 ? null : this.ds.getString(row, col);
        }
        setMolecule(row, v) {
            let col = this.ds.findColByName(AssayProvenance.COLNAME_MOLECULE);
            if (col >= 0)
                this.ds.setMolecule(row, col, v);
        }
        setName(row, v) {
            let col = this.ds.findColByName(AssayProvenance.COLNAME_NAME);
            if (col >= 0)
                this.ds.setString(row, col, v);
        }
        setValue(row, v) {
            let col = this.ds.findColByName(AssayProvenance.COLNAME_VALUE);
            if (col < 0) { }
            else if (Number.isNaN(v))
                this.ds.setToNull(row, col);
            else
                this.ds.setReal(row, col, v);
        }
        setError(row, v) {
            let col = this.ds.findColByName(AssayProvenance.COLNAME_ERROR);
            if (col < 0) { }
            else if (Number.isNaN(v))
                this.ds.setToNull(row, col);
            else
                this.ds.setReal(row, col, v);
        }
        setUnits(row, v) {
            let col = this.ds.findColByName(AssayProvenance.COLNAME_UNITS);
            if (col >= 0)
                this.ds.setString(row, col, v);
        }
        setRelation(row, v) {
            let col = this.ds.findColByName(AssayProvenance.COLNAME_RELATION);
            if (col >= 0)
                this.ds.setString(row, col, v);
        }
        setSourceURI(row, v) {
            let col = this.ds.findColByName(AssayProvenance.COLNAME_SOURCEURI);
            if (col >= 0)
                this.ds.setString(row, col, v);
        }
        setup() {
            this.parseAndCorrect();
        }
        parseAndCorrect() {
            let header = new AssayProvenanceHeader();
            let got = false;
            for (let n = 0; n < this.ds.numExtensions; n++)
                if (this.ds.getExtType(n) == AssayProvenance.CODE) {
                    header = this.parseMetaData(this.ds.getExtData(n));
                    got = true;
                    break;
                }
            this.ds.ensureColumn(AssayProvenance.COLNAME_MOLECULE, WebMolKit.DataSheet.COLTYPE_MOLECULE, 'Molecular structure of compound being measured');
            this.ds.ensureColumn(AssayProvenance.COLNAME_NAME, WebMolKit.DataSheet.COLTYPE_STRING, 'Name of compound');
            this.ds.ensureColumn(AssayProvenance.COLNAME_VALUE, WebMolKit.DataSheet.COLTYPE_REAL, 'Measured value');
            this.ds.ensureColumn(AssayProvenance.COLNAME_ERROR, WebMolKit.DataSheet.COLTYPE_REAL, 'Experimental error of measurement');
            this.ds.ensureColumn(AssayProvenance.COLNAME_UNITS, WebMolKit.DataSheet.COLTYPE_STRING, 'Units of measurement');
            this.ds.ensureColumn(AssayProvenance.COLNAME_RELATION, WebMolKit.DataSheet.COLTYPE_STRING, 'Relation: exact, greater or less');
            this.ds.ensureColumn(AssayProvenance.COLNAME_SOURCEURI, WebMolKit.DataSheet.COLTYPE_STRING, 'Source identifier for activity measurement');
            if (!got) {
                let content = this.formatMetaData(header);
                this.ds.appendExtension(AssayProvenance.NAME, AssayProvenance.CODE, content);
            }
        }
        parseMetaData(content) {
            let header = new AssayProvenanceHeader();
            for (let line of content.split(/\r?\n/)) {
                let eq = line.indexOf('=');
                if (eq < 0)
                    continue;
                if (line.startsWith('pfx:'))
                    header.prefixes[WebMolKit.MoleculeStream.sk_unescape(line.substring(4, eq))] = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('targetName='))
                    header.targetName = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('targetURI='))
                    header.targetURI = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('organismName='))
                    header.organismName = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('organismURI='))
                    header.organismURI = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('targetTypeName='))
                    header.targetTypeName = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('targetTypeURI='))
                    header.targetTypeURI = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('cellName='))
                    header.cellName = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('cellURI='))
                    header.cellURI = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('assayTypeName='))
                    header.assayTypeName = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('assayTypeURI='))
                    header.assayTypeURI = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('assayDescription='))
                    header.assayDescription = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('sourceName='))
                    header.sourceName = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('sourceURI='))
                    header.sourceURI = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('sourceVersion='))
                    header.sourceVersion = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('documentName='))
                    header.documentName = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('documentURI='))
                    header.documentURI = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('measureTypeName='))
                    header.measureTypeName = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('measureTypeURI='))
                    header.measureTypeURI = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('unit:')) {
                    header.unitNames.push(WebMolKit.MoleculeStream.sk_unescape(line.substring(5, eq)));
                    header.unitURIs.push(WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1)));
                }
            }
            return header;
        }
        formatMetaData(header) {
            let content = '';
            for (let pfx in header.prefixes)
                content += 'pfx:' + WebMolKit.MoleculeStream.sk_escape(pfx) + '=' + WebMolKit.MoleculeStream.sk_escape(header.prefixes[pfx]) + '\n';
            content += 'targetName=' + WebMolKit.MoleculeStream.sk_escape(header.targetName) + '\n';
            content += 'targetURI=' + WebMolKit.MoleculeStream.sk_escape(header.targetURI) + '\n';
            content += 'organismName=' + WebMolKit.MoleculeStream.sk_escape(header.organismName) + '\n';
            content += 'organismURI=' + WebMolKit.MoleculeStream.sk_escape(header.organismURI) + '\n';
            content += 'targetTypeName=' + WebMolKit.MoleculeStream.sk_escape(header.targetTypeName) + '\n';
            content += 'targetTypeURI=' + WebMolKit.MoleculeStream.sk_escape(header.targetTypeURI) + '\n';
            content += 'cellName=' + WebMolKit.MoleculeStream.sk_escape(header.cellName) + '\n';
            content += 'cellURI=' + WebMolKit.MoleculeStream.sk_escape(header.cellURI) + '\n';
            content += 'assayTypeName=' + WebMolKit.MoleculeStream.sk_escape(header.assayTypeName) + '\n';
            content += 'assayTypeURI=' + WebMolKit.MoleculeStream.sk_escape(header.assayTypeURI) + '\n';
            content += 'assayDescription=' + WebMolKit.MoleculeStream.sk_escape(header.assayDescription) + '\n';
            content += 'sourceName=' + WebMolKit.MoleculeStream.sk_escape(header.sourceName) + '\n';
            content += 'sourceURI=' + WebMolKit.MoleculeStream.sk_escape(header.sourceURI) + '\n';
            content += 'sourceVersion=' + WebMolKit.MoleculeStream.sk_escape(header.sourceVersion) + '\n';
            content += 'documentName=' + WebMolKit.MoleculeStream.sk_escape(header.documentName) + '\n';
            content += 'documentURI=' + WebMolKit.MoleculeStream.sk_escape(header.documentURI) + '\n';
            content += 'measureTypeName=' + WebMolKit.MoleculeStream.sk_escape(header.measureTypeName) + '\n';
            content += 'measureTypeURI=' + WebMolKit.MoleculeStream.sk_escape(header.measureTypeURI) + '\n';
            for (let n = 0, num = Math.min(header.unitNames.length, header.unitURIs.length); n < num; n++)
                content += 'unit:' + WebMolKit.MoleculeStream.sk_escape(header.unitNames[n]) + '=' + WebMolKit.MoleculeStream.sk_escape(header.unitURIs[n]) + '\n';
            return content;
        }
        plainHeading() { return AssayProvenance.NAME; }
        isColumnReserved(colName) {
            return colName == AssayProvenance.COLNAME_VALUE || colName == AssayProvenance.COLNAME_ERROR ||
                colName == AssayProvenance.COLNAME_UNITS || colName == AssayProvenance.COLNAME_RELATION ||
                colName == AssayProvenance.COLNAME_SOURCEURI;
        }
        numTextRenderings(row) { return 2; }
        produceTextRendering(row, idx) {
            let header = this.getHeader();
            if (idx == 0) {
                let tr = {
                    'name': 'Activity',
                    'descr': 'Activity measurement details for this record',
                    'text': '',
                    'type': WebMolKit.Aspect.TEXT_PLAIN
                };
                let val = this.getValue(row), error = this.getError(row);
                let units = this.getUnits(row), rel = this.getRelation(row);
                tr.text = '';
                if (!Number.isNaN(val)) {
                    if (rel)
                        tr.text += rel + ' ';
                    tr.text += val;
                    if (!Number.isNaN(error))
                        tr.text += ' \u2213 ' + error;
                    if (units)
                        tr.text += ' ' + units;
                }
                return tr;
            }
            else if (idx == 1) {
                let tr = {
                    'name': 'Source',
                    'descr': 'Origin of the structure and activity measurement',
                    'text': '',
                    'type': WebMolKit.Aspect.TEXT_LINK
                };
                let url = this.getSourceURI(row);
                for (let pfx in header.prefixes)
                    if (url.startsWith(pfx + ':')) {
                        url = header.prefixes[pfx] + url.substring(pfx.length + 1);
                        break;
                    }
                tr.text = url;
                return tr;
            }
            return null;
        }
    }
    AssayProvenance.CODE = 'org.mmi.aspect.AssayProvenance';
    AssayProvenance.NAME = 'Assay Provenance';
    AssayProvenance.COLNAME_MOLECULE = 'Molecule';
    AssayProvenance.COLNAME_NAME = 'Name';
    AssayProvenance.COLNAME_VALUE = 'Value';
    AssayProvenance.COLNAME_ERROR = 'Error';
    AssayProvenance.COLNAME_UNITS = 'Units';
    AssayProvenance.COLNAME_RELATION = 'Relation';
    AssayProvenance.COLNAME_SOURCEURI = 'SourceURI';
    AssayProvenance.URI_UNIT_M = 'http://purl.obolibrary.org/obo/UO_0000062';
    AssayProvenance.URI_UNIT_mM = 'http://purl.obolibrary.org/obo/UO_0000063';
    AssayProvenance.URI_UNIT_uM = 'http://purl.obolibrary.org/obo/UO_0000064';
    AssayProvenance.URI_UNIT_nM = 'http://purl.obolibrary.org/obo/UO_0000065';
    AssayProvenance.URI_UNIT_pM = 'http://purl.obolibrary.org/obo/UO_0000066';
    AssayProvenance.URI_UNIT_logM = 'http://www.bioassayontology.org/bao#BAO_0000101';
    AssayProvenance.URI_UNIT_perM = 'http://www.bioassayontology.org/bao#BAO_0000102';
    AssayProvenance.URI_UNIT_gL = 'http://purl.obolibrary.org/obo/UO_0000175';
    AssayProvenance.URI_UNIT_mgL = 'http://purl.obolibrary.org/obo/UO_0000273';
    AssayProvenance.URI_UNIT_ugL = 'http://purl.obolibrary.org/obo/UO_0000275';
    AssayProvenance.URI_UNIT_binary = 'http://www.bioassayontology.org/bao#BAO_0080023';
    WebMolKit.AssayProvenance = AssayProvenance;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class BayesianSourceModel {
        constructor() {
            this.colNameMolecule = '';
            this.colNameValue = '';
            this.thresholdValue = 0.5;
            this.thresholdRelation = '>=';
            this.folding = 0;
            this.noteField = '';
            this.noteTitle = '';
            this.noteOrigin = '';
            this.noteComment = '';
        }
    }
    WebMolKit.BayesianSourceModel = BayesianSourceModel;
    class BayesianSource extends WebMolKit.Aspect {
        constructor(ds, allowModify) {
            super(ds, allowModify);
            this.setup();
        }
        static isBayesianSource(ds) {
            for (let n = 0; n < ds.numExtensions; n++)
                if (ds.getExtType(n) == BayesianSource.CODE)
                    return true;
            return false;
        }
        getModels() {
            let content = '';
            for (let n = 0; n < this.ds.numExtensions; n++)
                if (this.ds.getExtType(n) == BayesianSource.CODE) {
                    content = this.ds.getExtData(n);
                    break;
                }
            let models = [];
            let m = null;
            for (let line of content.split('\n')) {
                if (line == 'model:') {
                    if (m != null)
                        models.push(m);
                    m = {};
                    continue;
                }
                if (m == null)
                    continue;
                let eq = line.indexOf('=');
                if (eq < 0)
                    continue;
                if (line.startsWith('colNameMolecule='))
                    m.colNameMolecule = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('colNameValue='))
                    m.colNameValue = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('thresholdValue='))
                    m.thresholdValue = parseFloat(line.substring(eq + 1));
                else if (line.startsWith('thresholdRelation='))
                    m.thresholdRelation = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('folding='))
                    m.folding = parseInt(line.substring(eq + 1));
                else if (line.startsWith('noteField='))
                    m.noteField = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('noteTitle='))
                    m.noteTitle = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('noteOrigin='))
                    m.noteOrigin = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('noteComment='))
                    m.noteComment = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
            }
            if (m != null)
                models.push(m);
            return models;
        }
        setModels(models) {
            let lines = [];
            for (let m of models) {
                lines.push('model:');
                lines.push('colNameMolecule=' + WebMolKit.MoleculeStream.sk_escape(m.colNameMolecule));
                lines.push('colNameValue=' + WebMolKit.MoleculeStream.sk_escape(m.colNameValue));
                lines.push('thresholdValue=' + m.thresholdValue);
                lines.push('thresholdRelation=' + WebMolKit.MoleculeStream.sk_escape(m.thresholdRelation));
                lines.push('folding=%d' + m.folding);
                lines.push('noteField=' + WebMolKit.MoleculeStream.sk_escape(m.noteField));
                lines.push('noteTitle=' + WebMolKit.MoleculeStream.sk_escape(m.noteTitle));
                lines.push('noteOrigin=' + WebMolKit.MoleculeStream.sk_escape(m.noteOrigin));
                lines.push('noteComment=' + WebMolKit.MoleculeStream.sk_escape(m.noteComment));
            }
            let content = lines.join('\n');
            for (let n = 0; n < this.ds.numExtensions; n++)
                if (this.ds.getExtType(n) == BayesianSource.CODE) {
                    this.ds.setExtData(n, content.toString());
                    return;
                }
            this.ds.appendExtension('BayesianSource', BayesianSource.CODE, content.toString());
        }
        setup() {
            if (this.allowModify) {
                let models = this.getModels();
                this.setModels(models);
            }
        }
        plainHeading() { return BayesianSource.NAME; }
    }
    BayesianSource.CODE = 'org.mmi.aspect.BayesianSource';
    BayesianSource.NAME = 'Bayesian Source';
    WebMolKit.BayesianSource = BayesianSource;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class BayesianPredictionModel {
    }
    WebMolKit.BayesianPredictionModel = BayesianPredictionModel;
    class BayesianPredictionOutcome {
    }
    WebMolKit.BayesianPredictionOutcome = BayesianPredictionOutcome;
    class BayesianPrediction extends WebMolKit.Aspect {
        constructor(ds, allowModify) {
            super(ds, allowModify);
            this.setup();
        }
        static isBayesianPrediction(ds) {
            for (let n = 0; n < ds.numExtensions; n++)
                if (ds.getExtType(n) == BayesianPrediction.CODE)
                    return true;
            return false;
        }
        getModels() {
            let content = '';
            for (let n = 0; n < this.ds.numExtensions; n++)
                if (this.ds.getExtType(n) == BayesianPrediction.CODE) {
                    content = this.ds.getExtData(n);
                    break;
                }
            let models = [];
            let m = null;
            for (let line of content.split('\n')) {
                if (line == 'model:') {
                    if (m != null)
                        models.push(m);
                    m = {};
                    continue;
                }
                if (m == null)
                    continue;
                let eq = line.indexOf('=');
                if (eq < 0)
                    continue;
                if (line.startsWith('colMolecule='))
                    m.colMolecule = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('colRaw='))
                    m.colRaw = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('colScaled='))
                    m.colScaled = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('colArcTan='))
                    m.colArcTan = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('colDomain='))
                    m.colDomain = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('colAtoms='))
                    m.colAtoms = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('name='))
                    m.name = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('description='))
                    m.description = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('targetName='))
                    m.targetName = WebMolKit.MoleculeStream.sk_unescape(line.substring(eq + 1));
                else if (line.startsWith('isOffTarget='))
                    m.isOffTarget = line.substring(eq + 1) == 'true';
            }
            if (m != null)
                models.push(m);
            return models;
        }
        setModels(models) {
            let lines = [];
            for (let m of models) {
                lines.push('model:');
                lines.push('colMolecule=' + WebMolKit.MoleculeStream.sk_escape(m.colMolecule));
                lines.push('colRaw=' + WebMolKit.MoleculeStream.sk_escape(m.colRaw));
                lines.push('colScaled=' + WebMolKit.MoleculeStream.sk_escape(m.colScaled));
                lines.push('colArcTan=' + WebMolKit.MoleculeStream.sk_escape(m.colArcTan));
                lines.push('colDomain=' + WebMolKit.MoleculeStream.sk_escape(m.colDomain));
                lines.push('colAtoms=' + WebMolKit.MoleculeStream.sk_escape(m.colAtoms));
                lines.push('name=' + WebMolKit.MoleculeStream.sk_escape(m.name));
                lines.push('description=' + WebMolKit.MoleculeStream.sk_escape(m.description));
                lines.push('targetName=' + WebMolKit.MoleculeStream.sk_escape(m.targetName));
                lines.push('isOffTarget=' + m.isOffTarget);
            }
            let content = lines.join('\n');
            for (let n = 0; n < this.ds.numExtensions; n++)
                if (this.ds.getExtType(n) == WebMolKit.BayesianSource.CODE) {
                    this.ds.setExtData(n, content.toString());
                    return;
                }
            this.ds.appendExtension('BayesianPrediction', BayesianPrediction.CODE, content.toString());
        }
        getOutcome(row, model) {
            let outcome = new BayesianPredictionOutcome();
            outcome.raw = this.ds.getReal(row, model.colRaw);
            outcome.scaled = this.ds.getReal(row, model.colScaled);
            outcome.arctan = this.ds.getReal(row, model.colArcTan);
            outcome.domain = this.ds.getReal(row, model.colDomain);
            let strAtoms = this.ds.getString(row, model.colAtoms);
            if (strAtoms) {
                outcome.atoms = [];
                for (let b of strAtoms.split(','))
                    outcome.atoms.push(parseFloat(b));
            }
            return outcome;
        }
        setOutcome(row, model, outcome) {
            let col = this.ds.findColByName(model.colRaw, WebMolKit.DataSheet.COLTYPE_REAL);
            if (col >= 0)
                this.ds.setReal(row, col, outcome.raw);
            col = this.ds.findColByName(model.colScaled, WebMolKit.DataSheet.COLTYPE_REAL);
            if (col >= 0)
                this.ds.setReal(row, col, outcome.scaled);
            col = this.ds.findColByName(model.colArcTan, WebMolKit.DataSheet.COLTYPE_REAL);
            if (col >= 0)
                this.ds.setReal(row, col, outcome.arctan);
            col = this.ds.findColByName(model.colDomain, WebMolKit.DataSheet.COLTYPE_REAL);
            if (col >= 0)
                this.ds.setReal(row, col, outcome.domain);
            col = this.ds.findColByName(model.colAtoms, WebMolKit.DataSheet.COLTYPE_STRING);
            if (col >= 0)
                this.ds.setString(row, col, outcome.atoms ? outcome.atoms.toString() : null);
        }
        setup() {
            if (this.allowModify) {
                let models = this.getModels();
                this.setModels(models);
            }
        }
        plainHeading() { return WebMolKit.BayesianSource.NAME; }
    }
    BayesianPrediction.CODE = 'org.mmi.aspect.BayesianPrediction';
    BayesianPrediction.NAME = 'Bayesian Prediction';
    WebMolKit.BayesianPrediction = BayesianPrediction;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let SUPPORTED_ASPECTS = {};
    class AspectList {
        constructor(ds) {
            this.ds = ds;
            if ($.isEmptyObject(SUPPORTED_ASPECTS)) {
                SUPPORTED_ASPECTS[WebMolKit.SARTable.CODE] = WebMolKit.SARTable.NAME;
                SUPPORTED_ASPECTS[WebMolKit.Experiment.CODE] = WebMolKit.Experiment.NAME;
                SUPPORTED_ASPECTS[WebMolKit.AssayProvenance.CODE] = WebMolKit.AssayProvenance.NAME;
                SUPPORTED_ASPECTS[WebMolKit.BayesianSource.CODE] = WebMolKit.BayesianSource.NAME;
                SUPPORTED_ASPECTS[WebMolKit.BayesianPrediction.CODE] = WebMolKit.BayesianPrediction.NAME;
            }
        }
        list() {
            let present = [], absent = [];
            let codes = new Set();
            for (let n = 0; n < this.ds.numExtensions; n++)
                codes.add(this.ds.getExtType(n));
            for (let code in SUPPORTED_ASPECTS)
                if (codes.has(code))
                    present.push(code);
                else
                    absent.push(code);
            return [present, absent];
        }
        instantiate(code) {
            if (code == WebMolKit.SARTable.CODE)
                return new WebMolKit.SARTable(this.ds);
            if (code == WebMolKit.Experiment.CODE)
                return new WebMolKit.Experiment(this.ds);
            if (code == WebMolKit.AssayProvenance.CODE)
                return new WebMolKit.AssayProvenance(this.ds);
            if (code == WebMolKit.BayesianSource.CODE)
                return new WebMolKit.BayesianSource(this.ds);
            return null;
        }
        enumerate() {
            let aspects = [];
            for (let n = 0; n < this.ds.numExtensions; n++) {
                let code = this.ds.getExtType(n);
                if (SUPPORTED_ASPECTS[code])
                    aspects.push(this.instantiate(code));
            }
            return aspects;
        }
    }
    WebMolKit.AspectList = AspectList;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class Stereochemistry {
        constructor(meta) {
            this.meta = meta;
            this.mol = meta.mol;
            this.priority = WebMolKit.Vec.numberArray(0, this.mol.numAtoms);
            this.chiralTetra = WebMolKit.Vec.numberArray(Stereochemistry.STEREO_NONE, this.mol.numAtoms);
            this.cistransBond = WebMolKit.Vec.numberArray(Stereochemistry.STEREO_NONE, this.mol.numBonds);
            this.cistransPlanar = WebMolKit.Vec.numberArray(Stereochemistry.STEREO_NONE, this.mol.numAtoms);
            this.chiralOcta = WebMolKit.Vec.numberArray(Stereochemistry.STEREO_NONE, this.mol.numAtoms);
        }
        calculate() {
            this.isH = WebMolKit.Vec.booleanArray(false, this.mol.numAtoms);
            for (let n = this.mol.numAtoms; n >= 1; n--)
                this.isH[n - 1] = this.mol.atomElement(n) == 'H';
            this.buildPriority();
            this.buildTetraChirality();
            this.buildBondCisTrans();
            this.buildPlanarCisTrans();
            this.buildOctaChirality();
        }
        atomPriority(atom) { return this.priority[atom - 1]; }
        atomTetraChirality(atom) { return this.chiralTetra[atom - 1]; }
        bondSideStereo(bond) { return this.cistransBond[bond - 1]; }
        atomPlanarStereo(atom) { return this.cistransPlanar[atom - 1]; }
        atomOctaChirality(atom) { return this.chiralOcta[atom - 1]; }
        getPriorities() { return this.priority.slice(0); }
        getAtomTetraChiral() { return this.chiralTetra.slice(0); }
        getBondSideStereo() { return this.cistransBond.slice(0); }
        static create(meta) {
            let stereo = new Stereochemistry(meta);
            stereo.calculate();
            return stereo;
        }
        static rubricTetrahedral(mol, atom) {
            if (mol.atomAdjCount(atom) < 3 || mol.atomAdjCount(atom) + mol.atomHydrogens(atom) != 4)
                return null;
            let adjBonds = mol.atomAdjBonds(atom);
            let hasWedge = false;
            for (let n = 0; n < adjBonds.length; n++) {
                let bt = mol.bondType(adjBonds[n]);
                if (bt == WebMolKit.Molecule.BONDTYPE_UNKNOWN)
                    return null;
                if (mol.bondFrom(adjBonds[n]) != atom)
                    continue;
                if (bt == WebMolKit.Molecule.BONDTYPE_INCLINED || bt == WebMolKit.Molecule.BONDTYPE_DECLINED)
                    hasWedge = true;
            }
            if (!hasWedge && !mol.is3D())
                return null;
            let adj = mol.atomAdjList(atom);
            let x = [0, 0, 0, 0];
            let y = [0, 0, 0, 0];
            let z = [0, 0, 0, 0];
            let numShort = 0, numWedges = 0;
            for (let n = 0; n < adjBonds.length; n++) {
                const bfr = mol.bondFrom(adjBonds[n]), bt = mol.bondType(adjBonds[n]);
                x[n] = mol.atomX(adj[n]) - mol.atomX(atom);
                y[n] = mol.atomY(adj[n]) - mol.atomY(atom);
                if (mol.is3D()) {
                    z[n] = mol.atomZ(adj[n]) - mol.atomZ(atom);
                }
                else if (bfr == atom) {
                    if (bt == WebMolKit.Molecule.BONDTYPE_INCLINED) {
                        z[n] = 1;
                        numWedges++;
                    }
                    else if (bt == WebMolKit.Molecule.BONDTYPE_DECLINED) {
                        z[n] = -1;
                        numWedges++;
                    }
                }
                let dsq = WebMolKit.norm_xyz(x[n], y[n], z[n]);
                if (dsq < 0.01 * 0.01) {
                    numShort++;
                    if (numShort > 1)
                        return null;
                }
            }
            if (adjBonds.length == 3) {
                adj.push(0);
                if (!mol.is3D() && numWedges == 1) {
                    let th0 = Math.atan2(y[0], x[0]), th1 = Math.atan2(y[1], x[1]), th2 = Math.atan2(y[2], x[2]);
                    let i1 = 1, i2 = 2;
                    if (WebMolKit.angleDiffPos(th1, th0) > WebMolKit.angleDiffPos(th2, th0)) {
                        i2 = 1;
                        i1 = 2;
                    }
                    x[0] = 1.5;
                    y[0] = 0;
                    x[1] = -0.75;
                    y[i1] = 1.3;
                    x[2] = -0.75;
                    y[i2] = -1.3;
                }
                else {
                    x[3] = -(x[0] + x[1] + x[2]);
                    y[3] = -(y[0] + y[1] + y[2]);
                    z[3] = -(z[0] + z[1] + z[2]);
                    let dsq = WebMolKit.norm_xyz(x[3], y[3], z[3]);
                    if (dsq < 0.01 * 0.01)
                        return null;
                    let inv = 1.0 / Math.sqrt(dsq);
                    x[3] *= inv;
                    y[3] *= inv;
                    z[3] *= inv;
                }
            }
            let one = 0, two = 0;
            for (let i = 1; i <= 6; i++) {
                let a = 0, b = 0;
                if (i == 1) {
                    a = 1;
                    b = 2;
                }
                else if (i == 2) {
                    a = 2;
                    b = 3;
                }
                else if (i == 3) {
                    a = 3;
                    b = 1;
                }
                else if (i == 4) {
                    a = 2;
                    b = 1;
                }
                else if (i == 5) {
                    a = 3;
                    b = 2;
                }
                else if (i == 6) {
                    a = 1;
                    b = 3;
                }
                let xx = y[a] * z[b] - y[b] * z[a] - x[0];
                let yy = z[a] * x[b] - z[b] * x[a] - y[0];
                let zz = x[a] * y[b] - x[b] * y[a] - z[0];
                if (i <= 3)
                    one += xx * xx + yy * yy + zz * zz;
                else
                    two += xx * xx + yy * yy + zz * zz;
            }
            if (two > one)
                WebMolKit.Vec.swap(adj, 2, 3);
            return adj;
        }
        static rubricSquarePlanar(mol, atom) {
            if (mol.atomAdjCount(atom) != 4)
                return null;
            let adj = mol.atomAdjList(atom);
            let v0 = WebMolKit.MolUtil.atomVec3(mol, atom);
            let v1 = WebMolKit.MolUtil.atomVec3(mol, adj[0]);
            WebMolKit.Vec.subFromArray(v1, v0);
            let v2 = WebMolKit.MolUtil.atomVec3(mol, adj[1]);
            WebMolKit.Vec.subFromArray(v2, v0);
            let v3 = WebMolKit.MolUtil.atomVec3(mol, adj[2]);
            WebMolKit.Vec.subFromArray(v3, v0);
            let v4 = WebMolKit.MolUtil.atomVec3(mol, adj[3]);
            WebMolKit.Vec.subFromArray(v4, v0);
            let d2 = WebMolKit.GeomUtil.dist2(v1, v2), d3 = WebMolKit.GeomUtil.dist2(v1, v3), d4 = WebMolKit.GeomUtil.dist2(v1, v4);
            if (d2 > d3 && d2 >= d4) {
                WebMolKit.Vec.swap(adj, 1, 2);
                let tmp = v2;
                v2 = v3;
                v3 = tmp;
            }
            else if (d4 > d3) {
                WebMolKit.Vec.swap(adj, 3, 2);
                let tmp = v4;
                v4 = v3;
                v3 = tmp;
            }
            const MIN_ANGLE = 45 * WebMolKit.DEGRAD, MAX_ANGLE = 135 * WebMolKit.DEGRAD;
            let th12 = WebMolKit.GeomUtil.acuteAngle(v1, v2);
            if (th12 < MIN_ANGLE || th12 > MAX_ANGLE)
                return null;
            let th23 = WebMolKit.GeomUtil.acuteAngle(v2, v3);
            if (th23 < MIN_ANGLE || th23 > MAX_ANGLE)
                return null;
            let th34 = WebMolKit.GeomUtil.acuteAngle(v3, v4);
            if (th34 < MIN_ANGLE || th34 > MAX_ANGLE)
                return null;
            let th41 = WebMolKit.GeomUtil.acuteAngle(v4, v1);
            if (th41 < MIN_ANGLE || th41 > MAX_ANGLE)
                return null;
            return adj;
        }
        static rubricOctahedral(mol, atom) {
            const nadj = mol.atomAdjCount(atom);
            if (nadj != 5 && nadj != 6)
                return null;
            let adj = mol.atomAdjList(atom), bonds = mol.atomAdjBonds(atom);
            if (nadj == 5) {
                adj.push(0);
                bonds.push(0);
            }
            if (!mol.is3D()) {
                let numWedges = 0;
                for (let b of bonds)
                    if (b > 0) {
                        const bt = mol.bondType(b);
                        if (bt == WebMolKit.Molecule.BONDTYPE_INCLINED || bt == WebMolKit.Molecule.BONDTYPE_DECLINED)
                            numWedges++;
                    }
                if ((nadj == 5 && numWedges < 1) || (nadj == 6 && numWedges < 2))
                    return null;
            }
            const THRESH = 0.1, THRESHSQ = THRESH * THRESH;
            let v0 = WebMolKit.MolUtil.atomVec3(mol, atom);
            let v = [[], [], [], [], [], []];
            for (let n = 0; n < nadj; n++) {
                v[n] = WebMolKit.MolUtil.atomVec3(mol, adj[n]);
                WebMolKit.Vec.subFromArray(v[n], v0);
                let mag = WebMolKit.GeomUtil.magnitude(v[n]);
                if (mag < THRESH)
                    return null;
                WebMolKit.Vec.mulBy(v[n], 1 / mag);
                let bt = mol.bondType(bonds[n]);
                if (bt == WebMolKit.Molecule.BONDTYPE_INCLINED) {
                    if (mol.bondFrom(bonds[n]) == atom)
                        v[n][2] += 1;
                    else
                        v[n][2] -= 1;
                }
                else if (bt == WebMolKit.Molecule.BONDTYPE_DECLINED) {
                    if (mol.bondFrom(bonds[n]) == atom)
                        v[n][2] -= 1;
                    else
                        v[n][2] += 1;
                }
            }
            if (nadj == 5) {
                v[5] = [0, 0, 0];
                for (let n = 0; n < 5; n++)
                    WebMolKit.Vec.subFromArray(v[5], v[n]);
                let mag = WebMolKit.GeomUtil.magnitude(v[5]);
                if (mag < THRESH)
                    return null;
                WebMolKit.Vec.mulBy(v[5], 1 / mag);
            }
            let slots = [-1, -1, -1, -1, 0, 1];
            let bestOpposite = WebMolKit.GeomUtil.acuteAngle(v[0], v[1]);
            for (let i = 0; i < 5; i++)
                for (let j = (i == 0 ? 2 : i + 1); j < 6; j++) {
                    let theta = WebMolKit.GeomUtil.acuteAngle(v[i], v[j]);
                    if (theta > bestOpposite) {
                        slots[4] = i;
                        slots[5] = j;
                        bestOpposite = theta;
                    }
                }
            let axial = WebMolKit.Vec.sub(v[slots[5]], v[slots[4]]);
            let bestOrthogonal = Number.POSITIVE_INFINITY;
            for (let n = 0; n < 6; n++)
                if (n != slots[4] && n != slots[5]) {
                    let delta = Math.abs((90 * WebMolKit.DEGRAD) - WebMolKit.GeomUtil.acuteAngle(v[n], axial));
                    if (delta < bestOrthogonal) {
                        slots[0] = n;
                        bestOrthogonal = delta;
                    }
                }
            for (let s = 1; s <= 2; s++) {
                let cross = WebMolKit.GeomUtil.crossProduct(axial, v[slots[s - 1]]);
                let bestOrient = Number.POSITIVE_INFINITY;
                for (let n = 0; n < 6; n++) {
                    if (n == slots[4] || n == slots[5] || n == slots[0] || n == slots[1])
                        continue;
                    let delta = WebMolKit.GeomUtil.acuteAngle(v[n], cross);
                    if (delta < bestOrient) {
                        slots[s] = n;
                        bestOrient = delta;
                    }
                }
            }
            for (let n = 0; n < 6; n++)
                if (slots.indexOf(n) < 0) {
                    slots[3] = n;
                    break;
                }
            let rubric = [0, 0, 0, 0, 0, 0];
            for (let n = 0; n < 6; n++)
                rubric[n] = slots[n] < 0 ? 0 : adj[slots[n]];
            return rubric;
        }
        static rubricBondSides(mol, bond) {
            const bfr = mol.bondFrom(bond), bto = mol.bondTo(bond);
            const nfr = mol.atomAdjCount(bfr), nto = mol.atomAdjCount(bto);
            if (nfr < 2 || nfr > 3 || nto < 2 || nto > 3)
                return null;
            let adj1 = mol.atomAdjList(bfr), adj2 = mol.atomAdjList(bto);
            let f1 = 0, f2 = 0, t1 = 0, t2 = 0;
            for (let i = 0; i < adj1.length; i++) {
                if (adj1[i] != bto) {
                    if (f1 == 0)
                        f1 = adj1[i];
                    else
                        f2 = adj1[i];
                }
            }
            for (let i = 0; i < adj2.length; i++) {
                if (adj2[i] != bfr) {
                    if (t1 == 0)
                        t1 = adj2[i];
                    else
                        t2 = adj2[i];
                }
            }
            if (f1 > 0 && f2 > 0 && mol.atomElement(f1) == 'H') {
                let f = f1;
                f1 = f2;
                f2 = f;
            }
            if (t1 > 0 && t2 > 0 && mol.atomElement(t1) == 'H') {
                let t = t1;
                t1 = t2;
                t2 = t;
            }
            let vfr = WebMolKit.MolUtil.atomVec3(mol, bfr), vto = WebMolKit.MolUtil.atomVec3(mol, bto);
            let vbond = WebMolKit.Vec.sub(vto, vfr);
            let vf1 = WebMolKit.Vec.sub(WebMolKit.MolUtil.atomVec3(mol, f1), vfr), vt1 = WebMolKit.Vec.sub(WebMolKit.MolUtil.atomVec3(mol, t1), vto);
            const THRESHSQ = 0.1 * 0.1;
            let xf1 = WebMolKit.GeomUtil.crossProduct(vf1, vbond);
            if (WebMolKit.GeomUtil.magnitude2(xf1) < THRESHSQ)
                return null;
            let xt1 = WebMolKit.GeomUtil.crossProduct(vt1, vbond);
            if (WebMolKit.GeomUtil.magnitude2(xt1) < THRESHSQ)
                return null;
            let xf1N = WebMolKit.Vec.neg(xf1);
            let keepF1T1 = WebMolKit.GeomUtil.dist2(xf1, xt1) < WebMolKit.GeomUtil.dist2(xf1N, xt1);
            let keepF2T1 = keepF1T1, keepF1T2 = keepF1T1, keepF2T2 = keepF1T1;
            let vf2 = null, vt2 = null, xf2 = null, xt2 = null, xf2N = null;
            if (f2 > 0) {
                vf2 = WebMolKit.Vec.sub(WebMolKit.MolUtil.atomVec3(mol, f2), vfr);
                if (WebMolKit.GeomUtil.magnitude2(vf2) < THRESHSQ) {
                    if (mol.atomElement(f2) != 'H')
                        return null;
                }
                else {
                    xf2 = WebMolKit.GeomUtil.crossProduct(vf2, vbond);
                    if (WebMolKit.GeomUtil.magnitude2(xf2) < THRESHSQ)
                        return null;
                    xf2N = WebMolKit.Vec.neg(xf2);
                    keepF2T1 = WebMolKit.GeomUtil.dist2(xf2, xt1) > WebMolKit.GeomUtil.dist2(xf2N, xt1);
                }
            }
            if (t2 > 0) {
                vt2 = WebMolKit.Vec.sub(WebMolKit.MolUtil.atomVec3(mol, t2), vto);
                if (WebMolKit.GeomUtil.magnitude2(vt2) < THRESHSQ) {
                    if (mol.atomElement(t2) != 'H')
                        return null;
                }
                else {
                    xt2 = WebMolKit.GeomUtil.crossProduct(vt2, vbond);
                    if (WebMolKit.GeomUtil.magnitude2(xt2) < THRESHSQ)
                        return null;
                    keepF1T2 = WebMolKit.GeomUtil.dist2(xf1, xt2) > WebMolKit.GeomUtil.dist2(xf1N, xt2);
                }
            }
            if (xf2 != null && xt2 != null) {
                keepF2T2 = WebMolKit.GeomUtil.dist2(xf2, xt2) < WebMolKit.GeomUtil.dist2(xf2N, xt2);
            }
            if (keepF1T1 && keepF2T1 && keepF1T2 && keepF2T2)
                return [f1, f2, t1, t2];
            if (!keepF1T1 && !keepF2T1 && !keepF1T2 && !keepF2T2)
                return [f1, f2, t2, t1];
            return null;
        }
        buildTetraChirality() {
            const mol = this.mol, na = mol.numAtoms, nb = mol.numBonds;
            let haswedge = WebMolKit.Vec.booleanArray(false, na);
            for (let n = 1; n <= nb; n++) {
                if (mol.bondType(n) == WebMolKit.Molecule.BONDTYPE_INCLINED || mol.bondType(n) == WebMolKit.Molecule.BONDTYPE_DECLINED)
                    haswedge[mol.bondFrom(n) - 1] = true;
            }
            skip_atom: for (let n = 1; n <= na; n++) {
                this.chiralTetra[n - 1] = Stereochemistry.STEREO_NONE;
                let adj = mol.atomAdjList(n);
                if (!(adj.length == 4 || (adj.length == 3 && mol.atomHydrogens(n) == 1)))
                    continue;
                if (adj.length == 3 && (this.isH[adj[0] - 1] || this.isH[adj[1] - 1] || this.isH[adj[2] - 1]))
                    continue;
                for (let i = 0; i < adj.length - 1; i++) {
                    for (let j = i + 1; j < adj.length; j++) {
                        if (this.priority[adj[i] - 1] == this.priority[adj[j] - 1])
                            continue skip_atom;
                    }
                }
                if (!haswedge[n - 1] && !mol.is3D()) {
                    this.chiralTetra[n - 1] = Stereochemistry.STEREO_UNKNOWN;
                    continue;
                }
                let rubric = Stereochemistry.rubricTetrahedral(mol, n);
                if (rubric == null)
                    continue;
                let pri = [
                    rubric[0] == 0 ? 0 : this.priority[rubric[0] - 1],
                    rubric[1] == 0 ? 0 : this.priority[rubric[1] - 1],
                    rubric[2] == 0 ? 0 : this.priority[rubric[2] - 1],
                    rubric[3] == 0 ? 0 : this.priority[rubric[3] - 1]
                ];
                pri = WebMolKit.Vec.idxSort(pri);
                let parity = WebMolKit.Permutation.parityIdentity(pri);
                this.chiralTetra[n - 1] = (parity & 1) == 0 ? Stereochemistry.STEREO_POS : Stereochemistry.STEREO_NEG;
            }
        }
        buildBondCisTrans() {
            const mol = this.mol, na = mol.numAtoms, nb = mol.numBonds;
            let sf = [0, 0], st = [0, 0];
            let ringMask = WebMolKit.Vec.booleanArray(false, nb);
            for (let rsz = 3; rsz <= 7; rsz++) {
                for (let r of mol.findRingsOfSize(rsz)) {
                    for (let n = 0; n < r.length; n++) {
                        let b = mol.findBond(r[n], r[n < r.length - 1 ? n + 1 : 0]);
                        ringMask[b - 1] = true;
                    }
                }
            }
            skip_bond: for (let n = 1; n <= nb; n++) {
                this.cistransBond[n - 1] = Stereochemistry.STEREO_NONE;
                if (mol.bondOrder(n) != 2 || this.meta.isBondAromatic(n) || ringMask[n - 1])
                    continue;
                let bfr = mol.bondFrom(n), bto = mol.bondTo(n);
                let adj1 = mol.atomAdjList(bfr), adj2 = mol.atomAdjList(bto);
                if (adj1.length <= 1 || adj2.length <= 1 || adj1.length > 3 || adj2.length > 3)
                    continue;
                if (adj1.length == 2 && (this.isH[adj1[0] - 1] || this.isH[adj1[1] - 1]))
                    continue;
                if (adj2.length == 2 && (this.isH[adj2[0] - 1] || this.isH[adj2[1] - 1]))
                    continue;
                for (let i = 0; i < adj1.length - 1; i++)
                    if (adj1[i] != bfr)
                        for (let j = i + 1; j < adj1.length; j++)
                            if (adj1[j] != bfr)
                                if (this.priority[adj1[i] - 1] == this.priority[adj1[j] - 1])
                                    continue skip_bond;
                for (let i = 0; i < adj2.length - 1; i++)
                    if (adj2[i] != bto)
                        for (let j = i + 1; j < adj2.length; j++)
                            if (adj2[j] != bto)
                                if (this.priority[adj2[i] - 1] == this.priority[adj2[j] - 1])
                                    continue skip_bond;
                if (mol.bondType(n) == WebMolKit.Molecule.BONDTYPE_UNKNOWN) {
                    this.cistransBond[n - 1] = Stereochemistry.STEREO_UNKNOWN;
                    continue;
                }
                let rubric = Stereochemistry.rubricBondSides(mol, n);
                if (rubric == null)
                    continue;
                let pf1 = rubric[0] == 0 ? 0 : this.priority[rubric[0] - 1];
                let pf2 = rubric[1] == 0 ? 0 : this.priority[rubric[1] - 1];
                let pt1 = rubric[2] == 0 ? 0 : this.priority[rubric[2] - 1];
                let pt2 = rubric[3] == 0 ? 0 : this.priority[rubric[3] - 1];
                this.cistransBond[n - 1] = ((pf1 < pf2) == (pt1 < pt2)) ? Stereochemistry.STEREO_POS : Stereochemistry.STEREO_NEG;
            }
        }
        buildPlanarCisTrans() {
            const mol = this.mol, na = mol.numAtoms, nb = mol.numBonds;
            skip_atom: for (let n = 1; n <= na; n++) {
                this.cistransPlanar[n - 1] = Stereochemistry.STEREO_NONE;
                if (mol.atomAdjCount(n) != 4)
                    continue;
                if (WebMolKit.Chemistry.ELEMENT_BLOCKS[mol.atomicNumber(n)] < 3)
                    continue;
                let adj = mol.atomAdjList(n);
                for (let i = 0; i < adj.length; i++) {
                    let count = 0;
                    for (let j = 0; j < adj.length; j++) {
                        if (this.priority[adj[i] - 1] == this.priority[adj[j] - 1])
                            count++;
                    }
                    if (count >= 3)
                        continue skip_atom;
                }
                let rubric = Stereochemistry.rubricSquarePlanar(mol, n);
                if (rubric == null)
                    continue;
                let pri = [
                    rubric[0] == 0 ? 0 : this.priority[rubric[0] - 1],
                    rubric[1] == 0 ? 0 : this.priority[rubric[1] - 1],
                    rubric[2] == 0 ? 0 : this.priority[rubric[2] - 1],
                    rubric[3] == 0 ? 0 : this.priority[rubric[3] - 1]
                ];
                let parity = WebMolKit.Permutation.parityOrder(pri);
                this.cistransPlanar[n - 1] = (parity & 1) == 0 ? Stereochemistry.STEREO_POS : Stereochemistry.STEREO_NEG;
            }
        }
        buildOctaChirality() {
        }
        buildPriority() {
            const mol = this.mol, na = mol.numAtoms, nb = mol.numBonds;
            let cipgr = [];
            for (let n = 0; n < na; n++)
                cipgr.push(WebMolKit.Vec.numberArray(-1, mol.atomHydrogens(n + 1)));
            for (let n = 1; n <= nb; n++) {
                let bf = mol.bondFrom(n) - 1, bt = mol.bondTo(n) - 1, bo = mol.bondOrder(n);
                if (this.meta.isBondAromatic(n))
                    bo = 2;
                if (bf != bt)
                    for (let i = 0; i < bo; i++) {
                        cipgr[bf].push(bt);
                        cipgr[bt].push(bf);
                    }
            }
            this.priority = WebMolKit.Vec.numberArray(0, na);
            let anyActualH = false;
            for (let n = 0; n < na; n++) {
                this.priority[n] = mol.atomicNumber(n + 1);
                if (this.priority[n] == 1)
                    anyActualH = true;
            }
            let prigr = [];
            for (let n = 0; n < na; n++)
                prigr.push([]);
            while (true) {
                for (let n = 0; n < na; n++) {
                    let cip = cipgr[n], pri = [];
                    for (let i = 0; i < cip.length; i++)
                        pri.push(cip[i] < 0 ? 1 : this.priority[cip[i]]);
                    WebMolKit.Vec.sort(pri);
                    prigr[n] = pri;
                }
                let groups = this.sortAndGroup(this.priority);
                let nextpri = anyActualH ? 0 : 1;
                let repartitioned = false;
                for (let n = 0; n < groups.length; n++) {
                    let g = groups[n];
                    for (let p = 0; p < g.length - 1;) {
                        const i1 = g[p], i2 = g[p + 1];
                        let cmp = 0, sz = Math.max(prigr[i1].length, prigr[i2].length);
                        for (let i = 0; i < sz; i++) {
                            let v1 = i < prigr[i1].length ? prigr[i1][i] : 0, v2 = i < prigr[i2].length ? prigr[i2][i] : 0;
                            if (v1 < v2) {
                                cmp = -1;
                                break;
                            }
                            if (v1 > v2) {
                                cmp = 1;
                                break;
                            }
                        }
                        if (cmp > 0) {
                            g[p] = i2;
                            g[p + 1] = i1;
                            if (p > 0)
                                p--;
                        }
                        else
                            p++;
                    }
                    for (let i = 0; i < g.length; i++) {
                        if (i == 0)
                            nextpri++;
                        else if (prigr[g[i]].length != prigr[g[i - 1]].length) {
                            nextpri++;
                            repartitioned = true;
                        }
                        else {
                            for (let j = 0; j < prigr[g[i]].length; j++)
                                if (prigr[g[i]][j] != prigr[g[i - 1]][j]) {
                                    nextpri++;
                                    repartitioned = true;
                                    break;
                                }
                        }
                        this.priority[g[i]] = nextpri;
                    }
                }
                if (!repartitioned)
                    break;
            }
        }
        sortAndGroup(val) {
            let uset = new Set();
            for (let v of val)
                uset.add(v);
            let unique = Array.from(uset);
            WebMolKit.Vec.sort(unique);
            let ret = [];
            for (let n = 0; n < unique.length; n++)
                ret.push([]);
            for (let n = 0; n < val.length; n++) {
                let grp = unique.indexOf(val[n]);
                ret[grp].push(n);
            }
            return ret;
        }
    }
    Stereochemistry.STEREO_NONE = 0;
    Stereochemistry.STEREO_POS = 1;
    Stereochemistry.STEREO_NEG = 2;
    Stereochemistry.STEREO_UNKNOWN = 3;
    Stereochemistry.STEREO_BROKEN = 4;
    Stereochemistry.RUBRIC_EQUIV_TETRA = [
        [0, 1, 2, 3], [0, 2, 3, 1], [0, 3, 1, 2], [1, 0, 3, 2], [1, 2, 0, 3], [1, 3, 2, 0],
        [2, 0, 1, 3], [2, 1, 3, 0], [2, 3, 0, 1], [3, 0, 2, 1], [3, 1, 0, 2], [3, 2, 1, 0]
    ];
    Stereochemistry.RUBRIC_EQUIV_SIDES = [
        [0, 1, 2, 3], [1, 0, 3, 2], [2, 3, 0, 1], [3, 2, 1, 0]
    ];
    Stereochemistry.RUBRIC_EQUIV_SQUARE = [
        [0, 1, 2, 3], [0, 3, 2, 1], [1, 2, 3, 0], [1, 0, 3, 2],
        [2, 1, 0, 3], [2, 3, 0, 1], [3, 2, 1, 0], [3, 0, 1, 2]
    ];
    Stereochemistry.RUBRIC_EQUIV_OCTA = [
        [0, 1, 2, 3, 4, 5], [0, 3, 2, 1, 5, 4], [0, 4, 2, 5, 3, 1], [0, 5, 2, 4, 1, 3],
        [1, 0, 3, 2, 5, 4], [1, 2, 3, 0, 4, 5], [1, 4, 3, 5, 0, 2], [1, 5, 3, 4, 2, 0],
        [2, 1, 0, 3, 5, 4], [2, 3, 0, 1, 4, 5], [2, 4, 0, 5, 1, 3], [2, 5, 0, 4, 3, 1],
        [3, 0, 1, 2, 4, 5], [3, 2, 1, 0, 5, 4], [3, 4, 1, 5, 2, 0], [3, 5, 1, 4, 0, 2],
        [4, 0, 5, 2, 1, 3], [4, 1, 5, 3, 2, 0], [4, 2, 5, 0, 3, 1], [4, 3, 5, 1, 0, 2],
        [5, 0, 4, 2, 3, 1], [5, 1, 4, 3, 0, 2], [5, 2, 4, 0, 1, 3], [5, 3, 4, 1, 2, 0]
    ];
    WebMolKit.Stereochemistry = Stereochemistry;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class MetaMolecule {
        constructor(mol) {
            this.mol = mol;
            this.atomArom = null;
            this.bondArom = null;
            this.rubricTetra = null;
            this.rubricSquare = null;
            this.rubricOcta = null;
            this.rubricSides = null;
            this.hash = null;
            this.heavyHash = null;
            this.uniqueElements = null;
            this.piAtom = null;
        }
        calculateStrictAromaticity() {
            let mol = this.mol;
            this.atomArom = WebMolKit.Vec.booleanArray(false, mol.numAtoms);
            this.bondArom = WebMolKit.Vec.booleanArray(false, mol.numBonds);
            let rings = mol.findRingsOfSize(6);
            const nr = rings.length;
            if (nr == 0)
                return;
            this.ensurePiAtoms();
            let mask = WebMolKit.Vec.booleanArray(false, nr);
            for (let n = 0; n < nr; n++) {
                for (let i = 0; i < rings[n].length; i++) {
                    let a = rings[n][i];
                    if (!this.piAtom[a - 1]) {
                        mask[n] = true;
                        break;
                    }
                    let b = mol.findBond(a, rings[n][i == rings[n].length - 1 ? 0 : i + 1]);
                    let bo = mol.bondOrder(b);
                    if (bo != 1 && bo != 2) {
                        mask[n] = true;
                        break;
                    }
                }
            }
            while (true) {
                let anyChange = false;
                for (let n = 0; n < nr; n++)
                    if (!mask[n]) {
                        let phase1 = true, phase2 = true;
                        for (let i = 0; i < rings[n].length; i++) {
                            let b = mol.findBond(rings[n][i], rings[n][i == rings[n].length - 1 ? 0 : i + 1]);
                            if (this.bondArom[b - 1])
                                continue;
                            let bo = mol.bondOrder(b);
                            phase1 = phase1 && bo == (2 - (i & 1));
                            phase2 = phase2 && bo == (1 + (i & 1));
                        }
                        if (!phase1 && !phase2)
                            continue;
                        for (let i = 0; i < rings[n].length; i++) {
                            let b = mol.findBond(rings[n][i], rings[n][i == rings[n].length - 1 ? 0 : i + 1]);
                            this.bondArom[b - 1] = true;
                        }
                        mask[n] = true;
                        anyChange = true;
                    }
                if (!anyChange)
                    break;
            }
            for (let n = 0; n < this.bondArom.length; n++)
                if (this.bondArom[n]) {
                    this.atomArom[mol.bondFrom(n + 1) - 1] = true;
                    this.atomArom[mol.bondTo(n + 1) - 1] = true;
                }
        }
        calculateRelaxedAromaticity() {
            let mol = this.mol;
            this.atomArom = WebMolKit.Vec.booleanArray(false, mol.numAtoms);
            this.bondArom = WebMolKit.Vec.booleanArray(false, mol.numBonds);
            this.ensurePiAtoms();
            const na = mol.numAtoms, nb = mol.numBonds;
            let electrons = WebMolKit.Vec.numberArray(0, na);
            let exocyclic = WebMolKit.Vec.booleanArray(false, na);
            for (let n = 1; n <= na; n++) {
                let atno = mol.atomicNumber(n);
                electrons[n - 1] = (WebMolKit.Chemistry.ELEMENT_BLOCKS[atno] == 2 ? WebMolKit.Chemistry.ELEMENT_VALENCE[atno] : 0) - mol.atomCharge(n) - mol.atomHydrogens(n)
                    - mol.atomUnpaired(n);
            }
            for (let n = 1; n <= nb; n++) {
                const bfr = mol.bondFrom(n), bto = mol.bondTo(n), bo = mol.bondOrder(n);
                electrons[bfr - 1] -= bo;
                electrons[bto - 1] -= bo;
                if (bo == 2) {
                    const rblk1 = mol.atomRingBlock(bfr), rblk2 = mol.atomRingBlock(bto);
                    if (rblk1 > 0 && rblk1 != rblk2)
                        exocyclic[bfr - 1] = true;
                    if (rblk2 > 0 && rblk2 != rblk1)
                        exocyclic[bto - 1] = true;
                }
            }
            let rings = [];
            for (let rsz = 3; rsz <= 7; rsz++)
                for (let rng of mol.findRingsOfSize(rsz)) {
                    let valid = true;
                    for (let n = 0; n < rsz; n++) {
                        const a = rng[n];
                        if (!this.piAtom[a - 1] && electrons[a - 1] < 2 && !exocyclic[a - 1]) {
                            valid = false;
                            break;
                        }
                        let b = mol.findBond(a, rng[n < rsz - 1 ? n + 1 : 0]);
                        let bo = mol.bondOrder(b);
                        if (bo != 1 && bo != 2) {
                            valid = false;
                            break;
                        }
                    }
                    if (valid)
                        rings.push(rng);
                }
            while (rings.length > 0) {
                let anyChange = false;
                for (let n = 0; n < rings.length; n++) {
                    let r = rings[n];
                    let paths = [0];
                    for (let i = 0; i < r.length; i++) {
                        const a = r[i];
                        const b1 = mol.findBond(a, r[i < r.length - 1 ? i + 1 : 0]);
                        const b2 = mol.findBond(a, r[i > 0 ? i - 1 : r.length - 1]);
                        if (this.bondArom[b1 - 1]) {
                            for (let j = paths.length - 1; j >= 0; j--) {
                                const e = paths[j] + 2;
                                if (paths.indexOf(e) < 0)
                                    paths = WebMolKit.Vec.append(paths, e);
                            }
                        }
                        else if (mol.bondOrder(b1) == 2)
                            WebMolKit.Vec.addTo(paths, 2);
                        else if (electrons[a - 1] >= 2 && mol.bondOrder(b1) == 1 && mol.bondOrder(b2) == 1)
                            WebMolKit.Vec.addTo(paths, 2);
                    }
                    let arom = false;
                    for (let e of paths) {
                        if (e == 2 && r.length == 3) {
                            arom = true;
                            break;
                        }
                        if (e == 6) {
                            arom = true;
                            break;
                        }
                    }
                    if (arom) {
                        for (let i = 0; i < r.length; i++) {
                            let a = r[i], b = mol.findBond(a, r[i < r.length - 1 ? i + 1 : 0]);
                            this.atomArom[a - 1] = true;
                            this.bondArom[b - 1] = true;
                        }
                        rings.splice(n, 1);
                        n--;
                        anyChange = true;
                    }
                }
                if (!anyChange)
                    break;
            }
        }
        calculateStereoRubric() {
            const mol = this.mol, na = mol.numAtoms, nb = mol.numBonds;
            this.rubricTetra = new Array(na);
            this.rubricSquare = new Array(na);
            this.rubricOcta = new Array(na);
            this.rubricSides = new Array(nb);
            for (let n = 1; n <= na; n++) {
                let blk = WebMolKit.Chemistry.ELEMENT_BLOCKS[mol.atomicNumber(n)];
                let adjc = mol.atomAdjCount(n), hc = mol.atomHydrogens(n);
                if (blk == 2 && ((adjc == 3 && hc == 1) || (adjc == 4 && hc == 0))) {
                    this.rubricTetra[n - 1] = WebMolKit.Stereochemistry.rubricTetrahedral(mol, n);
                }
                if (blk >= 3 && adjc == 4 && hc == 0) {
                    this.rubricSquare[n - 1] = WebMolKit.Stereochemistry.rubricSquarePlanar(mol, n);
                }
                if (blk >= 3 && (adjc == 5 || adjc == 6) && hc == 0) {
                    this.rubricOcta[n - 1] = WebMolKit.Stereochemistry.rubricOctahedral(mol, n);
                }
            }
            for (let n = 1; n <= mol.numBonds; n++) {
                if (mol.bondOrder(n) != 2 || this.isBondAromatic(n))
                    continue;
                let bfr = mol.bondFrom(n), bto = mol.bondTo(n);
                let blk1 = WebMolKit.Chemistry.ELEMENT_BLOCKS[mol.atomicNumber(bfr)];
                let blk2 = WebMolKit.Chemistry.ELEMENT_BLOCKS[mol.atomicNumber(bto)];
                let adjc1 = mol.atomAdjCount(bfr), hc1 = mol.atomHydrogens(bfr);
                let adjc2 = mol.atomAdjCount(bto), hc2 = mol.atomHydrogens(bto);
                if (blk1 == 2 && blk2 == 2 && (adjc1 + hc1 == 3 && hc1 <= 1) && (adjc2 + hc2 == 3 && hc2 <= 1)) {
                    this.rubricSides[n - 1] = WebMolKit.Stereochemistry.rubricBondSides(mol, n);
                }
            }
        }
        isAtomAromatic(atom) {
            return this.atomArom == null ? false : this.atomArom[atom - 1];
        }
        isBondAromatic(bond) {
            return this.bondArom == null ? false : this.bondArom[bond - 1];
        }
        bondOrderArom(bond) {
            return this.bondArom != null && this.bondArom[bond - 1] ? -1 : this.mol.bondOrder(bond);
        }
        getAtomAromaticity() {
            return this.atomArom == null ? null : this.atomArom.slice(0);
        }
        getBondAromaticity() {
            return this.bondArom == null ? null : this.bondArom.slice(0);
        }
        getUniqueElements() {
            if (this.uniqueElements == null) {
                this.uniqueElements = [];
                for (let n = 1; n <= this.mol.numAtoms; n++) {
                    let el = this.mol.atomElement(n);
                    if (this.uniqueElements.indexOf(el) < 0)
                        this.uniqueElements.push(el);
                }
            }
            return this.uniqueElements;
        }
        static createRubric(mol) {
            if (mol == null)
                return null;
            let meta = new MetaMolecule(mol);
            meta.calculateStereoRubric();
            return meta;
        }
        static createStrict(mol) {
            if (mol == null)
                return null;
            let meta = new MetaMolecule(mol);
            meta.calculateStrictAromaticity();
            return meta;
        }
        static createStrictRubric(mol) {
            if (mol == null)
                return null;
            let meta = new MetaMolecule(mol);
            meta.calculateStrictAromaticity();
            meta.calculateStereoRubric();
            return meta;
        }
        static createRelaxed(mol) {
            if (mol == null)
                return null;
            let meta = new MetaMolecule(mol);
            meta.calculateRelaxedAromaticity();
            return meta;
        }
        static createRelaxedRubric(mol) {
            if (mol == null)
                return null;
            let meta = new MetaMolecule(mol);
            meta.calculateRelaxedAromaticity();
            meta.calculateStereoRubric();
            return meta;
        }
        ensurePiAtoms() {
            if (this.piAtom != null)
                return;
            this.piAtom = WebMolKit.Vec.booleanArray(false, this.mol.numAtoms);
            for (let n = 1; n <= this.mol.numBonds; n++)
                if (this.mol.bondOrder(n) == 2) {
                    {
                        this.piAtom[this.mol.bondFrom(n) - 1] = true;
                        this.piAtom[this.mol.bondTo(n) - 1] = true;
                    }
                }
        }
    }
    WebMolKit.MetaMolecule = MetaMolecule;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let crc_table = [];
    function make_crc_table() {
        if (crc_table.length > 0)
            return;
        for (let n = 0; n < 256; n++) {
            let c = n;
            for (let i = 0; i < 8; i++)
                if ((c & 1) != 0)
                    c = 0xEDB88320 ^ (c >>> 1);
                else
                    c = (c >>> 1);
            crc_table.push(c);
        }
    }
    const BOOT_CRC = 0xFFFFFFFF;
    function start_crc() { return BOOT_CRC; }
    function feed_crc(crc, byte) {
        let idx = (crc ^ byte) & 0xFF;
        return crc_table[idx] ^ (crc >>> 8);
    }
    function end_crc(crc) { return crc ^ BOOT_CRC; }
    class CircularFingerprints {
        constructor(meta, kind) {
            this.meta = meta;
            this.kind = kind;
            this.hookApplyNewFP = null;
            this.hookConsiderNewFP = null;
            this.identity = [];
            this.resolvedChiral = [];
            this.atomGroup = [];
            this.fplist = [];
            this.amask = [];
            this.atomAdj = [];
            this.bondAdj = [];
            make_crc_table();
        }
        calculate() {
            let mol = this.meta.mol, na = mol.numAtoms;
            this.identity = WebMolKit.Vec.numberArray(0, na);
            this.resolvedChiral = WebMolKit.Vec.booleanArray(false, na);
            for (let n = 0; n < na; n++)
                this.atomGroup.push([]);
            this.amask = WebMolKit.Vec.booleanArray(false, na);
            for (let n = 0; n < na; n++) {
                this.amask[n] = mol.atomicNumber(n + 1) >= 2 && !WebMolKit.MolUtil.hasAbbrev(mol, n + 1);
                this.atomAdj.push([]);
                this.bondAdj.push([]);
            }
            for (let n = 0; n < na; n++) {
                if (!this.amask[n])
                    continue;
                this.atomAdj[n] = mol.atomAdjList(n + 1);
                this.bondAdj[n] = mol.atomAdjBonds(n + 1);
                for (let i = this.atomAdj[n].length - 1; i >= 0; i--)
                    if (!this.amask[this.atomAdj[n][i] - 1]) {
                        this.atomAdj[n].splice(i, 1);
                        this.bondAdj[n].splice(i, 1);
                    }
            }
            for (let n = 0; n < na; n++)
                if (this.amask[n]) {
                    this.identity[n] = this.initialIdentityECFP(n + 1);
                    this.atomGroup[n] = [n + 1];
                    this.applyNewFP({ 'hashCode': this.identity[n], 'iteration': 0, 'atoms': this.atomGroup[n] });
                }
            let niter = this.kind;
            for (let iter = 1; iter <= niter; iter++) {
                let newident = WebMolKit.Vec.numberArray(0, na);
                for (let n = 0; n < na; n++)
                    if (this.amask[n])
                        newident[n] = this.circularIterate(iter, n + 1);
                this.identity = newident;
                for (let n = 0; n < na; n++)
                    if (this.amask[n]) {
                        this.atomGroup[n] = this.growAtoms(this.atomGroup[n]);
                        this.considerNewFP({ 'hashCode': this.identity[n], 'iteration': iter, 'atoms': this.atomGroup[n] });
                    }
            }
        }
        static create(meta, kind) {
            if (meta instanceof WebMolKit.Molecule)
                meta = WebMolKit.MetaMolecule.createStrictRubric(meta);
            let circ = new CircularFingerprints(meta, kind);
            circ.calculate();
            return circ;
        }
        getMolecule() { return this.meta.mol; }
        get numFP() { return this.fplist.length; }
        getFP(idx) { return this.fplist[idx]; }
        getFingerprints() { return this.fplist.slice(0); }
        getUniqueHashes() {
            let hashes = new Set();
            for (let fp of this.fplist)
                hashes.add(fp.hashCode);
            return WebMolKit.Vec.sorted(Array.from(hashes));
        }
        getFoldedHashes(maxBits) {
            let andBits = maxBits - 1;
            let hashes = new Set();
            for (let fp of this.fplist)
                hashes.add(fp.hashCode & andBits);
            return WebMolKit.Vec.sorted(Array.from(hashes));
        }
        static tanimoto(hash1, hash2) {
            let shared = 0, total = 0;
            let sz1 = hash1.length, sz2 = hash2.length;
            if (sz1 == 0 && sz2 == 0)
                return 0;
            let i1 = 0, i2 = 0;
            while (i1 < sz1 || i2 < sz2) {
                if (i1 == sz1) {
                    total += sz2 - i2;
                    break;
                }
                if (i2 == sz2) {
                    total += sz1 - i1;
                    break;
                }
                let v1 = hash1[i1], v2 = hash2[i2];
                if (v1 == v2) {
                    shared += 1;
                    i1 += 1;
                    i2 += 1;
                }
                else if (v1 < v2)
                    i1 += 1;
                else
                    i2 += 1;
                total += 1;
            }
            return shared / total;
        }
        initialIdentityECFP(atom) {
            const mol = this.meta.mol;
            let adj = mol.atomAdjList(atom);
            let nheavy = 0, nhydr = mol.atomHydrogens(atom);
            for (let a of adj)
                if (mol.atomElement(a) == 'H')
                    nhydr++;
                else
                    nheavy++;
            let atno = mol.atomicNumber(atom);
            let degree = Math.max(0, WebMolKit.Chemistry.ELEMENT_BONDING[atno] - nhydr);
            let chg = mol.atomCharge(atom);
            let inring = mol.atomRingBlock(atom) > 0 ? 1 : 0;
            let crc = start_crc();
            crc = feed_crc(crc, (nheavy << 4) | degree);
            crc = feed_crc(crc, atno);
            crc = feed_crc(crc, chg + 0x80);
            crc = feed_crc(crc, (nhydr << 4) | inring);
            return end_crc(crc);
        }
        circularIterate(iter, atom) {
            let adj = this.atomAdj[atom - 1], adjb = this.bondAdj[atom - 1];
            var seq = WebMolKit.Vec.numberArray(0, 2 + 2 * adj.length);
            seq[0] = iter;
            seq[1] = this.identity[atom - 1];
            for (let n = 0; n < adj.length; n++) {
                seq[2 * n + 2] = this.meta.isBondAromatic(adjb[n]) ? 0xF : this.meta.mol.bondOrder(adjb[n]);
                seq[2 * n + 3] = this.identity[adj[n] - 1];
            }
            let p = 0;
            while (p < adj.length - 1) {
                let i = 2 + 2 * p;
                if (seq[i] > seq[i + 2] || (seq[i] == seq[i + 2] && seq[i + 1] > seq[i + 3])) {
                    WebMolKit.Vec.swap(seq, i, i + 2);
                    WebMolKit.Vec.swap(seq, i + 1, i + 3);
                    if (p > 0)
                        p--;
                }
                else
                    p++;
            }
            var crc = start_crc();
            for (let n = 0; n < seq.length; n += 2) {
                crc = feed_crc(crc, seq[n]);
                let v = seq[n + 1];
                crc = feed_crc(crc, v >> 24);
                crc = feed_crc(crc, (v >> 16) & 0xFF);
                crc = feed_crc(crc, (v >> 8) & 0xFF);
                crc = feed_crc(crc, v & 0xFF);
            }
            if (!this.resolvedChiral[atom - 1] && WebMolKit.Vec.arrayLength(this.meta.rubricTetra) > 0 && this.meta.rubricTetra[atom - 1] != null) {
                let ru = this.meta.rubricTetra[atom - 1];
                let par = [
                    ru[0] == 0 ? 0 : this.identity[ru[0] - 1],
                    ru[1] == 0 ? 0 : this.identity[ru[1] - 1],
                    ru[2] == 0 ? 0 : this.identity[ru[2] - 1],
                    ru[3] == 0 ? 0 : this.identity[ru[3] - 1]
                ];
                if (par[0] != par[1] && par[0] != par[2] && par[0] != par[3] && par[1] != par[2] && par[1] != par[3] && par[2] != par[3]) {
                    crc = feed_crc(crc, WebMolKit.Permutation.parityOrder(par) + 1);
                    this.resolvedChiral[atom - 1] = true;
                }
            }
            return end_crc(crc);
        }
        growAtoms(atoms) {
            let mask = WebMolKit.Vec.booleanArray(false, this.meta.mol.numAtoms);
            for (let n = 0; n < atoms.length; n++) {
                mask[atoms[n] - 1] = true;
                for (let a of this.atomAdj[atoms[n] - 1])
                    mask[a - 1] = true;
            }
            return WebMolKit.Vec.add(WebMolKit.Vec.maskIdx(mask), 1);
        }
        applyNewFP(newFP) {
            if (this.hookApplyNewFP)
                this.hookApplyNewFP(newFP);
            this.fplist.push(newFP);
        }
        considerNewFP(newFP) {
            if (this.hookConsiderNewFP)
                this.hookConsiderNewFP(newFP);
            let hit = -1;
            let fp = null;
            for (let n = 0; n < this.fplist.length; n++) {
                let lookFP = this.fplist[n];
                if (WebMolKit.Vec.equals(lookFP.atoms, newFP.atoms)) {
                    fp = lookFP;
                    hit = n;
                    break;
                }
            }
            if (hit < 0) {
                this.fplist.push(newFP);
                return;
            }
            if (fp.iteration < newFP.iteration || fp.hashCode < newFP.hashCode)
                return;
            this.fplist[hit] = newFP;
        }
    }
    CircularFingerprints.CLASS_ECFP0 = 0;
    CircularFingerprints.CLASS_ECFP2 = 1;
    CircularFingerprints.CLASS_ECFP4 = 2;
    CircularFingerprints.CLASS_ECFP6 = 3;
    WebMolKit.CircularFingerprints = CircularFingerprints;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class BayesianModel {
        constructor(classType, folding) {
            this.classType = classType;
            this.folding = folding;
            this.numActive = 0;
            this.inHash = {};
            this.training = [];
            this.activity = [];
            this.contribs = {};
            this.lowThresh = 0;
            this.highThresh = 0;
            this.range = 0;
            this.invRange = 0;
            this.estimates = null;
            this.rocX = null;
            this.rocY = null;
            this.rocType = null;
            this.rocAUC = Number.NaN;
            this.trainingSize = 0;
            this.trainingActives = 0;
            this.truthTP = 0;
            this.truthFP = 0;
            this.truthTN = 0;
            this.truthFN = 0;
            this.precision = Number.NaN;
            this.recall = Number.NaN;
            this.specificity = Number.NaN;
            this.statF1 = Number.NaN;
            this.statKappa = Number.NaN;
            this.statMCC = Number.NaN;
            this.noteTitle = null;
            this.noteOrigin = null;
            this.noteField = null;
            this.noteComments = null;
            if (this.folding == null)
                this.folding = 0;
        }
        addMolecule(mol, active, hashes) {
            if (WebMolKit.MolUtil.isBlank(mol) && hashes == null)
                throw 'Molecule cannot be blank or null.';
            if (hashes == null) {
                let meta = WebMolKit.MetaMolecule.createStrictRubric(mol);
                let circ = new WebMolKit.CircularFingerprints(meta, this.classType);
                circ.calculate();
                hashes = this.folding == 0 ? circ.getUniqueHashes() : circ.getFoldedHashes(this.folding);
            }
            if (active)
                this.numActive++;
            this.training.push(hashes);
            this.activity.push(active);
            for (let h of hashes) {
                let stash = this.inHash[h];
                if (stash == null)
                    stash = [0, 0];
                if (active)
                    stash[0]++;
                stash[1]++;
                this.inHash[h] = stash;
            }
        }
        build() {
            this.trainingSize = this.training.length;
            this.trainingActives = this.numActive;
            this.contribs = [];
            const sz = this.training.length;
            const invSz = 1.0 / sz;
            const P_AT = this.numActive * invSz;
            for (let hashStr in this.inHash) {
                let hash = parseInt(hashStr);
                const AT = this.inHash[hash];
                const A = AT[0], T = AT[1];
                const Pcorr = (A + 1) / (T * P_AT + 1);
                const P = Math.log(Pcorr);
                this.contribs[hash] = P;
            }
            this.lowThresh = Number.POSITIVE_INFINITY;
            this.highThresh = Number.NEGATIVE_INFINITY;
            for (let fp of this.training) {
                let val = 0;
                for (let hash of fp)
                    val += this.contribs[hash];
                this.lowThresh = Math.min(this.lowThresh, val);
                this.highThresh = Math.max(this.highThresh, val);
            }
            this.range = this.highThresh - this.lowThresh;
            this.invRange = this.range > 0 ? 1 / this.range : 0;
        }
        predictMolecule(mol) {
            if (WebMolKit.MolUtil.isBlank(mol))
                throw 'Molecule cannot be blank or null.';
            let meta = WebMolKit.MetaMolecule.createStrictRubric(mol);
            let circ = new WebMolKit.CircularFingerprints(meta, this.classType);
            circ.calculate();
            let hashes = this.folding == 0 ? circ.getUniqueHashes() : circ.getFoldedHashes(this.folding);
            return this.predictFP(hashes);
        }
        predictFP(hashes) {
            let val = 0;
            for (let h of hashes) {
                let c = this.contribs[h];
                if (c != null)
                    val += c;
            }
            return val;
        }
        scalePredictor(pred) {
            if (this.range == 0)
                return pred >= this.highThresh ? 1 : 0;
            return (pred - this.lowThresh) * this.invRange;
        }
        scaleArcTan(scaled) {
            const INVPI = 1.0 / Math.PI;
            return Math.atan(2 * scaled - 1) * INVPI + 0.5;
        }
        calculateOverlap(mol) {
            if (WebMolKit.MolUtil.isBlank(mol))
                throw 'Molecule cannot be blank or null.';
            let meta = WebMolKit.MetaMolecule.createStrictRubric(mol);
            let circ = new WebMolKit.CircularFingerprints(meta, this.classType);
            circ.calculate();
            let hashes = this.folding == 0 ? circ.getUniqueHashes() : circ.getFoldedHashes(this.folding);
            return this.calculateOverlapFP(hashes);
        }
        calculateOverlapFP(hashes) {
            if (hashes.length == 0)
                return 0;
            let count = 0.0;
            for (let h of hashes)
                if (this.contribs[h] != null)
                    count++;
            return hashes.length == 1 ? count : count / hashes.length;
        }
        calculateAtomPredictors(mol) {
            const na = mol.numAtoms;
            let atomic = WebMolKit.Vec.numberArray(0, na);
            let predHashes = new Set();
            let cover = this.determineCoverage(mol, predHashes);
            for (let h in cover) {
                let c = this.contribs[h];
                if (c == null)
                    continue;
                let mask = cover[h];
                let msz = WebMolKit.Vec.maskCount(mask);
                let invSz = 1.0 / msz;
                for (let n = 0; n < na; n++)
                    if (mask[n])
                        atomic[n] += c * invSz;
            }
            let pred = 0;
            for (let h of predHashes) {
                let c = this.contribs[h];
                if (c != null)
                    pred += c;
            }
            const SCALE_STDDEV_TO = 0.25;
            const invN = 1.0 / na;
            WebMolKit.Vec.addTo(atomic, -WebMolKit.Vec.sum(atomic) * invN);
            let stdDev = 0;
            for (let a of atomic)
                stdDev += a * a;
            stdDev = Math.sqrt(stdDev * invN);
            if (stdDev > 1E-3)
                WebMolKit.Vec.mulBy(atomic, SCALE_STDDEV_TO / stdDev);
            let scaled = (this.scalePredictor(pred) - 0.5) * 2;
            if (scaled < -1)
                scaled = -1;
            else if (scaled > 1)
                scaled = 1;
            WebMolKit.Vec.addTo(atomic, scaled);
            return atomic;
        }
        validateLeaveOneOut() {
            const sz = this.training.length;
            this.estimates = [];
            for (let n = 0; n < sz; n++)
                this.estimates.push(this.singleLeaveOneOut(n));
            this.calculateROC();
            this.calculateTruth();
            this.rocType = 'leave-one-out';
        }
        validateFiveFold() {
            this.rocType = 'five-fold';
            this.validateNfold(5);
        }
        validateThreeFold() {
            this.rocType = 'three-fold';
            this.validateNfold(3);
        }
        clearTraining() {
            this.training = [];
            this.activity = [];
        }
        serialise() {
            let lines = [];
            let fpname = this.classType == WebMolKit.CircularFingerprints.CLASS_ECFP0 ? 'ECFP0' : this.classType == WebMolKit.CircularFingerprints.CLASS_ECFP2 ? 'ECFP2'
                : this.classType == WebMolKit.CircularFingerprints.CLASS_ECFP4 ? 'ECFP4' : this.classType == WebMolKit.CircularFingerprints.CLASS_ECFP6 ? 'ECFP6'
                    : '?';
            lines.push('Bayesian!(' + fpname + ',' + this.folding + ',' + this.lowThresh + ',' + this.highThresh + ')');
            let sorted = [];
            for (let hash in this.contribs)
                sorted.push(parseInt(hash));
            WebMolKit.Vec.sort(sorted);
            for (let hash of sorted) {
                const c = this.contribs[hash];
                lines.push(hash + '=' + c);
            }
            lines.push('training:size=' + this.trainingSize);
            lines.push('training:actives=' + this.trainingActives);
            if (!Number.isNaN(this.rocAUC))
                lines.push('roc:auc=' + this.rocAUC);
            if (this.rocType != null)
                lines.push('roc:type=' + this.rocType);
            if (this.rocX != null && this.rocY != null) {
                let x = 'roc:x=';
                for (let n = 0; n < this.rocX.length; n++)
                    x += (n == 0 ? '' : ',') + this.rocX[n];
                lines.push(x);
                let y = 'roc:y=';
                for (let n = 0; n < this.rocY.length; n++)
                    y += (n == 0 ? '' : ',') + this.rocY[n];
                lines.push(y);
            }
            if (this.truthTP > 0 || this.truthFP > 0 || this.truthTN > 0 || this.truthFP > 0) {
                lines.push('truth:TP=' + this.truthTP);
                lines.push('truth:FP=' + this.truthFP);
                lines.push('truth:TN=' + this.truthTN);
                lines.push('truth:FN=' + this.truthFN);
                lines.push('truth:precision=' + this.precision);
                lines.push('truth:recall=' + this.recall);
                lines.push('truth:specificity=' + this.specificity);
                lines.push('truth:F1=' + this.statF1);
                lines.push('truth:kappa=' + this.statKappa);
                lines.push('truth:MCC=' + this.statMCC);
            }
            if (this.noteTitle)
                lines.push('note:title=' + this.noteTitle);
            if (this.noteOrigin)
                lines.push('note:origin=' + this.noteOrigin);
            if (this.noteField)
                lines.push('note:field=' + this.noteField);
            if (this.noteComments)
                for (let comment of this.noteComments)
                    lines.push('note:comment=' + comment);
            lines.push('!End');
            return lines.join('\n');
        }
        static deserialise(str) {
            let lines = str.split('\n'), lnum = 0;
            function readLine() { return lnum >= lines.length ? null : lines[lnum++].trim(); }
            let line = readLine();
            if (line == null || !line.startsWith('Bayesian!(') || !line.endsWith(')'))
                throw 'Not a serialised Bayesian model.';
            let bits = line.substring(10, line.length - 1).split(',');
            if (bits.length < 4)
                throw 'Invalid header content';
            let classType = bits[0] == 'ECFP0' ? WebMolKit.CircularFingerprints.CLASS_ECFP0 : bits[0] == 'ECFP2' ? WebMolKit.CircularFingerprints.CLASS_ECFP2
                : bits[0] == 'ECFP4' ? WebMolKit.CircularFingerprints.CLASS_ECFP4 : bits[0] == 'ECFP6' ? WebMolKit.CircularFingerprints.CLASS_ECFP6
                    : 0;
            if (classType == 0)
                throw 'Unknown fingerprint type: ' + bits[0];
            let folding = parseInt(bits[1]);
            if (folding > 0)
                for (let f = folding; f > 0; f = f >> 1) {
                    if ((f & 1) == 1 && f != 1) {
                        folding = -1;
                        break;
                    }
                }
            if (folding < 0)
                throw 'Fingerprint folding ' + bits[1] + ' invalid: must be 0 or power of 2.';
            let model = new BayesianModel(classType, folding);
            model.lowThresh = parseFloat(bits[2]);
            model.highThresh = parseFloat(bits[3]);
            model.range = model.highThresh - model.lowThresh;
            model.invRange = model.range > 0 ? 1 / model.range : 0;
            const PTN_HASHLINE = new RegExp('^(-?\\d+)=([\\d\\.Ee-]+)');
            while (true) {
                line = readLine();
                if (line == null)
                    throw 'Missing correct terminator line.';
                if (line == '!End')
                    break;
                let match = PTN_HASHLINE.exec(line);
                if (match != null) {
                    let hash = parseInt(match[1]);
                    let c = parseFloat(match[2]);
                    model.contribs[hash] = c;
                }
                else if (line.startsWith('training:size='))
                    model.trainingSize = parseInt(line.substring(14));
                else if (line.startsWith('training:actives='))
                    model.trainingActives = parseInt(line.substring(17));
                else if (line.startsWith('roc:auc='))
                    model.rocAUC = parseFloat(line.substring(8));
                else if (line.startsWith('roc:type='))
                    model.rocType = line.substring(9);
                else if (line.startsWith('roc:x=')) {
                    model.rocX = [];
                    for (let str of line.substring(6).split(','))
                        model.rocX.push(parseFloat(str));
                }
                else if (line.startsWith('roc:y=')) {
                    model.rocY = [];
                    for (let str of line.substring(6).split(','))
                        model.rocY.push(parseFloat(str));
                }
                else if (line.startsWith('truth:TP='))
                    model.truthTP = parseInt(line.substring(9), 0);
                else if (line.startsWith('truth:FP='))
                    model.truthFP = parseInt(line.substring(9), 0);
                else if (line.startsWith('truth:TN='))
                    model.truthTN = parseInt(line.substring(9), 0);
                else if (line.startsWith('truth:FN='))
                    model.truthFN = parseInt(line.substring(9), 0);
                else if (line.startsWith('truth:precision='))
                    model.precision = parseFloat(line.substring(16));
                else if (line.startsWith('truth:recall='))
                    model.recall = parseFloat(line.substring(13));
                else if (line.startsWith('truth:specificity='))
                    model.specificity = parseFloat(line.substring(18));
                else if (line.startsWith('truth:F1='))
                    model.statF1 = parseFloat(line.substring(9));
                else if (line.startsWith('truth:kappa='))
                    model.statKappa = parseFloat(line.substring(12));
                else if (line.startsWith('truth:MCC='))
                    model.statMCC = parseFloat(line.substring(10));
                else if (line.startsWith('note:title='))
                    model.noteTitle = line.substring(11);
                else if (line.startsWith('note:origin='))
                    model.noteOrigin = line.substring(12);
                else if (line.startsWith('note:field='))
                    model.noteField = line.substring(11);
                else if (line.startsWith('note:comment=')) {
                    if (model.noteComments == null)
                        model.noteComments = [];
                    model.noteComments.push(line.substring(13));
                }
            }
            return model;
        }
        singleLeaveOneOut(idx) {
            let exclActive = this.activity[idx];
            let exclSet = new Set();
            for (let fp of this.training[idx])
                exclSet.add(fp);
            const sz = this.training.length, szN = sz - 1;
            const invSzN = 1.0 / szN;
            const activeN = exclActive ? this.numActive - 1 : this.numActive;
            const P_AT = activeN * invSzN;
            let val = 0;
            for (let hashStr in this.inHash) {
                const hash = parseInt(hashStr);
                if (!exclSet.has(hash))
                    continue;
                const AT = this.inHash[hash];
                const A = AT[0] - (exclActive ? 1 : 0), T = AT[1] - 1;
                const Pcorr = (A + 1) / (T * P_AT + 1);
                const P = Math.log(Pcorr);
                val += P;
            }
            return val;
        }
        validateNfold(nsegs) {
            const sz = this.training.length;
            let order = WebMolKit.Vec.numberArray(0, sz);
            let p = 0;
            for (let n = 0; n < sz; n++)
                if (this.activity[n])
                    order[p++] = n;
            for (let n = 0; n < sz; n++)
                if (!this.activity[n])
                    order[p++] = n;
            let segContribs = [];
            for (let n = 0; n < nsegs; n++)
                segContribs.push(this.buildPartial(order, n, nsegs));
            this.estimates = WebMolKit.Vec.numberArray(0, sz);
            for (let n = 0; n < sz; n++)
                this.estimates[order[n]] = this.estimatePartial(order, n, segContribs[n % nsegs]);
            this.calculateROC();
            this.calculateTruth();
        }
        buildPartial(order, seg, div) {
            const sz = this.training.length;
            let na = 0, nt = 0;
            let ih = {};
            for (let n = 0; n < sz; n++) {
                if (n % div != seg) {
                    const active = this.activity[order[n]];
                    if (active)
                        na++;
                    nt++;
                    for (let h of this.training[order[n]]) {
                        let stash = ih[h];
                        if (stash == null)
                            stash = [0, 0];
                        if (active)
                            stash[0]++;
                        stash[1]++;
                        ih[h] = stash;
                    }
                }
            }
            let segContribs = {};
            const invSz = 1.0 / nt;
            const P_AT = na * invSz;
            for (let hashStr in ih) {
                let hash = parseInt(hashStr);
                const AT = ih[hash];
                const A = AT[0], T = AT[1];
                const Pcorr = (A + 1) / (T * P_AT + 1);
                const P = Math.log(Pcorr);
                segContribs[hash] = P;
            }
            return segContribs;
        }
        estimatePartial(order, idx, segContrib) {
            let val = 0;
            for (let h of this.training[order[idx]]) {
                let c = segContrib[h];
                if (c != null)
                    val += c;
            }
            return val;
        }
        calculateROC() {
            const sz = this.training.length;
            let idx = WebMolKit.Vec.idxSort(this.estimates);
            let thresholds = [];
            thresholds.push(this.lowThresh - 0.01 * this.range);
            for (let n = 0; n < sz - 1; n++) {
                const th1 = this.estimates[idx[n]], th2 = this.estimates[idx[n + 1]];
                if (th1 == th2)
                    continue;
                thresholds.push(0.5 * (th1 + th2));
            }
            thresholds.push(this.highThresh + 0.01 * this.range);
            this.rocX = [];
            this.rocY = [];
            let rocT = [];
            let posTrue = 0, posFalse = 0, ipos = 0;
            let invPos = 1.0 / this.numActive, invNeg = 1.0 / (sz - this.numActive);
            for (let n = 0; n < thresholds.length; n++) {
                const th = thresholds[n];
                for (; ipos < sz; ipos++) {
                    if (th < this.estimates[idx[ipos]])
                        break;
                    if (this.activity[idx[ipos]])
                        posTrue++;
                    else
                        posFalse++;
                }
                const x = posFalse * invNeg;
                const y = posTrue * invPos;
                const rsz = rocT.length;
                if (rsz > 0 && x == this.rocX[rsz - 1] && y == this.rocY[rsz - 1])
                    continue;
                this.rocX[rsz] = 1 - x;
                this.rocY[rsz] = 1 - y;
                rocT[rsz] = th;
            }
            this.rocX = WebMolKit.Vec.reverse(this.rocX);
            this.rocY = WebMolKit.Vec.reverse(this.rocY);
            rocT = WebMolKit.Vec.reverse(rocT);
            this.calibrateThresholds(this.rocX, this.rocY, rocT);
            this.rocAUC = 0;
            for (let n = 0; n < rocT.length - 1; n++) {
                const w = this.rocX[n + 1] - this.rocX[n], h = 0.5 * (this.rocY[n] + this.rocY[n + 1]);
                this.rocAUC += w * h;
            }
            const DIST = 0.002, DSQ = DIST * DIST;
            let gx = [], gy = [];
            gx.push(this.rocX[0]);
            gy.push(this.rocY[0]);
            for (let i = 1; i < rocT.length - 1; i++) {
                const dx = this.rocX[i] - gx[gx.length - 1], dy = this.rocY[i] - gy[gy.length - 1];
                if (WebMolKit.norm2_xy(dx, dy) < DSQ)
                    continue;
                gx.push(this.rocX[i]);
                gy.push(this.rocY[i]);
            }
            gx.push(this.rocX[rocT.length - 1]);
            gy.push(this.rocY[rocT.length - 1]);
        }
        calculateTruth() {
            let thresh = 0.5 * (this.lowThresh + this.highThresh);
            this.truthTP = this.truthFP = this.truthTN = this.truthFN = 0;
            for (let n = 0; n < this.activity.length; n++) {
                let actual = this.activity[n], predicted = this.estimates[n] >= thresh;
                if (actual && predicted)
                    this.truthTP++;
                else if (!actual && predicted)
                    this.truthFP++;
                else if (actual && !predicted)
                    this.truthFN++;
                else if (!actual && !predicted)
                    this.truthTN++;
            }
            const TP = this.truthTP, FP = this.truthFP, TN = this.truthTN, FN = this.truthFN;
            let invSize = 1.0 / this.activity.length;
            this.precision = TP / (TP + FP);
            this.recall = TP / (TP + FN);
            this.specificity = TN / (TN + FP);
            this.statF1 = 2 * (this.precision * this.recall) / (this.precision + this.recall);
            let Pyes = (TP + FP) * invSize * (TP + FN) * invSize;
            let Pno = (FP + TN) * invSize * (FN + TN) * invSize;
            let P0 = (TP + TN) * invSize, Pe = Pyes + Pno;
            this.statKappa = (P0 - Pe) / (1 - Pe);
            let mccOver = TP * TN - FP * FN;
            let mccUnder = (TP + FP) * (TP + FN) * (TN + FP) * (TN + FN);
            this.statMCC = mccOver / Math.sqrt(mccUnder);
        }
        calibrateThresholds(x, y, t) {
            const sz = t.length;
            let idx = 0;
            for (let n = 1; n < sz; n++)
                if (y[n] - x[n] > y[idx] - x[idx])
                    idx = n;
            const midThresh = t[idx];
            let idxX = 0, idxY = sz - 1;
            for (; idxX < idx - 1; idxX++)
                if (x[idxX] > 0)
                    break;
            for (; idxY > idx + 1; idxY--)
                if (y[idxY] < 1)
                    break;
            let delta = Math.min(t[idxX] - midThresh, midThresh - t[idxY]);
            this.lowThresh = midThresh - delta;
            this.highThresh = midThresh + delta;
            this.range = 2 * delta;
            this.invRange = this.range > 0 ? 1 / this.range : 0;
        }
        determineCoverage(mol, approvedHashes) {
            const na = mol.numAtoms;
            let cover = {};
            const andBits = this.folding == 0 ? 0xFFFFFFFF : this.folding - 1;
            let meta = WebMolKit.MetaMolecule.createStrictRubric(mol);
            let circ = new WebMolKit.CircularFingerprints(meta, this.classType);
            let collectFP = (fp) => {
                let idx = fp.hashCode & andBits;
                if (this.contribs[idx] == null)
                    return;
                let mask = cover[idx];
                if (mask == null) {
                    mask = WebMolKit.Vec.booleanArray(false, na);
                    cover[idx] = mask;
                }
                for (let a of fp.atoms)
                    mask[a - 1] = true;
            };
            circ.hookApplyNewFP = collectFP;
            circ.hookConsiderNewFP = collectFP;
            circ.calculate();
            if (approvedHashes != null) {
                let hashes = this.folding == 0 ? circ.getUniqueHashes() : circ.getFoldedHashes(this.folding);
                for (let h of hashes)
                    approvedHashes.add(h);
            }
            return cover;
        }
    }
    WebMolKit.BayesianModel = BayesianModel;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class BuildSMILES {
        constructor(mol, pri = null) {
            this.mol = mol;
            this.pri = pri;
        }
        generate() {
            if (this.mol.numAtoms == 0)
                return '';
            this.walkSequence();
            this.findLinks();
            return this.assemble();
        }
        walkSequence() {
            const mol = this.mol, na = mol.numAtoms, pri = this.pri;
            this.seq = [];
            let visited = WebMolKit.Vec.booleanArray(false, na);
            let pos = 1;
            if (pri != null)
                pos = WebMolKit.Vec.idxMin(pri) + 1;
            for (let count = 0; count < na; count++) {
                this.seq.push(pos);
                visited[pos - 1] = true;
                if (count == na - 1)
                    break;
                let adj = mol.atomAdjList(pos);
                let cc = mol.atomConnComp(pos);
                pos = 0;
                for (let n = 0; n < adj.length; n++)
                    if (!visited[adj[n] - 1]) {
                        if (pri == null) {
                            pos = adj[n];
                            break;
                        }
                        if (pos == 0 || pri[adj[n] - 1] < pri[pos - 1])
                            pos = adj[n];
                    }
                if (pos > 0)
                    continue;
                for (let n = 1; n <= na; n++)
                    if (!visited[n - 1] && mol.atomConnComp(n) == cc) {
                        if (pri == null) {
                            pos = n;
                            break;
                        }
                        if (pos == 0 || pri[n - 1] < pri[pos - 1])
                            pos = n;
                    }
                if (pos > 0)
                    continue;
                for (let n = 1; n <= na; n++)
                    if (!visited[n - 1]) {
                        if (pri == null) {
                            pos = n;
                            break;
                        }
                        if (pos == 0 || pri[n - 1] < pri[pos - 1])
                            pos = n;
                    }
                if (pos == 0)
                    throw 'Walk sequence failed.';
            }
        }
        findLinks() {
            const mol = this.mol, na = mol.numAtoms, pri = this.pri, seq = this.seq;
            this.link = [];
            this.conn = [];
            for (let n = 0; n < na; n++) {
                this.link.push([]);
                this.conn.push([]);
            }
            let invseq = WebMolKit.Vec.numberArray(0, na);
            for (let n = 0; n < na; n++)
                invseq[seq[n] - 1] = n;
            let inPlay = WebMolKit.Vec.numberArray(-1, na + 1);
            for (let n = 0; n < na; n++) {
                let prev = n > 0 ? seq[n - 1] : 0;
                let cur = seq[n];
                let next = n < na - 1 ? seq[n + 1] : 0;
                for (let i = 1; i <= na; i++)
                    if (inPlay[i] >= 0 && n > inPlay[i])
                        inPlay[i] = -1;
                let adj = mol.atomAdjList(cur);
                if (pri != null)
                    for (let p = 0; p < adj.length - 1;) {
                        if (invseq[adj[p] - 1] > invseq[adj[p + 1] - 1]) {
                            WebMolKit.Vec.swap(adj, p, p + 1);
                            if (p > 0)
                                p--;
                        }
                        else
                            p++;
                    }
                for (let i = 0; i < adj.length; i++) {
                    if (adj[i] == prev || adj[i] == next)
                        continue;
                    let nbr = adj[i];
                    if (invseq[cur - 1] > invseq[nbr - 1])
                        continue;
                    let num = -1;
                    for (let j = 1; j <= na; j++)
                        if (inPlay[j] < 0) {
                            num = j;
                            inPlay[j] = Math.max(invseq[cur - 1], invseq[nbr - 1]);
                            break;
                        }
                    this.link[cur - 1].push(num);
                    this.conn[cur - 1].push(nbr);
                    this.link[nbr - 1].push(num);
                    this.conn[nbr - 1].push(cur);
                }
            }
        }
        assemble() {
            const mol = this.mol, na = mol.numAtoms, seq = this.seq, link = this.link, conn = this.conn;
            let smiles = '';
            const NON_ESCAPED = ['C', 'N', 'O', 'P', 'S'];
            for (let n = 0; n < na; n++) {
                let prev = n > 0 ? seq[n - 1] : 0, cur = seq[n];
                let bidx = prev > 0 ? mol.findBond(prev, cur) : 0;
                if (prev > 0 && bidx == 0)
                    smiles += '.';
                if (bidx > 0) {
                    let bo = mol.bondOrder(bidx);
                    if (bo == 2)
                        smiles += '=';
                    else if (bo == 3)
                        smiles += '#';
                }
                let el = mol.atomElement(cur);
                if (WebMolKit.Chemistry.ELEMENTS.indexOf(el) < 0)
                    el = '*';
                let chg = mol.atomCharge(cur);
                if (NON_ESCAPED.indexOf(el) >= 0 && chg == 0) {
                    smiles += el;
                }
                else {
                    smiles += '[' + el;
                    if (chg > 0)
                        smiles += '+' + chg;
                    if (chg < 0)
                        smiles += chg;
                    smiles += ']';
                }
                let num = link[cur - 1];
                if (num != null)
                    for (let i = 0; i < num.length; i++) {
                        bidx = mol.findBond(cur, conn[cur - 1][i]);
                        let bo = mol.bondOrder(bidx);
                        if (bo == 2)
                            smiles += '=';
                        else if (bo == 3)
                            smiles += '#';
                        if (num[i] < 10)
                            smiles += num[i];
                        else
                            smiles += '%' + num[i];
                    }
            }
            return smiles;
        }
    }
    WebMolKit.BuildSMILES = BuildSMILES;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class DataSheetStream {
        static readXML(strXML) {
            let xmlDoc = new DOMParser().parseFromString(strXML, 'application/xml');
            if (xmlDoc == null)
                return null;
            let root = xmlDoc.documentElement;
            if (root == null)
                return null;
            let ds = new WebMolKit.DataSheet();
            let summary = WebMolKit.findNode(root, 'Summary');
            if (summary == null)
                return null;
            ds.setTitle(WebMolKit.nodeText(WebMolKit.findNode(summary, 'Title')));
            ds.setDescription(WebMolKit.nodeText(WebMolKit.findNode(summary, 'Description')));
            let extRoot = WebMolKit.findNode(root, 'Extension');
            if (extRoot != null) {
                let extList = WebMolKit.findNodes(extRoot, 'Ext');
                for (let n = 0; n < extList.length; n++) {
                    let ext = extList[n];
                    ds.appendExtension(ext.getAttribute("name"), ext.getAttribute("type"), WebMolKit.nodeText(ext));
                }
            }
            let header = WebMolKit.findNode(root, 'Header');
            let numCols = parseInt(header.getAttribute("ncols")), numRows = parseInt(header.getAttribute("nrows"));
            let colList = WebMolKit.findNodes(header, 'Column');
            if (colList.length != numCols)
                return null;
            for (let n = 0; n < numCols; n++) {
                let col = colList[n];
                let id = parseInt(col.getAttribute("id"));
                if (id != n + 1)
                    return null;
                ds.appendColumn(col.getAttribute("name"), col.getAttribute("type"), WebMolKit.nodeText(col));
            }
            let row = WebMolKit.findNode(root, 'Content').firstElementChild;
            let rowidx = 0;
            while (row) {
                if (parseInt(row.getAttribute("id")) != rowidx + 1)
                    return null;
                ds.appendRow();
                let col = row.firstElementChild;
                while (col) {
                    let colidx = parseInt(col.getAttribute("id")) - 1;
                    let ct = ds.colType(colidx), val = WebMolKit.nodeText(col);
                    if (val == '') { }
                    else if (ct == WebMolKit.DataSheet.COLTYPE_MOLECULE)
                        ds.setObject(rowidx, colidx, val);
                    else if (ct == WebMolKit.DataSheet.COLTYPE_STRING)
                        ds.setString(rowidx, colidx, val);
                    else if (ct == WebMolKit.DataSheet.COLTYPE_REAL)
                        ds.setReal(rowidx, colidx, parseFloat(val));
                    else if (ct == WebMolKit.DataSheet.COLTYPE_INTEGER)
                        ds.setInteger(rowidx, colidx, parseInt(val));
                    else if (ct == WebMolKit.DataSheet.COLTYPE_BOOLEAN)
                        ds.setBoolean(rowidx, colidx, val == 'true' ? true : val == 'false' ? false : null);
                    else if (ct == WebMolKit.DataSheet.COLTYPE_EXTEND)
                        ds.setExtend(rowidx, colidx, val);
                    col = col.nextElementSibling;
                    colidx++;
                }
                row = row.nextElementSibling;
                rowidx++;
            }
            return ds;
        }
        static writeXML(ds) {
            let xml = new DOMParser().parseFromString('<DataSheet/>', 'text/xml');
            let summary = xml.createElement('Summary');
            xml.documentElement.appendChild(summary);
            let title = xml.createElement('Title'), descr = xml.createElement('Description');
            summary.appendChild(title);
            title.appendChild(xml.createTextNode(ds.getTitle()));
            summary.appendChild(descr);
            descr.appendChild(xml.createCDATASection(ds.getDescription()));
            let extension = xml.createElement('Extension');
            xml.documentElement.appendChild(extension);
            for (let n = 0; n < ds.numExtensions; n++) {
                let ext = xml.createElement('Ext');
                extension.appendChild(ext);
                ext.setAttribute('name', ds.getExtName(n));
                ext.setAttribute('type', ds.getExtType(n));
                ext.appendChild(xml.createCDATASection(ds.getExtData(n)));
            }
            let header = xml.createElement('Header');
            xml.documentElement.appendChild(header);
            header.setAttribute('nrows', ds.numRows.toString());
            header.setAttribute('ncols', ds.numCols.toString());
            for (let n = 0; n < ds.numCols; n++) {
                let column = xml.createElement('Column');
                header.appendChild(column);
                column.setAttribute('id', (n + 1).toString());
                column.setAttribute('name', ds.colName(n));
                column.setAttribute('type', ds.colType(n));
                column.appendChild(xml.createTextNode(ds.colDescr(n)));
            }
            let content = xml.createElement('Content');
            xml.documentElement.appendChild(content);
            for (let r = 0; r < ds.numRows; r++) {
                let row = xml.createElement('Row');
                row.setAttribute('id', (r + 1).toString());
                content.appendChild(row);
                for (let c = 0; c < ds.numCols; c++) {
                    let cell = xml.createElement('Cell');
                    cell.setAttribute('id', (c + 1).toString());
                    row.appendChild(cell);
                    let ct = ds.colType(c);
                    let txtNode = null;
                    if (ds.isNull(r, c)) { }
                    else if (ct == WebMolKit.DataSheet.COLTYPE_MOLECULE) {
                        let obj = ds.getObject(r, c);
                        if (obj instanceof WebMolKit.Molecule)
                            obj = WebMolKit.MoleculeStream.writeNative(obj);
                        txtNode = xml.createCDATASection(obj);
                    }
                    else if (ct == WebMolKit.DataSheet.COLTYPE_STRING)
                        txtNode = xml.createCDATASection(ds.getString(r, c));
                    else if (ct == WebMolKit.DataSheet.COLTYPE_REAL)
                        txtNode = xml.createTextNode(ds.getReal(r, c).toString());
                    else if (ct == WebMolKit.DataSheet.COLTYPE_INTEGER)
                        txtNode = xml.createTextNode(ds.getInteger(r, c).toString());
                    else if (ct == WebMolKit.DataSheet.COLTYPE_BOOLEAN)
                        txtNode = xml.createTextNode(ds.getBoolean(r, c).toString());
                    else if (ct == WebMolKit.DataSheet.COLTYPE_EXTEND)
                        txtNode = xml.createCDATASection(ds.getExtend(r, c));
                    if (txtNode != null)
                        cell.appendChild(txtNode);
                }
            }
            return new XMLSerializer().serializeToString(xml.documentElement);
        }
        ;
    }
    WebMolKit.DataSheetStream = DataSheetStream;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class FormatList {
    }
    FormatList.FMT_NATIVE = 'native';
    FormatList.FMT_XMLDS = 'xmlds';
    FormatList.FMT_MDLMOL = 'mdlmol';
    FormatList.FMT_MDLSDF = 'mdlsdf';
    FormatList.FMT_MDLRDF = 'mdlrdf';
    FormatList.FMT_MDLRXN = 'mdlrxn';
    FormatList.GFX_PNG = 'png';
    FormatList.GFX_PNGZIP = 'pngzip';
    FormatList.GFX_SVG = 'svg';
    FormatList.GFX_SVGZIP = 'svgzip';
    FormatList.GFX_PDF = 'pdf';
    FormatList.GFX_PDFZIP = 'pdfzip';
    FormatList.GFX_EPS = 'eps';
    FormatList.GFX_HTML = 'html';
    FormatList.GFX_OPENDOC_ODG = 'odg';
    FormatList.GFX_OPENDOC_ODT = 'odt';
    FormatList.GFX_OPENDOC_ODS = 'ods';
    FormatList.GFX_OOXML_DOCX = 'docx';
    FormatList.GFX_OOXML_XLSX = 'xlsx';
    FormatList.FORMAT_DESCR = {
        'native': 'SketchEl Molecule',
        'xmlds': 'DataSheet XML',
        'mdlmol': 'MDL MOL (single molecule)',
        'mdlsdf': 'MDL SDF (molecules + data)',
        'mdlrdf': 'MDL RDF (reactions + data)',
        'mdlrxn': 'MDL RXN (single reaction)',
        'png': 'PNG image (raster)',
        'pngzip': 'ZIP (multiple PNG files)',
        'svg': 'SVG picture (vector)',
        'svgzip': 'ZIP (multiple SVG files)',
        'pdf': 'PDF diagram (vector)',
        'pdfzip': 'ZIP (multiple PDF files)',
        'eps': 'Encapsulated PostScript (vector)',
        'html': 'HTML with embedded SVG',
        'odg': 'OpenDocument Graphic',
        'odt': 'OpenDocument Text',
        'ods': 'OpenDocument SpreadSheet',
        'docx': 'Microsoft Word',
        'xlsx': 'Microsoft Excel'
    };
    FormatList.FORMAT_EXTN = {
        'native': '.el',
        'xmlds': '.ds',
        'mdlmol': '.mol',
        'mdlsdf': '.sdf',
        'mdlrdf': '.rdf',
        'mdlrxn': '.rxn',
        'png': '.png',
        'pngzip': '_png.zip',
        'svg': '.svg',
        'svgzip': '_svg.zip',
        'pdf': '.pdf',
        'pdfzip': '_pdf.zip',
        'eps': '.eps',
        'html': '.html',
        'odg': '.odg',
        'odt': '.odt',
        'ods': '.ods',
        'docx': '.docx',
        'xlsx': '.xlsx'
    };
    FormatList.FORMAT_MIMETYPE = {
        'native': 'chemical/x-sketchel',
        'xmlds': 'chemical/x-datasheet',
        'mdlmol': 'chemical/x-mdl-molfile',
        'mdlsdf': 'chemical/x-mdl-sdfile',
        'mdlrdf': 'chemical/x-mdl-rdfile',
        'mdlrxn': 'chemical/x-mdl-rxnfile',
        'png': 'image/png',
        'pngzip': 'application/zip',
        'svg': 'image/png',
        'svgzip': 'application/zip',
        'pdf': 'application/pdf',
        'pdfzip': 'application/zip',
        'eps': 'image/eps',
        'html': 'text/html',
        'odg': 'application/vnd.oasis.opendocument.graphics',
        'odt': 'application/vnd.oasis.opendocument.text',
        'ods': 'application/vnd.oasis.opendocument.spreadsheet',
        'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    };
    WebMolKit.FormatList = FormatList;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class QuantityComp {
        constructor(comp, step, type, idx) {
            this.comp = comp;
            this.step = step;
            this.type = type;
            this.idx = idx;
            this.role = 0;
            this.molw = 0;
            this.valueEquiv = 0;
            this.statEquiv = QuantityCalc.STAT_UNKNOWN;
            this.valueMass = QuantityCalc.UNSPECIFIED;
            this.statMass = QuantityCalc.STAT_UNKNOWN;
            this.valueVolume = QuantityCalc.UNSPECIFIED;
            this.statVolume = QuantityCalc.STAT_UNKNOWN;
            this.valueMoles = QuantityCalc.UNSPECIFIED;
            this.statMoles = QuantityCalc.STAT_UNKNOWN;
            this.valueDensity = QuantityCalc.UNSPECIFIED;
            this.statDensity = QuantityCalc.STAT_UNKNOWN;
            this.valueConc = QuantityCalc.UNSPECIFIED;
            this.statConc = QuantityCalc.STAT_UNKNOWN;
            this.valueYield = QuantityCalc.UNSPECIFIED;
            this.statYield = QuantityCalc.STAT_UNKNOWN;
        }
    }
    WebMolKit.QuantityComp = QuantityComp;
    class GreenMetrics {
        constructor() {
            this.step = 0;
            this.idx = 0;
            this.massReact = [];
            this.massProd = [];
            this.massWaste = [];
            this.massProdWaste = [];
            this.molwReact = [];
            this.molwProd = [];
            this.impliedWaste = 0;
            this.isBlank = false;
        }
    }
    WebMolKit.GreenMetrics = GreenMetrics;
    class QuantityCalc {
        constructor(entry) {
            this.entry = entry;
            this.quantities = [];
            this.idxPrimary = [];
            this.idxYield = [];
            this.allMassReact = [];
            this.allMassProd = [];
            this.allMassWaste = [];
            this.greenMetrics = [];
        }
        static isStoichZero(stoich) {
            if (this.isStoichUnity(stoich))
                return false;
            if (parseFloat(stoich) == 0)
                return true;
            return false;
        }
        static isStoichUnity(stoich) {
            if (!stoich || stoich == '1')
                return true;
            let [numer, denom] = this.extractStoichFraction(stoich);
            return numer != 0 && numer == denom;
        }
        static extractStoichFraction(stoich) {
            if (!stoich)
                return [1, 1];
            let numer = 1, denom = 1;
            let i = stoich.indexOf('/');
            if (i < 0) {
                let v = parseFloat(stoich);
                if (v >= 0)
                    numer = v;
            }
            else {
                let v1 = parseFloat(stoich.substring(0, i)), v2 = parseFloat(stoich.substring(i + 1));
                if (v1 >= 0)
                    numer = v1;
                if (v2 >= 0)
                    denom = v2;
            }
            return [numer, denom];
        }
        static extractStoichValue(stoich) {
            let [numer, denom] = this.extractStoichFraction(stoich);
            return denom <= 1 ? numer : numer / denom;
        }
        static stoichAsRatio(stoich) {
            let [numer, denom] = this.extractStoichFraction(stoich);
            if (numer == Math.floor(numer))
                return [numer, denom];
            return this.stoichFractAsRatio(numer);
        }
        static stoichFractAsRatio(fract) {
            if (fract == Math.floor(fract))
                return [fract, 1];
            const MAX_DENOM = QuantityCalc.MAX_DENOM;
            if (QuantityCalc.RATIO_FRACT == null) {
                QuantityCalc.RATIO_FRACT = [];
                for (let p = 0, j = 2; j <= MAX_DENOM; j++)
                    for (let i = 1; i < j && i < MAX_DENOM - 1; i++)
                        QuantityCalc.RATIO_FRACT.push(i * 1.0 / j);
            }
            let whole = Math.floor(fract);
            let resid = fract - whole;
            let bestDiff = Number.MAX_VALUE;
            let bestOver = 1, bestUnder = 1;
            for (let p = 0, j = 2; j <= MAX_DENOM; j++)
                for (let i = 1; i < j && i < MAX_DENOM - 1; i++) {
                    let diff = Math.abs(QuantityCalc.RATIO_FRACT[p++] - resid);
                    if (diff < bestDiff) {
                        bestDiff = diff;
                        bestOver = i;
                        bestUnder = j;
                    }
                }
            return [bestOver + (whole * bestUnder), bestUnder];
        }
        static impliedReagentStoich(reagent, products) {
            if (WebMolKit.MolUtil.isBlank(reagent.mol) || products.length == 0)
                return 0;
            let pstoich = WebMolKit.Vec.numberArray(-1, products.length);
            let rmol = reagent.mol;
            let highest = 0;
            for (let n = 1; n <= rmol.numAtoms; n++) {
                let m = rmol.atomMapNum(n);
                if (m == 0)
                    continue;
                let total = 0;
                for (let i = 0; i < products.length; i++) {
                    let pmol = products[i].mol;
                    if (WebMolKit.MolUtil.isBlank(pmol))
                        continue;
                    let pcount = 0;
                    for (let j = 1; j <= pmol.numAtoms; j++)
                        if (pmol.atomMapNum(j) == m)
                            pcount++;
                    if (pcount > 0) {
                        let rcount = 0;
                        for (let k = 1; k <= rmol.numAtoms; k++)
                            if (rmol.atomMapNum(k) == m)
                                rcount++;
                        if (pstoich[i] < 0)
                            pstoich[i] = QuantityCalc.extractStoichValue(products[i].stoich);
                        total += pcount * pstoich[i] / rcount;
                    }
                }
                highest = Math.max(highest, total);
            }
            return highest;
        }
        calculate() {
            this.classifyTypes();
            while (this.calculateSomething()) { }
            this.allMassReact = [];
            this.allMassProd = [];
            this.allMassWaste = [];
            for (let n = 0; n < this.quantities.length; n++) {
                let qc = this.quantities[n];
                if (qc.type == WebMolKit.Experiment.REACTANT || qc.type == WebMolKit.Experiment.REAGENT) {
                    if (qc.valueEquiv == 0 && qc.type == WebMolKit.Experiment.REAGENT)
                        continue;
                    this.allMassReact.push(qc.valueMass);
                }
                else if (qc.type == WebMolKit.Experiment.PRODUCT) {
                    if (!qc.comp.waste) {
                        this.allMassProd.push(qc.valueMass);
                        this.calculateGreenMetrics(n);
                    }
                    else {
                        this.allMassWaste.push(qc.valueMass);
                    }
                }
            }
        }
        get numQuantities() { return this.quantities.length; }
        getQuantity(idx) { return this.quantities[idx]; }
        getAllQuantities() { return this.quantities.slice(0); }
        get numGreenMetrics() { return this.greenMetrics.length; }
        getGreenMetrics(idx) { return this.greenMetrics[idx]; }
        getAllGreenMetrics() { return this.greenMetrics.slice(0); }
        getAllMassReact() { return this.allMassReact.slice(0); }
        getAllMassProd() { return this.allMassProd.slice(0); }
        getAllMassWaste() { return this.allMassWaste.slice(0); }
        findComponent(step, type, idx) {
            for (let qc of this.quantities)
                if (qc.step == step && qc.type == type && qc.idx == idx)
                    return qc;
            return null;
        }
        static formatMolWeight(value) {
            if (value == QuantityCalc.UNSPECIFIED)
                return '';
            return WebMolKit.formatDouble(value, 6) + ' g/mol';
        }
        static formatMass(value) {
            if (value == QuantityCalc.UNSPECIFIED)
                return '';
            if (value <= 1E-6)
                return WebMolKit.formatDouble(value * 1E6, 6) + ' \u03BCg';
            if (value <= 1E-3)
                return WebMolKit.formatDouble(value * 1E3, 6) + ' mg';
            if (value >= 1E3)
                return WebMolKit.formatDouble(value * 1E-3, 6) + ' kg';
            return WebMolKit.formatDouble(value, 6) + ' g';
        }
        static formatVolume(value) {
            if (value == QuantityCalc.UNSPECIFIED)
                return '';
            if (value <= 1E-6)
                return WebMolKit.formatDouble(value * 1E6, 6) + ' nL';
            if (value <= 1E-3)
                return WebMolKit.formatDouble(value * 1E3, 6) + ' \u03BCL';
            if (value >= 1E3)
                return WebMolKit.formatDouble(value * 1E-3, 6) + ' L';
            return WebMolKit.formatDouble(value, 6) + ' mL';
        }
        static formatMoles(value) {
            if (value == QuantityCalc.UNSPECIFIED)
                return '';
            if (value <= 1E-9)
                return WebMolKit.formatDouble(value * 1E9, 6) + ' nmol';
            if (value <= 1E-6)
                return WebMolKit.formatDouble(value * 1E6, 6) + ' \u03BCmol';
            if (value <= 1E-3)
                return WebMolKit.formatDouble(value * 1E3, 6) + ' mmol';
            return WebMolKit.formatDouble(value, 6) + ' mol';
        }
        static formatDensity(value) {
            if (value == QuantityCalc.UNSPECIFIED)
                return '';
            return WebMolKit.formatDouble(value, 6) + ' g/mL';
        }
        static formatConc(value) {
            if (value == QuantityCalc.UNSPECIFIED)
                return '';
            if (value <= 1E-9)
                return WebMolKit.formatDouble(value * 1E9, 6) + ' nmol/L';
            if (value <= 1E-6)
                return WebMolKit.formatDouble(value * 1E6, 6) + ' \u03BCmol/L';
            if (value <= 1E-3)
                return WebMolKit.formatDouble(value * 1E3, 6) + ' mmol/L';
            return WebMolKit.formatDouble(value, 6) + ' mol/L';
        }
        static formatPercent(value) {
            if (value == QuantityCalc.UNSPECIFIED)
                return '';
            return WebMolKit.formatDouble(value, 6) + '%';
        }
        classifyTypes() {
            for (let s = 0; s < this.entry.steps.length; s++) {
                let step = this.entry.steps[s];
                for (let n = 0; n < step.reactants.length; n++)
                    this.quantities.push(new QuantityComp(step.reactants[n], s, WebMolKit.Experiment.REACTANT, n));
                for (let n = 0; n < step.reagents.length; n++)
                    this.quantities.push(new QuantityComp(step.reagents[n], s, WebMolKit.Experiment.REAGENT, n));
                for (let n = 0; n < step.products.length; n++)
                    this.quantities.push(new QuantityComp(step.products[n], s, WebMolKit.Experiment.PRODUCT, n));
            }
            for (let n = 0; n < this.quantities.length; n++) {
                let qc = this.quantities[n];
                if (qc.type == WebMolKit.Experiment.REAGENT) {
                    if (qc.comp.equiv != null)
                        qc.valueEquiv = qc.comp.equiv;
                    else {
                        let eq = QuantityCalc.impliedReagentStoich(qc.comp, this.entry.steps[qc.step].products);
                        if (eq > 0)
                            qc.valueEquiv = eq;
                    }
                }
                else {
                    qc.valueEquiv = QuantityCalc.extractStoichValue(qc.comp.stoich);
                }
                if (qc.comp.mol != null)
                    qc.molw = WebMolKit.MolUtil.molecularWeight(qc.comp.mol);
                qc.role = QuantityCalc.ROLE_INDEPENDENT;
                if (qc.step == 0 && qc.type == WebMolKit.Experiment.REACTANT) {
                    if (qc.comp.primary) {
                        qc.role = QuantityCalc.ROLE_PRIMARY;
                        this.idxPrimary.push(n);
                    }
                    else
                        qc.role = QuantityCalc.ROLE_SECONDARY;
                }
                else if (qc.type == WebMolKit.Experiment.REAGENT) {
                    if (qc.valueEquiv > 0)
                        qc.role = QuantityCalc.ROLE_SECONDARY;
                }
                else if (qc.type == WebMolKit.Experiment.PRODUCT && !qc.comp.waste) {
                    qc.role = QuantityCalc.ROLE_PRODUCT;
                    this.idxYield.push(n);
                }
                else if (qc.valueEquiv > 0) {
                    qc.role = QuantityCalc.ROLE_SECONDARY;
                }
                if (qc.comp.mass != null)
                    qc.valueMass = qc.comp.mass;
                if (qc.comp.volume != null)
                    qc.valueVolume = qc.comp.volume;
                if (qc.comp.moles != null)
                    qc.valueMoles = qc.comp.moles;
                if (qc.comp.density != null)
                    qc.valueDensity = qc.comp.density;
                if (qc.comp.conc != null)
                    qc.valueConc = qc.comp.conc;
                if (qc.comp.yield != null)
                    qc.valueYield = qc.comp.yield;
                qc.statEquiv = qc.valueEquiv == QuantityCalc.UNSPECIFIED ? QuantityCalc.STAT_UNKNOWN : QuantityCalc.STAT_ACTUAL;
                qc.statMass = qc.valueMass == QuantityCalc.UNSPECIFIED ? QuantityCalc.STAT_UNKNOWN : QuantityCalc.STAT_ACTUAL;
                qc.statVolume = qc.valueVolume == QuantityCalc.UNSPECIFIED ? QuantityCalc.STAT_UNKNOWN : QuantityCalc.STAT_ACTUAL;
                qc.statMoles = qc.valueMoles == QuantityCalc.UNSPECIFIED ? QuantityCalc.STAT_UNKNOWN : QuantityCalc.STAT_ACTUAL;
                qc.statDensity = qc.valueDensity == QuantityCalc.UNSPECIFIED ? QuantityCalc.STAT_UNKNOWN : QuantityCalc.STAT_ACTUAL;
                qc.statConc = qc.valueConc == QuantityCalc.UNSPECIFIED ? QuantityCalc.STAT_UNKNOWN : QuantityCalc.STAT_ACTUAL;
                qc.statYield = qc.valueYield == QuantityCalc.UNSPECIFIED ? QuantityCalc.STAT_UNKNOWN : QuantityCalc.STAT_ACTUAL;
            }
            if (this.idxPrimary.length == 0) {
                for (let n = 0; n < this.quantities.length; n++) {
                    let qc = this.quantities[n];
                    if (qc.type == WebMolKit.Experiment.REACTANT && qc.step == 0) {
                        qc.role = QuantityCalc.ROLE_PRIMARY;
                        this.idxPrimary.push(n);
                    }
                }
            }
        }
        calculateSomething() {
            let anything = false;
            for (let qc of this.quantities) {
                if (qc.molw > 0 && qc.valueMass == QuantityCalc.UNSPECIFIED && qc.statMoles == QuantityCalc.STAT_ACTUAL) {
                    qc.valueMass = qc.valueMoles * qc.molw;
                    qc.statMass = QuantityCalc.STAT_VIRTUAL;
                    anything = true;
                }
                if (qc.molw > 0 && qc.valueMass != QuantityCalc.UNSPECIFIED && qc.valueMoles == QuantityCalc.UNSPECIFIED) {
                    qc.valueMoles = qc.valueMass / qc.molw;
                    qc.statMoles = QuantityCalc.STAT_VIRTUAL;
                    anything = true;
                }
                if (qc.molw > 0 && qc.statMass == QuantityCalc.STAT_ACTUAL && qc.statMoles == QuantityCalc.STAT_ACTUAL) {
                    let calcMoles = qc.valueMass / qc.molw;
                    if (!this.closeEnough(qc.valueMoles, calcMoles)) {
                        qc.statMass = QuantityCalc.STAT_CONFLICT;
                        qc.statMoles = QuantityCalc.STAT_CONFLICT;
                    }
                }
                let isSoln = qc.statConc == QuantityCalc.STAT_ACTUAL ||
                    (qc.statVolume == QuantityCalc.STAT_ACTUAL && (qc.statMass == QuantityCalc.STAT_ACTUAL || qc.statMoles == QuantityCalc.STAT_ACTUAL));
                if (!isSoln) {
                    if (qc.valueDensity > 0 && qc.valueMass == QuantityCalc.UNSPECIFIED && qc.valueVolume != QuantityCalc.UNSPECIFIED) {
                        qc.valueMass = qc.valueVolume * qc.valueDensity;
                        qc.statMass = QuantityCalc.STAT_VIRTUAL;
                        anything = true;
                    }
                    if (qc.valueDensity > 0 && qc.valueMass != QuantityCalc.UNSPECIFIED && qc.valueVolume == QuantityCalc.UNSPECIFIED) {
                        qc.valueVolume = qc.valueMass / qc.valueDensity;
                        qc.statVolume = QuantityCalc.STAT_VIRTUAL;
                        anything = true;
                    }
                    if (qc.valueDensity == QuantityCalc.UNSPECIFIED && qc.valueMass != QuantityCalc.UNSPECIFIED &&
                        qc.valueVolume != QuantityCalc.UNSPECIFIED && qc.valueConc == QuantityCalc.UNSPECIFIED) {
                        if (qc.statMass == QuantityCalc.STAT_ACTUAL || qc.statMoles == QuantityCalc.STAT_ACTUAL) {
                            qc.valueDensity = qc.valueMass / qc.valueVolume;
                            qc.statDensity = QuantityCalc.STAT_VIRTUAL;
                            anything = true;
                        }
                    }
                }
                if (isSoln) {
                    if (qc.valueConc > 0 && qc.valueMoles == QuantityCalc.UNSPECIFIED && qc.valueVolume != QuantityCalc.UNSPECIFIED) {
                        qc.valueMoles = 0.001 * qc.valueVolume * qc.valueConc;
                        qc.statMoles = QuantityCalc.STAT_VIRTUAL;
                        anything = true;
                    }
                    if (qc.valueConc > 0 && qc.valueMoles != QuantityCalc.UNSPECIFIED && qc.valueVolume == QuantityCalc.UNSPECIFIED) {
                        qc.valueVolume = 1000 * qc.valueMoles / qc.valueConc;
                        qc.statVolume = QuantityCalc.STAT_VIRTUAL;
                        anything = true;
                    }
                    if (qc.valueConc == QuantityCalc.UNSPECIFIED && qc.valueMass != QuantityCalc.UNSPECIFIED && qc.valueVolume != QuantityCalc.UNSPECIFIED) {
                        qc.valueConc = 1000 * qc.valueMoles / qc.valueVolume;
                        qc.statConc = QuantityCalc.STAT_VIRTUAL;
                        anything = true;
                    }
                    if (qc.statConc == QuantityCalc.STAT_ACTUAL && qc.valueMoles > 0 && qc.statVolume == QuantityCalc.STAT_ACTUAL) {
                        let calcVolume = 1000 * qc.valueMoles / qc.valueConc;
                        if (!this.closeEnough(qc.valueVolume, calcVolume)) {
                            qc.statConc = QuantityCalc.STAT_CONFLICT;
                            if (qc.statMass == QuantityCalc.STAT_ACTUAL)
                                qc.statMass = QuantityCalc.STAT_CONFLICT;
                            if (qc.statMoles == QuantityCalc.STAT_ACTUAL)
                                qc.statMoles = QuantityCalc.STAT_CONFLICT;
                            qc.statVolume = QuantityCalc.STAT_CONFLICT;
                        }
                    }
                }
                if (qc.molw > 0 && qc.valueMass == QuantityCalc.UNSPECIFIED && qc.valueMoles != QuantityCalc.UNSPECIFIED) {
                    qc.valueMass = qc.valueMoles * qc.molw;
                    qc.statMass = QuantityCalc.STAT_VIRTUAL;
                    anything = true;
                }
                if (qc.statDensity == QuantityCalc.STAT_ACTUAL && qc.statConc == QuantityCalc.STAT_ACTUAL) {
                    qc.statDensity = QuantityCalc.STAT_CONFLICT;
                    qc.statConc = QuantityCalc.STAT_CONFLICT;
                }
            }
            if (anything)
                return true;
            let hasRef = false;
            let numSteps = this.entry.steps.length;
            let primaryCounts = WebMolKit.Vec.numberArray(0, numSteps);
            let primaryEquivs = WebMolKit.Vec.numberArray(0, numSteps);
            let primaryMoles = WebMolKit.Vec.numberArray(0, numSteps);
            for (let qc of this.quantities) {
                let ref = -1;
                if (qc.step == 0 && qc.type == WebMolKit.Experiment.REACTANT && qc.comp.primary)
                    ref = qc.step;
                else if (qc.step < numSteps - 1 && qc.type == WebMolKit.Experiment.PRODUCT && !qc.comp.waste)
                    ref = qc.step + 1;
                else
                    continue;
                if (primaryEquivs[ref] < 0)
                    continue;
                if (qc.statMoles == QuantityCalc.STAT_UNKNOWN) {
                    primaryEquivs[ref] = -1;
                    continue;
                }
                primaryCounts[ref]++;
                primaryEquivs[ref] += qc.valueEquiv;
                primaryMoles[ref] += qc.valueMoles;
            }
            if (primaryEquivs[0] <= 0) {
                primaryCounts[0] = 0;
                primaryEquivs[0] = 0;
                primaryMoles[0] = 0;
                for (let i of this.idxPrimary) {
                    let qc = this.quantities[i];
                    if (qc.statMoles == QuantityCalc.STAT_UNKNOWN) {
                        primaryCounts[0] = 0;
                        primaryEquivs[0] = -1;
                        primaryMoles[0] = 0;
                        break;
                    }
                    primaryCounts[0]++;
                    primaryEquivs[0] += qc.valueEquiv;
                    primaryMoles[0] += qc.valueMoles;
                }
            }
            let refMoles = WebMolKit.Vec.numberArray(0, numSteps);
            for (let n = 0; n < numSteps; n++) {
                refMoles[n] = primaryCounts[n] == 0 || primaryEquivs[n] <= 0 ? 0 : primaryMoles[n] / primaryEquivs[n];
                if (refMoles[n] > 0)
                    hasRef = true;
            }
            if (!hasRef) {
                for (let n = 0; n < numSteps; n++) {
                    let prodMolar = [];
                    for (let qc of this.quantities) {
                        if (qc.step != n || qc.role != QuantityCalc.ROLE_PRODUCT)
                            continue;
                        if (qc.statMoles == QuantityCalc.STAT_UNKNOWN || qc.valueMoles <= 0 || qc.valueEquiv <= 0)
                            continue;
                        let yld = qc.valueYield > 0 ? qc.valueYield * 0.01 : 1;
                        prodMolar.push(qc.valueMoles / (qc.valueEquiv * yld));
                    }
                    if (prodMolar.length > 0) {
                        refMoles[n] = WebMolKit.Vec.sum(prodMolar) / prodMolar.length;
                        hasRef = true;
                    }
                }
            }
            if (!hasRef)
                return false;
            for (let qc of this.quantities) {
                if (qc.type != WebMolKit.Experiment.PRODUCT)
                    continue;
                if (refMoles[qc.step] == 0)
                    continue;
                if (qc.valueYield == QuantityCalc.UNSPECIFIED && qc.valueMoles != QuantityCalc.UNSPECIFIED) {
                    qc.valueYield = 100 * qc.valueMoles / (refMoles[qc.step] * qc.valueEquiv);
                    qc.statYield = QuantityCalc.STAT_VIRTUAL;
                    anything = true;
                }
                if (qc.valueYield != QuantityCalc.UNSPECIFIED && qc.valueMoles == QuantityCalc.UNSPECIFIED) {
                    qc.valueMoles = qc.valueYield * 0.01 * (refMoles[qc.step] * qc.valueEquiv);
                    qc.statMoles = QuantityCalc.STAT_VIRTUAL;
                    anything = true;
                }
                if (qc.valueMoles > 0 && qc.statYield == QuantityCalc.STAT_ACTUAL) {
                    let calcYield = 100 * qc.valueMoles / (refMoles[qc.step] * qc.valueEquiv);
                    if (!this.closeEnough(qc.valueYield, calcYield)) {
                        if (qc.statMass == QuantityCalc.STAT_ACTUAL)
                            qc.statMass = QuantityCalc.STAT_CONFLICT;
                        if (qc.statMoles == QuantityCalc.STAT_ACTUAL)
                            qc.statMoles = QuantityCalc.STAT_CONFLICT;
                        qc.statYield = QuantityCalc.STAT_CONFLICT;
                    }
                }
            }
            if (anything)
                return true;
            for (let qc of this.quantities) {
                if (refMoles[qc.step] == 0)
                    continue;
                if (qc.valueMass == QuantityCalc.UNSPECIFIED && qc.valueMoles == QuantityCalc.UNSPECIFIED && qc.valueEquiv > 0) {
                    qc.valueMoles = refMoles[qc.step] * qc.valueEquiv;
                    qc.statMoles = QuantityCalc.STAT_VIRTUAL;
                    anything = true;
                }
                if (qc.valueMoles != QuantityCalc.UNSPECIFIED && qc.valueEquiv == QuantityCalc.UNSPECIFIED) {
                    qc.valueEquiv = qc.valueMoles / refMoles[qc.step];
                    qc.statEquiv = QuantityCalc.STAT_VIRTUAL;
                    anything = true;
                }
            }
            return anything;
        }
        calculateGreenMetrics(idx) {
            let qc = this.quantities[idx];
            let gm = new GreenMetrics();
            gm.step = qc.step;
            gm.idx = idx;
            gm.isBlank = true;
            for (let n = 0; n < this.quantities.length; n++) {
                let sub = this.quantities[n];
                if (sub.step > gm.step)
                    continue;
                let eq = sub.valueEquiv;
                if (eq == 0 && sub.type == WebMolKit.Experiment.REAGENT)
                    continue;
                if (sub.valueMass != QuantityCalc.UNSPECIFIED)
                    gm.isBlank = false;
                if (sub.type == WebMolKit.Experiment.REACTANT || sub.type == WebMolKit.Experiment.REAGENT) {
                    gm.massReact.push(sub.valueMass);
                    if (sub.step == gm.step && eq > 0 && sub.molw > 0)
                        gm.molwReact.push(eq * sub.molw);
                }
                else if (sub.type == WebMolKit.Experiment.PRODUCT) {
                    if (!sub.comp.waste) {
                        if (sub.step == gm.step)
                            gm.massProd.push(sub.valueMass);
                        if (eq > 0 && sub.molw > 0) {
                            if (sub.step == gm.step)
                                gm.molwProd.push(eq * sub.molw);
                            else if (sub.step == gm.step - 1)
                                gm.molwReact.push(eq * sub.molw);
                        }
                    }
                    else {
                        gm.massWaste.push(sub.valueMass);
                    }
                    if (sub.step == gm.step)
                        gm.massProdWaste.push(sub.valueMass);
                }
            }
            gm.impliedWaste = WebMolKit.Vec.sum(gm.massReact) - WebMolKit.Vec.sum(gm.massProdWaste);
            if (Math.abs(gm.impliedWaste) > 1E-3)
                gm.impliedWaste = 0;
            this.greenMetrics.push(gm);
        }
        closeEnough(value1, value2) {
            if (value1 <= 0 || value2 <= 0)
                return true;
            let ratio = value1 / value2;
            return ratio >= 0.99 && ratio <= 1.01;
        }
    }
    QuantityCalc.UNSPECIFIED = -1;
    QuantityCalc.ROLE_PRIMARY = 1;
    QuantityCalc.ROLE_SECONDARY = 2;
    QuantityCalc.ROLE_PRODUCT = 3;
    QuantityCalc.ROLE_INDEPENDENT = 4;
    QuantityCalc.STAT_UNKNOWN = 0;
    QuantityCalc.STAT_ACTUAL = 1;
    QuantityCalc.STAT_VIRTUAL = 2;
    QuantityCalc.STAT_CONFLICT = 3;
    QuantityCalc.MAX_DENOM = 16;
    QuantityCalc.RATIO_FRACT = null;
    WebMolKit.QuantityCalc = QuantityCalc;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class RPC {
        constructor(request, parameter, callback) {
            this.request = request;
            this.parameter = parameter;
            this.callback = callback;
        }
        invoke() {
            let data = this.parameter;
            if (data == null)
                data = {};
            let url = RPC.BASE_URL + "/REST/" + this.request;
            $.ajax({
                'url': url,
                'type': 'POST',
                'data': JSON.stringify(this.parameter),
                'contentType': 'application/json;charset=utf-8',
                'dataType': 'json',
                headers: { 'Access-Control-Allow-Origin': '*' },
                success: (data, textStatus, jqXHR) => {
                    var result = null, error = null;
                    if (!data) {
                        error =
                            {
                                'message': 'null result',
                                'code': RPC.ERRCODE_NONSPECIFIC,
                                type: 0,
                                'detail': 'unknown failure'
                            };
                    }
                    else {
                        if (data.error) {
                            error =
                                {
                                    'message': data.error,
                                    'code': data.errorCode,
                                    'type': data.errorType,
                                    'detail': data.errorDetail
                                };
                            console.log('RPC error communicating with: ' + url + ', content: ' + JSON.stringify(data.error) + '\nDetail:\n' + data.errorDetail);
                        }
                        else
                            result = data.result;
                    }
                    this.callback(result, error);
                },
                error: (jqXHR, textStatus, errorThrow) => {
                    var error = {
                        'message': 'connection failure',
                        'code': RPC.ERRCODE_NONSPECIFIC,
                        type: 0,
                        'detail': `unable to obtain result from service: {$url}`
                    };
                    this.callback({}, error);
                }
            });
        }
    }
    RPC.BASE_URL = null;
    RPC.RESOURCE_URL = null;
    RPC.ERRCODE_CLIENT_ABORTED = -3;
    RPC.ERRCODE_CLIENT_TIMEOUT = -1;
    RPC.ERRCODE_CLIENT_OTHER = -1;
    RPC.ERRCODE_NONSPECIFIC = 0;
    RPC.ERRCODE_UNKNOWN = 1;
    RPC.ERRCODE_NOSUCHUSER = 2;
    RPC.ERRCODE_INVALIDLOGIN = 3;
    RPC.ERRCODE_INVALIDTOKEN = 4;
    RPC.ERRCODE_DATASHEETUNAVAIL = 5;
    RPC.ERRCODE_INVALIDCOMMAND = 6;
    RPC.ERRCODE_ROWDATAUNAVAIL = 7;
    RPC.ERRCODE_MISSINGPARAM = 8;
    WebMolKit.RPC = RPC;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class Theme {
    }
    Theme.foreground = 0x000000;
    Theme.background = 0xFFFFFF;
    Theme.lowlight = 0x24D0D0;
    Theme.lowlightEdge1 = 0x47D5D2;
    Theme.lowlightEdge2 = 0x008FD1;
    Theme.highlight = 0x00FF00;
    Theme.highlightEdge1 = 0x00CA59;
    Theme.highlightEdge2 = 0x008650;
    Theme.error = 0xFF0000;
    WebMolKit.Theme = Theme;
    function initWebMolKit(resourcePath) {
        WebMolKit.RPC.RESOURCE_URL = resourcePath;
        installInlineCSS('main', composeMainCSS());
    }
    WebMolKit.initWebMolKit = initWebMolKit;
    var cssTagsInstalled = new Set();
    function hasInlineCSS(tag) { return cssTagsInstalled.has(tag); }
    WebMolKit.hasInlineCSS = hasInlineCSS;
    function installInlineCSS(tag, css) {
        if (cssTagsInstalled.has(tag))
            return false;
        let el = document.createElement('style');
        el.innerHTML = css;
        document.head.appendChild(el);
        cssTagsInstalled.add(tag);
        return true;
    }
    WebMolKit.installInlineCSS = installInlineCSS;
    function composeMainCSS() {
        let lowlight = WebMolKit.colourCode(Theme.lowlight), lowlightEdge1 = WebMolKit.colourCode(Theme.lowlightEdge1), lowlightEdge2 = WebMolKit.colourCode(Theme.lowlightEdge2);
        let highlight = WebMolKit.colourCode(Theme.highlight), highlightEdge1 = WebMolKit.colourCode(Theme.highlightEdge1), highlightEdge2 = WebMolKit.colourCode(Theme.highlightEdge2);
        return `
		.wmk-button
		{
			display: inline-block;
			padding: 6px 12px;
			margin-bottom: 0;
			font-family: 'Open Sans', sans-serif;
			font-size: 14px;
			font-weight: normal;
			line-height: 1.42857143;
			text-align: center;
			white-space: nowrap;
			vertical-align: middle;
			cursor: pointer;
			background-image: none;
			border: 1px solid transparent;
			border-radius: 4px;
			-ms-touch-action: manipulation; touch-action: manipulation;
			-webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
		}
		.wmk-button:focus,
		.wmk-button:active:focus,
		.wmk-button.active:focus,
		.wmk-button.focus,
		.wmk-button:active.focus,
		.wmk-button.active.focus 
		{
			outline: thin dotted;
			outline: 5px auto -webkit-focus-ring-color;
			outline-offset: -2px;
		}
		.wmk-button:hover,
		.wmk-button:focus,
		.wmk-button.focus 
		{
			color: #333;
			text-decoration: none;
		}
		.wmk-button:active,
		.wmk-button.active 
		{
			background-image: none;
			outline: 0;
			-webkit-box-shadow: inset 0 3px 5px rgba(0, 0, 0, .125);
			box-shadow: inset 0 3px 5px rgba(0, 0, 0, .125);
		}
		.wmk-button.disabled,
		.wmk-button[disabled],
		fieldset[disabled] .wmk-button 
		{
			cursor: not-allowed;
			filter: alpha(opacity=65);
			-webkit-box-shadow: none;
			box-shadow: none;
			opacity: .65;
		}
		a.wmk-button.disabled,
		fieldset[disabled] a.wmk-button 
		{
			pointer-events: none;
		}

		/* shrunken button */

		.wmk-button-small
		{
			padding: 2px 4px;
			line-height: 1;
			font-size: 12px;
		}

		/* default button */

		.wmk-button-default 
		{
			color: #333;
			background-color: #fff;
			background-image: linear-gradient(to right bottom, #FFFFFF, #E0E0E0);
			border-color: #ccc;
		}
		.wmk-button-default:focus,
		.wmk-button-default.focus 
		{
			color: #333;
			background-color: #e6e6e6;
			border-color: #8c8c8c;
		}
		.wmk-button-default:hover 
		{
			color: #333;
			background-color: #e6e6e6;
			border-color: #adadad;
		}
		.wmk-button-default:active,
		.wmk-button-default.active,
		.open > .dropdown-toggle.wmk-button-default 
		{
			color: #333;
			background-color: #e6e6e6;
			border-color: #adadad;
		}
		.wmk-button-default:active:hover,
		.wmk-button-default.active:hover,
		.open > .dropdown-toggle.wmk-button-default:hover,
		.wmk-button-default:active:focus,
		.wmk-button-default.active:focus,
		.open > .dropdown-toggle.wmk-button-default:focus,
		.wmk-button-default:active.focus,
		.wmk-button-default.active.focus,
		.open > .dropdown-toggle.wmk-button-default.focus 
		{
			color: #333;
			background-color: #d4d4d4;
			border-color: #8c8c8c;
		}
		.wmk-button-default:active,
		.wmk-button-default.active,
		.open > .dropdown-toggle.wmk-button-default 
		{
			background-image: none;
		}
		.wmk-button-default.disabled:hover,
		.wmk-button-default[disabled]:hover,
		fieldset[disabled] .wmk-button-default:hover,
		.wmk-button-default.disabled:focus,
		.wmk-button-default[disabled]:focus,
		fieldset[disabled] .wmk-button-default:focus,
		.wmk-button-default.disabled.focus,
		.wmk-button-default[disabled].focus,
		fieldset[disabled] .wmk-button-default.focus 
		{
			background-color: #fff;
			border-color: #ccc;
		}
		.wmk-button-default .badge 
		{
			color: #fff;
			background-color: #333;
		}

		/* primary button */

		.wmk-button-primary 
		{
			color: #fff;
			background-color: #008FD2;
			background-image: linear-gradient(to right bottom, ${lowlightEdge1}, ${lowlightEdge2});
			border-color: #00C0C0;
		}
		.wmk-button-primary:focus,
		.wmk-button-primary.focus 
		{
			color: #fff;
			background-color: ${lowlight};
			border-color: #122b40;
		}
		.wmk-button-primary:hover 
		{
			color: #fff;
			background-color: #286090;
			border-color: #204d74;
		}
		.wmk-button-primary:active,
		.wmk-button-primary.active,
		.open > .dropdown-toggle.wmk-button-primary 
		{
			color: #fff;
			background-color: #286090;
			border-color: #20744d;
		}
		.wmk-button-primary:active:hover,
		.wmk-button-primary.active:hover,
		.open > .dropdown-toggle.wmk-button-primary:hover,
		.wmk-button-primary:active:focus,
		.wmk-button-primary.active:focus,
		.open > .dropdown-toggle.wmk-button-primary:focus,
		.wmk-button-primary:active.focus,
		.wmk-button-primary.active.focus,
		.open > .dropdown-toggle.wmk-button-primary.focus 
		{
			color: #fff;
			background-color: ${highlight};
			background-image: linear-gradient(to right bottom, ${highlightEdge1}, ${highlightEdge2});
			border-color: #12802b;
		}
		.wmk-button-primary:active,
		.wmk-button-primary.active,
		.open > .dropdown-toggle.wmk-button-primary 
		{
			background-image: none;
		}
		.wmk-button-primary.disabled:hover,
		.wmk-button-primary[disabled]:hover,
		fieldset[disabled] .wmk-button-primary:hover,
		.wmk-button-primary.disabled:focus,
		.wmk-button-primary[disabled]:focus,
		fieldset[disabled] .wmk-button-primary:focus,
		.wmk-button-primary.disabled.focus,
		.wmk-button-primary[disabled].focus,
		fieldset[disabled] .wmk-button-primary.focus 
		{
			background-color: #337ab7;
			border-color: #2ea46d;
		}
		.wmk-button-primary .badge 
		{
			color: #337ab7;
			background-color: #fff;
		}
	`;
    }
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    const CSS_DIALOG = `
    *.wmk-dialog
    {
        font-family: 'Open Sans', sans-serif;
    }
`;
    class Dialog {
        constructor() {
            this.minPortionWidth = 80;
            this.maxPortionWidth = 80;
            this.maximumWidth = 0;
            this.maximumHeight = 0;
            this.title = 'Dialog';
            this.callbackClose = null;
            WebMolKit.installInlineCSS('dialog', CSS_DIALOG);
        }
        onClose(callback) {
            this.callbackClose = callback;
        }
        open() {
            let body = $(document.documentElement);
            let bg = $('<div></div>').appendTo(body);
            bg.css('width', '100%');
            bg.css('height', document.documentElement.clientHeight + 'px');
            bg.css('background-color', 'black');
            bg.css('opacity', 0.8);
            bg.css('position', 'absolute');
            bg.css('left', 0);
            bg.css('top', 0);
            bg.css('z-index', 9999);
            this.obscureBackground = bg;
            let pb = $('<div class="wmk-dialog"></div>').appendTo(body);
            pb.css('min-width', this.minPortionWidth + '%');
            if (this.maximumWidth > 0)
                pb.css('max-width', this.maximumWidth + 'px');
            else if (this.maxPortionWidth != null)
                pb.css('max-width', this.maxPortionWidth + '%');
            if (this.maximumHeight > 0)
                pb.css('max-height', this.maximumHeight + 'px');
            pb.css('background-color', 'white');
            pb.css('border-radius', '6px');
            pb.css('border', '1px solid black');
            pb.css('position', 'absolute');
            pb.css('left', (50 - 0.5 * this.minPortionWidth) + '%');
            pb.css('top', (document.body.scrollTop + 50) + 'px');
            pb.css('min-height', '20%');
            pb.css('z-index', 10000);
            this.panelBoundary = pb;
            let tdiv = $('<div></div>').appendTo(pb);
            tdiv.css('width', '100%');
            tdiv.css('background-color', '#F0F0F0');
            tdiv.css('background-image', 'linear-gradient(to right bottom, #FFFFFF, #E0E0E0)');
            tdiv.css('border-bottom', '1px solid #C0C0C0');
            tdiv.css('border-radius', '6px 6px 0 0');
            tdiv.css('margin', 0);
            tdiv.css('padding', 0);
            this.titleDiv = tdiv;
            let bdiv = $('<div></div>').appendTo(pb);
            bdiv.css('width', '100%');
            this.bodyDiv = $('<div style="padding: 0.5em;"></div>').appendTo(bdiv);
            let ttlTable = $('<table></table>').appendTo(tdiv), tr = $('<tr></tr>').appendTo(ttlTable);
            ttlTable.attr('width', '100%');
            let tdTitle = $('<td valign="center"></td>').appendTo(tr);
            tdTitle.css('padding', '0.5em');
            let ttl = $('<font></font>').appendTo(tdTitle);
            ttl.css('font-size', '1.5em');
            ttl.css('font-weight', '600');
            ttl.text(this.title);
            let tdButtons = $('<td align="right" valign="center"></td>').appendTo(tr);
            tdButtons.css('padding', '0.5em');
            this.btnClose = $('<button class="wmk-button wmk-button-default">Close</button>').appendTo(tdButtons);
            this.btnClose.click(() => this.close());
            this.titleButtons = tdButtons;
            this.populate();
            this.repositionSize();
            bg.show();
            pb.show();
        }
        close() {
            this.panelBoundary.remove();
            this.obscureBackground.remove();
            if (this.callbackClose)
                this.callbackClose(this);
        }
        bump() {
            this.repositionSize();
        }
        body() { return this.bodyDiv; }
        buttons() { return this.titleButtons; }
        populate() {
            this.body().text('Empty dialog box.');
        }
        repositionSize() {
            let docW = $(window).width(), dlgW = this.panelBoundary.width();
            this.panelBoundary.css('left', (0.5 * (docW - dlgW)) + 'px');
        }
    }
    WebMolKit.Dialog = Dialog;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    var globalPopover = null;
    var globalTooltip = null;
    var globalPopWatermark = 0;
    function addTooltip(parent, bodyHTML, titleHTML, delay) {
        Tooltip.ensureGlobal();
        let widget = $(parent);
        const tooltip = new Tooltip(widget, bodyHTML, titleHTML, delay == null ? 1000 : delay);
        let prevEnter = widget.attr('onmouseenter'), prevLeave = widget.attr('onmouseleave');
        widget.mouseenter((e) => { tooltip.start(); if (prevEnter)
            prevEnter(e); });
        widget.mouseleave((e) => { tooltip.stop(); if (prevLeave)
            prevLeave(e); });
    }
    WebMolKit.addTooltip = addTooltip;
    function raiseToolTip(widget, avoid, bodyHTML, titleHTML) {
        clearTooltip();
        Tooltip.ensureGlobal();
        new Tooltip($(widget), bodyHTML, titleHTML, 0).raise(avoid);
    }
    WebMolKit.raiseToolTip = raiseToolTip;
    function clearTooltip() {
        if (globalTooltip == null)
            return;
        globalPopWatermark++;
        globalTooltip.lower();
    }
    WebMolKit.clearTooltip = clearTooltip;
    class Tooltip {
        constructor(widget, bodyHTML, titleHTML, delay) {
            this.widget = widget;
            this.bodyHTML = bodyHTML;
            this.titleHTML = titleHTML;
            this.delay = delay;
        }
        static ensureGlobal() {
            if (globalPopover == null) {
                globalPopover = $(document.createElement('div'));
                globalPopover.css('position', 'absolute');
                globalPopover.css('background-color', '#F0F0FF');
                globalPopover.css('background-image', 'linear-gradient(to right bottom, #FFFFFF, #D0D0FF)');
                globalPopover.css('color', 'black');
                globalPopover.css('border', '1px solid black');
                globalPopover.css('z-index', 12000);
                globalPopover.css('border-radius', '4px');
                globalPopover.hide();
                globalPopover.appendTo(document.body);
            }
        }
        start() {
            globalPopover.hide();
            this.watermark = ++globalPopWatermark;
            window.setTimeout(() => {
                if (this.watermark == globalPopWatermark)
                    this.raise();
            }, this.delay);
        }
        stop() {
            if (this.watermark == globalPopWatermark)
                this.lower();
            globalPopWatermark++;
        }
        raise(avoid) {
            globalTooltip = this;
            let pop = globalPopover;
            pop.css('max-width', '20em');
            pop.empty();
            let div = $('<div></div>').appendTo(pop);
            div.css('padding', '0.3em');
            let hasTitle = this.titleHTML != null && this.titleHTML.length > 0, hasBody = this.bodyHTML != null && this.bodyHTML.length > 0;
            if (hasTitle)
                ($('<div></div>').appendTo(div)).html('<b>' + this.titleHTML + '</b>');
            if (hasTitle && hasBody)
                div.append('<hr>');
            if (hasBody)
                ($('<div></div>').appendTo(div)).html(this.bodyHTML);
            let winW = $(window).width(), winH = $(window).height();
            const GAP = 2;
            let wx1 = this.widget.offset().left, wy1 = this.widget.offset().top;
            let wx2 = wx1 + this.widget.width(), wy2 = wy1 + this.widget.height();
            if (avoid) {
                wx1 += avoid.x;
                wy1 += avoid.y;
                wx2 = wx1 + avoid.w;
                wy2 = wy1 + avoid.h;
            }
            let setPosition = () => {
                let popW = pop.width(), popH = pop.height();
                let posX = 0, posY = 0;
                if (wx1 + popW < winW)
                    posX = wx1;
                else if (popW < wx2)
                    posX = wx2 - popW;
                if (wy2 + GAP + popH < winH)
                    posY = wy2 + GAP;
                else if (wy1 - GAP - popH > 0)
                    posY = wy1 - GAP - popH;
                else
                    posY = wy2 + GAP;
                pop.css('left', `${posX}px`);
                pop.css('top', `${posY}px`);
            };
            setPosition();
            pop.show();
            window.setTimeout(() => setPosition(), 1);
        }
        lower() {
            let pop = globalPopover;
            pop.hide();
        }
    }
    WebMolKit.Tooltip = Tooltip;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class Widget {
        constructor() {
            this.tagType = 'div';
            this.content = null;
        }
        render(parent) {
            let tag = this.tagType;
            this.content = $(`<${tag}></${tag}>`).appendTo($(parent));
        }
        addTooltip(bodyHTML, titleHTML) {
            WebMolKit.addTooltip(this.content, bodyHTML, titleHTML);
        }
    }
    WebMolKit.Widget = Widget;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class OptionList extends WebMolKit.Widget {
        constructor(options, isVertical = false) {
            super();
            this.options = options;
            this.isVertical = isVertical;
            this.selidx = 0;
            this.buttonDiv = [];
            this.auxCell = [];
            this.padding = 6;
            this.callbackSelect = null;
            if (options.length == 0)
                throw 'molsync.ui.OptionList: must provide a list of option labels.';
            if (!WebMolKit.hasInlineCSS('option'))
                WebMolKit.installInlineCSS('option', this.composeCSS());
        }
        getSelectedIndex() {
            return this.selidx;
        }
        getSelectedValue() {
            return this.options[this.selidx];
        }
        getAuxiliaryCell(idx) {
            return this.auxCell[idx];
        }
        render(parent) {
            super.render(parent);
            this.buttonDiv = [];
            this.auxCell = [];
            let table = $('<table class="wmk-option-table"></table>').appendTo(this.content);
            let tr = this.isVertical ? null : $('<tr></tr>').appendTo(table);
            for (let n = 0; n < this.options.length; n++) {
                if (this.isVertical)
                    tr = $('<tr></tr>').appendTo(table);
                let td = $('<td class="wmk-option-cell"></td>').appendTo(tr);
                let div = $('<div class="wmk-option"></div>').appendTo(td);
                div.css('padding', this.padding + 'px');
                this.buttonDiv.push(div);
                if (this.isVertical) {
                    td = $('<td style="vertical-align: middle;"></td>').appendTo(tr);
                    this.auxCell.push(td);
                }
            }
            this.updateButtons();
        }
        clickButton(idx) {
            if (idx == this.selidx)
                return;
            this.setSelectedIndex(idx);
            if (this.callbackSelect)
                this.callbackSelect(idx, this);
        }
        setSelectedIndex(idx) {
            if (this.selidx == idx)
                return;
            this.selidx = idx;
            this.updateButtons();
        }
        setSelectedValue(val) {
            let idx = this.options.indexOf(val);
            if (idx >= 0)
                this.setSelectedIndex(idx);
        }
        updateButtons() {
            for (let n = 0; n < this.options.length && n < this.buttonDiv.length; n++) {
                let div = this.buttonDiv[n];
                let txt = this.options[n];
                if (txt.length == 0 && n == this.selidx)
                    div.text('\u00A0\u2716\u00A0');
                else if (txt.length == 0)
                    div.text('\u00A0\u00A0\u00A0');
                else
                    div.text(txt);
                div.off('mouseover');
                div.off('mouseout');
                div.off('mousedown');
                div.off('mouseup');
                div.off('mouseleave');
                div.off('mousemove');
                div.off('click');
                div.removeClass('wmk-option-hover wmk-option-active wmk-option-unselected wmk-option-selected');
                if (n != this.selidx) {
                    div.addClass('wmk-option-unselected');
                    div.mouseover(() => div.addClass('wmk-option-hover'));
                    div.mouseout(() => div.removeClass('wmk-option-hover wmk-option-active'));
                    div.mousedown(() => div.addClass('wmk-option-active'));
                    div.mouseup(() => div.removeClass('wmk-option-active'));
                    div.mouseleave(() => div.removeClass('wmk-option-hover wmk-option-active'));
                    div.mousemove(() => { return false; });
                    div.click(() => this.clickButton(n));
                }
                else
                    div.addClass('wmk-option-selected');
            }
        }
        composeCSS() {
            let lowlight = WebMolKit.colourCode(WebMolKit.Theme.lowlight), lowlightEdge1 = WebMolKit.colourCode(WebMolKit.Theme.lowlightEdge1), lowlightEdge2 = WebMolKit.colourCode(WebMolKit.Theme.lowlightEdge2);
            let highlight = WebMolKit.colourCode(WebMolKit.Theme.highlight), highlightEdge1 = WebMolKit.colourCode(WebMolKit.Theme.highlightEdge1), highlightEdge2 = WebMolKit.colourCode(WebMolKit.Theme.highlightEdge2);
            return `
			.wmk-option
			{
				margin-bottom: 0;
				font-family: 'Open Sans', sans-serif;
				font-size: 14px;
				font-weight: normal;
				text-align: center;
				white-space: nowrap;
				vertical-align: middle;
				-ms-touch-action: manipulation; touch-action: manipulation;
				cursor: pointer;
				-webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
			}
			.wmk-option-selected
			{
				color: white;
				background-color: #008FD2;
				background-image: linear-gradient(to right bottom, ${lowlightEdge1}, ${lowlightEdge2});
			}
			.wmk-option-unselected
			{
				color: #333;
				background-color: white;
				background-image: linear-gradient(to right bottom, #FFFFFF, #E0E0E0);
			}
			.wmk-option-table
			{
				margin: 1px;
				padding: 0;
				border-width: 0;
				border-collapse: collapse;
			}
			.wmk-option-cell
			{
				margin: 0;
				padding: 0;
				border-width: 0;
				border-width: 1px;
				border-style: solid;
				border-color: #808080;
			}
			.wmk-option-hover
			{
				background-color: #808080;
				background-image: linear-gradient(to right bottom, #F0F0F0, #D0D0D0);
			}
			.wmk-option-active
			{
				background-color: #00C000;
				background-image: linear-gradient(to right bottom, ${highlightEdge1}, ${highlightEdge2});
			}
		`;
        }
    }
    WebMolKit.OptionList = OptionList;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class Func {
        static renderStructure(input, callback) {
            new WebMolKit.RPC('func.renderStructure', input, callback).invoke();
        }
        static arrangeMolecule(input, callback) {
            new WebMolKit.RPC('func.arrangeMolecule', input, callback).invoke();
        }
        static renderRowDetail(input, callback) {
            new WebMolKit.RPC('func.renderRowDetail', input, callback).invoke();
        }
        static renderYieldDetail(input, callback) {
            new WebMolKit.RPC('func.renderYieldDetail', input, callback).invoke();
        }
        static composeDocument(input, callback) {
            new WebMolKit.RPC('func.composeDocument', input, callback).invoke();
        }
        static getMoleculeProperties(input, callback) {
            new WebMolKit.RPC('func.getMoleculeProperties', input, callback).invoke();
        }
        static atomMapping(input, callback) {
            new WebMolKit.RPC('func.atomMapping', input, callback).invoke();
        }
        static prepareDownloadable(input, callback) {
            new WebMolKit.RPC('func.prepareDownloadable', input, callback).invoke();
        }
        static downloadFromSource(input, callback) {
            new WebMolKit.RPC('func.downloadFromSource', input, callback).invoke();
        }
        static getDefaultTemplateGroups(input, callback) {
            new WebMolKit.RPC('func.getDefaultTemplateGroups', input, callback).invoke();
        }
        static getDefaultTemplateStructs(input, callback) {
            new WebMolKit.RPC('func.getDefaultTemplateStructs', input, callback).invoke();
        }
        static getActionIcons(input, callback) {
            new WebMolKit.RPC('func.getActionIcons', input, callback).invoke();
        }
    }
    WebMolKit.Func = Func;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class Download extends WebMolKit.Dialog {
        constructor(tokenID) {
            super();
            this.tokenID = tokenID;
            this.mol = null;
            this.ds = null;
            this.policy = WebMolKit.RenderPolicy.defaultColourOnWhite();
            this.formatKey = [];
            this.formatGfx = [];
        }
        ;
        static openTransientMolecule(tokenID, mol) {
            let dlg = new Download(tokenID);
            dlg.mol = mol;
            dlg.title = 'Download Molecule';
            dlg.open();
            return dlg;
        }
        ;
        static openTransientDataSheet(tokenID, ds) {
            let dlg = new Download(tokenID);
            dlg.ds = ds;
            dlg.title = 'Download DataSheet';
            dlg.open();
            return dlg;
        }
        ;
        populate() {
            let body = this.body();
            this.mainArea = $('<p>Setting up...</p>').appendTo(body);
            let paraBtn = $('<p align="right"></p>').appendTo(body);
            this.downloadArea = $('<span style="padding-right: 2em;"></span>').appendTo(paraBtn);
            this.btnPrepare = $('<button class="button button-primary">Prepare</button>').appendTo(paraBtn);
            this.btnPrepare.click(() => this.clickPrepare());
            if (this.mol != null) {
                this.formatKey.push(WebMolKit.FormatList.FMT_NATIVE);
                this.formatGfx.push(false);
                this.formatKey.push(WebMolKit.FormatList.FMT_MDLMOL);
                this.formatGfx.push(false);
                this.formatKey.push(WebMolKit.FormatList.GFX_PNG);
                this.formatGfx.push(true);
                this.formatKey.push(WebMolKit.FormatList.GFX_SVG);
                this.formatGfx.push(true);
                this.formatKey.push(WebMolKit.FormatList.GFX_PDF);
                this.formatGfx.push(true);
                this.formatKey.push(WebMolKit.FormatList.GFX_EPS);
                this.formatGfx.push(true);
            }
            else if (this.ds != null) {
                let isReaction = false, isExperiment = false;
                for (let n = 0; n < this.ds.numExtensions; n++) {
                    if (this.ds.getExtType(n) == 'org.mmi.aspect.Reaction')
                        isReaction = true;
                    if (this.ds.getExtType(n) == 'org.mmi.aspect.Experiment')
                        isExperiment = true;
                }
                this.formatKey.push(WebMolKit.FormatList.FMT_XMLDS);
                this.formatGfx.push(false);
                if (!isReaction) {
                    this.formatKey.push(WebMolKit.FormatList.FMT_MDLSDF);
                    this.formatGfx.push(false);
                }
                if (isReaction) {
                    this.formatKey.push(WebMolKit.FormatList.FMT_MDLRDF);
                    this.formatGfx.push(false);
                    if (this.ds.numRows == 1) {
                        this.formatKey.push(WebMolKit.FormatList.FMT_MDLRXN);
                        this.formatGfx.push(false);
                    }
                }
                if (this.ds.numRows == 1 || isExperiment) {
                    if (!isReaction && this.ds.firstColOfType(WebMolKit.DataSheet.COLTYPE_MOLECULE) >= 0) {
                        this.formatKey.push(WebMolKit.FormatList.FMT_NATIVE);
                        this.formatGfx.push(false);
                        this.formatKey.push(WebMolKit.FormatList.FMT_MDLMOL);
                        this.formatGfx.push(false);
                    }
                    this.formatKey.push(WebMolKit.FormatList.GFX_PNG);
                    this.formatGfx.push(true);
                    this.formatKey.push(WebMolKit.FormatList.GFX_SVG);
                    this.formatGfx.push(true);
                    this.formatKey.push(WebMolKit.FormatList.GFX_EPS);
                    this.formatGfx.push(true);
                    this.formatKey.push(WebMolKit.FormatList.GFX_PDF);
                    this.formatGfx.push(true);
                }
                this.formatKey.push(WebMolKit.FormatList.GFX_PNGZIP);
                this.formatGfx.push(true);
                this.formatKey.push(WebMolKit.FormatList.GFX_SVGZIP);
                this.formatGfx.push(true);
                this.formatKey.push(WebMolKit.FormatList.GFX_PDFZIP);
                this.formatGfx.push(true);
                this.formatKey.push(WebMolKit.FormatList.GFX_HTML);
                this.formatGfx.push(true);
            }
            this.formatKey.push(WebMolKit.FormatList.GFX_OOXML_DOCX);
            this.formatGfx.push(true);
            this.formatKey.push(WebMolKit.FormatList.GFX_OOXML_XLSX);
            this.formatGfx.push(true);
            this.fillContent();
        }
        clickPrepare() {
            let input = { 'tokenID': this.tokenID };
            input.format = this.formatKey[this.optFormatList.getSelectedIndex()];
            input.policy = WebMolKit.clone(this.policy.data);
            let sizeType = this.optSizeType.getSelectedValue();
            if (sizeType == 'Scale') {
                input.policy.pointScale = this.lineScale.val();
            }
            else if (sizeType == 'Box') {
                input.policy.pointScale = this.lineBoxMaxScale.val();
                input.box = [this.lineBoxWidth.val(), this.lineBoxHeight.val()];
            }
            this.btnPrepare.prop('disabled', true);
            if (this.mol != null) {
                input.molNative = this.mol.toString();
            }
            else if (this.ds != null) {
                input.dataXML = WebMolKit.DataSheetStream.writeXML(this.ds);
            }
            WebMolKit.Func.prepareDownloadable(input, (result, error) => this.downloadContent(result, error));
        }
        fillContent() {
            let input = { 'tokenID': this.tokenID };
            input.policy = this.policy.data;
            if (this.mol != null) {
                input.molNative = this.mol.toString();
            }
            else if (this.ds != null) {
                input.dataXML = WebMolKit.DataSheetStream.writeXML(this.ds);
                input.dataRow = 0;
            }
            WebMolKit.Func.renderStructure(input, (result, error) => this.updateStructure(result, error));
        }
        updateStructure(result, error) {
            if (!result) {
                alert('Request failed: ' + error.message);
                return;
            }
            let metavec = result.metavec;
            if (this.pictureArea == null)
                this.buildDisplay();
            this.pictureArea.empty();
            let w = metavec.size[0], h = metavec.size[1], padding = 2, scale = 1;
            if (w > 700) {
                let mod = 700 / w;
                scale *= mod;
                w *= mod;
                h *= mod;
            }
            if (h > 500) {
                let mod = 500 / h;
                scale *= mod;
                w *= mod;
                h *= mod;
            }
            let cw = Math.ceil(w) + 2 * padding, ch = Math.ceil(h) + 2 * padding;
            let canvas = WebMolKit.newElement(this.pictureArea, 'canvas', { 'width': cw, 'height': ch });
            let density = WebMolKit.pixelDensity();
            canvas.width = cw * density;
            canvas.height = ch * density;
            canvas.style.width = cw + 'px';
            canvas.style.height = ch + 'px';
            let ctx = canvas.getContext('2d');
            ctx.save();
            ctx.scale(density, density);
            let grad = ctx.createLinearGradient(0, 0, cw, ch);
            if (this.policy.data.background != 0x000000) {
                grad.addColorStop(0, WebMolKit.colourCode(0xF8F8F8));
                grad.addColorStop(1, WebMolKit.colourCode(0xE0E0E0));
            }
            else {
                grad.addColorStop(0, WebMolKit.colourCode(0x404040));
                grad.addColorStop(1, WebMolKit.colourCode(0x101010));
            }
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, cw, h + ch);
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.strokeRect(0.5, 0.5, cw - 1, ch - 1);
            let draw = new WebMolKit.MetaVector(metavec);
            draw.offsetX = padding;
            draw.offsetY = padding;
            draw.scale = scale;
            draw.renderContext(ctx);
            let isExperiment = false;
            if (this.ds != null) {
                for (let n = 0; n < this.ds.numExtensions; n++)
                    if (this.ds.getExtType(n) == 'org.mmi.aspect.Experiment')
                        isExperiment = true;
            }
            if (this.ds != null && this.ds.numRows > 1 && !isExperiment) {
                let dstxt = '... and ' + (this.ds.numRows - 1) + ' more row' + (this.ds.numRows == 2 ? '' : 's') + '.';
                WebMolKit.addText(WebMolKit.newElement(this.pictureArea, 'p'), dstxt);
            }
            ctx.restore();
        }
        ;
        buildDisplay() {
            this.mainArea.empty();
            this.pictureArea = $('<p align="center"></p>').appendTo(this.mainArea);
            this.formatArea = $('<div style="text-align: left;"></div>').appendTo(this.mainArea);
            this.graphicArea = $('<div style="text-align: left;"></div>').appendTo(this.mainArea);
            this.formatArea.append($('<h2 class="tight">Choose Format</h2>'));
            this.formatArea.append($('<hr class="thin"></hr>'));
            let optList = [];
            for (let n = 0; n < this.formatKey.length; n++)
                optList.push('');
            let optFormatList = new WebMolKit.OptionList(optList, true);
            optFormatList.render(this.formatArea);
            for (let n = 0; n < this.formatKey.length; n++) {
                let k = this.formatKey[n];
                $(optFormatList.getAuxiliaryCell(n)).append('\u00A0' + WebMolKit.FormatList.FORMAT_DESCR[k]);
            }
            optFormatList.callbackSelect = (idx, source) => this.changeFormat(idx);
            this.graphicArea.append($('<h2 class="tight">Graphic Options</h2>'));
            this.graphicArea.append($('<hr class="thin"></hr>'));
            let paraSizeType = $('<p></p>').appendTo(this.graphicArea);
            let paraSizeSpec = $('<p></p>').appendTo(this.graphicArea);
            let paraRender = $('<p></p>').appendTo(this.graphicArea);
            let trSize = $('<table><tr></tr></table>').appendTo(paraSizeType).find('tr');
            trSize.append('<td style="vertical-align: middle; font-weight: bold;">Sizing: </td>');
            let optSizeType = new WebMolKit.OptionList(['Scale', 'Box'], false);
            optSizeType.setSelectedIndex(0);
            optSizeType.render($('<td style="vertical-align: middle;"></td>').appendTo(trSize));
            optSizeType.callbackSelect = (idx, source) => this.changeSizeType(idx);
            let divSizeScale = $('<div></div>').appendTo(paraSizeSpec);
            divSizeScale.append('<b>Angstroms-to-Points: </b>');
            let lineScale = $('<input type="text" size="6"></input>"').appendTo(divSizeScale);
            lineScale.val('30');
            let divSizeBox = $('<div style="display: none;"></div>').appendTo(paraSizeSpec);
            divSizeBox.append('<b>Width: </b>');
            let lineBoxWidth = $('<input type="text" size="6"></input>"').appendTo(divSizeBox);
            lineBoxWidth.val('400');
            divSizeBox.append('<b> Height: </b>');
            let lineBoxHeight = $('<input type="text" size="6"></input>"').appendTo(divSizeBox);
            lineBoxHeight.val('300');
            divSizeBox.append(' <b>Max Scale: </b>');
            let lineBoxMaxScale = $('<input type="text" size="6"></input>"').appendTo(divSizeBox);
            lineBoxMaxScale.val('30');
            paraRender.append('<b>Rendering: </b>');
            let selectRender = $('<select></select>').appendTo(paraRender);
            selectRender.append('<option>Black-on-White</option>');
            selectRender.append('<option>Colour-on-White</option>');
            selectRender.append('<option>White-on-Black</option>');
            selectRender.append('<option>Colour-on-Black</option>');
            selectRender.append('<option>Printed Publication</option>');
            selectRender.prop('selectedIndex', 1);
            selectRender.change(() => this.changeRender());
            this.optFormatList = optFormatList;
            this.optSizeType = optSizeType;
            this.divSizeScale = divSizeScale;
            this.divSizeBox = divSizeBox;
            this.lineScale = lineScale;
            this.lineBoxWidth = lineBoxWidth;
            this.lineBoxHeight = lineBoxHeight;
            this.lineBoxMaxScale = lineBoxMaxScale;
            this.selectRender = selectRender;
        }
        changeFormat(idx) {
            let ftype = this.formatKey[idx];
            let psz = 30;
            if (ftype == WebMolKit.FormatList.GFX_OOXML_DOCX || ftype == WebMolKit.FormatList.GFX_OOXML_XLSX)
                psz = 10;
            this.lineScale.val(psz.toString());
        }
        ;
        changeSizeType(idx) {
            if (idx == 0) {
                this.divSizeScale.css('display', 'block');
                this.divSizeBox.css('display', 'none');
            }
            else {
                this.divSizeScale.css('display', 'none');
                this.divSizeBox.css('display', 'block');
            }
        }
        changeRender() {
            let t = this.selectRender.prop('selectedIndex');
            if (t == 0)
                this.policy = WebMolKit.RenderPolicy.defaultBlackOnWhite();
            else if (t == 1)
                this.policy = WebMolKit.RenderPolicy.defaultColourOnWhite();
            else if (t == 2)
                this.policy = WebMolKit.RenderPolicy.defaultWhiteOnBlack();
            else if (t == 3)
                this.policy = WebMolKit.RenderPolicy.defaultColourOnBlack();
            else if (t == 4)
                this.policy = WebMolKit.RenderPolicy.defaultPrintedPublication();
            let input = { 'tokenID': this.tokenID };
            input.policy = this.policy.data;
            if (this.mol != null) {
                input.molNative = this.mol.toString();
            }
            else if (this.ds != null) {
                input.dataXML = WebMolKit.DataSheetStream.writeXML(this.ds);
                input.dataRow = 0;
            }
            WebMolKit.Func.renderStructure(input, () => this.updateStructure);
        }
        downloadContent(result, error) {
            this.btnPrepare.prop('disabled', false);
            if (!result) {
                alert('Request failed: ' + error.message);
                return;
            }
            let format = this.formatKey[this.optFormatList.getSelectedIndex()];
            let id = result.transientID;
            let fn = 'download' + WebMolKit.FormatList.FORMAT_EXTN[format];
            let url = WebMolKit.RPC.BASE_URL + '/Download/' + fn + '?transientID=' + id;
            this.downloadArea.empty();
            WebMolKit.addText(this.downloadArea, 'Temporary download link: ');
            WebMolKit.addText(WebMolKit.newElement(this.downloadArea, 'a', { 'href': url, 'target': '_blank' }), fn);
        }
    }
    WebMolKit.Download = Download;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class Cookies {
        constructor() {
            this.molecules = [];
            this.ASPIRIN = 'SketchEl!(13,13)\n' +
                'C=-1.6010,4.3000;0,0,i0\n' +
                'C=-2.9000,3.5500;0,0,i1\n' +
                'C=-0.3019,3.5500;0,0,i0\n' +
                'C=-2.9000,2.0500;0,0,i1\n' +
                'C=-1.6010,1.3000;0,0,i1\n' +
                'C=-0.3019,2.0500;0,0,i1\n' +
                'C=-1.6010,5.8000;0,0,i0\n' +
                'O=-0.3019,6.5500;0,0,i1\n' +
                'O=-2.9000,6.5500;0,0,i0\n' +
                'O=0.9971,4.3000;0,0,i0\n' +
                'C=2.2962,3.5500;0,0,i0\n' +
                'C=3.5952,4.3000;0,0,i3\n' +
                'O=2.2962,2.0500;0,0,i0\n' +
                '1-2=1,0\n' +
                '1-3=2,0\n' +
                '2-4=2,0\n' +
                '4-5=1,0\n' +
                '5-6=2,0\n' +
                '6-3=1,0\n' +
                '1-7=1,0\n' +
                '7-8=1,0\n' +
                '7-9=2,0\n' +
                '3-10=1,0\n' +
                '10-11=1,0\n' +
                '11-12=1,0\n' +
                '11-13=2,0\n' +
                '!End';
            this.CAFFEINE = 'SketchEl!(14,15)\n' +
                'N=-0.2062,0.7255;0,0,i0\n' +
                'C=1.0929,1.4755;0,0,i0\n' +
                'C=-1.5052,1.4755;0,0,i0\n' +
                'C=1.0929,2.9755;0,0,i0\n' +
                'C=-0.2062,3.7255;0,0,i0\n' +
                'N=-1.5052,2.9755;0,0,i0\n' +
                'N=2.5142,1.0083;0,0,i0\n' +
                'C=3.3966,2.2166;0,0,i1\n' +
                'N=2.5208,3.4370;0,0,i0\n' +
                'O=-2.8042,0.7255;0,0,i0\n' +
                'O=-0.2062,5.2255;0,0,i0\n' +
                'C=2.9896,4.8619;0,0,i3\n' +
                'C=-2.8042,3.7255;0,0,i3\n' +
                'C=-0.2062,-0.7745;0,0,i3\n' +
                '1-2=1,0\n' +
                '1-3=1,0\n' +
                '2-4=2,0\n' +
                '4-5=1,0\n' +
                '5-6=1,0\n' +
                '6-3=1,0\n' +
                '9-8=1,0\n' +
                '8-7=2,0\n' +
                '7-2=1,0\n' +
                '4-9=1,0\n' +
                '3-10=2,0\n' +
                '5-11=2,0\n' +
                '9-12=1,0\n' +
                '6-13=1,0\n' +
                '1-14=1,0\n' +
                '!End';
            this.MAX_MOL_STASH = 20;
            for (var idx = 0;; idx++) {
                let str = this.get('mol' + idx);
                if (str == null)
                    break;
                let mol = WebMolKit.Molecule.fromString(str);
                if (mol == null)
                    break;
                this.molecules.push(mol);
            }
        }
        numMolecules() {
            return this.molecules.length;
        }
        getMolecule(idx) {
            return this.molecules[idx];
        }
        deleteMolecule(idx) {
            this.molecules.splice(idx, 1);
            this.setMolecules();
        }
        stashMolecule(mol) {
            if (WebMolKit.MolUtil.isBlank(mol))
                return;
            for (let n = 0; n < this.molecules.length; n++)
                if (mol.compareTo(this.molecules[n]) == 0) {
                    if (n > 0) {
                        this.molecules.splice(n, 1);
                        this.molecules.splice(0, 0, mol.clone());
                        this.setMolecules();
                    }
                    return;
                }
            this.molecules.splice(0, 0, mol);
            while (this.molecules.length > this.MAX_MOL_STASH)
                this.molecules.pop();
            this.setMolecules();
        }
        promoteToTop(idx) {
            if (idx == 0)
                return;
            let mol = this.molecules.splice(idx, 1)[0];
            this.molecules.splice(0, 0, mol);
            this.setMolecules();
        }
        seedMolecules() {
            this.molecules = [];
            this.molecules.push(WebMolKit.Molecule.fromString(this.CAFFEINE));
            this.molecules.push(WebMolKit.Molecule.fromString(this.ASPIRIN));
            this.setMolecules();
        }
        setMolecules() {
            for (let n = 0; n < this.molecules.length; n++)
                this.set('mol' + n, this.molecules[n].toString());
            this.remove('mol' + this.molecules.length);
        }
        get(key) {
            let value = "; " + document.cookie;
            let parts = value.split("; " + key + "=");
            if (parts.length == 2)
                return decodeURIComponent(parts.pop().split(";").shift());
            return null;
        }
        set(key, val) {
            document.cookie = key + '=' + encodeURIComponent(val);
        }
        remove(key) {
            document.cookie = key + '=; expires=Thu, 01 Jan 1970 00:00:00 GMT';
        }
    }
    WebMolKit.Cookies = Cookies;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class OutlineMeasurement {
        constructor(offsetX, offsetY, pointScale) {
            this.offsetX = offsetX;
            this.offsetY = offsetY;
            this.pointScale = pointScale;
            this.invScale = 1 / pointScale;
        }
        scale() { return this.pointScale; }
        angToX(ax) { return ax * this.pointScale + this.offsetX; }
        angToY(ay) { return ay * -this.pointScale + this.offsetY; }
        xToAng(px) { return (px - this.offsetX) * this.invScale; }
        yToAng(py) { return (py - this.offsetY) * -this.invScale; }
        yIsUp() { return false; }
        measureText(str, fontSize) { return WebMolKit.FontData.main.measureText(str, fontSize); }
    }
    WebMolKit.OutlineMeasurement = OutlineMeasurement;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let BLineType;
    (function (BLineType) {
        BLineType[BLineType["Normal"] = 1] = "Normal";
        BLineType[BLineType["Inclined"] = 2] = "Inclined";
        BLineType[BLineType["Declined"] = 3] = "Declined";
        BLineType[BLineType["Unknown"] = 4] = "Unknown";
        BLineType[BLineType["Dotted"] = 5] = "Dotted";
        BLineType[BLineType["DotDir"] = 6] = "DotDir";
        BLineType[BLineType["IncDouble"] = 7] = "IncDouble";
        BLineType[BLineType["IncTriple"] = 8] = "IncTriple";
        BLineType[BLineType["IncQuadruple"] = 9] = "IncQuadruple";
    })(BLineType = WebMolKit.BLineType || (WebMolKit.BLineType = {}));
    class ArrangeMolecule {
        constructor(mol, measure, policy, effects = new WebMolKit.RenderEffects()) {
            this.mol = mol;
            this.measure = measure;
            this.policy = policy;
            this.effects = effects;
            this.MINBOND_LINE = 0.25;
            this.MINBOND_EXOTIC = 0.5;
            this.points = [];
            this.lines = [];
            this.rings = [];
            this.paths = [];
            this.space = [];
            this.wantArtifacts = true;
            this.artifacts = null;
            this.bondOrder = [];
            this.atomCharge = [];
            this.atomUnpaired = [];
            this.artifactCharge = new Map();
            this.artifactUnpaired = new Map();
            this.artifactFract = new Map();
        }
        static guestimateSize(mol, policy, maxW, maxH) {
            let box = mol.boundary();
            let minX = box.minX(), minY = box.minY(), maxX = box.maxX(), maxY = box.maxY();
            let fontSize = policy.data.fontSize * this.FONT_CORRECT;
            for (let n = 1; n <= mol.numAtoms; n++)
                if (mol.atomExplicit(n)) {
                    let plusH = mol.atomHydrogens(n) > 0 ? 1 : 0;
                    const aw = 0.5 * 0.7 * fontSize * (mol.atomElement(n).length + plusH);
                    const ah = 0.5 * fontSize * (1 + plusH);
                    const ax = mol.atomX(n), ay = mol.atomY(n);
                    minX = Math.min(minX, ax - aw);
                    maxX = Math.max(maxX, ax + aw);
                    minY = Math.min(minY, ay - ah);
                    maxY = Math.max(maxY, ay + ah);
                }
            let w = Math.max(1, (maxX - minX)) * policy.data.pointScale;
            let h = Math.max(1, (maxY - minY)) * policy.data.pointScale;
            if (maxW > 0 && w > maxW) {
                h *= maxW / w;
                w = maxW;
            }
            if (maxH > 0 && h > maxH) {
                w *= maxH / h;
                h = maxH;
            }
            return [w, h];
        }
        getMolecule() { return this.mol; }
        getMeasure() { return this.measure; }
        getPolicy() { return this.policy; }
        getEffects() { return this.effects; }
        getScale() { return this.scale; }
        setWantArtifacts(want) { this.wantArtifacts = want; }
        getArtifacts() { return this.artifacts; }
        setArtifacts(artifacts) { this.artifacts = artifacts; }
        arrange() {
            const mol = this.mol;
            this.scale = this.measure.scale();
            this.bondSepPix = this.policy.data.bondSep * this.measure.scale();
            this.lineSizePix = this.policy.data.lineSize * this.measure.scale();
            this.fontSizePix = this.policy.data.fontSize * this.measure.scale() * ArrangeMolecule.FONT_CORRECT;
            this.ymul = this.measure.yIsUp() ? -1 : 1;
            let artmask = null;
            if (this.wantArtifacts && this.artifacts == null) {
                this.artifacts = new WebMolKit.BondArtifact(mol);
                artmask = WebMolKit.Vec.booleanArray(false, mol.numAtoms);
                for (let path of this.artifacts.getResPaths())
                    for (let a of path.atoms)
                        artmask[a - 1] = true;
                for (let ring of this.artifacts.getResRings())
                    for (let a of ring.atoms)
                        artmask[a - 1] = true;
                for (let arene of this.artifacts.getArenes()) {
                    artmask[arene.centre - 1] = true;
                    for (let a of arene.atoms)
                        artmask[a - 1] = true;
                }
            }
            this.setupBondOrders();
            for (let n = 1; n <= mol.numAtoms; n++) {
                if (mol.atomElement(n).length > 2 && mol.atomHydrogens(n) == 0) {
                    this.points.push(null);
                    this.space.push(null);
                    continue;
                }
                let a = {
                    'anum': n,
                    'text': mol.atomExplicit(n) || this.atomIsWeirdLinear(n) ? mol.atomElement(n) : null,
                    'fsz': this.fontSizePix,
                    'bold': mol.atomMapNum(n) > 0,
                    'col': this.policy.data.atomCols[mol.atomicNumber(n)],
                    'oval': new WebMolKit.Oval(this.measure.angToX(mol.atomX(n)), this.measure.angToY(mol.atomY(n)), 0, 0)
                };
                let overCol = this.effects.colAtom[n];
                if (overCol)
                    a.col = overCol;
                if (artmask[n - 1] && mol.atomElement(n) == 'C')
                    a.text = null;
                if (a.text != null) {
                    let wad = this.measure.measureText(a.text, a.fsz);
                    const PADDING = 1.1;
                    a.oval.rw = 0.5 * wad[0] * PADDING;
                    a.oval.rh = 0.5 * wad[1] * PADDING;
                }
                this.points.push(a);
                this.space.push(this.computeSpacePoint(a));
            }
            for (let n = 1; n <= mol.numAtoms; n++)
                if (this.points[n - 1] == null)
                    this.processLabel(n);
            let bdbl = WebMolKit.Vec.booleanArray(false, mol.numBonds);
            for (let n = 1; n <= mol.numBonds; n++) {
                let bfr = mol.bondFrom(n), bto = mol.bondTo(n);
                let bt = mol.bondType(n), bo = this.bondOrder[n - 1];
                if (bo < 0)
                    continue;
                let col = this.effects.colBond[n];
                if (!col)
                    col = this.policy.data.foreground;
                bdbl[n - 1] = bo == 2 && (bt == WebMolKit.Molecule.BONDTYPE_NORMAL || bt == WebMolKit.Molecule.BONDTYPE_UNKNOWN);
                let a1 = this.points[bfr - 1], a2 = this.points[bto - 1];
                let x1 = a1.oval.cx, y1 = a1.oval.cy, x2 = a2.oval.cx, y2 = a2.oval.cy;
                if (Math.abs(x2 - x1) <= 1 && Math.abs(y2 - y1) <= 1) {
                    bdbl[n - 1] = false;
                    continue;
                }
                if (bdbl[n - 1])
                    continue;
                let minDist = (bo == 1 && bt == WebMolKit.Molecule.BONDTYPE_NORMAL ? this.MINBOND_LINE : this.MINBOND_EXOTIC) * this.measure.scale();
                let xy1 = this.backOffAtom(bfr, x1, y1, x2, y2, minDist);
                let xy2 = this.backOffAtom(bto, x2, y2, x1, y1, minDist);
                this.ensureMinimumBondLength(xy1, xy2, x1, y1, x2, y2, minDist);
                let sz = this.lineSizePix, head = 0;
                let ltype = BLineType.Normal;
                if (bo == 1 && bt == WebMolKit.Molecule.BONDTYPE_INCLINED) {
                    ltype = BLineType.Inclined;
                    head = 0.15 * this.measure.scale();
                }
                else if (bo == 1 && bt == WebMolKit.Molecule.BONDTYPE_DECLINED) {
                    ltype = BLineType.Declined;
                    head = 0.15 * this.measure.scale();
                }
                else if (bt == WebMolKit.Molecule.BONDTYPE_UNKNOWN) {
                    ltype = BLineType.Unknown;
                    head = 0.2 * this.measure.scale();
                }
                else if (bo == 0) {
                    if (bt == WebMolKit.Molecule.BONDTYPE_INCLINED || bt == WebMolKit.Molecule.BONDTYPE_DECLINED)
                        ltype = BLineType.DotDir;
                    else
                        ltype = BLineType.Dotted;
                }
                else if ((bo == 2 || bo == 3 || bo == 4) && (bt == WebMolKit.Molecule.BONDTYPE_INCLINED || bt == WebMolKit.Molecule.BONDTYPE_DECLINED)) {
                    ltype = bo == 2 ? BLineType.IncDouble : bo == 3 ? BLineType.IncTriple : BLineType.IncQuadruple;
                    head = (bo == 2 ? 0.20 : 0.25) * this.measure.scale();
                }
                if (bo == 0) {
                    let dx = xy2[0] - xy1[0], dy = xy2[1] - xy1[1];
                    let d = WebMolKit.norm_xy(dx, dy), invD = 1 / d;
                    let ox = 0.5 * dx * invD * this.bondSepPix, oy = 0.5 * dy * invD * this.bondSepPix;
                    if (mol.atomAdjCount(bfr) > 1) {
                        xy1[0] += ox;
                        xy1[1] += oy;
                    }
                    if (mol.atomAdjCount(bto) > 1) {
                        xy2[0] -= ox;
                        xy2[1] -= oy;
                    }
                }
                if (bo != 1 && bt == WebMolKit.Molecule.BONDTYPE_DECLINED) {
                    let tmp = xy1;
                    xy1 = xy2;
                    xy2 = tmp;
                }
                if (bo > 1 && (bt == WebMolKit.Molecule.BONDTYPE_NORMAL || bt == WebMolKit.Molecule.BONDTYPE_UNKNOWN)) {
                    let oxy = this.orthogonalDelta(xy1[0], xy1[1], xy2[0], xy2[1], this.bondSepPix);
                    let v = -0.5 * (bo - 1);
                    for (let i = 0; i < bo; i++, v++) {
                        let lx1 = xy1[0] + v * oxy[0], ly1 = xy1[1] + v * oxy[1], lx2 = xy2[0] + v * oxy[0], ly2 = xy2[1] + v * oxy[1];
                        let b = {
                            'bnum': n,
                            'bfr': bfr,
                            'bto': bto,
                            'type': ltype,
                            'line': new WebMolKit.Line(lx1, ly1, lx2, ly2),
                            'size': sz,
                            'head': 0,
                            'col': col
                        };
                        this.lines.push(b);
                        this.space.push(this.computeSpaceLine(b));
                    }
                }
                else {
                    let b = {
                        'bnum': n,
                        'bfr': bfr,
                        'bto': bto,
                        'type': ltype,
                        'line': new WebMolKit.Line(xy1[0], xy1[1], xy2[0], xy2[1]),
                        'size': sz,
                        'head': head,
                        'col': col
                    };
                    this.lines.push(b);
                    this.space.push(this.computeSpaceLine(b));
                }
            }
            let rings = this.orderedRingList();
            for (let i = 0; i < rings.length; i++) {
                for (let j = 0; j < rings[i].length; j++) {
                    let k = mol.findBond(rings[i][j], rings[i][j < rings[i].length - 1 ? j + 1 : 0]);
                    if (bdbl[k - 1]) {
                        this.processDoubleBond(k, rings[i]);
                        bdbl[k - 1] = false;
                    }
                }
            }
            for (let i = 1; i <= mol.numBonds; i++)
                if (bdbl[i - 1])
                    this.processDoubleBond(i, this.priorityDoubleSubstit(i));
            let hcount = WebMolKit.Vec.numberArray(0, mol.numAtoms);
            for (let n = 1; n <= mol.numAtoms; n++)
                hcount[n - 1] = this.points[n - 1].text == null ? 0 : mol.atomHydrogens(n);
            for (let n = 0; n < mol.numAtoms; n++)
                if (hcount[n] > 0 && this.placeHydrogen(n, hcount[n], true))
                    hcount[n] = 0;
            for (let n = 0; n < mol.numAtoms; n++)
                if (hcount[n] > 0)
                    this.placeHydrogen(n, hcount[n], false);
            for (let n = 1; n <= mol.numAtoms; n++)
                if (mol.atomIsotope(n) != WebMolKit.Molecule.ISOTOPE_NATURAL) {
                    let isostr = mol.atomIsotope(n).toString();
                    let col = this.policy.data.atomCols[mol.atomicNumber(n)];
                    this.placeAdjunct(n, isostr, this.fontSizePix * 0.6, col, 150 * WebMolKit.DEGRAD);
                }
            for (let n = 1; n <= mol.numAtoms; n++) {
                let str = '';
                let chg = this.atomCharge[n - 1];
                if (chg == -1)
                    str = '-';
                else if (chg == 1)
                    str = '+';
                else if (chg < -1)
                    str = Math.abs(chg) + '-';
                else if (chg > 1)
                    str = chg + '+';
                for (let i = this.atomUnpaired[n - 1]; i > 0; i--)
                    str += '.';
                if (str.length == 0)
                    continue;
                let col = this.policy.data.atomCols[mol.atomicNumber(n)];
                this.placeAdjunct(n, str, str.length == 1 ? 0.8 * this.fontSizePix : 0.6 * this.fontSizePix, col, 30 * WebMolKit.DEGRAD);
            }
            if (this.artifacts != null) {
                for (let path of this.artifacts.getResPaths()) {
                    this.createCurvedPath(path.atoms, this.artifactFract.get(path), 0);
                    this.delocalisedAnnotation(path.atoms, this.artifactCharge.get(path), this.artifactUnpaired.get(path));
                }
                for (let ring of this.artifacts.getResRings()) {
                    this.createCircularRing(ring.atoms);
                    this.delocalisedAnnotation(ring.atoms, this.artifactCharge.get(ring), this.artifactUnpaired.get(ring));
                }
                for (let arene of this.artifacts.getArenes()) {
                    let isRing = arene.atoms.length > 2;
                    if (isRing)
                        for (let n = 0; n < arene.atoms.length; n++) {
                            let nn = n < arene.atoms.length - 1 ? n + 1 : 0;
                            if (mol.findBond(arene.atoms[n], arene.atoms[nn]) == 0) {
                                isRing = false;
                                break;
                            }
                        }
                    this.createBondCentroid(arene.centre, arene.atoms);
                    if (isRing)
                        this.createCircularRing(arene.atoms);
                    else
                        this.createCurvedPath(arene.atoms, false, arene.centre);
                    this.delocalisedAnnotation(arene.atoms, this.artifactCharge.get(arene), this.artifactUnpaired.get(arene));
                }
            }
        }
        numPoints() { return this.points.length; }
        getPoint(idx) { return this.points[idx]; }
        numLines() { return this.lines.length; }
        getLine(idx) { return this.lines[idx]; }
        numRings() { return this.rings.length; }
        getRing(idx) { return this.rings[idx]; }
        getRings() { return this.rings; }
        numPaths() { return this.paths.length; }
        getPath(idx) { return this.paths[idx]; }
        getPaths() { return this.paths; }
        numSpace() { return this.space.length; }
        getSpace(idx) { return this.space[idx]; }
        offsetEverything(dx, dy) {
            for (let a of this.points)
                a.oval.offsetBy(dx, dy);
            for (let b of this.lines)
                b.line.offsetBy(dx, dy);
            for (let r of this.rings) {
                r.cx += dx;
                r.cy += dy;
            }
            for (let p of this.paths) {
                WebMolKit.Vec.addTo(p.px, dx);
                WebMolKit.Vec.addTo(p.py, dy);
            }
            for (let spc of this.space) {
                spc.box.offsetBy(dx, dy);
                WebMolKit.Vec.addTo(spc.px, dx);
                WebMolKit.Vec.addTo(spc.py, dy);
            }
        }
        scaleEverything(scaleBy) {
            this.scale *= scaleBy;
            for (let a of this.points) {
                a.oval.scaleBy(scaleBy);
                a.fsz *= scaleBy;
            }
            for (let b of this.lines) {
                b.line.scaleBy(scaleBy);
                b.size *= scaleBy;
                b.head *= scaleBy;
            }
            for (let r of this.rings) {
                r.cx *= scaleBy;
                r.cy *= scaleBy;
                r.rw *= scaleBy;
                r.rh *= scaleBy;
            }
            for (let p of this.paths) {
                WebMolKit.Vec.mulBy(p.px, scaleBy);
                WebMolKit.Vec.mulBy(p.py, scaleBy);
            }
            for (let spc of this.space) {
                spc.box.scaleBy(scaleBy);
                WebMolKit.Vec.mulBy(spc.px, scaleBy);
                WebMolKit.Vec.mulBy(spc.py, scaleBy);
            }
        }
        determineBoundary(padding) {
            if (padding == null)
                padding = 0;
            if (this.space.length == 0)
                return [0, 0, 2 * padding, 2 * padding];
            let bounds = WebMolKit.Vec.numberArray(0, 4);
            let spc = this.space[0];
            bounds[0] = spc.box.x;
            bounds[1] = spc.box.y;
            bounds[2] = spc.box.x + spc.box.w;
            bounds[3] = spc.box.y + spc.box.h;
            for (let n = this.space.length - 1; n > 0; n--) {
                spc = this.space[n];
                bounds[0] = Math.min(bounds[0], spc.box.x);
                bounds[1] = Math.min(bounds[1], spc.box.y);
                bounds[2] = Math.max(bounds[2], spc.box.x + spc.box.w);
                bounds[3] = Math.max(bounds[3], spc.box.y + spc.box.h);
            }
            return bounds;
        }
        squeezeInto(x, y, w, h, padding) {
            if (padding != null && padding > 0) {
                x += padding;
                y += padding;
                w -= 2 * padding;
                h -= 2 * padding;
            }
            let bounds = this.determineBoundary(0);
            let bw = bounds[2] - bounds[0], bh = bounds[3] - bounds[1];
            if (bw > w || bh > h) {
                let downScale = 1;
                if (bw > w)
                    downScale = w / bw;
                if (bh > h)
                    downScale = Math.min(downScale, h / bh);
                this.scaleEverything(downScale);
                WebMolKit.Vec.mulBy(bounds, downScale);
            }
            this.offsetEverything(x - bounds[0] + 0.5 * (w - bounds[2] + bounds[0]), y - bounds[1] + 0.5 * (h - bounds[3] + bounds[1]));
        }
        monochromate(col) {
            for (let a of this.points)
                a.col = col;
            for (let b of this.lines)
                b.col = col;
        }
        clone() {
            let dup = new ArrangeMolecule(this.mol, this.measure, this.policy, this.effects);
            dup.scale = this.scale;
            dup.bondSepPix = this.bondSepPix;
            dup.lineSizePix = this.lineSizePix;
            dup.fontSizePix = this.fontSizePix;
            dup.ymul = this.ymul;
            for (let a of this.points)
                dup.points.push(WebMolKit.clone(a));
            for (let b of this.lines)
                dup.lines.push(WebMolKit.clone(b));
            for (let s of this.space)
                dup.space.push(WebMolKit.clone(s));
            return dup;
        }
        setupBondOrders() {
            const mol = this.mol;
            for (let n = 0; n < mol.numBonds; n++)
                this.bondOrder[n] = mol.bondOrder(n + 1);
            for (let n = 0; n < mol.numAtoms; n++) {
                this.atomCharge[n] = mol.atomCharge(n + 1);
                this.atomUnpaired[n] = mol.atomUnpaired(n + 1);
            }
            let delocalise = (obj, atoms) => {
                let charge = 0, unpaired = 0;
                for (let a of atoms) {
                    charge += this.atomCharge[a - 1];
                    unpaired += this.atomUnpaired[a - 1];
                    this.atomCharge[a - 1] = this.atomUnpaired[a - 1] = 0;
                }
                this.artifactCharge.set(obj, charge);
                this.artifactUnpaired.set(obj, unpaired);
            };
            if (this.artifacts == null)
                return;
            for (let path of this.artifacts.getResPaths()) {
                let charge = 0, unpaired = 0, orders = 0;
                for (let n = 0; n < path.atoms.length; n++) {
                    charge += mol.atomCharge(path.atoms[n]);
                    unpaired += mol.atomUnpaired(path.atoms[n]);
                    let b = mol.findBond(path.atoms[n], path.atoms[n < path.atoms.length - 1 ? n + 1 : 0]);
                    if (b > 0)
                        orders += mol.bondOrder(b);
                }
                let fractional = (2 * orders - charge + unpaired) / path.atoms.length < 1;
                this.artifactFract.set(path, fractional);
                for (let n = 0; n < path.atoms.length - 1; n++) {
                    let b = mol.findBond(path.atoms[n], path.atoms[n + 1]);
                    if (b > 0)
                        this.bondOrder[b - 1] = fractional ? -1 : 1;
                }
                delocalise(path, path.atoms);
            }
            for (let ring of this.artifacts.getResRings()) {
                for (let n = 0; n < ring.atoms.length; n++) {
                    let b = mol.findBond(ring.atoms[n], ring.atoms[n < ring.atoms.length - 1 ? n + 1 : 0]);
                    if (b > 0)
                        this.bondOrder[b - 1] = 1;
                }
                delocalise(ring, ring.atoms);
            }
            for (let arene of this.artifacts.getArenes()) {
                for (let n = 0; n < arene.atoms.length; n++) {
                    let b = mol.findBond(arene.atoms[n], arene.atoms[n < arene.atoms.length - 1 ? n + 1 : 0]);
                    if (b > 0)
                        this.bondOrder[b - 1] = 1;
                    b = mol.findBond(arene.centre, arene.atoms[n]);
                    if (b > 0)
                        this.bondOrder[b - 1] = -1;
                }
                delocalise(arene, arene.atoms);
            }
        }
        placeAdjunct(atom, str, fsz, col, angdir) {
            let wad = this.measure.measureText(str, fsz);
            let a = this.points[atom - 1];
            let cx = a.oval.cx, cy = a.oval.cy, rw = 0.55 * wad[0], rh = 0.55 * wad[1];
            let bestScore = 0, bestDX = 0, bestDY = 0;
            let px = WebMolKit.Vec.numberArray(0, 4), py = WebMolKit.Vec.numberArray(0, 4);
            let angThresh = 10;
            let shorted = false;
            for (let ext = 0.5 * (a.oval.rw + a.oval.rh); !shorted && ext < 1.5 * this.measure.scale(); ext += 0.1 * this.measure.scale()) {
                const DELTA = 5 * WebMolKit.DEGRAD;
                for (let d = 0; !shorted && d < Math.PI - 0.0001; d += DELTA)
                    for (let s = -1; s <= 1; s += 2) {
                        let dang = d * s + (s > 0 ? DELTA : 0), ang = angdir + dang;
                        let dx = ext * Math.cos(ang), dy = ext * Math.sin(ang) * -this.ymul;
                        let x1 = cx + dx - rw, x2 = cx + dx + rw, y1 = cy + dy - rh, y2 = cy + dy + rh;
                        px[0] = x1;
                        py[0] = y1;
                        px[1] = x2;
                        py[1] = y1;
                        px[2] = x2;
                        py[2] = y2;
                        px[3] = x1;
                        py[3] = y2;
                        let viol = this.countPolyViolations(px, py, false);
                        let score = 10 * viol + Math.abs(dang) + 10 * ext;
                        let shortCircuit = viol == 0 && Math.abs(dang) < (angThresh + 1) * WebMolKit.DEGRAD;
                        if (bestScore == 0 || shortCircuit || score < bestScore) {
                            bestScore = score;
                            bestDX = dx;
                            bestDY = dy;
                        }
                        if (shortCircuit) {
                            shorted = true;
                            break;
                        }
                    }
                angThresh += 5;
            }
            a =
                {
                    'anum': 0,
                    'text': str,
                    'fsz': fsz,
                    'bold': false,
                    'col': col,
                    'oval': new WebMolKit.Oval(cx + bestDX, cy + bestDY, rw, rh)
                };
            this.points.push(a);
            let spc = {
                'anum': 0,
                'bnum': 0,
                'box': new WebMolKit.Box(a.oval.cx - rw, a.oval.cy - rh, 2 * rw, 2 * rh),
                'px': [a.oval.cx - rw, a.oval.cx + rw, a.oval.cx + rw, a.oval.cx - rw],
                'py': [a.oval.cy - rh, a.oval.cy - rh, a.oval.cy + rh, a.oval.cy + rh]
            };
            this.space.push(spc);
        }
        processLabel(anum) {
            let ax = this.mol.atomX(anum), ay = this.mol.atomY(anum);
            let left = 0, right = 0;
            let adj = this.mol.atomAdjList(anum);
            for (let n = 0; n < adj.length; n++) {
                let theta = Math.atan2(this.mol.atomY(adj[n]) - ay, this.mol.atomX(adj[n]) - ax) * WebMolKit.RADDEG;
                if (theta >= -15 && theta <= 15)
                    right += 3;
                else if (theta >= -85 && theta <= 85)
                    right++;
                else if (theta > 85 && theta < 95) { }
                else if (theta < -85 && theta > -95) { }
                else if (theta > 165 || theta < -165)
                    left += 3;
                else
                    left++;
            }
            let label = this.mol.atomElement(anum);
            let ibar = label.indexOf('|'), ibrace = label.indexOf('{');
            let side = 0;
            if (left == 0 && right == 0 && ibar < 0 && ibrace < 0) { }
            else if (left < right)
                side = -1;
            else if (right < left)
                side = 1;
            else {
                let score1 = WebMolKit.CoordUtil.congestionPoint(this.mol, ax - 1, ay);
                let score2 = WebMolKit.CoordUtil.congestionPoint(this.mol, ax + 1, ay);
                if (score1 < 0.5 * score2)
                    side = -1;
                else
                    side = 1;
            }
            let chunks = null;
            let position = null;
            let primary = null;
            let refchunk = 0;
            if (ibar < 0 && ibrace < 0) {
                if (side == 0)
                    chunks = [label];
                else if (side < 0) {
                    chunks = [label.substring(0, label.length - 1), label.substring(label.length - 1)];
                    refchunk = 1;
                }
                else
                    chunks = [label.substring(0, 1), label.substring(1)];
            }
            else {
                let bits = [];
                let bpos = [];
                let bpri = [];
                let blocks = label.split('|');
                if (side < 0) {
                    let oldblk = blocks;
                    blocks = [];
                    for (let i = oldblk.length - 1; i >= 0; i--)
                        blocks.push(oldblk[i]);
                }
                let buff = '';
                for (let i = 0; i < blocks.length; i++) {
                    let isPrimary = (side >= 0 && i == 0) || (side < 0 && i == blocks.length - 1);
                    if (side < 0 && refchunk == 0 && i == blocks.length - 1)
                        refchunk = bits.length;
                    let pos = 0;
                    buff = '';
                    for (let j = 0; j < blocks[i].length; j++) {
                        let ch = blocks[i].charAt(j);
                        if (ch == '{' || ch == '}') {
                            if (buff.length > 0) {
                                bits.push(buff.toString());
                                bpos.push(pos);
                                bpri.push(isPrimary);
                            }
                            buff = '';
                            pos = ch == '{' ? -1 : 0;
                        }
                        else if (ch == '^' && pos == -1 && buff.length == 0)
                            pos = 1;
                        else
                            buff += ch;
                    }
                    if (buff.length > 0) {
                        bits.push(buff.toString());
                        bpos.push(pos);
                        bpri.push(isPrimary);
                    }
                }
                chunks = bits;
                position = bpos;
                primary = bpri;
                while (refchunk < chunks.length - 1 && position[refchunk] != 0)
                    refchunk++;
            }
            let PADDING = 1.1;
            let SSFRACT = 0.6;
            let chunkw = WebMolKit.Vec.numberArray(0, chunks.length);
            let tw = 0;
            for (let n = 0; n < chunks.length; n++) {
                chunkw[n] = this.measure.measureText(chunks[n], this.fontSizePix)[0];
                if (position != null && position[n] != 0)
                    chunkw[n] *= SSFRACT;
                tw += chunkw[n];
            }
            let x = this.measure.angToX(ax), y = this.measure.angToY(ay);
            if (side == 0)
                x -= 0.5 * chunkw[0];
            else if (side < 0) {
                for (let n = 0; n < refchunk; n++)
                    x -= chunkw[n];
                x -= 0.5 * chunkw[refchunk];
            }
            else {
                x -= 0.5 * chunkw[0];
            }
            for (let n = 0; n < chunks.length; n++) {
                let a = {
                    'anum': (n == refchunk || (primary != null && primary[n])) ? anum : 0,
                    'text': chunks[n],
                    'fsz': this.fontSizePix,
                    'bold': false,
                    'col': this.policy.data.atomCols[this.mol.atomicNumber(anum)],
                    'oval': new WebMolKit.Oval(x + 0.5 * chunkw[n], y, 0.5 * chunkw[n] * PADDING, 0.5 * this.fontSizePix * PADDING)
                };
                if (position != null && position[n] != 0) {
                    a.fsz *= SSFRACT;
                    if (position[n] < 0)
                        a.oval.cy += a.fsz * 0.7 * (this.measure.yIsUp() ? -1 : 1);
                    else
                        a.oval.cy -= a.fsz * 0.3 * (this.measure.yIsUp() ? -1 : 1);
                }
                if (n == refchunk) {
                    this.points[anum - 1] = a;
                    this.space[anum - 1] = this.computeSpacePoint(a);
                }
                else {
                    this.points.push(a);
                    this.space.push(this.computeSpacePoint(a));
                }
                x += chunkw[n];
            }
        }
        atomIsWeirdLinear(idx) {
            let bonds = this.mol.atomAdjBonds(idx);
            if (bonds.length != 2)
                return false;
            for (let n = 0; n < bonds.length; n++)
                if (this.mol.bondOrder(bonds[n]) == 3)
                    return false;
            let adj = this.mol.atomAdjList(idx);
            let th1 = Math.atan2(this.mol.atomY(adj[0]) - this.mol.atomY(idx), this.mol.atomX(adj[0]) - this.mol.atomX(idx));
            let th2 = Math.atan2(this.mol.atomY(adj[1]) - this.mol.atomY(idx), this.mol.atomX(adj[1]) - this.mol.atomX(idx));
            return Math.abs(WebMolKit.angleDiff(th1, th2)) >= 175 * WebMolKit.DEGRAD;
        }
        backOffAtom(atom, x, y, fx, fy, minDist) {
            if (x == fx && y == fy)
                return [x, y];
            let active = false;
            let dx = 0, dy = 0, dst = 0, ext = 0;
            for (let s = 0; s < this.space.length; s++) {
                let spc = this.space[s];
                if (spc.anum != atom)
                    continue;
                const sz = spc.px.length;
                if (sz == 0)
                    continue;
                for (let n = 0; n < sz; n++) {
                    let nn = n < sz - 1 ? n + 1 : 0;
                    let x1 = spc.px[n], y1 = spc.py[n], x2 = spc.px[nn], y2 = spc.py[nn];
                    if (!WebMolKit.GeomUtil.doLineSegsIntersect(x, y, fx, fy, x1, y1, x2, y2))
                        continue;
                    let xy = WebMolKit.GeomUtil.lineIntersect(x, y, fx, fy, x1, y1, x2, y2);
                    if (!active) {
                        dx = x - fx;
                        dy = y - fy;
                        dst = WebMolKit.norm_xy(dx, dy);
                        ext = dst;
                        active = true;
                    }
                    ext = Math.min(ext, WebMolKit.norm_xy(xy[0] - fx, xy[1] - fy));
                }
            }
            if (active) {
                ext = Math.max(minDist, ext - 0.1 * this.measure.scale());
                let idst = 1.0 / dst;
                return [fx + ext * idst * dx, fy + ext * idst * dy];
            }
            else
                return [x, y];
        }
        ensureMinimumBondLength(xy1, xy2, x1, y1, x2, y2, minDist) {
            let dx = xy2[0] - xy1[0], dy = xy2[1] - xy1[1];
            let dsq = WebMolKit.norm2_xy(dx, dy);
            minDist = Math.min(minDist, WebMolKit.norm_xy(x2 - x1, y2 - y1));
            if (dsq >= WebMolKit.sqr(minDist - 0.0001))
                return;
            let d12 = Math.sqrt(dsq), d1 = WebMolKit.norm_xy(xy1[0] - x1, xy1[1] - y1), d2 = WebMolKit.norm_xy(x2 - xy2[0], y2 - xy2[1]);
            let mag = 1 - minDist / d12, invD12 = 1.0 / (d1 + d2), mag1 = d1 * mag * invD12, mag2 = d2 * mag * invD12;
            xy1[0] -= dx * mag1;
            xy1[1] -= dy * mag1;
            xy2[0] += dx * mag2;
            xy2[1] += dy * mag2;
        }
        orderedRingList() {
            let rings = [];
            let SIZE_ORDER = [6, 5, 7, 4, 3];
            for (let i = 0; i < SIZE_ORDER.length; i++) {
                let nring = this.mol.findRingsOfSize(SIZE_ORDER[i]);
                for (let j = 0; j < nring.length; j++)
                    rings.push(nring[j]);
            }
            let ringsz = rings.length;
            let ringbusy = WebMolKit.Vec.numberArray(0, this.mol.numAtoms);
            for (let n = 0; n < ringsz; n++) {
                let r = rings[n];
                for (let i = 0; i < r.length; i++)
                    ringbusy[r[i] - 1]++;
            }
            let ringscore = WebMolKit.Vec.numberArray(0, ringsz);
            for (let n = 0; n < ringsz; n++) {
                let r = rings[n];
                for (let i = 0; i < r.length; i++)
                    ringscore[n] += ringbusy[r[i] - 1];
            }
            let ringorder = WebMolKit.Vec.idxSort(ringscore);
            let resbcount = WebMolKit.Vec.numberArray(0, ringsz), maxbcount = 0;
            for (let n = 0; n < ringsz; n++) {
                let r = rings[ringorder[n]];
                for (let i = 0; i < r.length; i++) {
                    let j = this.mol.findBond(r[i], r[i + 1 < r.length ? i + 1 : 0]);
                    if (this.mol.bondOrder(j) == 2)
                        resbcount[n]++;
                }
                maxbcount = Math.max(maxbcount, resbcount[n]);
            }
            let pos = 0, ret = [];
            for (let sz = maxbcount; sz >= 0; sz--) {
                for (let n = 0; n < ringsz; n++)
                    if (resbcount[n] == sz)
                        ret.push(rings[ringorder[n]]);
            }
            return ret;
        }
        orthogonalDelta(x1, y1, x2, y2, d) {
            let ox = y1 - y2, oy = x2 - x1, dsq = WebMolKit.norm2_xy(ox, oy);
            let sc = dsq > 0 ? d / Math.sqrt(dsq) : 1;
            return [ox * sc, oy * sc];
        }
        processDoubleBond(idx, priority) {
            let bfr = this.mol.bondFrom(idx), bto = this.mol.bondTo(idx);
            let nfr = this.mol.atomAdjList(bfr), nto = this.mol.atomAdjList(bto);
            let a1 = this.points[bfr - 1], a2 = this.points[bto - 1];
            let x1 = a1.oval.cx, y1 = a1.oval.cy, x2 = a2.oval.cx, y2 = a2.oval.cy;
            const minDist = this.MINBOND_EXOTIC * this.measure.scale();
            let xy1 = this.backOffAtom(bfr, x1, y1, x2, y2, minDist);
            let xy2 = this.backOffAtom(bto, x2, y2, x1, y1, minDist);
            this.ensureMinimumBondLength(xy1, xy2, x1, y1, x2, y2, minDist);
            x1 = xy1[0];
            y1 = xy1[1];
            x2 = xy2[0];
            y2 = xy2[1];
            let dx = x2 - x1, dy = y2 - y1, btheta = Math.atan2(dy, dx);
            let countFLeft = 0, countFRight = 0, countTLeft = 0, countTRight = 0;
            let idxFLeft = 0, idxFRight = 0, idxTLeft = 0, idxTRight = 0;
            let noshift = false;
            for (let n = 0; n < nfr.length; n++)
                if (nfr[n] != bto) {
                    let bo = this.mol.bondOrder(this.mol.findBond(bfr, nfr[n]));
                    if (bo == 0)
                        continue;
                    if (bo > 1) {
                        noshift = true;
                        break;
                    }
                    let ispri = false;
                    for (let i = 0; i < (priority == null ? 0 : priority.length); i++)
                        if (priority[i] == nfr[n])
                            ispri = true;
                    let theta = WebMolKit.angleDiff(Math.atan2(this.points[nfr[n] - 1].oval.cy - y1, this.points[nfr[n] - 1].oval.cx - x1), btheta);
                    if (Math.abs(theta) * WebMolKit.RADDEG > 175) {
                        noshift = true;
                        break;
                    }
                    if (theta > 0) {
                        if (ispri)
                            countFLeft++;
                        idxFLeft = nfr[n];
                    }
                    else {
                        if (ispri)
                            countFRight++;
                        idxFRight = nfr[n];
                    }
                }
            for (let n = 0; n < nto.length; n++)
                if (nto[n] != bfr) {
                    let bo = this.mol.bondOrder(this.mol.findBond(bto, nto[n]));
                    if (bo == 0)
                        continue;
                    if (bo > 1) {
                        noshift = true;
                        break;
                    }
                    let ispri = false;
                    for (let i = 0; i < (priority == null ? 0 : priority.length); i++)
                        if (priority[i] == nto[n])
                            ispri = true;
                    let theta = WebMolKit.angleDiff(Math.atan2(this.points[nto[n] - 1].oval.cy - y2, this.points[nto[n] - 1].oval.cx - x2), btheta);
                    if (Math.abs(theta) * WebMolKit.RADDEG > 175) {
                        noshift = true;
                        break;
                    }
                    if (theta > 0) {
                        if (ispri)
                            countTLeft++;
                        idxTLeft = nto[n];
                    }
                    else {
                        if (ispri)
                            countTRight++;
                        idxTRight = nto[n];
                    }
                }
            let side = 0;
            if (noshift || countFLeft > 1 || countFRight > 1 || countTLeft > 1 || countTRight > 1) { }
            else if (countFLeft > 0 && countFRight > 0) { }
            else if (countTLeft > 0 && countTRight > 0) { }
            else if (countFLeft > 0 || countTLeft > 0)
                side = 1;
            else if (countFRight > 0 || countTRight > 0)
                side = -1;
            let sz = this.lineSizePix;
            let oxy = this.orthogonalDelta(x1, y1, x2, y2, this.bondSepPix);
            let ax1 = x1, ay1 = y1, ax2 = x2, ay2 = y2;
            let bx1 = 0, by1 = 0, bx2 = 0, by2 = 0;
            if (side == 0) {
                ax1 = x1 + 0.5 * oxy[0];
                ay1 = y1 + 0.5 * oxy[1];
                ax2 = x2 + 0.5 * oxy[0];
                ay2 = y2 + 0.5 * oxy[1];
                bx1 = x1 - 0.5 * oxy[0];
                by1 = y1 - 0.5 * oxy[1];
                bx2 = x2 - 0.5 * oxy[0];
                by2 = y2 - 0.5 * oxy[1];
            }
            else if (side > 0) {
                bx1 = x1 + oxy[0];
                by1 = y1 + oxy[1];
                bx2 = x2 + oxy[0];
                by2 = y2 + oxy[1];
                if (nfr.length > 1 && this.points[bfr - 1].text == null) {
                    bx1 += oxy[1];
                    by1 -= oxy[0];
                }
                if (nto.length > 1 && this.points[bto - 1].text == null) {
                    bx2 -= oxy[1];
                    by2 += oxy[0];
                }
            }
            else if (side < 0) {
                bx1 = x1 - oxy[0];
                by1 = y1 - oxy[1];
                bx2 = x2 - oxy[0];
                by2 = y2 - oxy[1];
                if (nfr.length > 1 && this.points[bfr - 1].text == null) {
                    bx1 += oxy[1];
                    by1 -= oxy[0];
                }
                if (nto.length > 1 && this.points[bto - 1].text == null) {
                    bx2 -= oxy[1];
                    by2 += oxy[0];
                }
            }
            if (side != 0) {
                if (this.mol.atomElement(bfr).length <= 2 && this.mol.atomAdjCount(bfr) == 1 && this.points[bfr - 1].text != null) {
                    this.bumpAtomPosition(bfr, 0.5 * oxy[0] * side, 0.5 * oxy[1] * side);
                }
                if (this.mol.atomElement(bto).length <= 2 && this.mol.atomAdjCount(bto) == 1 && this.points[bto - 1].text != null) {
                    this.bumpAtomPosition(bto, 0.5 * oxy[0] * side, 0.5 * oxy[1] * side);
                }
            }
            if (side == 0 && !noshift) {
                let xy = null;
                if (this.points[bfr - 1].text == null && !this.mol.bondInRing(idx)) {
                    xy = this.adjustBondPosition(idxFLeft, bfr, ax1, ay1, ax2, ay2);
                    if (xy != null) {
                        ax1 = xy[0];
                        ay1 = xy[1];
                    }
                    xy = this.adjustBondPosition(idxFRight, bfr, bx1, by1, bx2, by2);
                    if (xy != null) {
                        bx1 = xy[0];
                        by1 = xy[1];
                    }
                }
                if (this.points[bto - 1].text == null && !this.mol.bondInRing(idx)) {
                    xy = this.adjustBondPosition(idxTLeft, bto, ax2, ay2, ax1, ay1);
                    if (xy != null) {
                        ax2 = xy[0];
                        ay2 = xy[1];
                    }
                    xy = this.adjustBondPosition(idxTRight, bto, bx2, by2, bx1, by1);
                    if (xy != null) {
                        bx2 = xy[0];
                        by2 = xy[1];
                    }
                }
            }
            let lt = this.mol.bondType(idx) == WebMolKit.Molecule.BONDTYPE_UNKNOWN ? BLineType.Unknown : BLineType.Normal;
            let col = this.effects.colBond[idx];
            if (!col)
                col = this.policy.data.foreground;
            let b1 = {
                'bnum': idx,
                'bfr': bfr,
                'bto': bto,
                'type': lt,
                'line': new WebMolKit.Line(ax1, ay1, ax2, ay2),
                'size': sz,
                'head': 0,
                'col': col
            };
            let b2 = {
                'bnum': idx,
                'bfr': bfr,
                'bto': bto,
                'type': lt,
                'line': new WebMolKit.Line(bx1, by1, bx2, by2),
                'size': sz,
                'head': 0,
                'col': col
            };
            this.lines.push(b1);
            this.lines.push(b2);
            this.space.push(this.computeSpaceLine(b1));
            this.space.push(this.computeSpaceLine(b2));
        }
        placeHydrogen(idx, hcount, fussy) {
            let font = WebMolKit.FontData.main;
            const SSFRACT = 0.6;
            const GLYPH_H = font.getIndex('H');
            let a = this.points[idx];
            let emscale = a.fsz * font.INV_UNITS_PER_EM;
            let sub = hcount >= 2 ? hcount.toString() : '';
            let outlineX = font.getOutlineX(GLYPH_H), outlineY = font.getOutlineY(GLYPH_H);
            let firstEMW = font.HORIZ_ADV_X[GLYPH_H], emw = firstEMW;
            for (let n = 0; n < sub.length; n++) {
                let ch = sub.charAt(n), g = font.getIndex(ch);
                if (n == 0) {
                    emw += font.getKerning('H', ch);
                }
                else {
                    let chp = sub.charAt(n - 1);
                    emw += font.getKerning(chp, ch) * SSFRACT;
                }
                let extraX = font.getOutlineX(g), extraY = font.getOutlineY(g);
                WebMolKit.Vec.addTo(extraX, emw / SSFRACT);
                WebMolKit.Vec.addTo(extraY, (SSFRACT - 1) * font.ASCENT);
                WebMolKit.Vec.mulBy(extraX, SSFRACT);
                WebMolKit.Vec.mulBy(extraY, SSFRACT);
                outlineX = outlineX.concat(extraX);
                outlineY = outlineY.concat(extraY);
                emw += font.HORIZ_ADV_X[g] * SSFRACT;
            }
            if (sub.length > 0) {
                let qh = new WebMolKit.QuickHull(outlineX, outlineY, 0);
                outlineX = qh.hullX;
                outlineY = qh.hullY;
            }
            let emdx = -0.5 * firstEMW, emdy = 0.5 * (font.ASCENT + font.DESCENT);
            for (let n = 0; n < outlineX.length; n++) {
                outlineX[n] = a.oval.cx + (emdx + outlineX[n]) * emscale;
                outlineY[n] = a.oval.cy + (emdy - outlineY[n]) * emscale * this.ymul;
            }
            let dx = 0, dy = 0;
            let srcWAD = this.measure.measureText(a.text, a.fsz);
            if (fussy) {
                let RIGHTLEFT = [0, 1, 2, 3];
                let LEFTRIGHT = [1, 0, 2, 3];
                let UPDOWN = [2, 3, 0, 1];
                let DOWNUP = [3, 2, 0, 1];
                let quad = RIGHTLEFT, adj = this.mol.atomAdjList(a.anum);
                if (adj.length == 0) {
                    let LEFTIES = ["O", "S", "F", "Cl", "Br", "I"];
                    if (this.mol.atomCharge(a.anum) == 0 && this.mol.atomUnpaired(a.anum) == 0 &&
                        LEFTIES.indexOf(this.mol.atomElement(a.anum)) >= 0)
                        quad = LEFTRIGHT;
                    else
                        quad = RIGHTLEFT;
                }
                else {
                    let allLeft = true, allRight = true, allUp = true, allDown = true;
                    const ax = this.mol.atomX(a.anum), ay = this.mol.atomY(a.anum);
                    for (let n = 0; n < adj.length; n++) {
                        const bx = this.mol.atomX(adj[n]), by = this.mol.atomY(adj[n]);
                        if (bx > ax + 0.01)
                            allLeft = false;
                        if (bx < ax - 0.01)
                            allRight = false;
                        if (by < ay - 0.01)
                            allUp = false;
                        if (by > ay + 0.01)
                            allDown = false;
                    }
                    if (allLeft) { }
                    else if (allRight)
                        quad = LEFTRIGHT;
                    else if (allUp)
                        quad = DOWNUP;
                    else if (allDown)
                        quad = UPDOWN;
                }
                for (let n = 0; n < 4; n++) {
                    let tx = 0, ty = 0;
                    if (quad[n] == 0)
                        tx = 0.5 * srcWAD[0] + 0.5 * firstEMW * emscale;
                    else if (quad[n] == 1)
                        tx = -0.5 * srcWAD[0] - (emw - 0.5 * firstEMW) * emscale;
                    else if (quad[n] == 2)
                        ty = (1.1 * srcWAD[1] + 0.5 * srcWAD[2]) * -this.ymul;
                    else if (quad[n] == 3)
                        ty = (1.1 * srcWAD[1] + 0.5 * srcWAD[2]) * this.ymul;
                    WebMolKit.Vec.addTo(outlineX, tx);
                    WebMolKit.Vec.addTo(outlineY, ty);
                    let viol = this.countPolyViolations(outlineX, outlineY, true);
                    WebMolKit.Vec.addTo(outlineX, -tx);
                    WebMolKit.Vec.addTo(outlineY, -ty);
                    if (viol == 0) {
                        dx = tx;
                        dy = ty;
                        break;
                    }
                }
                if (dx == 0 && dy == 0)
                    return false;
            }
            else {
                const mx1 = WebMolKit.Vec.min(outlineY), mx2 = WebMolKit.Vec.max(outlineX), my1 = WebMolKit.Vec.min(outlineY), my2 = WebMolKit.Vec.max(outlineY), cx = 0.5 * (mx1 + mx2), cy = 0.5 * (my1 + my2);
                const mag = 1 + this.measure.scale() * this.policy.data.fontSize * ArrangeMolecule.FONT_CORRECT * 0.1 / Math.max(mx2 - cx, my2 - cy);
                const psz = outlineX.length;
                let magPX = outlineX.slice(0), magPY = outlineY.slice(0);
                for (let n = 0; n < psz; n++) {
                    magPX[n] = (magPX[n] - cx) * mag + cx;
                    magPY[n] = (magPY[n] - cy) * mag + cy;
                }
                let bestScore = 0, bestExt = 0, bestAng = 0;
                for (let ext = 0.5 * (a.oval.rw + a.oval.rh); ext < 1.5 * this.measure.scale(); ext += 0.1 * this.measure.scale()) {
                    let anyNoClash = false;
                    for (let ang = 0; ang < 2 * Math.PI; ang += 5 * WebMolKit.DEGRAD) {
                        let tx = ext * Math.cos(ang), ty = ext * Math.sin(ang);
                        WebMolKit.Vec.addTo(magPX, tx);
                        WebMolKit.Vec.addTo(magPY, ty);
                        let viol = this.countPolyViolations(magPX, magPY, false);
                        WebMolKit.Vec.addTo(magPX, -tx);
                        WebMolKit.Vec.addTo(magPY, -ty);
                        if (viol == 0)
                            anyNoClash = true;
                        let score = 10 * viol + this.spatialCongestion(a.oval.cx + tx, a.oval.cy + ty, 0.5) + 2 * ext;
                        if (bestScore == 0 || score < bestScore) {
                            bestScore = score;
                            bestExt = ext;
                            bestAng = ang;
                            dx = tx;
                            dy = ty;
                        }
                    }
                    if (anyNoClash)
                        break;
                }
            }
            let wad = this.measure.measureText("H", a.fsz);
            const PADDING = 1.1;
            let ah = {
                'anum': 0,
                'text': 'H',
                'fsz': a.fsz,
                'bold': a.bold,
                'col': a.col,
                'oval': new WebMolKit.Oval(a.oval.cx + dx, a.oval.cy + dy, 0.5 * wad[0] * PADDING, 0.5 * wad[1] * PADDING)
            };
            this.points.push(ah);
            if (sub.length > 0) {
                const subFsz = SSFRACT * a.fsz;
                wad = this.measure.measureText(sub, subFsz);
                let an = {
                    'anum': 0,
                    'text': sub,
                    'fsz': subFsz,
                    'bold': a.bold,
                    'col': a.col,
                    'oval': new WebMolKit.Oval(ah.oval.cx + 0.5 * firstEMW * a.fsz * font.INV_UNITS_PER_EM + 0.5 * wad[0], ah.oval.cy + (1 - SSFRACT) * a.fsz, 0.5 * wad[0] * PADDING, 0.5 * wad[1] * PADDING)
                };
                this.points.push(an);
            }
            WebMolKit.Vec.addTo(outlineX, dx);
            WebMolKit.Vec.addTo(outlineY, dy);
            let minX = WebMolKit.Vec.min(outlineX), minY = WebMolKit.Vec.min(outlineY);
            let spc = {
                'anum': 0,
                'bnum': 0,
                'box': new WebMolKit.Box(minX, minY, WebMolKit.Vec.max(outlineX) - minX, WebMolKit.Vec.max(outlineY) - minY),
                'px': outlineX,
                'py': outlineY
            };
            this.space.push(spc);
            return true;
        }
        computeSpacePoint(a) {
            let s = {
                'anum': a.anum,
                'bnum': 0,
                'box': new WebMolKit.Box(),
                'px': [],
                'py': []
            };
            const font = WebMolKit.FontData.main;
            let outlineX = [], outlineY = [];
            let emw = 0, nglyphs = 0;
            if (a.text != null) {
                for (let n = 0; n < a.text.length; n++) {
                    let ch1 = a.text.charAt(n);
                    let i = font.getIndex(ch1);
                    if (i >= 0) {
                        if (emw == 0) {
                            outlineX = font.getOutlineX(i);
                            outlineY = font.getOutlineY(i);
                            nglyphs = 1;
                        }
                        else {
                            let extraX = font.getOutlineX(i), extraY = font.getOutlineY(i);
                            if (extraX.length > 0) {
                                WebMolKit.Vec.addTo(extraX, emw);
                                outlineX = outlineX.concat(extraX);
                                outlineY = outlineY.concat(extraY);
                                nglyphs++;
                            }
                        }
                        emw += font.HORIZ_ADV_X[i];
                    }
                    else
                        emw += font.MISSING_HORZ;
                    if (n < a.text.length - 1) {
                        let ch2 = a.text.charAt(n + 1);
                        emw += font.getKerning(ch1, ch2);
                    }
                }
            }
            if (outlineX.length > 0) {
                if (nglyphs > 1) {
                    let qh = new WebMolKit.QuickHull(outlineX, outlineY, 0);
                    outlineX = qh.hullX;
                    outlineY = qh.hullY;
                }
                let emdx = -0.5 * emw, emdy = 0.5 * (font.ASCENT + font.DESCENT);
                let emscale = a.fsz * font.INV_UNITS_PER_EM;
                for (let n = 0; n < outlineX.length; n++) {
                    outlineX[n] = a.oval.cx + (emdx + outlineX[n]) * emscale;
                    outlineY[n] = a.oval.cy + (emdy - outlineY[n]) * emscale * this.ymul;
                }
                s.px = outlineX;
                s.py = outlineY;
                let minX = WebMolKit.Vec.min(outlineX), minY = WebMolKit.Vec.min(outlineY);
                s.box = new WebMolKit.Box(minX, minY, WebMolKit.Vec.max(outlineX) - minX, WebMolKit.Vec.max(outlineY) - minY);
            }
            else {
                s.box = WebMolKit.Box.fromOval(a.oval);
                if (s.box.w > 0 && s.box.h > 0) {
                    s.px = [s.box.minX(), s.box.maxX(), s.box.maxX(), s.box.minX()];
                    s.py = [s.box.minY(), s.box.minY(), s.box.maxY(), s.box.maxY()];
                }
            }
            return s;
        }
        computeSpaceLine(b) {
            let s = {
                'anum': 0,
                'bnum': b.bnum,
                'box': new WebMolKit.Box(),
                'px': [],
                'py': []
            };
            if (b.type == BLineType.Normal || b.type == BLineType.Dotted || b.type == BLineType.DotDir) {
                s.px = [b.line.x1, b.line.x2];
                s.py = [b.line.y1, b.line.y2];
            }
            else {
                const dx = b.line.x2 - b.line.x1, dy = b.line.y2 - b.line.y1;
                const norm = b.head / Math.sqrt(dx * dx + dy * dy);
                const ox = norm * dy, oy = -norm * dx;
                if (b.type == BLineType.Unknown) {
                    s.px = [b.line.x1 + ox, b.line.x1 - ox, b.line.x2 - ox, b.line.x2 + ox];
                    s.py = [b.line.y1 + oy, b.line.y1 - oy, b.line.y2 - oy, b.line.y2 + oy];
                }
                else {
                    s.px = [b.line.x1, b.line.x2 - ox, b.line.x2 + ox];
                    s.py = [b.line.y1, b.line.y2 - oy, b.line.y2 + oy];
                }
            }
            s.box.x = WebMolKit.Vec.min(s.px) - b.size;
            s.box.y = WebMolKit.Vec.min(s.py) - b.size;
            s.box.w = WebMolKit.Vec.max(s.px) - s.box.x + b.size;
            s.box.h = WebMolKit.Vec.max(s.py) - s.box.y + b.size;
            return s;
        }
        bumpAtomPosition(atom, dx, dy) {
            let p = this.points[atom - 1];
            p.oval.cx += dx;
            p.oval.cy += dy;
            for (let n = this.space.length - 1; n >= 0; n--) {
                let s = this.space[n - 1];
                if (s == null || s.anum != atom)
                    continue;
                s.box.x += dx;
                s.box.y += dy;
                WebMolKit.Vec.addTo(s.px, dx);
                WebMolKit.Vec.addTo(s.py, dy);
            }
        }
        countPolyViolations(px, py, shortCircuit) {
            let hits = 0;
            const psz = px.length, nspc = this.space.length;
            let pr = new WebMolKit.Box(), sr = new WebMolKit.Box();
            for (let i1 = 0; i1 < psz; i1++) {
                let i2 = i1 < psz - 1 ? i1 + 1 : 0;
                pr.x = Math.min(px[i1], px[i2]) - 1;
                pr.y = Math.min(py[i1], py[i2]) - 1;
                pr.w = Math.max(px[i1], px[i2]) - pr.x + 2;
                pr.h = Math.max(py[i1], py[i2]) - pr.y + 2;
                for (let j = 0; j < nspc; j++) {
                    let spc = this.space[j];
                    if (spc.px == null)
                        continue;
                    sr.x = spc.box.x - 1;
                    sr.y = spc.box.y - 1;
                    sr.w = spc.box.w + 1;
                    sr.h = spc.box.h + 1;
                    if (!pr.intersects(sr))
                        continue;
                    let ssz = spc.px.length;
                    for (let j1 = 0; j1 < ssz; j1++) {
                        let j2 = j1 < ssz - 1 ? j1 + 1 : 0;
                        sr.x = Math.min(spc.px[j1], spc.px[j2]) - 1;
                        sr.y = Math.min(spc.py[j1], spc.py[j2]) - 1;
                        sr.w = Math.max(spc.px[j1], spc.px[j2]) - sr.x + 2;
                        sr.h = Math.max(spc.py[j1], spc.py[j2]) - sr.y + 2;
                        if (!pr.intersects(sr))
                            continue;
                        if (WebMolKit.GeomUtil.doLineSegsIntersect(px[i1], py[i1], px[i2], py[i2], spc.px[j1], spc.py[j1], spc.px[j2], spc.py[j2])) {
                            if (shortCircuit)
                                return 1;
                            hits++;
                            break;
                        }
                        if (ssz == 1)
                            break;
                    }
                }
            }
            pr.x = WebMolKit.Vec.min(px);
            pr.y = WebMolKit.Vec.min(py);
            pr.w = WebMolKit.Vec.max(px) - pr.x;
            pr.h = WebMolKit.Vec.max(py) - pr.y;
            for (let n = nspc - 1; n >= 0; n--) {
                let spc = this.space[n];
                sr.x = spc.box.x;
                sr.y = spc.box.y;
                sr.w = spc.box.w;
                sr.h = spc.box.h;
                if (!pr.intersects(sr))
                    continue;
                for (let i = spc.px.length - 1; i >= 0; i--)
                    if (WebMolKit.GeomUtil.pointInPolygon(spc.px[i], spc.py[i], px, py)) {
                        if (shortCircuit)
                            return 1;
                        hits++;
                        break;
                    }
                for (let i = 0; i < psz; i++)
                    if (WebMolKit.GeomUtil.pointInPolygon(px[i], py[i], spc.px, spc.py)) {
                        if (shortCircuit)
                            return 1;
                        hits++;
                        break;
                    }
            }
            return hits;
        }
        adjustBondPosition(bf, bt, x1, y1, x2, y2) {
            if (bf == 0 || bt == 0)
                return null;
            for (let n = 0; n < this.lines.length; n++) {
                let b = this.lines[n];
                if (this.mol.bondOrder(b.bnum) != 1 || this.mol.bondType(b.bnum) != WebMolKit.Molecule.BONDTYPE_NORMAL)
                    continue;
                let alt = false;
                if (this.mol.bondFrom(b.bnum) == bf && this.mol.bondTo(b.bnum) == bt) { }
                else if (this.mol.bondFrom(b.bnum) == bt && this.mol.bondTo(b.bnum) == bf)
                    alt = true;
                else
                    continue;
                let th = WebMolKit.angleDiff(Math.atan2(b.line.y2 - b.line.y1, b.line.x2 - b.line.x1), Math.atan2(y2 - y1, x2 - x1)) * WebMolKit.RADDEG;
                if ((th > -5 && th < 5) || th > 175 || th < -175)
                    continue;
                let xy = WebMolKit.GeomUtil.lineIntersect(b.line.x1, b.line.y1, b.line.x2, b.line.y2, x1, y1, x2, y2);
                if (this.mol.atomRingBlock(bt) == 0) {
                    if (alt) {
                        b.line.x1 = xy[0];
                        b.line.y1 = xy[1];
                    }
                    else {
                        b.line.x2 = xy[0];
                        b.line.y2 = xy[1];
                    }
                }
                return xy;
            }
            return null;
        }
        priorityDoubleSubstit(idx) {
            let bf = this.mol.bondFrom(idx), bt = this.mol.bondTo(idx);
            let nf = this.mol.atomAdjList(bf), nt = this.mol.atomAdjList(bt);
            let a1 = this.points[bf - 1], a2 = this.points[bt - 1];
            let x1 = a1.oval.cx, y1 = a1.oval.cy, x2 = a2.oval.cx, y2 = a2.oval.cy;
            let dx = x2 - x1, dy = y2 - y1, btheta = Math.atan2(dy, dx);
            let idxFLeft = 0, idxFRight = 0, idxTLeft = 0, idxTRight = 0;
            for (let n = 0; n < nf.length; n++)
                if (nf[n] != bt) {
                    let theta = WebMolKit.angleDiff(Math.atan2(this.points[nf[n] - 1].oval.cy - y1, this.points[nf[n] - 1].oval.cx - x1), btheta);
                    if (theta > 0) {
                        if (idxFLeft != 0)
                            return null;
                        idxFLeft = nf[n];
                    }
                    else {
                        if (idxFRight != 0)
                            return null;
                        idxFRight = nf[n];
                    }
                }
            for (let n = 0; n < nt.length; n++)
                if (nt[n] != bf) {
                    let theta = WebMolKit.angleDiff(Math.atan2(this.points[nt[n] - 1].oval.cy - y2, this.points[nt[n] - 1].oval.cx - x2), btheta);
                    if (theta > 0) {
                        if (idxTLeft != 0)
                            return null;
                        idxTLeft = nt[n];
                    }
                    else {
                        if (idxTRight != 0)
                            return null;
                        idxTRight = nt[n];
                    }
                }
            let sumFrom = (idxFLeft > 0 ? 1 : 0) + (idxFRight > 0 ? 1 : 0), sumTo = (idxTLeft > 0 ? 1 : 0) + (idxTRight > 0 ? 1 : 0);
            if (sumFrom == 1 && sumTo == 0)
                return [idxFLeft > 0 ? idxFLeft : idxFRight];
            if (sumFrom == 0 && sumTo == 1)
                return [idxTLeft > 0 ? idxTLeft : idxTRight];
            if (sumFrom == 1 && sumTo == 1) {
                if (idxFLeft > 0 && idxTLeft > 0)
                    return [idxFLeft, idxTLeft];
                if (idxFRight > 0 && idxTRight > 0)
                    return [idxFRight, idxTRight];
                let oxy = this.orthogonalDelta(x1, y1, x2, y2, this.bondSepPix);
                let congestLeft = this.spatialCongestion(0.5 * (x1 + x2) + oxy[0], 0.5 * (y1 + y2) + oxy[1]);
                let congestRight = this.spatialCongestion(0.5 * (x1 + x2) - oxy[0], 0.5 * (y1 + y2) - oxy[1]);
                if (congestLeft < congestRight)
                    return [idxFLeft > 0 ? idxFLeft : idxTLeft];
                else
                    return [idxFRight > 0 ? idxFRight : idxTRight];
            }
            if (sumFrom == 2 && sumTo == 1) {
                if (idxTLeft == 0)
                    return [idxFRight, idxTRight];
                else
                    return [idxFLeft, idxTLeft];
            }
            if (sumFrom == 1 && sumTo == 2) {
                if (idxFLeft == 0)
                    return [idxFRight, idxTRight];
                else
                    return [idxFLeft, idxTLeft];
            }
            return null;
        }
        spatialCongestion(x, y, thresh) {
            if (thresh == null)
                thresh = 0.001;
            let congest = 0;
            for (let n = 0; n < this.points.length; n++) {
                let a = this.points[n];
                if (a == null)
                    continue;
                let dx = a.oval.cx - x, dy = a.oval.cy - y;
                congest += 1 / (dx * dx + dy * dy + thresh);
            }
            return congest;
        }
        boxOverlaps(x, y, w, h, pointmask, linemask) {
            let vx1 = x, vy1 = y, vx2 = x + w, vy2 = y + h;
            for (let n = 0; n < this.points.length; n++) {
                if (pointmask != null && !pointmask[n])
                    continue;
                let a = this.points[n];
                let wx1 = a.oval.cx - a.oval.rw, wy1 = a.oval.cy - a.oval.rh, wx2 = a.oval.cx + a.oval.rw, wy2 = a.oval.cy + a.oval.rh;
                if (vx2 < wx1 || vx1 > wx2 || vy2 < wy1 || vy1 > wy2)
                    continue;
                return true;
            }
            for (let n = 0; n < this.lines.length; n++) {
                if (linemask != null && !linemask[n])
                    continue;
                let b = this.lines[n];
                let wx1 = b.line.x1, wy1 = b.line.y1, wx2 = b.line.x2, wy2 = b.line.y2;
                if (vx2 < Math.min(wx1, wx2) || vx1 > Math.max(wx1, wx2) || vy2 < Math.min(wy1, wy2) || vy1 > Math.max(wy1, wy2))
                    continue;
                if (wx1 >= vx1 && wx1 <= vx2 && wy1 >= vy1 && wy1 <= vy2)
                    return true;
                if (wx2 >= vx1 && wx2 <= vx2 && wy2 >= vy1 && wy2 <= vy2)
                    return true;
                if (WebMolKit.GeomUtil.doLineSegsIntersect(wx1, wy1, wx2, wy2, vx1, vy1, vx2, vy1))
                    return true;
                if (WebMolKit.GeomUtil.doLineSegsIntersect(wx1, wy1, wx2, wy2, vx1, vy2, vx2, vy2))
                    return true;
                if (WebMolKit.GeomUtil.doLineSegsIntersect(wx1, wy1, wx2, wy2, vx1, vy1, vx1, vy2))
                    return true;
                if (WebMolKit.GeomUtil.doLineSegsIntersect(wx1, wy1, wx2, wy2, vx2, vy1, vx2, vy2))
                    return true;
            }
            return false;
        }
        resolveLineCrossings(bondHigher, bondLower) {
            while (true) {
                let anything = false;
                for (let i1 = 0; i1 < this.lines.length; i1++) {
                    let b1 = this.lines[i1];
                    if (b1.bnum != bondHigher)
                        continue;
                    if (b1.type != BLineType.Normal && b1.type != BLineType.Dotted && b1.type != BLineType.DotDir)
                        continue;
                    for (let i2 = 0; i2 < this.lines.length; i2++) {
                        let b2 = this.lines[i2];
                        if (b2.bnum != bondLower)
                            continue;
                        if (b2.type == BLineType.DotDir)
                            b2.type = BLineType.Dotted;
                        if (b2.type != BLineType.Normal && b2.type != BLineType.Dotted)
                            continue;
                        if (b1.bfr == b2.bfr || b1.bfr == b2.bto || b1.bto == b2.bfr || b1.bto == b2.bto)
                            continue;
                        if (!WebMolKit.GeomUtil.doLineSegsIntersect(b1.line.x1, b1.line.y1, b1.line.x2, b1.line.y2, b2.line.x1, b2.line.y1, b2.line.x2, b2.line.y2))
                            continue;
                        let xy = WebMolKit.GeomUtil.lineIntersect(b1.line.x1, b1.line.y1, b1.line.x2, b1.line.y2, b2.line.x1, b2.line.y1, b2.line.x2, b2.line.y2);
                        let dx = b2.line.x2 - b2.line.x1, dy = b2.line.y2 - b2.line.y1;
                        let ext = Math.abs(dx) > Math.abs(dy) ? (xy[0] - b2.line.x1) / dx : (xy[1] - b2.line.y1) / dy;
                        let dist = WebMolKit.norm_xy(dx, dy);
                        let delta = b2.size / dist * (b2.type == BLineType.Normal ? 2 : 4);
                        if (ext > delta && ext < 1 - delta) {
                            let b3 = {
                                'bnum': b2.bnum,
                                'bfr': b2.bfr,
                                'bto': b2.bto,
                                'type': b2.type,
                                'line': b2.line.clone(),
                                'size': b2.size,
                                'head': b2.head,
                                'col': b2.col
                            };
                            this.lines.push(b3);
                            b2.line.x2 = b2.line.x1 + dx * (ext - delta);
                            b2.line.y2 = b2.line.y1 + dy * (ext - delta);
                            b3.line.x1 = b3.line.x1 + dx * (ext + delta);
                            b3.line.y1 = b3.line.y1 + dy * (ext + delta);
                            anything = true;
                        }
                        else if (ext > delta) {
                            b2.line.x2 = b2.line.x1 + dx * (ext - delta);
                            b2.line.y2 = b2.line.y1 + dy * (ext - delta);
                            anything = true;
                        }
                        else if (ext < 1 - delta) {
                            b2.line.x1 = b2.line.x1 + dx * (ext + delta);
                            b2.line.y1 = b2.line.y1 + dy * (ext + delta);
                            anything = true;
                        }
                    }
                }
                if (!anything)
                    break;
            }
        }
        createCircularRing(atoms) {
            let cx = 0, cy = 0;
            for (let a of atoms) {
                let pt = this.points[a - 1];
                cx += pt.oval.cx;
                cy += pt.oval.cy;
            }
            cx /= atoms.length;
            cy /= atoms.length;
            let bx = [], by = [];
            let isRegular = true;
            let regDist = Number.NaN;
            for (let a of atoms) {
                let pt = this.points[a - 1];
                let x0 = pt.oval.cx - cx, y0 = pt.oval.cy - cy, x1 = x0 - pt.oval.rw, x2 = x0 + pt.oval.rw, y1 = y0 - pt.oval.rh, y2 = y0 + pt.oval.rh;
                bx.push(x1);
                by.push(y0);
                bx.push(x1);
                by.push(y1);
                bx.push(x1);
                by.push(y2);
                bx.push(x0);
                by.push(y1);
                bx.push(x0);
                by.push(y2);
                bx.push(x2);
                by.push(y0);
                bx.push(x2);
                by.push(y1);
                bx.push(x2);
                by.push(y2);
                let dist = WebMolKit.norm_xy(x0, y0), theta = Math.atan2(y0, x0);
                const FRACT = 0.7;
                bx.push(FRACT * dist * Math.cos(theta));
                by.push(FRACT * dist * Math.sin(theta));
                for (let b of this.mol.atomAdjList(a))
                    if (atoms.indexOf(b) >= 0) {
                        let pb = this.points[b - 1];
                        let mx = 0.5 * (pt.oval.cx + pb.oval.cx) - cx, my = 0.5 * (pt.oval.cy + pb.oval.cy) - cy;
                        let mdist = WebMolKit.norm_xy(mx, my), mtheta = Math.atan2(my, mx);
                        bx.push(FRACT * mdist * Math.cos(mtheta));
                        by.push(FRACT * mdist * Math.sin(mtheta));
                    }
                if (!isRegular) { }
                else if (Number.isFinite(regDist)) {
                    if (Math.abs(regDist - dist) > 1)
                        isRegular = false;
                }
                else
                    regDist = dist;
            }
            let r = { 'atoms': atoms, 'cx': cx, 'cy': cy, 'rw': 0, 'rh': 0, 'size': 0 };
            if (isRegular) {
                r.rw = r.rh = WebMolKit.GeomUtil.fitCircle(bx, by);
            }
            else {
                let lowX = WebMolKit.Vec.min(bx) - 10 * WebMolKit.Vec.range(bx), highX = WebMolKit.Vec.max(bx) + 10 * WebMolKit.Vec.range(bx);
                let lowY = WebMolKit.Vec.min(by) - 10 * WebMolKit.Vec.range(by), highY = WebMolKit.Vec.max(by) + 10 * WebMolKit.Vec.range(by);
                let minX = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;
                for (let n = 0; n < atoms.length; n++) {
                    let nn = n < atoms.length - 1 ? n + 1 : 0;
                    let p1 = this.points[atoms[n] - 1], p2 = this.points[atoms[nn] - 1];
                    let x1 = p1.oval.cx - cx - 0.1 * (p2.oval.cx - p1.oval.cx), y1 = p1.oval.cy - cy - 0.1 * (p2.oval.cy - p1.oval.cy);
                    let x2 = p2.oval.cx - cx + 0.1 * (p2.oval.cx - p1.oval.cx), y2 = p2.oval.cy - cy + 0.1 * (p2.oval.cy - p1.oval.cy);
                    if (WebMolKit.GeomUtil.doLineSegsIntersect(x1, y1, x2, y2, lowX, 0, highX, 0)) {
                        let xy = WebMolKit.GeomUtil.lineIntersect(x1, y1, x2, y2, lowX, 0, highX, 0);
                        minX = Math.min(minX, xy[0]);
                        maxX = Math.max(maxX, xy[0]);
                    }
                    if (WebMolKit.GeomUtil.doLineSegsIntersect(x1, y1, x2, y2, 0, lowY, 0, highY)) {
                        let xy = WebMolKit.GeomUtil.lineIntersect(x1, y1, x2, y2, 0, lowY, 0, highY);
                        minY = Math.min(minY, xy[1]);
                        maxY = Math.max(maxY, xy[1]);
                    }
                }
                let rwh = WebMolKit.GeomUtil.fitEllipse(bx, by, minX, minY, maxX, maxY);
                r.rw = rwh[0];
                r.rh = rwh[1];
            }
            r.size = this.lineSizePix;
            this.rings.push(r);
        }
        createCurvedPath(atoms, fractional, extAtom) {
            const sz = atoms.length, szn = sz - 1;
            let x = [], y = [], symbol = [];
            for (let n = 0; n < sz; n++) {
                let pt = this.points[atoms[n] - 1];
                x.push(pt.oval.cx);
                y.push(pt.oval.cy);
                symbol.push(pt.text != null);
            }
            let ox = [], oy = [];
            const EXT = WebMolKit.Molecule.IDEALBOND * 0.25 * this.scale;
            for (let n = 0; n < sz - 1; n++) {
                let dx = x[n + 1] - x[n], dy = y[n + 1] - y[n], invD = EXT * WebMolKit.invZ(WebMolKit.norm_xy(dx, dy));
                ox.push(dy * invD);
                oy.push(-dx * invD);
            }
            const FAR = 1.2, CLOSE = 0.7;
            let sx1 = WebMolKit.Vec.numberArray(0, sz), sy1 = WebMolKit.Vec.numberArray(0, sz), sx2 = WebMolKit.Vec.numberArray(0, sz), sy2 = WebMolKit.Vec.numberArray(0, sz);
            const capA = symbol[0] ? FAR : CLOSE;
            if (!fractional) {
                sx1[0] = x[0] + ox[0] * capA;
                sy1[0] = y[0] + oy[0] * capA;
                sx2[0] = x[0] - ox[0] * capA;
                sy2[0] = y[0] - oy[0] * capA;
            }
            else {
                const dx = -oy[0], dy = ox[0];
                sx1[0] = x[0] + dx * capA;
                sy1[0] = y[0] + dy * capA;
                sx2[0] = x[0] + dx * capA;
                sy2[0] = y[0] + dy * capA;
            }
            let ncross1 = 0, ncross2 = 0;
            for (let n = 1; n < sz - 1; n++) {
                const fr1 = symbol[n] ? FAR : CLOSE, fr2 = fr1;
                sx1[n] = x[n] + fr1 * (ox[n - 1] + ox[n]);
                sy1[n] = y[n] + fr1 * (oy[n - 1] + oy[n]);
                sx2[n] = x[n] - fr2 * (ox[n - 1] + ox[n]);
                sy2[n] = y[n] - fr2 * (oy[n - 1] + oy[n]);
                for (let a of this.mol.atomAdjList(atoms[n]))
                    if (atoms.indexOf(a) < 0 && a != extAtom) {
                        let pt = this.points[a - 1];
                        let dx = pt.oval.cx - x[n], dy = pt.oval.cy - y[n];
                        let dot1 = dx * (sx1[n] - x[n]) + dy * (sy1[n] - x[n]);
                        let dot2 = dy * (sx2[n] - x[n]) + dy * (sy2[n] - x[n]);
                        if (dot1 > dot2)
                            ncross1++;
                        else
                            ncross2++;
                    }
            }
            let nn = sz - 1;
            let capB = symbol[nn] ? FAR : CLOSE;
            if (!fractional) {
                sx1[nn] = x[nn] + ox[nn - 1] * capB;
                sy1[nn] = y[nn] + oy[nn - 1] * capB;
                sx2[nn] = x[nn] - ox[nn - 1] * capB;
                sy2[nn] = y[nn] - oy[nn - 1] * capB;
            }
            else {
                let dx = -oy[nn - 1], dy = ox[nn - 1];
                sx1[nn] = x[nn] - dx * capB;
                sy1[nn] = y[nn] - dy * capB;
                sx2[nn] = x[nn] - dx * capB;
                sy2[nn] = y[nn] - dy * capB;
            }
            let score1 = 0, score2 = 0;
            for (let n = 0; n < sz - 1; n++) {
                score1 += WebMolKit.norm_xy(sx1[n + 1] - sx1[n], sy1[n + 1] - sy1[n]);
                score2 += WebMolKit.norm_xy(sx2[n + 1] - sx2[n], sy2[n + 1] - sy2[n]);
            }
            score1 *= ncross1 + 1;
            score2 *= ncross2 + 1;
            let sx = score1 < score2 ? sx1 : sx2;
            let sy = score1 < score2 ? sy1 : sy2;
            let p = { 'atoms': atoms, 'px': null, 'py': null, 'ctrl': null, 'size': this.lineSizePix };
            this.splineInterpolate(p, sx, sy);
            this.paths.push(p);
        }
        createBondCentroid(from, to) {
            let pt = this.points[from - 1];
            let x1 = pt.oval.cx, y1 = pt.oval.cy, x2 = 0, y2 = 0;
            for (let a of to) {
                pt = this.points[a - 1];
                x2 += pt.oval.cx;
                y2 += pt.oval.cy;
            }
            x2 /= to.length;
            y2 /= to.length;
            if (to.length <= 2) {
                x2 -= 0.1 * (x2 - x1);
                y2 -= 0.1 * (y2 - y1);
            }
            const minDist = this.MINBOND_LINE * this.measure.scale();
            let xy1 = this.backOffAtom(from, x1, y1, x2, y2, minDist);
            this.ensureMinimumBondLength(xy1, [x2, y2], x1, y1, x2, y2, minDist);
            let b = {
                'bnum': 0, 'bfr': from, 'bto': 0,
                'type': BLineType.Normal, 'line': new WebMolKit.Line(xy1[0], xy1[1], x2, y2),
                'size': this.lineSizePix, 'head': 0, 'col': this.policy.data.foreground
            };
            this.lines.push(b);
            this.space.push(this.computeSpaceLine(b));
        }
        splineInterpolate(path, x, y) {
            const sz = x.length;
            const scale = 0.25;
            for (let n = 0; n < sz; n++) {
                if (n == 0) {
                    let dx = x[n + 1] - x[n], dy = y[n + 1] - y[n];
                    let qx = x[n] + scale * dx, qy = y[n] + scale * dy;
                    path.px = WebMolKit.Vec.append(path.px, x[n]);
                    path.py = WebMolKit.Vec.append(path.py, y[n]);
                    path.ctrl = WebMolKit.Vec.append(path.ctrl, false);
                    path.px = WebMolKit.Vec.append(path.px, qx);
                    path.py = WebMolKit.Vec.append(path.py, qy);
                    path.ctrl = WebMolKit.Vec.append(path.ctrl, true);
                }
                else if (n == sz - 1) {
                    let dx = x[n] - x[n - 1], dy = y[n] - y[n - 1];
                    let qx = x[n] - scale * dx, qy = y[n] - scale * dy;
                    path.px = WebMolKit.Vec.append(path.px, qx);
                    path.py = WebMolKit.Vec.append(path.py, qy);
                    path.ctrl = WebMolKit.Vec.append(path.ctrl, true);
                    path.px = WebMolKit.Vec.append(path.px, x[n]);
                    path.py = WebMolKit.Vec.append(path.py, y[n]);
                    path.ctrl = WebMolKit.Vec.append(path.ctrl, false);
                }
                else {
                    let dx = x[n + 1] - x[n - 1], dy = y[n + 1] - y[n - 1];
                    let invD = WebMolKit.invZ(WebMolKit.norm_xy(dx, dy));
                    dx *= invD;
                    dy *= invD;
                    let d1 = scale * WebMolKit.norm_xy(x[n] - x[n - 1], y[n] - y[n - 1]), d2 = scale * WebMolKit.norm_xy(x[n + 1] - x[n], y[n + 1] - y[n]);
                    let qx1 = x[n] - dx * d1, qy1 = y[n] - dy * d1;
                    let qx2 = x[n] + dx * d2, qy2 = y[n] + dy * d2;
                    path.px = WebMolKit.Vec.append(path.px, qx1);
                    path.py = WebMolKit.Vec.append(path.py, qy1);
                    path.ctrl = WebMolKit.Vec.append(path.ctrl, true);
                    path.px = WebMolKit.Vec.append(path.px, x[n]);
                    path.py = WebMolKit.Vec.append(path.py, y[n]);
                    path.ctrl = WebMolKit.Vec.append(path.ctrl, false);
                    path.px = WebMolKit.Vec.append(path.px, qx2);
                    path.py = WebMolKit.Vec.append(path.py, qy2);
                    path.ctrl = WebMolKit.Vec.append(path.ctrl, true);
                }
            }
        }
        delocalisedAnnotation(atoms, charge, unpaired) {
            const mol = this.mol;
            let str = '';
            if (charge == -1)
                str = '-';
            else if (charge == 1)
                str = '+';
            else if (charge < -1)
                str = Math.abs(charge) + '-';
            else if (charge > 1)
                str = charge + '+';
            if (unpaired > 0)
                for (let n = 0; n < unpaired; n++)
                    str += '.';
            if (str.length == 0)
                return;
            const sz = atoms.length;
            let bestX = 0, bestY = 0;
            for (let a of atoms) {
                bestX += mol.atomX(a);
                bestY += mol.atomY(a);
            }
            bestX /= sz;
            bestY /= sz;
            let bestScore = WebMolKit.CoordUtil.congestionPoint(mol, bestX, bestY);
            for (let n = 1; n < sz - 1; n++) {
                let x = 0.5 * (mol.atomX(atoms[n - 1]) + mol.atomX(atoms[n + 1])), y = 0.5 * (mol.atomY(atoms[n - 1]) + mol.atomY(atoms[n + 1]));
                let score = WebMolKit.CoordUtil.congestionPoint(mol, x, y);
                if (score < bestScore) {
                    bestScore = score;
                    bestX = x;
                    bestY = y;
                }
            }
            let fsz = 0.8 * this.fontSizePix;
            let wad = this.measure.measureText(str, fsz);
            let rw = 0.55 * wad[0], rh = 0.55 * wad[1];
            let a = {
                'anum': 0,
                'text': str,
                'fsz': fsz,
                'bold': false,
                'col': this.policy.data.foreground,
                'oval': new WebMolKit.Oval(this.measure.angToX(bestX), this.measure.angToY(bestY), rw, rh)
            };
            this.points.push(a);
            let spc = {
                'anum': 0,
                'bnum': 0,
                'box': new WebMolKit.Box(a.oval.cx - rw, a.oval.cy - rh, 2 * rw, 2 * rh),
                'px': [a.oval.cx - rw, a.oval.cx + rw, a.oval.cx + rw, a.oval.cx - rw],
                'py': [a.oval.cy - rh, a.oval.cy - rh, a.oval.cy + rh, a.oval.cy + rh]
            };
            this.space.push(spc);
        }
    }
    ArrangeMolecule.FONT_CORRECT = 1.5;
    WebMolKit.ArrangeMolecule = ArrangeMolecule;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class DrawMolecule {
        constructor(layout, vg) {
            this.layout = layout;
            this.vg = vg;
            this.mol = layout.getMolecule();
            this.policy = layout.getPolicy();
            this.effects = layout.getEffects();
            this.scale = layout.getScale();
            this.invScale = 1.0 / this.scale;
        }
        getMolecule() { return this.mol; }
        getMetaVector() { return this.vg; }
        getLayout() { return this.layout; }
        getPolicy() { return this.policy; }
        getEffects() { return this.effects; }
        draw() {
            let DRAW_SPACE = false;
            if (DRAW_SPACE)
                for (let n = 0; n < this.layout.numSpace(); n++) {
                    let spc = this.layout.getSpace(n);
                    this.vg.drawRect(spc.box.x, spc.box.y, spc.box.w, spc.box.h, WebMolKit.MetaVector.NOCOLOUR, 0, 0xE0E0E0);
                    if (spc.px != null && spc.py != null && spc.px.length > 2)
                        this.vg.drawPoly(spc.px, spc.py, 0x000000, 1, 0x808080FF, true);
                }
            this.drawUnderEffects();
            let layout = this.layout, effects = this.effects, policy = this.policy, vg = this.vg;
            for (let n = 0; n < layout.numLines(); n++) {
                let b = layout.getLine(n);
                if (effects.hideBonds.has(b.bnum))
                    continue;
                if (b.type == WebMolKit.BLineType.Normal) {
                    vg.drawLine(b.line.x1, b.line.y1, b.line.x2, b.line.y2, b.col, b.size);
                }
                else if (b.type == WebMolKit.BLineType.Inclined)
                    this.drawBondInclined(b);
                else if (b.type == WebMolKit.BLineType.Declined)
                    this.drawBondDeclined(b);
                else if (b.type == WebMolKit.BLineType.Unknown)
                    this.drawBondUnknown(b);
                else if (b.type == WebMolKit.BLineType.Dotted || b.type == WebMolKit.BLineType.DotDir)
                    this.drawBondDotted(b);
                else if (b.type == WebMolKit.BLineType.IncDouble || b.type == WebMolKit.BLineType.IncTriple || b.type == WebMolKit.BLineType.IncQuadruple)
                    this.drawBondIncMulti(b);
            }
            let fg = policy.data.foreground;
            for (let r of layout.getRings())
                vg.drawOval(r.cx, r.cy, r.rw, r.rh, fg, r.size, WebMolKit.MetaVector.NOCOLOUR);
            for (let p of layout.getPaths())
                vg.drawPath(p.px, p.py, p.ctrl, false, fg, p.size, WebMolKit.MetaVector.NOCOLOUR, false);
            for (let n = 0; n < layout.numPoints(); n++) {
                let p = layout.getPoint(n);
                if (effects.hideBonds.has(p.anum))
                    continue;
                let txt = p.text;
                if (txt == null)
                    continue;
                let fsz = p.fsz;
                let cx = p.oval.cx, cy = p.oval.cy, rw = p.oval.rw;
                let col = p.col;
                while (txt.endsWith('.')) {
                    let dw = rw / txt.length;
                    let r = fsz * 0.15;
                    vg.drawOval(cx + rw - dw, cy, r, r, WebMolKit.MetaVector.NOCOLOUR, 0, col);
                    cx -= dw;
                    rw -= dw;
                    txt = txt.substring(0, txt.length - 1);
                }
                while (txt.startsWith('+')) {
                    let dw = rw / txt.length;
                    let x = cx - rw + dw, y = cy, r = fsz * 0.18, lsz = fsz * 0.1;
                    vg.drawLine(x - r, y, x + r, y, col, lsz);
                    vg.drawLine(x, y - r, x, y + r, col, lsz);
                    cx += dw;
                    rw -= dw;
                    txt = txt.substring(1, txt.length);
                }
                while (txt.startsWith('-')) {
                    let dw = rw / txt.length;
                    let x = cx - rw + dw, y = cy, r = fsz * 0.18, lsz = fsz * 0.1;
                    vg.drawLine(x - r, y, x + r, y, col, lsz);
                    cx += dw;
                    rw -= dw;
                    txt = txt.substring(1, txt.length);
                }
                if (txt.length > 0) {
                    vg.drawText(cx, cy, txt, fsz, col, WebMolKit.TextAlign.Centre | WebMolKit.TextAlign.Middle);
                }
            }
            this.drawOverEffects();
        }
        drawUnderEffects() {
            let mol = this.mol, policy = this.policy, effects = this.effects, layout = this.layout, scale = this.scale, vg = this.vg;
            for (let n = 0, num = Math.min(effects.atomFrameDotSz.length, mol.numAtoms); n < num; n++) {
                if (effects.hideAtoms.has(n + 1))
                    continue;
                let dw = effects.atomFrameDotSz[n] * scale, col = effects.atomFrameCol[n];
                let a = layout.getPoint(n);
                let rw = a.oval.rw + 0.1 * scale, rh = a.oval.rh + 0.1 * scale;
                let wdots = Math.ceil(2 * rw / (3 * dw));
                let hdots = Math.ceil(2 * rh / (3 * dw));
                let wspc = 2 * rw / wdots, hspc = 2 * rh / hdots;
                for (let i = 0; i <= wdots; i++) {
                    let x = a.oval.cx - rw + i * wspc;
                    vg.drawOval(x, a.oval.cy - rh, dw, dw, WebMolKit.MetaVector.NOCOLOUR, 0, col);
                    vg.drawOval(x, a.oval.cy + rh, dw, dw, WebMolKit.MetaVector.NOCOLOUR, 0, col);
                }
                for (let i = 1; i < hdots; i++) {
                    let y = a.oval.cy - rh + i * hspc;
                    vg.drawOval(a.oval.cx - rw, y, dw, dw, WebMolKit.MetaVector.NOCOLOUR, 0, col);
                    vg.drawOval(a.oval.cx + rw, y, dw, dw, WebMolKit.MetaVector.NOCOLOUR, 0, col);
                }
            }
            for (let key in effects.dottedRectOutline) {
                let atom = parseInt(key), col = effects.dottedRectOutline[key];
                let a = layout.getPoint(atom - 1);
                let rw = Math.max(a.oval.rw, 0.2 * scale), rh = Math.max(a.oval.rh, 0.2 * scale);
                let sz = 0.05 * scale;
                let xdots = Math.max(1, Math.round(rw / (2 * sz)));
                let ydots = Math.max(1, Math.round(rh / (2 * sz)));
                let invX = (2 * rw) / xdots, invY = (2 * rh) / ydots;
                for (let n = 0; n <= xdots; n++) {
                    let x = a.oval.cx - rw + n * invX;
                    vg.drawOval(x, a.oval.cy - rh, sz, sz, WebMolKit.MetaVector.NOCOLOUR, 0, col);
                    vg.drawOval(x, a.oval.cy + rh, sz, sz, WebMolKit.MetaVector.NOCOLOUR, 0, col);
                }
                for (let n = 1; n < ydots; n++) {
                    let y = a.oval.cy - rh + n * invY;
                    vg.drawOval(a.oval.cx - rw, y, sz, sz, WebMolKit.MetaVector.NOCOLOUR, 0, col);
                    vg.drawOval(a.oval.cx + rw, y, sz, sz, WebMolKit.MetaVector.NOCOLOUR, 0, col);
                }
            }
            for (let key in effects.dottedBondCross) {
                let bond = parseInt(key), col = effects.dottedBondCross[key];
                var x1 = 0, y1 = 0, x2 = 0, y2 = 0, bcount = 0;
                for (let n = 0; n < layout.numLines(); n++) {
                    let b = layout.getLine(n);
                    if (b.bnum == bond) {
                        x1 += b.line.x1;
                        y1 += b.line.y1;
                        x2 += b.line.x2;
                        y2 += b.line.y2;
                        bcount += 1;
                    }
                }
                if (bcount > 1) {
                    let inv = 1 / bcount;
                    [x1, y1, x2, y2] = [x1 * inv, y1 * inv, x2 * inv, y2 * inv];
                }
                let dx = x2 - x1, dy = y2 - y1;
                let inv = 0.2 * scale * WebMolKit.invZ(WebMolKit.norm_xy(dx, dy)), ox = dy * inv, oy = -dx * inv;
                let cx = 0.5 * (x1 + x2), cy = 0.5 * (y1 + y2), sz = 0.05 * scale;
                for (let p of [-2, -1, 1, 2]) {
                    let x = cx + p * ox, y = cy + p * oy;
                    vg.drawOval(x, y, sz, sz, WebMolKit.MetaVector.NOCOLOUR, 0, col);
                }
            }
        }
        drawOverEffects() {
            let mol = this.mol, policy = this.policy, effects = this.effects, layout = this.layout, scale = this.scale, vg = this.vg;
            for (let a of effects.overlapAtoms) {
                let p = layout.getPoint(a - 1);
                let rad = scale * 0.2;
                vg.drawLine(p.oval.cx - rad, p.oval.cy - rad, p.oval.cx + rad, p.oval.cy + rad, 0xFF0000, 1);
                vg.drawLine(p.oval.cx + rad, p.oval.cy - rad, p.oval.cx - rad, p.oval.cy + rad, 0xFF0000, 1);
            }
            for (let n = 0, num = Math.min(effects.atomCircleSz.length, mol.numAtoms); n < num; n++)
                if (effects.atomCircleSz[n] > 0) {
                    let dw = effects.atomCircleSz[n] * scale, col = effects.atomCircleCol[n];
                    let p = layout.getPoint(n);
                    vg.drawOval(p.oval.cx, p.oval.cy, dw, dw, WebMolKit.MetaVector.NOCOLOUR, 0, col);
                }
        }
        drawBondInclined(b) {
            let x1 = b.line.x1, y1 = b.line.y1, x2 = b.line.x2, y2 = b.line.y2;
            let dx = x2 - x1, dy = y2 - y1;
            let col = b.col;
            let size = b.size, head = b.head;
            let norm = head / Math.sqrt(dx * dx + dy * dy);
            let ox = norm * dy, oy = -norm * dx;
            let px = [x1, x2 - ox, x2 + ox], py = [y1, y2 - oy, y2 + oy];
            if (this.layout.getPoint(b.bto - 1).text == null && this.mol.atomAdjCount(b.bto) == 2) {
                let other = null;
                for (let n = 0; n < this.layout.numLines(); n++) {
                    let o = this.layout.getLine(n);
                    if (o.type == WebMolKit.BLineType.Normal && (o.bfr == b.bto || o.bto == b.bto)) {
                        if (other != null) {
                            other = null;
                            break;
                        }
                        other = o;
                    }
                }
                if (other != null) {
                    let th1 = Math.atan2(y1 - y2, x1 - x2);
                    let th2 = Math.atan2(other.line.y1 - other.line.y2, other.line.x1 - other.line.x2);
                    if (b.bto == other.bfr)
                        th2 += Math.PI;
                    let diff = Math.abs(WebMolKit.angleDiff(th1, th2));
                    if (diff > 105 * WebMolKit.DEGRAD && diff < 135 * WebMolKit.DEGRAD) {
                        let ixy1 = WebMolKit.GeomUtil.lineIntersect(px[0], py[0], px[1], py[1], other.line.x1, other.line.y1, other.line.x2, other.line.y2);
                        let ixy2 = WebMolKit.GeomUtil.lineIntersect(px[0], py[0], px[2], py[2], other.line.x1, other.line.y1, other.line.x2, other.line.y2);
                        px[1] = ixy1[0];
                        py[1] = ixy1[1];
                        px[2] = ixy2[0];
                        py[2] = ixy2[1];
                        let dx1 = px[1] - px[0], dy1 = py[1] - py[0], inv1 = 0.5 * other.size / WebMolKit.norm_xy(dx1, dy1);
                        px[1] += dx1 * inv1;
                        py[1] += dy1 * inv1;
                        let dx2 = px[2] - px[0], dy2 = py[2] - py[0], inv2 = 0.5 * other.size / WebMolKit.norm_xy(dx2, dy2);
                        px[2] += dx2 * inv1;
                        py[2] += dy2 * inv1;
                    }
                }
            }
            if (this.layout.getPoint(b.bto - 1).text == null && this.mol.atomAdjCount(b.bto) == 3) {
                let other1 = null, other2 = null;
                for (let n = 0; n < this.layout.numLines(); n++) {
                    let o = this.layout.getLine(n);
                    if (o.type == WebMolKit.BLineType.Normal && (o.bfr == b.bto || o.bto == b.bto)) {
                        if (other1 == null)
                            other1 = o;
                        else if (other2 == null)
                            other2 = o;
                        else {
                            other1 = other2 = null;
                            break;
                        }
                    }
                }
                if (other1 != null && other2 != null) {
                    let th1 = Math.atan2(y1 - y2, x1 - x2);
                    let th2 = Math.atan2(other1.line.y1 - other1.line.y2, other1.line.x1 - other1.line.x2);
                    let th3 = Math.atan2(other2.line.y1 - other2.line.y2, other2.line.x1 - other2.line.x2);
                    if (b.bto == other1.bfr)
                        th2 += Math.PI;
                    if (b.bto == other2.bfr)
                        th3 += Math.PI;
                    let dth1 = WebMolKit.angleDiff(th1, th2), diff1 = Math.abs(dth1);
                    let dth2 = WebMolKit.angleDiff(th1, th3), diff2 = Math.abs(dth2);
                    let diff3 = Math.abs(WebMolKit.angleDiff(th2, th3));
                    if (diff1 > 105 * WebMolKit.DEGRAD && diff1 < 135 * WebMolKit.DEGRAD ||
                        diff2 > 105 * WebMolKit.DEGRAD && diff2 < 135 * WebMolKit.DEGRAD ||
                        diff3 > 105 * WebMolKit.DEGRAD && diff3 < 135 * WebMolKit.DEGRAD) {
                        if (dth1 < 0)
                            [other1, other2] = [other2, other1];
                        let ixy1 = WebMolKit.GeomUtil.lineIntersect(px[0], py[0], px[1], py[1], other1.line.x1, other1.line.y1, other1.line.x2, other1.line.y2);
                        let ixy2 = WebMolKit.GeomUtil.lineIntersect(px[0], py[0], px[2], py[2], other2.line.x1, other2.line.y1, other2.line.x2, other2.line.y2);
                        px = [x1, ixy1[0], x2, ixy2[0]];
                        py = [y1, ixy1[1], y2, ixy2[1]];
                    }
                }
            }
            this.vg.drawPoly(px, py, WebMolKit.MetaVector.NOCOLOUR, 0, col, true);
        }
        drawBondDeclined(b) {
            let x1 = b.line.x1, y1 = b.line.y1, x2 = b.line.x2, y2 = b.line.y2;
            let dx = x2 - x1, dy = y2 - y1;
            let col = b.col;
            let size = b.size, head = b.head;
            let ext = Math.sqrt(dx * dx + dy * dy);
            let nsteps = Math.ceil(ext * 2.5 * this.invScale);
            let norm = head / ext;
            let ox = norm * dy, oy = -norm * dx, invSteps = 1.0 / (nsteps + 1);
            let holdout = this.mol.atomAdjCount(b.bto) == 1 && this.layout.getPoint(b.bto - 1).text == null ? 1 : 1 - (0.15 * this.scale) / ext;
            for (let i = 0; i <= nsteps + 1; i++) {
                let cx = x1 + i * dx * invSteps * holdout, cy = y1 + i * dy * invSteps * holdout;
                let ix = ox * i * invSteps, iy = oy * i * invSteps;
                this.vg.drawLine(cx - ix, cy - iy, cx + ix, cy + iy, col, size);
            }
        }
        drawBondUnknown(b) {
            let x1 = b.line.x1, y1 = b.line.y1, x2 = b.line.x2, y2 = b.line.y2;
            let dx = x2 - x1, dy = y2 - y1;
            let col = b.col;
            let size = b.size, head = b.head;
            let ext = Math.sqrt(dx * dx + dy * dy);
            let nsteps = Math.ceil(ext * 3.5 * this.invScale);
            let norm = head / ext;
            let ox = norm * dy, oy = -norm * dx;
            let sz = 1 + 3 * (nsteps + 1);
            let x = WebMolKit.Vec.numberArray(0, sz), y = WebMolKit.Vec.numberArray(0, sz), ctrl = WebMolKit.Vec.booleanArray(false, sz);
            x[0] = x1;
            y[0] = y1;
            ctrl[0] = false;
            for (let i = 0, j = 1; i <= nsteps; i++, j += 3) {
                let ax = x1 + i * dx / (nsteps + 1), ay = y1 + i * dy / (nsteps + 1);
                let cx = x1 + (i + 1) * dx / (nsteps + 1), cy = y1 + (i + 1) * dy / (nsteps + 1);
                let bx = (ax + cx) / 2, by = (ay + cy) / 2;
                let sign = i % 2 == 0 ? 1 : -1;
                x[j] = ax;
                x[j + 1] = bx + sign * ox;
                x[j + 2] = cx;
                y[j] = ay;
                y[j + 1] = by + sign * oy;
                y[j + 2] = cy;
                ctrl[j] = true;
                ctrl[j + 1] = true;
                ctrl[j + 2] = false;
            }
            this.vg.drawPath(x, y, ctrl, false, col, size, WebMolKit.MetaVector.NOCOLOUR, false);
        }
        drawBondDotted(b) {
            let x1 = b.line.x1, y1 = b.line.y1, x2 = b.line.x2, y2 = b.line.y2;
            let dx = x2 - x1, dy = y2 - y1;
            let col = b.col;
            let size = b.size;
            let radius = size, dist = WebMolKit.norm_xy(dx, dy);
            if (dist < 0.01)
                return;
            let nudge = 0.5 * size / dist;
            x1 += nudge * dx;
            y1 += nudge * dy;
            x2 -= nudge * dx;
            y2 -= nudge * dy;
            dx = x2 - x1;
            dy = y2 - y1;
            let nsteps = Math.ceil(0.2 * dist / radius);
            let invSteps = 1.0 / (nsteps + 1);
            for (let i = 0; i <= nsteps + 1; i++) {
                let r = radius;
                if (b.type == WebMolKit.BLineType.DotDir)
                    r *= 1 + (i * (1.0 / (nsteps + 2)) - 0.5);
                let cx = x1 + i * dx * invSteps, cy = y1 + i * dy * invSteps;
                this.vg.drawOval(cx, cy, r, r, WebMolKit.MetaVector.NOCOLOUR, 0, col);
            }
        }
        drawBondIncMulti(b) {
            let x1 = b.line.x1, y1 = b.line.y1, x2 = b.line.x2, y2 = b.line.y2;
            let dx = x2 - x1, dy = y2 - y1;
            let col = b.col;
            let size = b.size, head = b.head;
            let norm = head / Math.sqrt(dx * dx + dy * dy);
            let ox = norm * dy, oy = -norm * dx;
            this.vg.drawPoly([x1, x2 - ox, x2 + ox], [y1, y2 - oy, y2 + oy], col, this.scale * 0.05, WebMolKit.MetaVector.NOCOLOUR, true);
            if (b.type == WebMolKit.BLineType.IncDouble) {
                this.vg.drawLine(x1, y1, x2, y2, col, this.scale * 0.03);
            }
            else {
                this.vg.drawLine(x1, y1, x2 + 0.33 * ox, y2 + 0.33 * oy, col, this.scale * 0.03);
                this.vg.drawLine(x1, y1, x2 - 0.33 * ox, y2 - 0.33 * oy, col, this.scale * 0.03);
            }
        }
    }
    WebMolKit.DrawMolecule = DrawMolecule;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class ViewStructure extends WebMolKit.Widget {
        constructor(tokenID) {
            super();
            this.tokenID = tokenID;
            this.naturalWidth = 0;
            this.naturalHeight = 0;
            this.width = 0;
            this.height = 0;
            this.padding = 2;
            this.borderCol = 0x000000;
            this.borderRadius = 8;
            this.backgroundCol1 = 0xFFFFFF;
            this.backgroundCol2 = 0xE0E0E0;
            this.molstr = null;
            this.datastr = null;
            this.datarow = 0;
            this.policy = null;
        }
        defineMolecule(mol) {
            this.molstr = mol.toString();
        }
        defineMoleculeString(molsk) {
            this.molstr = molsk;
        }
        defineDataSheetString(dsxml, rowidx) {
            this.datastr = dsxml;
            this.datarow = rowidx != null ? rowidx : 0;
        }
        defineRenderPolicy(policy) {
            this.policy = policy;
        }
        setup(callback) {
            if (this.molstr == null && this.datastr == null)
                throw 'molsync.ui.ViewStructure.setup called without specifying a molecule or datasheet';
            if (this.policy == null)
                this.policy = WebMolKit.RenderPolicy.defaultColourOnWhite();
            if (this.molstr != null)
                this.setupMolecule(callback);
            else
                this.setupData(callback);
        }
        render(parent) {
            if (!this.metavec)
                throw 'molsync.ui.ViewStructure.render must be preceded by a call to setup';
            super.render(parent);
            let canvas = WebMolKit.newElement(this.content, 'canvas', { 'width': this.width, 'height': this.height });
            let density = WebMolKit.pixelDensity();
            canvas.width = this.width * density;
            canvas.height = this.height * density;
            canvas.style.width = this.width + 'px';
            canvas.style.height = this.height + 'px';
            let ctx = canvas.getContext('2d');
            ctx.save();
            ctx.scale(density, density);
            let path;
            if (this.borderRadius == 0) {
                path = new Path2D();
                path.rect(1.5, 1.5, this.width - 3, this.height - 3);
            }
            else
                path = WebMolKit.pathRoundedRect(1.5, 1.5, this.width - 1.5, this.height - 1.5, this.borderRadius);
            if (this.backgroundCol1 != null) {
                if (this.backgroundCol2 == null) {
                    ctx.fillStyle = WebMolKit.colourCanvas(this.backgroundCol1);
                }
                else {
                    var grad = ctx.createLinearGradient(0, 0, this.width, this.height);
                    grad.addColorStop(0, WebMolKit.colourCanvas(this.backgroundCol1));
                    grad.addColorStop(1, WebMolKit.colourCanvas(this.backgroundCol2));
                    ctx.fillStyle = grad;
                }
                ctx.fill(path);
            }
            if (this.borderCol != -1) {
                ctx.strokeStyle = WebMolKit.colourCanvas(this.borderCol);
                ctx.lineWidth = 1;
                ctx.stroke(path);
            }
            let limW = this.width - 2 * this.padding, limH = this.height - 2 * this.padding;
            let natW = this.naturalWidth, natH = this.naturalHeight;
            let scale = 1;
            if (natW > limW) {
                let down = limW / natW;
                scale *= down;
                natW *= down;
                natH *= down;
            }
            if (natH > limH) {
                let down = limH / natH;
                scale *= down;
                natW *= down;
                natH *= down;
            }
            this.metavec.offsetX = 0.5 * (this.width - natW);
            this.metavec.offsetY = 0.5 * (this.height - natH);
            this.metavec.scale = scale;
            this.metavec.renderContext(ctx);
            ctx.restore();
        }
        setupMolecule(callback) {
            let mol = WebMolKit.Molecule.fromString(this.molstr);
            let effects = new WebMolKit.RenderEffects();
            let measure = new WebMolKit.OutlineMeasurement(0, 0, this.policy.data.pointScale);
            let layout = new WebMolKit.ArrangeMolecule(mol, measure, this.policy, effects);
            layout.arrange();
            this.metavec = new WebMolKit.MetaVector();
            new WebMolKit.DrawMolecule(layout, this.metavec).draw();
            this.metavec.normalise();
            this.naturalWidth = this.metavec.width;
            this.naturalHeight = this.metavec.height;
            if (this.width == 0)
                this.width = this.naturalWidth + 2 * this.padding;
            if (this.height == 0)
                this.height = this.naturalHeight + 2 * this.padding;
            if (callback)
                callback();
        }
        setupData(callback) {
            let input = { 'tokenID': this.tokenID };
            input.policy = this.policy.data;
            input.dataXML = this.datastr;
            input.dataRow = this.datarow;
            WebMolKit.Func.renderStructure(input, (result, error) => {
                if (!result) {
                    alert('Setup of ViewStructure failed: ' + error.message);
                    return;
                }
                this.metavec = new WebMolKit.MetaVector(result.metavec);
                this.naturalWidth = this.metavec.width;
                this.naturalHeight = this.metavec.width;
                if (this.width == 0)
                    this.width = this.naturalWidth + 2 * this.padding;
                if (this.height == 0)
                    this.height = this.naturalHeight + 2 * this.padding;
                if (callback)
                    callback();
            });
        }
    }
    WebMolKit.ViewStructure = ViewStructure;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class PickRecent extends WebMolKit.Dialog {
        constructor(cookies, sides) {
            super();
            this.cookies = cookies;
            this.sides = sides;
            this.callbackPick1 = null;
            this.callbackPick2 = null;
            this.tableRows = [];
            this.views = [];
            this.title = "Recent Molecules";
            this.minPortionWidth = 20;
            this.maxPortionWidth = 95;
        }
        populate() {
            let table = $('<table></table>').appendTo(this.body());
            for (let n = 0; n < this.cookies.numMolecules(); n++) {
                const idx = n;
                let tr = $('<tr></tr>').appendTo(table);
                this.tableRows.push(tr);
                let tdHTML = '<td style="text-align: center; vertical-align: middle; padding: 0.5em;"></td>';
                const tdMol = $(tdHTML).appendTo(tr);
                let mol = this.cookies.getMolecule(n);
                const vs = new WebMolKit.ViewStructure();
                this.views[n] = vs;
                vs.content = tdMol;
                vs.defineMolecule(mol);
                vs.borderCol = -1;
                vs.backgroundCol1 = 0xF8F8F8;
                vs.backgroundCol2 = 0xE0E0E0;
                vs.padding = 4;
                vs.setup(() => { vs.render(tdMol); this.bump(); });
                let tdPick = $(tdHTML).appendTo(tr);
                if (this.sides == 1) {
                    let btnPick = $('<button class="button button-primary">Pick</button>').appendTo(tdPick);
                    btnPick.click(() => this.pickMolecule(idx, 1));
                }
                else {
                    let btnPick1 = $('<button class="button button-primary">Reactant</button>').appendTo(tdPick);
                    tdPick.append('&nbsp;');
                    let btnPick2 = $('<button class="button button-primary">Product</button>').appendTo(tdPick);
                    btnPick1.click(() => this.pickMolecule(idx, 1));
                    btnPick2.click(() => this.pickMolecule(idx, 2));
                }
                tdPick.append('&nbsp;');
                let btnDelete = $('<button class="button button-default">Delete</button>').appendTo(tdPick);
                btnDelete.click(() => this.deleteMolecule(idx));
            }
        }
        pickMolecule(idx, which) {
            let mol = this.cookies.getMolecule(idx);
            this.cookies.promoteToTop(idx);
            if (which == 1 && this.callbackPick1)
                this.callbackPick1(mol);
            if (which == 2 && this.callbackPick2)
                this.callbackPick2(mol);
            this.close();
        }
        deleteMolecule(idx) {
            this.cookies.deleteMolecule(idx);
            this.tableRows[idx].remove();
            this.bump();
        }
    }
    WebMolKit.PickRecent = PickRecent;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class ButtonView extends WebMolKit.Widget {
        constructor(position, parentX, parentY, parentWidth, parentHeight) {
            super();
            this.position = position;
            this.parentX = parentX;
            this.parentY = parentY;
            this.parentWidth = parentWidth;
            this.parentHeight = parentHeight;
            this.idealSize = 50;
            this.width = 0;
            this.height = 0;
            this.selectedButton = null;
            this.highlightButton = null;
            this.border = 0x808080;
            this.background = 0xFFFFFF;
            this.buttonColNorm1 = 0x47D5D2;
            this.buttonColNorm2 = 0x008FD1;
            this.buttonColActv1 = 0x30FF69;
            this.buttonColActv2 = 0x008650;
            this.buttonColSel1 = 0xFFFFFF;
            this.buttonColSel2 = 0xE0E0E0;
            this.canvas = null;
            this.stack = [];
            this.display = [];
            this.hasBigButtons = true;
            this.prefabImgSize = 44;
            this.gripHeight = 30;
            this.gripWidth = 50;
            this.isRaised = true;
            this.outPadding = 2;
            this.inPadding = 2;
            this.x = 0;
            this.y = 0;
        }
        static prepare(callback) {
            if (WebMolKit.RPC.BASE_URL == null && WebMolKit.RPC.RESOURCE_URL != null)
                ButtonView.ACTION_ICONS = {};
            if (ButtonView.ACTION_ICONS != null) {
                callback();
                return;
            }
            let fcn = (result, error) => {
                if (!result.actions) {
                    alert('Fetching action icons failed: ' + error.message);
                    return;
                }
                ButtonView.ACTION_ICONS = result.actions;
                callback();
            };
            WebMolKit.Func.getActionIcons({}, fcn);
        }
        setParentSize(width, height) {
            this.parentWidth = width;
            this.parentHeight = height;
        }
        get topBank() {
            return this.stack.length > 0 ? this.stack[this.stack.length - 1] : null;
        }
        get stackSize() { return this.stack.length; }
        render(parent) {
            super.render(parent);
            this.content.css('position', 'absolute');
            this.content.css('width', `${this.width}px`);
            this.content.css('height', `${this.height}px`);
            this.content.addClass('no_selection');
            this.layoutButtons();
            let canvasStyle = 'position: absolute; left: 0; top: 0;';
            canvasStyle += 'pointer-events: none;';
            this.canvas = WebMolKit.newElement(this.content, 'canvas', { 'width': this.width, 'height': this.height, 'style': canvasStyle });
            this.canvas.style.width = this.width + 'px';
            this.canvas.style.height = this.height + 'px';
            this.applyOffset();
            this.redraw();
            this.content.click((event) => this.mouseClick(event));
            this.content.dblclick((event) => this.mouseDoubleClick(event));
            this.content.mousedown((event) => { event.preventDefault(); this.mouseDown(event); });
            this.content.mouseup((event) => this.mouseUp(event));
            this.content.mouseover((event) => this.mouseOver(event));
            this.content.mouseout((event) => this.mouseOut(event));
            this.content.mousemove((event) => this.mouseMove(event));
        }
        pushBank(bank) {
            bank.buttonView = this;
            bank.isSubLevel = this.stack.length > 0;
            bank.init();
            this.stack.push(bank);
            if (this.canvas != null) {
                this.layoutButtons();
                this.replaceCanvas();
                this.applyOffset();
                this.redraw();
            }
        }
        popBank() {
            if (this.stack.length == 0)
                return;
            this.stack[this.stack.length - 1].bankClosed();
            this.stack.length--;
            if (this.canvas != null) {
                this.layoutButtons();
                this.replaceCanvas();
                this.applyOffset();
                this.redraw();
            }
        }
        refreshBank() {
            if (this.canvas != null) {
                this.layoutButtons();
                this.replaceCanvas();
                this.applyOffset();
                this.redraw();
            }
        }
        getSelectedButton() {
            return this.selectedButton;
        }
        setSelectedButton(id) {
            if (id != this.selectedButton) {
                this.selectedButton = id;
                this.redraw();
            }
        }
        raiseBank() {
            if (this.isRaised)
                return;
            this.isRaised = true;
            if (this.content) {
                this.layoutButtons();
                this.replaceCanvas();
                this.applyOffset();
                this.redraw();
            }
        }
        lowerBank() {
            if (!this.isRaised)
                return;
            this.isRaised = false;
            if (this.content) {
                this.layoutButtons();
                this.replaceCanvas();
                this.applyOffset();
                this.redraw();
            }
        }
        getHasBigButtons() {
            return this.hasBigButtons;
        }
        ;
        setHasBigButtons(flag) {
            this.hasBigButtons = flag;
            this.prefabImgSize = flag ? 44 : 36;
            this.idealSize = flag ? 50 : 40;
        }
        ;
        withinOutline(x, y) {
            let w = this.width, h = this.height;
            if (x < 0 || x > w || y < 0 || y > h)
                return false;
            if (this.position == 'centre' || this.stack.length == 0)
                return true;
            if (this.position == 'left') {
                let my = 0.5 * h - 1, gw = this.gripHeight, hg = 0.5 * this.gripWidth;
                return x < w - gw || (y > my - hg && y < my + hg);
            }
            else if (this.position == 'right') {
                let my = 0.5 * h - 1, gw = this.gripHeight, hg = 0.5 * this.gripWidth;
                return x > gw || (y > my - hg && y < my + hg);
            }
            else if (this.position == 'top') {
                let mx = 0.5 * w - 1, gh = this.gripHeight, hg = 0.5 * this.gripWidth;
                return y < h - gh || (x > mx - hg && x < mx + hg);
            }
            else if (this.position == 'bottom') {
                let mx = 0.5 * w - 1, gh = this.gripHeight, hg = 0.5 * this.gripWidth;
                return y > gh || (x > mx - hg && x < mx + hg);
            }
            return true;
        }
        ;
        layoutButtons() {
            if (this.content == null)
                return;
            let outPadding = this.outPadding, inPadding = this.inPadding;
            this.removeDisplayButtons();
            if (this.stack.length == 0) {
                this.width = 10;
                this.height = 10;
                if (this.position == 'left' || this.position == 'right')
                    this.height = this.parentHeight;
                else if (this.position == 'top' || this.position == 'bottom')
                    this.width = this.parentWidth;
                return;
            }
            if (!this.isRaised) {
                if (this.position == 'left' || this.position == 'right') {
                    this.width = this.gripHeight;
                    this.height = this.gripWidth + 2 * outPadding;
                }
                else if (this.position == 'top' || this.position == 'bottom') {
                    this.width = this.gripWidth + 2 * outPadding;
                    this.height = this.gripHeight;
                }
                this.addGripButton();
                return;
            }
            let bank = this.stack[this.stack.length - 1];
            bank.buttons = [];
            bank.update();
            let popWidth = 0, popHeight = 0;
            if (this.stack.length == 1) { }
            else if (this.position == 'left' || this.position == 'right')
                popHeight = this.gripHeight + inPadding;
            else if (this.position == 'top' || this.position == 'bottom')
                popWidth = this.gripHeight + inPadding;
            let bestLayout = null, bestScore = null;
            if (this.position == 'left' || this.position == 'right') {
                let maxSlotHeight = Math.floor((this.parentHeight - 2 * outPadding - inPadding) / (this.idealSize + inPadding));
                let minSlotHeight = Math.ceil(0.5 * maxSlotHeight);
                for (let i = maxSlotHeight; i >= minSlotHeight; i--) {
                    let slotWidth = Math.ceil(bank.buttons.length / i);
                    for (let j = slotWidth; j <= slotWidth + 1; j++) {
                        let layout = this.layoutMaxHeight(bank, i, j);
                        let score = this.scoreLayout(layout) + 1 * layout[0].length;
                        if (bestLayout == null || score < bestScore) {
                            bestLayout = layout;
                            bestScore = score;
                        }
                    }
                }
            }
            else if (this.position == 'top' || this.position == 'bottom') {
                let maxSlotWidth = Math.floor((this.parentWidth - 2 * outPadding - inPadding - popWidth) / (this.idealSize + inPadding));
                let minSlotWidth = Math.ceil(0.5 * maxSlotWidth);
                for (let n = maxSlotWidth; n >= minSlotWidth; n--) {
                    let layout = this.layoutMaxWidth(bank, n);
                    let score = this.scoreLayout(layout) + 1 * layout.length;
                    if (bestLayout == null || score < bestScore) {
                        bestLayout = layout;
                        bestScore = score;
                    }
                }
            }
            else {
            }
            let ncols = bestLayout[0].length, nrows = bestLayout.length;
            this.width = 2 * outPadding + inPadding + (this.idealSize + inPadding) * ncols + popWidth;
            this.height = 2 * outPadding + inPadding + (this.idealSize + inPadding) * nrows + popHeight;
            if (this.position == 'left' || this.position == 'right')
                this.width += this.gripHeight;
            else if (this.position == 'top' || this.position == 'bottom')
                this.height += this.gripHeight;
            this.addGripButton();
            if (popWidth > 0 || popHeight > 0) {
                let d = {
                    'id': '!',
                    'x': outPadding + inPadding,
                    'y': outPadding + inPadding,
                    'width': popWidth - inPadding,
                    'height': popHeight - inPadding
                };
                if (this.position == 'right')
                    d.x += this.gripHeight;
                else if (this.position == 'bottom')
                    d.y += this.gripHeight;
                if (popWidth == 0)
                    d.width = ncols * this.idealSize + inPadding * (ncols - 1);
                if (popHeight == 0)
                    d.height = nrows * this.idealSize + inPadding * (nrows - 1);
                this.display.push(d);
            }
            for (let y = 0; y < nrows; y++)
                for (let x = 0; x < ncols; x++) {
                    for (let n = 0; n < bank.buttons.length; n++)
                        if (bestLayout[y][x] == bank.buttons[n].id) {
                            let b = bank.buttons[n], d = { 'id': b.id };
                            d.x = outPadding + inPadding + popWidth + (this.idealSize + inPadding) * x;
                            d.y = outPadding + inPadding + popHeight + (this.idealSize + inPadding) * y;
                            if (this.position == 'right')
                                d.x += this.gripHeight;
                            else if (this.position == 'bottom')
                                d.y += this.gripHeight;
                            d.width = this.idealSize;
                            d.height = this.idealSize;
                            this.display.push(d);
                        }
                }
        }
        addGripButton() {
            if (this.position == 'centre')
                return;
            let d = { 'id': '*' }, spc = 3;
            if (this.position == 'left') {
                d.width = this.gripHeight - spc;
                d.height = this.gripWidth - 2 * spc;
                d.x = this.width - d.width - spc - 1;
                d.y = 0.5 * (this.height - d.height);
            }
            else if (this.position == 'right') {
                d.width = this.gripHeight - spc;
                d.height = this.gripWidth - 2 * spc;
                d.x = spc + 1;
                d.y = 0.5 * (this.height - d.height);
            }
            else if (this.position == 'top') {
                d.width = this.gripWidth - 2 * spc;
                d.height = this.gripHeight - spc;
                d.x = 0.5 * (this.width - d.width);
                d.y = this.height - d.height - spc - 1;
            }
            else if (this.position == 'bottom') {
                d.width = this.gripWidth - 2 * spc;
                d.height = this.gripHeight - spc;
                d.x = 0.5 * (this.width - d.width);
                d.y = spc + 1;
            }
            this.display.push(d);
        }
        replaceCanvas() {
            this.content.empty();
            for (let n = 0; n < this.display.length; n++) {
                this.display[n].svgDOM = null;
                this.display[n].helpSpan = null;
            }
            let canvasStyle = 'position: absolute; left: 0; top: 0;';
            canvasStyle += 'pointer-events: none;';
            this.canvas = WebMolKit.newElement(this.content, 'canvas', { 'width': this.width, 'height': this.height, 'style': canvasStyle });
        }
        removeDisplayButtons() {
            this.content.empty();
            this.display = [];
        }
        applyOffset() {
            let x, y;
            if (this.position == 'left') {
                x = 0;
                y = 0.5 * (this.parentHeight - this.height);
            }
            else if (this.position == 'right') {
                x = this.parentWidth - this.width;
                y = 0.5 * (this.parentHeight - this.height);
            }
            else if (this.position == 'top') {
                x = 0.5 * (this.parentWidth - this.width);
                y = 0;
            }
            else if (this.position == 'bottom') {
                x = 0.5 * (this.parentWidth - this.width);
                y = this.parentHeight - this.height;
            }
            else {
                x = 0.5 * (this.parentWidth - this.width);
                y = 0.5 * (this.parentHeight - this.height);
            }
            this.x = this.parentX + x;
            this.y = this.parentY + y;
            this.content.css('position', 'absolute');
            this.content.css('width', this.width + 'px');
            this.content.css('height', this.height + 'px');
            this.content.css('left', this.x + 'px');
            this.content.css('top', this.y + 'px');
        }
        redraw() {
            if (!this.content || !this.canvas)
                return;
            let density = WebMolKit.pixelDensity();
            this.canvas.width = this.width * density;
            this.canvas.height = this.height * density;
            this.canvas.style.width = this.width + 'px';
            this.canvas.style.height = this.height + 'px';
            let ctx = this.canvas.getContext('2d');
            ctx.save();
            ctx.scale(density, density);
            ctx.clearRect(0, 0, this.width, this.height);
            let path = this.traceOutline();
            ctx.fillStyle = WebMolKit.colourCanvas(this.background);
            ctx.fill(path);
            ctx.strokeStyle = WebMolKit.colourCanvas(this.border);
            ctx.lineWidth = 1;
            ctx.stroke(path);
            let bank = this.stack.length > 0 ? this.stack[this.stack.length - 1] : null;
            this.content.css('width', this.width + 'px');
            this.content.css('height', this.height + 'px');
            for (let n = 0; n < this.display.length; n++) {
                const d = this.display[n], b = this.buttonFromID(d.id);
                let col1, col2;
                if (this.highlightButton != null && d.id == this.highlightButton) {
                    col1 = this.buttonColActv1;
                    col2 = this.buttonColActv2;
                }
                else if (this.selectedButton != null && d.id == this.selectedButton) {
                    col1 = this.buttonColSel1;
                    col2 = this.buttonColSel2;
                }
                else {
                    col1 = this.buttonColNorm1;
                    col2 = this.buttonColNorm2;
                }
                ctx.save();
                path = WebMolKit.pathRoundedRect(d.x + 0.5, d.y + 0.5, d.x + d.width - 1, d.y + d.height - 1, 5);
                if (col2 != null) {
                    let grad = ctx.createLinearGradient(d.x, d.y, d.x + d.width, d.y + d.height);
                    grad.addColorStop(0, WebMolKit.colourCanvas(col1));
                    grad.addColorStop(1, WebMolKit.colourCanvas(col2));
                    ctx.fillStyle = grad;
                }
                else
                    ctx.fillStyle = WebMolKit.colourCanvas(col1);
                ctx.fill(path);
                ctx.strokeStyle = WebMolKit.colourCanvas(this.border);
                ctx.lineWidth = 0.5;
                ctx.stroke(path);
                ctx.restore();
                if (d.svgDOM != null) {
                    $(d.svgDOM).remove();
                    d.svgDOM = null;
                }
                if (b != null) {
                    if (d.helpSpan == null) {
                        d.helpSpan = $('<span style="position: absolute;"></span>').appendTo(this.content);
                        let txt = b.helpText;
                        if (b.mnemonic) {
                            while (txt.endsWith('.'))
                                txt = txt.substring(0, txt.length - 1);
                            txt += ' [' + b.mnemonic + ']';
                        }
                        WebMolKit.addTooltip(d.helpSpan, txt);
                    }
                    d.helpSpan.css('left', d.x + 'px');
                    d.helpSpan.css('top', d.y + 'px');
                    d.helpSpan.css('width', d.width + 'px');
                    d.helpSpan.css('height', d.height + 'px');
                }
                if (b == null) { }
                else if (b.imageFN != null && d.svgDOM == null) {
                    const sz = this.prefabImgSize;
                    const bx = d.x + Math.floor(0.5 * (d.width - sz));
                    const by = d.y + Math.floor(0.5 * (d.height - sz));
                    let putSVG = (svg) => {
                        let extra = 'style="position: absolute; left: ' + bx + 'px; top: ' + by + 'px;' +
                            ' width: ' + sz + 'px; height: ' + sz + 'px; pointer-events: none;"';
                        svg = svg.substring(0, 4) + ' ' + extra + svg.substring(4);
                        d.svgDOM = $(svg)[0];
                        this.content.append(d.svgDOM);
                    };
                    let svg = ButtonView.ACTION_ICONS[b.imageFN];
                    if (svg)
                        putSVG(svg);
                    else if (WebMolKit.RPC.RESOURCE_URL != null) {
                        let url = WebMolKit.RPC.RESOURCE_URL + '/img/actions/' + b.imageFN + '.svg';
                        $.ajax({
                            'url': url,
                            'type': 'GET',
                            'dataType': 'text',
                            'success': (svg) => {
                                svg = this.fixSVGFile(svg);
                                ButtonView.ACTION_ICONS[b.imageFN] = svg;
                                putSVG(svg);
                            }
                        });
                    }
                    else
                        console.log('Action button "' + b.imageFN + '" not found.');
                }
                else if (b.metavec != null) {
                    let draw = b.metavec instanceof WebMolKit.MetaVector ? b.metavec : new WebMolKit.MetaVector(b.metavec);
                    draw.offsetX = d.x + Math.floor(0.5 * (d.width - draw.width));
                    draw.offsetY = d.y + Math.floor(0.5 * (d.height - draw.height));
                    draw.renderContext(ctx);
                }
                else if (b.text != null) {
                    let sz = this.idealSize;
                    let draw = new WebMolKit.MetaVector({ 'size': [sz, sz] });
                    let fsz = sz * 0.6;
                    let wad = WebMolKit.FontData.main.measureText(b.text, fsz);
                    if (wad[1] + wad[2] > sz) {
                        fsz *= sz / (wad[1] + wad[2]);
                        wad = WebMolKit.FontData.main.measureText(b.text, fsz);
                    }
                    if (wad[0] > sz) {
                        fsz *= sz / wad[0];
                        wad = WebMolKit.FontData.main.measureText(b.text, fsz);
                    }
                    let x = 0.5 * (sz - wad[0]), y = 0.5 * (sz + wad[1]);
                    draw.drawText(x - 1, y, b.text, fsz, 0x000000);
                    draw.drawText(x + 1, y, b.text, fsz, 0x000000);
                    draw.drawText(x, y - 1, b.text, fsz, 0x000000);
                    draw.drawText(x, y + 1, b.text, fsz, 0x000000);
                    draw.drawText(x, y, b.text, fsz, 0xFFFFFF);
                    draw.offsetX = d.x + Math.floor(0.5 * (d.width - draw.width));
                    draw.offsetY = d.y + Math.floor(0.5 * (d.height - draw.height));
                    draw.renderContext(ctx);
                }
                if (b != null && b.isSubMenu) {
                    ctx.save();
                    let sx = d.x + d.width - 3, sy = d.y + d.height - 3;
                    ctx.beginPath();
                    ctx.moveTo(sx, sy);
                    ctx.lineTo(sx - 6, sy);
                    ctx.lineTo(sx, sy - 6);
                    ctx.closePath();
                    ctx.fillStyle = 'black';
                    ctx.fill();
                    ctx.restore();
                }
                if (d.id == '*') {
                    ctx.save();
                    path = new Path2D();
                    let px, py, flip = this.isRaised;
                    if (this.position == 'left' || this.position == 'right') {
                        px = [0.2, 0.7, 0.7];
                        py = [0.5, 0.3, 0.7];
                        if (this.position == 'left')
                            flip = !flip;
                    }
                    else if (this.position == 'top' || this.position == 'bottom') {
                        px = [0.5, 0.3, 0.7];
                        py = [0.2, 0.7, 0.7];
                        if (this.position == 'top')
                            flip = !flip;
                    }
                    if (flip) {
                        px = [1 - px[0], 1 - px[1], 1 - px[2]];
                        py = [1 - py[0], 1 - py[1], 1 - py[2]];
                    }
                    path.moveTo(d.x + d.width * px[0], d.y + d.height * py[0]);
                    path.lineTo(d.x + d.width * px[1], d.y + d.height * py[1]);
                    path.lineTo(d.x + d.width * px[2], d.y + d.height * py[2]);
                    path.closePath();
                    ctx.fillStyle = 'white';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 0;
                    ctx.fill(path);
                    ctx.stroke(path);
                    ctx.restore();
                }
                else if (d.id == '!') {
                    ctx.save();
                    let path1 = new Path2D(), path2 = new Path2D();
                    let inset = 5;
                    let w = d.width - inset * 2, h = d.height - inset * 2;
                    for (let z = 5; z < w + h - 1; z += 12) {
                        let x1 = 0, y1 = z, x2 = z, y2 = 0;
                        if (y1 > h) {
                            let delta = y1 - h;
                            x1 += delta;
                            y1 -= delta;
                        }
                        if (x2 > w) {
                            let delta = x2 - w;
                            x2 -= delta;
                            y2 += delta;
                        }
                        path1.moveTo(d.x + inset + x1, d.y + inset + y1);
                        path1.lineTo(d.x + inset + x2, d.y + inset + y2);
                        path2.moveTo(d.x + inset + x1 + 1, d.y + inset + y1);
                        path2.lineTo(d.x + inset + x2 + 1, d.y + inset + y2);
                    }
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = '#404040';
                    ctx.stroke(path1);
                    ctx.strokeStyle = 'white';
                    ctx.stroke(path2);
                    ctx.restore();
                }
            }
            ctx.restore();
        }
        ;
        delayedRedraw() {
            window.setTimeout(() => this.redraw(), 100);
        }
        ;
        buttonFromID(id) {
            let bank = this.stack[this.stack.length - 1];
            for (let n = 0; n < bank.buttons.length; n++)
                if (bank.buttons[n].id == id)
                    return bank.buttons[n];
            return null;
        }
        displayFromID(id) {
            for (let n = 0; n < this.display.length; n++)
                if (this.display[n].id == id)
                    return this.display[n];
            return null;
        }
        traceOutline() {
            let w = this.width, h = this.height, uw = w - 1, uh = h - 1, r = 8;
            if (this.position == 'centre' || this.stack.length == 0)
                return WebMolKit.pathRoundedRect(0.5, 0.5, w - 0.5, h - 0.5, r);
            let path = new Path2D();
            if (this.position == 'left') {
                let my = 0.5 * h - 1, gw = this.gripHeight, hg = 0.5 * this.gripWidth;
                path.moveTo(0.5, 0.5);
                path.lineTo(0.5 + uw - gw - r, 0.5);
                path.bezierCurveTo(0.5 + uw - gw, 0.5, 0.5 + uw - gw, 0.5, 0.5 + uw - gw, 0.5 + r);
                path.lineTo(0.5 + uw - gw, 0.5 + my - hg);
                path.lineTo(0.5 + uw - r, 0.5 + my - hg);
                path.bezierCurveTo(0.5 + uw, 0.5 + my - hg, 0.5 + uw, 0.5 + my - hg, 0.5 + uw, 0.5 + my - hg + r);
                path.lineTo(0.5 + uw, 0.5 + my + hg - r);
                path.bezierCurveTo(0.5 + uw, 0.5 + my + hg, 0.5 + uw, 0.5 + my + hg, 0.5 + uw - r, 0.5 + my + hg);
                path.lineTo(0.5 + uw - gw, 0.5 + my + hg);
                path.lineTo(0.5 + uw - gw, 0.5 + uh - r);
                path.bezierCurveTo(0.5 + uw - gw, 0.5 + uh, 0.5 + uw - gw, 0.5 + uh, 0.5 + uw - gw - r, 0.5 + uh);
                path.lineTo(0.5, 0.5 + uh);
            }
            else if (this.position == 'right') {
                let my = 0.5 * h - 1, gw = this.gripHeight, hg = 0.5 * this.gripWidth;
                path.moveTo(w - 0.5, 0.5);
                path.lineTo(w - (0.5 + uw - gw - r), 0.5);
                path.bezierCurveTo(w - (0.5 + uw - gw), 0.5, w - (0.5 + uw - gw), 0.5, w - (0.5 + uw - gw), 0.5 + r);
                path.lineTo(w - (0.5 + uw - gw), 0.5 + my - hg);
                path.lineTo(w - (0.5 + uw - r), 0.5 + my - hg);
                path.bezierCurveTo(w - (0.5 + uw), 0.5 + my - hg, w - (0.5 + uw), 0.5 + my - hg, w - (0.5 + uw), 0.5 + my - hg + r);
                path.lineTo(w - (0.5 + uw), 0.5 + my + hg - r);
                path.bezierCurveTo(w - (0.5 + uw), 0.5 + my + hg, w - (0.5 + uw), 0.5 + my + hg, w - (0.5 + uw - r), 0.5 + my + hg);
                path.lineTo(w - (0.5 + uw - gw), 0.5 + my + hg);
                path.lineTo(w - (0.5 + uw - gw), 0.5 + uh - r);
                path.bezierCurveTo(w - (0.5 + uw - gw), 0.5 + uh, w - (0.5 + uw - gw), 0.5 + uh, w - (0.5 + uw - gw - r), 0.5 + uh);
                path.lineTo(w - 0.5, 0.5 + uh);
            }
            else if (this.position == 'top') {
                let mx = 0.5 * w - 1, gh = this.gripHeight, hg = 0.5 * this.gripWidth;
                path.moveTo(0.5, h - (0.5 + uh));
                path.lineTo(0.5, h - (0.5 + gh + r));
                path.bezierCurveTo(0.5, h - (0.5 + gh), 0.5, h - (0.5 + gh), 0.5 + r, h - (0.5 + gh));
                path.lineTo(0.5 + mx - hg, h - (0.5 + gh));
                path.lineTo(0.5 + mx - hg, h - (0.5 + r));
                path.bezierCurveTo(0.5 + mx - hg, h - 0.5, 0.5 + mx - hg, h - 0.5, 0.5 + mx - hg + r, h - 0.5);
                path.lineTo(0.5 + mx + hg - r, h - 0.5);
                path.bezierCurveTo(0.5 + mx + hg, h - 0.5, 0.5 + mx + hg, h - 0.5, 0.5 + mx + hg, h - (0.5 + r));
                path.lineTo(0.5 + mx + hg, h - (0.5 + gh));
                path.lineTo(0.5 + uw - r, h - (0.5 + gh));
                path.bezierCurveTo(0.5 + uw, h - (0.5 + gh), 0.5 + uw, h - (0.5 + gh), 0.5 + uw, h - (0.5 + gh + r));
                path.lineTo(0.5 + uw, h - (0.5 + uh));
            }
            else if (this.position == 'bottom') {
                let mx = 0.5 * w - 1, gh = this.gripHeight, hg = 0.5 * this.gripWidth;
                path.moveTo(0.5, 0.5 + uh);
                path.lineTo(0.5, 0.5 + gh + r);
                path.bezierCurveTo(0.5, 0.5 + gh, 0.5, 0.5 + gh, 0.5 + r, 0.5 + gh);
                path.lineTo(0.5 + mx - hg, 0.5 + gh);
                path.lineTo(0.5 + mx - hg, 0.5 + r);
                path.bezierCurveTo(0.5 + mx - hg, 0.5, 0.5 + mx - hg, 0.5, 0.5 + mx - hg + r, 0.5);
                path.lineTo(0.5 + mx + hg - r, 0.5);
                path.bezierCurveTo(0.5 + mx + hg, 0.5, 0.5 + mx + hg, 0.5, 0.5 + mx + hg, 0.5 + r);
                path.lineTo(0.5 + mx + hg, 0.5 + gh);
                path.lineTo(0.5 + uw - r, 0.5 + gh);
                path.bezierCurveTo(0.5 + uw, 0.5 + gh, 0.5 + uw, 0.5 + gh, 0.5 + uw, 0.5 + gh + r);
                path.lineTo(0.5 + uw, 0.5 + uh);
            }
            return path;
        }
        layoutMaxWidth(bank, slotWidth) {
            if (bank.buttons.length == 0)
                return [[null]];
            let bx = new Array(bank.buttons.length), by = new Array(bank.buttons.length);
            let x = 0, y = 0, w = 0, h = 0;
            for (let n = 0; n < bank.buttons.length; n++) {
                w = Math.max(x + 1, w);
                h = Math.max(y + 1, h);
                bx[n] = x;
                by[n] = y;
                x++;
                if (x >= slotWidth) {
                    x = 0;
                    y++;
                }
            }
            let slot = new Array(h);
            for (let n = 0; n < h; n++)
                slot[n] = new Array(w);
            for (let n = 0; n < bank.buttons.length; n++) {
                slot[by[n]][bx[n]] = bank.buttons[n].id;
            }
            return slot;
        }
        layoutMaxHeight(bank, slotHeight, slotWidth) {
            if (bank.buttons.length == 0)
                return [[null]];
            let bx = new Array(bank.buttons.length), by = new Array(bank.buttons.length);
            let x = 0, y = 0, w = 0, h = 0;
            for (let n = 0; n < bank.buttons.length; n++) {
                w = Math.max(x + 1, w);
                h = Math.max(y + 1, h);
                bx[n] = x;
                by[n] = y;
                x++;
                if (x >= slotWidth) {
                    x = 0;
                    y++;
                }
            }
            let slot = new Array(h);
            for (let n = 0; n < h; n++)
                slot[n] = new Array(w);
            for (let n = 0; n < bank.buttons.length; n++) {
                slot[by[n]][bx[n]] = bank.buttons[n].id;
            }
            return slot;
        }
        scoreLayout(slots) {
            let score = 0;
            for (let y = 0; y < slots.length; y++)
                for (let x = 0; x < slots[y].length; x++) {
                    if (slots[y][x] == null)
                        score++;
                }
            return score;
        }
        pickButtonIndex(x, y) {
            for (let n = 0; n < this.display.length; n++) {
                let d = this.display[n];
                if (x >= d.x && y >= d.y && x < d.x + d.width && y < d.y + d.height)
                    return n;
            }
            return -1;
        }
        pickButtonID(x, y) {
            let idx = this.pickButtonIndex(x, y);
            if (idx < 0)
                return undefined;
            return this.display[idx].id;
        }
        triggerButton(id) {
            if (id == '*') {
                if (this.isRaised)
                    this.lowerBank();
                else
                    this.raiseBank();
                return;
            }
            else if (id == '!') {
                this.popBank();
                return;
            }
            let bank = this.stack[this.stack.length - 1];
            bank.hitButton(id);
        }
        mouseClick(event) {
        }
        mouseDoubleClick(event) {
            event.stopImmediatePropagation();
        }
        mouseDown(event) {
            let xy = WebMolKit.eventCoords(event, this.content);
            if (!this.withinOutline(xy[0], xy[1]))
                return;
            let id = this.pickButtonID(xy[0], xy[1]);
            if (id != this.highlightButton) {
                this.highlightButton = id;
                this.redraw();
            }
            event.stopPropagation();
        }
        mouseUp(event) {
            let xy = WebMolKit.eventCoords(event, this.content);
            if (!this.withinOutline(xy[0], xy[1]))
                return;
            let id = this.pickButtonID(xy[0], xy[1]);
            if (id != null && this.highlightButton == id) {
                this.highlightButton = undefined;
                this.triggerButton(id);
                this.delayedRedraw();
            }
            else {
                this.highlightButton = undefined;
                this.delayedRedraw();
            }
            event.stopPropagation();
        }
        mouseOver(event) {
            let xy = WebMolKit.eventCoords(event, this.content);
            if (!this.withinOutline(xy[0], xy[1]))
                return;
            event.stopPropagation();
        }
        mouseOut(event) {
            let xy = WebMolKit.eventCoords(event, this.content);
            if (!this.withinOutline(xy[0], xy[1])) {
                if (this.highlightButton != null) {
                    this.highlightButton = null;
                    this.delayedRedraw();
                }
                return;
            }
            if (this.highlightButton != null) {
                let xy = WebMolKit.eventCoords(event, this.content);
                let id = this.pickButtonID(xy[0], xy[1]);
                if (id != this.highlightButton) {
                    this.highlightButton = null;
                    this.delayedRedraw();
                }
            }
            event.stopPropagation();
        }
        mouseMove(event) {
            let xy = WebMolKit.eventCoords(event, this.content);
            if (!this.withinOutline(xy[0], xy[1]))
                return;
        }
        fixSVGFile(svg) {
            svg = svg.substring(svg.indexOf('<svg'));
            let iw = svg.indexOf('width="'), ih = svg.indexOf('height="');
            if (iw < 0 || ih < 0)
                return svg;
            let w = parseInt(svg.substring(iw + 7, svg.indexOf('"', iw + 7)));
            let h = parseInt(svg.substring(ih + 8, svg.indexOf('"', ih + 8)));
            svg = '<svg viewBox="0 0 ' + w + ' ' + h + '"' + svg.substring(svg.indexOf('>'));
            return svg;
        }
    }
    ButtonView.ACTION_ICONS = null;
    WebMolKit.ButtonView = ButtonView;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class ClipboardProxy {
        constructor() {
            this.copyEvent = null;
            this.pasteEvent = null;
        }
        install(container) { }
        uninstall() { }
        getString() { return null; }
        setString(str) { }
        canAlwaysGet() { return false; }
    }
    WebMolKit.ClipboardProxy = ClipboardProxy;
    class ClipboardProxyWeb extends ClipboardProxy {
        constructor() {
            super(...arguments);
            this.lastContent = null;
            this.busy = false;
            this.copyFunc = null;
            this.pasteFunc = null;
            this.fakeTextArea = null;
        }
        install(container) {
            if (!container)
                throw 'ClipboardProxy: need a container to install to';
            this.copyFunc = (e) => {
                if (this.busy)
                    return;
                let content = this.copyEvent();
                if (content == null)
                    return;
                if (!$.contains(document.documentElement, container[0])) {
                    this.uninstall();
                    return false;
                }
                document.removeEventListener('copy', this.copyFunc);
                this.performCopy(content);
                document.addEventListener('copy', this.copyFunc);
                e.preventDefault();
                return false;
            };
            document.addEventListener('copy', this.copyFunc);
            this.pasteFunc = (e) => {
                if (!$.contains(document.documentElement, container[0])) {
                    this.uninstall();
                    return false;
                }
                let wnd = window;
                this.lastContent = null;
                if (wnd.clipboardData && wnd.clipboardData.getData)
                    this.lastContent = wnd.clipboardData.getData('Text');
                else if (e.clipboardData && e.clipboardData.getData)
                    this.lastContent = e.clipboardData.getData('text/plain');
                this.pasteEvent(this);
                this.lastContent = null;
                e.preventDefault();
                return false;
            };
            document.addEventListener('paste', this.pasteFunc);
        }
        uninstall() {
            if (this.copyFunc) {
                document.removeEventListener('copy', this.copyFunc);
                this.copyFunc = null;
            }
            if (this.pasteFunc) {
                document.removeEventListener('paste', this.pasteFunc);
                this.pasteFunc = null;
            }
        }
        getString() {
            return this.lastContent;
        }
        setString(str) {
            this.performCopy(str);
        }
        performCopy(content) {
            if (this.fakeTextArea == null) {
                this.fakeTextArea = document.createElement('textarea');
                this.fakeTextArea.style.fontSize = '12pt';
                this.fakeTextArea.style.border = '0';
                this.fakeTextArea.style.padding = '0';
                this.fakeTextArea.style.margin = '0';
                this.fakeTextArea.style.position = 'fixed';
                this.fakeTextArea.style['left'] = '-9999px';
                this.fakeTextArea.style.top = (window.pageYOffset || document.documentElement.scrollTop) + 'px';
                this.fakeTextArea.setAttribute('readonly', '');
                document.body.appendChild(this.fakeTextArea);
            }
            this.fakeTextArea.value = content;
            this.fakeTextArea.select();
            this.busy = true;
            document.execCommand('copy');
            this.busy = false;
        }
    }
    WebMolKit.ClipboardProxyWeb = ClipboardProxyWeb;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class FusionPermutation {
        constructor() {
            this.attdist = 0;
            this.guided = false;
            this.bridged = false;
            this.scoreModifier = 0;
            this.chainSelect = 0;
        }
    }
    WebMolKit.FusionPermutation = FusionPermutation;
    class TemplateFusion {
        constructor(mol, templ, abbrev) {
            this.mol = mol;
            this.templ = templ;
            this.abbrev = abbrev;
            this.perms = [];
            this.numAttach = 0;
            this.withGuideOnly = false;
            this.guidetempl = null;
            this.guideidx = [];
            this.guideadj = [];
            this.TIME_LIMIT = 5.0;
            let artif1 = new WebMolKit.BondArtifact(mol), artif2 = new WebMolKit.BondArtifact(templ);
            artif2.harmoniseNumbering(artif1);
            artif2.rewriteMolecule();
            this.huntForGuides();
        }
        permuteNone() {
            let numAttach = 0;
            let oldmol = this.mol.clone(), newmol = this.templ.clone();
            if (oldmol.numAtoms > 0) {
                let oldbox = oldmol.boundary(), newbox = newmol.boundary();
                let dx = oldbox.maxX() + 1 - newbox.minX();
                let dy = 0.5 * (oldbox.minY() + oldbox.maxY()) - 0.5 * (newbox.minY() + newbox.maxY());
                WebMolKit.CoordUtil.translateMolecule(newmol, dx, dy);
            }
            else {
                let newbox = newmol.boundary();
                WebMolKit.CoordUtil.translateMolecule(newmol, -newbox.midX(), -newbox.midY());
            }
            let oldbox = oldmol.boundary(), newbox = newmol.boundary();
            let cx = newbox.midX(), cy = newbox.midY();
            let ROTN = [0, 30, 45, 60, 90, 120, 135, 150, 180, 210, 225, 240, 270, 300, 315, 330];
            duplicate: for (let n = 0; n < ROTN.length; n++) {
                let rotmol = newmol.clone();
                WebMolKit.CoordUtil.rotateMolecule(rotmol, -ROTN[n] * WebMolKit.DEGRAD, cx, cy);
                for (let i = 0; i < this.perms.length; i++)
                    if (WebMolKit.CoordUtil.sketchEquivalent(rotmol, this.perms[i].display))
                        continue duplicate;
                let p = new FusionPermutation();
                p.mol = oldmol.clone();
                p.mol.append(rotmol);
                p.display = rotmol;
                p.srcidx = this.sourceIndex(p.mol, oldmol);
                p.attdist = 0;
                p.guided = false;
                this.perms.push(p);
            }
        }
        permuteAtom(atom) {
            this.numAttach = 1;
            let timeStart = new Date().getTime();
            let oldmol = this.mol.clone(), newmol = this.templ.clone();
            let newperms = [];
            if (this.guidetempl != null) {
                let fliptempl = this.guidetempl.clone();
                WebMolKit.CoordUtil.mirrorImage(fliptempl);
                for (let n = 0; n < this.guideidx.length; n++) {
                    if (new Date().getTime() - timeStart > this.TIME_LIMIT * 1000)
                        break;
                    this.composeGuidedOne(newperms, oldmol, this.guidetempl, atom, this.guideidx[n]);
                    this.composeGuidedOne(newperms, oldmol, fliptempl, atom, this.guideidx[n]);
                }
            }
            if (!this.withGuideOnly) {
                let flipmol = newmol.clone();
                WebMolKit.CoordUtil.mirrorImage(flipmol);
                for (let n = 1; n <= newmol.numAtoms; n++) {
                    if (new Date().getTime() - timeStart > this.TIME_LIMIT * 1000)
                        break;
                    this.composeDirectOne(newperms, oldmol, newmol, atom, n);
                    this.composeDirectOne(newperms, oldmol, flipmol, atom, n);
                    this.composeBridge(newperms, oldmol, newmol, atom, n);
                    this.composeBridge(newperms, oldmol, flipmol, atom, n);
                }
            }
            this.affixRawPermutations(newperms);
        }
        permuteBond(a1, a2) {
            this.numAttach = 2;
            let timeStart = new Date().getTime();
            let oldmol = this.mol.clone(), newmol = this.templ.clone();
            let newperms = [];
            if (this.guidetempl != null) {
                let fliptempl = this.guidetempl.clone();
                WebMolKit.CoordUtil.mirrorImage(fliptempl);
                for (let i = 0; i < this.guideidx.length; i++) {
                    if (new Date().getTime() - timeStart > this.TIME_LIMIT * 1000)
                        break;
                    let g1 = this.guideidx[i];
                    let adj = this.guidetempl.atomAdjList(g1);
                    for (let j = 0; j < adj.length; j++) {
                        let g2 = adj[j];
                        this.composeGuidedTwo(newperms, oldmol, this.guidetempl, a1, a2, g1, g2, true);
                        this.composeGuidedTwo(newperms, oldmol, this.guidetempl, a2, a1, g1, g2, true);
                        this.composeGuidedTwo(newperms, oldmol, fliptempl, a1, a2, g1, g2, true);
                        this.composeGuidedTwo(newperms, oldmol, fliptempl, a2, a1, g1, g2, true);
                        this.composeGuidedTwo(newperms, oldmol, this.guidetempl, a1, a2, g1, g2, false);
                        this.composeGuidedTwo(newperms, oldmol, this.guidetempl, a2, a1, g1, g2, false);
                        this.composeGuidedTwo(newperms, oldmol, fliptempl, a1, a2, g1, g2, false);
                        this.composeGuidedTwo(newperms, oldmol, fliptempl, a2, a1, g1, g2, false);
                    }
                }
            }
            if (!this.withGuideOnly) {
                let flipmol = newmol.clone();
                WebMolKit.CoordUtil.mirrorImage(flipmol);
                for (let n = 1; n <= newmol.numBonds; n++) {
                    if (new Date().getTime() - timeStart > this.TIME_LIMIT * 1000)
                        break;
                    let nfr = newmol.bondFrom(n), nto = newmol.bondTo(n);
                    this.composeDirectTwo(newperms, oldmol, newmol, a1, a2, nfr, nto);
                    this.composeDirectTwo(newperms, oldmol, flipmol, a1, a2, nfr, nto);
                    this.composeDirectTwo(newperms, oldmol, newmol, a1, a2, nto, nfr);
                    this.composeDirectTwo(newperms, oldmol, flipmol, a1, a2, nto, nfr);
                }
            }
            this.affixRawPermutations(newperms);
        }
        permuteMulti(atoms) {
            this.numAttach = atoms.length;
            let timeStart = new Date().getTime();
            let oldmol = this.mol.clone(), newmol = this.templ.clone();
            let newperms = [];
            if (this.guidetempl != null) {
                let fliptempl = this.guidetempl.clone();
                WebMolKit.CoordUtil.mirrorImage(fliptempl);
                if (this.guideidx.length == atoms.length) {
                    this.composeGuidedMulti(newperms, oldmol, this.guidetempl, atoms, this.guideidx, true);
                    this.composeGuidedMulti(newperms, oldmol, fliptempl, atoms, this.guideidx, true);
                }
                if (this.guideadj.length == atoms.length) {
                    this.composeGuidedMulti(newperms, oldmol, this.guidetempl, atoms, this.guideadj, false);
                    this.composeGuidedMulti(newperms, oldmol, fliptempl, atoms, this.guideadj, false);
                }
            }
            if (!this.withGuideOnly) {
                let flipmol = newmol.clone();
                WebMolKit.CoordUtil.mirrorImage(flipmol);
                for (let n = 1; n <= newmol.numAtoms; n++) {
                    if (new Date().getTime() - timeStart > this.TIME_LIMIT * 1000)
                        break;
                    this.composeDirectMulti(newperms, oldmol, newmol, atoms, n);
                    this.composeDirectMulti(newperms, oldmol, flipmol, atoms, n);
                }
            }
            this.affixRawPermutations(newperms);
        }
        huntForGuides() {
            this.guideidx = [];
            this.guideadj = [];
            for (let n = 1; n <= this.templ.numAtoms; n++)
                if (this.templ.atomElement(n) == 'X' && this.templ.atomAdjCount(n) > 0) {
                    this.guideidx.push(n);
                    let adj = this.templ.atomAdjList(n);
                    for (let i = 0; i < adj.length; i++)
                        if (this.guideadj.indexOf(adj[i]) < 0)
                            this.guideadj.push(adj[i]);
                }
            if (this.guideidx.length > 0) {
                this.guidetempl = this.templ.clone();
                for (let n = this.guideidx.length - 1; n >= 0; n--)
                    this.templ.deleteAtomAndBonds(this.guideidx[n]);
            }
        }
        composeDirectOne(list, oldmol, newmol, o1, n1) {
            let otheta = WebMolKit.SketchUtil.primeDirections(oldmol, o1);
            let ntheta = WebMolKit.SketchUtil.primeDirections(newmol, n1);
            let ocurrent = WebMolKit.CoordUtil.atomBondAngles(oldmol, o1);
            let ncurrent = WebMolKit.CoordUtil.atomBondAngles(newmol, n1);
            let theta1 = [], theta2 = [], scoreMod = [];
            for (let i = 0; i < ocurrent.length; i++)
                for (let j = 0; j < ntheta.length; j++) {
                    theta1.push(ocurrent[i]);
                    theta2.push(ntheta[j]);
                    scoreMod.push(-51);
                }
            for (let i = 0; i < otheta.length; i++)
                for (let j = 0; j < ncurrent.length; j++) {
                    theta1.push(otheta[i]);
                    theta2.push(ncurrent[j]);
                    scoreMod.push(0);
                }
            for (let i = 0; i < otheta.length; i++)
                for (let j = 0; j < ntheta.length; j++) {
                    theta1.push(otheta[i]);
                    theta2.push(ntheta[j]);
                    scoreMod.push(0);
                }
            let bfs = WebMolKit.Graph.fromMolecule(newmol).calculateBFS(0);
            let ox = oldmol.atomX(o1), oy = oldmol.atomY(o1), nx = newmol.atomX(n1), ny = newmol.atomY(n1);
            for (let n = 0; n < theta1.length; n++) {
                let dth = WebMolKit.angleDiff(theta1[n], theta2[n]);
                let frag = newmol.clone();
                WebMolKit.CoordUtil.translateMolecule(frag, ox - nx, oy - ny);
                WebMolKit.CoordUtil.rotateMolecule(frag, dth, ox, oy);
                let pmol = oldmol.clone();
                let osz = pmol.numAtoms;
                pmol.append(frag);
                let srcidx = this.sourceIndex(pmol, oldmol);
                WebMolKit.SketchUtil.mergeFragmentsMask(pmol, this.asMask(srcidx));
                if (pmol.numAtoms == osz)
                    continue;
                let p = new FusionPermutation();
                p.mol = pmol;
                p.display = frag;
                p.srcidx = srcidx;
                p.molidx = [o1];
                p.temidx = [n1];
                p.attdist = bfs[n1 - 1];
                p.guided = false;
                p.scoreModifier = scoreMod[n];
                this.removeExtraGuides(p, oldmol);
                list.push(p);
            }
        }
        composeDirectTwo(list, oldmol, newmol, o1, o2, n1, n2) {
            let oth = Math.atan2(oldmol.atomY(o2) - oldmol.atomY(o1), oldmol.atomX(o2) - oldmol.atomX(o1));
            let nth = Math.atan2(newmol.atomY(n2) - newmol.atomY(n1), newmol.atomX(n2) - newmol.atomX(n1));
            let cx = 0.5 * (oldmol.atomX(o1) + oldmol.atomX(o2)), cy = 0.5 * (oldmol.atomY(o1) + oldmol.atomY(o2));
            let frag = newmol.clone();
            WebMolKit.CoordUtil.translateMolecule(frag, cx - 0.5 * (newmol.atomX(n1) + newmol.atomX(n2)), cy - 0.5 * (newmol.atomY(n1) + newmol.atomY(n2)));
            WebMolKit.CoordUtil.rotateMolecule(frag, oth - nth, cx, cy);
            frag.setAtomPos(n1, oldmol.atomX(o1), oldmol.atomY(o1));
            frag.setAtomPos(n2, oldmol.atomX(o2), oldmol.atomY(o2));
            let pmol = oldmol.clone();
            let osz = pmol.numAtoms;
            pmol.append(frag);
            let srcidx = this.sourceIndex(pmol, oldmol);
            WebMolKit.SketchUtil.mergeFragmentsMask(pmol, this.asMask(srcidx));
            if (pmol.numAtoms == osz)
                return;
            let bfs = WebMolKit.Graph.fromMolecule(newmol).calculateBFS(0);
            let p = new FusionPermutation();
            p.mol = pmol;
            p.display = frag;
            p.srcidx = srcidx;
            p.molidx = [o1, o2];
            p.temidx = [n1, n2];
            p.attdist = Math.min(bfs[n1 - 1], bfs[n2 - 1]);
            p.guided = false;
            this.removeExtraGuides(p, oldmol);
            list.push(p);
        }
        composeDirectMulti(list, oldmol, newmol, oidx, n1) {
            let frag = newmol.clone();
            let x0 = oldmol.atomX(oidx[0]), y0 = oldmol.atomY(oidx[0]);
            WebMolKit.CoordUtil.translateMolecule(frag, x0 - frag.atomX(n1), y0 - frag.atomY(n1));
            let ox = oldmol.atomX(oidx[1]) - x0, oy = oldmol.atomY(oidx[1]) - y0;
            let otheta = Math.atan2(oy, ox), orad = WebMolKit.norm_xy(ox, oy);
            let bfs = WebMolKit.Graph.fromMolecule(newmol).calculateBFS(1);
            let nidx = [];
            for (let n2 = 1; n2 <= frag.numAtoms; n2++)
                if (n1 != n2) {
                    let nx = frag.atomX(n2) - frag.atomX(n1), ny = frag.atomY(n2) - frag.atomY(n1), nrad = WebMolKit.norm_xy(nx, ny);
                    if (Math.abs(nrad - orad) > 0.1)
                        continue;
                    let ntheta = Math.atan2(ny, nx);
                    WebMolKit.CoordUtil.rotateMolecule(frag, otheta - ntheta, x0, y0);
                    nidx = [n1, n2];
                    for (let i = 2; i < oidx.length; i++) {
                        let hit = false;
                        for (let j = 1; j <= frag.numAtoms; j++)
                            if (nidx.indexOf(j) < 0)
                                if (WebMolKit.norm_xy(oldmol.atomX(oidx[i]) - frag.atomX(j), oldmol.atomY(oidx[i]) - frag.atomY(j)) < 0.1 * 0.1) {
                                    hit = true;
                                    nidx.push(j);
                                    break;
                                }
                        if (!hit)
                            break;
                    }
                    if (nidx.length < oidx.length)
                        continue;
                    let lowbfs = bfs.length;
                    for (let n = 0; n < nidx.length; n++)
                        lowbfs = Math.min(lowbfs, bfs[nidx[n] - 1]);
                    let dx = 0, dy = 0;
                    for (let n = 0; n < oidx.length; n++) {
                        dx += oldmol.atomX(oidx[n]) - frag.atomX(nidx[n]);
                        dy += oldmol.atomY(oidx[n]) - frag.atomY(nidx[n]);
                    }
                    let invsz = 1.0 / oidx.length;
                    dx *= invsz;
                    dy *= invsz;
                    WebMolKit.CoordUtil.translateMolecule(frag, dx, dy);
                    let pmol = oldmol.clone();
                    let osz = pmol.numAtoms;
                    pmol.append(frag);
                    let srcidx = this.sourceIndex(pmol, oldmol);
                    for (let n = 0; n < nidx.length; n++) {
                        let x = pmol.atomX(oidx[n]), y = pmol.atomY(oidx[n]);
                        pmol.setAtomPos(osz + nidx[n], x, y);
                    }
                    WebMolKit.SketchUtil.mergeFragmentsMask(pmol, this.asMask(srcidx));
                    if (pmol.numAtoms == osz)
                        continue;
                    let p = new FusionPermutation();
                    p.mol = pmol;
                    p.display = frag.clone();
                    p.srcidx = srcidx;
                    p.molidx = oidx.slice(0);
                    p.temidx = nidx.slice(0);
                    p.attdist = Math.min(bfs[n1 - 1], bfs[n2 - 1]);
                    p.guided = false;
                    this.removeExtraGuides(p, oldmol);
                    list.push(p);
                }
        }
        composeBridge(list, oldmol, newmol, o1, n1) {
            let busy1 = oldmol.atomRingBlock(o1) != 0 || oldmol.atomAdjCount(o1) >= 3;
            let busy2 = newmol.atomRingBlock(n1) != 0 || newmol.atomAdjCount(n1) >= 3;
            if (!busy1 || !busy2)
                return;
            let otheta = WebMolKit.SketchUtil.primeDirections(oldmol, o1);
            let ntheta = WebMolKit.SketchUtil.primeDirections(newmol, n1);
            let bfs = WebMolKit.Graph.fromMolecule(newmol).calculateBFS(0);
            for (let i = 0; i < otheta.length; i++)
                for (let j = 0; j < ntheta.length; j++) {
                    let ox = oldmol.atomX(o1), oy = oldmol.atomY(o1), nx = newmol.atomX(n1), ny = newmol.atomY(n1);
                    let dx = WebMolKit.Molecule.IDEALBOND * Math.cos(otheta[i]), dy = WebMolKit.Molecule.IDEALBOND * Math.sin(otheta[i]);
                    let dth = WebMolKit.angleDiff(otheta[i], Math.PI + ntheta[j]);
                    let frag = newmol.clone();
                    WebMolKit.CoordUtil.translateMolecule(frag, ox - nx + dx, oy - ny + dy);
                    WebMolKit.CoordUtil.rotateMolecule(frag, dth, ox + dx, oy + dy);
                    let pmol = oldmol.clone();
                    let att = pmol.numAtoms + n1, osz = pmol.numAtoms;
                    pmol.append(frag);
                    let srcidx = this.sourceIndex(pmol, oldmol);
                    pmol.addBond(o1, att, 1);
                    att = frag.addAtom('C', ox, oy);
                    frag.addBond(n1, att, 1);
                    WebMolKit.SketchUtil.mergeFragmentsMask(pmol, this.asMask(srcidx));
                    if (pmol.numAtoms == osz)
                        continue;
                    let p = new FusionPermutation();
                    p.mol = pmol;
                    p.display = frag;
                    p.srcidx = srcidx;
                    p.molidx = [o1];
                    p.temidx = [att];
                    p.attdist = bfs[n1 - 1];
                    p.bridged = true;
                    p.guided = false;
                    this.removeExtraGuides(p, oldmol);
                    list.push(p);
                }
        }
        composeGuidedOne(list, oldmol, newmol, oidx, gidx) {
            if (newmol.atomAdjCount(gidx) == 0)
                return;
            let otheta = WebMolKit.SketchUtil.primeDirections(oldmol, oidx);
            if (newmol.atomAdjCount(gidx) > 1 && oldmol.atomAdjCount(oidx) > 0) {
                let ox = 0, oy = 0;
                let adj = oldmol.atomAdjList(oidx);
                for (let n = 0; n < adj.length; n++) {
                    ox += oldmol.atomX(adj[n]) - oldmol.atomX(oidx);
                    oy += oldmol.atomY(adj[n]) - oldmol.atomY(oidx);
                }
                let ang = Math.atan2(oy, ox);
                let unique = true;
                for (let n = 0; n < otheta.length; n++)
                    if (Math.abs(WebMolKit.angleDiff(ang, otheta[n])) < 3 * WebMolKit.RADDEG) {
                        unique = false;
                        break;
                    }
                if (unique)
                    otheta.push(ang);
            }
            let gx = newmol.atomX(gidx), gy = newmol.atomY(gidx);
            let dx = 0, dy = 0;
            let adj = newmol.atomAdjList(gidx);
            for (let n = 0; n < adj.length; n++) {
                dx += newmol.atomX(adj[n]) - gx;
                dy += newmol.atomY(adj[n]) - gy;
            }
            dx /= adj.length;
            dy /= adj.length;
            let ntheta = Math.atan2(dy, dx);
            let homoPenalty = 0;
            if (adj.length == 1) {
                let oel = oldmol.atomElement(oidx), nel = newmol.atomElement(adj[0]);
                if (oel != 'C' && oel == nel)
                    homoPenalty = 1;
            }
            for (let n = 0; n < otheta.length; n++) {
                let frag = newmol.clone();
                if (this.guideidx.length == 2) {
                    for (let i = 1; i <= frag.numAtoms; i++)
                        if (i != gidx && frag.atomElement(i) == 'X') {
                            frag.setAtomElement(i, TemplateFusion.RESERVED_GUIDESYMBOL);
                            break;
                        }
                }
                WebMolKit.CoordUtil.rotateMolecule(frag, otheta[n] - ntheta, gx, gy);
                WebMolKit.CoordUtil.translateMolecule(frag, oldmol.atomX(oidx) - gx, oldmol.atomY(oidx) - gy);
                let pmol = oldmol.clone();
                let osz = pmol.numAtoms;
                pmol.append(frag);
                let srcidx = this.sourceIndex(pmol, oldmol);
                WebMolKit.SketchUtil.mergeFragmentsMask(pmol, this.asMask(srcidx));
                if (pmol.numAtoms == osz)
                    continue;
                let sel = 0;
                for (let i = 1; i <= pmol.numAtoms; i++)
                    if (pmol.atomElement(i) == TemplateFusion.RESERVED_GUIDESYMBOL) {
                        let padj = pmol.atomAdjList(i);
                        if (padj.length == 1) {
                            sel = padj[0];
                            if (sel > i)
                                sel--;
                        }
                        pmol.deleteAtomAndBonds(i);
                        srcidx.splice(i - 1, 1);
                        break;
                    }
                let p = new FusionPermutation();
                p.mol = pmol;
                p.display = frag;
                p.srcidx = srcidx;
                p.molidx = [oidx];
                p.temidx = [gidx];
                p.attdist = 0;
                p.guided = true;
                p.scoreModifier = homoPenalty;
                p.chainSelect = sel;
                this.removeExtraGuides(p, oldmol);
                list.push(p);
            }
        }
        composeGuidedTwo(list, oldmol, newmol, o1, o2, gidx, nidx, snapToGuide) {
            let ox = oldmol.atomX(o1), oy = oldmol.atomY(o1);
            let gx = newmol.atomX(gidx), gy = newmol.atomY(gidx);
            let nx = newmol.atomX(nidx), ny = newmol.atomY(nidx);
            let otheta = Math.atan2(oldmol.atomY(o2) - oy, oldmol.atomX(o2) - ox);
            let gtheta = Math.atan2(ny - gy, nx - gx);
            let isGuideOnTerminal = oldmol.atomAdjCount(o1) == 1;
            let pmol = oldmol.clone(), frag = newmol.clone();
            WebMolKit.CoordUtil.rotateMolecule(frag, otheta - gtheta, gx, gy);
            if (snapToGuide) {
                WebMolKit.CoordUtil.translateMolecule(frag, ox - gx, oy - gy);
                pmol.setAtomPos(o2, frag.atomX(nidx), frag.atomY(nidx));
            }
            else {
                WebMolKit.CoordUtil.translateMolecule(frag, oldmol.atomX(o2) - frag.atomX(nidx), oldmol.atomY(o2) - frag.atomY(nidx));
                frag.setAtomPos(gidx, ox, oy);
            }
            let osz = pmol.numAtoms;
            pmol.append(frag);
            let srcidx = this.sourceIndex(pmol, oldmol);
            WebMolKit.SketchUtil.mergeFragmentsMask(pmol, this.asMask(srcidx));
            if (pmol.numAtoms == osz)
                return;
            let p = new FusionPermutation();
            p.mol = pmol;
            p.display = frag;
            p.srcidx = srcidx;
            p.molidx = [o1, o2];
            p.temidx = [gidx, nidx];
            p.attdist = isGuideOnTerminal ? 1 : 0;
            p.guided = true;
            this.removeExtraGuides(p, oldmol);
            list.push(p);
        }
        composeGuidedMulti(list, oldmol, newmol, oidx, gidx, nudgenew) {
            let cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0;
            for (let n = 0; n < oidx.length; n++) {
                cx1 += oldmol.atomX(oidx[n]);
                cy1 += oldmol.atomY(oidx[n]);
            }
            for (let n = 0; n < gidx.length; n++) {
                cx2 += newmol.atomX(gidx[n]);
                cy2 += newmol.atomY(gidx[n]);
            }
            cx1 /= oidx.length;
            cy1 /= oidx.length;
            cx2 /= gidx.length;
            cy2 /= gidx.length;
            let osz = oldmol.numAtoms;
            for (let i = 0; i < oidx.length; i++)
                for (let j = 0; j < gidx.length; j++) {
                    let pmol = oldmol.clone(), frag = newmol.clone();
                    let th1 = Math.atan2(pmol.atomY(oidx[i]) - cy1, pmol.atomX(oidx[i]) - cx1);
                    let th2 = Math.atan2(frag.atomY(gidx[j]) - cy2, frag.atomX(gidx[j]) - cx2);
                    WebMolKit.CoordUtil.rotateMolecule(frag, th1 - th2, cx2, cy2);
                    WebMolKit.CoordUtil.translateMolecule(frag, cx1 - cx2, cy1 - cy2);
                    pmol.append(frag);
                    let srcidx = this.sourceIndex(pmol, oldmol);
                    let midx = WebMolKit.Vec.numberArray(0, gidx.length), tidx = gidx.slice(0);
                    WebMolKit.Vec.sort(tidx);
                    let mask = WebMolKit.Vec.booleanArray(false, osz);
                    for (let g = tidx.length - 1; g >= 0; g--) {
                        let gatom = tidx[g] + osz;
                        let closest = 0, closeDSQ = 0;
                        for (let n = 0; n < oidx.length; n++)
                            if (!mask[oidx[n] - 1]) {
                                let dx = pmol.atomX(oidx[n]) - pmol.atomX(gatom), dy = pmol.atomY(oidx[n]) - pmol.atomY(gatom);
                                let dsq = WebMolKit.norm_xy(dx, dy);
                                if (closest == 0 || dsq < closeDSQ) {
                                    closest = oidx[n];
                                    closeDSQ = dsq;
                                }
                            }
                        if (!nudgenew) {
                            let dsq = WebMolKit.norm_xy(pmol.atomX(gatom) - pmol.atomX(closest), pmol.atomY(gatom) - pmol.atomY(closest));
                            if (dsq > 0.1 * 0.1) {
                                let num = frag.addAtom('C', pmol.atomX(closest), pmol.atomY(closest));
                                frag.addBond(num, tidx[g], 0);
                            }
                            pmol.setAtomPos(closest, pmol.atomX(gatom), pmol.atomY(gatom));
                        }
                        midx[g] = closest;
                        mask[closest - 1] = true;
                        let adj = pmol.atomAdjList(gatom);
                        for (let n = 0; n < adj.length; n++) {
                            let b = pmol.findBond(gatom, adj[n]);
                            pmol.addBond(closest, adj[n], pmol.bondOrder(b), pmol.bondType(b));
                        }
                        pmol.deleteAtomAndBonds(gatom);
                        srcidx.splice(gatom - 1, 1);
                        frag.setAtomPos(tidx[g], pmol.atomX(closest), pmol.atomY(closest));
                    }
                    for (let n = pmol.numAtoms; n > osz; n--)
                        if (pmol.atomElement(n) == 'X') {
                            pmol.deleteAtomAndBonds(n);
                            srcidx.splice(n - 1, 1);
                            for (let k = 0; k < tidx.length; k++)
                                if (n < tidx[k])
                                    tidx[k]--;
                        }
                    for (let n = frag.numAtoms; n >= 1; n--)
                        if (frag.atomElement(n) == 'X') {
                            frag.setAtomElement(n, 'C');
                        }
                    let p = new FusionPermutation();
                    p.mol = pmol;
                    p.display = frag;
                    p.srcidx = srcidx;
                    p.molidx = midx;
                    p.temidx = tidx;
                    p.attdist = 0;
                    p.guided = true;
                    this.removeExtraGuides(p, oldmol);
                    list.push(p);
                }
        }
        affixRawPermutations(list) {
            let npsz = list.length;
            if (npsz == 0)
                return;
            let umask = WebMolKit.Vec.booleanArray(true, npsz);
            for (let i = 0; i < npsz - 1; i++)
                if (umask[i]) {
                    let p1 = list[i];
                    for (let j = i + 1; j < npsz; j++)
                        if (umask[j]) {
                            let p2 = list[j];
                            if (WebMolKit.CoordUtil.sketchEquivalent(p1.mol, p2.mol)) {
                                if (p1.scoreModifier + p1.attdist > p2.scoreModifier + p2.attdist) {
                                    list[i] = p2;
                                    list[j] = p1;
                                }
                                umask[j] = false;
                            }
                        }
                }
            let score = WebMolKit.Vec.numberArray(0, npsz);
            let numKeep = 0;
            for (let n = 0; n < npsz; n++) {
                if (umask[n]) {
                    score[n] = this.scorePermutation(list[n]);
                    if (score[n] < 1000)
                        numKeep++;
                }
                else
                    score[n] = 0;
            }
            if (numKeep > 0)
                for (let n = 0; n < npsz; n++)
                    if (umask[n] && score[n] >= 1000)
                        umask[n] = false;
            let uscore = [], uidx = [];
            for (let n = 0; n < npsz; n++)
                if (umask[n]) {
                    uscore.push(score[n]);
                    uidx.push(n);
                }
            let sidx = WebMolKit.Vec.idxSort(uscore);
            for (let n = 0; n < sidx.length; n++) {
                let p = list[uidx[sidx[n]]];
                if (p.guided) {
                    this.perms.push(p);
                }
            }
            for (let n = 0; n < sidx.length; n++) {
                let p = list[uidx[sidx[n]]];
                if (!p.guided) {
                    this.perms.push(p);
                }
            }
        }
        removeExtraGuides(perm, oldmol) {
            WebMolKit.MolUtil.removeDuplicateBonds(perm.mol);
            for (let n = perm.temidx.length - 1; n >= 0; n--) {
                let el = perm.display.atomElement(perm.temidx[n]);
                if (el != 'X' && el != TemplateFusion.RESERVED_GUIDESYMBOL)
                    continue;
                perm.molidx.splice(n, 1);
                perm.temidx.splice(n, 1);
            }
            for (let n = perm.display.numAtoms; n >= 1; n--) {
                let el = perm.display.atomElement(n);
                if (el != 'X' && el != TemplateFusion.RESERVED_GUIDESYMBOL)
                    continue;
                let a = WebMolKit.CoordUtil.atomAtPoint(oldmol, perm.display.atomX(n), perm.display.atomY(n));
                if (a > 0)
                    perm.display.setAtomElement(n, 'C');
                else {
                    perm.display.deleteAtomAndBonds(n);
                    for (let i = 0; i < perm.temidx.length; i++)
                        if (perm.temidx[i] > n)
                            perm.temidx[i]--;
                }
            }
        }
        scorePermutation(perm) {
            let mol = this.mol, tmol = perm.display, tunion = perm.mol;
            let score = 0.2 * perm.attdist + perm.scoreModifier;
            score += WebMolKit.CoordUtil.congestionMolecule(tunion, 1e-3);
            score -= tunion.numAtoms;
            let sz1 = mol.numAtoms, sz2 = tmol.numAtoms;
            let mx1 = [], my1 = [], mx2 = [], my2 = [];
            for (let n = 0; n < sz1; n++) {
                mx1.push(mol.atomX(n + 1));
                my1.push(mol.atomY(n + 1));
            }
            for (let n = 0; n < sz2; n++) {
                mx2.push(tmol.atomX(n + 1));
                my2.push(tmol.atomY(n + 1));
            }
            for (let i = 0; i < sz1; i++)
                for (let j = 0; j < sz2; j++) {
                    if (WebMolKit.norm_xy(mx1[i] - mx2[j], my1[i] - my2[j]) > WebMolKit.CoordUtil.OVERLAP_THRESHOLD_SQ)
                        continue;
                    let contained = false;
                    for (let k = 0; k < perm.molidx.length; k++)
                        if (perm.molidx[k] == i + 1 && perm.temidx[k] == j + 1) {
                            contained = true;
                            break;
                        }
                    if (contained)
                        continue;
                    score += 100;
                }
            if (!perm.guided)
                for (let n = 0; n < perm.molidx.length; n++) {
                    let el = mol.atomElement(perm.molidx[n]);
                    if (el == 'C' || el == 'O' || el == 'S' || el == 'N' || el == 'P')
                        continue;
                    let adj1 = mol.atomAdjList(perm.molidx[n]), adj2 = tmol.atomAdjList(perm.temidx[n]);
                    if (adj1.length + adj2.length >= 4)
                        continue;
                    for (let i = 0; i < adj1.length; i++)
                        for (let j = 0; j < adj2.length; j++) {
                            let ai = adj1[i], aj = adj2[j];
                            let bo1 = mol.bondOrder(mol.findBond(perm.molidx[n], ai));
                            let bo2 = mol.bondOrder(mol.findBond(perm.temidx[n], aj));
                            let wantTheta = 0;
                            if ((bo1 == 1 && bo2 == 1) || (bo1 == 1 && bo2 == 2) || (bo1 == 2 && bo2 == 1))
                                wantTheta = 120;
                            else if ((bo1 == 2 && bo2 == 2) || (bo1 == 1 && bo2 == 3) || (bo1 == 3 && bo2 == 1))
                                wantTheta = 180;
                            else
                                continue;
                            let dx1 = mx1[ai - 1] - mx1[perm.molidx[n] - 1];
                            let dy1 = my1[ai - 1] - my1[perm.molidx[n] - 1];
                            let dx2 = mx2[aj - 1] - mx2[perm.temidx[n] - 1];
                            let dy2 = my2[aj - 1] - my2[perm.temidx[n] - 1];
                            let theta = Math.abs(WebMolKit.angleDiff(Math.atan2(dy1, dx1), Math.atan2(dy2, dx2))) * WebMolKit.RADDEG;
                            if (Math.abs(theta - wantTheta) > 5)
                                score += 50;
                        }
                }
            for (let n = 1; n <= tunion.numAtoms; n++)
                if (tunion.atomElement(n) == 'C' || tunion.atomElement(n) == 'N') {
                    let adjb = tunion.atomAdjBonds(n);
                    let totalBO = 0;
                    for (let i = 0; i < adjb.length; i++) {
                        let bo = tunion.bondOrder(adjb[i]);
                        totalBO += bo;
                        if (bo == 0) {
                            totalBO = 0;
                            break;
                        }
                    }
                    if (totalBO > 4)
                        score += 1000;
                }
            if (perm.molidx.length >= 2) {
                let mmask = WebMolKit.Vec.booleanArray(false, sz1);
                for (let n = 0; n < perm.molidx.length; n++)
                    mmask[perm.molidx[n] - 1] = true;
                for (let n = 1; n <= mol.numBonds; n++) {
                    let bfr = mol.bondFrom(n), bto = mol.bondTo(n);
                    if (!mmask[bfr - 1] || !mmask[bto - 1])
                        continue;
                    let tfr = perm.molidx.indexOf(bfr), tto = perm.molidx.indexOf(bto);
                    let tn = tmol.findBond(perm.temidx[tfr], perm.temidx[tto]);
                    if (tn == 0)
                        continue;
                    if (mol.bondOrder(n) != tmol.bondOrder(tn))
                        score += 1;
                }
            }
            return score;
        }
        sourceIndex(xmol, wmol) {
            let idx = WebMolKit.Vec.numberArray(0, xmol.numAtoms);
            for (let n = wmol.numAtoms; n >= 1; n--)
                idx[n - 1] = n;
            return idx;
        }
        asMask(imask) {
            let ret = WebMolKit.Vec.booleanArray(false, imask.length);
            for (let n = 0; n < imask.length; n++)
                ret[n] = imask[n] != 0;
            return ret;
        }
    }
    TemplateFusion.RESERVED_GUIDESYMBOL = 'XXX';
    WebMolKit.TemplateFusion = TemplateFusion;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let ActivityType;
    (function (ActivityType) {
        ActivityType[ActivityType["Delete"] = 1] = "Delete";
        ActivityType[ActivityType["Clear"] = 2] = "Clear";
        ActivityType[ActivityType["Copy"] = 3] = "Copy";
        ActivityType[ActivityType["Cut"] = 4] = "Cut";
        ActivityType[ActivityType["SelectAll"] = 5] = "SelectAll";
        ActivityType[ActivityType["SelectNone"] = 6] = "SelectNone";
        ActivityType[ActivityType["SelectPrevComp"] = 7] = "SelectPrevComp";
        ActivityType[ActivityType["SelectNextComp"] = 8] = "SelectNextComp";
        ActivityType[ActivityType["SelectSide"] = 9] = "SelectSide";
        ActivityType[ActivityType["SelectGrow"] = 10] = "SelectGrow";
        ActivityType[ActivityType["SelectShrink"] = 11] = "SelectShrink";
        ActivityType[ActivityType["SelectChain"] = 12] = "SelectChain";
        ActivityType[ActivityType["SelectSmRing"] = 13] = "SelectSmRing";
        ActivityType[ActivityType["SelectRingBlk"] = 14] = "SelectRingBlk";
        ActivityType[ActivityType["SelectCurElement"] = 15] = "SelectCurElement";
        ActivityType[ActivityType["SelectToggle"] = 16] = "SelectToggle";
        ActivityType[ActivityType["SelectUnCurrent"] = 17] = "SelectUnCurrent";
        ActivityType[ActivityType["Element"] = 18] = "Element";
        ActivityType[ActivityType["AtomPos"] = 19] = "AtomPos";
        ActivityType[ActivityType["Charge"] = 20] = "Charge";
        ActivityType[ActivityType["Connect"] = 21] = "Connect";
        ActivityType[ActivityType["Disconnect"] = 22] = "Disconnect";
        ActivityType[ActivityType["BondOrder"] = 23] = "BondOrder";
        ActivityType[ActivityType["BondType"] = 24] = "BondType";
        ActivityType[ActivityType["BondGeom"] = 25] = "BondGeom";
        ActivityType[ActivityType["BondAtom"] = 26] = "BondAtom";
        ActivityType[ActivityType["BondSwitch"] = 27] = "BondSwitch";
        ActivityType[ActivityType["BondAddTwo"] = 28] = "BondAddTwo";
        ActivityType[ActivityType["BondInsert"] = 29] = "BondInsert";
        ActivityType[ActivityType["Join"] = 30] = "Join";
        ActivityType[ActivityType["Nudge"] = 31] = "Nudge";
        ActivityType[ActivityType["NudgeLots"] = 32] = "NudgeLots";
        ActivityType[ActivityType["NudgeFar"] = 33] = "NudgeFar";
        ActivityType[ActivityType["Flip"] = 34] = "Flip";
        ActivityType[ActivityType["Scale"] = 35] = "Scale";
        ActivityType[ActivityType["Rotate"] = 36] = "Rotate";
        ActivityType[ActivityType["Move"] = 37] = "Move";
        ActivityType[ActivityType["Ring"] = 38] = "Ring";
        ActivityType[ActivityType["TemplateFusion"] = 39] = "TemplateFusion";
        ActivityType[ActivityType["AbbrevTempl"] = 40] = "AbbrevTempl";
        ActivityType[ActivityType["AbbrevGroup"] = 41] = "AbbrevGroup";
        ActivityType[ActivityType["AbbrevFormula"] = 42] = "AbbrevFormula";
        ActivityType[ActivityType["AbbrevClear"] = 43] = "AbbrevClear";
        ActivityType[ActivityType["AbbrevExpand"] = 44] = "AbbrevExpand";
        ActivityType[ActivityType["BondArtifactPath"] = 45] = "BondArtifactPath";
        ActivityType[ActivityType["BondArtifactRing"] = 46] = "BondArtifactRing";
        ActivityType[ActivityType["BondArtifactArene"] = 47] = "BondArtifactArene";
        ActivityType[ActivityType["BondArtifactClear"] = 48] = "BondArtifactClear";
    })(ActivityType = WebMolKit.ActivityType || (WebMolKit.ActivityType = {}));
    class MoleculeActivity {
        constructor(owner, activity, param, override) {
            this.owner = owner;
            this.activity = activity;
            this.param = param;
            this.input = owner.getState();
            this.output =
                {
                    'mol': null,
                    'currentAtom': -1,
                    'currentBond': -1,
                    'selectedMask': null
                };
            let altInput = this.input;
            for (let k in override)
                altInput[k] = override[k];
            let na = this.input.mol.numAtoms;
            if (this.input.selectedMask == null)
                this.input.selectedMask = WebMolKit.Vec.booleanArray(false, na);
            while (this.input.selectedMask.length < na)
                this.input.selectedMask.push(false);
            this.subjectMask = this.input.selectedMask.slice(0);
            this.subjectLength = WebMolKit.Vec.maskCount(this.subjectMask);
            this.subjectIndex = [];
            this.hasSelected = this.subjectLength > 0;
            if (this.subjectLength == 0) {
                if (this.input.currentAtom > 0) {
                    this.subjectLength = 1;
                    this.subjectMask[this.input.currentAtom - 1] = true;
                    this.subjectIndex = [this.input.currentAtom];
                }
                else if (this.input.currentBond > 0) {
                    let bfr = this.input.mol.bondFrom(this.input.currentBond), bto = this.input.mol.bondTo(this.input.currentBond);
                    let b1 = Math.min(bfr, bto), b2 = Math.max(bfr, bto);
                    this.subjectLength = 2;
                    this.subjectMask[b1 - 1] = true;
                    this.subjectMask[b2 - 1] = true;
                    this.subjectIndex = [b1, b2];
                }
            }
            else {
                this.subjectIndex = WebMolKit.Vec.maskIdx(this.subjectMask);
                WebMolKit.Vec.addTo(this.subjectIndex, 1);
            }
        }
        evaluate() {
            return true;
        }
        execute() {
            let param = this.param;
            if (this.activity == ActivityType.Delete) {
                this.execDelete();
                this.finish();
            }
            else if (this.activity == ActivityType.Clear) {
                this.execClear();
                this.finish();
            }
            else if (this.activity == ActivityType.Copy) {
                this.execCopy(false);
                this.finish();
            }
            else if (this.activity == ActivityType.Cut) {
                this.execCopy(true);
                this.finish();
            }
            else if (this.activity == ActivityType.SelectAll) {
                this.execSelectAll(true);
                this.finish();
            }
            else if (this.activity == ActivityType.SelectNone) {
                this.execSelectAll(false);
                this.finish();
            }
            else if (this.activity == ActivityType.SelectPrevComp) {
                this.execSelectComp(-1);
                this.finish();
            }
            else if (this.activity == ActivityType.SelectNextComp) {
                this.execSelectComp(1);
                this.finish();
            }
            else if (this.activity == ActivityType.SelectSide) {
                this.execSelectSide();
                this.finish();
            }
            else if (this.activity == ActivityType.SelectGrow) {
                this.execSelectGrow();
                this.finish();
            }
            else if (this.activity == ActivityType.SelectShrink) {
                this.execSelectShrink();
                this.finish();
            }
            else if (this.activity == ActivityType.SelectChain) {
                this.execSelectChain();
                this.finish();
            }
            else if (this.activity == ActivityType.SelectSmRing) {
                this.execSelectSmRing();
                this.finish();
            }
            else if (this.activity == ActivityType.SelectRingBlk) {
                this.execSelectRingBlk();
                this.finish();
            }
            else if (this.activity == ActivityType.SelectCurElement) {
                this.execSelectCurElement();
                this.finish();
            }
            else if (this.activity == ActivityType.SelectToggle) {
                this.execSelectToggle();
                this.finish();
            }
            else if (this.activity == ActivityType.SelectUnCurrent) {
                this.execSelectUnCurrent();
                this.finish();
            }
            else if (this.activity == ActivityType.Element) {
                this.execElement(param.element, param.positionX, param.positionY, param.keepAbbrev);
                this.finish();
            }
            else if (this.activity == ActivityType.Charge) {
                this.execCharge(param.delta);
                this.finish();
            }
            else if (this.activity == ActivityType.Connect) {
                this.execConnect(1, WebMolKit.Molecule.BONDTYPE_NORMAL);
                this.finish();
            }
            else if (this.activity == ActivityType.Disconnect) {
                this.execDisconnect();
                this.finish();
            }
            else if (this.activity == ActivityType.BondOrder) {
                this.execBond(param.order, WebMolKit.Molecule.BONDTYPE_NORMAL);
                this.finish();
            }
            else if (this.activity == ActivityType.BondType) {
                this.execBond(1, param.type);
                this.finish();
            }
            else if (this.activity == ActivityType.BondGeom) {
                this.execBondGeom(param.geom);
                this.finish();
            }
            else if (this.activity == ActivityType.BondAtom) {
                this.execBondAtom(param.order, param.type, param.element, param.x1, param.y1, param.x2, param.y2);
                this.finish();
            }
            else if (this.activity == ActivityType.BondSwitch) {
                this.execBondSwitch();
                this.finish();
            }
            else if (this.activity == ActivityType.BondAddTwo) {
                this.execBondAddTwo();
                this.finish();
            }
            else if (this.activity == ActivityType.BondInsert) {
            }
            else if (this.activity == ActivityType.Join) {
                this.execJoin();
                this.finish();
            }
            else if (this.activity == ActivityType.Nudge) {
                this.execNudge(param.dir, 0.1);
                this.finish();
            }
            else if (this.activity == ActivityType.NudgeLots) {
                this.execNudge(param.dir, 1);
                this.finish();
            }
            else if (this.activity == ActivityType.NudgeFar) {
                this.execNudgeFar(param.dir);
                this.finish();
            }
            else if (this.activity == ActivityType.Flip) {
                this.execFlip(param.axis);
                this.finish();
            }
            else if (this.activity == ActivityType.Scale) {
                this.execScale(param.mag);
                this.finish();
            }
            else if (this.activity == ActivityType.Rotate) {
                this.execRotate(param.theta, param.centreX, param.centreY);
                this.finish();
            }
            else if (this.activity == ActivityType.Move) {
                this.execMove(param.refAtom, param.deltaX, param.deltaY);
                this.finish();
            }
            else if (this.activity == ActivityType.Ring) {
                this.execRing(param.ringX, param.ringY, param.aromatic);
                this.finish();
            }
            else if (this.activity == ActivityType.TemplateFusion) {
                this.execTemplateFusion(WebMolKit.Molecule.fromString(param.fragNative));
                this.owner.setPermutations(this.output.permutations);
            }
            else if (this.activity == ActivityType.AbbrevTempl) {
                this.execAbbrevTempl();
                this.finish();
            }
            else if (this.activity == ActivityType.AbbrevGroup) {
                this.execAbbrevGroup();
                this.finish();
            }
            else if (this.activity == ActivityType.AbbrevFormula) {
                this.execAbbrevFormula();
                this.finish();
            }
            else if (this.activity == ActivityType.AbbrevClear) {
                this.execAbbrevClear();
                this.finish();
            }
            else if (this.activity == ActivityType.AbbrevExpand) {
                this.execAbbrevExpand();
                this.finish();
            }
            else if (this.activity == ActivityType.BondArtifactPath || this.activity == ActivityType.BondArtifactRing ||
                this.activity == ActivityType.BondArtifactArene || this.activity == ActivityType.BondArtifactClear) {
                this.execBondArtifact(this.activity);
                this.finish();
            }
        }
        finish() {
            if (this.output.mol != null || this.output.currentAtom >= 0 || this.output.currentBond >= 0 || this.output.selectedMask != null) {
                this.owner.setState(this.output, true);
                if (this.errmsg != null)
                    this.owner.showMessage(this.errmsg, false);
            }
            else {
                if (this.errmsg != null)
                    this.owner.showMessage(this.errmsg, true);
            }
        }
        execDelete() {
            if (!this.requireSubject())
                return;
            let mol = this.input.mol;
            this.output.mol = mol.clone();
            this.zapSubject();
            if (this.input.currentBond > 0 && !this.hasSelected) {
                this.output.mol.deleteBond(this.input.currentBond);
                this.input.currentBond = 0;
                return;
            }
            if (this.subjectLength == 1 && this.subjectIndex[0] == this.input.currentAtom) {
                let adj = mol.atomAdjList(this.input.currentAtom);
                if (adj.length == 1) {
                    this.output.currentAtom = adj[0];
                    if (this.output.currentAtom > this.input.currentAtom)
                        this.output.currentAtom--;
                }
            }
            for (let n = this.subjectLength - 1; n >= 0; n--)
                this.output.mol.deleteAtomAndBonds(this.subjectIndex[n]);
        }
        execCopy(withCut) {
            let mol = this.input.mol;
            if (this.subjectLength > 0)
                mol = WebMolKit.MolUtil.subgraphWithAttachments(mol, this.subjectMask);
            this.owner.performCopy(mol);
            if (withCut) {
                this.zapSubject();
                this.output.mol = WebMolKit.MolUtil.subgraphMask(this.input.mol, WebMolKit.Vec.notMask(this.subjectMask));
            }
        }
        execClear() {
            this.output.mol = new WebMolKit.Molecule();
            this.zapSubject();
        }
        execSelectAll(all) {
            let same = true;
            for (let n = 0; n < this.input.mol.numAtoms; n++)
                if (this.subjectMask[n] != all) {
                    same = false;
                    break;
                }
            if (same) {
                this.errmsg = all ? "All atoms already selected." : "All atoms already deselected.";
                return;
            }
            this.output.selectedMask = WebMolKit.Vec.booleanArray(all, this.input.mol.numAtoms);
        }
        execSelectComp(dir) {
            let cclist = WebMolKit.MolUtil.componentList(this.input.mol);
            if (cclist.length == 1 && this.hasSelected && this.subjectLength == this.input.mol.numAtoms) {
                this.errmsg = 'All atoms already selected.';
                return;
            }
            let sel = this.pickSelectedGroup(cclist, dir);
            this.output.selectedMask = WebMolKit.Vec.booleanArray(false, this.input.mol.numAtoms);
            for (let n = 0; n < cclist[sel].length; n++)
                this.output.selectedMask[cclist[sel][n] - 1] = true;
        }
        execSelectSide() {
            if (!this.requireCurrent())
                return;
            let mol = this.input.mol, currentAtom = this.input.currentAtom, currentBond = this.input.currentBond;
            if (currentAtom > 0 && mol.atomAdjCount(currentAtom) == 0) {
                this.errmsg = 'Current atom has no neighbours.';
                return;
            }
            if (currentBond > 0 && mol.atomAdjCount(mol.bondFrom(currentBond)) == 1 && mol.atomAdjCount(mol.bondTo(currentBond)) == 1) {
                this.errmsg = 'Current bond has no neighbours.';
                return;
            }
            let sides = currentAtom > 0 ? WebMolKit.MolUtil.getAtomSides(mol, currentAtom) : WebMolKit.MolUtil.getBondSides(mol, currentBond);
            let sel = this.pickSelectedGroup(sides, 1);
            this.output.selectedMask = WebMolKit.Vec.booleanArray(false, mol.numAtoms);
            for (let n = 0; n < sides[sel].length; n++)
                this.output.selectedMask[sides[sel][n] - 1] = true;
        }
        execSelectGrow() {
            if (!this.requireSubject())
                return;
            let mol = this.input.mol, currentAtom = this.input.currentAtom, currentBond = this.input.currentBond;
            this.output.selectedMask = this.input.selectedMask.slice(0);
            if (!this.hasSelected) {
                if (currentAtom > 0) {
                    this.output.selectedMask[currentAtom - 1] = true;
                }
                else {
                    this.output.selectedMask[mol.bondFrom(currentBond) - 1] = true;
                    this.output.selectedMask[mol.bondTo(currentBond) - 1] = true;
                }
            }
            else {
                for (let n = 1; n <= mol.numBonds; n++) {
                    let bfr = mol.bondFrom(n) - 1, bto = mol.bondTo(n) - 1;
                    if (this.input.selectedMask[bfr] && !this.input.selectedMask[bto])
                        this.output.selectedMask[bto] = true;
                    else if (this.input.selectedMask && !this.input.selectedMask[bfr])
                        this.output.selectedMask[bfr] = true;
                }
            }
        }
        execSelectShrink() {
            if (!this.requireSelected())
                return;
            let mol = this.input.mol;
            let count = WebMolKit.Vec.numberArray(0, mol.numAtoms);
            for (let n = 1; n <= mol.numBonds; n++) {
                let bfr = mol.bondFrom(n) - 1, bto = mol.bondTo(n) - 1;
                if (!this.input.selectedMask[bfr] || !this.input.selectedMask[bto])
                    continue;
                count[bfr]++;
                count[bto]++;
            }
            this.output.selectedMask = this.input.selectedMask.slice(0);
            for (let n = 0; n < mol.numAtoms; n++)
                this.output.selectedMask[n] = this.input.selectedMask[n] && count[n] >= 2;
        }
        execSelectChain() {
            if (!this.requireSubject())
                return;
            let mol = this.input.mol;
            this.output.selectedMask = this.input.selectedMask.slice(0);
            for (let n = 1; n <= mol.numBonds; n++) {
                let bfr = mol.bondFrom(n) - 1, bto = mol.bondTo(n) - 1;
                if (this.input.selectedMask[bfr] && !this.input.selectedMask[bto] && mol.atomRingBlock(bto + 1) == 0)
                    this.output.selectedMask[bto] = true;
                else if (this.input.selectedMask[bto] && !this.input.selectedMask[bfr] && mol.atomRingBlock(bfr + 1) == 0)
                    this.output.selectedMask[bfr] = true;
            }
        }
        execSelectSmRing() {
            if (!this.requireSubject())
                return;
            this.output.selectedMask = this.input.selectedMask.slice(0);
            for (let r = 3; r <= 8; r++) {
                let rings = this.input.mol.findRingsOfSize(r);
                for (let i = 0; i < rings.length; i++) {
                    let any = false;
                    for (let j = 0; j < rings[i].length; j++)
                        if (this.subjectMask[rings[i][j] - 1]) {
                            any = true;
                            break;
                        }
                    if (any)
                        for (let j = 0; j < rings[i].length; j++)
                            this.output.selectedMask[rings[i][j] - 1] = true;
                }
            }
        }
        execSelectRingBlk() {
            if (!this.requireSubject())
                return;
            let mol = this.input.mol;
            this.output.selectedMask = this.input.selectedMask.slice(0);
            let maxRB = 0;
            for (let n = 1; n <= mol.numAtoms; n++)
                maxRB = Math.max(maxRB, mol.atomRingBlock(n));
            if (maxRB == 0)
                return;
            let gotRB = WebMolKit.Vec.booleanArray(false, maxRB);
            for (let n = 1; n <= mol.numAtoms; n++) {
                let rb = mol.atomRingBlock(n);
                if (rb > 0 && this.subjectMask[n - 1])
                    gotRB[rb - 1] = true;
            }
            for (let n = 1; n <= mol.numAtoms; n++) {
                let rb = mol.atomRingBlock(n);
                if (rb > 0 && gotRB[rb - 1])
                    this.output.selectedMask[n - 1] = true;
            }
        }
        execSelectCurElement() {
            if (!this.requireCurrent())
                return;
            let mol = this.input.mol;
            this.output.selectedMask = this.input.selectedMask.slice(0);
            let el1 = '', el2 = '';
            if (this.input.currentAtom > 0) {
                el1 = mol.atomElement(this.input.currentAtom);
            }
            else {
                el1 = mol.atomElement(mol.bondFrom(this.input.currentBond));
                el2 = mol.atomElement(mol.bondTo(this.input.currentBond));
            }
            for (let n = 1; n <= mol.numAtoms; n++)
                if (mol.atomElement(n) == el1 || mol.atomElement(n) == el2)
                    this.output.selectedMask[n - 1] = true;
        }
        execSelectToggle() {
            if (!this.requireCurrent())
                return;
            this.output.selectedMask = this.input.selectedMask.slice(0);
            if (this.input.currentAtom > 0) {
                this.output.selectedMask[this.input.currentAtom - 1] = !this.output.selectedMask[this.input.currentAtom - 1];
            }
            else {
                let bfr = this.input.mol.bondFrom(this.input.currentBond), bto = this.input.mol.bondTo(this.input.currentBond);
                let sel = !this.input.selectedMask[bfr - 1] || !this.input.selectedMask[bto - 1];
                this.output.selectedMask[bfr - 1] = sel;
                this.output.selectedMask[bto - 1] = sel;
            }
        }
        execSelectUnCurrent() {
            if (!this.requireCurrent())
                return;
            this.output.selectedMask = this.input.selectedMask.slice(0);
            if (this.input.currentAtom > 0) {
                this.output.selectedMask[this.input.currentAtom - 1] = false;
            }
            else {
                this.output.selectedMask[this.input.mol.bondFrom(this.input.currentBond) - 1] = false;
                this.output.selectedMask[this.input.mol.bondTo(this.input.currentBond) - 1] = false;
            }
        }
        execElement(element, positionX, positionY, keepAbbrev) {
            if (this.subjectLength > 0) {
                let anyChange = false;
                for (let n = 0; n < this.subjectLength; n++)
                    if (this.input.mol.atomElement(this.subjectIndex[n]) != element) {
                        anyChange = true;
                        break;
                    }
                if (!anyChange) {
                    this.errmsg = 'Elements not changed.';
                    return;
                }
            }
            this.output.mol = this.input.mol.clone();
            if (this.subjectLength == 0) {
                if (positionX != null && positionY != null)
                    this.output.mol.addAtom(element, positionX, positionY);
                else
                    WebMolKit.SketchUtil.placeNewAtom(this.output.mol, element);
            }
            else {
                for (let n = 0; n < this.subjectLength; n++) {
                    if (keepAbbrev)
                        this.output.mol.setAtomElement(this.subjectIndex[n], element);
                    else
                        WebMolKit.MolUtil.setAtomElement(this.output.mol, this.subjectIndex[n], element);
                }
            }
        }
        execCharge(delta) {
            if (!this.requireSubject())
                return;
            this.output.mol = this.input.mol.clone();
            for (let n = 0; n < this.subjectLength; n++) {
                let chg = Math.max(-20, Math.min(20, this.input.mol.atomCharge(this.subjectIndex[n]) + delta));
                this.output.mol.setAtomCharge(this.subjectIndex[n], chg);
            }
        }
        execConnect(order, type) {
            if (!this.requireSubject())
                return;
            let conn = WebMolKit.SketchUtil.pickAtomsToConnect(this.input.mol, this.subjectIndex);
            if (conn == null) {
                this.errmsg = 'Subject atoms contain no bonds suitable for connection.';
                return;
            }
            this.output.mol = this.input.mol.clone();
            for (let n = 0; n < conn.length; n += 2)
                WebMolKit.MolUtil.addBond(this.output.mol, conn[n], conn[n + 1], order, type);
        }
        execDisconnect() {
            let zap = [];
            let mol = this.input.mol;
            if (this.hasSelected) {
                for (let n = 1; n <= mol.numBonds; n++)
                    if (this.subjectMask[mol.bondFrom(n) - 1] && this.subjectMask[mol.bondTo(n) - 1])
                        zap.push(n);
            }
            else if (this.input.currentAtom > 0) {
                for (let a of mol.atomAdjBonds(this.input.currentAtom))
                    zap.push(a);
            }
            else if (this.input.currentBond > 0) {
                zap.push(this.input.currentBond);
            }
            if (zap.length == 0) {
                this.errmsg = 'Subject atoms contain no bonds suitable for disconnection.';
                return;
            }
            let killmask = WebMolKit.Vec.booleanArray(false, mol.numBonds);
            for (let b of zap)
                killmask[b - 1] = true;
            this.output.mol = this.input.mol.clone();
            for (let n = mol.numBonds; n >= 1; n--)
                if (killmask[n - 1])
                    this.output.mol.deleteBond(n);
        }
        execBond(order, type) {
            if (!this.requireSubject())
                return;
            if (this.subjectLength == 1) {
                this.performBondNew(this.subjectIndex[0], order, type);
                return;
            }
            let ccmol = WebMolKit.MolUtil.subgraphMask(this.input.mol, this.subjectMask);
            let oneComp = true;
            for (let n = ccmol.numAtoms; n >= 1; n--)
                if (ccmol.atomConnComp(n) != 1) {
                    oneComp = false;
                    break;
                }
            if (oneComp)
                this.performBondChange(order, type);
            else
                this.execConnect(order, type);
        }
        execBondGeom(geom) {
            let bond = this.subjectLength == 2 ? this.input.mol.findBond(this.subjectIndex[0], this.subjectIndex[1]) : 0;
            if (this.subjectLength == 0 || this.subjectLength > 2 || (this.subjectLength == 2 && bond == 0)) {
                this.errmsg = 'The subject must be a single atom or bond.';
                return;
            }
            if (this.subjectLength == 1)
                this.performBondGeomAtom(geom, this.subjectIndex[0]);
            else
                this.performBondGeomBond(geom, bond);
        }
        execBondAtom(order, type, element, x1, y1, x2, y2) {
            let mol = this.input.mol;
            let a1 = WebMolKit.CoordUtil.atomAtPoint(mol, x1, y1, 0.01), a2 = WebMolKit.CoordUtil.atomAtPoint(mol, x2, y2, 0.01);
            if (a1 > 0 && a2 > 0 && mol.findBond(a1, a2) > 0)
                return;
            this.output.mol = mol.clone();
            if (a1 == 0)
                a1 = this.output.mol.addAtom('C', x1, y1);
            if (a2 == 0)
                a2 = this.output.mol.addAtom(element, x2, y2);
            this.output.mol.addBond(a1, a2, order, type);
        }
        execBondSwitch() {
            if (!this.requireSubject())
                return;
            let mol = this.input.mol;
            let src = 0, dst = [];
            if (this.subjectLength == 1) {
                src = this.subjectIndex[0];
                let adj = mol.atomAdjList(src);
                for (let n = 0; n < adj.length; n++)
                    if (mol.atomAdjCount(adj[n]) == 1)
                        dst.push(adj[n]);
            }
            else if (this.subjectLength == 2 && mol.findBond(this.subjectIndex[0], this.subjectIndex[1]) > 0) {
                let ac1 = mol.atomAdjCount(this.subjectIndex[0]), ac2 = mol.atomAdjCount(this.subjectIndex[1]);
                if (ac1 > 1 && ac2 == 1) {
                    src = this.subjectIndex[0];
                    dst.push(this.subjectIndex[1]);
                }
                else if (ac1 == 1 && ac2 > 1) {
                    src = this.subjectIndex[1];
                    dst.push(this.subjectIndex[0]);
                }
            }
            if (src == 0 || dst.length == 0) {
                this.errmsg = 'Subject must include a terminal bond.';
                return;
            }
            let geoms = WebMolKit.SketchUtil.guessAtomGeometry(mol, src, 1);
            if (geoms.length == 0) {
                this.errmsg = 'No alternative geometries identified.';
                return;
            }
            this.output.mol = WebMolKit.SketchUtil.switchAtomGeometry(mol, src, dst, geoms);
            if (this.output.mol == null) {
                this.errmsg = 'No alternative geometries identified.';
            }
        }
        execBondAddTwo() {
            if (this.subjectLength != 1) {
                this.errmsg = 'Subject must be a single atom.';
                return;
            }
            let atom = this.subjectIndex[0];
            if (this.input.mol.atomAdjCount(atom) < 2) {
                this.errmsg = 'Subject atom must already have at least 2 bonds.';
                return;
            }
            var ang = WebMolKit.SketchUtil.calculateNewBondAngles(this.input.mol, atom, 1);
            if (ang.length == 0)
                ang = WebMolKit.SketchUtil.exitVectors(this.input.mol, atom);
            if (ang.length == 0) {
                this.errmsg = 'Could not find a suitable geometry for new substituents.';
                return;
            }
            var baseAng = ang[0];
            let cx = this.input.mol.atomX(atom), cy = this.input.mol.atomY(atom);
            if (ang.length > 1) {
                let best = 0;
                for (let n = 0; n < ang.length; n++) {
                    let x = cx + WebMolKit.Molecule.IDEALBOND * Math.cos(ang[n]);
                    let y = cy + WebMolKit.Molecule.IDEALBOND * Math.sin(ang[n]);
                    let score = WebMolKit.CoordUtil.congestionPoint(this.input.mol, x, y);
                    if (n == 0 || score < best) {
                        best = score;
                        baseAng = ang[n];
                    }
                }
            }
            let ang1 = baseAng - 30.0 * WebMolKit.DEGRAD, ang2 = baseAng + 30.0 * WebMolKit.DEGRAD;
            let mol = this.input.mol.clone();
            let a1 = mol.addAtom('C', cx + WebMolKit.Molecule.IDEALBOND * Math.cos(ang1), cy + WebMolKit.Molecule.IDEALBOND * Math.sin(ang1));
            let a2 = mol.addAtom('C', cx + WebMolKit.Molecule.IDEALBOND * Math.cos(ang2), cy + WebMolKit.Molecule.IDEALBOND * Math.sin(ang2));
            mol.addBond(atom, a1, 1);
            mol.addBond(atom, a2, 1);
            this.output.mol = mol;
        }
        execJoin() {
            if (!this.requireSubject())
                return;
            this.output.mol = WebMolKit.SketchUtil.joinOverlappingAtoms(this.input.mol, this.subjectMask);
            if (this.output.mol == null) {
                this.errmsg = 'Subject contains no overlapping atoms.';
            }
            else {
                this.zapSubject();
            }
        }
        execNudge(dir, extent) {
            if (!this.requireSubject())
                return;
            let dx = extent * (dir == 'left' ? -1 : dir == 'right' ? 1 : 0);
            let dy = extent * (dir == 'down' ? -1 : dir == 'up' ? 1 : 0);
            this.output.mol = this.input.mol.clone();
            for (let n = 0; n < this.subjectLength; n++) {
                let x = this.output.mol.atomX(this.subjectIndex[n]), y = this.output.mol.atomY(this.subjectIndex[n]);
                this.output.mol.setAtomPos(this.subjectIndex[n], x + dx, y + dy);
            }
        }
        execNudgeFar(dir) {
            if (!this.requireSubject())
                return;
            if (this.subjectLength == this.input.mol.numAtoms) {
                this.errmsg = 'Cannot apply to entire molecule.';
                return;
            }
            let dx = dir == 'left' ? -1 : dir == 'right' ? 1 : 0;
            let dy = dir == 'down' ? -1 : dir == 'up' ? 1 : 0;
            this.output.mol = WebMolKit.SketchUtil.moveToEdge(this.input.mol, this.subjectMask, dx, dy);
            if (this.output.mol == null) {
                this.execNudge(dir, 1);
            }
        }
        execFlip(axis) {
            if (this.input.mol.numAtoms < 2) {
                this.errmsg = 'At least 2 atoms are required.';
                return;
            }
            let isVertical = axis == 'ver';
            let cx = 0, cy = 0;
            let mask = this.subjectMask, mol = this.input.mol;
            if (this.input.currentAtom > 0) {
                cx = mol.atomX(this.input.currentAtom);
                cy = mol.atomY(this.input.currentAtom);
                if (!this.hasSelected) {
                    mask = WebMolKit.Vec.booleanArray(false, mol.numAtoms);
                    let cc = mol.atomConnComp(this.input.currentAtom);
                    for (let n = 1; n <= mol.numAtoms; n++)
                        mask[n - 1] = mol.atomConnComp(n) == cc;
                }
            }
            else if (this.input.currentBond > 0) {
                let bfr = mol.bondFrom(this.input.currentBond), bto = mol.bondTo(this.input.currentBond);
                cx = 0.5 * (mol.atomX(bfr) + mol.atomX(bto));
                cy = 0.5 * (mol.atomY(bfr) + mol.atomY(bto));
                if (!this.hasSelected) {
                    mask = WebMolKit.Vec.booleanArray(false, mol.numAtoms);
                    let cc = mol.atomConnComp(bfr);
                    for (let n = 1; n <= mol.numAtoms; n++)
                        mask[n - 1] = mol.atomConnComp(n) == cc;
                }
            }
            else if (this.subjectLength == 0) {
                let box = mol.boundary();
                cx = 0.5 * (box.minX() + box.maxX());
                cy = 0.5 * (box.minY() + box.maxY());
                mask = WebMolKit.Vec.booleanArray(true, mol.numAtoms);
            }
            else {
                for (let n = 0; n < this.subjectLength; n++) {
                    cx += mol.atomX(this.subjectIndex[n]);
                    cy += mol.atomY(this.subjectIndex[n]);
                }
                let invSz = 1.0 / this.subjectLength;
                cx *= invSz;
                cy *= invSz;
            }
            this.output.mol = mol.clone();
            for (let n = 1; n <= mol.numAtoms; n++)
                if (mask[n - 1]) {
                    if (!isVertical)
                        this.output.mol.setAtomX(n, 2 * cx - this.output.mol.atomX(n));
                    else
                        this.output.mol.setAtomY(n, 2 * cy - this.output.mol.atomY(n));
                }
        }
        execScale(mag) {
            if (this.input.mol.numAtoms < 2) {
                this.errmsg = 'At least 2 atoms are required.';
                return;
            }
            let mol = this.input.mol;
            let b;
            if (this.subjectLength == 2 && (b = mol.findBond(this.subjectIndex[0], this.subjectIndex[1])) > 0 && !mol.bondInRing(b)) {
                let a1 = this.subjectIndex[0], a2 = this.subjectIndex[1];
                let ccmol = mol.clone();
                ccmol.deleteBond(b);
                let idx1 = [], idx2 = [];
                for (let n = 1; n <= ccmol.numAtoms; n++) {
                    if (ccmol.atomConnComp(n) == ccmol.atomConnComp(a1))
                        idx1.push(n);
                    else if (ccmol.atomConnComp(n) == ccmol.atomConnComp(a2))
                        idx2.push(n);
                }
                let dx = (mol.atomX(a2) - mol.atomX(a1)) * (mag - 1);
                let dy = (mol.atomY(a2) - mol.atomY(a1)) * (mag - 1);
                if (idx1.length == idx2.length) {
                    dx *= 0.5;
                    dy *= 0.5;
                }
                this.output.mol = mol.clone();
                if (idx1.length <= idx2.length)
                    for (let n = 0; n < idx1.length; n++) {
                        let a = idx1[n];
                        this.output.mol.setAtomPos(a, this.output.mol.atomX(a) - dx, this.output.mol.atomY(a) - dy);
                    }
                if (idx2.length <= idx1.length)
                    for (let n = 0; n < idx2.length; n++) {
                        let a = idx2[n];
                        this.output.mol.setAtomPos(a, this.output.mol.atomX(a) + dx, this.output.mol.atomY(a) + dy);
                    }
                return;
            }
            let cx = 0, cy = 0;
            if (this.input.currentAtom > 0) {
                cx = mol.atomX(this.input.currentAtom);
                cy = mol.atomY(this.input.currentAtom);
            }
            else if (this.input.currentBond > 0) {
                let bfr = mol.bondFrom(this.input.currentBond), bto = mol.bondTo(this.input.currentBond);
                cx = 0.5 * (mol.atomX(bfr) + mol.atomX(bto));
                cy = 0.5 * (mol.atomY(bfr) + mol.atomY(bto));
            }
            else {
                for (let n = 0; n < this.subjectLength; n++) {
                    cx += mol.atomX(this.subjectIndex[n]);
                    cy += mol.atomY(this.subjectIndex[n]);
                }
                let invSz = 1.0 / this.subjectLength;
                cx *= invSz;
                cy *= invSz;
            }
            this.output.mol = mol.clone();
            for (let n = 0; n < this.subjectLength; n++) {
                let x = this.output.mol.atomX(this.subjectIndex[n]);
                let y = this.output.mol.atomY(this.subjectIndex[n]);
                this.output.mol.setAtomPos(this.subjectIndex[n], (x - cx) * mag + cx, (y - cy) * mag + cy);
            }
        }
        execRotate(theta, centreX, centreY) {
            theta *= WebMolKit.DEGRAD;
            let mol = this.input.mol;
            if (centreX != null && centreY != null) {
                this.output.mol = mol.clone();
                let mask = this.subjectLength == 0 ? WebMolKit.Vec.booleanArray(true, mol.numAtoms) : this.subjectMask;
                WebMolKit.CoordUtil.rotateAtoms(this.output.mol, mask, centreX, centreY, theta);
                return;
            }
            if (mol.numAtoms < 2) {
                this.errmsg = 'At least 2 atoms are required.';
                return;
            }
            let cx = 0, cy = 0;
            let mask = this.subjectMask;
            if (this.input.currentAtom > 0) {
                cx = mol.atomX(this.input.currentAtom);
                cy = mol.atomY(this.input.currentAtom);
                if (!this.hasSelected) {
                    mask = WebMolKit.Vec.booleanArray(false, mol.numAtoms);
                    let cc = mol.atomConnComp(this.input.currentAtom);
                    for (let n = 1; n <= mol.numAtoms; n++)
                        mask[n - 1] = mol.atomConnComp(n) == cc;
                }
            }
            else if (this.input.currentBond > 0) {
                let bfr = mol.bondFrom(this.input.currentBond), bto = mol.bondTo(this.input.currentBond);
                cx = 0.5 * (mol.atomX(bfr) + mol.atomX(bto));
                cy = 0.5 * (mol.atomY(bfr) + mol.atomY(bto));
                if (!this.hasSelected) {
                    mask = WebMolKit.Vec.booleanArray(false, mol.numAtoms);
                    let cc = mol.atomConnComp(bfr);
                    for (let n = 1; n <= mol.numAtoms; n++)
                        mask[n - 1] = mol.atomConnComp(n) == cc;
                }
            }
            else if (this.subjectLength == 0) {
                let box = mol.boundary();
                cx = 0.5 * (box.minX() + box.maxX());
                cy = 0.5 * (box.minY() + box.maxY());
                mask = WebMolKit.Vec.booleanArray(true, mol.numAtoms);
            }
            else {
                for (let n = 0; n < this.subjectLength; n++) {
                    cx += mol.atomX(this.subjectIndex[n]);
                    cy += mol.atomY(this.subjectIndex[n]);
                }
                let invSz = 1.0 / this.subjectLength;
                cx *= invSz;
                cy *= invSz;
            }
            this.output.mol = mol.clone();
            WebMolKit.CoordUtil.rotateAtoms(this.output.mol, mask, cx, cy, theta);
        }
        execMove(refAtom, deltaX, deltaY) {
            let subj = this.subjectIndex;
            if (WebMolKit.Vec.arrayLength(subj) == 0)
                subj = [refAtom];
            this.output.mol = this.input.mol.clone();
            for (let a of subj)
                this.output.mol.setAtomPos(a, this.output.mol.atomX(a) + deltaX, this.output.mol.atomY(a) + deltaY);
        }
        execRing(ringX, ringY, aromatic) {
            let rsz = ringX.length;
            let atoms = WebMolKit.Vec.numberArray(0, rsz), bonds = WebMolKit.Vec.numberArray(0, rsz);
            let outmol = this.input.mol.clone();
            for (let n = 0; n < rsz; n++) {
                atoms[n] = WebMolKit.CoordUtil.atomAtPoint(outmol, ringX[n], ringY[n]);
                if (atoms[n] == 0)
                    atoms[n] = outmol.addAtom('C', ringX[n], ringY[n]);
            }
            for (let n = 0; n < rsz; n++) {
                let nn = n < rsz - 1 ? n + 1 : 0;
                bonds[n] = outmol.findBond(atoms[n], atoms[nn]);
                if (bonds[n] == 0)
                    bonds[n] = outmol.addBond(atoms[n], atoms[nn], 1);
            }
            if (aromatic) {
                let valence = WebMolKit.Vec.numberArray(0, rsz);
                let pi = WebMolKit.Vec.booleanArray(false, rsz);
                for (let n = 0; n < rsz; n++) {
                    valence[n] = WebMolKit.Chemistry.ELEMENT_BONDING[outmol.atomicNumber(atoms[n])] + outmol.atomCharge(atoms[n]);
                    if (outmol.atomHExplicit(atoms[n]) != WebMolKit.Molecule.HEXPLICIT_UNKNOWN)
                        valence[n] -= outmol.atomHExplicit(atoms[n]);
                    for (let b of outmol.atomAdjBonds(atoms[n]))
                        valence[n] -= outmol.bondOrder(b);
                    if (outmol.bondOrder(bonds[n]) >= 2) {
                        pi[n] = true;
                        if (n < rsz - 1) {
                            pi[n] = true;
                            n++;
                        }
                        else
                            pi[0] = true;
                    }
                }
                for (let n = 0; n < rsz; n++) {
                    let nn = n < rsz - 1 ? n + 1 : 0;
                    if (pi[n] || pi[nn])
                        continue;
                    if (valence[n] > 0 && valence[nn] > 0) {
                        outmol.setBondOrder(bonds[n], 2);
                        pi[n] = true;
                        pi[nn] = true;
                        valence[n]--;
                        valence[nn]--;
                    }
                }
            }
            this.output.mol = outmol;
        }
        execTemplateFusion(frag) {
            let mol = this.input.mol;
            let fusion = new WebMolKit.TemplateFusion(mol, frag, '');
            if (this.subjectLength == 0)
                fusion.permuteNone();
            else if (this.subjectLength == 1)
                fusion.permuteAtom(this.subjectIndex[0]);
            else if (this.subjectLength == 2 && mol.findBond(this.subjectIndex[0], this.subjectIndex[1]) > 0)
                fusion.permuteBond(this.subjectIndex[0], this.subjectIndex[1]);
            else
                fusion.permuteMulti(this.subjectIndex);
            let permutations = [];
            for (let perm of fusion.perms) {
                let obj = {};
                obj['mol'] = perm.mol.toString();
                obj['display'] = perm.display.toString();
                obj['molidx'] = perm.molidx;
                obj['temidx'] = perm.temidx;
                obj['srcidx'] = perm.srcidx;
                permutations.push(obj);
            }
            this.output.permutations = permutations;
        }
        execAbbrevTempl() {
        }
        execAbbrevGroup() {
            if (!this.requireSubject())
                return;
            if (!this.checkAbbreviationReady())
                return;
            let mol = WebMolKit.MolUtil.convertToAbbrev(this.input.mol, WebMolKit.Vec.notMask(this.subjectMask), '?');
            if (mol == null) {
                this.errmsg = 'Inline abbreviations must be terminal with exactly one attachment point.';
                return;
            }
            this.output.mol = mol;
            this.zapSubject();
            this.output.currentAtom = mol.numAtoms;
        }
        execAbbrevFormula() {
            if (!this.requireSubject())
                return;
            if (!this.checkAbbreviationReady())
                return;
            let fixed = this.input.mol.clone();
            for (let n = 1; n <= fixed.numAtoms; n++)
                fixed.setAtomHExplicit(n, fixed.atomHydrogens(n));
            let abv = WebMolKit.MolUtil.subgraphMask(fixed, this.subjectMask);
            let formula = WebMolKit.MolUtil.molecularFormula(abv, true);
            let mol = WebMolKit.MolUtil.convertToAbbrev(this.input.mol, WebMolKit.Vec.notMask(this.subjectMask), formula);
            if (mol == null) {
                this.errmsg = 'Inline abbreviations must be terminal with exactly one attachment point.';
                return;
            }
            this.output.mol = mol;
            this.zapSubject();
            this.output.currentAtom = mol.numAtoms;
        }
        execAbbrevClear() {
            let idx = [];
            for (let n of this.subjectIndex)
                if (WebMolKit.MolUtil.hasAbbrev(this.input.mol, n))
                    idx.push(n);
            if (idx.length == 0) {
                this.errmsg = 'No abbreviations to clear.';
                return;
            }
            let mol = this.input.mol.clone();
            for (let n of idx)
                WebMolKit.MolUtil.clearAbbrev(mol, n);
            this.output.mol = mol;
        }
        execAbbrevExpand() {
            let idx = [];
            for (let n of this.subjectIndex)
                if (WebMolKit.MolUtil.hasAbbrev(this.input.mol, n))
                    idx.push(n);
            if (idx.length == 0) {
                this.errmsg = 'No abbreviations to expand.';
                return;
            }
            let mol = this.input.mol.clone();
            for (let n of idx)
                WebMolKit.MolUtil.expandOneAbbrev(mol, n, true);
            this.output.mol = mol;
        }
        execBondArtifact(activity) {
            if (!this.requireAtoms() || !this.requireSubject())
                return;
            let artif = new WebMolKit.BondArtifact(this.input.mol.clone());
            var subject = this.subjectIndex.slice(0), curAtom = this.input.currentAtom;
            if (curAtom > 0 && subject.indexOf(curAtom) < 0)
                subject.push(curAtom);
            if (activity == ActivityType.BondArtifactPath) {
                if (!artif.createPath(subject)) {
                    this.errmsg = "Path artifact not suitable.";
                    return;
                }
            }
            else if (activity == ActivityType.BondArtifactRing) {
                if (!artif.createRing(subject)) {
                    this.errmsg = "Ring artifact not suitable.";
                    return;
                }
            }
            else if (activity == ActivityType.BondArtifactArene) {
                if (!artif.createArene(subject)) {
                    this.errmsg = "Arene artifact not suitable.";
                    return;
                }
            }
            else if (activity == ActivityType.BondArtifactClear) {
                if (!artif.removeArtifact(subject)) {
                    this.errmsg = "No artifact removed.";
                    return;
                }
            }
            artif.rewriteMolecule();
            this.output.mol = artif.mol;
        }
        requireSubject() {
            if (this.subjectLength == 0)
                this.errmsg = 'Subject required: current atom/bond or selected atoms.';
            return this.subjectLength > 0;
        }
        requireAtoms() {
            if (this.input.mol.numAtoms == 0)
                this.errmsg = 'There are no atoms.';
            return this.input.mol.numAtoms > 0;
        }
        requireCurrent() {
            if (this.input.currentAtom == 0 && this.input.currentBond == 0) {
                this.errmsg = 'There must be a current atom or bond.';
                return false;
            }
            return true;
        }
        requireSelected() {
            if (!this.hasSelected)
                this.errmsg = 'No atoms are selected.';
            return this.hasSelected;
        }
        pickSelectedGroup(groups, dir) {
            if (this.subjectLength == 0)
                return 0;
            for (let i = 0; i < groups.length; i++) {
                let g = groups[i];
                let all = true;
                for (let j = 0; j < g.length; j++)
                    if (!this.subjectMask[g[j] - 1]) {
                        all = false;
                        break;
                    }
                if (all) {
                    i += dir;
                    return i < 0 ? i + groups.length : i >= groups.length ? i - groups.length : i;
                }
            }
            for (let i = 0; i < groups.length; i++) {
                let g = groups[i];
                for (let j = 0; j < g.length; j++)
                    if (this.subjectMask[g[j] - 1])
                        return i;
            }
            return 0;
        }
        zapSubject() {
            this.output.currentAtom = 0;
            this.output.currentBond = 0;
            this.output.selectedMask = WebMolKit.Vec.booleanArray(false, this.input.mol.numAtoms);
        }
        performBondNew(atom, order, type) {
            let mol = this.input.mol;
            let ang = WebMolKit.SketchUtil.calculateNewBondAngles(mol, atom, order);
            if (ang.length == 0)
                ang = WebMolKit.SketchUtil.exitVectors(mol, atom);
            if (ang.length == 0) {
                this.errmsg = 'Could not find a suitable geometry for a new substituent.';
                return;
            }
            let bx = 0, by = 0, best = 0;
            for (let n = 0; n < ang.length; n++) {
                let x = mol.atomX(atom) + WebMolKit.Molecule.IDEALBOND * Math.cos(ang[n]);
                let y = mol.atomY(atom) + WebMolKit.Molecule.IDEALBOND * Math.sin(ang[n]);
                let score = WebMolKit.CoordUtil.congestionPoint(mol, x, y);
                if (n == 0 || score < best) {
                    best = score;
                    bx = x;
                    by = y;
                }
            }
            this.output.mol = mol.clone();
            let anum = WebMolKit.CoordUtil.atomAtPoint(this.output.mol, bx, by);
            if (anum == 0)
                anum = this.output.mol.addAtom('C', bx, by);
            WebMolKit.MolUtil.addBond(this.output.mol, atom, anum, order, type);
        }
        performBondChange(order, type) {
            let mol = this.input.mol;
            let bonds = [];
            for (let n = 1; n <= mol.numBonds; n++)
                if (this.subjectMask[mol.bondFrom(n) - 1] && this.subjectMask[mol.bondTo(n) - 1])
                    bonds.push(n);
            let switchType = type == WebMolKit.Molecule.BONDTYPE_DECLINED || type == WebMolKit.Molecule.BONDTYPE_INCLINED;
            let stereoType = switchType || type == WebMolKit.Molecule.BONDTYPE_UNKNOWN;
            let anyChange = switchType;
            for (let n = 0; n < bonds.length && !anyChange; n++) {
                let b = bonds[n];
                if (mol.bondOrder(b) != order && type == WebMolKit.Molecule.BONDTYPE_NORMAL)
                    anyChange = true;
                else if (mol.bondType(b) != type)
                    anyChange = true;
            }
            if (!anyChange) {
                this.errmsg = 'No bond changes made.';
                return;
            }
            this.output.mol = mol.clone();
            for (let n = 0; n < bonds.length; n++) {
                let b = bonds[n], bfr = this.output.mol.bondFrom(b), bto = this.output.mol.bondTo(b);
                if (switchType && this.output.mol.bondType(b) == type) {
                    this.output.mol.setBondFromTo(b, bto, bfr);
                }
                else if (this.output.mol.bondOrder(b) != order || this.output.mol.bondType(b) != type) {
                    if (!stereoType)
                        this.output.mol.setBondOrder(b, order);
                    this.output.mol.setBondType(b, type);
                }
                else if (switchType) {
                    this.output.mol.setBondFromTo(b, bto, bfr);
                }
            }
        }
        performBondGeomAtom(geom, atom) {
            let mol = this.input.mol;
            let adj = mol.atomAdjList(atom);
            let asz = adj.length, gsz = WebMolKit.SketchUtil.GEOM_ANGLES[geom].length;
            if (asz > gsz) {
                this.errmsg = 'The current atom has more bonds than does the selected geometry.';
                return;
            }
            if (asz == 0) {
                this.performBondNew(atom, 1, WebMolKit.Molecule.BONDTYPE_NORMAL);
                return;
            }
            if (asz == gsz) {
                this.output.mol = WebMolKit.SketchUtil.refitAtomGeometry(mol, atom, geom);
                if (this.output.mol == null)
                    this.errmsg = 'Could not re-fit the atom geometry.';
                return;
            }
            let ang = WebMolKit.CoordUtil.atomBondAngles(mol, atom);
            let newang = WebMolKit.SketchUtil.mapAngleSubstituent(geom, ang);
            if (newang == null) {
                this.output.mol = WebMolKit.SketchUtil.refitAtomGeometry(mol, atom, geom);
                if (this.output.mol == null)
                    this.errmsg = 'Could not re-fit the atom geometry.';
                return;
            }
            this.output.mol = mol.clone();
            let theta = WebMolKit.SketchUtil.pickNewAtomDirection(mol, atom, newang);
            let x = this.output.mol.atomX(atom) + WebMolKit.Molecule.IDEALBOND * Math.cos(theta);
            let y = this.output.mol.atomY(atom) + WebMolKit.Molecule.IDEALBOND * Math.sin(theta);
            let anum = WebMolKit.CoordUtil.atomAtPoint(this.output.mol, x, y);
            if (anum == 0)
                anum = this.output.mol.addAtom('C', x, y);
            WebMolKit.MolUtil.addBond(this.output.mol, atom, anum, 1);
        }
        performBondGeomBond(geom, bond) {
            let mol = this.input.mol;
            let bfr = mol.bondFrom(bond), bto = mol.bondTo(bond);
            let ac1 = mol.atomAdjCount(bfr), ac2 = mol.atomAdjCount(bto);
            if (ac1 > 1 && ac2 == 1) { }
            else if (ac1 == 1 && ac2 > 1) {
                let t = ac1;
                ac1 = ac2;
                ac2 = t;
            }
            else {
                this.errmsg = 'One end of the bond must be terminal.';
                return;
            }
            let adj = mol.atomAdjList(bfr);
            let x1 = mol.atomX(bfr), y1 = mol.atomY(bfr);
            let x2 = mol.atomX(bto), y2 = mol.atomY(bto);
            let ang = [];
            for (let n = 0, p = 0; n < adj.length; n++)
                if (adj[n] != bto) {
                    ang.push(Math.atan2(mol.atomY(adj[n]) - y1, mol.atomX(adj[n]) - x1));
                }
            let newang = WebMolKit.SketchUtil.mapAngleSubstituent(geom, ang);
            if (newang == null) {
                this.errmsg = 'No alternative geometries identified.';
                return;
            }
            let bestAng = WebMolKit.TWOPI + 1, bestX = 0, bestY = 0;
            let curth = Math.atan2(y2 - y1, x2 - x1), r = WebMolKit.norm_xy(x2 - x1, y2 - y1);
            for (let n = 0; n < newang.length; n++) {
                let th = WebMolKit.angleDiff(newang[n], curth);
                if (th < 0)
                    th += WebMolKit.TWOPI;
                if (n > 0 && th > bestAng)
                    continue;
                let x = x1 + r * Math.cos(th + curth);
                let y = y1 + r * Math.sin(th + curth);
                if (WebMolKit.CoordUtil.atomAtPoint(mol, x, y) > 0)
                    continue;
                bestAng = th;
                bestX = x;
                bestY = y;
            }
            if (bestAng > WebMolKit.TWOPI) {
                this.errmsg = 'No alternative geometries identified.';
                return;
            }
            this.output.mol = mol.clone();
            this.output.mol.setAtomPos(bto, bestX, bestY);
        }
        checkAbbreviationReady() {
            let junction = 0;
            let mol = this.input.mol, subjmask = this.subjectMask;
            for (let n = 1; n <= mol.numBonds; n++) {
                let b1 = mol.bondFrom(n), b2 = mol.bondTo(n);
                let atom = 0;
                if ((subjmask[b1 - 1] && !subjmask[b2 - 1] && WebMolKit.MolUtil.hasAbbrev(mol, b1)) ||
                    (subjmask[b2 - 1] && !subjmask[b1 - 1] && WebMolKit.MolUtil.hasAbbrev(mol, b2))) {
                    this.errmsg = 'Already an abbreviation.';
                    return false;
                }
                if (subjmask[b1 - 1] && !subjmask[b2 - 1])
                    atom = b1;
                else if (subjmask[b2 - 1] && !subjmask[b1 - 1])
                    atom = b2;
                if (atom == 0 || atom == junction) { }
                else if (junction == 0)
                    junction = atom;
                else {
                    this.errmsg = 'The selected group must be terminal.';
                    return false;
                }
            }
            return true;
        }
    }
    WebMolKit.MoleculeActivity = MoleculeActivity;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class ButtonBank {
        constructor() {
            this.isSubLevel = false;
            this.buttons = [];
        }
        init() { }
        claimKey(event) { return false; }
        bankClosed() { }
        static matchKey(event, mnemonic) {
            if (mnemonic == null || mnemonic == '')
                return;
            let mshift = false, mctrl = false, malt = false, mkey = mnemonic;
            while (true) {
                if (mkey.startsWith('Shift-')) {
                    mshift = true;
                    mkey = mkey.substring(6);
                }
                else if (mkey.startsWith('Ctrl-')) {
                    mctrl = true;
                    mkey = mkey.substring(5);
                }
                else if (mkey.startsWith('Alt-')) {
                    malt = true;
                    mkey = mkey.substring(4);
                }
                else
                    break;
            }
            if (mshift && !event.shiftKey)
                return false;
            if (mctrl && !event.ctrlKey)
                return false;
            if (malt && !event.altKey)
                return false;
            let ch = String.fromCharCode(event.keyCode || event.charCode);
            if (event.keyCode == 27)
                ch = 'escape';
            else if (event.keyCode == 8)
                ch = 'backspace';
            else if (event.keyCode == 46)
                ch = 'delete';
            if (mshift) {
                const SHIFT_SUBST = { '1': '!', '2': '@', '3': '#', '4': '$', '5': '%', '6': '^', '7': '&', '8': '*', '9': '(', '0': ')', '-': '_', '=': '+' };
                let subst = SHIFT_SUBST[mkey];
                if (subst)
                    mkey = subst;
            }
            return ch.toLowerCase() == mkey.toLowerCase();
        }
    }
    WebMolKit.ButtonBank = ButtonBank;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    const ELEMENTS_NOBLE = [
        'He', 'Ar', 'Kr', 'Xe', 'Rn'
    ];
    const ELEMENTS_S_BLOCK = [
        'Li', 'Na', 'K', 'Rb', 'Cs', 'Fr', 'Sc',
        'Be', 'Mg', 'Ca', 'Sr', 'Ba', 'Ra', 'Y'
    ];
    const ELEMENTS_P_BLOCK = [
        'B', 'Al', 'Si', 'Ga', 'Ge', 'As', 'Se',
        'In', 'Sn', 'Sb', 'Te', 'Tl', 'Pb', 'Bi', 'Po', 'At'
    ];
    const ELEMENTS_D_BLOCK = [
        'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn',
        'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd',
        'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg'
    ];
    const ELEMENTS_F_BLOCK = [
        'La', 'Ce', 'Pr', 'Nd', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy',
        'Ho', 'Er', 'Tm', 'Yb', 'Lu', 'Ac', 'Th', 'Pa', 'U'
    ];
    const ELEMENTS_ABBREV = [
        'X', 'Y', 'Z', 'Q', 'M', 'L', 'E', 'A', 'R',
        'R0', 'R1', 'R2', 'R3', 'R4', 'R5', 'R6', 'R7', 'R8'
    ];
    let CommandType;
    (function (CommandType) {
        CommandType[CommandType["Main"] = 0] = "Main";
        CommandType[CommandType["Atom"] = 1] = "Atom";
        CommandType[CommandType["Bond"] = 2] = "Bond";
        CommandType[CommandType["Select"] = 3] = "Select";
        CommandType[CommandType["Move"] = 4] = "Move";
        CommandType[CommandType["Abbrev"] = 5] = "Abbrev";
        CommandType[CommandType["SBlock"] = 6] = "SBlock";
        CommandType[CommandType["PBlock"] = 7] = "PBlock";
        CommandType[CommandType["DBlock"] = 8] = "DBlock";
        CommandType[CommandType["FBlock"] = 9] = "FBlock";
        CommandType[CommandType["Noble"] = 10] = "Noble";
    })(CommandType || (CommandType = {}));
    const COMMANDS_MAIN = [
        { 'id': 'undo', 'imageFN': 'MainUndo', 'helpText': 'Undo last change.', 'mnemonic': '' },
        { 'id': 'redo', 'imageFN': 'MainRedo', 'helpText': 'Cancel last undo.', 'mnemonic': '' },
        { 'id': 'zoomin', 'imageFN': 'MainZoomIn', 'helpText': 'Zoom in.', 'mnemonic': '=' },
        { 'id': 'zoomout', 'imageFN': 'MainZoomOut', 'helpText': 'Zoom out.', 'mnemonic': '-' },
        { 'id': 'zoomfit', 'imageFN': 'MainZoomFit', 'helpText': 'Show whole diagram onscreen.', 'mnemonic': '' },
        { 'id': 'selside', 'imageFN': 'MainSelSide', 'helpText': 'Select alternate side of current atom or bond.', 'mnemonic': 'E' },
        { 'id': 'selall', 'imageFN': 'MainSelAll', 'helpText': 'Select all atoms.', 'mnemonic': '' },
        { 'id': 'selnone', 'imageFN': 'MainSelNone', 'helpText': 'Clear selection.', 'mnemonic': '' },
        { 'id': 'delete', 'imageFN': 'MainDelete', 'helpText': 'Delete selected atoms and bonds.', 'mnemonic': '' },
        { 'id': 'cut', 'imageFN': 'MainCut', 'helpText': 'Copy selection to clipboard, and remove.', 'mnemonic': '' },
        { 'id': 'copy', 'imageFN': 'MainCopy', 'helpText': 'Copy selection to clipboard.', 'mnemonic': '' },
        { 'id': 'paste', 'imageFN': 'MainPaste', 'helpText': 'Paste clipboard contents.', 'mnemonic': '' },
        { 'id': 'atom', 'imageFN': 'MainAtom', 'helpText': 'Open the Atom submenu.', 'isSubMenu': true, 'mnemonic': 'A' },
        { 'id': 'bond', 'imageFN': 'MainBond', 'helpText': 'Open the Bond submenu.', 'isSubMenu': true, 'mnemonic': 'B' },
        { 'id': 'select', 'imageFN': 'MainSelect', 'helpText': 'Open the Selection submenu.', 'isSubMenu': true, 'mnemonic': 'S' },
        { 'id': 'move', 'imageFN': 'MainMove', 'helpText': 'Open the Move submenu.', 'isSubMenu': true, 'mnemonic': 'M' },
    ];
    const COMMANDS_ATOM = [
        { 'id': 'element:C', 'text': 'C', 'helpText': 'Change elements to Carbon.', 'mnemonic': 'Shift-C' },
        { 'id': 'element:N', 'text': 'N', 'helpText': 'Change elements to Nitrogen.', 'mnemonic': 'Shift-N' },
        { 'id': 'element:O', 'text': 'O', 'helpText': 'Change elements to Oxygen.', 'mnemonic': 'Shift-O' },
        { 'id': 'element:S', 'text': 'S', 'helpText': 'Change elements to Sulfur.', 'mnemonic': 'Shift-S' },
        { 'id': 'element:P', 'text': 'P', 'helpText': 'Change elements to Phosphorus.', 'mnemonic': 'Shift-P' },
        { 'id': 'element:H', 'text': 'H', 'helpText': 'Change elements to Hydrogen.', 'mnemonic': 'Shift-H' },
        { 'id': 'element:F', 'text': 'F', 'helpText': 'Change elements to Fluorine.', 'mnemonic': 'Shift-F' },
        { 'id': 'element:Cl', 'text': 'Cl', 'helpText': 'Change elements to Chlorine.', 'mnemonic': 'Shift-L' },
        { 'id': 'element:Br', 'text': 'Br', 'helpText': 'Change elements to Bromine.', 'mnemonic': 'Shift-B' },
        { 'id': 'element:I', 'text': 'I', 'helpText': 'Change elements to Iodine.', 'mnemonic': 'Shift-I' },
        { 'id': 'plus', 'imageFN': 'AtomPlus', 'helpText': 'Increase the atom charge.', 'mnemonic': '+' },
        { 'id': 'minus', 'imageFN': 'AtomMinus', 'helpText': 'Decrease the atom charge.', 'mnemonic': '_' },
        { 'id': 'abbrev', 'imageFN': 'AtomAbbrev', 'helpText': 'Open list of common labels.', 'isSubMenu': true, 'mnemonic': 'Q' },
        { 'id': 'sblock', 'imageFN': 'AtomSBlock', 'helpText': 'Open list of s-block elements.', 'isSubMenu': true, 'mnemonic': 'S' },
        { 'id': 'pblock', 'imageFN': 'AtomPBlock', 'helpText': 'Open list of p-block elements.', 'isSubMenu': true, 'mnemonic': 'P' },
        { 'id': 'dblock', 'imageFN': 'AtomDBlock', 'helpText': 'Open list of d-block elements.', 'isSubMenu': true, 'mnemonic': 'D' },
        { 'id': 'fblock', 'imageFN': 'AtomFBlock', 'helpText': 'Open list of f-block elements.', 'isSubMenu': true, 'mnemonic': 'F' },
        { 'id': 'noble', 'imageFN': 'AtomNoble', 'helpText': 'Open list of noble elements.', 'isSubMenu': true, 'mnemonic': 'Y' },
    ];
    const COMMANDS_BOND = [
        { 'id': 'one', 'imageFN': 'BondOne', 'helpText': 'Create or set bonds to single.', 'mnemonic': '1' },
        { 'id': 'two', 'imageFN': 'BondTwo', 'helpText': 'Create or set bonds to double.', 'mnemonic': '2' },
        { 'id': 'three', 'imageFN': 'BondThree', 'helpText': 'Create or set bonds to triple.', 'mnemonic': '3' },
        { 'id': 'four', 'imageFN': 'BondFour', 'helpText': 'Create or set bonds to quadruple.', 'mnemonic': '' },
        { 'id': 'zero', 'imageFN': 'BondZero', 'helpText': 'Create or set bonds to zero-order.', 'mnemonic': '0' },
        { 'id': 'inclined', 'imageFN': 'BondUp', 'helpText': 'Create or set bonds to inclined.', 'mnemonic': '5' },
        { 'id': 'declined', 'imageFN': 'BondDown', 'helpText': 'Create or set bonds to declined.', 'mnemonic': '6' },
        { 'id': 'squig', 'imageFN': 'BondSquig', 'helpText': 'Create or set bonds to unknown stereochemistry.', 'mnemonic': '4' },
        { 'id': 'addtwo', 'imageFN': 'BondAddTwo', 'helpText': 'Add two new bonds to the subject atom.', 'mnemonic': 'Shift-A' },
        { 'id': 'insert', 'imageFN': 'BondInsert', 'helpText': 'Insert a methylene into the subject bond.', 'mnemonic': '' },
        { 'id': 'switch', 'imageFN': 'BondSwitch', 'helpText': 'Cycle through likely bond geometries.', 'mnemonic': '' },
        { 'id': 'linear', 'imageFN': 'BondLinear', 'helpText': 'Apply linear geometry.', 'mnemonic': 'Shift-Q' },
        { 'id': 'trigonal', 'imageFN': 'BondTrigonal', 'helpText': 'Apply trigonal geometry.', 'mnemonic': 'Shift-W' },
        { 'id': 'tetra1', 'imageFN': 'BondTetra1', 'helpText': 'Apply tetrahedral geometry #1.', 'mnemonic': 'Shift-E' },
        { 'id': 'tetra2', 'imageFN': 'BondTetra2', 'helpText': 'Apply tetrahedral geometry #2.', 'mnemonic': 'Shift-R' },
        { 'id': 'sqplan', 'imageFN': 'BondSqPlan', 'helpText': 'Apply square planar geometry.', 'mnemonic': 'Shift-T' },
        { 'id': 'octa1', 'imageFN': 'BondOcta1', 'helpText': 'Apply octahedral geometry #1.', 'mnemonic': 'Shift-Y' },
        { 'id': 'octa2', 'imageFN': 'BondOcta2', 'helpText': 'Apply octahedral geometry #2.', 'mnemonic': 'Shift-U' },
        { 'id': 'connect', 'imageFN': 'BondConnect', 'helpText': 'Connect selected atoms, by proximity.', 'mnemonic': '' },
        { 'id': 'disconnect', 'imageFN': 'BondDisconnect', 'helpText': 'Disconnect selected atoms.', 'mnemonic': '' },
        { 'id': 'artifactpath', 'imageFN': 'BondArtifactPath', 'helpText': 'Add a path bond artifact.', 'mnemonic': '' },
        { 'id': 'artifactring', 'imageFN': 'BondArtifactRing', 'helpText': 'Add a ring bond artifact.', 'mnemonic': '' },
        { 'id': 'artifactarene', 'imageFN': 'BondArtifactArene', 'helpText': 'Add an arene bond artifact.', 'mnemonic': '' },
        { 'id': 'artifactclear', 'imageFN': 'BondArtifactClear', 'helpText': 'Remove a bond artifact.', 'mnemonic': '' },
    ];
    const COMMANDS_SELECT = [
        { 'id': 'selgrow', 'imageFN': 'SelectionGrow', 'helpText': 'Add adjacent atoms to selection.', 'mnemonic': '' },
        { 'id': 'selshrink', 'imageFN': 'SelectionShrink', 'helpText': 'Unselect exterior atoms.', 'mnemonic': '' },
        { 'id': 'selchain', 'imageFN': 'SelectionChain', 'helpText': 'Extend selection to non-ring atoms.', 'mnemonic': '' },
        { 'id': 'smallring', 'imageFN': 'SelectionSmRing', 'helpText': 'Extend selection to small rings.', 'mnemonic': '' },
        { 'id': 'ringblock', 'imageFN': 'SelectionRingBlk', 'helpText': 'Extend selection to ring blocks.', 'mnemonic': '' },
        { 'id': 'curelement', 'imageFN': 'SelectionCurElement', 'helpText': 'Select all atoms of current element type.', 'mnemonic': '' },
        { 'id': 'selprev', 'imageFN': 'MainSelPrev', 'helpText': 'Select previous connected component.', 'mnemonic': '' },
        { 'id': 'selnext', 'imageFN': 'MainSelNext', 'helpText': 'Select next connected component.', 'mnemonic': '' },
        { 'id': 'toggle', 'imageFN': 'SelectionToggle', 'helpText': 'Toggle selection of current.', 'mnemonic': '' },
        { 'id': 'uncurrent', 'imageFN': 'SelectionUncurrent', 'helpText': 'Undefine current object.', 'mnemonic': '' },
        { 'id': 'join', 'imageFN': 'MoveJoin', 'helpText': 'Overlapping atoms will be joined as one.', 'mnemonic': '' },
        { 'id': 'new', 'imageFN': 'MainNew', 'helpText': 'Clear the molecular structure.', 'mnemonic': '' },
        { 'id': 'inline', 'imageFN': 'AtomInline', 'helpText': 'Make selected atoms into an inline abbreviation.', 'mnemonic': '' },
        { 'id': 'formula', 'imageFN': 'AtomFormula', 'helpText': 'Make selected atoms into their molecule formula.', 'mnemonic': '' },
        { 'id': 'clearabbrev', 'imageFN': 'AtomClearAbbrev', 'helpText': 'Remove inline abbreviation.', 'mnemonic': '' },
        { 'id': 'expandabbrev', 'imageFN': 'AtomExpandAbbrev', 'helpText': 'Expand out the inline abbreviation.', 'mnemonic': '' },
    ];
    const COMMANDS_MOVE = [
        { 'id': 'up', 'imageFN': 'MoveUp', 'helpText': 'Move subject atoms up slightly.', 'mnemonic': '' },
        { 'id': 'down', 'imageFN': 'MoveDown', 'helpText': 'Move subject atoms down slightly.', 'mnemonic': '' },
        { 'id': 'left', 'imageFN': 'MoveLeft', 'helpText': 'Move subject atoms slightly to the left.', 'mnemonic': '' },
        { 'id': 'right', 'imageFN': 'MoveRight', 'helpText': 'Move subject atoms slightly to the right.', 'mnemonic': '' },
        { 'id': 'uplots', 'imageFN': 'MoveUpLots', 'helpText': 'Move subject atoms up somewhat.', 'mnemonic': '' },
        { 'id': 'downlots', 'imageFN': 'MoveDownLots', 'helpText': 'Move subject atoms down somewhat.', 'mnemonic': '' },
        { 'id': 'leftlots', 'imageFN': 'MoveLeftLots', 'helpText': 'Move subject atoms somewhat to the left.', 'mnemonic': '' },
        { 'id': 'rightlots', 'imageFN': 'MoveRightLots', 'helpText': 'Move subject atoms somewhat to the right.', 'mnemonic': '' },
        { 'id': 'upfar', 'imageFN': 'MoveUpFar', 'helpText': 'Move subject atoms far up.', 'mnemonic': '' },
        { 'id': 'downfar', 'imageFN': 'MoveDownFar', 'helpText': 'Move subject atoms far down.', 'mnemonic': '' },
        { 'id': 'leftfar', 'imageFN': 'MoveLeftFar', 'helpText': 'Move subject atoms far to the left.', 'mnemonic': '' },
        { 'id': 'rightfar', 'imageFN': 'MoveRightFar', 'helpText': 'Move subject atoms far to the right.', 'mnemonic': '' },
        { 'id': 'rotp01', 'imageFN': 'MoveRotP01', 'helpText': 'Rotate 1\u00B0 counter-clockwise.', 'mnemonic': '' },
        { 'id': 'rotm01', 'imageFN': 'MoveRotM01', 'helpText': 'Rotate 1\u00B0 clockwise.', 'mnemonic': '' },
        { 'id': 'rotp05', 'imageFN': 'MoveRotP05', 'helpText': 'Rotate 5\u00B0 counter-clockwise.', 'mnemonic': '' },
        { 'id': 'rotm05', 'imageFN': 'MoveRotM05', 'helpText': 'Rotate 5\u00B0 clockwise.', 'mnemonic': '' },
        { 'id': 'rotp15', 'imageFN': 'MoveRotP15', 'helpText': 'Rotate 15\u00B0 counter-clockwise.', 'mnemonic': '' },
        { 'id': 'rotm15', 'imageFN': 'MoveRotM15', 'helpText': 'Rotate 15\u00B0 clockwise.', 'mnemonic': '' },
        { 'id': 'rotp30', 'imageFN': 'MoveRotP30', 'helpText': 'Rotate 30\u00B0 counter-clockwise.', 'mnemonic': '' },
        { 'id': 'rotm30', 'imageFN': 'MoveRotM30', 'helpText': 'Rotate 30\u00B0 clockwise.', 'mnemonic': '' },
        { 'id': 'hflip', 'imageFN': 'MoveHFlip', 'helpText': 'Flip subject atoms horizontally.', 'mnemonic': '' },
        { 'id': 'vflip', 'imageFN': 'MoveVFlip', 'helpText': 'Flip subject atoms vertically.', 'mnemonic': '' },
        { 'id': 'shrink', 'imageFN': 'MoveShrink', 'helpText': 'Decrease subject bond distances.', 'mnemonic': '' },
        { 'id': 'grow', 'imageFN': 'MoveGrow', 'helpText': 'Increase subject bond distances.', 'mnemonic': '' },
    ];
    class CommandBank extends WebMolKit.ButtonBank {
        constructor(owner, cmdType = CommandType.Main) {
            super();
            this.owner = owner;
            this.cmdType = cmdType;
        }
        update() {
            if (this.cmdType == CommandType.Main)
                for (let btn of COMMANDS_MAIN)
                    this.buttons.push(btn);
            else if (this.cmdType == CommandType.Atom)
                for (let btn of COMMANDS_ATOM)
                    this.buttons.push(btn);
            else if (this.cmdType == CommandType.Bond)
                for (let btn of COMMANDS_BOND)
                    this.buttons.push(btn);
            else if (this.cmdType == CommandType.Select)
                for (let btn of COMMANDS_SELECT)
                    this.buttons.push(btn);
            else if (this.cmdType == CommandType.Move)
                for (let btn of COMMANDS_MOVE)
                    this.buttons.push(btn);
            else if (this.cmdType == CommandType.Abbrev)
                this.populateElements(ELEMENTS_NOBLE);
            else if (this.cmdType == CommandType.SBlock)
                this.populateElements(ELEMENTS_S_BLOCK);
            else if (this.cmdType == CommandType.PBlock)
                this.populateElements(ELEMENTS_P_BLOCK);
            else if (this.cmdType == CommandType.DBlock)
                this.populateElements(ELEMENTS_D_BLOCK);
            else if (this.cmdType == CommandType.FBlock)
                this.populateElements(ELEMENTS_F_BLOCK);
            else if (this.cmdType == CommandType.Noble)
                this.populateElements(ELEMENTS_ABBREV);
        }
        populateElements(elements) {
            for (let el of elements) {
                this.buttons.push({ 'id': `element:${el}`, 'text': el, 'helpText': `Change elements to ${el}.` });
            }
        }
        hitButton(id) {
            let actv = 0, param = null;
            if (id.startsWith('element:')) {
                let el = id.substring(8);
                actv = WebMolKit.ActivityType.Element;
                param = { 'element': el };
            }
            else if (id == 'delete')
                actv = WebMolKit.ActivityType.Delete;
            else if (id == 'undo') {
                if (this.owner.canUndo())
                    this.owner.performUndo();
                else
                    this.owner.showMessage('Nothing to undo.');
            }
            else if (id == 'redo') {
                if (this.owner.canRedo())
                    this.owner.performRedo();
                else
                    this.owner.showMessage('Nothing to redo.');
            }
            else if (id == 'cut')
                actv = WebMolKit.ActivityType.Cut;
            else if (id == 'copy')
                actv = WebMolKit.ActivityType.Copy;
            else if (id == 'paste')
                this.owner.performPaste();
            else if (id == 'new')
                actv = WebMolKit.ActivityType.Clear;
            else if (id == 'zoomfit')
                this.owner.autoScale();
            else if (id == 'zoomout')
                this.owner.zoom(0.8);
            else if (id == 'zoomin')
                this.owner.zoom(1.25);
            else if (id == 'selall')
                actv = WebMolKit.ActivityType.SelectAll;
            else if (id == 'selnone')
                actv = WebMolKit.ActivityType.SelectNone;
            else if (id == 'selprev')
                actv = WebMolKit.ActivityType.SelectPrevComp;
            else if (id == 'selnext')
                actv = WebMolKit.ActivityType.SelectNextComp;
            else if (id == 'selside')
                actv = WebMolKit.ActivityType.SelectSide;
            else if (id == 'plus') {
                actv = WebMolKit.ActivityType.Charge;
                param = { 'delta': 1 };
            }
            else if (id == 'minus') {
                actv = WebMolKit.ActivityType.Charge;
                param = { 'delta': -1 };
            }
            else if (id == 'one') {
                actv = WebMolKit.ActivityType.BondOrder;
                param = { 'order': 1 };
            }
            else if (id == 'two') {
                actv = WebMolKit.ActivityType.BondOrder;
                param = { 'order': 2 };
            }
            else if (id == 'three') {
                actv = WebMolKit.ActivityType.BondOrder;
                param = { 'order': 3 };
            }
            else if (id == 'four') {
                actv = WebMolKit.ActivityType.BondOrder;
                param = { 'order': 4 };
            }
            else if (id == 'zero') {
                actv = WebMolKit.ActivityType.BondOrder;
                param = { 'order': 0 };
            }
            else if (id == 'inclined') {
                actv = WebMolKit.ActivityType.BondType;
                param = { 'type': WebMolKit.Molecule.BONDTYPE_INCLINED };
            }
            else if (id == 'declined') {
                actv = WebMolKit.ActivityType.BondType;
                param = { 'type': WebMolKit.Molecule.BONDTYPE_DECLINED };
            }
            else if (id == 'squig') {
                actv = WebMolKit.ActivityType.BondType;
                param = { 'type': WebMolKit.Molecule.BONDTYPE_UNKNOWN };
            }
            else if (id == 'linear') {
                actv = WebMolKit.ActivityType.BondGeom;
                param = { 'geom': WebMolKit.Geometry.Linear };
            }
            else if (id == 'trigonal') {
                actv = WebMolKit.ActivityType.BondGeom;
                param = { 'geom': WebMolKit.Geometry.Trigonal };
            }
            else if (id == 'tetra1') {
                actv = WebMolKit.ActivityType.BondGeom;
                param = { 'geom': WebMolKit.Geometry.Tetra1 };
            }
            else if (id == 'tetra2') {
                actv = WebMolKit.ActivityType.BondGeom;
                param = { 'geom': WebMolKit.Geometry.Tetra2 };
            }
            else if (id == 'sqplan') {
                actv = WebMolKit.ActivityType.BondGeom;
                param = { 'geom': WebMolKit.Geometry.SqPlan };
            }
            else if (id == 'octa1') {
                actv = WebMolKit.ActivityType.BondGeom;
                param = { 'geom': WebMolKit.Geometry.Octa1 };
            }
            else if (id == 'octa2') {
                actv = WebMolKit.ActivityType.BondGeom;
                param = { 'geom': WebMolKit.Geometry.Octa2 };
            }
            else if (id == 'switch')
                actv = WebMolKit.ActivityType.BondSwitch;
            else if (id == 'connect')
                actv = WebMolKit.ActivityType.Connect;
            else if (id == 'disconnect')
                actv = WebMolKit.ActivityType.Disconnect;
            else if (id == 'artifactpath')
                actv = WebMolKit.ActivityType.BondArtifactPath;
            else if (id == 'artifactring')
                actv = WebMolKit.ActivityType.BondArtifactRing;
            else if (id == 'artifactarene')
                actv = WebMolKit.ActivityType.BondArtifactArene;
            else if (id == 'artifactclear')
                actv = WebMolKit.ActivityType.BondArtifactClear;
            else if (id == 'addtwo')
                actv = WebMolKit.ActivityType.BondAddTwo;
            else if (id == 'insert')
                actv = WebMolKit.ActivityType.BondInsert;
            else if (id == 'curelement')
                actv = WebMolKit.ActivityType.SelectCurElement;
            else if (id == 'selgrow')
                actv = WebMolKit.ActivityType.SelectGrow;
            else if (id == 'selshrink')
                actv = WebMolKit.ActivityType.SelectShrink;
            else if (id == 'selprev')
                actv = WebMolKit.ActivityType.SelectPrevComp;
            else if (id == 'selnext')
                actv = WebMolKit.ActivityType.SelectNextComp;
            else if (id == 'selchain')
                actv = WebMolKit.ActivityType.SelectChain;
            else if (id == 'smallring')
                actv = WebMolKit.ActivityType.SelectSmRing;
            else if (id == 'ringblock')
                actv = WebMolKit.ActivityType.SelectRingBlk;
            else if (id == 'toggle')
                actv = WebMolKit.ActivityType.SelectToggle;
            else if (id == 'uncurrent')
                actv = WebMolKit.ActivityType.SelectUnCurrent;
            else if (id == 'join')
                actv = WebMolKit.ActivityType.Join;
            else if (id == 'inline')
                actv = WebMolKit.ActivityType.AbbrevGroup;
            else if (id == 'formula')
                actv = WebMolKit.ActivityType.AbbrevFormula;
            else if (id == 'clearabbrev')
                actv = WebMolKit.ActivityType.AbbrevClear;
            else if (id == 'expandabbrev')
                actv = WebMolKit.ActivityType.AbbrevExpand;
            else if (id == 'up') {
                actv = WebMolKit.ActivityType.Nudge;
                param = { 'dir': 'up' };
            }
            else if (id == 'down') {
                actv = WebMolKit.ActivityType.Nudge;
                param = { 'dir': 'down' };
            }
            else if (id == 'left') {
                actv = WebMolKit.ActivityType.Nudge;
                param = { 'dir': 'left' };
            }
            else if (id == 'right') {
                actv = WebMolKit.ActivityType.Nudge;
                param = { 'dir': 'right' };
            }
            else if (id == 'uplots') {
                actv = WebMolKit.ActivityType.NudgeLots;
                param = { 'dir': 'up' };
            }
            else if (id == 'downlots') {
                actv = WebMolKit.ActivityType.NudgeLots;
                param = { 'dir': 'down' };
            }
            else if (id == 'leftlots') {
                actv = WebMolKit.ActivityType.NudgeLots;
                param = { 'dir': 'left' };
            }
            else if (id == 'rightlots') {
                actv = WebMolKit.ActivityType.NudgeLots;
                param = { 'dir': 'right' };
            }
            else if (id == 'upfar') {
                actv = WebMolKit.ActivityType.NudgeFar;
                param = { 'dir': 'up' };
            }
            else if (id == 'downfar') {
                actv = WebMolKit.ActivityType.NudgeFar;
                param = { 'dir': 'down' };
            }
            else if (id == 'leftfar') {
                actv = WebMolKit.ActivityType.NudgeFar;
                param = { 'dir': 'left' };
            }
            else if (id == 'rightfar') {
                actv = WebMolKit.ActivityType.NudgeFar;
                param = { 'dir': 'right' };
            }
            else if (id == 'rotp01') {
                actv = WebMolKit.ActivityType.Rotate;
                param = { 'theta': 1 };
            }
            else if (id == 'rotm01') {
                actv = WebMolKit.ActivityType.Rotate;
                param = { 'theta': -1 };
            }
            else if (id == 'rotp05') {
                actv = WebMolKit.ActivityType.Rotate;
                param = { 'theta': 5 };
            }
            else if (id == 'rotm05') {
                actv = WebMolKit.ActivityType.Rotate;
                param = { 'theta': -5 };
            }
            else if (id == 'rotp15') {
                actv = WebMolKit.ActivityType.Rotate;
                param = { 'theta': 15 };
            }
            else if (id == 'rotm15') {
                actv = WebMolKit.ActivityType.Rotate;
                param = { 'theta': -15 };
            }
            else if (id == 'rotp30') {
                actv = WebMolKit.ActivityType.Rotate;
                param = { 'theta': 30 };
            }
            else if (id == 'rotm30') {
                actv = WebMolKit.ActivityType.Rotate;
                param = { 'theta': -30 };
            }
            else if (id == 'hflip') {
                actv = WebMolKit.ActivityType.Flip;
                param = { 'axis': 'hor' };
            }
            else if (id == 'vflip') {
                actv = WebMolKit.ActivityType.Flip;
                param = { 'axis': 'ver' };
            }
            else if (id == 'shrink') {
                actv = WebMolKit.ActivityType.Scale;
                param = { 'mag': 1 / 1.1 };
            }
            else if (id == 'grow') {
                actv = WebMolKit.ActivityType.Scale;
                param = { 'mag': 1.1 };
            }
            else if (id == 'atom')
                this.buttonView.pushBank(new CommandBank(this.owner, CommandType.Atom));
            else if (id == 'bond')
                this.buttonView.pushBank(new CommandBank(this.owner, CommandType.Bond));
            else if (id == 'select')
                this.buttonView.pushBank(new CommandBank(this.owner, CommandType.Select));
            else if (id == 'move')
                this.buttonView.pushBank(new CommandBank(this.owner, CommandType.Move));
            else if (id == 'abbrev')
                this.buttonView.pushBank(new CommandBank(this.owner, CommandType.Abbrev));
            else if (id == 'sblock')
                this.buttonView.pushBank(new CommandBank(this.owner, CommandType.SBlock));
            else if (id == 'pblock')
                this.buttonView.pushBank(new CommandBank(this.owner, CommandType.PBlock));
            else if (id == 'dblock')
                this.buttonView.pushBank(new CommandBank(this.owner, CommandType.DBlock));
            else if (id == 'fblock')
                this.buttonView.pushBank(new CommandBank(this.owner, CommandType.FBlock));
            else if (id == 'noble')
                this.buttonView.pushBank(new CommandBank(this.owner, CommandType.Noble));
            else
                alert('Unhandled command: "' + id + '"');
            if (actv > 0) {
                new WebMolKit.MoleculeActivity(this.owner, actv, param).execute();
            }
        }
        claimKey(event) {
            for (let listItems of [COMMANDS_MAIN, COMMANDS_ATOM, COMMANDS_BOND, COMMANDS_SELECT, COMMANDS_MOVE])
                for (let item of listItems) {
                    if (WebMolKit.ButtonBank.matchKey(event, item.mnemonic)) {
                        this.hitButton(item.id);
                        return true;
                    }
                }
            return false;
        }
    }
    WebMolKit.CommandBank = CommandBank;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class TemplateBank extends WebMolKit.ButtonBank {
        constructor(owner, group) {
            super();
            this.owner = owner;
            this.group = group;
            this.subgroups = null;
            this.templates = null;
        }
        init() {
            let policy = WebMolKit.RenderPolicy.defaultBlackOnWhite();
            policy.data.pointScale = 10;
            policy.data.lineSize *= 1.5;
            policy.data.bondSep *= 1.5;
            let sz = this.buttonView.idealSize;
            if (this.group == null) {
                if (WebMolKit.RPC.BASE_URL != null) {
                    let input = { 'tokenID': this.owner.tokenID, 'policy': policy.data, 'size': [sz - 4, sz - 4] };
                    let fcn = (result, error) => {
                        if (!result) {
                            alert('Setup of TemplateBank failed: ' + error.message);
                            return;
                        }
                        this.subgroups = result;
                        this.buttonView.refreshBank();
                    };
                    WebMolKit.Func.getDefaultTemplateGroups(input, fcn);
                }
                else if (WebMolKit.RPC.RESOURCE_URL != null) {
                    if (TemplateBank.RESOURCE_DATA == null)
                        this.loadResourceData(() => this.prepareSubGroups());
                    else
                        this.prepareSubGroups();
                }
            }
            else {
                if (WebMolKit.RPC.BASE_URL != null) {
                    let input = { 'tokenID': this.owner.tokenID, 'policy': policy.data, 'size': [sz - 4, sz - 4], 'group': this.group };
                    let fcn = (result, error) => {
                        if (!result) {
                            alert('Setup of TemplateBank failed: ' + error.message);
                            return;
                        }
                        this.templates = result;
                        this.buttonView.refreshBank();
                    };
                    WebMolKit.Func.getDefaultTemplateStructs(input, fcn);
                }
                else if (WebMolKit.RPC.RESOURCE_URL != null) {
                    if (TemplateBank.RESOURCE_DATA == null)
                        this.loadResourceData(() => this.prepareTemplates());
                    else
                        this.prepareTemplates();
                }
            }
        }
        update() {
            if (this.subgroups == null && this.templates == null)
                return;
            this.buttons = [];
            if (this.group == null)
                this.populateGroups();
            else
                this.populateTemplates();
        }
        populateGroups() {
            let groups = this.subgroups.groups, titles = this.subgroups.titles, preview = this.subgroups.preview;
            for (let n = 0; n < groups.length; n++) {
                this.buttons.push({ 'id': groups[n], 'metavec': preview[n], 'helpText': titles[n] });
            }
        }
        populateTemplates() {
            let names = this.templates.names, abbrev = this.templates.abbrev, mnemonic = this.templates.mnemonic, preview = this.templates.preview;
            for (let n = 0; n < names.length; n++) {
                this.buttons.push({ 'id': n.toString(), 'metavec': preview[n], 'helpText': names[n] });
            }
        }
        hitButton(id) {
            if (this.group == null) {
                this.buttonView.pushBank(new TemplateBank(this.owner, id));
            }
            else {
                let idx = parseInt(id);
                let param = { 'fragNative': this.templates.molecules[idx] };
                new WebMolKit.MoleculeActivity(this.owner, WebMolKit.ActivityType.TemplateFusion, param).execute();
            }
        }
        loadResourceData(onComplete) {
            let roster = [
                'rings',
                'termgrp',
                'funcgrp',
                'protgrp',
                'nonplrings',
                'largerings',
                'crownethers',
                'ligmonodent',
                'ligbident',
                'ligtrident',
                'ligmultident',
                'cagecmplx',
                'aminoacids',
                'biomolecules',
                'saccharides'
            ];
            TemplateBank.RESOURCE_LIST = roster.slice(0);
            TemplateBank.RESOURCE_DATA = [];
            let grabNext = () => {
                if (roster.length == 0) {
                    onComplete();
                    return;
                }
                let url = WebMolKit.RPC.RESOURCE_URL + '/data/templates/' + roster.shift() + '.ds';
                $.ajax({
                    'url': url,
                    'type': 'GET',
                    'dataType': 'text',
                    'success': (dsstr) => {
                        TemplateBank.RESOURCE_DATA.push(WebMolKit.DataSheetStream.readXML(dsstr));
                        grabNext();
                    }
                });
            };
            grabNext();
        }
        prepareSubGroups() {
            this.subgroups = { 'groups': TemplateBank.RESOURCE_LIST, 'titles': [], 'preview': [] };
            let sz = this.buttonView.idealSize, msz = 0.5 * (sz - 2);
            let policy = WebMolKit.RenderPolicy.defaultBlackOnWhite();
            policy.data.pointScale = 10;
            let effects = new WebMolKit.RenderEffects();
            let measure = new WebMolKit.OutlineMeasurement(0, 0, policy.data.pointScale);
            for (let ds of TemplateBank.RESOURCE_DATA) {
                this.subgroups.titles.push(ds.getTitle());
                let colMol = ds.firstColOfType(WebMolKit.DataSheet.COLTYPE_MOLECULE);
                let metavec = new WebMolKit.MetaVector();
                for (let n = 0, idx = 0; idx < 4 && n < ds.numRows; n++) {
                    let mol = ds.getMolecule(n, colMol);
                    if (WebMolKit.MolUtil.isBlank(mol))
                        continue;
                    let layout = new WebMolKit.ArrangeMolecule(mol, measure, policy, effects);
                    layout.arrange();
                    let col = (idx % 2), row = Math.floor(idx / 2);
                    layout.squeezeInto(1 + col * msz, 1 + row * msz, msz, msz, 1);
                    new WebMolKit.DrawMolecule(layout, metavec).draw();
                    idx++;
                }
                metavec.width = sz;
                metavec.height = sz;
                this.subgroups.preview.push(metavec);
            }
            this.buttonView.refreshBank();
        }
        prepareTemplates() {
            let idx = TemplateBank.RESOURCE_LIST.indexOf(this.group);
            let ds = TemplateBank.RESOURCE_DATA[idx];
            this.templates = { 'molecules': [], 'names': [], 'abbrev': [], 'mnemonic': [], 'preview': [] };
            let sz = this.buttonView.idealSize;
            let policy = WebMolKit.RenderPolicy.defaultBlackOnWhite();
            policy.data.pointScale = 12;
            let effects = new WebMolKit.RenderEffects();
            let measure = new WebMolKit.OutlineMeasurement(0, 0, policy.data.pointScale);
            let colMol = ds.findColByName("Molecule");
            let colName = ds.findColByName("Name");
            let colAbbrev = ds.findColByName("Abbrev");
            let colMnemonic = ds.findColByName("Mnemonic");
            for (let n = 0; n < ds.numRows; n++) {
                let mol = ds.getMolecule(n, colMol);
                this.templates.molecules.push(mol.toString());
                this.templates.names.push(ds.getString(n, colName));
                this.templates.abbrev.push(ds.getString(n, colAbbrev));
                this.templates.mnemonic.push(ds.getString(n, colMnemonic));
                let layout = new WebMolKit.ArrangeMolecule(mol, measure, policy, effects);
                layout.arrange();
                layout.squeezeInto(0, 0, sz, sz, 2);
                let metavec = new WebMolKit.MetaVector();
                new WebMolKit.DrawMolecule(layout, metavec).draw();
                metavec.width = sz;
                metavec.height = sz;
                this.templates.preview.push(metavec);
            }
            this.buttonView.refreshBank();
        }
    }
    TemplateBank.RESOURCE_LIST = null;
    TemplateBank.RESOURCE_DATA = null;
    WebMolKit.TemplateBank = TemplateBank;
    class FusionBank extends WebMolKit.ButtonBank {
        constructor(owner) {
            super();
            this.owner = owner;
        }
        update() {
            this.buttons = [];
            this.buttons.push({ 'id': 'accept', 'imageFN': 'GenericAccept', 'helpText': 'Apply this template.' });
            this.buttons.push({ 'id': 'prev', 'imageFN': 'TemplatePrev', 'helpText': 'Show previous fusion option.' });
            this.buttons.push({ 'id': 'next', 'imageFN': 'TemplateNext', 'helpText': 'Show next fusion option.' });
        }
        hitButton(id) {
            if (id == 'accept')
                this.owner.templateAccept();
            else if (id == 'prev')
                this.owner.templateRotate(-1);
            else if (id == 'next')
                this.owner.templateRotate(1);
        }
        bankClosed() {
            this.owner.clearPermutations();
        }
    }
    WebMolKit.FusionBank = FusionBank;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    const TOOLS_MAIN = [
        { 'id': 'arrow', 'imageFN': 'ToolSelect', 'helpText': 'Selection tool.', 'mnemonic': 'Escape' },
        { 'id': 'rotate', 'imageFN': 'ToolRotate', 'helpText': 'Rotate subject atoms.', 'mnemonic': 'R' },
        { 'id': 'pan', 'imageFN': 'ToolPan', 'helpText': 'Pan the viewport around the screen.', 'mnemonic': 'V' },
        { 'id': 'drag', 'imageFN': 'ToolDrag', 'helpText': 'Drag selected atoms to new positions.', 'mnemonic': 'G' },
        { 'id': 'erasor', 'imageFN': 'ToolErasor', 'helpText': 'Delete atoms or bonds by selecting.', 'mnemonic': 'Delete' },
        { 'id': 'bondOrder0', 'imageFN': 'BondZero', 'helpText': 'Create or change a bond to zero order.', 'mnemonic': '' },
        { 'id': 'bondOrder1', 'imageFN': 'BondOne', 'helpText': 'Create or change a bond to single.', 'mnemonic': 'Shift-1' },
        { 'id': 'bondOrder2', 'imageFN': 'BondTwo', 'helpText': 'Create or change a bond to double.', 'mnemonic': 'Shift-2' },
        { 'id': 'bondOrder3', 'imageFN': 'BondThree', 'helpText': 'Create or change a bond to triple.', 'mnemonic': 'Shift-3' },
        { 'id': 'bondUnknown', 'imageFN': 'BondSquig', 'helpText': 'Create or change a bond to unknown stereochemistry.', 'mnemonic': 'Shift-4' },
        { 'id': 'bondInclined', 'imageFN': 'BondUp', 'helpText': 'Create or change a bond to up-wedge.', 'mnemonic': 'Shift-5' },
        { 'id': 'bondDeclined', 'imageFN': 'BondDown', 'helpText': 'Create or change a bond to down-wedge.', 'mnemonic': 'Shift-6' },
        { 'id': 'ringAliph', 'imageFN': 'ToolRing', 'helpText': 'Create plain ring.', 'mnemonic': 'Shift-7' },
        { 'id': 'ringArom', 'imageFN': 'ToolArom', 'helpText': 'Create aromatic ring.', 'mnemonic': 'Shift-8' },
        { 'id': 'atomPlus', 'imageFN': 'AtomPlus', 'helpText': 'Increase charge on atom.', 'mnemonic': '' },
        { 'id': 'atomMinus', 'imageFN': 'AtomMinus', 'helpText': 'Decrease charge on atom.', 'mnemonic': '' },
        { 'id': 'elementC', 'text': 'C', 'helpText': 'Change elements to Carbon.', 'mnemonic': '' },
        { 'id': 'elementN', 'text': 'N', 'helpText': 'Change elements to Nitrogen.', 'mnemonic': '' },
        { 'id': 'elementO', 'text': 'O', 'helpText': 'Change elements to Oxygen.', 'mnemonic': '' },
        { 'id': 'elementS', 'text': 'S', 'helpText': 'Change elements to Sulfur.', 'mnemonic': '' },
        { 'id': 'elementP', 'text': 'P', 'helpText': 'Change elements to Phosphorus.', 'mnemonic': '' },
        { 'id': 'elementH', 'text': 'H', 'helpText': 'Change elements to Hydrogen.', 'mnemonic': '' },
        { 'id': 'elementF', 'text': 'F', 'helpText': 'Change elements to Fluorine.', 'mnemonic': '' },
        { 'id': 'elementCl', 'text': 'Cl', 'helpText': 'Change elements to Chlorine.', 'mnemonic': '' },
        { 'id': 'elementBr', 'text': 'Br', 'helpText': 'Change elements to Bromine.', 'mnemonic': '' },
        { 'id': 'elementA', 'text': 'A', 'helpText': 'Pick other element.', 'mnemonic': 'O' }
    ];
    class ToolBank extends WebMolKit.ButtonBank {
        constructor(owner) {
            super();
            this.owner = owner;
            this.initiallySelected = 'arrow';
        }
        update() {
            for (let btn of TOOLS_MAIN)
                this.buttons.push(btn);
            this.buttonView.setSelectedButton('arrow');
        }
        ;
        hitButton(id) {
            this.buttonView.setSelectedButton(id);
        }
        claimKey(event) {
            for (let item of TOOLS_MAIN) {
                if (WebMolKit.ButtonBank.matchKey(event, item.mnemonic)) {
                    this.hitButton(item.id);
                    return true;
                }
            }
            return false;
        }
    }
    WebMolKit.ToolBank = ToolBank;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class TabBar extends WebMolKit.Widget {
        constructor(options) {
            super();
            this.options = options;
            this.selidx = 0;
            this.buttonDiv = [];
            this.panelDiv = [];
            this.padding = 6;
            this.callbackSelect = null;
            if (!WebMolKit.hasInlineCSS('tabbar'))
                WebMolKit.installInlineCSS('tabbar', this.composeCSS());
        }
        getSelectedIndex() {
            return this.selidx;
        }
        getSelectedValue() {
            return this.options[this.selidx];
        }
        getPanel(idxOrName) {
            let idx = typeof idxOrName == 'number' ? idxOrName : this.options.indexOf(idxOrName);
            if (idx < 0)
                return null;
            return this.panelDiv[idx];
        }
        render(parent) {
            super.render(parent);
            let grid = $('<div></div>').appendTo(this.content);
            grid.css('display', 'grid');
            grid.css('align-items', 'center');
            grid.css('justify-content', 'start');
            grid.css('grid-row-gap', '0.5em');
            let columns = '[start] 1fr ';
            for (let n = 0; n < this.options.length; n++)
                columns += '[btn' + n + '] auto ';
            columns += '[btnX] 1fr [end]';
            grid.css('grid-template-columns', columns);
            let underline = $('<div></div>').appendTo(grid);
            underline.css('grid-column', 'start / end');
            underline.css('grid-row', '1');
            underline.css('border-bottom', '1px solid #C0C0C0');
            underline.css('height', '100%');
            for (let n = 0; n < this.options.length; n++) {
                let outline = $('<div class="wmk-tabbar-cell"></div>').appendTo(grid);
                outline.css('grid-column', 'btn' + n);
                outline.css('grid-row', '1');
                let btn = $('<div class="wmk-tabbar"></div>').appendTo(outline);
                btn.css('padding', this.padding + 'px');
                this.buttonDiv.push(btn);
                let panel = $('<div></div>').appendTo(grid);
                panel.css('grid-column', 'start / end');
                panel.css('grid-row', '2');
                panel.css('align-self', 'start');
                panel.css('justify-self', 'center');
                this.panelDiv.push(panel);
            }
            this.updateButtons();
        }
        clickButton(idx) {
            if (idx == this.selidx)
                return;
            this.setSelectedIndex(idx);
            if (this.callbackSelect)
                this.callbackSelect(idx, this);
        }
        setSelectedIndex(idx) {
            if (this.selidx == idx)
                return;
            this.selidx = idx;
            this.updateButtons();
        }
        setSelectedValue(val) {
            let idx = this.options.indexOf(val);
            if (idx >= 0)
                this.setSelectedIndex(idx);
        }
        updateButtons() {
            for (let n = 0; n < this.options.length && n < this.buttonDiv.length; n++) {
                let div = this.buttonDiv[n];
                let txt = this.options[n];
                if (txt.length == 0 && n == this.selidx)
                    div.text('\u00A0\u2716\u00A0');
                else if (txt.length == 0)
                    div.text('\u00A0\u00A0\u00A0');
                else
                    div.text(txt);
                div.off('mouseover');
                div.off('mouseout');
                div.off('mousedown');
                div.off('mouseup');
                div.off('mouseleave');
                div.off('mousemove');
                div.off('click');
                div.removeClass('wmk-tabbar-hover wmk-tabbar-active wmk-tabbar-unselected wmk-tabbar-selected');
                if (n != this.selidx) {
                    div.addClass('wmk-tabbar-unselected');
                    div.mouseover(() => div.addClass('wmk-tabbar-hover'));
                    div.mouseout(() => div.removeClass('wmk-tabbar-hover wmk-tabbar-active'));
                    div.mousedown(() => div.addClass('wmk-tabbar-active'));
                    div.mouseup(() => div.removeClass('wmk-tabbar-active'));
                    div.mouseleave(() => div.removeClass('wmk-tabbar-hover wmk-tabbar-active'));
                    div.mousemove(() => { return false; });
                    div.click(() => this.clickButton(n));
                }
                else
                    div.addClass('wmk-tabbar-selected');
                this.panelDiv[n].css('visibility', n == this.selidx ? 'visible' : 'hidden');
            }
        }
        composeCSS() {
            let lowlight = WebMolKit.colourCode(WebMolKit.Theme.lowlight), lowlightEdge1 = WebMolKit.colourCode(WebMolKit.Theme.lowlightEdge1), lowlightEdge2 = WebMolKit.colourCode(WebMolKit.Theme.lowlightEdge2);
            let highlight = WebMolKit.colourCode(WebMolKit.Theme.highlight), highlightEdge1 = WebMolKit.colourCode(WebMolKit.Theme.highlightEdge1), highlightEdge2 = WebMolKit.colourCode(WebMolKit.Theme.highlightEdge2);
            return `
			.wmk-tabbar
			{
				margin-bottom: 0;
				font-family: 'Open Sans', sans-serif;
				font-size: 14px;
				font-weight: normal;
				text-align: center;
				white-space: nowrap;
				vertical-align: middle;
				-ms-touch-action: manipulation; touch-action: manipulation;
				cursor: pointer;
				-webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
			}
			.wmk-tabbar-selected
			{
				color: white;
				background-color: #008FD2;
				background-image: linear-gradient(to right bottom, ${lowlightEdge1}, ${lowlightEdge2});
			}
			.wmk-tabbar-unselected
			{
				color: #333;
				background-color: white;
				background-image: linear-gradient(to right bottom, #FFFFFF, #E0E0E0);
			}
			.wmk-tabbar-table
			{
				margin: 1px;
				padding: 0;
				border-width: 0;
				border-collapse: collapse;
			}
			.wmk-tabbar-cell
			{
				margin: 0 -1px -1px 0;
				padding: 0;
				border-width: 0;
				border-width: 1px;
				border-style: solid;
				border-color: #808080;
			}
			.wmk-tabbar-hover
			{
				background-color: #808080;
				background-image: linear-gradient(to right bottom, #F0F0F0, #D0D0D0);
			}
			.wmk-tabbar-active
			{
				background-color: #00C000;
				background-image: linear-gradient(to right bottom, ${highlightEdge1}, ${highlightEdge2});
			}
		`;
        }
    }
    WebMolKit.TabBar = TabBar;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class EditAtom extends WebMolKit.Dialog {
        constructor(mol, atom, callbackApply) {
            super();
            this.atom = atom;
            this.callbackApply = callbackApply;
            this.initMol = mol;
            this.mol = mol.clone();
            this.title = 'Edit Atom';
            this.minPortionWidth = 20;
            this.maxPortionWidth = 95;
        }
        populate() {
            let buttons = this.buttons(), body = this.body();
            buttons.append(this.btnClose);
            buttons.append(' ');
            this.btnApply = $('<button class="wmk-button wmk-button-primary">Save</button>').appendTo(buttons);
            this.btnApply.click(() => {
                this.updateMolecule();
                if (this.callbackApply)
                    this.callbackApply(this);
            });
            this.tabs = new WebMolKit.TabBar(['Atom', 'Abbreviation', 'Geometry', 'Query', 'Extra']);
            this.tabs.render(body);
            this.populateAtom(this.tabs.getPanel('Atom'));
            this.populateAbbreviation(this.tabs.getPanel('Abbreviation'));
            this.populateGeometry(this.tabs.getPanel('Geometry'));
            this.populateQuery(this.tabs.getPanel('Query'));
            this.populateExtra(this.tabs.getPanel('Extra'));
        }
        populateAtom(panel) {
            let grid = $('<div></div>').appendTo(panel);
            grid.css('display', 'grid');
            grid.css('align-items', 'center');
            grid.css('justify-content', 'start');
            grid.css('grid-row-gap', '0.5em');
            grid.css('grid-column-gap', '0.5em');
            grid.css('grid-template-columns', '[start col0] auto [col1] auto [col2] auto [col3] auto [col4 end]');
            grid.append('<div style="grid-area: 1 / col0;">Symbol</div>');
            this.inputSymbol = $('<input size="20"></input>').appendTo(grid);
            this.inputSymbol.css('grid-area', '1 / col1 / auto / col4');
            grid.append('<div style="grid-area: 2 / col0;">Charge</div>');
            this.inputCharge = $('<input type="number" size="6"></input>').appendTo(grid);
            this.inputCharge.css('grid-area', '2 / col1');
            grid.append('<div style="grid-area: 2 / col2;">Unpaired</div>');
            this.inputUnpaired = $('<input type="number" size="6"></input>').appendTo(grid);
            this.inputUnpaired.css('grid-area', '2 / col3');
            grid.append('<div style="grid-area: 3 / col0;">Hydrogens</div>');
            this.optionHydrogen = new WebMolKit.OptionList(['Auto', 'Explicit']);
            this.optionHydrogen.render($('<div style="grid-area: 3 / col1 / auto / col3"></div>').appendTo(grid));
            this.inputHydrogen = $('<input type="number" size="6"></input>').appendTo(grid);
            this.inputHydrogen.css('grid-area', '3 / col3');
            grid.append('<div style="grid-area: 4 / col0;">Isotope</div>');
            this.optionIsotope = new WebMolKit.OptionList(['Natural', 'Enriched']);
            this.optionIsotope.render($('<div style="grid-area: 4 / col1 / auto / col3"></div>').appendTo(grid));
            this.inputIsotope = $('<input type="number" size="6"></input>').appendTo(grid);
            this.inputIsotope.css('grid-area', '4 / col3');
            grid.append('<div style="grid-area: 5 / col0;">Mapping</div>');
            this.inputMapping = $('<input type="number" size="6"></input>').appendTo(grid);
            this.inputMapping.css('grid-area', '5 / col1');
            grid.append('<div style="grid-area: 5 / col2;">Index</div>');
            this.inputIndex = $('<input type="number" size="6" readonly="readonly"></input>').appendTo(grid);
            this.inputIndex.css('grid-area', '5 / col3');
            grid.find('input').css('font', 'inherit');
            const mol = this.mol, atom = this.atom;
            this.inputSymbol.val(mol.atomElement(atom));
            this.inputCharge.val(mol.atomCharge(atom).toString());
            this.inputUnpaired.val(mol.atomUnpaired(atom).toString());
            this.optionHydrogen.setSelectedIndex(mol.atomHExplicit(atom) == WebMolKit.Molecule.HEXPLICIT_UNKNOWN ? 0 : 1);
            if (mol.atomHExplicit(atom) != WebMolKit.Molecule.HEXPLICIT_UNKNOWN)
                this.inputHydrogen.val(mol.atomHExplicit(atom).toString());
            this.optionIsotope.setSelectedIndex(mol.atomIsotope(atom) == WebMolKit.Molecule.ISOTOPE_NATURAL ? 0 : 1);
            if (mol.atomIsotope(atom) == WebMolKit.Molecule.ISOTOPE_NATURAL)
                this.inputIsotope.val(mol.atomIsotope(atom).toString());
            this.inputMapping.val(mol.atomMapNum(atom).toString());
            this.inputIndex.val(atom.toString());
            this.inputSymbol.focus();
        }
        populateAbbreviation(panel) {
            panel.append('Abbreviations: TODO');
        }
        populateGeometry(panel) {
            panel.append('Geometry: TODO');
        }
        populateQuery(panel) {
            panel.append('Query: TODO');
        }
        populateExtra(panel) {
            panel.append('Extra: TODO');
        }
        updateMolecule() {
            const mol = this.mol, atom = this.atom;
            let sym = this.inputSymbol.val();
            if (sym != '')
                mol.setAtomElement(atom, sym);
            let chg = parseInt(this.inputCharge.val());
            if (chg > -20 && chg < 20)
                mol.setAtomCharge(atom, chg);
            let unp = parseInt(this.inputUnpaired.val());
            if (unp >= 0 && unp < 20)
                mol.setAtomUnpaired(atom, unp);
            if (this.optionHydrogen.getSelectedIndex() == 1) {
                let hyd = parseInt(this.inputHydrogen.val());
                if (hyd >= 0 && hyd < 20)
                    mol.setAtomHExplicit(atom, hyd);
            }
            else
                mol.setAtomHExplicit(atom, WebMolKit.Molecule.HEXPLICIT_UNKNOWN);
            if (this.optionIsotope.getSelectedIndex() == 1) {
                let iso = parseInt(this.inputIsotope.val());
                if (iso >= 0 && iso < 300)
                    mol.setAtomIsotope(atom, iso);
            }
            else
                mol.setAtomIsotope(atom, WebMolKit.Molecule.ISOTOPE_NATURAL);
            let map = parseInt(this.inputMapping.val());
            if (!isNaN(map))
                mol.setAtomMapNum(atom, map);
        }
    }
    WebMolKit.EditAtom = EditAtom;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let DraggingTool;
    (function (DraggingTool) {
        DraggingTool[DraggingTool["None"] = 0] = "None";
        DraggingTool[DraggingTool["Press"] = 1] = "Press";
        DraggingTool[DraggingTool["Lasso"] = 2] = "Lasso";
        DraggingTool[DraggingTool["Pan"] = 3] = "Pan";
        DraggingTool[DraggingTool["Zoom"] = 4] = "Zoom";
        DraggingTool[DraggingTool["Rotate"] = 5] = "Rotate";
        DraggingTool[DraggingTool["Move"] = 6] = "Move";
        DraggingTool[DraggingTool["Erasor"] = 7] = "Erasor";
        DraggingTool[DraggingTool["Atom"] = 8] = "Atom";
        DraggingTool[DraggingTool["Bond"] = 9] = "Bond";
        DraggingTool[DraggingTool["Charge"] = 10] = "Charge";
        DraggingTool[DraggingTool["Ring"] = 11] = "Ring";
    })(DraggingTool || (DraggingTool = {}));
    var globalMoleculeClipboard = null;
    class Sketcher extends WebMolKit.Widget {
        constructor() {
            super();
            this.useToolBank = true;
            this.lowerToolBank = false;
            this.useCommandBank = true;
            this.lowerCommandBank = false;
            this.useTemplateBank = true;
            this.lowerTemplateBank = false;
            this.debugOutput = undefined;
            this.mol = null;
            this.policy = null;
            this.width = 0;
            this.height = 0;
            this.border = 0x808080;
            this.background = 0xF8F8F8;
            this.beenSetup = false;
            this.undoStack = [];
            this.redoStack = [];
            this.spanBackground = null;
            this.canvasUnder = null;
            this.canvasMolecule = null;
            this.canvasOver = null;
            this.divMessage = null;
            this.fadeWatermark = 0;
            this.layout = null;
            this.metavec = null;
            this.guidelines = null;
            this.toolView = null;
            this.commandView = null;
            this.templateView = null;
            this.offsetX = 0;
            this.offsetY = 0;
            this.pointScale = 1;
            this.currentAtom = 0;
            this.currentBond = 0;
            this.hoverAtom = 0;
            this.hoverBond = 0;
            this.selectedMask = null;
            this.filthy = false;
            this.dragType = DraggingTool.None;
            this.opAtom = 0;
            this.opBond = 0;
            this.opBudged = false;
            this.opShift = false;
            this.opCtrl = false;
            this.opAlt = false;
            this.toolAtomSymbol = '';
            this.toolBondOrder = 0;
            this.toolBondType = 0;
            this.toolChargeDelta = 0;
            this.toolRingArom = false;
            this.toolRingFreeform = false;
            this.toolRotateIncr = 0;
            this.lassoX = null;
            this.lassoY = null;
            this.lassoMask = null;
            this.clickX = 0;
            this.clickY = 0;
            this.mouseX = 0;
            this.mouseY = 0;
            this.dragGuides = null;
            this.templatePerms = null;
            this.currentPerm = 0;
            this.fusionBank = null;
            this.proxyClip = null;
        }
        setSize(width, height) {
            this.width = width;
            this.height = height;
        }
        defineMolecule(mol, withAutoScale = true, withStashUndo = false) {
            if (withStashUndo)
                this.stashUndo();
            this.stopTemplateFusion();
            this.mol = mol.clone();
            this.guidelines = [];
            for (let n = 1; n <= this.mol.numAtoms; n++) {
                for (let sprout of WebMolKit.SketchUtil.guidelineSprouts(this.mol, n))
                    this.guidelines.push(sprout);
            }
            if (!this.beenSetup)
                return;
            this.layout = null;
            this.metavec = null;
            this.hoverAtom = 0;
            this.hoverBond = 0;
            if (!withAutoScale) {
                let effects = this.sketchEffects();
                this.layout = new WebMolKit.ArrangeMolecule(this.mol, this, this.policy, effects);
                this.layout.arrange();
                this.metavec = new WebMolKit.MetaVector();
                new WebMolKit.DrawMolecule(this.layout, this.metavec).draw();
                this.delayedRedraw();
            }
            else
                this.autoScale();
        }
        defineClipboard(proxy) {
            this.proxyClip = proxy;
            proxy.copyEvent = () => {
                return this.getMolecule.toString();
            };
            proxy.pasteEvent = (proxy) => {
                this.pasteText(proxy.getString());
                return true;
            };
            if (this.container)
                proxy.install(this.container);
        }
        defineMoleculeString(molsk, withAutoScale, withStashUndo) {
            this.defineMolecule(WebMolKit.Molecule.fromString(molsk), withAutoScale, withStashUndo);
        }
        defineRenderPolicy(policy) {
            this.policy = policy;
            this.pointScale = policy.data.pointScale;
        }
        clearMolecule() { this.defineMolecule(new WebMolKit.Molecule(), true, true); }
        getMolecule() { return this.mol.clone(); }
        setup(callback) {
            WebMolKit.ButtonView.prepare(() => {
                this.beenSetup = true;
                if (this.mol == null)
                    this.mol = new WebMolKit.Molecule();
                if (this.policy == null) {
                    this.policy = WebMolKit.RenderPolicy.defaultColourOnWhite();
                    this.pointScale = this.policy.data.pointScale;
                }
                let effects = this.sketchEffects();
                this.layout = new WebMolKit.ArrangeMolecule(this.mol, this, this.policy, effects);
                this.layout.arrange();
                this.centreAndShrink();
                this.metavec = new WebMolKit.MetaVector();
                new WebMolKit.DrawMolecule(this.layout, this.metavec).draw();
                if (callback)
                    callback();
            });
        }
        render(parent) {
            if (!this.width || !this.height)
                throw 'Sketcher.render called without width and height';
            super.render(parent);
            this.container = $('<div></div>').appendTo(this.content);
            this.container.attr('style', 'position: relative; width: ' + this.width + 'px; height: ' + this.height + 'px;');
            this.container.css('background-color', WebMolKit.colourCanvas(this.background));
            this.container.css('border', '1px solid ' + WebMolKit.colourCanvas(this.border));
            this.container.css('border-radius', '4px');
            this.container.css('outline', 'none');
            this.container.attr('tabindex', '0');
            this.container.focus();
            let canvasStyle = 'position: absolute; left: 0; top: 0;';
            canvasStyle += ' pointer-events: none;';
            this.canvasUnder = WebMolKit.newElement(this.container, 'canvas', { 'width': this.width, 'height': this.height, 'style': canvasStyle });
            this.canvasMolecule = WebMolKit.newElement(this.container, 'canvas', { 'width': this.width, 'height': this.height, 'style': canvasStyle });
            this.canvasOver = WebMolKit.newElement(this.container, 'canvas', { 'width': this.width, 'height': this.height, 'style': canvasStyle });
            this.divMessage = $('<div></div>').appendTo(this.container);
            this.divMessage.attr('style', canvasStyle);
            this.divMessage.css('width', this.width + 'px');
            this.divMessage.css('height', this.height + 'px');
            this.divMessage.css('text-align', 'center');
            this.divMessage.css('vertical-align', 'middle');
            this.divMessage.css('font-weight', 'bold');
            this.divMessage.css('font-size', '120%');
            this.centreAndShrink();
            this.redraw();
            let reserveHeight = 0;
            if (this.useCommandBank) {
                this.commandView = new WebMolKit.ButtonView('bottom', 0, 0, this.width, this.height);
                if (this.lowerCommandBank)
                    this.commandView.lowerBank();
                this.commandView.setHasBigButtons(false);
                this.commandView.pushBank(new WebMolKit.CommandBank(this));
                this.commandView.render(this.container);
                reserveHeight = this.commandView.height;
            }
            if (this.useToolBank) {
                this.toolView = new WebMolKit.ButtonView('left', 0, 0, this.width, this.height - reserveHeight);
                if (this.lowerToolBank)
                    this.toolView.lowerBank();
                this.toolView.setHasBigButtons(false);
                this.toolView.pushBank(new WebMolKit.ToolBank(this));
                this.toolView.render(this.container);
            }
            if (this.useTemplateBank) {
                this.templateView = new WebMolKit.ButtonView('right', 0, 0, this.width, this.height - reserveHeight);
                if (this.lowerTemplateBank)
                    this.templateView.lowerBank();
                this.templateView.setHasBigButtons(true);
                this.templateView.pushBank(new WebMolKit.TemplateBank(this, null));
                this.templateView.render(this.container);
            }
            this.container.click((event) => this.mouseClick(event));
            this.container.dblclick((event) => this.mouseDoubleClick(event));
            this.container.mousedown((event) => this.mouseDown(event));
            this.container.mouseup((event) => this.mouseUp(event));
            this.container.mouseover((event) => this.mouseOver(event));
            this.container.mouseout((event) => this.mouseOut(event));
            this.container.mousemove((event) => this.mouseMove(event));
            this.container.keypress((event) => this.keyPressed(event));
            this.container.keydown((event) => this.keyDown(event));
            this.container.keyup((event) => this.keyUp(event));
            this.container[0].addEventListener('dragover', (event) => {
                event.stopPropagation();
                event.preventDefault();
                event.dataTransfer.dropEffect = 'copy';
            });
            this.container[0].addEventListener('drop', (event) => {
                event.stopPropagation();
                event.preventDefault();
                this.dropInto(event.dataTransfer);
            });
            if (this.proxyClip)
                this.proxyClip.install(this.container);
        }
        changeSize(width, height) {
            if (width == this.width && height == this.height)
                return;
            this.width = width;
            this.height = height;
            for (let widget of [this.container, this.canvasUnder, this.canvasMolecule, this.canvasOver]) {
                $(widget).css('width', width + 'px');
                $(widget).css('height', height + 'px');
            }
            for (let btnv of [this.commandView, this.toolView, this.templateView])
                if (btnv) {
                    btnv.setParentSize(width, height);
                    btnv.refreshBank();
                }
            this.autoScale();
        }
        showMessage(msg, isError = false) {
            let watermark = ++this.fadeWatermark;
            this.divMessage.css('color', isError ? '#FF0000' : '#008000');
            this.divMessage.text(msg);
            let szLeft = (this.toolView == null ? 0 : this.toolView.width) + 2;
            let szRight = (this.templateView == null ? 0 : this.templateView.width) + 2;
            let szBottom = (this.commandView == null ? 0 : this.commandView.height) + 2;
            this.divMessage.css('left', szLeft + 'px');
            this.divMessage.css('width', (this.width - szLeft - szRight) + 'px');
            this.divMessage.css('height', (this.height - szBottom) + 'px');
            window.setTimeout(() => {
                if (watermark == this.fadeWatermark)
                    this.divMessage.text('');
            }, 5000);
        }
        clearMessage() {
            if (this.divMessage.text() == '')
                return;
            this.fadeWatermark++;
            this.divMessage.text('');
        }
        autoScale() {
            this.pointScale = this.policy.data.pointScale;
            let effects = this.sketchEffects();
            this.layout = new WebMolKit.ArrangeMolecule(this.mol, this, this.policy, effects);
            this.layout.arrange();
            this.centreAndShrink();
            this.metavec = new WebMolKit.MetaVector();
            new WebMolKit.DrawMolecule(this.layout, this.metavec).draw();
            this.layoutTemplatePerm();
            this.delayedRedraw();
        }
        anySelected() {
            if (this.selectedMask == null)
                return false;
            for (let n = 0; n < this.selectedMask.length; n++)
                if (this.selectedMask[n])
                    return true;
            return false;
        }
        getSelected(N) {
            if (this.selectedMask == null || N > this.selectedMask.length)
                return false;
            return this.selectedMask[N - 1];
        }
        setSelected(N, sel) {
            if (this.selectedMask == null) {
                this.selectedMask = new Array(this.mol.numAtoms);
                for (let n = this.selectedMask.length - 1; n >= 0; n--)
                    this.selectedMask[n] = false;
            }
            while (this.selectedMask.length < this.mol.numAtoms) {
                this.selectedMask.push(false);
            }
            this.selectedMask[N - 1] = sel;
            this.delayedRedraw();
        }
        clearSubject() {
            if (this.currentAtom == 0 && this.currentBond == 0 && WebMolKit.Vec.allFalse(this.selectedMask))
                return;
            this.currentAtom = 0;
            this.currentBond = 0;
            this.selectedMask = WebMolKit.Vec.booleanArray(false, this.mol.numAtoms);
            this.delayedRedraw();
        }
        getLassoed(N) {
            if (this.lassoMask == null || N > this.lassoMask.length)
                return false;
            return this.lassoMask[N - 1];
        }
        getState() {
            let state = {
                'mol': this.mol.clone(),
                'currentAtom': this.currentAtom,
                'currentBond': this.currentBond,
                'selectedMask': this.selectedMask == null ? null : this.selectedMask.slice(0)
            };
            return state;
        }
        setState(state, withStashUndo = true) {
            if (withStashUndo)
                this.stashUndo();
            this.stopTemplateFusion();
            if (state.mol != null)
                this.defineMolecule(state.mol.clone(), false, withStashUndo);
            if (state.currentAtom >= 0)
                this.currentAtom = state.currentAtom;
            if (state.currentBond >= 0)
                this.currentBond = state.currentBond;
            if (state.selectedMask != null)
                this.selectedMask = state.selectedMask == null ? null : state.selectedMask.slice(0);
            this.delayedRedraw();
        }
        stashUndo() {
            if (this.undoStack.length == 0 && this.mol.numAtoms == 0)
                return;
            let state = this.getState();
            this.undoStack.push(state);
            while (this.undoStack.length > Sketcher.UNDO_SIZE) {
                this.undoStack.splice(0, 1);
            }
            this.redoStack = [];
        }
        setPermutations(perms) {
            this.templatePerms = perms;
            this.pickTemplatePermutation(0);
            this.fusionBank = new WebMolKit.FusionBank(this);
            this.templateView.pushBank(this.fusionBank);
            if (this.mol.numAtoms == 0)
                this.centreAndShrink();
        }
        stopTemplateFusion() {
            if (this.fusionBank != null)
                this.templateView.popBank();
        }
        clearPermutations() {
            if (this.templatePerms == null)
                return;
            this.templatePerms = null;
            this.delayedRedraw();
            this.fusionBank = null;
        }
        templateAccept() {
            let mol = WebMolKit.Molecule.fromString(this.templatePerms[this.currentPerm].mol);
            this.templateView.popBank();
            this.defineMolecule(mol, false, true);
        }
        templateRotate(dir) {
            let idx = (this.currentPerm + dir) % this.templatePerms.length;
            if (idx < 0)
                idx += this.templatePerms.length;
            this.pickTemplatePermutation(idx);
        }
        canUndo() { return this.undoStack.length > 0; }
        canRedo() { return this.redoStack.length > 0; }
        performUndo() {
            if (this.undoStack.length == 0)
                return;
            let state = this.getState();
            this.redoStack.push(state);
            this.setState(this.undoStack.pop(), false);
        }
        performRedo() {
            if (this.redoStack.length == 0)
                return;
            let state = this.getState();
            this.undoStack.push(state);
            this.setState(this.redoStack.pop(), false);
        }
        performCopy(mol) {
            if (!mol)
                mol = this.getMolecule();
            globalMoleculeClipboard = mol.clone();
            let cookies = new WebMolKit.Cookies();
            if (cookies.numMolecules() > 0)
                cookies.stashMolecule(mol);
            if (this.proxyClip)
                this.proxyClip.setString(mol.toString());
        }
        performCopySelection(andCut) {
            new WebMolKit.MoleculeActivity(this, andCut ? WebMolKit.ActivityType.Cut : WebMolKit.ActivityType.Copy, {}).execute();
        }
        performPaste() {
            if (this.proxyClip && this.proxyClip.canAlwaysGet()) {
                let txt = this.proxyClip.getString();
                if (txt != null) {
                    let mol = WebMolKit.MoleculeStream.readUnknown(txt);
                    if (mol) {
                        this.pasteMolecule(mol);
                        return;
                    }
                }
            }
            let cookies = new WebMolKit.Cookies();
            if (cookies.numMolecules() == 0) {
                if (WebMolKit.MolUtil.notBlank(globalMoleculeClipboard))
                    this.pasteMolecule(globalMoleculeClipboard);
                return;
            }
            let dlg = new WebMolKit.PickRecent(cookies, 1);
            dlg.callbackPick1 = (mol) => this.pasteMolecule(mol);
            dlg.open();
        }
        zoom(mag) {
            let cx = 0.5 * this.width, cy = 0.5 * this.height;
            let newScale = Math.min(10 * this.policy.data.pointScale, Math.max(0.1 * this.policy.data.pointScale, this.pointScale * mag));
            if (newScale == this.pointScale)
                return;
            this.offsetX = cx - (newScale / this.pointScale) * (cx - this.offsetX);
            this.offsetY = cy - (newScale / this.pointScale) * (cy - this.offsetY);
            this.pointScale = newScale;
            let effects = this.sketchEffects();
            this.layout = new WebMolKit.ArrangeMolecule(this.mol, this, this.policy, effects);
            this.layout.arrange();
            this.metavec = new WebMolKit.MetaVector();
            new WebMolKit.DrawMolecule(this.layout, this.metavec).draw();
            this.layoutTemplatePerm();
            this.delayedRedraw();
        }
        pasteText(str) {
            let mol = WebMolKit.MoleculeStream.readUnknown(str);
            if (mol != null)
                this.pasteMolecule(mol);
            else
                alert('Text from clipboard is not a valid molecule.');
        }
        pasteMolecule(mol) {
            if (this.mol.numAtoms == 0) {
                this.defineMolecule(mol, true, true);
                return;
            }
            let param = { 'fragNative': mol.toString() };
            new WebMolKit.MoleculeActivity(this, WebMolKit.ActivityType.TemplateFusion, param).execute();
        }
        pickTemplatePermutation(idx) {
            let perm = this.templatePerms[idx];
            this.currentPerm = idx;
            this.layoutTemplatePerm();
            this.delayedRedraw();
        }
        scale() { return this.pointScale; }
        angToX(ax) {
            return ax * this.pointScale + this.offsetX;
        }
        angToY(ay) {
            return ay * -this.pointScale + this.offsetY;
        }
        xToAng(px) {
            return (px - this.offsetX) / this.pointScale;
        }
        yToAng(py) {
            return (py - this.offsetY) / -this.pointScale;
        }
        scaleToAng(scale) { return scale / this.pointScale; }
        angToScale(ang) { return ang * this.pointScale; }
        yIsUp() { return false; }
        measureText(str, fontSize) { return WebMolKit.FontData.main.measureText(str, fontSize); }
        pasteEvent(e) {
            let wnd = window;
            if (wnd.clipboardData && wnd.clipboardData.getData)
                this.pasteText(wnd.clipboardData.getData('Text'));
            else if (e.clipboardData && e.clipboardData.getData)
                this.pasteText(e.clipboardData.getData('text/plain'));
            e.preventDefault();
            return false;
        }
        centreAndShrink() {
            if (this.mol.numAtoms == 0 || this.layout == null) {
                this.offsetX = 0.5 * this.width;
                this.offsetY = 0.5 * this.height;
                this.pointScale = this.policy.data.pointScale;
                return;
            }
            let bounds = this.layout.determineBoundary(0);
            let limW = this.width - 6, limH = this.height - 6;
            let natW = bounds[2] - bounds[0], natH = bounds[3] - bounds[1];
            let scale = 1;
            if (natW > limW) {
                let down = limW / natW;
                scale *= down;
                natW *= down;
                natH *= down;
            }
            if (natH > limH) {
                let down = limH / natH;
                scale *= down;
                natW *= down;
                natH *= down;
            }
            if (scale < 1) {
                this.pointScale *= scale;
                this.layout.offsetEverything(this.offsetX * scale, this.offsetY * scale);
                this.layout.scaleEverything(scale);
                bounds = this.layout.determineBoundary(0);
            }
            let dx = 0.5 * (limW - natW) - bounds[0], dy = 0.5 * (limH - natH) - bounds[1];
            this.offsetX += dx;
            this.offsetY += dy;
            this.layout.offsetEverything(dx, dy);
        }
        layoutTemplatePerm() {
            if (this.currentPerm < 0 || this.templatePerms == null)
                return;
            let perm = this.templatePerms[this.currentPerm];
            let tpolicy = new WebMolKit.RenderPolicy(this.policy.data);
            tpolicy.data.foreground = 0x808080;
            tpolicy.data.atomCols = tpolicy.data.atomCols.slice(0);
            for (let n in tpolicy.data.atomCols)
                tpolicy.data.atomCols[n] = 0x808080;
            let effects = new WebMolKit.RenderEffects();
            let layout = new WebMolKit.ArrangeMolecule(WebMolKit.Molecule.fromString(perm.display), this, tpolicy, effects);
            layout.arrange();
            perm.metavec = new WebMolKit.MetaVector();
            new WebMolKit.DrawMolecule(layout, perm.metavec).draw();
        }
        redraw() {
            this.filthy = false;
            this.redrawUnder();
            this.redrawMolecule();
            this.redrawOver();
        }
        redrawUnder() {
            let HOVER_COL = 0xE0E0E0;
            let CURRENT_COL = 0xA0A0A0, CURRENT_BORD = 0x808080;
            let SELECT_COL = 0xC0C0C0;
            let LASSO_COL = 0xD0D0D0;
            let density = WebMolKit.pixelDensity();
            this.canvasUnder.width = this.width * density;
            this.canvasUnder.height = this.height * density;
            this.canvasUnder.style.width = this.width + 'px';
            this.canvasUnder.style.height = this.height + 'px';
            let ctx = this.canvasUnder.getContext('2d');
            ctx.save();
            ctx.scale(density, density);
            ctx.clearRect(0, 0, this.width, this.height);
            if (this.hoverAtom > 0) {
                let sz = 0;
                if (this.hoverAtom == this.currentAtom)
                    sz += 0.1;
                if (this.getSelected(this.hoverAtom))
                    sz += 0.1;
                if (this.currentBond > 0 && (this.mol.bondFrom(this.currentBond) == this.hoverAtom || this.mol.bondTo(this.currentBond) == this.hoverAtom))
                    sz += 0.1;
                this.drawAtomShade(ctx, this.hoverAtom, HOVER_COL, -1, sz);
            }
            if (this.hoverBond > 0) {
                let sz = 0, bfr = this.mol.bondFrom(this.hoverBond), bto = this.mol.bondTo(this.hoverBond);
                if (this.hoverBond == this.currentBond)
                    sz += 0.1;
                if (this.getSelected(bfr) && this.getSelected(bto))
                    sz += 0.1;
                this.drawBondShade(ctx, this.hoverBond, HOVER_COL, -1, sz);
            }
            for (let n = 1; n <= this.mol.numBonds; n++) {
                let sz = n == this.currentBond ? 0.1 : 0;
                let bfr = this.mol.bondFrom(n), bto = this.mol.bondTo(n);
                let sfr = this.getSelected(bfr), sto = this.getSelected(bto), lfr = this.getLassoed(bfr), lto = this.getLassoed(bto);
                if (sfr && sto)
                    this.drawBondShade(ctx, n, SELECT_COL, -1, sz);
                else if ((sfr || lfr) && (sto || lto))
                    this.drawBondShade(ctx, n, LASSO_COL, -1, sz);
            }
            for (let n = 1; n <= this.mol.numAtoms; n++) {
                let sz = this.currentAtom == n ? 0.1 : 0;
                if (this.getSelected(n))
                    this.drawAtomShade(ctx, n, SELECT_COL, -1, sz);
                else if (this.getLassoed(n))
                    this.drawAtomShade(ctx, n, LASSO_COL, -1, sz);
            }
            if (this.currentAtom > 0) {
                this.drawAtomShade(ctx, this.currentAtom, CURRENT_COL, CURRENT_BORD, 0);
            }
            if (this.currentBond > 0) {
                let bfr = this.mol.bondFrom(this.currentBond), bto = this.mol.bondTo(this.currentBond);
                this.drawBondShade(ctx, this.currentBond, CURRENT_COL, CURRENT_BORD, 0);
            }
            if (this.dragType == DraggingTool.Move || (this.dragType == DraggingTool.Atom && this.opAtom > 0) || this.dragType == DraggingTool.Bond) {
                if (this.dragGuides != null && this.dragGuides.length > 0) {
                    for (let g of this.dragGuides)
                        for (let n = 0; n < g.x.length; n++) {
                            let lw = this.policy.data.lineSize * this.pointScale;
                            ctx.strokeStyle = '#C0C0C0';
                            ctx.lineWidth = lw;
                            WebMolKit.drawLine(ctx, g.sourceX, g.sourceY, g.destX[n], g.destY[n]);
                            ctx.beginPath();
                            ctx.ellipse(g.destX[n], g.destY[n], 2 * lw, 2 * lw, 0, 0, WebMolKit.TWOPI, false);
                            ctx.fillStyle = '#C0C0C0';
                            ctx.fill();
                        }
                }
            }
            if (this.dragType == DraggingTool.Ring) {
                let [ringX, ringY] = this.determineFauxRing();
                let rsz = ringX == null ? 0 : ringX.length;
                if (rsz > 0) {
                    let scale = this.pointScale;
                    let lw = this.policy.data.lineSize * scale;
                    ctx.strokeStyle = '#C0C0C0';
                    ctx.lineWidth = lw;
                    for (let n = 0; n < rsz; n++) {
                        let nn = n < rsz - 1 ? n + 1 : 0;
                        let x1 = this.angToX(ringX[n]), y1 = this.angToY(ringY[n]);
                        let x2 = this.angToX(ringX[nn]), y2 = this.angToY(ringY[nn]);
                        WebMolKit.drawLine(ctx, x1, y1, x2, y2);
                    }
                    if (this.toolRingArom) {
                        let cx = 0, cy = 0;
                        for (let n = 0; n < rsz; n++) {
                            cx += ringX[n];
                            cy += ringY[n];
                        }
                        cx /= rsz;
                        cy /= rsz;
                        let rad = 0;
                        for (let n = 0; n < rsz; n++)
                            rad += WebMolKit.norm_xy(ringX[n] - cx, ringY[n] - cy);
                        rad = this.angToScale(rad * 0.5 / rsz);
                        ctx.beginPath();
                        ctx.ellipse(this.angToX(cx), this.angToY(cy), rad, rad, 0, 0, WebMolKit.TWOPI, false);
                        ctx.stroke();
                    }
                }
            }
            ctx.restore();
        }
        redrawMolecule() {
            let density = WebMolKit.pixelDensity();
            this.canvasMolecule.width = this.width * density;
            this.canvasMolecule.height = this.height * density;
            this.canvasMolecule.style.width = this.width + 'px';
            this.canvasMolecule.style.height = this.height + 'px';
            let ctx = this.canvasMolecule.getContext('2d');
            ctx.save();
            ctx.scale(density, density);
            ctx.clearRect(0, 0, this.width, this.height);
            if (this.metavec != null)
                this.metavec.renderContext(ctx);
            if (this.templatePerms != null) {
                let perm = this.templatePerms[this.currentPerm];
                if (perm.metavec != null)
                    perm.metavec.renderContext(ctx);
            }
            ctx.restore();
        }
        redrawOver() {
            let density = WebMolKit.pixelDensity();
            this.canvasOver.width = this.width * density;
            this.canvasOver.height = this.height * density;
            this.canvasOver.style.width = this.width + 'px';
            this.canvasOver.style.height = this.height + 'px';
            let ctx = this.canvasOver.getContext('2d');
            ctx.save();
            ctx.scale(density, density);
            ctx.clearRect(0, 0, this.width, this.height);
            if ((this.dragType == DraggingTool.Lasso || this.dragType == DraggingTool.Erasor) && this.lassoX.length > 1) {
                let erasing = this.dragType == DraggingTool.Erasor;
                let path = new Path2D();
                path.moveTo(this.lassoX[0], this.lassoY[0]);
                for (let n = 1; n < this.lassoX.length; n++)
                    path.lineTo(this.lassoX[n], this.lassoY[n]);
                path.closePath();
                ctx.fillStyle = WebMolKit.colourCanvas(erasing ? 0xD0FF0000 : 0xF0000000);
                ctx.fill(path);
                ctx.strokeStyle = erasing ? '#804040' : '#808080';
                ctx.lineWidth = 0.5;
                ctx.stroke(path);
            }
            if (this.dragType == DraggingTool.Rotate) {
                let [x0, y0, theta, magnitude] = this.determineDragTheta();
                let scale = this.pointScale;
                let lw = this.policy.data.lineSize * scale;
                ctx.strokeStyle = '#E0E0E0';
                ctx.lineWidth = 0.5 * lw;
                WebMolKit.drawLine(ctx, x0, y0, x0 + magnitude, y0);
                ctx.strokeStyle = '#808080';
                ctx.lineWidth = lw;
                WebMolKit.drawLine(ctx, x0, y0, x0 + magnitude * Math.cos(theta), y0 + magnitude * Math.sin(theta));
                ctx.beginPath();
                ctx.ellipse(x0, y0, 2 * lw, 2 * lw, 0, 0, WebMolKit.TWOPI, false);
                ctx.fillStyle = '#808080';
                ctx.fill();
                for (let atom of this.subjectAtoms(true, false)) {
                    let ax = this.angToX(this.mol.atomX(atom)), ay = this.angToY(this.mol.atomY(atom));
                    let ang = Math.atan2(ay - y0, ax - x0), dist = WebMolKit.norm_xy(ax - x0, ay - y0);
                    let nx = x0 + dist * Math.cos(ang + theta), ny = y0 + dist * Math.sin(ang + theta);
                    ctx.beginPath();
                    ctx.ellipse(nx, ny, 2 * lw, 2 * lw, 0, 0, WebMolKit.TWOPI, false);
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }
            }
            if (this.dragType == DraggingTool.Move) {
                let [dx, dy] = this.determineMoveDelta();
                let scale = this.pointScale;
                let lw = this.policy.data.lineSize * scale;
                for (let atom of this.subjectAtoms(false, true)) {
                    let ax = this.angToX(this.mol.atomX(atom)), ay = this.angToY(this.mol.atomY(atom));
                    ctx.beginPath();
                    ctx.ellipse(ax + dx, ay + dy, 2 * lw, 2 * lw, 0, 0, WebMolKit.TWOPI, false);
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }
            }
            if ((this.dragType == DraggingTool.Atom && this.opAtom > 0) || this.dragType == DraggingTool.Bond) {
                let element = this.dragType == DraggingTool.Atom ? this.toolAtomSymbol : 'C';
                let order = this.dragType == DraggingTool.Bond ? this.toolBondOrder : 1;
                let type = this.dragType == DraggingTool.Bond ? this.toolBondType : WebMolKit.Molecule.BONDTYPE_NORMAL;
                this.drawOriginatingBond(ctx, element, order, type);
            }
            ctx.restore();
        }
        delayedRedraw() {
            if (this.canvasMolecule == null)
                return;
            this.filthy = true;
            window.setTimeout(() => { if (this.filthy)
                this.redraw(); }, 10);
        }
        pickObject(x, y) {
            if (this.layout == null)
                return 0;
            if (this.toolView != null) {
                let pos1 = this.container.position(), pos2 = this.toolView.content.position();
                if (this.toolView.withinOutline(x + pos1.left - pos2.left, y + pos1.top - pos2.top))
                    return 0;
            }
            if (this.commandView != null) {
                let pos1 = this.container.position(), pos2 = this.commandView.content.position();
                if (this.toolView.withinOutline(x + pos1.left - pos2.left, y + pos1.top - pos2.top))
                    return 0;
            }
            if (this.templateView != null) {
                let pos1 = this.container.position(), pos2 = this.templateView.content.position();
                if (this.toolView.withinOutline(x + pos1.left - pos2.left, y + pos1.top - pos2.top))
                    return 0;
            }
            let limitDSQ = WebMolKit.sqr(0.5 * this.pointScale);
            let bestItem = 0, bestDSQ;
            for (let n = 0; n < this.layout.numPoints(); n++) {
                let p = this.layout.getPoint(n);
                if (p.anum == 0)
                    continue;
                let dx = Math.abs(x - p.oval.cx), dy = Math.abs(y - p.oval.cy);
                let dsq = WebMolKit.norm2_xy(dx, dy);
                if (dsq > limitDSQ)
                    continue;
                if (bestItem == 0 || dsq < bestDSQ) {
                    bestItem = p.anum;
                    bestDSQ = dsq;
                }
            }
            for (let n = 0; n < this.layout.numLines(); n++) {
                let l = this.layout.getLine(n);
                if (l.bnum == 0)
                    continue;
                let x1 = l.line.x1, y1 = l.line.y1;
                let x2 = l.line.x2, y2 = l.line.y2;
                let bondDSQ = WebMolKit.norm2_xy(x2 - x1, y2 - y1) * 0.25;
                let dsq = WebMolKit.norm2_xy(x - 0.5 * (x1 + x2), y - 0.5 * (y1 + y2));
                if (dsq > bondDSQ)
                    continue;
                if (bestItem == 0 || dsq < bestDSQ) {
                    bestItem = -l.bnum;
                    bestDSQ = dsq;
                }
            }
            return bestItem;
        }
        log(str, zap) {
            if (this.debugOutput) {
                if (zap)
                    this.debugOutput.value = '';
                this.debugOutput.value = this.debugOutput.value + '' + str + '\n';
            }
        }
        drawAtomShade(ctx, atom, fillCol, borderCol, anghalo) {
            if (this.layout == null)
                return;
            let p = undefined;
            for (let n = 0; n < this.layout.numPoints(); n++)
                if (this.layout.getPoint(n).anum == atom) {
                    p = this.layout.getPoint(n);
                    break;
                }
            if (p == null)
                return;
            let minRad = 0.2 * this.pointScale, minRadSq = WebMolKit.sqr(minRad);
            let cx = p.oval.cx, cy = p.oval.cy;
            let rad = Math.max(minRad, Math.max(p.oval.rw, p.oval.rh)) + (0.1 + anghalo) * this.pointScale;
            if (fillCol != -1) {
                ctx.beginPath();
                ctx.ellipse(cx, cy, rad, rad, 0, 0, WebMolKit.TWOPI, true);
                ctx.fillStyle = WebMolKit.colourCanvas(fillCol);
                ctx.fill();
            }
            if (borderCol != -1) {
                ctx.beginPath();
                ctx.ellipse(cx, cy, rad, rad, 0, 0, WebMolKit.TWOPI, true);
                ctx.strokeStyle = WebMolKit.colourCanvas(borderCol);
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }
        drawBondShade(ctx, bond, fillCol, borderCol, anghalo) {
            if (this.layout == null)
                return;
            let x1 = 0, y1 = 0, x2 = 0, y2 = 0, nb = 0, sz = 0;
            for (let n = 0; n < this.layout.numLines(); n++) {
                let l = this.layout.getLine(n);
                if (l.bnum != bond)
                    continue;
                x1 += l.line.x1;
                y1 += l.line.y1;
                x2 += l.line.x2;
                y2 += l.line.y2;
                nb++;
                sz += l.size + (0.2 + anghalo) * this.pointScale;
            }
            if (nb == 0)
                return;
            let invNB = 1 / nb;
            sz *= invNB;
            x1 *= invNB;
            y1 *= invNB;
            x2 *= invNB;
            y2 *= invNB;
            let dx = x2 - x1, dy = y2 - y1, invDist = 1 / WebMolKit.norm_xy(dx, dy);
            dx *= invDist;
            dy *= invDist;
            let ox = dy, oy = -dx;
            let path = new Path2D(), mx, my, CIRC = 0.8;
            path.moveTo(x1 + ox * sz, y1 + oy * sz);
            mx = x1 + (ox * sz - dx * sz) * CIRC;
            my = y1 + (oy * sz - dy * sz) * CIRC;
            path.quadraticCurveTo(mx, my, x1 - dx * sz, y1 - dy * sz);
            mx = x1 + (-ox * sz - dx * sz) * CIRC;
            my = y1 + (-oy * sz - dy * sz) * CIRC;
            path.quadraticCurveTo(mx, my, x1 - ox * sz, y1 - oy * sz);
            path.lineTo(x2 - ox * sz, y2 - oy * sz);
            mx = x2 + (-ox * sz + dx * sz) * CIRC;
            my = y2 + (-oy * sz + dy * sz) * CIRC;
            path.quadraticCurveTo(mx, my, x2 + dx * sz, y2 + dy * sz);
            mx = x2 + (ox * sz + dx * sz) * CIRC;
            my = y2 + (oy * sz + dy * sz) * CIRC;
            path.quadraticCurveTo(mx, my, x2 + ox * sz, y2 + oy * sz);
            path.closePath();
            if (fillCol != -1) {
                ctx.beginPath();
                ctx.fillStyle = WebMolKit.colourCanvas(fillCol);
                ctx.fill(path);
            }
            if (borderCol != -1) {
                ctx.beginPath();
                ctx.strokeStyle = WebMolKit.colourCanvas(borderCol);
                ctx.lineWidth = 1;
                ctx.stroke(path);
            }
        }
        drawOriginatingBond(ctx, element, order, type) {
            let x1 = this.clickX, y1 = this.clickY;
            if (this.opAtom > 0) {
                x1 = this.angToX(this.mol.atomX(this.opAtom));
                y1 = this.angToY(this.mol.atomY(this.opAtom));
            }
            let x2 = this.mouseX, y2 = this.mouseY;
            let snapTo = this.snapToGuide(x2, y2);
            if (snapTo != null) {
                x2 = snapTo[0];
                y2 = snapTo[1];
            }
            let scale = this.pointScale;
            ctx.strokeStyle = '#808080';
            ctx.lineWidth = this.policy.data.lineSize * scale;
            WebMolKit.drawLine(ctx, x1, y1, x2, y2);
            if (element != 'C') {
                let fh = this.policy.data.fontSize * scale;
                ctx.font = WebMolKit.fontSansSerif(fh);
                let metrics = ctx.measureText(element);
                ctx.fillStyle = '#808080';
                ctx.fillText(element, x2 - 0.5 * metrics.width, y2 + 0.5 * fh);
            }
        }
        updateHoverCursor(event) {
            let tool = 'finger';
            if (this.toolView != null)
                tool = this.toolView.selectedButton;
            let toolApplies = tool != 'finger' && tool != 'pan' && tool != 'zoom' && tool != 'rotate';
            let mouseObj = 0;
            if (this.dragType == DraggingTool.None && toolApplies) {
                let xy = WebMolKit.eventCoords(event, this.container);
                mouseObj = this.pickObject(xy[0], xy[1]);
            }
            let mouseAtom = mouseObj > 0 ? mouseObj : 0, mouseBond = mouseObj < 0 ? -mouseObj : 0;
            if (mouseAtom != this.hoverAtom || mouseBond != this.hoverBond) {
                this.hoverAtom = mouseAtom;
                this.hoverBond = mouseBond;
                this.delayedRedraw();
            }
        }
        updateLasso(event) {
            if (this.dragType != DraggingTool.Lasso && this.dragType != DraggingTool.Erasor)
                return;
            let xy = WebMolKit.eventCoords(event, this.container);
            if (xy[0] < 0 || xy[1] < 0 || xy[0] > this.width || xy[1] > this.height) {
                this.dragType = DraggingTool.None;
                this.lassoX = null;
                this.lassoY = null;
                this.lassoMask = null;
                this.delayedRedraw();
            }
            let len = this.lassoX.length;
            if (len > 0 && this.lassoX[len - 1] == xy[0] && this.lassoY[len - 1] == xy[1])
                return;
            this.lassoX.push(xy[0]);
            this.lassoY.push(xy[1]);
            this.calculateLassoMask();
            this.delayedRedraw();
        }
        calculateLassoMask() {
            this.lassoMask = new Array(this.mol.numAtoms);
            for (let n = 0; n < this.mol.numAtoms; n++)
                this.lassoMask[n] = false;
            for (let n = 0; n < this.layout.numPoints(); n++) {
                let p = this.layout.getPoint(n);
                if (p.anum == 0)
                    continue;
                this.lassoMask[p.anum - 1] = WebMolKit.GeomUtil.pointInPolygon(p.oval.cx, p.oval.cy, this.lassoX, this.lassoY);
            }
        }
        determineDragGuide(order) {
            if (this.opAtom == 0) {
                let g = {
                    'atom': 0,
                    'orders': [order],
                    'x': [],
                    'y': [],
                    'sourceX': this.clickX,
                    'sourceY': this.clickY,
                    'destX': [],
                    'destY': []
                };
                let mx = this.xToAng(this.clickX), my = this.yToAng(this.clickY);
                for (let n = 0; n < 12; n++) {
                    let theta = WebMolKit.TWOPI * n / 12;
                    let dx = WebMolKit.Molecule.IDEALBOND * Math.cos(theta), dy = WebMolKit.Molecule.IDEALBOND * Math.sin(theta);
                    g.x.push(mx + dx);
                    g.y.push(my + dy);
                    g.destX.push(this.clickX + dx * this.pointScale);
                    g.destY.push(this.clickY - dy * this.pointScale);
                }
                return [g];
            }
            if (this.guidelines == null)
                return null;
            let best = null, single = null;
            for (let n = 0; n < this.guidelines.length; n++) {
                let g = this.guidelines[n];
                if (g.atom != this.opAtom)
                    continue;
                if (g.orders.indexOf(order) >= 0) {
                    best = g;
                    break;
                }
                if (g.orders.indexOf(1) >= 0)
                    single = g;
            }
            if (best == null)
                best = single;
            if (best == null)
                return;
            let g = WebMolKit.clone(best);
            g.sourceX = this.angToX(this.mol.atomX(g.atom));
            g.sourceY = this.angToY(this.mol.atomY(g.atom));
            g.destX = [];
            g.destY = [];
            for (let n = 0; n < g.x.length; n++) {
                g.destX.push(this.angToX(g.x[n]));
                g.destY.push(this.angToY(g.y[n]));
            }
            return [g];
        }
        determineMoveGuide() {
            let subj = this.subjectAtoms(false, true);
            if (subj.length == 0 || subj.length == this.mol.numAtoms)
                return null;
            let guides = [];
            for (let n = 0; n < this.guidelines.length; n++) {
                let g = this.guidelines[n];
                if (g.orders.indexOf(1) < 0 || subj.indexOf(g.atom) >= 0)
                    continue;
                g = WebMolKit.clone(g);
                g.sourceX = this.angToX(this.mol.atomX(g.atom));
                g.sourceY = this.angToY(this.mol.atomY(g.atom));
                g.destX = [];
                g.destY = [];
                for (let i = 0; i < g.x.length; i++) {
                    g.destX.push(this.angToX(g.x[i]));
                    g.destY.push(this.angToY(g.y[i]));
                }
                guides.push(g);
            }
            return guides;
        }
        determineDragTheta() {
            let x0 = this.clickX, y0 = this.clickY;
            let snap = this.snapToGuide(x0, y0);
            if (snap != null) {
                x0 = snap[0];
                y0 = snap[1];
            }
            let theta = Math.atan2(this.mouseY - y0, this.mouseX - x0), magnitude = WebMolKit.norm_xy(this.mouseX - x0, this.mouseY - y0);
            if (this.toolRotateIncr > 0)
                theta = Math.round(theta / this.toolRotateIncr) * this.toolRotateIncr;
            return [x0, y0, theta, magnitude];
        }
        determineMoveDelta() {
            let x1 = this.clickX, y1 = this.clickY, x2 = this.mouseX, y2 = this.mouseY;
            if (this.opAtom > 0) {
                x1 = this.angToX(this.mol.atomX(this.opAtom));
                y1 = this.angToY(this.mol.atomY(this.opAtom));
                let snap = this.snapToGuide(x2, y2);
                if (snap != null) {
                    x2 = snap[0];
                    y2 = snap[1];
                }
            }
            return [x2 - x1, y2 - y1];
        }
        determineFauxRing() {
            let atom = this.opAtom, bond = this.opBond, mol = this.mol;
            let x1 = atom > 0 ? mol.atomX(atom) : bond > 0 ? 0.5 * (mol.atomX(mol.bondFrom(bond)) + mol.atomX(mol.bondTo(bond))) : this.xToAng(this.clickX);
            let y1 = atom > 0 ? mol.atomY(atom) : bond > 0 ? 0.5 * (mol.atomY(mol.bondFrom(bond)) + mol.atomY(mol.bondTo(bond))) : this.yToAng(this.clickY);
            let x2 = this.xToAng(this.mouseX), y2 = this.yToAng(this.mouseY), dx = x2 - x1, dy = y2 - y1;
            let rsz = Math.min(9, Math.round(WebMolKit.norm_xy(dx, dy) * 2 / WebMolKit.Molecule.IDEALBOND) + 2);
            if (rsz < 3) { }
            else if (bond > 0) {
                return WebMolKit.SketchUtil.proposeBondRing(mol, rsz, bond, dx, dy);
            }
            else if (atom > 0 && mol.atomAdjCount(atom) > 0 && !this.toolRingFreeform) {
                return WebMolKit.SketchUtil.proposeAtomRing(mol, rsz, atom, dx, dy);
            }
            else {
                return WebMolKit.SketchUtil.proposeNewRing(mol, rsz, x1, y1, dx, dy, !this.toolRingFreeform);
            }
            return [null, null];
        }
        snapToGuide(x, y) {
            let bestDSQ = Number.POSITIVE_INFINITY, bestX = 0, bestY = 0;
            const APPROACH = WebMolKit.sqr(0.5 * this.pointScale);
            if (this.dragGuides != null)
                for (let i = 0; i < this.dragGuides.length; i++)
                    for (let j = 0; j < this.dragGuides[i].x.length; j++) {
                        let px = this.dragGuides[i].destX[j], py = this.dragGuides[i].destY[j];
                        let dsq = WebMolKit.norm2_xy(px - x, py - y);
                        if (dsq < APPROACH && dsq < bestDSQ) {
                            bestDSQ = dsq;
                            bestX = px;
                            bestY = py;
                        }
                    }
            for (let n = 1; n <= this.mol.numAtoms; n++) {
                let px = this.angToX(this.mol.atomX(n)), py = this.angToY(this.mol.atomY(n));
                let dsq = WebMolKit.norm2_xy(px - x, py - y);
                if (dsq < APPROACH && dsq < bestDSQ) {
                    bestDSQ = dsq;
                    bestX = px;
                    bestY = py;
                }
            }
            if (isFinite(bestDSQ))
                return [bestX, bestY];
            return null;
        }
        subjectAtoms(allIfNone = false, useOpAtom = false) {
            let atoms = [];
            if (this.selectedMask != null) {
                for (let n = 0; n < this.selectedMask.length; n++)
                    if (this.selectedMask[n])
                        atoms.push(n + 1);
                if (atoms.length > 0)
                    return atoms;
            }
            if (this.currentAtom > 0)
                atoms.push(this.currentAtom);
            else if (this.currentBond > 0) {
                atoms.push(this.mol.bondFrom(this.currentBond));
                atoms.push(this.mol.bondTo(this.currentBond));
            }
            if (useOpAtom && atoms.length == 0 && this.opAtom > 0)
                atoms.push(this.opAtom);
            if (allIfNone && atoms.length == 0) {
                for (let n = 1; n <= this.mol.numAtoms; n++)
                    atoms.push(n);
            }
            return atoms;
        }
        mouseClick(event) {
            this.container.focus();
        }
        mouseDoubleClick(event) {
            event.preventDefault();
            let xy = WebMolKit.eventCoords(event, this.container);
            let clickObj = this.pickObject(xy[0], xy[1]);
            if (clickObj > 0) {
                let atom = clickObj;
                let dlg = new WebMolKit.EditAtom(this.mol, this.opAtom, () => {
                    if (this.mol.compareTo(dlg.mol) != 0)
                        this.defineMolecule(dlg.mol);
                    dlg.close();
                });
                dlg.open();
            }
            else {
                let bond = -clickObj;
            }
        }
        mouseDown(event) {
            event.preventDefault();
            this.clearMessage();
            this.dragType = DraggingTool.Press;
            this.opBudged = false;
            this.dragGuides = null;
            let xy = WebMolKit.eventCoords(event, this.container);
            this.mouseX = xy[0];
            this.mouseY = xy[1];
            this.clickX = xy[0];
            this.clickY = xy[1];
            let clickObj = this.pickObject(xy[0], xy[1]);
            this.opAtom = clickObj > 0 ? clickObj : 0;
            this.opBond = clickObj < 0 ? -clickObj : 0;
            this.opShift = event.shiftKey;
            this.opCtrl = event.ctrlKey;
            this.opAlt = event.altKey;
            let tool = 'finger';
            if (this.toolView != null)
                tool = this.toolView.selectedButton;
            if (tool == 'arrow') {
                if (!this.opShift && !this.opCtrl && !this.opAlt) {
                    this.dragType = DraggingTool.Press;
                }
                else if (!this.opShift && this.opCtrl && !this.opAlt) {
                }
                else if (!this.opShift && !this.opCtrl && this.opAlt) {
                    this.dragType = DraggingTool.Pan;
                }
                else if (!this.opShift && this.opCtrl && this.opAlt) {
                    this.dragType = DraggingTool.Zoom;
                }
            }
            else if (tool == 'rotate') {
                this.dragType = DraggingTool.Rotate;
                this.toolRotateIncr = this.opShift ? 0 : 15 * WebMolKit.DEGRAD;
            }
            else if (tool == 'pan') {
                this.dragType = DraggingTool.Pan;
            }
            else if (tool == 'drag') {
                this.dragType = DraggingTool.Move;
                if (this.opAtom > 0)
                    this.dragGuides = this.determineMoveGuide();
                this.delayedRedraw();
            }
            else if (tool == 'erasor') {
                this.dragType = DraggingTool.Erasor;
                this.lassoX = [xy[0]];
                this.lassoY = [xy[1]];
                this.lassoMask = [];
            }
            else if (tool == 'ringAliph') {
                this.dragType = DraggingTool.Ring;
                this.toolRingArom = false;
                this.toolRingFreeform = this.opShift;
            }
            else if (tool == 'ringArom') {
                this.dragType = DraggingTool.Ring;
                this.toolRingArom = true;
                this.toolRingFreeform = this.opShift;
            }
            else if (tool == 'atomPlus') {
                this.dragType = DraggingTool.Charge;
                this.toolChargeDelta = 1;
            }
            else if (tool == 'atomMinus') {
                this.dragType = DraggingTool.Charge;
                this.toolChargeDelta = -1;
            }
            else if (tool.startsWith('bond')) {
                this.dragType = DraggingTool.Bond;
                this.toolBondOrder = 1;
                this.toolBondType = WebMolKit.Molecule.BONDTYPE_NORMAL;
                if (tool == 'bondOrder0')
                    this.toolBondOrder = 0;
                else if (tool == 'bondOrder2')
                    this.toolBondOrder = 2;
                else if (tool == 'bondOrder3')
                    this.toolBondOrder = 3;
                else if (tool == 'bondUnknown')
                    this.toolBondType = WebMolKit.Molecule.BONDTYPE_UNKNOWN;
                else if (tool == 'bondInclined')
                    this.toolBondType = WebMolKit.Molecule.BONDTYPE_INCLINED;
                else if (tool == 'bondDeclined')
                    this.toolBondType = WebMolKit.Molecule.BONDTYPE_DECLINED;
                this.dragGuides = this.determineDragGuide(this.toolBondOrder);
            }
            else if (tool.startsWith('element')) {
                this.dragType = DraggingTool.Atom;
                this.toolAtomSymbol = tool.substring(7);
                this.dragGuides = this.determineDragGuide(1);
            }
        }
        mouseUp(event) {
            if (!this.opBudged) {
                let xy = WebMolKit.eventCoords(event, this.container);
                let clickObj = this.pickObject(xy[0], xy[1]);
                let clickAtom = clickObj > 0 ? clickObj : 0, clickBond = clickObj < 0 ? -clickObj : 0;
                if (this.dragType == DraggingTool.Press) {
                    if (!this.opShift && !this.opCtrl && !this.opAlt) {
                        if (clickAtom == 0 && clickBond == 0) {
                            if (WebMolKit.Vec.anyTrue(this.selectedMask))
                                this.selectedMask = null;
                            else if (this.currentAtom > 0)
                                this.currentAtom = 0;
                            else if (this.currentBond > 0)
                                this.currentBond = 0;
                        }
                        else if (clickAtom != this.currentAtom || clickBond != this.currentBond) {
                            this.currentAtom = clickAtom;
                            this.currentBond = clickBond;
                            this.delayedRedraw();
                        }
                        else if (clickAtom == 0 && clickBond == 0 && this.anySelected()) {
                            this.selectedMask = null;
                            this.delayedRedraw();
                        }
                    }
                    else if (this.opShift && !this.opCtrl && !this.opAlt) {
                    }
                }
                else if (this.dragType == DraggingTool.Erasor) {
                    if (this.opAtom > 0 || this.opBond > 0) {
                        let override = {
                            'currentAtom': this.opAtom,
                            'currentBond': this.opBond,
                            'selectedMask': []
                        };
                        let molact = new WebMolKit.MoleculeActivity(this, WebMolKit.ActivityType.Delete, {}, override);
                        molact.execute();
                    }
                }
                else if (this.dragType == DraggingTool.Atom) {
                    let element = this.toolAtomSymbol;
                    if (element == 'A') {
                        let dlg = new WebMolKit.EditAtom(this.mol, this.opAtom, () => {
                            if (this.mol.compareTo(dlg.mol) != 0)
                                this.defineMolecule(dlg.mol);
                            dlg.close();
                        });
                        dlg.open();
                    }
                    else if (element) {
                        let param = { 'element': element, 'keepAbbrev': true };
                        if (this.opAtom == 0) {
                            let x = this.xToAng(this.clickX), y = this.yToAng(this.clickY);
                            if (this.mol.numAtoms == 0) {
                                this.offsetX = this.clickX;
                                this.offsetY = this.clickY;
                                x = 0;
                                y = 0;
                            }
                            param.positionX = x;
                            param.positionY = y;
                        }
                        let override = {
                            'currentAtom': this.opAtom,
                            'currentBond': 0,
                            'selectedMask': null
                        };
                        let molact = new WebMolKit.MoleculeActivity(this, WebMolKit.ActivityType.Element, param, override);
                        molact.execute();
                    }
                }
                else if (this.dragType == DraggingTool.Charge) {
                    if (this.opAtom > 0 || this.opBond > 0) {
                        let override = {
                            'currentAtom': this.opAtom,
                            'currentBond': this.opBond,
                            'selectedMask': null
                        };
                        let molact = new WebMolKit.MoleculeActivity(this, WebMolKit.ActivityType.Charge, { 'delta': this.toolChargeDelta }, override);
                        molact.execute();
                    }
                }
                else if (this.dragType == DraggingTool.Bond) {
                    let override = {
                        'currentAtom': this.opAtom,
                        'currentBond': this.opBond,
                        'selectedMask': null
                    };
                    let molact;
                    if (this.toolBondType == WebMolKit.Molecule.BONDTYPE_NORMAL)
                        molact = new WebMolKit.MoleculeActivity(this, WebMolKit.ActivityType.BondOrder, { 'order': this.toolBondOrder }, override);
                    else
                        molact = new WebMolKit.MoleculeActivity(this, WebMolKit.ActivityType.BondType, { 'type': this.toolBondType }, override);
                    molact.execute();
                }
            }
            else {
                if (this.dragType == DraggingTool.Lasso) {
                    if (this.lassoX.length >= 2) {
                        this.calculateLassoMask();
                        for (let n = 1; n <= this.mol.numAtoms; n++)
                            if (this.getLassoed(n) && !this.getSelected(n))
                                this.setSelected(n, true);
                    }
                    this.lassoX = null;
                    this.lassoY = null;
                    this.lassoMask = null;
                    this.delayedRedraw();
                }
                else if (this.dragType == DraggingTool.Erasor) {
                    let any = false;
                    for (let n = 0; n < this.lassoMask.length; n++)
                        if (this.lassoMask[n]) {
                            any = true;
                            break;
                        }
                    if (any) {
                        let override = {
                            'currentAtom': 0,
                            'currentBond': 0,
                            'selectedMask': this.lassoMask
                        };
                        let molact = new WebMolKit.MoleculeActivity(this, WebMolKit.ActivityType.Delete, {}, override);
                        molact.execute();
                    }
                }
                else if (this.dragType == DraggingTool.Rotate) {
                    let [x0, y0, theta, magnitude] = this.determineDragTheta();
                    let degrees = -theta * WebMolKit.DEGRAD;
                    let mx = this.xToAng(x0), my = this.yToAng(y0);
                    let molact = new WebMolKit.MoleculeActivity(this, WebMolKit.ActivityType.Rotate, { 'theta': degrees, 'centreX': mx, 'centreY': my });
                    molact.execute();
                }
                else if (this.dragType == DraggingTool.Move) {
                    let [dx, dy] = this.determineMoveDelta();
                    let scale = this.pointScale;
                    let molact = new WebMolKit.MoleculeActivity(this, WebMolKit.ActivityType.Move, { 'refAtom': this.opAtom, 'deltaX': dx / scale, 'deltaY': -dy / scale });
                    molact.execute();
                }
                else if (this.dragType == DraggingTool.Ring) {
                    let [ringX, ringY] = this.determineFauxRing();
                    if (ringX != null) {
                        let param = {
                            'ringX': ringX,
                            'ringY': ringY,
                            'aromatic': this.toolRingArom
                        };
                        let molact = new WebMolKit.MoleculeActivity(this, WebMolKit.ActivityType.Ring, param);
                        molact.execute();
                    }
                }
                else if (this.dragType == DraggingTool.Atom && this.opAtom > 0) {
                    let x2 = this.mouseX, y2 = this.mouseY;
                    let snapTo = this.snapToGuide(x2, y2);
                    if (snapTo != null) {
                        x2 = snapTo[0];
                        y2 = snapTo[1];
                    }
                    let param = {
                        'order': 1,
                        'type': WebMolKit.Molecule.BONDTYPE_NORMAL,
                        'element': this.toolAtomSymbol,
                        'x1': this.mol.atomX(this.opAtom),
                        'y1': this.mol.atomY(this.opAtom),
                        'x2': this.xToAng(x2),
                        'y2': this.yToAng(y2)
                    };
                    if (this.toolAtomSymbol == 'A')
                        param.element = window.prompt('Enter element symbol:', '');
                    if (param.element != '') {
                        let molact = new WebMolKit.MoleculeActivity(this, WebMolKit.ActivityType.BondAtom, param);
                        molact.execute();
                    }
                }
                else if (this.dragType == DraggingTool.Bond) {
                    let x2 = this.mouseX, y2 = this.mouseY;
                    let snapTo = this.snapToGuide(x2, y2);
                    if (snapTo != null) {
                        x2 = snapTo[0];
                        y2 = snapTo[1];
                    }
                    let param = {
                        'order': this.toolBondOrder,
                        'type': this.toolBondType,
                        'element': "C",
                        'x1': this.opAtom == 0 ? this.xToAng(this.clickX) : this.mol.atomX(this.opAtom),
                        'y1': this.opAtom == 0 ? this.yToAng(this.clickY) : this.mol.atomY(this.opAtom),
                        'x2': this.xToAng(x2),
                        'y2': this.yToAng(y2)
                    };
                    let molact = new WebMolKit.MoleculeActivity(this, WebMolKit.ActivityType.BondAtom, param);
                    molact.execute();
                }
            }
            this.dragType = DraggingTool.None;
            this.lassoX = null;
            this.lassoY = null;
            this.lassoMask = null;
            this.dragGuides = null;
            this.delayedRedraw();
        }
        mouseOver(event) {
            this.updateHoverCursor(event);
            this.updateLasso(event);
        }
        mouseOut(event) {
            this.updateHoverCursor(event);
            this.updateLasso(event);
        }
        mouseMove(event) {
            this.updateHoverCursor(event);
            if (this.dragType == DraggingTool.None)
                return;
            let xy = WebMolKit.eventCoords(event, this.container);
            if (!this.opBudged) {
                let dx = xy[0] - this.clickX, dy = xy[1] - this.clickY;
                if (dx * dx + dy * dy > 2 * 2)
                    this.opBudged = true;
            }
            if (this.dragType == DraggingTool.Press && this.opAtom == 0 && this.opBond == 0 && this.opBudged) {
                this.dragType = DraggingTool.Lasso;
                this.lassoX = [xy[0]];
                this.lassoY = [xy[1]];
                this.lassoMask = [];
            }
            if (this.dragType == DraggingTool.Lasso || this.dragType == DraggingTool.Erasor) {
                this.updateLasso(event);
            }
            else if (this.dragType == DraggingTool.Pan) {
                let xy = WebMolKit.eventCoords(event, this.container);
                let dx = xy[0] - this.mouseX, dy = xy[1] - this.mouseY;
                if (dx != 0 || dy != 0) {
                    this.offsetX += dx;
                    this.offsetY += dy;
                    this.layout.offsetEverything(dx, dy);
                    this.metavec.transformPrimitives(dx, dy, 1, 1);
                    if (this.currentPerm >= 0 && this.templatePerms != null) {
                        let perm = this.templatePerms[this.currentPerm];
                        perm.metavec.transformPrimitives(dx, dy, 1, 1);
                    }
                    this.delayedRedraw();
                }
                this.mouseX = xy[0];
                this.mouseY = xy[1];
            }
            else if (this.dragType == DraggingTool.Zoom) {
                let xy = WebMolKit.eventCoords(event, this.container);
                let dy = xy[1] - this.mouseY;
                if (dy != 0) {
                    dy = Math.min(50, Math.max(-50, dy));
                    let newScale = this.pointScale * (1 - dy * 0.01);
                    newScale = Math.min(10, Math.max(0.1, newScale));
                    let newOX = this.clickX - (newScale / this.pointScale) * (this.clickX - this.offsetX);
                    let newOY = this.clickY - (newScale / this.pointScale) * (this.clickY - this.offsetY);
                    this.pointScale = newScale;
                    this.offsetX = newOX;
                    this.offsetY = newOY;
                    this.delayedRedraw();
                }
                this.mouseX = xy[0];
                this.mouseY = xy[1];
            }
            else if (this.dragType == DraggingTool.Rotate ||
                this.dragType == DraggingTool.Move ||
                this.dragType == DraggingTool.Atom ||
                this.dragType == DraggingTool.Bond ||
                this.dragType == DraggingTool.Ring) {
                this.mouseX = xy[0];
                this.mouseY = xy[1];
                this.delayedRedraw();
            }
        }
        keyPressed(event) {
            if (this.toolView != null && this.toolView.topBank.claimKey(event)) {
                event.preventDefault();
                return;
            }
            if (this.commandView != null && this.commandView.topBank.claimKey(event)) {
                event.preventDefault();
                return;
            }
            if (this.templateView != null && this.templateView.topBank.claimKey(event)) {
                event.preventDefault();
                return;
            }
        }
        keyDown(event) {
            let key = event.keyCode;
            if (key == 27) {
                for (let view of [this.templateView, this.commandView, this.toolView])
                    if (view != null && view.stackSize > 1) {
                        view.popBank();
                        event.preventDefault();
                        return;
                    }
            }
            if (key == 13) { }
            else if (key == 37) { }
            else if (key == 39) { }
            else if (key == 38) { }
            else if (key == 40) { }
            else if ([27, 8, 46].indexOf(key) >= 0) {
                if (this.toolView != null && this.toolView.topBank.claimKey(event)) {
                    event.preventDefault();
                    return;
                }
                if (this.commandView != null && this.commandView.topBank.claimKey(event)) {
                    event.preventDefault();
                    return;
                }
                if (this.templateView != null && this.templateView.topBank.claimKey(event)) {
                    event.preventDefault();
                    return;
                }
            }
        }
        keyUp(event) {
        }
        mouseWheel(event) {
        }
        dropInto(transfer) {
            let items = transfer.items, files = transfer.files;
            const SUFFIXES = ['.el', '.mol'];
            const MIMES = ['text/plain', 'chemical/x-sketchel', 'x-mdl-molfile'];
            for (let n = 0; n < items.length; n++) {
                if (items[n].kind == 'string' && MIMES.indexOf(items[n].type) >= 0) {
                    items[n].getAsString((str) => {
                        let mol = WebMolKit.Molecule.fromString(str);
                        if (mol != null) {
                            this.defineMolecule(mol, true, true);
                        }
                        else
                            console.log('Dragged data is not a SketchEl molecule: ' + str);
                    });
                    return;
                }
            }
            for (let n = 0; n < files.length; n++) {
                for (let sfx of SUFFIXES)
                    if (files[n].name.endsWith(sfx)) {
                        let reader = new FileReader();
                        reader.onload = (event) => {
                            let str = reader.result;
                            let mol = WebMolKit.MoleculeStream.readUnknown(str.toString());
                            if (mol != null) {
                                this.defineMolecule(mol, true, true);
                            }
                            else
                                console.log('Dragged file is not a recognised molecule: ' + str);
                        };
                        reader.readAsText(files[n]);
                        return;
                    }
            }
        }
        sketchEffects() {
            let effects = new WebMolKit.RenderEffects();
            for (let n = 1; n <= this.mol.numAtoms; n++)
                if (WebMolKit.MolUtil.hasAbbrev(this.mol, n))
                    effects.dottedRectOutline[n] = 0x808080;
            return effects;
        }
    }
    Sketcher.UNDO_SIZE = 20;
    WebMolKit.Sketcher = Sketcher;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class EditCompound extends WebMolKit.Dialog {
        constructor(mol) {
            super();
            this.mol = mol;
            this.sketcher = new WebMolKit.Sketcher();
            this.callbackSave = null;
            this.title = 'Edit Compound';
            this.minPortionWidth = 20;
            this.maxPortionWidth = 95;
        }
        onSave(callback) {
            this.callbackSave = callback;
        }
        getMolecule() { return this.sketcher.getMolecule(); }
        defineClipboard(proxy) {
            this.sketcher.defineClipboard(proxy);
        }
        populate() {
            let buttons = this.buttons(), body = this.body();
            this.btnClear = $('<button class="wmk-button wmk-button-default">Clear</button>').appendTo(buttons);
            this.btnClear.click(() => this.sketcher.clearMolecule());
            buttons.append(' ');
            this.btnCopy = $('<button class="wmk-button wmk-button-default">Copy</button>').appendTo(buttons);
            this.btnCopy.click(() => this.actionCopy());
            buttons.append(' ');
            buttons.append(this.btnClose);
            buttons.append(' ');
            this.btnSave = $('<button class="wmk-button wmk-button-primary">Save</button>').appendTo(buttons);
            this.btnSave.click(() => { if (this.callbackSave)
                this.callbackSave(this); });
            let skw = 800, skh = 650;
            let skdiv = $('<div></div>').appendTo(this.body());
            skdiv.css('width', skw + 'px');
            skdiv.css('height', skh + 'px');
            this.sketcher.setSize(skw, skh);
            this.sketcher.defineMolecule(this.mol);
            this.sketcher.setup(() => this.sketcher.render(skdiv));
        }
        actionCopy() {
            this.sketcher.performCopySelection(false);
        }
        actionCut() {
            this.sketcher.performCopySelection(true);
        }
        actionPaste() {
            this.sketcher.performPaste();
        }
        actionUndo() {
            this.sketcher.performUndo();
        }
        actionRedo() {
            this.sketcher.performRedo();
        }
    }
    WebMolKit.EditCompound = EditCompound;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class MapReaction extends WebMolKit.Dialog {
        constructor(mol1, mol2) {
            super();
            this.callbackSave = null;
            this.rawvec1 = null;
            this.metavec1 = null;
            this.arrmol1 = null;
            this.transform1 = null;
            this.rawvec2 = null;
            this.metavec2 = null;
            this.arrmol2 = null;
            this.transform2 = null;
            this.scale = 1;
            this.ARROWWIDTH = 30;
            this.COLCYCLE = ['#89A54E', '#71588F', '#4198AF', '#DB843D', '#93A9CF', '#D19392', '#4572A7', '#AA4643'];
            this.highlighted = [0, 0];
            this.pressed = [0, 0];
            this.mol1 = mol1.clone();
            this.mol2 = mol2.clone();
            this.policy = WebMolKit.RenderPolicy.defaultBlackOnWhite();
            this.policy.data.pointScale = 40;
            this.title = "Map Reaction Atoms";
            this.minPortionWidth = 20;
            this.maxPortionWidth = 95;
        }
        getMolecule1() { return this.mol1; }
        getMolecule2() { return this.mol2; }
        populate() {
            let buttons = this.buttons(), body = this.body();
            this.btnClear = $('<button class="button button-default">Clear</button>').appendTo(buttons);
            this.btnClear.click(() => this.clearAllMappings());
            buttons.append(' ');
            buttons.append(this.btnClose);
            buttons.append(' ');
            this.btnSave = $('<button class="button button-primary">Save</button>').appendTo(buttons);
            this.btnSave.click(() => { if (this.callbackSave)
                this.callbackSave(this); });
            WebMolKit.Func.arrangeMolecule({ 'policy': this.policy.data, 'molNative': this.mol1.toString() }, (result, error) => {
                this.arrmol1 = result.arrmol;
                this.rawvec1 = result.metavec;
                this.metavec1 = new WebMolKit.MetaVector(result.metavec);
                this.transform1 = result.transform;
                WebMolKit.Func.arrangeMolecule({ 'policy': this.policy.data, 'molNative': this.mol2.toString() }, (result, error) => {
                    this.arrmol2 = result.arrmol;
                    this.rawvec2 = result.metavec;
                    this.metavec2 = new WebMolKit.MetaVector(result.metavec);
                    this.transform2 = result.transform;
                    this.setupPanel();
                });
            });
        }
        setupPanel() {
            let maxWidth = 0.9 * $(window).width(), maxHeight = 0.8 * $(window).height();
            this.padding = 1 * this.policy.data.pointScale;
            let scale1 = (maxWidth - this.ARROWWIDTH) / (this.metavec1.width + this.metavec2.width + 4 * this.padding);
            let scale2 = maxHeight / (this.metavec1.height + 2 * this.padding);
            let scale3 = maxHeight / (this.metavec2.height + 2 * this.padding);
            this.scale = Math.min(1, Math.min(scale1, Math.min(scale2, scale3)));
            this.canvasW = Math.ceil((this.metavec1.width + this.metavec2.width + 4 * this.padding) * this.scale + this.ARROWWIDTH);
            this.canvasH = Math.ceil((Math.max(this.metavec1.height, this.metavec2.height) + 2 * this.padding) * this.scale);
            this.offsetX1 = this.padding * this.scale;
            this.offsetY1 = 0.5 * (this.canvasH - this.metavec1.height * this.scale);
            this.offsetX2 = (this.metavec1.width + 3 * this.padding) * this.scale + this.ARROWWIDTH;
            this.offsetY2 = 0.5 * (this.canvasH - this.metavec2.height * this.scale);
            let div = $('<div></div>').appendTo(this.body());
            div.css('position', 'relative');
            div.css('width', this.canvasW + 'px');
            div.css('height', this.canvasH + 'px');
            let density = WebMolKit.pixelDensity();
            let styleCanvas = 'position: absolute; left: 0; top: 0; width: ' + this.canvasW + 'px; height: ' + this.canvasH + 'px;';
            let styleOverlay = styleCanvas + 'pointer-events: none;';
            this.canvas = WebMolKit.newElement(div, 'canvas', { 'width': this.canvasW * density, 'height': this.canvasH * density, 'style': styleCanvas });
            let ctx = this.canvas.getContext('2d');
            ctx.scale(density, density);
            this.redrawCanvas();
            $(this.canvas).mousedown((event) => { event.preventDefault(); this.mouseDown(event); });
            $(this.canvas).mouseup((event) => { this.mouseUp(event); });
            $(this.canvas).mouseenter((event) => { this.mouseEnter(event); });
            $(this.canvas).mouseleave((event) => { this.mouseLeave(event); });
            $(this.canvas).mousemove((event) => { this.mouseMove(event); });
            this.drawnMols = WebMolKit.newElement(div, 'canvas', { 'width': this.canvasW * density, 'height': this.canvasH * density, 'style': styleOverlay });
            ctx = this.drawnMols.getContext('2d');
            ctx.scale(density, density);
            let draw = new WebMolKit.MetaVector(this.rawvec1);
            draw.offsetX = this.offsetX1;
            draw.offsetY = this.offsetY1;
            draw.scale = this.scale;
            draw.renderContext(ctx);
            draw = new WebMolKit.MetaVector(this.rawvec2);
            draw.offsetX = this.offsetX2;
            draw.offsetY = this.offsetY2;
            draw.scale = this.scale;
            draw.renderContext(ctx);
            this.bump();
        }
        redrawCanvas() {
            let ctx = this.canvas.getContext('2d');
            let w = this.canvasW, h = this.canvasH;
            ctx.clearRect(0, 0, w, h);
            let arrowX1 = (2 * this.padding + this.metavec1.width) * this.scale;
            let arrowX2 = arrowX1 + this.ARROWWIDTH;
            let arrowY = 0.5 * this.canvasH;
            ctx.beginPath();
            ctx.moveTo(arrowX1, arrowY);
            ctx.lineTo(arrowX2 - 2, arrowY);
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(arrowX2, arrowY);
            ctx.lineTo(arrowX2 - 8, arrowY - 5);
            ctx.lineTo(arrowX2 - 8, arrowY + 5);
            ctx.fillStyle = 'black';
            ctx.fill();
            this.drawHighlights(ctx, 1, this.highlighted[0] == 1 ? this.highlighted[1] : 0);
            this.drawHighlights(ctx, 2, this.highlighted[0] == 2 ? this.highlighted[1] : 0);
            if (this.pressed[0] > 0) {
                let compatMask = this.compatibilityMask(this.pressed[0], this.pressed[1]);
                ctx.strokeStyle = '#808080';
                ctx.lineWidth = 1;
                if (this.pressed[0] == 1) {
                    for (let n = 1; n <= this.mol2.numAtoms; n++)
                        if (compatMask[n - 1]) {
                            let [cx, cy, rw, rh] = this.getAtomPos(2, n);
                            ctx.beginPath();
                            ctx.ellipse(cx, cy, rw, rh, 0, 0, WebMolKit.TWOPI, false);
                            ctx.stroke();
                        }
                }
                else {
                    for (let n = 1; n <= this.mol1.numAtoms; n++)
                        if (compatMask[n - 1]) {
                            let [cx, cy, rw, rh] = this.getAtomPos(1, n);
                            ctx.beginPath();
                            ctx.ellipse(cx, cy, rw, rh, 0, 0, WebMolKit.TWOPI, false);
                            ctx.stroke();
                        }
                }
                let [cx1, cy1, rw1, rh1] = this.getAtomPos(this.pressed[0], this.pressed[1]);
                ctx.beginPath();
                ctx.ellipse(cx1, cy1, rw1, rh1, 0, 0, WebMolKit.TWOPI, false);
                ctx.fillStyle = '#808080';
                ctx.fill();
                let dx = this.dragToX, dy = this.dragToY;
                let dest = this.pickAtom(dx, dy, this.pressed[0] == 2 ? compatMask : null, this.pressed[0] == 1 ? compatMask : null);
                if (dest[0] == 3 - this.pressed[0]) {
                    let [cx2, cy2, rw2, rh2] = this.getAtomPos(dest[0], dest[1]);
                    ctx.beginPath();
                    ctx.ellipse(cx2, cy2, rw2, rh2, 0, 0, WebMolKit.TWOPI, false);
                    ctx.fillStyle = '#808080';
                    ctx.fill();
                    dx = cx2;
                    dy = cy2;
                }
                ctx.beginPath();
                ctx.moveTo(cx1, cy1);
                ctx.lineTo(dx, dy);
                ctx.strokeStyle = '#808080';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }
        drawHighlights(ctx, side, highlight) {
            const mol = side == 1 ? this.mol1 : this.mol2;
            const arrmol = side == 1 ? this.arrmol1 : this.arrmol2;
            const offsetX = side == 1 ? this.offsetX1 : this.offsetX2;
            const offsetY = side == 1 ? this.offsetY1 : this.offsetY2;
            const scale = this.scale;
            for (let n = 1; n <= mol.numAtoms; n++) {
                let mapnum = mol.atomMapNum(n);
                if (mapnum == 0 && n != highlight)
                    continue;
                let pt = arrmol.points[n - 1];
                let cx = offsetX + pt.cx * scale, cy = offsetY + pt.cy * scale;
                let rw = Math.max(0.5 * this.policy.data.pointScale, pt.rw) * scale, rh = Math.max(0.5 * this.policy.data.pointScale, pt.rh) * scale;
                if (mapnum > 0) {
                    let col = this.COLCYCLE[(mapnum - 1) % this.COLCYCLE.length];
                    ctx.beginPath();
                    ctx.ellipse(cx, cy, rw, rh, 0, 0, WebMolKit.TWOPI, false);
                    ctx.fillStyle = col;
                    ctx.fill();
                    if (n == highlight) {
                        let oside = 3 - side, omol = side == 1 ? this.mol2 : this.mol1;
                        for (let i = 1; i <= omol.numAtoms; i++)
                            if (omol.atomMapNum(i) == mapnum) {
                                let [dx, dy] = this.getAtomPos(oside, i);
                                ctx.beginPath();
                                ctx.moveTo(cx, cy);
                                ctx.lineTo(dx, dy);
                                ctx.strokeStyle = col;
                                ctx.lineWidth = 1;
                                ctx.stroke();
                            }
                    }
                }
                if (n == highlight) {
                    ctx.beginPath();
                    ctx.ellipse(cx, cy, rw, rh, 0, 0, WebMolKit.TWOPI, false);
                    ctx.strokeStyle = '#404040';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }
        }
        pickAtom(x, y, mask1, mask2) {
            let ret = [0, 0];
            const scale = this.scale, thresh2 = WebMolKit.sqr(this.scale * 1.0 * this.policy.data.pointScale);
            let bestDist = Number.POSITIVE_INFINITY;
            for (let n = 1; n <= this.mol1.numAtoms; n++) {
                if (mask1 != null && !mask1[n - 1])
                    continue;
                let pt = this.arrmol1.points[n - 1];
                let cx = this.offsetX1 + pt.cx * scale, cy = this.offsetY1 + pt.cy * scale;
                let dsq = WebMolKit.norm2_xy(x - cx, y - cy);
                if (dsq < thresh2 && dsq < bestDist) {
                    ret = [1, n];
                    bestDist = dsq;
                }
            }
            for (let n = 1; n <= this.mol2.numAtoms; n++) {
                if (mask2 != null && !mask2[n - 1])
                    continue;
                let pt = this.arrmol2.points[n - 1];
                let cx = this.offsetX2 + pt.cx * scale, cy = this.offsetY2 + pt.cy * scale;
                let dsq = WebMolKit.norm2_xy(x - cx, y - cy);
                if (dsq < thresh2 && dsq < bestDist) {
                    ret = [2, n];
                    bestDist = dsq;
                }
            }
            return ret;
        }
        getAtomPos(side, atom) {
            let arrmol = side == 1 ? this.arrmol1 : this.arrmol2;
            let ox = side == 1 ? this.offsetX1 : this.offsetX2, oy = side == 1 ? this.offsetY1 : this.offsetY2;
            let pt = arrmol.points[atom - 1];
            let cx = ox + pt.cx * this.scale, cy = oy + pt.cy * this.scale;
            let rw = Math.max(0.5 * this.policy.data.pointScale, pt.rw) * this.scale, rh = Math.max(0.5 * this.policy.data.pointScale, pt.rh) * this.scale;
            return [cx, cy, rw, rh];
        }
        compatibilityMask(side, atom) {
            let mask = [];
            let mol1 = side == 1 ? this.mol1 : this.mol2, mol2 = side == 1 ? this.mol2 : this.mol1;
            let el = mol1.atomElement(atom), iso = mol1.atomIsotope(atom), map = mol1.atomMapNum(atom);
            for (let n = 1; n <= mol2.numAtoms; n++) {
                let match = el == mol2.atomElement(n) && iso == mol2.atomIsotope(n);
                match = match && (map == 0 || mol2.atomMapNum(n) == 0);
                mask.push(match);
            }
            return mask;
        }
        connectAtoms(side, atom1, atom2) {
            let mol1 = side == 1 ? this.mol1 : this.mol2, mol2 = side == 1 ? this.mol2 : this.mol1;
            let map = mol1.atomMapNum(atom1);
            if (map == 0)
                map = mol2.atomMapNum(atom2);
            if (map == 0) {
                let allnums = new Set();
                for (let n = 1; n <= mol1.numAtoms; n++)
                    allnums.add(mol1.atomMapNum(n));
                for (let n = 1; n <= mol2.numAtoms; n++)
                    allnums.add(mol2.atomMapNum(n));
                for (map = 1; allnums.has(map); map++)
                    ;
            }
            mol1.setAtomMapNum(atom1, map);
            mol2.setAtomMapNum(atom2, map);
        }
        autoConnect() {
            WebMolKit.Func.atomMapping({ 'leftNative': this.mol1.toString(), 'rightNative': this.mol2.toString() }, (result, error) => {
                if (!result)
                    return;
                let map1 = result.map1, map2 = result.map2;
                if (map1 == null || map2 == null)
                    return;
                let modified = false;
                for (let n = 1; n <= this.mol1.numAtoms && n <= map1.length; n++)
                    if (map1[n - 1] > 0 && this.mol1.atomMapNum(n) == 0) {
                        this.mol1.setAtomMapNum(n, map1[n - 1]);
                        modified = true;
                    }
                for (let n = 1; n <= this.mol2.numAtoms && n <= map2.length; n++)
                    if (map2[n - 1] > 0 && this.mol2.atomMapNum(n) == 0) {
                        this.mol2.setAtomMapNum(n, map2[n - 1]);
                        modified = true;
                    }
                if (modified)
                    this.redrawCanvas();
            });
        }
        clearAllMappings() {
            let anything = false;
            for (let n = 1; n <= this.mol1.numAtoms; n++)
                if (this.mol1.atomMapNum(n) > 0) {
                    this.mol1.setAtomMapNum(n, 0);
                    anything = true;
                }
            for (let n = 1; n <= this.mol2.numAtoms; n++)
                if (this.mol2.atomMapNum(n) > 0) {
                    this.mol2.setAtomMapNum(n, 0);
                    anything = true;
                }
            if (anything)
                this.redrawCanvas();
        }
        clearMapping(side, atom) {
            let map = side == 1 ? this.mol1.atomMapNum(atom) : this.mol2.atomMapNum(atom);
            if (map == 0)
                return;
            for (let n = 1; n <= this.mol1.numAtoms; n++)
                if (this.mol1.atomMapNum(n) == map)
                    this.mol1.setAtomMapNum(n, 0);
            for (let n = 1; n <= this.mol2.numAtoms; n++)
                if (this.mol2.atomMapNum(n) == map)
                    this.mol2.setAtomMapNum(n, 0);
        }
        mouseDown(event) {
            let xy = WebMolKit.eventCoords(event, this.canvas);
            this.pressed = this.pickAtom(xy[0], xy[1]);
            this.dragToX = xy[0];
            this.dragToY = xy[1];
            this.redrawCanvas();
        }
        mouseUp(event) {
            let xy = WebMolKit.eventCoords(event, this.canvas);
            if (this.pressed[0] > 0) {
                let dest = this.pickAtom(xy[0], xy[1]);
                if (dest[0] == this.pressed[0] && dest[1] == this.pressed[1]) {
                    this.clearMapping(dest[0], dest[1]);
                }
                else {
                    let compatMask = this.compatibilityMask(this.pressed[0], this.pressed[1]);
                    dest = this.pickAtom(xy[0], xy[1], this.pressed[0] == 2 ? compatMask : null, this.pressed[0] == 1 ? compatMask : null);
                    if (dest[0] == 3 - this.pressed[0]) {
                        this.connectAtoms(this.pressed[0], this.pressed[1], dest[1]);
                        this.autoConnect();
                    }
                }
                this.pressed = [0, 0];
            }
            this.highlighted = this.pickAtom(xy[0], xy[1]);
            this.redrawCanvas();
        }
        mouseEnter(event) {
        }
        mouseLeave(event) {
            if (this.highlighted[0] > 0 || this.pressed[0] > 0) {
                this.highlighted = [0, 0];
                this.pressed = [0, 0];
                this.redrawCanvas();
            }
        }
        mouseMove(event) {
            let xy = WebMolKit.eventCoords(event, this.canvas);
            if (this.pressed[0] > 0) {
                this.dragToX = xy[0];
                this.dragToY = xy[1];
                this.redrawCanvas();
            }
            else {
                let high = this.pickAtom(xy[0], xy[1]);
                if (high[0] != this.highlighted[0] || high[1] != this.highlighted[1]) {
                    this.highlighted = high;
                    this.redrawCanvas();
                }
            }
        }
    }
    WebMolKit.MapReaction = MapReaction;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class ArrangeComponent {
        constructor() {
            this.annot = ArrangeExperiment.COMP_ANNOT_NONE;
            this.box = new WebMolKit.Box();
        }
        clone() {
            let dup = new ArrangeComponent();
            dup.type = this.type;
            dup.srcIdx = this.srcIdx;
            dup.step = this.step;
            dup.side = this.side;
            dup.refIdx = this.refIdx;
            dup.mol = this.mol;
            dup.text = this.text;
            dup.leftNumer = this.leftNumer;
            dup.leftDenom = this.leftDenom;
            dup.fszText = this.fszText;
            dup.fszLeft = this.fszLeft;
            dup.annot = this.annot;
            dup.box = this.box.clone();
            dup.padding = this.padding;
            return dup;
        }
    }
    WebMolKit.ArrangeComponent = ArrangeComponent;
    class ArrangeExperiment {
        constructor(entry, measure, policy) {
            this.entry = entry;
            this.measure = measure;
            this.policy = policy;
            this.width = 0;
            this.height = 0;
            this.components = [];
            this.limitTotalW = 1000;
            this.limitTotalH = 1000;
            this.limitStructW = 0;
            this.limitStructH = 0;
            this.includeReagents = true;
            this.includeNames = false;
            this.includeStoich = true;
            this.includeAnnot = false;
            this.includeBlank = false;
            this.PADDING = 0.25;
            this.PLUSSZ = 0.5;
            this.ARROW_W = 2;
            this.ARROW_H = 0.5;
            this.REAGENT_SCALE = 0.7;
            this.PLACEHOLDER_W = 2;
            this.PLACEHOLDER_H = 2;
            this.scale = policy.data.pointScale;
            this.limitStructW = this.limitStructH = this.scale * 10;
        }
        arrange() {
            this.createComponents();
            let fszText = this.scale * this.policy.data.fontSize, fszLeft = this.scale * this.policy.data.fontSize * 1.5;
            let padding = this.PADDING * this.scale;
            for (let xc of this.components) {
                if (xc.type == ArrangeExperiment.COMP_PLUS)
                    xc.box = new WebMolKit.Box(0, 0, this.scale * this.PLUSSZ, this.scale * this.PLUSSZ);
                else if (xc.type == ArrangeExperiment.COMP_ARROW) { }
                else {
                    let w = 0, h = 0;
                    if (WebMolKit.MolUtil.notBlank(xc.mol)) {
                        let sz = WebMolKit.Size.fromArray(WebMolKit.ArrangeMolecule.guestimateSize(xc.mol, this.policy));
                        if (xc.type == ArrangeExperiment.COMP_REAGENT)
                            sz.scaleBy(this.REAGENT_SCALE);
                        if (xc.leftNumer) {
                            xc.fszLeft = fszLeft;
                            let wad = this.measure.measureText(xc.leftNumer, fszLeft);
                            let lw = wad[0], lh = wad[1] + wad[2];
                            if (xc.leftDenom)
                                lw = Math.max(lw, this.measure.measureText(xc.leftDenom, fszLeft)[0]);
                            sz.w += lw + ArrangeExperiment.COMP_GAP_LEFT * lh;
                            sz.h = Math.max(sz.h, lh * (xc.leftDenom ? 2 : 1));
                        }
                        sz.fitInto(this.limitStructW, this.limitStructH);
                        w = sz.w;
                        h = sz.h;
                    }
                    if (xc.text) {
                        xc.fszText = fszText;
                        let wad = this.measure.measureText(xc.text, fszText);
                        w = Math.max(w, wad[0]);
                        h += wad[1] + wad[2];
                    }
                    if (xc.annot != 0)
                        w += ArrangeExperiment.COMP_ANNOT_SIZE * this.scale;
                    if (this.includeBlank || w == 0 || h == 0) {
                        w = Math.max(w, this.PLACEHOLDER_W * this.scale);
                        h = Math.max(h, this.PLACEHOLDER_H * this.scale);
                    }
                    xc.box = new WebMolKit.Box(0, 0, w, h);
                }
                xc.padding = padding;
                xc.box = new WebMolKit.Box(0, 0, xc.box.w + 2 * padding, xc.box.h + 2 * padding);
            }
            let best = null;
            let bestScore = 0;
            for (let bend = this.entry.steps.length + 1; bend >= 1; bend--)
                for (let vert = 0; vert <= 1; vert++) {
                    let trial = [];
                    for (let xc of this.components)
                        trial.push(xc.clone());
                    this.arrangeComponents(trial, bend, vert > 0);
                    let score = this.scoreArrangement(trial);
                    if (best == null || score > bestScore) {
                        best = trial;
                        bestScore = score;
                    }
                }
            this.components = best;
            this.width = this.height = 0;
            for (let xc of this.components) {
                this.width = Math.max(this.width, xc.box.maxX());
                this.height = Math.max(this.height, xc.box.maxY());
            }
        }
        get numComponents() { return this.components.length; }
        getComponent(idx) { return this.components[idx]; }
        scaleComponents(modScale) {
            if (modScale == 1)
                return;
            this.scale *= modScale;
            this.width *= modScale;
            this.height *= modScale;
            for (let xc of this.components) {
                xc.box.scaleBy(modScale);
                xc.fszText *= modScale;
                xc.fszLeft *= modScale;
                xc.padding *= modScale;
            }
        }
        createComponents() {
            for (let n = 0; n < this.entry.steps[0].reactants.length; n++) {
                if (n > 0)
                    this.createSegregator(ArrangeExperiment.COMP_PLUS, 0, -1);
                this.createReactant(n, 0);
            }
            if (this.components.length == 0 && this.includeBlank)
                this.createBlank(ArrangeExperiment.COMP_REACTANT, 0);
            for (let s = 0; s < this.entry.steps.length; s++) {
                this.createSegregator(ArrangeExperiment.COMP_ARROW, s, 0);
                if (this.includeReagents) {
                    let any = false;
                    for (let n = 0; n < this.entry.steps[s].reagents.length; n++) {
                        this.createReagent(n, s);
                        any = true;
                    }
                    if (!any && this.includeBlank)
                        this.createBlank(ArrangeExperiment.COMP_REAGENT, s);
                }
                let any = false;
                for (let n = 0; n < this.entry.steps[s].products.length; n++) {
                    if (n > 0)
                        this.createSegregator(ArrangeExperiment.COMP_PLUS, s, 1);
                    this.createProduct(n, s);
                    any = true;
                }
                if (!any && this.includeBlank)
                    this.createBlank(ArrangeExperiment.COMP_PRODUCT, s);
            }
        }
        createReactant(idx, step) {
            let comp = this.entry.steps[step].reactants[idx];
            let xc = new ArrangeComponent();
            xc.type = ArrangeExperiment.COMP_REACTANT;
            xc.srcIdx = idx;
            xc.step = step;
            xc.side = -1;
            if (WebMolKit.MolUtil.notBlank(comp.mol))
                xc.mol = comp.mol;
            if (name && (this.includeNames || WebMolKit.MolUtil.isBlank(comp.mol)))
                xc.text = name;
            if (WebMolKit.MolUtil.isBlank(xc.mol) && !xc.text)
                xc.text = '?';
            if (this.includeStoich && !WebMolKit.QuantityCalc.isStoichZero(comp.stoich) && !WebMolKit.QuantityCalc.isStoichUnity(comp.stoich)) {
                let slash = comp.stoich.indexOf('/');
                if (slash >= 0) {
                    xc.leftNumer = comp.stoich.substring(0, slash);
                    xc.leftDenom = comp.stoich.substring(slash + 1);
                }
                else
                    xc.leftNumer = comp.stoich;
            }
            if (this.includeAnnot && WebMolKit.MolUtil.notBlank(comp.mol) && comp.primary)
                xc.annot = ArrangeExperiment.COMP_ANNOT_PRIMARY;
            this.components.push(xc);
        }
        createReagent(idx, step) {
            let comp = this.entry.steps[step].reagents[idx];
            let xc = new ArrangeComponent();
            xc.type = ArrangeExperiment.COMP_REAGENT;
            xc.srcIdx = idx;
            xc.step = step;
            xc.side = 0;
            if (WebMolKit.MolUtil.notBlank(comp.mol))
                xc.mol = comp.mol;
            if (name && (this.includeNames || WebMolKit.MolUtil.isBlank(comp.mol)))
                xc.text = name;
            if (WebMolKit.MolUtil.isBlank(xc.mol) && !xc.text)
                xc.text = '?';
            if (this.includeAnnot) {
                let stoich = WebMolKit.QuantityCalc.impliedReagentStoich(comp, this.entry.steps[step].products);
                if (stoich > 0)
                    xc.annot = ArrangeExperiment.COMP_ANNOT_IMPLIED;
                if (stoich > 0 && stoich != 1) {
                    if (WebMolKit.realEqual(stoich, Math.round(stoich)))
                        xc.leftNumer = Math.round(stoich).toString();
                    else
                        xc.leftNumer = stoich.toString();
                }
            }
            this.components.push(xc);
        }
        createProduct(idx, step) {
            let comp = this.entry.steps[step].products[idx];
            let xc = new ArrangeComponent();
            xc.type = ArrangeExperiment.COMP_PRODUCT;
            xc.srcIdx = idx;
            xc.step = step;
            xc.side = 1;
            if (WebMolKit.MolUtil.notBlank(comp.mol))
                xc.mol = comp.mol;
            if (name && (this.includeNames || WebMolKit.MolUtil.isBlank(comp.mol)))
                xc.text = comp.name;
            if (WebMolKit.MolUtil.isBlank(xc.mol) && !xc.text)
                xc.text = '?';
            if (this.includeStoich && !WebMolKit.QuantityCalc.isStoichZero(comp.stoich) && !WebMolKit.QuantityCalc.isStoichUnity(comp.stoich)) {
                let slash = comp.stoich.indexOf('/');
                if (slash >= 0) {
                    xc.leftNumer = comp.stoich.substring(0, slash);
                    xc.leftDenom = comp.stoich.substring(slash + 1);
                }
                else
                    xc.leftNumer = comp.stoich;
            }
            if (this.includeAnnot && WebMolKit.MolUtil.notBlank(comp.mol) && comp.waste)
                xc.annot = ArrangeExperiment.COMP_ANNOT_WASTE;
            this.components.push(xc);
        }
        createSegregator(type, step, side) {
            let xc = new ArrangeComponent();
            xc.type = type;
            xc.step = step;
            xc.side = side;
            this.components.push(xc);
        }
        createBlank(type, step) {
            let xc = new ArrangeComponent();
            xc.type = type;
            xc.step = step;
            xc.side = type == ArrangeExperiment.COMP_REACTANT ? -1 : type == ArrangeExperiment.COMP_PRODUCT ? 1 : 0;
            xc.srcIdx = -1;
            this.components.push(xc);
        }
        arrangeComponents(comps, bendStep, vertComp) {
            let blkMain = [];
            let blkArrow = [];
            let szMain = [], szArrow = [];
            let midMain = [], midArrow = [];
            blkMain.push(this.gatherBlock(comps, 0, -1));
            szMain.push(this.arrangeMainBlock(blkMain[0], vertComp));
            midMain.push(this.findMidBlock(blkMain[0], szMain[0]));
            for (let n = 0; n < this.entry.steps.length; n++) {
                let bent = n + 1 >= bendStep;
                blkMain.push(this.gatherBlock(comps, n, 1));
                szMain.push(this.arrangeMainBlock(blkMain[n + 1], vertComp && !bent));
                midMain.push(this.findMidBlock(blkMain[n + 1], szMain[n + 1]));
                blkArrow.push(this.gatherBlock(comps, n, 0));
                if (!bent)
                    szArrow.push(this.arrangeHorizontalArrowBlock(blkArrow[n]));
                else
                    szArrow.push(this.arrangeVerticalArrowBlock(blkArrow[n]));
                midArrow.push(this.findMidBlock(blkArrow[n], szArrow[n]));
            }
            let midH = 0;
            for (let n = 0; n < bendStep; n++) {
                midH = Math.max(midH, midMain[n].y);
                if (n > 0)
                    midH = Math.max(midH, midArrow[n - 1].y);
            }
            let sz = WebMolKit.Size.zero();
            for (let n = 0; n < bendStep; n++) {
                sz.w += szMain[n].w;
                sz.h = Math.max(sz.h, midH + (szMain[n].h - midMain[n].y));
                if (n > 0) {
                    sz.w += szArrow[n - 1].w;
                    sz.h = Math.max(sz.h, midH + (szArrow[n - 1].h - midArrow[n - 1].y));
                }
            }
            let x = 0, arrowX = 0;
            for (let n = 0; n < bendStep; n++) {
                if (n > 0) {
                    this.originateBlock(blkArrow[n - 1], x, midH - midArrow[n - 1].y);
                    x += szArrow[n - 1].w;
                }
                this.originateBlock(blkMain[n], x, midH - midMain[n].y);
                arrowX = x + midMain[n].x;
                x += szMain[n].w;
            }
            let y = sz.h, lowX = 0;
            for (let n = bendStep; n <= this.entry.steps.length; n++) {
                x = arrowX - midArrow[n - 1].x;
                lowX = Math.min(lowX, x);
                this.originateBlock(blkArrow[n - 1], x, y);
                y += szArrow[n - 1].h;
                sz.w = Math.max(sz.w, x + szArrow[n - 1].w);
                x = arrowX - midMain[n].x;
                lowX = Math.min(lowX, x);
                this.originateBlock(blkMain[n], x, y);
                y += szMain[n].h;
                sz.w = Math.max(sz.w, x + szMain[n].w);
            }
            if (lowX < 0) {
                for (let xc of comps)
                    xc.box.x -= lowX;
            }
        }
        gatherBlock(comps, step, side) {
            let block = [];
            for (let xc of comps)
                if (xc.side == side && xc.step == step)
                    block.push(xc);
            return block;
        }
        arrangeMainBlock(block, vertComp) {
            let sz = WebMolKit.Size.zero();
            if (!vertComp) {
                for (let xc of block) {
                    sz.w += xc.box.w;
                    sz.h = Math.max(sz.h, xc.box.h);
                }
            }
            else {
                for (let xc of block) {
                    sz.w = Math.max(sz.w, xc.box.w);
                    sz.h += xc.box.h;
                }
            }
            sz.w = Math.max(sz.w, this.scale * 2.0);
            sz.h = Math.max(sz.h, this.scale * 2.0);
            if (!vertComp) {
                let x = 0;
                for (let xc of block) {
                    xc.box.x = x;
                    xc.box.y = 0.5 * (sz.h - xc.box.h);
                    x += xc.box.w;
                }
            }
            else {
                let y = 0;
                for (let xc of block) {
                    xc.box.x = 0.5 * (sz.w - xc.box.w);
                    xc.box.y = y;
                    y += xc.box.h;
                }
            }
            return sz;
        }
        arrangeHorizontalArrowBlock(block) {
            let arrow = null;
            for (let xc of block)
                if (xc.type == ArrangeExperiment.COMP_ARROW) {
                    arrow = xc;
                    xc.box.w = this.ARROW_W * this.scale + 2 * xc.padding;
                    xc.box.h = this.ARROW_H * this.scale + 2 * xc.padding;
                }
            let mid = block.length >> 1;
            for (let xc of block)
                arrow.box.w = Math.max(xc.box.w, arrow.box.w);
            let sz = WebMolKit.Size.zero();
            let n = 0;
            let y = 0;
            let arrowPlaced = false;
            for (let xc of block)
                if (xc.type != ArrangeExperiment.COMP_ARROW) {
                    xc.box.x = 0.5 * (arrow.box.w - xc.box.w);
                    xc.box.y = y;
                    y += xc.box.h;
                    n++;
                    if (n == mid) {
                        arrow.box.x = 0;
                        arrow.box.y = y;
                        y += arrow.box.h;
                        arrowPlaced = true;
                    }
                }
            if (!arrowPlaced) {
                arrow.box.x = 0;
                arrow.box.y = y;
                y += arrow.box.h;
            }
            sz.w = arrow.box.w;
            sz.h = y;
            return sz;
        }
        arrangeVerticalArrowBlock(block) {
            let arrow = null;
            for (let xc of block)
                if (xc.type == ArrangeExperiment.COMP_ARROW) {
                    arrow = xc;
                    xc.box.w = this.ARROW_H * this.scale + 2 * xc.padding;
                    xc.box.h = this.ARROW_W * this.scale + 2 * xc.padding;
                }
            let mid = block.length >> 1;
            let sz1 = WebMolKit.Size.zero(), sz2 = WebMolKit.Size.zero();
            let n = 0;
            for (let xc of block)
                if (xc.type != ArrangeExperiment.COMP_ARROW) {
                    if (n < mid) {
                        sz1.w = Math.max(sz1.w, xc.box.w);
                        sz1.h += xc.box.h;
                    }
                    else {
                        sz2.w = Math.max(sz2.w, xc.box.w);
                        sz2.h += xc.box.h;
                    }
                    n++;
                }
            let sz = new WebMolKit.Size(sz1.w + sz2.w + arrow.box.w, Math.max(arrow.box.h, Math.max(sz1.h, sz2.h)));
            arrow.box = new WebMolKit.Box(sz1.w, 0, arrow.box.w, sz.h);
            let y1 = 0.5 * (sz.h - sz1.h), y2 = 0.5 * (sz.h - sz2.h);
            n = 0;
            for (let xc of block)
                if (xc.type != ArrangeExperiment.COMP_ARROW) {
                    if (n < mid) {
                        xc.box.x = sz1.w - xc.box.w;
                        xc.box.y = y1;
                        y1 += xc.box.h;
                    }
                    else {
                        xc.box.x = sz.w - sz2.w;
                        xc.box.y = y2;
                        y2 += xc.box.h;
                    }
                    n++;
                }
            return sz;
        }
        findMidBlock(block, sz) {
            let count = 0;
            let mid = WebMolKit.Pos.zero();
            for (let xc of block)
                if (xc.type == ArrangeExperiment.COMP_PLUS || xc.type == ArrangeExperiment.COMP_ARROW) {
                    mid.x += xc.box.midX();
                    mid.y += xc.box.midY();
                    count++;
                }
            if (count == 0) {
                mid.x = 0.5 * sz.w;
                mid.y = 0.5 * sz.h;
            }
            else if (count > 1) {
                let inv = 1.0 / count;
                mid.x *= inv;
                mid.y *= inv;
            }
            return mid;
        }
        scoreArrangement(comps) {
            let w = 0;
            for (let xc of comps)
                w = Math.max(w, xc.box.maxX());
            let score = 0;
            score -= Math.abs(w - this.limitTotalW);
            return score;
        }
        originateBlock(block, x, y) {
            for (let xc of block) {
                xc.box.x += x;
                xc.box.y += y;
            }
        }
    }
    ArrangeExperiment.COMP_ARROW = 1;
    ArrangeExperiment.COMP_PLUS = 2;
    ArrangeExperiment.COMP_REACTANT = 3;
    ArrangeExperiment.COMP_REAGENT = 4;
    ArrangeExperiment.COMP_PRODUCT = 5;
    ArrangeExperiment.COMP_ANNOT_NONE = 0;
    ArrangeExperiment.COMP_ANNOT_PRIMARY = 1;
    ArrangeExperiment.COMP_ANNOT_WASTE = 2;
    ArrangeExperiment.COMP_ANNOT_IMPLIED = 3;
    ArrangeExperiment.COMP_GAP_LEFT = 0.5;
    ArrangeExperiment.COMP_ANNOT_SIZE = 1;
    WebMolKit.ArrangeExperiment = ArrangeExperiment;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class AxisLabeller {
        constructor(width, minVal, maxVal, textWidth, inverse) {
            this.width = width;
            this.minVal = minVal;
            this.maxVal = maxVal;
            this.textWidth = textWidth;
            this.inverse = inverse;
            this.notches = [];
        }
        calculate() {
            if (this.minVal == this.maxVal) {
                this.notches.push({
                    'label': this.minVal.toString(),
                    'value': this.minVal,
                    'pos': 0.5 * this.width
                });
                return;
            }
            const width = this.width, minVal = this.minVal, maxVal = this.maxVal;
            const range = maxVal - minVal, invRange = 1.0 / range;
            let position = (val) => width * (val - minVal) * invRange;
            let loT = null, hiT = null;
            const bumpLess = 1 - 1E-5, bumpMore = 1 + 1E-5;
            got: for (let outer = 1E-10; outer <= 1E11; outer *= 10)
                for (let inner of [0.2, 0.5, 1]) {
                    let mag = outer * inner, inv = 1.0 / mag;
                    let t1 = Math.floor(minVal * mag * bumpLess) * inv, t2 = Math.round(minVal * mag) * inv, t3 = Math.ceil(minVal * mag * bumpMore) * inv;
                    let t4 = Math.floor(maxVal * mag * bumpLess) * inv, t5 = Math.round(maxVal * mag) * inv, t6 = Math.ceil(maxVal * mag * bumpMore) * inv;
                    let p1 = position(t1), p2 = position(t2), p3 = position(t3);
                    let p4 = position(t4), p5 = position(t5), p6 = position(t6);
                    if ((WebMolKit.fltEqual(p1, 0) || p1 >= 0) && p1 <= 0.1 * width)
                        loT = t1;
                    else if ((WebMolKit.fltEqual(p2, 0) || p2 >= 0) && p2 <= 0.1 * width)
                        loT = t2;
                    else if ((WebMolKit.fltEqual(p3, 0) || p3 >= 0) && p3 <= 0.1 * width)
                        loT = t3;
                    else
                        continue;
                    if (p6 >= 0.9 * width && (WebMolKit.fltEqual(p6, width) || p6 <= width))
                        hiT = t6;
                    else if (p5 >= 0.9 * width && (WebMolKit.fltEqual(p5, width) || p5 <= width))
                        hiT = t5;
                    else if (p4 >= 0.9 * width && (WebMolKit.fltEqual(p4, width) || p4 <= width))
                        hiT = t4;
                    else
                        continue;
                    break got;
                }
            if (loT == null || hiT == null)
                return;
            let loVal = this.inverse(loT), hiVal = this.inverse(hiT);
            this.notches.push({
                'label': this.formatNumber(loVal),
                'value': loVal,
                'pos': position(loT)
            });
            this.notches.push({
                'label': this.formatNumber(hiVal),
                'value': hiVal,
                'pos': position(hiT)
            });
        }
        formatNumber(num) {
            let str = num.toPrecision(4);
            str = str.replace(/^(-?\d+)\.0+$/, '$1');
            str = str.replace(/^(-?\d+\.0*[1-9]+)0+$/, '$1');
            str = str.replace(/^(-?\d+)\.0+(e[\+\-]\d+)$/, '$1$2');
            str = str.replace(/^(-?\d+\.0*[1-9]+)0+(e[\+\-]\d+)$/, '$1$2');
            return str;
        }
    }
    WebMolKit.AxisLabeller = AxisLabeller;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class DrawExperiment {
        constructor(layout, vg) {
            this.layout = layout;
            this.vg = vg;
            this.entry = layout.entry;
            this.measure = layout.measure;
            this.policy = layout.policy;
            this.scale = layout.scale;
            this.invScale = 1.0 / this.scale;
        }
        draw() {
            for (let xc of this.layout.components) {
                if (xc.type == WebMolKit.ArrangeExperiment.COMP_ARROW)
                    this.drawSymbolArrow(xc);
                else if (xc.type == WebMolKit.ArrangeExperiment.COMP_PLUS)
                    this.drawSymbolPlus(xc);
                else
                    this.drawComponent(xc);
            }
        }
        drawComponent(xc) {
            let vg = this.vg, policy = this.policy;
            let bx = xc.box.x + xc.padding, by = xc.box.y + xc.padding;
            let bw = xc.box.w - 2 * xc.padding, bh = xc.box.h - 2 * xc.padding;
            if (xc.text) {
                let wad = this.measure.measureText(xc.text, xc.fszText);
                vg.drawText(bx + 0.5 * bw, by + bh, xc.text, xc.fszText, policy.data.foreground, WebMolKit.TextAlign.Bottom | WebMolKit.TextAlign.Centre);
                bh -= wad[1] + wad[2];
            }
            if (xc.leftNumer) {
                let wad1 = this.measure.measureText(xc.leftNumer, xc.fszLeft);
                if (xc.leftDenom) {
                    vg.drawText(bx, by + 0.5 * bh, xc.leftNumer, xc.fszLeft, policy.data.foreground, WebMolKit.TextAlign.Left | WebMolKit.TextAlign.Middle);
                    let useW = wad1[0] + WebMolKit.ArrangeExperiment.COMP_GAP_LEFT * (wad1[1] + wad1[2]);
                    bx += useW;
                    bw -= useW;
                }
                else {
                    let wad2 = this.measure.measureText(xc.leftDenom, xc.fszLeft);
                    let tw = Math.max(wad1[0], wad2[0]);
                    let x = bx + 0.5 * tw, y = by + 0.5 * bh;
                    vg.drawText(x, y, xc.leftNumer, xc.fszLeft, policy.data.foreground, WebMolKit.TextAlign.Centre | WebMolKit.TextAlign.Bottom);
                    vg.drawText(x, y + wad1[2], xc.leftDenom, xc.fszLeft, policy.data.foreground, WebMolKit.TextAlign.Centre | WebMolKit.TextAlign.Top);
                    vg.drawLine(bx, y, bx + tw, y, policy.data.foreground, this.scale * 0.03);
                    let useW = tw + WebMolKit.ArrangeExperiment.COMP_GAP_LEFT * (wad1[1] + wad1[2]);
                    bx += useW;
                    bw -= useW;
                }
            }
            if (xc.annot != 0) {
                let aw = WebMolKit.ArrangeExperiment.COMP_ANNOT_SIZE * this.scale;
                bw -= aw;
                this.drawAnnotation(xc.annot, bx + bw, by, aw, bh);
            }
            if (WebMolKit.MolUtil.notBlank(xc.mol)) {
                let arrmol = new WebMolKit.ArrangeMolecule(xc.mol, this.layout.measure, policy, new WebMolKit.RenderEffects());
                arrmol.arrange();
                arrmol.squeezeInto(bx, by, bw, bh, 0);
                let drawmol = new WebMolKit.DrawMolecule(arrmol, vg);
                drawmol.draw();
            }
            if (xc.srcIdx < 0) {
                let fsz = 0.5 * bh;
                vg.drawText(bx + 0.5 * bw, by + 0.5 * bh, '?', fsz, policy.data.foreground, WebMolKit.TextAlign.Centre | WebMolKit.TextAlign.Middle);
            }
        }
        drawSymbolArrow(xc) {
            let bx = xc.box.x + xc.padding, by = xc.box.y + xc.padding;
            let bw = xc.box.w - 2 * xc.padding, bh = xc.box.h - 2 * xc.padding;
            if (bw > bh)
                this.drawArrow(bx, by + 0.5 * bh, bx + bw, by + 0.5 * bh, bh, this.policy.data.foreground, this.scale * 0.05);
            else
                this.drawArrow(bx + 0.5 * bw, by, bx + 0.5 * bw, by + bh, bw, this.policy.data.foreground, this.scale * 0.05);
        }
        drawSymbolPlus(xc) {
            let vg = this.vg, policy = this.policy;
            let x1 = xc.box.x + xc.padding, y1 = xc.box.y + xc.padding;
            let x3 = x1 + xc.box.w - 2 * xc.padding, y3 = y1 + xc.box.h - 2 * xc.padding;
            let x2 = 0.5 * (x1 + x3), y2 = 0.5 * (y1 + y3);
            let lw = 0.2 * 0.5 * (x3 - x1 + y3 - y1);
            vg.drawLine(x1, y2, x3, y2, policy.data.foreground, lw);
            vg.drawLine(x2, y1, x2, y3, policy.data.foreground, lw);
        }
        drawAnnotation(annot, bx, by, bw, bh) {
            let vg = this.vg, policy = this.policy;
            let sz = bw, x2 = bx + bw, y2 = by + bh, x1 = x2 - sz, y1 = by;
            if (annot == WebMolKit.ArrangeExperiment.COMP_ANNOT_PRIMARY)
                y2 = y1 + sz;
            else if (annot == WebMolKit.ArrangeExperiment.COMP_ANNOT_WASTE)
                y1 = y2 - sz;
            if (annot == WebMolKit.ArrangeExperiment.COMP_ANNOT_PRIMARY) {
                let cx = 0.5 * (x1 + x2), cy = 0.5 * (y1 + y2), ext = 0.25 * sz;
                let px = [cx, cx + 0.866 * ext, cx + 0.866 * ext, cx, cx - 0.866 * ext, cx - 0.866 * ext];
                let py = [cy - ext, cy - 0.5 * ext, cy + 0.5 * ext, cy + ext, cy + 0.5 * ext, cy - 0.5 * ext];
                let lw = 0.05 * this.scale;
                vg.drawLine(px[0], py[0], px[3], py[3], policy.data.foreground, lw);
                vg.drawLine(px[1], py[1], px[4], py[4], policy.data.foreground, lw);
                vg.drawLine(px[2], py[2], px[5], py[5], policy.data.foreground, lw);
                let inset = 0.1 * sz;
                vg.drawOval(x1 + 0.5 * sz, y1 + 0.5 * sz, 0.5 * sz - inset, 0.5 * sz - inset, policy.data.foreground, lw, WebMolKit.MetaVector.NOCOLOUR);
            }
            else if (annot == WebMolKit.ArrangeExperiment.COMP_ANNOT_WASTE) {
                let cx = x1 + 0.7 * sz, cy = 0.5 * (y1 + y2), quart = 0.25 * sz;
                let lw = 0.05 * this.scale;
                let px = [x1 + 0.1 * sz, cx - quart, cx, cx, cx];
                let py = [y1, y1, y1, cy - quart, cy];
                let ctrl = [false, false, true, false, false];
                vg.drawPath(px, py, ctrl, false, policy.data.foreground, lw, WebMolKit.MetaVector.NOCOLOUR, false);
                for (let n = 0; n < 4; n++) {
                    let y = cy + n * 0.45 * sz * (1.0 / 3), dw = (3.1 - n) * 0.1 * sz;
                    vg.drawLine(cx - dw, y, cx + dw, y, policy.data.foreground, lw);
                }
            }
            else if (annot == WebMolKit.ArrangeExperiment.COMP_ANNOT_IMPLIED) {
                let tw = 0.5 * sz, th = 0.75 * sz;
                let cx = x2 - 0.5 * tw, cy = y1 + 0.5 * th;
                let ty = y1 + 0.25 * th, dsz = sz * 0.1, hsz = 0.5 * dsz;
                let lw = 0.05 * this.scale, fg = policy.data.foreground;
                vg.drawLine(cx, y1, cx, y1 + th, fg, lw);
                vg.drawLine(x2 - tw, ty, x2, ty, fg, lw);
                vg.drawLine(x2 - tw, cy, x2, cy, fg, lw);
                vg.drawOval(x2 - tw + hsz, y1 + th - hsz, hsz, hsz, 0, 0, fg);
                vg.drawOval(x2 - hsz, y1 + th - hsz, hsz, hsz, 0, 0, fg);
            }
        }
        drawArrow(x1, y1, x2, y2, headsz, colour, linesz) {
            let dx = x2 - x1, dy = y2 - y1, invD = WebMolKit.invZ(WebMolKit.norm_xy(dx, dy));
            dx *= invD;
            dy *= invD;
            let ox = dy, oy = -dx;
            let hx = x2 - dx * headsz, hy = y2 - dy * headsz;
            let px = [
                x1 + ox * 0.5 * linesz,
                hx + ox * 0.5 * linesz,
                hx + ox * 0.5 * headsz,
                x2,
                hx - ox * 0.5 * headsz,
                hx - ox * 0.5 * linesz,
                x1 - ox * 0.5 * linesz
            ];
            let py = [
                y1 + oy * 0.5 * linesz,
                hy + oy * 0.5 * linesz,
                hy + oy * 0.5 * headsz,
                y2,
                hy - oy * 0.5 * headsz,
                hy - oy * 0.5 * linesz,
                y1 - oy * 0.5 * linesz
            ];
            this.vg.drawPoly(px, py, WebMolKit.MetaVector.NOCOLOUR, 0, colour, true);
        }
    }
    WebMolKit.DrawExperiment = DrawExperiment;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class Account {
        static connectTransient(callback) {
            new WebMolKit.RPC('account.connectTransient', {}, callback).invoke();
        }
        static refreshTransient(input, callback) {
            new WebMolKit.RPC('account.refreshTransient', input, callback).invoke();
        }
    }
    WebMolKit.Account = Account;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class Pile {
        static uploadMolecule(input, callback) {
            new WebMolKit.RPC('pile.uploadMolecule', input, callback).invoke();
        }
        static uploadDataSheet(input, callback) {
            new WebMolKit.RPC('pile.uploadDataSheet', input, callback).invoke();
        }
        static downloadMolecule(input, callback) {
            new WebMolKit.RPC('pile.downloadMolecule', input, callback).invoke();
        }
        static downloadDataSheet(input, callback) {
            new WebMolKit.RPC('pile.downloadDataSheet', input, callback).invoke();
        }
        static fetchSelection(input, callback) {
            new WebMolKit.RPC('pile.fetchSelection', input, callback).invoke();
        }
        static fetchMolecules(input, callback) {
            new WebMolKit.RPC('pile.fetchMolecules', input, callback).invoke();
        }
    }
    WebMolKit.Pile = Pile;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class Search {
        static startMolSearch(input, callback) {
            new WebMolKit.RPC('search.startMolSearch', input, callback).invoke();
        }
        static pollMolSearch(input, callback) {
            new WebMolKit.RPC('search.pollMolSearch', input, callback).invoke();
        }
        static startRxnSearch(input, callback) {
            new WebMolKit.RPC('search.startRxnSearch', input, callback).invoke();
        }
        static pollRxnSearch(input, callback) {
            new WebMolKit.RPC('search.pollRxnSearch', input, callback).invoke();
        }
    }
    WebMolKit.Search = Search;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class CircleButton extends WebMolKit.Widget {
        constructor(icon) {
            super();
            this.icon = icon;
            this.BUTTON_DIAMETER = 50;
            this.BUTTON_HPADDING = 4;
            this.BUTTON_VPADDING = 2;
            this.STATE_NORMAL = 'normal';
            this.STATE_SELECTED = 'selected';
            this.STATE_DISABLED = 'disabled';
            this.content = null;
            this.state = this.STATE_NORMAL;
            this.isHighlight = false;
            this.isPressed = false;
            this.progressFraction = null;
            this.callbackAction = null;
        }
        render(parent) {
            super.render(parent);
            this.content.addClass('no_selection');
            const diameter = this.BUTTON_DIAMETER;
            const width = diameter, height = diameter;
            let div = this.content;
            let density = WebMolKit.pixelDensity();
            div.css('width', width + 2 * this.BUTTON_HPADDING);
            div.css('height', height + 2 * this.BUTTON_VPADDING);
            div.css('position', 'relative');
            let canvasStyle = 'position: absolute; left: ' + this.BUTTON_HPADDING + 'px; top: ' + this.BUTTON_VPADDING + 'px;';
            canvasStyle += 'pointer-events: none;';
            function renderSolid(col1, col2) {
                let node = WebMolKit.newElement(div, 'canvas', { 'width': width * density, 'height': height * density, 'style': canvasStyle });
                node.style.width = width + 'px';
                node.style.height = height + 'px';
                let ctx = node.getContext('2d');
                ctx.save();
                ctx.scale(density, density);
                ctx.beginPath();
                ctx.arc(0.5 * width, 0.5 * height, 0.5 * diameter - 1, 0, 2 * Math.PI, true);
                ctx.clip();
                let grad = ctx.createLinearGradient(0, 0, width, height);
                grad.addColorStop(0, col1);
                grad.addColorStop(1, col2);
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, width, height);
                ctx.restore();
                return node;
            }
            function renderBorder(lw) {
                let node = WebMolKit.newElement(div, 'canvas', { 'width': width * density, 'height': height * density, 'style': canvasStyle });
                node.style.width = width + 'px';
                node.style.height = height + 'px';
                var ctx = node.getContext('2d');
                ctx.save();
                ctx.scale(density, density);
                ctx.beginPath();
                ctx.arc(0.5 * width, 0.5 * height, 0.5 * diameter - 0.5 * (1 + lw), 0, 2 * Math.PI, true);
                ctx.strokeStyle = 'black';
                ctx.lineWidth = lw;
                ctx.stroke();
                ctx.restore();
                return node;
            }
            this.normalBackgr = renderSolid('#FFFFFF', '#D0D0D0');
            this.selectedBackgr = renderSolid('#47D5D2', '#008FD1');
            this.pressedBackgr = renderSolid('#00CA59', '#008650');
            this.disabledBackgr = renderSolid('white', 'white');
            this.ringProgress = WebMolKit.newElement(div, 'canvas', { 'width': width * density, 'height': height * density, 'style': canvasStyle });
            this.ringProgress.style.width = width + 'px';
            this.ringProgress.style.height = height + 'px';
            this.ringProgress.getContext('2d').scale(density, density);
            this.ringProgress.hidden = true;
            this.thinBorder = renderBorder(1);
            this.thickBorder = renderBorder(2);
            var svgurl = WebMolKit.RPC.BASE_URL + "/img/icons/" + this.icon;
            this.svg = WebMolKit.newElement(div, 'object', { 'width': width, 'height': height, 'style': canvasStyle, 'data': svgurl, 'type': 'image/svg+xml' });
            this.updateLayers();
            div.mouseenter(() => this.mouseEnter());
            div.mouseleave(() => this.mouseLeave());
            div.mousedown(() => this.mouseDown());
            div.mouseup(() => this.mouseUp());
            div.click(() => this.mouseClicked());
        }
        ;
        setProgress(fraction) {
            if (this.progressFraction == fraction)
                return;
            this.progressFraction = fraction;
            this.ringProgress.hidden = false;
            let diameter = this.BUTTON_DIAMETER, mid = 0.5 * diameter, outer = mid - 1, inner = 0.8 * mid;
            var ctx = this.ringProgress.getContext('2d');
            ctx.clearRect(0, 0, diameter, diameter);
            ctx.strokeStyle = 'rgba(80,80,80,0.5)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.ellipse(mid, mid, inner + 0.5, inner + 0.5, 0, 0, WebMolKit.TWOPI, false);
            ctx.stroke();
            if (this.progressFraction == 0) {
                ctx.lineWidth = 1;
                ctx.strokeStyle = '#47D5D2';
                WebMolKit.drawLine(ctx, mid, mid - inner, mid, mid - outer);
                return;
            }
            let delta = WebMolKit.TWOPI * fraction;
            let theta1 = -0.5 * Math.PI, theta2 = theta1 + delta;
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(mid, mid - outer);
            ctx.arc(mid, mid, outer, theta1, theta2, false);
            ctx.lineTo(mid + inner * Math.cos(theta2), mid + inner * Math.sin(theta2));
            ctx.arc(mid, mid, inner, theta2, theta1, true);
            ctx.closePath();
            let grad = ctx.createRadialGradient(mid, mid, inner, mid, mid, outer);
            grad.addColorStop(0, '#47D5D2');
            grad.addColorStop(1, '#008FD2');
            ctx.fillStyle = grad;
            ctx.fill();
            ctx.restore();
        }
        clearProgress() {
            this.progressFraction = null;
            this.ringProgress.hidden = true;
        }
        updateLayers() {
            WebMolKit.setVisible(this.pressedBackgr, this.isPressed);
            WebMolKit.setVisible(this.normalBackgr, !this.isPressed && this.state == this.STATE_NORMAL);
            WebMolKit.setVisible(this.selectedBackgr, !this.isPressed && this.state == this.STATE_SELECTED);
            WebMolKit.setVisible(this.disabledBackgr, !this.isPressed && this.state == this.STATE_DISABLED);
            var highlight = this.isHighlight;
            if (this.state == this.STATE_DISABLED) {
                highlight = false;
                this.content.css('cursor', 'no-drop');
            }
            else
                this.content.css('cursor', 'pointer');
            WebMolKit.setVisible(this.thinBorder, !highlight);
            WebMolKit.setVisible(this.thickBorder, highlight);
        }
        mouseEnter() {
            this.isHighlight = true;
            this.updateLayers();
        }
        mouseLeave() {
            this.isHighlight = false;
            this.isPressed = false;
            this.updateLayers();
        }
        mouseDown() {
            this.isPressed = this.state != this.STATE_DISABLED;
            this.updateLayers();
        }
        mouseUp() {
            this.isPressed = false;
            this.updateLayers();
        }
        mouseClicked() {
            if (this.callbackAction)
                this.callbackAction(this);
        }
    }
    WebMolKit.CircleButton = CircleButton;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class EmbedChemistry extends WebMolKit.Widget {
        constructor() {
            super();
            this.padding = 4;
            this.borderCol = 0xD0D0D0;
            this.borderRadius = 8;
            this.backgroundCol1 = 0xFFFFFF;
            this.backgroundCol2 = 0xF0F0F0;
            this.policy = WebMolKit.RenderPolicy.defaultColourOnWhite();
        }
        clearBackground() { this.backgroundCol1 = null; this.backgroundCol2 = null; }
        setBackground(bg) { this.backgroundCol1 = bg; this.backgroundCol2 = null; }
        setBackgroundGradient(bg1, bg2) { this.backgroundCol1 = bg1; this.backgroundCol2 = bg2; }
        render(parent) {
            super.render(parent);
            if (this.borderCol != null)
                this.content.css('border', '1px solid ' + WebMolKit.colourCanvas(this.borderCol));
            if (this.borderRadius > 0)
                this.content.css('border-radius', this.borderRadius + 'px');
            let bg1 = this.backgroundCol1, bg2 = this.backgroundCol2;
            if (bg1 != null && bg2 != null) {
                let cols = WebMolKit.colourCanvas(bg1) + ',' + WebMolKit.colourCanvas(bg2);
                this.content.css('background-image', 'linear-gradient(to bottom right, ' + cols + ')');
            }
            else if (bg1 != null) {
                this.content.css('background-color', WebMolKit.colourCanvas(bg1));
            }
            this.content.css('padding', this.padding + 'px');
            this.content.css('margin', 0);
        }
    }
    WebMolKit.EmbedChemistry = EmbedChemistry;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class EmbedCollection extends WebMolKit.EmbedChemistry {
        constructor(datastr, options) {
            super();
            this.datastr = datastr;
            this.ds = null;
            this.failmsg = '';
            this.tight = false;
            if (!options)
                options = {};
            if (options.encoding == 'base64')
                datastr = WebMolKit.fromUTF8(atob(datastr.trim()));
            let ds = null, name = options.name;
            if (options.format == 'datasheet' || options.format == 'chemical/x-datasheet') {
                ds = WebMolKit.DataSheetStream.readXML(datastr);
            }
            else if (options.format == 'sdfile' || options.format == 'chemical/x-mdl-sdfile') {
                try {
                    let mdl = new WebMolKit.MDLSDFReader(datastr);
                    ds = mdl.parse();
                }
                catch (ex) {
                    this.failmsg = ex;
                }
            }
            else {
                try {
                    ds = WebMolKit.DataSheetStream.readXML(datastr);
                }
                catch (ex) { }
                if (ds == null) {
                    try {
                        let mdl = new WebMolKit.MDLSDFReader(datastr);
                        ds = mdl.parse();
                    }
                    catch (ex) { }
                }
            }
            if (ds == null)
                return;
            if (options.padding)
                this.padding = options.padding;
            if (options.background == 'transparent')
                this.clearBackground();
            else if (options.background) {
                let bg = options.background, comma = bg.indexOf(',');
                if (comma < 0)
                    this.setBackground(WebMolKit.htmlToRGB(bg));
                else
                    this.setBackgroundGradient(WebMolKit.htmlToRGB(bg.substring(0, comma)), WebMolKit.htmlToRGB(bg.substring(comma + 1)));
            }
            if (options.border == 'transparent')
                this.borderCol = WebMolKit.MetaVector.NOCOLOUR;
            else if (options.border)
                this.borderCol = WebMolKit.htmlToRGB(options.border);
            if (options.radius != null)
                this.borderRadius = parseInt(options.radius);
            if (options.scheme == 'wob')
                this.policy = WebMolKit.RenderPolicy.defaultWhiteOnBlack();
            else if (options.scheme == 'cob')
                this.policy = WebMolKit.RenderPolicy.defaultColourOnBlack();
            else if (options.scheme == 'bow')
                this.policy = WebMolKit.RenderPolicy.defaultBlackOnWhite();
            else if (options.scheme == 'cow')
                this.policy = WebMolKit.RenderPolicy.defaultColourOnWhite();
            if (options.scale)
                this.policy.data.pointScale = options.scale;
            if (options.tight == true || options.tight == 'true')
                this.tight = true;
            this.ds = ds;
        }
        render(parent) {
            this.tagType = 'span';
            super.render(parent);
            let span = this.content, ds = this.ds, policy = this.policy;
            span.css('display', 'inline-block');
            span.css('line-height', '0');
            if (!this.tight)
                span.css('margin-bottom', '1.5em');
            if (ds != null) {
                let aspects = new WebMolKit.AspectList(ds).enumerate();
                let columns = this.determineColumns(aspects);
                let table = $('<table></table>').appendTo(span);
                table.css('font-family', '"HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif');
                table.css('border-collapse', 'collapse');
                table.css('line-height', '1');
                table.css('margin', '2px');
                table.css('border', '0');
                let tr = $('<tr></tr>').appendTo(table);
                tr.css('line-height', '1');
                for (let n = 0; n < columns.length; n++) {
                    let th = $('<th></th>').appendTo(tr);
                    th.css('white-space', 'nowrap');
                    th.css('font-weight', '600');
                    th.css('color', 'black');
                    th.css('text-decoration', 'underline');
                    th.css('text-align', 'center');
                    th.css('padding', '0.2em 0.5em 0.2em 0.5em');
                    th.css('border', '0');
                    th.text(columns[n].name);
                }
                for (let row = 0; row < ds.numRows;) {
                    let blksz = 1;
                    for (let aspect of aspects)
                        blksz = Math.max(blksz, aspect.rowBlockCount(row));
                    tr = $('<tr></tr>').appendTo(table);
                    tr.css('line-height', '1');
                    for (let col = 0; col < columns.length; col++) {
                        let td = $('<td></td>').appendTo(tr);
                        td.css('border', '1px solid #D0D0D0');
                        td.css('padding', '0.2em');
                        td.css('vertical-align', 'middle');
                        let spec = columns[col];
                        if (spec.aspect == null) {
                            if (ds.isNull(row, spec.idx))
                                td.text(' ');
                            else if (ds.colType(spec.idx) == WebMolKit.DataSheet.COLTYPE_MOLECULE)
                                this.renderMolecule(td, row, spec.idx);
                            else
                                this.renderPrimitive(td, row, spec.idx);
                        }
                        else if (spec.type == 'text')
                            this.renderTextAspect(td, row, spec.aspect, spec.idx);
                        else if (spec.type == 'graphic')
                            this.renderGraphicAspect(td, row, spec.aspect, spec.idx);
                    }
                    row += blksz;
                }
            }
            else {
                span.css('color', 'red');
                span.text('Unable to parse datasheet: ' + this.failmsg);
                let pre = $('<pre></pre>').appendTo(span);
                pre.css('line-height', '1.1');
                pre.text(this.datastr);
                console.log('Unparseable datasheet source string:\n[' + this.datastr + ']');
            }
        }
        determineColumns(aspects) {
            let ds = this.ds;
            let columns = [];
            let reserved = WebMolKit.Vec.booleanArray(false, ds.numCols);
            let names = [];
            for (let n = 0; n < ds.numCols; n++)
                names.push(ds.colName(n));
            for (let aspect of aspects) {
                if (ds.numRows > 0)
                    for (let n = 0, num = aspect.numTextRenderings(0); n < num; n++) {
                        let title = aspect.produceTextRendering(0, n).name;
                        columns.push({ 'name': title, 'aspect': aspect, 'type': 'text', 'idx': n });
                    }
                if (ds.numRows > 0)
                    for (let n = 0, num = aspect.numGraphicRenderings(0); n < num; n++) {
                        let title = aspect.produceGraphicRendering(0, n, this.policy)[0];
                        columns.push({ 'name': title, 'aspect': aspect, 'type': 'graphic', 'idx': n });
                    }
                let claimed = aspect.areColumnsReserved(names);
                for (let n = 0; n < names.length; n++)
                    reserved[n] = reserved[n] || claimed[n];
            }
            for (let n = 0; n < ds.numCols; n++)
                if (!reserved[n] && ds.colType(n) != WebMolKit.DataSheet.COLTYPE_EXTEND) {
                    columns.push({ 'name': ds.colName(n), 'aspect': null, 'type': null, 'idx': n });
                }
            return columns;
        }
        renderPrimitive(td, row, col) {
            let txt = '', ct = this.ds.colType(col), align = 'center';
            if (ct == WebMolKit.DataSheet.COLTYPE_STRING) {
                txt = this.ds.getString(row, col);
                align = 'left';
            }
            else if (ct == WebMolKit.DataSheet.COLTYPE_INTEGER)
                txt = this.ds.getInteger(row, col).toString();
            else if (ct == WebMolKit.DataSheet.COLTYPE_REAL)
                txt = this.ds.getReal(row, col).toString();
            else if (ct == WebMolKit.DataSheet.COLTYPE_BOOLEAN)
                txt = this.ds.getBoolean(row, col) ? 'true' : 'false';
            td.text(txt);
            td.css('text-align', align);
        }
        renderMolecule(td, row, col) {
            td.css('text-align', 'center');
            let effects = new WebMolKit.RenderEffects();
            let measure = new WebMolKit.OutlineMeasurement(0, 0, this.policy.data.pointScale);
            let layout = new WebMolKit.ArrangeMolecule(this.ds.getMolecule(row, col), measure, this.policy, effects);
            layout.arrange();
            let metavec = new WebMolKit.MetaVector();
            new WebMolKit.DrawMolecule(layout, metavec).draw();
            metavec.normalise();
            let svg = $(metavec.createSVG()).appendTo(td);
        }
        renderTextAspect(td, row, aspect, idx) {
            let rend = aspect.produceTextRendering(row, idx);
            if (!rend.text)
                td.text(' ');
            else if (rend.type == WebMolKit.Aspect.TEXT_PLAIN)
                td.text(rend.text);
            else if (rend.type == WebMolKit.Aspect.TEXT_LINK) {
                let ahref = $('<a target="_blank"></a>').appendTo(td);
                ahref.attr('href', rend.text);
                ahref.text(rend.text);
            }
            else if (rend.type == WebMolKit.Aspect.TEXT_HTML)
                td.html(rend.text);
        }
        renderGraphicAspect(td, row, aspect, idx) {
            let [name, metavec] = aspect.produceGraphicRendering(row, idx, this.policy);
            if (metavec == null) {
                td.text(' ');
                return;
            }
            td.css('text-align', 'center');
            metavec.normalise();
            $(metavec.createSVG()).appendTo(td);
        }
    }
    WebMolKit.EmbedCollection = EmbedCollection;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class EmbedMolecule extends WebMolKit.EmbedChemistry {
        constructor(molstr, options) {
            super();
            this.molstr = molstr;
            this.mol = null;
            this.name = '';
            this.failmsg = '';
            this.maxWidth = 0;
            this.maxHeight = 0;
            this.boxSize = null;
            this.tight = false;
            if (!options)
                options = {};
            let mol = null, name = options.name;
            if (options.format == 'sketchel' || options.format == 'chemical/x-sketchel') {
                mol = WebMolKit.Molecule.fromString(molstr);
            }
            else if (options.format == 'molfile' || options.format == 'chemical/x-mdl-molfile') {
                try {
                    let mdl = new WebMolKit.MDLMOLReader(molstr);
                    mol = mdl.parse();
                    if (mol != null && name == null)
                        name = mdl.molName;
                }
                catch (ex) {
                    this.failmsg = ex;
                }
            }
            else {
                mol = WebMolKit.Molecule.fromString(molstr);
                if (mol == null) {
                    try {
                        let mdl = new WebMolKit.MDLMOLReader(molstr);
                        mol = mdl.parse();
                        if (mol != null && name == null)
                            name = mdl.molName;
                    }
                    catch (ex) { }
                }
            }
            if (mol == null)
                return;
            if (options.invert)
                mol = WebMolKit.CoordUtil.mirrorImage(mol);
            if (options.rotate)
                WebMolKit.CoordUtil.rotateMolecule(mol, options.rotate * WebMolKit.DEGRAD);
            if (options.padding)
                this.padding = options.padding;
            if (options.background == 'transparent')
                this.clearBackground();
            else if (options.background) {
                let bg = options.background, comma = bg.indexOf(',');
                if (comma < 0)
                    this.setBackground(WebMolKit.htmlToRGB(bg));
                else
                    this.setBackgroundGradient(WebMolKit.htmlToRGB(bg.substring(0, comma)), WebMolKit.htmlToRGB(bg.substring(comma + 1)));
            }
            if (options.border == 'transparent')
                this.borderCol = WebMolKit.MetaVector.NOCOLOUR;
            else if (options.border)
                this.borderCol = WebMolKit.htmlToRGB(options.border);
            if (options.radius != null)
                this.borderRadius = parseInt(options.radius);
            if (options.width)
                this.maxWidth = options.width;
            if (options.height)
                this.maxHeight = options.height;
            if (options.box) {
                let box = options.box, comma = box.indexOf(',');
                this.boxSize = new WebMolKit.Size(parseInt(box.substring(0, comma)), parseInt(box.substring(comma + 1)));
            }
            if (options.scheme == 'wob')
                this.policy = WebMolKit.RenderPolicy.defaultWhiteOnBlack();
            else if (options.scheme == 'cob')
                this.policy = WebMolKit.RenderPolicy.defaultColourOnBlack();
            else if (options.scheme == 'bow')
                this.policy = WebMolKit.RenderPolicy.defaultBlackOnWhite();
            else if (options.scheme == 'cow')
                this.policy = WebMolKit.RenderPolicy.defaultColourOnWhite();
            if (options.scale)
                this.policy.data.pointScale = options.scale;
            if (options.tight == true || options.tight == 'true')
                this.tight = true;
            this.mol = mol;
            this.name = name;
        }
        render(parent) {
            this.tagType = 'span';
            super.render(parent);
            let span = this.content, mol = this.mol, policy = this.policy;
            span.css('display', 'inline-block');
            span.css('line-height', '0');
            if (!this.tight)
                span.css('margin-bottom', '1.5em');
            if (mol != null && mol.numAtoms > 0) {
                span.css('text-align', 'center');
                let effects = new WebMolKit.RenderEffects();
                let measure = new WebMolKit.OutlineMeasurement(0, 0, policy.data.pointScale);
                let layout = new WebMolKit.ArrangeMolecule(mol, measure, policy, effects);
                layout.arrange();
                if (this.boxSize)
                    layout.squeezeInto(0, 0, this.boxSize.w, this.boxSize.h);
                else if (this.maxWidth > 0 || this.maxHeight > 0) {
                    let bounds = layout.determineBoundary();
                    let w = bounds[2] - bounds[0], h = bounds[3] - bounds[1];
                    let limW = this.maxWidth == 0 ? w : Math.min(w, this.maxWidth);
                    let limH = this.maxHeight == 0 ? h : Math.min(h, this.maxHeight);
                    if (limW != w || limH != h)
                        layout.squeezeInto(0, 0, limW, limH);
                }
                let metavec = new WebMolKit.MetaVector();
                new WebMolKit.DrawMolecule(layout, metavec).draw();
                if (this.boxSize == null)
                    metavec.normalise();
                else
                    metavec.setSize(this.boxSize.w, this.boxSize.h);
                let svg = $(metavec.createSVG()).appendTo(span);
                if (this.name) {
                    let p = $('<p></p>').appendTo(span);
                    p.css('padding', '0');
                    p.css('padding-top', '0.2em');
                    p.css('margin', 0);
                    p.css('font-family', '"HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif');
                    p.css('line-height', '1');
                    p.css('width', '100%');
                    p.css('color', '#606060');
                    p.text(this.name);
                }
            }
            else {
                span.css('color', 'red');
                span.text('Unable to parse molecule: ' + this.failmsg);
                let pre = $('<pre></pre>').appendTo(span);
                pre.css('line-height', '1.1');
                pre.text(this.molstr);
                console.log('Unparseable molecule source string:\n[' + this.molstr + ']');
            }
        }
    }
    WebMolKit.EmbedMolecule = EmbedMolecule;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let EmbedReactionFacet;
    (function (EmbedReactionFacet) {
        EmbedReactionFacet["HEADER"] = "header";
        EmbedReactionFacet["SCHEME"] = "scheme";
        EmbedReactionFacet["QUANTITY"] = "quantity";
        EmbedReactionFacet["METRICS"] = "metrics";
    })(EmbedReactionFacet = WebMolKit.EmbedReactionFacet || (WebMolKit.EmbedReactionFacet = {}));
    class EmbedReaction extends WebMolKit.EmbedChemistry {
        constructor(datastr, options) {
            super();
            this.datastr = datastr;
            this.row = 0;
            this.entry = null;
            this.failmsg = '';
            this.tight = false;
            this.facet = 'scheme';
            this.limitTotalW = 800;
            this.includeStoich = true;
            this.includeAnnot = false;
            if (!options)
                options = {};
            if (options.encoding == 'base64')
                datastr = WebMolKit.fromUTF8(atob(datastr.trim()));
            let xs = null;
            if (options.format == 'datasheet' || options.format == 'chemical/x-datasheet') {
                let ds = WebMolKit.DataSheetStream.readXML(datastr);
                if (ds == null) {
                    this.failmsg = 'Unable to parse raw XML datasheet.';
                    return;
                }
                if (WebMolKit.Experiment.isExperiment(ds))
                    xs = new WebMolKit.Experiment(ds);
            }
            else {
                let ds = WebMolKit.DataSheetStream.readXML(datastr);
                if (ds == null) {
                    this.failmsg = 'Unable to parse raw XML datasheet.';
                    return;
                }
                if (WebMolKit.Experiment.isExperiment(ds))
                    xs = new WebMolKit.Experiment(ds);
            }
            if (xs == null) {
                this.failmsg = 'Unable to instantiate Experiment aspect.';
                return;
            }
            if (xs.ds.numRows == 0) {
                this.failmsg = 'Experiment datasheet has no rows.';
                return;
            }
            if (options.row)
                this.row = options.row;
            if (this.row < 0 || this.row >= xs.ds.numRows) {
                this.failmsg = 'Requested row ' + this.row + ' out of bounds.';
                return;
            }
            this.entry = xs.getEntry(this.row);
            if (options.facet)
                this.facet = options.facet;
            if (options.padding)
                this.padding = options.padding;
            if (options.background == 'transparent')
                this.clearBackground();
            else if (options.background) {
                let bg = options.background, comma = bg.indexOf(',');
                if (comma < 0)
                    this.setBackground(WebMolKit.htmlToRGB(bg));
                else
                    this.setBackgroundGradient(WebMolKit.htmlToRGB(bg.substring(0, comma)), WebMolKit.htmlToRGB(bg.substring(comma + 1)));
            }
            if (options.border == 'transparent')
                this.borderCol = WebMolKit.MetaVector.NOCOLOUR;
            else if (options.border)
                this.borderCol = WebMolKit.htmlToRGB(options.border);
            if (options.radius != null)
                this.borderRadius = parseInt(options.radius);
            if (options.scheme == 'wob')
                this.policy = WebMolKit.RenderPolicy.defaultWhiteOnBlack();
            else if (options.scheme == 'cob')
                this.policy = WebMolKit.RenderPolicy.defaultColourOnBlack();
            else if (options.scheme == 'bow')
                this.policy = WebMolKit.RenderPolicy.defaultBlackOnWhite();
            else if (options.scheme == 'cow')
                this.policy = WebMolKit.RenderPolicy.defaultColourOnWhite();
            if (options.scale)
                this.policy.data.pointScale = options.scale;
            if (options.tight == true || options.tight == 'true')
                this.tight = true;
            if (options.maximumwidth > 0)
                this.limitTotalW = options.maximumwidth;
            if (options.stoichiometry == false || options.stoichiometry == 'false')
                this.includeStoich = true;
            if (options.annotations == true || options.annotations == 'true')
                this.includeAnnot = true;
        }
        render(parent) {
            this.tagType = 'span';
            super.render(parent);
            let span = this.content;
            span.css('display', 'inline-block');
            span.css('line-height', '0');
            if (!this.tight)
                span.css('margin-bottom', '1.5em');
            if (this.entry != null) {
                if (this.facet == EmbedReactionFacet.HEADER)
                    this.renderHeader(span);
                else if (this.facet == EmbedReactionFacet.SCHEME)
                    this.renderScheme(span);
                else if (this.facet == EmbedReactionFacet.QUANTITY)
                    this.renderQuantity(span);
                else if (this.facet == EmbedReactionFacet.METRICS)
                    this.renderMetrics(span);
            }
            else {
                span.css('color', 'red');
                span.text('Failure to acquire data: ' + this.failmsg);
                let pre = $('<pre></pre>').appendTo(span);
                pre.css('line-height', '1.1');
                pre.text(this.datastr);
                console.log('Unparseable datasheet source string:\n[' + this.datastr + ']');
            }
        }
        renderHeader(span) {
            let table = $('<table></table>').appendTo(span);
            table.css('font-family', '"HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif');
            table.css('border-collapse', 'collapse');
            table.css('line-height', '1');
            table.css('margin', '2px');
            table.css('border', '0');
            let titles = ['Title', 'Created', 'Modified', 'DOI'];
            for (let n = 0; n < 4; n++) {
                if (n == 3 && !this.entry.doi)
                    continue;
                let tr = $('<tr></tr>').appendTo(table);
                tr.css('line-height', '1');
                let th = $('<th></th>').appendTo(tr);
                th.css('white-space', 'nowrap');
                th.css('font-weight', '600');
                th.css('color', 'black');
                th.css('text-align', 'left');
                th.css('vertical-align', 'middle');
                th.css('padding', '0.2em 0.5em 0.2em 0.5em');
                th.css('border', '1px solid #D0D0D0');
                th.text(titles[n]);
                let td = $('<td></td>').appendTo(tr);
                td.css('border', '1px solid #D0D0D0');
                td.css('padding', '0.2em');
                td.css('vertical-align', 'middle');
                if (n == 0) {
                    if (!this.entry.title)
                        td.css('font-style', 'italic');
                    td.text(this.entry.title ? this.entry.title : '(none)');
                }
                else if (n == 1 || n == 2) {
                    let date = n == 1 ? this.entry.createDate : this.entry.modifyDate;
                    if (date == null)
                        td.css('font-style', 'italic');
                    td.text(date == null ? '(none)' : date.toLocaleString());
                }
                else if (n == 3) {
                    let url = this.doiToLink(this.entry.doi);
                    if (url != null && (url.startsWith('http://') || url.startsWith('https://'))) {
                        let ahref = $('<a target="_blank"></a>').appendTo(td);
                        ahref.attr('href', url);
                        ahref.text(this.entry.doi);
                    }
                    else
                        td.text(this.entry.doi);
                }
            }
        }
        renderScheme(span) {
            let measure = new WebMolKit.OutlineMeasurement(0, 0, this.policy.data.pointScale);
            let layout = new WebMolKit.ArrangeExperiment(this.entry, measure, this.policy);
            layout.limitTotalW = this.limitTotalW;
            layout.includeStoich = this.includeStoich;
            layout.includeAnnot = this.includeAnnot;
            layout.arrange();
            let metavec = new WebMolKit.MetaVector();
            new WebMolKit.DrawExperiment(layout, metavec).draw();
            metavec.normalise();
            let svg = $(metavec.createSVG()).appendTo(span);
        }
        renderQuantity(span) {
            let quant = new WebMolKit.QuantityCalc(this.entry);
            quant.calculate();
            let table = $('<table></table>').appendTo(span);
            table.css('font-family', '"HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif');
            table.css('border-collapse', 'collapse');
            table.css('line-height', '1');
            table.css('margin', '2px');
            table.css('border', '0');
            let effects = new WebMolKit.RenderEffects();
            let measure = new WebMolKit.OutlineMeasurement(0, 0, this.policy.data.pointScale);
            for (let n = 0; n < quant.numQuantities; n++) {
                let qc = quant.getQuantity(n);
                let tr = $('<tr></tr>').appendTo(table);
                tr.css('line-height', '1');
                let td = $('<td></td>').appendTo(tr);
                td.css('border', '1px solid #D0D0D0');
                td.css('padding', '0.2em');
                td.css('text-align', 'center');
                td.css('vertical-align', 'middle');
                if (WebMolKit.MolUtil.notBlank(qc.comp.mol)) {
                    let layout = new WebMolKit.ArrangeMolecule(qc.comp.mol, measure, this.policy, effects);
                    layout.arrange();
                    let metavec = new WebMolKit.MetaVector();
                    new WebMolKit.DrawMolecule(layout, metavec).draw();
                    metavec.normalise();
                    let svg = $(metavec.createSVG()).appendTo(td);
                }
                td = $('<td></td>').appendTo(tr);
                td.css('border', '1px solid #D0D0D0');
                td.css('padding', '0.2em');
                td.css('text-align', 'left');
                td.css('vertical-align', 'top');
                this.renderComponentText(td, qc);
            }
        }
        renderComponentText(parent, qc) {
            let title = [], content = [];
            if (qc.comp.name) {
                title.push('Name');
                content.push('<i>' + WebMolKit.escapeHTML(qc.comp.name) + '</i>');
            }
            if (WebMolKit.MolUtil.notBlank(qc.comp.mol)) {
                let mw = WebMolKit.MolUtil.molecularWeight(qc.comp.mol);
                title.push('Weight');
                content.push(mw.toFixed(4));
                let mf = WebMolKit.MolUtil.molecularFormula(qc.comp.mol, ['<sub>', '</sub>', '<sup>', '</sup>']);
                title.push('Formula');
                content.push(mf);
            }
            if (qc.valueEquiv > 0) {
                let text = qc.valueEquiv.toString(), stat = qc.statEquiv;
                if (stat == WebMolKit.QuantityCalc.STAT_VIRTUAL)
                    text = "<i>(" + text + ")</i>";
                else if (stat == WebMolKit.QuantityCalc.STAT_CONFLICT)
                    text += " (conflicting)";
                title.push('Stoichiometry');
                content.push(text);
            }
            if (qc.valueMass > 0) {
                let text = WebMolKit.QuantityCalc.formatMass(qc.valueMass), stat = qc.statMass;
                if (stat == WebMolKit.QuantityCalc.STAT_VIRTUAL)
                    text = "<i>(" + text + ")</i>";
                else if (stat == WebMolKit.QuantityCalc.STAT_CONFLICT)
                    text += " (conflicting)";
                title.push('Mass');
                content.push(text);
            }
            if (qc.valueVolume > 0) {
                let text = WebMolKit.QuantityCalc.formatVolume(qc.valueVolume), stat = qc.statVolume;
                if (stat == WebMolKit.QuantityCalc.STAT_VIRTUAL)
                    text = "<i>(" + text + ")</i>";
                else if (stat == WebMolKit.QuantityCalc.STAT_CONFLICT)
                    text += " (conflicting)";
                title.push('Volume');
                content.push(text);
            }
            if (qc.valueMoles > 0) {
                let text = WebMolKit.QuantityCalc.formatMoles(qc.valueMoles), stat = qc.statMoles;
                if (stat == WebMolKit.QuantityCalc.STAT_VIRTUAL)
                    text = "<i>(" + text + ")</i>";
                else if (stat == WebMolKit.QuantityCalc.STAT_CONFLICT)
                    text += " (conflicting)";
                title.push('Moles');
                content.push(text);
            }
            if (qc.valueDensity > 0) {
                let text = WebMolKit.QuantityCalc.formatDensity(qc.valueDensity), stat = qc.statDensity;
                if (stat == WebMolKit.QuantityCalc.STAT_VIRTUAL)
                    text = "<i>(" + text + ")</i>";
                else if (stat == WebMolKit.QuantityCalc.STAT_CONFLICT)
                    text += " (conflicting)";
                title.push('Density');
                content.push(text);
            }
            if (qc.valueConc > 0) {
                let text = WebMolKit.QuantityCalc.formatConc(qc.valueConc), stat = qc.statConc;
                if (stat == WebMolKit.QuantityCalc.STAT_VIRTUAL)
                    text = "<i>(" + text + ")</i>";
                else if (stat == WebMolKit.QuantityCalc.STAT_CONFLICT)
                    text += " (conflicting)";
                title.push('Concentration');
                content.push(text);
            }
            if (qc.valueYield > 0 && !qc.comp.waste) {
                let text = WebMolKit.QuantityCalc.formatPercent(qc.valueYield), stat = qc.statYield;
                if (stat == WebMolKit.QuantityCalc.STAT_VIRTUAL)
                    text = "<i>(" + text + ")</i>";
                else if (stat == WebMolKit.QuantityCalc.STAT_CONFLICT)
                    text += " (conflicting)";
                title.push('Yield');
                content.push(text);
            }
            for (let n = 0; n < title.length; n++) {
                let p = $('<p></p>').appendTo(parent);
                p.css('margin', '0.1em');
                p.append($('<b>' + title[n] + '</b>'));
                p.append(': ');
                p.append(content[n]);
            }
        }
        renderMetrics(span) {
            let quant = new WebMolKit.QuantityCalc(this.entry);
            quant.calculate();
            let table = $('<table></table>').appendTo(span);
            table.css('font-family', '"HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif');
            table.css('border-collapse', 'collapse');
            table.css('line-height', '1');
            table.css('margin', '2px');
            table.css('border', '0');
            let effects = new WebMolKit.RenderEffects();
            let measure = new WebMolKit.OutlineMeasurement(0, 0, this.policy.data.pointScale);
            if (quant.numGreenMetrics > 0)
                for (let n = 0; n < 3; n++) {
                    let tr = $('<tr></tr>').appendTo(table);
                    tr.css('line-height', '1');
                    let th = $('<th></th>').appendTo(tr);
                    th.css('border', '1px solid #D0D0D0');
                    th.css('padding', '0.5em');
                    th.css('text-align', 'right');
                    th.css('vertical-align', 'middle');
                    th.css('white-space', 'nowrap');
                    th.css('font-weight', 'bold');
                    th.text(n == 0 ? 'All Reactants' : n == 1 ? 'All Products' : 'All Waste');
                    let td = $('<td></td>').appendTo(tr);
                    td.css('border', '1px solid #D0D0D0');
                    td.css('padding', '0.5em');
                    td.css('text-align', 'left');
                    td.css('vertical-align', 'middle');
                    td.css('white-space', 'nowrap');
                    if (n == 0) {
                        td.text(this.combineQuant(quant.getAllMassReact(), 'g') + ' = ' + this.sumQuant(quant.getAllMassReact(), 'g', true));
                    }
                    else if (n == 1) {
                        td.text(this.combineQuant(quant.getAllMassProd(), 'g') + ' = ' + this.sumQuant(quant.getAllMassProd(), 'g', true));
                    }
                    else if (n == 2) {
                        if (quant.getAllMassWaste().length > 0)
                            td.text(this.combineQuant(quant.getAllMassWaste(), 'g') + ' = ' + this.sumQuant(quant.getAllMassWaste(), 'g', false));
                        else
                            td.text('none');
                    }
                }
            else {
                let tr = $('<tr></tr>').appendTo(table);
                let td = $('<td></td>').appendTo(tr);
                td.text('No metrics to show.');
            }
            for (let n = 0; n < quant.numGreenMetrics; n++) {
                let gm = quant.getGreenMetrics(n);
                let qc = quant.getQuantity(gm.idx);
                let tr = $('<tr></tr>').appendTo(table);
                tr.css('line-height', '1');
                let td = $('<td></td>').appendTo(tr);
                td.css('border', '1px solid #D0D0D0');
                td.css('padding', '0.2em');
                td.css('text-align', 'center');
                td.css('vertical-align', 'middle');
                if (WebMolKit.MolUtil.notBlank(qc.comp.mol)) {
                    let layout = new WebMolKit.ArrangeMolecule(qc.comp.mol, measure, this.policy, effects);
                    layout.arrange();
                    let metavec = new WebMolKit.MetaVector();
                    new WebMolKit.DrawMolecule(layout, metavec).draw();
                    metavec.normalise();
                    $(metavec.createSVG()).appendTo(td);
                }
                td = $('<td></td>').appendTo(tr);
                td.css('border', '1px solid #D0D0D0');
                td.css('padding', '0.5em');
                td.css('text-align', 'left');
                td.css('vertical-align', 'top');
                let pmi1 = this.combineQuant(gm.massReact, 'g'), pmi2 = this.combineQuant(gm.massProd, 'g');
                let pmi3 = this.sumQuantExt(gm.massReact, gm.massProd, 1, Number.NaN, null);
                let vg = this.drawTotals('PMI', pmi1, pmi2, pmi3);
                vg.normalise();
                let para = $('<p></p>').appendTo(td);
                $(vg.createSVG()).appendTo(para);
                let ef1 = this.combineQuant(gm.massWaste, 'g'), ef2 = this.combineQuant(gm.massProd, 'g');
                let ef3 = this.sumQuantExt(gm.massWaste, gm.massProd, 1, Number.NaN, null);
                vg = this.drawTotals('E-factor', ef1, ef2, ef3);
                vg.normalise();
                para = $('<p></p>').appendTo(td);
                $(vg.createSVG()).appendTo(para);
                let ae1 = this.combineQuant(gm.molwProd, null), ae2 = this.combineQuant(gm.molwReact, null);
                let ae3 = this.sumQuantExt(gm.molwProd, gm.molwReact, 100, 100, '%');
                vg = this.drawTotals('Atom-E', ae1, ae2, ae3);
                vg.normalise();
                para = $('<p></p>').appendTo(td);
                $(vg.createSVG()).appendTo(para);
            }
        }
        combineQuant(values, units) {
            if (values.length == 0)
                return '?';
            let str = '';
            for (let n = 0; n < values.length; n++) {
                if (n > 0)
                    str += ' + ';
                if (values[n] == WebMolKit.QuantityCalc.UNSPECIFIED) {
                    str += '?';
                }
                else {
                    str += WebMolKit.formatDouble(values[n], 4);
                    if (units)
                        str += ' ' + units;
                }
            }
            return str;
        }
        sumQuant(values, units, requireSomething) {
            if (values.length == 0)
                return requireSomething ? '?' : '0';
            let sum = 0;
            for (let n = 0; n < values.length; n++) {
                if (values[n] == WebMolKit.QuantityCalc.UNSPECIFIED)
                    return '?';
                sum += values[n];
            }
            let ret = WebMolKit.formatDouble(sum, 4);
            if (units)
                ret += ' ' + units;
            return ret;
        }
        sumQuantExt(numer, denom, mul, max, units) {
            if (numer.length == 0 || denom.length == 0)
                return '?';
            let sum1 = 0, sum2 = 0;
            for (let n = 0; n < numer.length; n++) {
                if (numer[n] == WebMolKit.QuantityCalc.UNSPECIFIED)
                    return '?';
                sum1 += numer[n];
            }
            for (let n = 0; n < denom.length; n++) {
                if (denom[n] == WebMolKit.QuantityCalc.UNSPECIFIED)
                    return '?';
                sum2 += denom[n];
            }
            if (sum2 <= 0)
                return '?';
            let val = mul * sum1 / sum2;
            if (!Number.isNaN(max))
                val = Math.min(val, max);
            let ret = WebMolKit.formatDouble(val, 4);
            if (units)
                ret += ' ' + units;
            return ret;
        }
        drawTotals(heading, over, under, answer) {
            let vg = new WebMolKit.MetaVector();
            let measure = new WebMolKit.OutlineMeasurement(0, 0, this.policy.data.pointScale);
            let sep = ' = ';
            let fsz = this.policy.data.pointScale * 0.8;
            let wadHeading = measure.measureText(heading, fsz);
            let wadOver = measure.measureText(over, fsz), wadUnder = measure.measureText(under, fsz);
            let wadAnswer = measure.measureText(answer, fsz);
            let wadSep = measure.measureText(sep, fsz);
            let x = 0;
            vg.drawText(x, 0, heading, fsz, 0x000000, WebMolKit.TextAlign.Left | WebMolKit.TextAlign.Middle);
            x += wadHeading[0];
            vg.drawText(x, 0, sep, fsz, 0x000000, WebMolKit.TextAlign.Left | WebMolKit.TextAlign.Middle);
            x += wadSep[0];
            vg.drawText(x, 0, answer, fsz, 0x000000, WebMolKit.TextAlign.Left | WebMolKit.TextAlign.Middle);
            x += wadAnswer[0];
            vg.drawText(x, 0, sep, fsz, 0x000000, WebMolKit.TextAlign.Left | WebMolKit.TextAlign.Middle);
            x += wadSep[0];
            let lw = Math.max(wadOver[0], wadUnder[0]);
            vg.drawLine(x, 0, x + lw, 0, 0x000000, 1);
            vg.drawText(x + 0.5 * lw, -2, over, fsz, 0x000000, WebMolKit.TextAlign.Centre | WebMolKit.TextAlign.Bottom);
            vg.drawText(x + 0.5 * lw, 2, under, fsz, 0x000000, WebMolKit.TextAlign.Centre | WebMolKit.TextAlign.Top);
            return vg;
        }
        doiToLink(doi) {
            if (doi.startsWith('http://') || doi.startsWith('https://'))
                return doi;
            let m = EmbedReaction.PTN_DOI1.exec(doi);
            if (m)
                return 'http://dx.doi.org/' + m[1];
            m = EmbedReaction.PTN_DOI2.exec(doi);
            if (m)
                return 'http://dx.doi.org/' + m[1];
            m = EmbedReaction.PTN_ISBN.exec(doi);
            if (m)
                return 'ISBN: ' + m[1];
            return null;
        }
    }
    EmbedReaction.PTN_DOI1 = /^doi:(\d+\.\d+\/.*)$/;
    EmbedReaction.PTN_DOI2 = /^(\d+\.\d+\/.*)$/;
    EmbedReaction.PTN_ISBN = /^(\d+-\d+-\d+-\d+-\d+)$/;
    WebMolKit.EmbedReaction = EmbedReaction;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    const CSS_POPUP = `
    *.wmk-popup
    {
        font-family: 'Open Sans', sans-serif;
    }
`;
    class Popup {
        constructor(parent) {
            this.parent = parent;
            this.callbackClose = null;
            this.callbackPopulate = null;
            WebMolKit.installInlineCSS('popup', CSS_POPUP);
        }
        onClose(callback) {
            this.callbackClose = callback;
        }
        open() {
            let body = $(document.documentElement);
            let bg = this.obscureBackground = $('<div></div>').appendTo(body);
            bg.css('width', '100%');
            bg.css('height', document.documentElement.clientHeight + 'px');
            bg.css('background-color', 'black');
            bg.css('opacity', 0.2);
            bg.css('position', 'absolute');
            bg.css('left', 0);
            bg.css('top', 0);
            bg.css('z-index', 9999);
            bg.click(() => this.close());
            this.obscureBackground = bg;
            let pb = this.panelBoundary = $('<div class="wmk-popup"></div>').appendTo(body);
            pb.click((event) => event.stopPropagation());
            pb.css('background-color', 'white');
            pb.css('border', '1px solid black');
            pb.css('position', 'absolute');
            pb.css('z-index', 10000);
            let bd = this.bodyDiv = $('<div></div>').appendTo(pb);
            bd.css('padding', '0.5em');
            bg.show();
            this.populate();
            this.positionAndShow();
        }
        close() {
            this.panelBoundary.remove();
            this.obscureBackground.remove();
            if (this.callbackClose)
                this.callbackClose(this);
        }
        bump() {
            this.positionAndShow();
        }
        body() { return this.bodyDiv; }
        populate() {
            if (this.callbackPopulate)
                this.callbackPopulate(this);
            else
                this.body().text('Empty popup.');
        }
        positionAndShow() {
            let winW = $(window).width(), winH = $(window).height();
            const GAP = 2;
            let wx1 = this.parent.offset().left, wy1 = this.parent.offset().top;
            let wx2 = wx1 + this.parent.width(), wy2 = wy1 + this.parent.height();
            let pb = this.panelBoundary;
            let maxW = Math.max(wx1, winW - wx2) - 4;
            pb.css('max-width', maxW + 'px');
            let setPosition = () => {
                let popW = pb.width(), popH = pb.height();
                let posX = 0, posY = 0;
                if (wx1 + popW < winW)
                    posX = wx1;
                else if (popW < wx2)
                    posX = wx2 - popW;
                if (wy2 + GAP + popH < winH)
                    posY = wy2 + GAP;
                else if (wy1 - GAP - popH > 0)
                    posY = wy1 - GAP - popH;
                else
                    posY = wy2 + GAP;
                pb.css('left', `${posX}px`);
                pb.css('top', `${posY}px`);
            };
            setPosition();
            pb.show();
            window.setTimeout(() => setPosition());
        }
    }
    WebMolKit.Popup = Popup;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class RowView extends WebMolKit.Widget {
        constructor(tokenID) {
            super();
            this.tokenID = tokenID;
            this.entries = null;
            this.watermark = 0;
        }
        defineEntries(entries) {
            this.entries = entries;
        }
        render(parent) {
            super.render(parent);
            if (this.entries == null)
                throw 'molsync.ui.RowView: entries must be defined before rendering';
            let tableStyle = 'border-collapse: collapse;';
            let table = $('<table></table>').appendTo(this.content);
            table.attr('style', tableStyle);
            let roster = [];
            this.watermark++;
            for (let n = 0; n < this.entries.length; n++) {
                let entry = this.entries[n];
                entry.tr = $('<tr></tr>').appendTo(table);
                entry = WebMolKit.clone(entry);
                entry.tdStyle = '';
                if (n > 0)
                    entry.tdStyle += 'border-top: 1px solid #80C080;';
                if (n < this.entries.length - 1)
                    entry.tdStyle += 'border-bottom: 1px solid #80C080;';
                entry.watermark = this.watermark;
                roster.push(entry);
            }
            let fcnComposure = (result, error) => {
                let entry = roster.shift();
                if (entry.watermark != this.watermark)
                    return;
                if (error != null)
                    throw 'molsync.ui.RowView: failed to obtain document composition: ' + error.message;
                let nodes = [];
                for (let n = 0; n < result.doc.nodes.length; n++) {
                    let node = result.doc.nodes[n];
                    let src = node.src;
                    if (src.startsWith('experiment:') && src != 'experiment:header' && src != 'experiment:scheme')
                        continue;
                    nodes.push(node);
                }
                for (let n = 0; n < nodes.length; n++) {
                    let tdStyle = entry.tdStyle + 'vertical-align: top;';
                    if (n > 0)
                        tdStyle += 'border-left: 1px solid #80C080;';
                    if (n < nodes.length - 1)
                        tdStyle += 'border-right: 1px solid #80C080;';
                    if (nodes[n].type != 'graphics')
                        tdStyle += 'padding: 0.5em;';
                    let td = $('<td></td>').appendTo(entry.tr);
                    td.attr('style', tdStyle);
                    this.renderNode(td, nodes[n]);
                }
                if (roster.length > 0)
                    WebMolKit.Func.composeDocument({ 'tokenID': this.tokenID, 'dataXML': roster[0].dataXML, 'subsumeTitle': true }, fcnComposure);
            };
            if (roster.length > 0)
                WebMolKit.Func.composeDocument({ 'tokenID': this.tokenID, 'dataXML': roster[0].dataXML, 'subsumeTitle': true }, fcnComposure);
        }
        renderNode(parent, node) {
            if (node.type == 'line')
                this.renderLine(parent, node, true);
            else if (node.type == 'link')
                this.renderLink(parent, node);
            else if (node.type == 'graphics')
                this.renderGraphics(parent, node);
            else if (node.type == 'para')
                this.renderPara(parent, node);
            else if (node.type == 'matrix')
                this.renderMatrix(parent, node);
        }
        renderLine(parent, node, inPara) {
            if (inPara)
                parent = $(WebMolKit.newElement(parent, 'p'));
            if (node.title) {
                WebMolKit.addText(WebMolKit.newElement(parent, 'b'), node.title);
                WebMolKit.addText(parent[0], ': ');
            }
            if (node.bold)
                parent = $(WebMolKit.newElement(parent, 'b'));
            if (node.italic)
                parent = $(WebMolKit.newElement(parent, 'i'));
            if (node.underline)
                parent = $(WebMolKit.newElement(parent, 'u'));
            if (node.formula)
                this.renderFormula(parent, node.text);
            else
                WebMolKit.addText(parent, node.text);
        }
        renderLink(parent, node) {
            if (node.title) {
                WebMolKit.addText(WebMolKit.newElement(parent, 'b'), node.title);
                WebMolKit.addText(parent[0], ': ');
            }
            let ahref = WebMolKit.newElement(parent, 'a', { 'href': node.url, 'target': '_blank' });
            WebMolKit.addText(ahref, node.url);
        }
        renderGraphics(parent, node) {
            let draw = new WebMolKit.MetaVector(node.metavec);
            draw.renderInto(parent);
        }
        renderPara(parent, node) {
            parent = $('<p></p>').appendTo(parent);
            for (let n = 0; n < node.nodes.length; n++) {
                let sub = node.nodes[n];
                if (n > 0)
                    WebMolKit.newElement(parent, 'br');
                if (sub.type == 'line')
                    this.renderLine(parent, sub, false);
                else
                    this.renderNode(parent, sub);
            }
        }
        renderMatrix(parent, node) {
            let ncols = node.ncols, nrows = node.nrows;
            let table = WebMolKit.newElement(parent, 'table', { 'class': 'data', 'style': 'margin: 0;' });
            let tableBody = WebMolKit.newElement(table, 'tbody');
            for (let r = 0; r < nrows; r++) {
                let tableRow = WebMolKit.newElement(tableBody, 'tr');
                for (let c = 0; c < ncols; c++) {
                    let cell = node.matrix[r][c];
                    let tableCell = WebMolKit.newElement(tableRow, 'td', { 'class': 'data' });
                    this.renderNode($(tableCell), cell);
                }
            }
        }
        renderFormula(parent, formula) {
            for (let n = 0; n < formula.length; n++) {
                let ch = formula.charAt(n);
                if (ch == '|') { }
                else if (ch == '{') {
                    let end = formula.indexOf('}', n + 1);
                    if (end >= 0) {
                        let snip = formula.substring(n + 1, end);
                        WebMolKit.addText(WebMolKit.newElement(parent, 'sub'), snip);
                        n = end;
                    }
                    else
                        WebMolKit.addText(parent, ch);
                }
                else
                    WebMolKit.addText(parent, ch);
            }
        }
    }
    WebMolKit.RowView = RowView;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class SearchMolecules extends WebMolKit.Widget {
        constructor(tokenID) {
            super();
            this.tokenID = tokenID;
            this.molsearchToken = null;
            this.cancelled = false;
            this.started = false;
            this.finished = false;
            this.progress = 0;
            this.count = 0;
            this.results = [];
            this.callbackStop = null;
            this.callbackProgress = null;
            this.callbackMol = null;
            this.callbackDS = null;
        }
        render(parent) {
            super.render(parent);
            let tableStyle = 'border-collapse: collapse;';
            this.table = $('<table></table>').appendTo(this.content);
            this.table.attr('style', tableStyle);
        }
        startSearch(origin, mol, type, maxResults = 100) {
            this.cancelled = false;
            this.results = [];
            this.table.empty();
            this.placeholder = $('<tr><td>Starting search...</td></tr>').appendTo(this.table);
            let molstr = mol == null ? null : mol.toString();
            let param = { 'origin': origin, 'molNative': molstr, 'type': type, 'maxResults': maxResults };
            WebMolKit.Search.startMolSearch(param, (result, error) => {
                if (error != null)
                    throw 'molsync.ui.SearchMolecules: failed to initiate search: ' + error.message;
                this.molsearchToken = result.molsearchToken;
                this.started = true;
                this.finished = false;
                WebMolKit.Search.pollMolSearch({ 'molsearchToken': this.molsearchToken }, () => this.batchSearch(result, error));
            });
        }
        stopSearch() {
            if (this.placeholder) {
                this.placeholder.remove();
                this.placeholder = null;
            }
            this.cancelled = true;
            this.finished = true;
            if (this.callbackStop)
                this.callbackStop(this);
        }
        isRunning() {
            return this.started && !this.finished;
        }
        batchSearch(result, error) {
            if (this.placeholder) {
                this.placeholder.remove();
                this.placeholder = null;
            }
            if (error != null)
                throw 'molsync.ui.SearchMolecules: failed to obtain next batch: ' + error.message;
            if (this.cancelled)
                return;
            this.finished = result.finished;
            this.progress = result.progress;
            this.count = result.count;
            if (result.modified)
                this.updateResults(result.results);
            if (!this.finished) {
                WebMolKit.Search.pollMolSearch({ 'molsearchToken': this.molsearchToken }, (result, error) => this.batchSearch(result, error));
                if (this.callbackProgress)
                    this.callbackProgress(this.progress, this.count, this);
            }
            else {
                if (this.callbackStop)
                    this.callbackStop(this);
            }
        }
        updateResults(results) {
            for (let n = 0; n < results.length; n++) {
                let res = results[n];
                res.tr = $('<tr></tr>').appendTo(this.table);
                res.td = $('<td></td>').appendTo(res.tr);
                if (n > 0)
                    res.td.css('border-top', '1px solid #80C080');
                if (n < results.length - 1)
                    res.td.css('border-bottom', '1px solid #80C080');
                let table = $('<table></table>').appendTo(res.td), tr = $('<tr></tr>').appendTo(table);
                if (res.similarity) {
                    let td = $('<td></td>').appendTo(tr);
                    let txt = res.similarity == 1 ? '100%' : (res.similarity * 100).toFixed(1) + '%';
                    td.text(txt);
                }
                for (let sk of res.sketches) {
                    let td = $('<td></td>').appendTo(tr);
                    let vs = this.grabSketch(td, sk.molNative, sk.moleculeID);
                    sk.viewMol = vs;
                }
                let td = $('<td></td>').appendTo(tr);
                for (let src of res.sources) {
                    let link = $('<a href="#' + src.datasheetID + '"></a>').appendTo(td);
                    link.mouseenter((e) => e.target.style.backgroundColor = '#D0D0D0');
                    link.mouseleave((e) => e.target.style.backgroundColor = 'transparent');
                    let title = src.subTitle ? src.subTitle : src.title ? src.title : 'DataSheet#' + src.datasheetID;
                    link.text(title);
                    let body = '';
                    if (src.title && src.title != title)
                        body += '<div>Title: <i>' + WebMolKit.escapeHTML(src.title) + '</i></div>';
                    if (src.descr)
                        body += '<div>Description: <i>' + WebMolKit.escapeHTML(src.descr) + '</i></div>';
                    body += '<div>Row ' + src.row + '</div>';
                    WebMolKit.addTooltip(link, body, WebMolKit.escapeHTML(title));
                    link.click(() => { if (this.callbackDS)
                        this.callbackDS(src.datasheetID, this); });
                    td.append(' ');
                }
            }
            for (let res of this.results)
                res.tr.remove();
            this.results = results;
        }
        grabSketch(parent, molNative, moleculeID) {
            for (let res of this.results)
                for (let sk of res.sketches) {
                    for (let mid of moleculeID)
                        if (sk.moleculeID.indexOf(mid) >= 0 && sk.viewMol != null) {
                            sk.viewMol.content.appendTo(parent);
                            return sk.viewMol;
                        }
                }
            const vs = new WebMolKit.ViewStructure(this.tokenID);
            vs.content = parent;
            vs.defineMoleculeString(molNative);
            vs.borderCol = -1;
            vs.backgroundCol1 = 0xF8F8F8;
            vs.backgroundCol2 = 0xE0E0E0;
            vs.padding = 4;
            vs.setup(() => {
                vs.render(parent);
                vs.content.css('cursor', 'pointer');
                vs.content.click(() => {
                    if (this.callbackMol)
                        this.callbackMol(moleculeID, WebMolKit.Molecule.fromString(molNative));
                });
            });
            return vs;
        }
    }
    SearchMolecules.TYPE_EXACT = 'exact';
    SearchMolecules.TYPE_SUBSTRUCTURE = 'substructure';
    SearchMolecules.TYPE_SIMILARITY = 'similarity';
    SearchMolecules.TYPE_RANDOM = 'random';
    WebMolKit.SearchMolecules = SearchMolecules;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class SearchPanel extends WebMolKit.Widget {
        constructor(type) {
            super();
            this.type = type;
            this.onChange = null;
            this.highlight = 0;
            this.pressed = 0;
            this.mol1 = new WebMolKit.Molecule();
            this.mol2 = new WebMolKit.Molecule();
            this.isSketching = false;
            this.height = 50;
            this.molWidth = 80;
            this.arrowWidth = 30;
            this.HPADDING = 4;
            this.VPADDING = 2;
            this.emptyMsg1 = null;
            this.emptyMsg2 = null;
        }
        configureDisplay(molWidth, height, emptyMsg1, emptyMsg2) {
            this.molWidth = molWidth;
            this.height = height;
            this.emptyMsg1 = emptyMsg1;
            this.emptyMsg2 = emptyMsg2;
        }
        getMolecule1() { return this.mol1; }
        getMolecule2() { return this.mol2; }
        setMolecule1(mol) {
            this.mol1 = mol;
            this.renderMolecule(1);
        }
        setMolecule2(mol) {
            this.mol2 = mol;
            this.renderMolecule(2);
        }
        render(parent) {
            super.render(parent);
            this.content.addClass('no_selection');
            const height = this.height, molw = this.molWidth, arrow = this.arrowWidth;
            const density = WebMolKit.pixelDensity();
            const hpad = this.HPADDING, vpad = this.VPADDING;
            let isRxn = this.type == SearchPanel.TYPE_REACTION, isMol = !isRxn;
            let div = this.content;
            if (isMol)
                div.css('width', (molw + 2 * hpad) + 'px');
            else
                div.css('width', (2 * molw + arrow + 4 * hpad) + 'px');
            div.css('height', (height + 2 * vpad) + 'px');
            div.css('position', 'relative');
            let renderSolid = (col1, col2, style) => {
                let node = WebMolKit.newElement(div, 'canvas', { 'width': molw * density, 'height': height * density, 'style': style });
                node.style.width = molw + 'px';
                node.style.height = height + 'px';
                let ctx = node.getContext('2d');
                ctx.scale(density, density);
                let grad = ctx.createLinearGradient(0, 0, molw, height);
                grad.addColorStop(0, col1);
                grad.addColorStop(1, col2);
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, molw, height);
                return node;
            };
            let renderBorder = (lw, style) => {
                let node = WebMolKit.newElement(div, 'canvas', { 'width': molw * density, 'height': height * density, 'style': style });
                node.style.width = molw + 'px';
                node.style.height = height + 'px';
                let ctx = node.getContext('2d');
                ctx.scale(density, density);
                ctx.strokeStyle = 'black';
                ctx.lineWidth = lw;
                ctx.strokeRect(0.5 * lw, 0.5 * lw, molw - lw, height - lw);
                return node;
            };
            let renderArrow = (style) => {
                let node = WebMolKit.newElement(div, 'canvas', { 'width': arrow * density, 'height': height * density, 'style': style });
                node.style.width = arrow + 'px';
                node.style.height = height + 'px';
                let ctx = node.getContext('2d');
                ctx.scale(density, density);
                let midY = Math.round(0.5 * height);
                ctx.beginPath();
                ctx.moveTo(0, midY);
                ctx.lineTo(arrow - 2, midY);
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(arrow, midY);
                ctx.lineTo(arrow - 8, midY - 5);
                ctx.lineTo(arrow - 8, midY + 5);
                ctx.fillStyle = 'black';
                ctx.fill();
                return node;
            };
            let renderOutlineArrow = (style, col) => {
                let node = WebMolKit.newElement(div, 'canvas', { 'width': arrow * density, 'height': height * density, 'style': style });
                node.style.width = arrow + 'px';
                node.style.height = height + 'px';
                let ctx = node.getContext('2d');
                ctx.scale(density, density);
                let midY = Math.round(0.5 * height);
                var path = WebMolKit.pathRoundedRect(0, midY - 8, arrow, midY + 8, 4);
                ctx.fillStyle = col;
                ctx.fill(path);
                return node;
            };
            let styleMol1Pos = 'position: absolute; left: ' + hpad + 'px; top: ' + vpad + 'px;';
            let styleMol1 = styleMol1Pos + 'pointer-events: none;';
            this.normalMol1 = renderSolid('#FFFFFF', '#D0D0D0', styleMol1);
            this.pressedMol1 = renderSolid('#00CA59', '#008650', styleMol1);
            this.drawnMol1 = WebMolKit.newElement(div, 'canvas', { 'width': molw * density, 'height': height * density, 'style': styleMol1Pos });
            this.drawnMol1.style.cursor = 'pointer';
            this.renderMolecule(1);
            this.thinMol1 = renderBorder(1, styleMol1);
            this.thickMol1 = renderBorder(2, styleMol1);
            if (isRxn) {
                let styleArrowPos = 'position: absolute; left: ' + (2 * hpad + molw) + 'px; top: ' + vpad + 'px;';
                let styleArrow = styleArrowPos + 'pointer-events: none;';
                this.hoverArrow = renderOutlineArrow(styleArrow, '#C0C0C0');
                this.pressedArrow = renderOutlineArrow(styleArrow, '#00CA59');
                this.drawnArrow = renderArrow(styleArrowPos);
                let styleMol2Pos = 'position: absolute; left: ' + (3 * hpad + molw + arrow) + 'px; top: ' + vpad + 'px;';
                let styleMol2 = styleMol2Pos + 'pointer-events: none;';
                this.normalMol2 = renderSolid('#FFFFFF', '#D0D0D0', styleMol2);
                this.pressedMol2 = renderSolid('#00CA59', '#008650', styleMol2);
                this.drawnMol2 = WebMolKit.newElement(div, 'canvas', { 'width': molw * density, 'height': height * density, 'style': styleMol2Pos });
                this.drawnMol2.style.cursor = 'pointer';
                this.renderMolecule(2);
                this.thinMol2 = renderBorder(1, styleMol2);
                this.thickMol2 = renderBorder(2, styleMol2);
            }
            this.updateLayers();
            $(this.drawnMol1).mouseenter(() => this.mouseEnter(1));
            $(this.drawnMol1).mouseleave(() => this.mouseLeave(1));
            $(this.drawnMol1).mousedown(() => this.mouseDown(1));
            $(this.drawnMol1).mouseup(() => this.mouseUp(1));
            $(this.drawnMol1).attr('ondragstart', () => false);
            $(this.drawnMol1).click(() => this.editMolecule(1));
            if (isRxn) {
                $(this.drawnArrow).mouseenter(() => this.mouseEnter(3));
                $(this.drawnArrow).mouseleave(() => this.mouseLeave(3));
                $(this.drawnArrow).mousedown(() => this.mouseDown(3));
                $(this.drawnArrow).mouseup(() => this.mouseUp(3));
                $(this.drawnArrow).attr('ondragstart', () => false);
                $(this.drawnArrow).click(() => this.editMapping());
                $(this.drawnMol2).mouseenter(() => this.mouseEnter(2));
                $(this.drawnMol2).mouseleave(() => this.mouseLeave(2));
                $(this.drawnMol2).mousedown(() => this.mouseDown(2));
                $(this.drawnMol2).mouseup(() => this.mouseUp(2));
                $(this.drawnMol2).attr('ondragstart', () => false);
                $(this.drawnMol2).click(() => this.editMolecule(2));
            }
            if (!isRxn) {
                WebMolKit.addTooltip(this.drawnMol1, 'Edit the molecular structure.');
            }
            else {
                WebMolKit.addTooltip(this.drawnMol1, 'Edit the reactant structures.');
                WebMolKit.addTooltip(this.drawnMol2, 'Edit the product structures.');
                WebMolKit.addTooltip(this.drawnArrow, 'Map the reactant and product atoms, for more precise searches.');
            }
            document.addEventListener('paste', (e) => {
                if (this.isSketching)
                    return true;
                let wnd = window, txt = '';
                if (wnd.clipboardData && wnd.clipboardData.getData)
                    txt = wnd.clipboardData.getData('Text');
                else if (e.clipboardData && e.clipboardData.getData)
                    txt = e.clipboardData.getData('text/plain');
                if (!txt)
                    return true;
                let mol = WebMolKit.MoleculeStream.readUnknown(txt);
                if (!mol)
                    return true;
                let which = this.type == SearchPanel.TYPE_REACTION && !WebMolKit.MolUtil.isBlank(this.mol1) && WebMolKit.MolUtil.isBlank(this.mol2) ? 2 : 1;
                if (which == 1)
                    this.setMolecule1(mol);
                else
                    this.setMolecule2(mol);
                e.preventDefault();
                if (this.onChange)
                    this.onChange(this);
                return false;
            });
            this.drawnMol1.addEventListener('dragover', (event) => {
                event.stopPropagation();
                event.preventDefault();
                event.dataTransfer.dropEffect = 'copy';
            });
            this.drawnMol1.addEventListener('drop', (event) => {
                event.stopPropagation();
                event.preventDefault();
                this.dropInto(1, event.dataTransfer);
            });
            if (isRxn) {
                this.drawnMol2.addEventListener('dragover', (event) => {
                    event.stopPropagation();
                    event.preventDefault();
                    event.dataTransfer.dropEffect = 'copy';
                });
                this.drawnMol2.addEventListener('drop', (event) => {
                    event.stopPropagation();
                    event.preventDefault();
                    this.dropInto(2, event.dataTransfer);
                });
            }
        }
        ;
        updateLayers() {
            WebMolKit.setVisible(this.normalMol1, this.pressed != 1);
            WebMolKit.setVisible(this.pressedMol1, this.pressed == 1);
            WebMolKit.setVisible(this.thinMol1, this.highlight != 1);
            WebMolKit.setVisible(this.thickMol1, this.highlight == 1);
            WebMolKit.setVisible(this.hoverArrow, this.highlight == 3);
            WebMolKit.setVisible(this.pressedArrow, this.pressed == 3);
            WebMolKit.setVisible(this.normalMol2, this.pressed != 2);
            WebMolKit.setVisible(this.pressedMol2, this.pressed == 2);
            WebMolKit.setVisible(this.thinMol2, this.highlight != 2);
            WebMolKit.setVisible(this.thickMol2, this.highlight == 2);
        }
        renderMolecule(which) {
            let mol = which == 1 ? this.mol1 : this.mol2, canvas = which == 1 ? this.drawnMol1 : this.drawnMol2;
            let withMapping = false;
            if (this.type == SearchPanel.TYPE_REACTION)
                for (let n = 1; n <= mol.numAtoms; n++)
                    if (mol.atomMapNum(n) > 0) {
                        withMapping = true;
                        break;
                    }
            let width = this.molWidth, height = this.height;
            let density = WebMolKit.pixelDensity();
            let ctx = canvas.getContext('2d');
            ctx.save();
            ctx.scale(density, density);
            ctx.clearRect(0, 0, width, height);
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            if (mol.numAtoms > 0) {
                let policy = withMapping ? WebMolKit.RenderPolicy.defaultBlackOnWhite() : WebMolKit.RenderPolicy.defaultColourOnWhite();
                let measure = new WebMolKit.OutlineMeasurement(0, 0, policy.data.pointScale);
                let layout = new WebMolKit.ArrangeMolecule(mol, measure, policy, new WebMolKit.RenderEffects());
                layout.arrange();
                let metavec = new WebMolKit.MetaVector();
                new WebMolKit.DrawMolecule(layout, metavec).draw();
                metavec.transformIntoBox(new WebMolKit.Box(2, 2, width - 4, height - 4));
                metavec.renderContext(ctx);
            }
            else if ((which == 1 && this.emptyMsg1) || (which == 2 && this.emptyMsg2)) {
                let lines = (which == 1 ? this.emptyMsg1 : this.emptyMsg2).split('\n');
                const fsz = 10, fh = fsz * WebMolKit.ASCENT_FUDGE;
                ctx.font = WebMolKit.fontSansSerif(fsz);
                ctx.fillStyle = 'black';
                let ty = 0.5 * (height - fh * (lines.length - 1));
                for (let txt of lines) {
                    let metrics = ctx.measureText(txt);
                    ctx.fillText(txt, 0.5 * (width - metrics.width), ty);
                    ty += fh;
                }
            }
            ctx.restore();
        }
        mouseEnter(which) {
            if (this.highlight != which) {
                this.highlight = which;
                this.updateLayers();
            }
        }
        mouseLeave(which) {
            if (this.highlight == which) {
                this.highlight = 0;
                this.pressed = 0;
                this.updateLayers();
            }
        }
        mouseDown(which) {
            if (this.pressed != which) {
                this.pressed = which;
                this.updateLayers();
            }
        }
        mouseUp(which) {
            if (this.pressed == which) {
                this.pressed = 0;
                this.updateLayers();
            }
        }
        editMolecule(which) {
            let dlg = new WebMolKit.EditCompound(which == 1 ? this.mol1 : this.mol2);
            this.isSketching = true;
            dlg.onSave(() => { if (which == 1)
                this.saveMolecule1(dlg);
            else
                this.saveMolecule2(dlg); });
            dlg.onClose(() => this.isSketching = false);
            dlg.open();
        }
        editMapping() {
            if (this.mol1.numAtoms == 0 || this.mol2.numAtoms == 0) {
                alert('Draw structures on both sides of the arrow before mapping.');
                return;
            }
            let dlg = new WebMolKit.MapReaction(this.mol1, this.mol2);
            dlg.callbackSave = (source) => this.saveMapping(source);
            dlg.open();
        }
        saveMolecule1(dlg) {
            this.mol1 = dlg.getMolecule();
            dlg.close();
            this.renderMolecule(1);
            let cookies = new WebMolKit.Cookies();
            if (cookies.numMolecules() > 0)
                cookies.stashMolecule(this.mol1);
            if (this.onChange)
                this.onChange(this);
        }
        saveMolecule2(dlg) {
            this.mol2 = dlg.getMolecule();
            dlg.close();
            this.renderMolecule(2);
            let cookies = new WebMolKit.Cookies();
            if (cookies.numMolecules() > 0)
                cookies.stashMolecule(this.mol2);
            if (this.onChange)
                this.onChange(this);
        }
        saveMapping(dlg) {
            this.mol1 = dlg.getMolecule1();
            this.mol2 = dlg.getMolecule2();
            dlg.close();
            this.renderMolecule(1);
            this.renderMolecule(2);
        }
        dropInto(which, transfer) {
            let items = transfer.items, files = transfer.files;
            const SUFFIXES = ['.el', '.mol'];
            const MIMES = ['text/plain', 'chemical/x-sketchel', 'x-mdl-molfile'];
            for (let n = 0; n < items.length; n++) {
                if (items[n].kind == 'string' && MIMES.indexOf(items[n].type) >= 0) {
                    items[n].getAsString((str) => {
                        let mol = WebMolKit.Molecule.fromString(str);
                        if (mol != null) {
                            if (which == 1)
                                this.setMolecule1(mol);
                            else
                                this.setMolecule2(mol);
                            if (this.onChange)
                                this.onChange(this);
                        }
                        else
                            console.log('Dragged data is not a SketchEl molecule: ' + str);
                    });
                    return;
                }
            }
            for (let n = 0; n < files.length; n++) {
                for (let sfx of SUFFIXES)
                    if (files[n].name.endsWith(sfx)) {
                        let reader = new FileReader();
                        reader.onload = (event) => {
                            let str = reader.result;
                            let mol = WebMolKit.MoleculeStream.readUnknown(str.toString());
                            if (mol != null) {
                                if (which == 1)
                                    this.setMolecule1(mol);
                                else
                                    this.setMolecule2(mol);
                                if (this.onChange)
                                    this.onChange(this);
                            }
                            else
                                console.log('Dragged file is not a recognised molecule: ' + str);
                        };
                        reader.readAsText(files[n]);
                        return;
                    }
            }
        }
    }
    SearchPanel.TYPE_MOLECULE = 'molecule';
    SearchPanel.TYPE_REACTION = 'reaction';
    WebMolKit.SearchPanel = SearchPanel;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class SearchReactions extends WebMolKit.Widget {
        constructor(tokenID) {
            super();
            this.tokenID = tokenID;
            this.rxnsearchToken = null;
            this.cancelled = false;
            this.started = false;
            this.finished = false;
            this.progress = 0;
            this.count = 0;
            this.results = [];
            this.callbackStop = null;
            this.callbackProgress = null;
            this.callbackRxn = null;
            this.callbackDS = null;
        }
        render(parent) {
            super.render(parent);
            let tableStyle = 'border-collapse: collapse;';
            this.table = $('<table></table>').appendTo(this.content);
            this.table.attr('style', tableStyle);
        }
        startSearch(origin, mol1, mol2, type, maxResults = 100) {
            this.cancelled = false;
            this.results = [];
            this.table.empty();
            this.placeholder = $('<tr><td>Starting search...</td></tr>').appendTo(this.table);
            let molstr1 = mol1 == null ? null : mol1.toString();
            let molstr2 = mol2 == null ? null : mol2.toString();
            let param = { 'origin': origin, 'molNative1': molstr1, 'molNative2': molstr2, 'type': type, 'maxResults': maxResults };
            WebMolKit.Search.startRxnSearch(param, (result, error) => {
                if (error != null)
                    throw 'molsync.ui.SearchReactions: failed to initiate search: ' + error.message;
                this.rxnsearchToken = result.rxnsearchToken;
                this.started = true;
                this.finished = false;
                WebMolKit.Search.pollRxnSearch({ 'rxnsearchToken': this.rxnsearchToken }, (result, error) => this.batchSearch(result, error));
            });
        }
        stopSearch() {
            if (this.placeholder) {
                this.placeholder.remove();
                this.placeholder = null;
            }
            this.cancelled = true;
            this.finished = true;
            if (this.callbackStop)
                this.callbackStop(this);
        }
        isRunning() {
            return this.started && !this.finished;
        }
        batchSearch(result, error) {
            if (error != null)
                throw 'molsync.ui.SearchReactions: failed to obtain next batch: ' + error.message;
            if (this.cancelled)
                return;
            this.finished = result.finished;
            this.progress = result.progress;
            this.count = result.count;
            if (result.modified) {
                if (this.placeholder) {
                    this.placeholder.remove();
                    this.placeholder = null;
                }
                this.updateResults(result.results);
            }
            if (!this.finished) {
                WebMolKit.Search.pollRxnSearch({ 'rxnsearchToken': this.rxnsearchToken }, (result, error) => this.batchSearch(result, error));
                if (this.callbackProgress)
                    this.callbackProgress(this.progress, this.count, this);
            }
            else {
                if (this.placeholder) {
                    this.placeholder.remove();
                    this.placeholder = null;
                }
                if (this.callbackStop)
                    this.callbackStop(this);
            }
        }
        updateResults(results) {
            for (let n = 0; n < results.length; n++) {
                let res = results[n];
                res.tr = $('<tr></tr>').appendTo(this.table);
                res.td = $('<td></td>').appendTo(res.tr);
                if (n > 0)
                    res.td.css('border-top', '1px solid #80C080');
                if (n < results.length - 1)
                    res.td.css('border-bottom', '1px solid #80C080');
                let table = $('<table></table>').appendTo(res.td), tr = $('<tr></tr>').appendTo(table);
                if (res.similarity) {
                    let td = $('<td></td>').appendTo(tr);
                    let txt = res.similarity == 1 ? '100%' : (res.similarity * 100).toFixed(1) + '%';
                    td.text(txt);
                }
                if (res.dataXML) {
                    let td = $('<td></td>').appendTo(tr);
                    let vs = this.grabSketch(td, res.dataXML, res.datasheetID, res.row, res.batchID);
                    res.viewRxn = vs;
                }
                let td = $('<td></td>').appendTo(tr);
                let link = $('<a href="#' + res.datasheetID + '"></a>').appendTo(td);
                link.mouseenter((e) => e.target.style.backgroundColor = '#D0D0D0');
                link.mouseleave((e) => e.target.style.backgroundColor = 'transparent');
                let title = res.subTitle ? res.subTitle : res.title ? res.title : 'DataSheet#' + res.datasheetID;
                link.text(title);
                let body = '';
                if (res.title && res.title != title)
                    body += '<div>Title: <i>' + WebMolKit.escapeHTML(res.title) + '</i></div>';
                if (res.descr)
                    body += '<div>Description: <i>' + WebMolKit.escapeHTML(res.descr) + '</i></div>';
                WebMolKit.addTooltip(link, body, WebMolKit.escapeHTML(title));
                link.click(() => { if (this.callbackDS)
                    this.callbackDS(res.datasheetID, this); });
                td.append(' ');
            }
            for (let res of this.results)
                res.tr.remove();
            this.results = results;
        }
        grabSketch(parent, dataXML, datasheetID, row, batchID) {
            for (let res of this.results)
                if (res.batchID == batchID) {
                    res.viewRxn.content.appendTo(parent);
                    return res.viewRxn;
                }
            const vs = new WebMolKit.ViewStructure(this.tokenID);
            vs.content = parent;
            vs.defineDataSheetString(dataXML, 0);
            vs.borderCol = -1;
            vs.backgroundCol1 = 0xF8F8F8;
            vs.backgroundCol2 = 0xE0E0E0;
            vs.padding = 4;
            vs.setup(() => {
                vs.render(parent);
                vs.content.css('cursor', 'pointer');
                vs.content.click(() => {
                    if (this.callbackRxn)
                        this.callbackRxn(dataXML, datasheetID, row, this);
                });
            });
            return vs;
        }
    }
    SearchReactions.TYPE_COMPONENT = 'component';
    SearchReactions.TYPE_TRANSFORM = 'transform';
    SearchReactions.TYPE_SIMILARITY = 'similarity';
    SearchReactions.TYPE_RANDOM = 'random';
    WebMolKit.SearchReactions = SearchReactions;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    const CSS_WEBMENU = `
    *.wmk-webmenubar
    {
        font-family: 'Open Sans', sans-serif;
        background-color: black;
        color: white;
        width: 100%;
    }
    *.wmk-webmenudrop
    {
        font-family: 'Open Sans', sans-serif;
        background-color: rgba(0,0,0,0.7);
        color: white;
    }
    *.wmk-webmenuitem
    {
        font-family: 'Open Sans', sans-serif;
        color: white;
        padding: 0 0.5em 0 0.5em;
    }
    *.wmk-webmenuitem:hover
    {
        background-color: #0000FF;
        cursor: pointer;
    }
`;
    class WebMenu extends WebMolKit.Widget {
        constructor(barItems) {
            super();
            this.barItems = barItems;
            this.topItems = [];
            if (!WebMolKit.hasInlineCSS('webmenu'))
                WebMolKit.installInlineCSS('webmenu', CSS_WEBMENU);
        }
        render(parent) {
            super.render(parent);
            this.content.addClass('wmk-webmenubar');
            for (let item of this.barItems) {
                let dom = $('<span></span>').appendTo(this.content);
                dom.addClass('wmk-webmenuitem');
                dom.text(item.label ? item.label : '?');
                dom.click((event) => { this.activateMenu(dom, item); event.preventDefault(); });
                dom.dblclick((event) => event.preventDefault());
            }
        }
        activateMenu(parent, item) {
            if (item.click) {
                item.click();
                return;
            }
            if (WebMolKit.Vec.arrayLength(item.submenu) == 0) {
                return;
            }
            let wx1 = parent.offset().left, wy1 = parent.offset().top;
            let wx2 = wx1 + parent.width(), wy2 = wy1 + parent.height();
            let menuX = 0, menuY = 0;
            if (this.obscureBackground) {
                menuX = wx2;
                menuY = wy1;
            }
            else {
                menuX = wx1;
                menuY = wy2;
                let bg = this.obscureBackground = $('<span></span>').appendTo($(document.documentElement));
                bg.css('width', '100%');
                bg.css('height', document.documentElement.clientHeight + 'px');
                bg.css('position', 'absolute');
                bg.css('left', 0);
                bg.css('top', 0);
                bg.css('z-index', 9999);
                bg.click(() => this.deactivateMenu());
                bg.show();
                this.obscureBackground = bg;
            }
            let container = $('<div></div>');
            container.addClass('wmk-webmenudrop');
            container.css('position', 'absolute');
            container.css('left', `${menuX}px`);
            container.css('top', `${menuY}px`);
            for (let subitem of item.submenu) {
                let dom = $('<div></div>').appendTo(container);
                dom.addClass('wmk-webmenuitem');
                dom.text(subitem.label ? subitem.label : '?');
                dom.click((event) => { this.activateMenu(dom, subitem); event.preventDefault(); });
                dom.dblclick((event) => event.preventDefault());
            }
            this.obscureBackground.append(container);
        }
        deactivateMenu() {
            this.obscureBackground.remove();
            this.obscureBackground = null;
        }
    }
    WebMolKit.WebMenu = WebMenu;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class XML {
        static nodeText(el) {
            let text = '';
            for (let child of Array.from(el.childNodes)) {
                if (child.nodeType == Node.TEXT_NODE || child.nodeType == Node.CDATA_SECTION_NODE)
                    text += child.nodeValue;
            }
            return text;
        }
        static childText(parent, tagName) {
            if (parent == null)
                return null;
            let el = this.findElement(parent, tagName);
            if (el == null)
                return null;
            return WebMolKit.nodeText(el);
        }
        static appendElement(parent, name) {
            let el = parent.ownerDocument.createElement(name);
            parent.appendChild(el);
            return el;
        }
        static appendElementAfter(presib, name) {
            let el = presib.ownerDocument.createElement(name);
            let postsib = presib.nextSibling;
            if (postsib == null)
                presib.parentNode.appendChild(el);
            else
                presib.parentNode.insertBefore(el, postsib);
            return el;
        }
        static appendText(parent, text, isCDATA) {
            if (text == null || text.length == 0)
                return;
            if (!isCDATA)
                parent.appendChild(parent.ownerDocument.createTextNode(text));
            else
                parent.appendChild(parent.ownerDocument.createCDATASection(text));
        }
        static createTextChild(parent, name, text, isCDATA = false) {
            let el = parent.ownerDocument.createElement(name);
            parent.appendChild(el);
            if (!isCDATA)
                el.textContent = text;
            else
                el.appendChild(parent.ownerDocument.createCDATASection(text));
        }
        static setText(parent, text, isCDATA = false) {
            while (parent.firstChild != null)
                parent.removeChild(parent.firstChild);
            this.appendText(parent, text, isCDATA);
        }
        static findElement(parent, tagName) {
            if (parent == null)
                return null;
            let node = parent.firstChild;
            while (node != null) {
                if (node.nodeType == Node.ELEMENT_NODE && node.nodeName == tagName)
                    return node;
                node = node.nextSibling;
            }
            return null;
        }
        static findChildElements(parent, tagName) {
            if (parent == null)
                return [];
            let list = [];
            let node = parent.firstChild;
            while (node != null) {
                if (node.nodeType == Node.ELEMENT_NODE && node.nodeName === tagName)
                    list.push(node);
                node = node.nextSibling;
            }
            return list;
        }
        static childElements(parent) {
            if (parent == null)
                return [];
            let list = [];
            let node = parent.firstChild;
            while (node != null) {
                if (node.nodeType == Node.ELEMENT_NODE)
                    list.push(node);
                node = node.nextSibling;
            }
            return list;
        }
    }
    WebMolKit.XML = XML;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class Validation {
        constructor() {
            this.tests = [];
            this.setupError = null;
            this.rec = {};
        }
        init(donefunc) {
            donefunc.call(this);
        }
        add(title, func) {
            this.tests.push({ 'title': title, 'func': func });
        }
        get count() { return this.tests.length; }
        getTitle(idx) { return this.tests[idx].title; }
        runTest(idx) {
            this.recentSuccess = true;
            this.recentError = null;
            let timeStarted = new Date().getTime();
            try {
                this.tests[idx].func.call(this);
            }
            catch (e) {
                this.recentSuccess = false;
                if (this.recentError == null) {
                    let error = e;
                    this.recentError = 'Exception: ' + e.message;
                    if (e.fileName)
                        this.recentError += ', file: ' + e.fileName;
                    if (e.lineNumber)
                        this.recentError += ', line: ' + e.lineNumber;
                    console.log('Unhandled exception in validation:\n' + e.stack);
                }
            }
            let timeFinished = new Date().getTime();
            this.recentTimeTaken = (timeFinished - timeStarted) / 1000;
            return [this.recentSuccess, this.recentError, this.recentTimeTaken];
        }
        assert(condition, message) {
            if (condition)
                return;
            this.recentError = message;
            throw '!';
        }
        assertEqual(thing1, thing2, message) {
            if (thing1 == thing2)
                return;
            this.recentError = message;
            throw '!';
        }
        assertNull(thing, message) {
            if (thing == null)
                return;
            this.recentError = message;
            throw '!';
        }
        assertNotNull(thing, message) {
            if (thing != null)
                return;
            this.recentError = message;
            throw '!';
        }
        fail(message) {
            this.recentError = message;
            throw '!';
        }
    }
    WebMolKit.Validation = Validation;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class ValidationHeadlessBasic extends WebMolKit.Validation {
        constructor() {
            super();
            this.add('Vector index sort', this.vectorIndexSort);
            this.add('Axis labeller', this.axisLabeller);
        }
        vectorIndexSort() {
            let array = ['b', 'c', 'a'];
            let idx = WebMolKit.Vec.idxSort(array);
            this.assert(WebMolKit.Vec.equals(idx, [2, 0, 1]));
        }
        axisLabeller() {
            let textWidth = (str) => str.length * 4;
            let tfUnity = (val) => val, tfNegLog = (val) => -Math.log10(val), tfBackLog = (val) => Math.pow(10, -val);
            const TESTCASES = [
                [1, 100, false, ['10', '100']],
                [0, 1, false, ['0', '1']],
                [0.01, 0.02, false, ['0.01', '0.02']],
                [0.008, 0.022, false, ['0.008', '0.022']],
                [0.00798, 0.0221, false, ['0.008', '0.022']],
                [1E-5, 1E4, true, ['1e+4', '0.00001']],
                [0.03162277660168379, 100, true, ['100', '0.03162']]
            ];
            for (let test of TESTCASES) {
                let low = test[0], high = test[1];
                let asLog = test[2];
                if (asLog)
                    [low, high] = [tfNegLog(high), tfNegLog(low)];
                let axis = new WebMolKit.AxisLabeller(100, low, high, textWidth, asLog ? tfBackLog : tfUnity);
                axis.calculate();
                let wanted = test[3];
                let got = [];
                for (let notch of axis.notches)
                    got.push(notch.label);
                if (wanted.length == 0 || !WebMolKit.Vec.equals(wanted, got)) {
                    console.log('Test:' + JSON.stringify(test));
                    console.log('Notches:' + JSON.stringify(axis.notches));
                    console.log('Wanted:' + JSON.stringify(wanted));
                    console.log('Got:' + JSON.stringify(got));
                    this.fail('Did not get the expected axis labels.');
                }
            }
        }
    }
    WebMolKit.ValidationHeadlessBasic = ValidationHeadlessBasic;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class ValidationHeadlessMolecule extends WebMolKit.Validation {
        constructor(urlBase) {
            super();
            this.urlBase = urlBase;
            this.add('Parse SketchEl molecule (native format)', this.parseSketchEl);
            this.add('Parse MDL Molfile', this.parseMolfile);
            this.add('Parse DataSheet XML', this.parseDataXML);
            this.add('Parse MDL SDfile', this.parseSDfile);
            this.add('Calculate strict aromaticity', this.calcStrictArom);
            this.add('Calculate stereochemistry', this.calcStereoChem);
            this.add('Circular ECFP6 fingerprints', this.calcFingerprints);
            this.add('Molfile Round-trip', this.molfileRoundTrip);
        }
        init(donefunc) {
            let FILES = ['molecule.el', 'molecule.mol', 'datasheet.ds', 'datasheet.sdf', 'stereo.el', 'circular.ds', 'roundtrip.ds'];
            let files = FILES;
            let fetchResult = (data) => {
                let fn = files.shift();
                if (fn == 'molecule.el')
                    this.strSketchEl = data;
                else if (fn == 'molecule.mol')
                    this.strMolfile = data;
                else if (fn == 'datasheet.ds')
                    this.strDataXML = data;
                else if (fn == 'datasheet.sdf')
                    this.strSDfile = data;
                else if (fn == 'stereo.el')
                    this.molStereo = WebMolKit.Molecule.fromString(data);
                else if (fn == 'circular.ds')
                    this.dsCircular = WebMolKit.DataSheetStream.readXML(data);
                else if (fn == 'roundtrip.ds')
                    this.dsRoundtrip = WebMolKit.DataSheetStream.readXML(data);
                if (files.length > 0)
                    $.get(this.urlBase + files[0], fetchResult);
                else
                    donefunc.call(this);
            };
            $.get(this.urlBase + files[0], fetchResult);
        }
        ;
        parseSketchEl() {
            this.assert(!!this.strSketchEl, 'molecule not loaded');
            let mol = WebMolKit.MoleculeStream.readNative(this.strSketchEl);
            this.assert(mol != null, 'parsing failed');
            this.assert(mol.numAtoms == 10 && mol.numBonds == 10, 'wrong atom/bond count');
        }
        parseMolfile() {
            this.assert(!!this.strMolfile, 'molecule not loaded');
            let mol = WebMolKit.MoleculeStream.readMDLMOL(this.strMolfile);
            this.assert(mol != null, 'parsing failed');
            this.assert(mol.numAtoms == 10 && mol.numBonds == 10, 'wrong atom/bond count');
        }
        parseDataXML() {
            this.assert(!!this.strDataXML, 'datasheet not loaded');
            let ds = WebMolKit.DataSheetStream.readXML(this.strDataXML);
            this.assert(ds != null, 'parsing failed');
            this.assert(ds.numRows == 2 && ds.numCols == 5, 'wrong row/column count');
            let colTypes = [WebMolKit.DataSheet.COLTYPE_MOLECULE, WebMolKit.DataSheet.COLTYPE_STRING, WebMolKit.DataSheet.COLTYPE_INTEGER, WebMolKit.DataSheet.COLTYPE_REAL, WebMolKit.DataSheet.COLTYPE_BOOLEAN];
            for (let n = 0; n < colTypes.length; n++)
                this.assert(ds.colType(n) == colTypes[n], 'column#' + (n + 1) + ' wrong type');
            this.assert(ds.getMolecule(0, 0).numAtoms == 1, 'row 1: invalid molecule');
            this.assert(ds.getString(0, 1) == 'string', 'row 1: invalid string');
            this.assert(ds.getInteger(0, 2) == 1, 'row 1: invalid integer');
            this.assert(ds.getReal(0, 3) == 1.5, 'row 1: invalid real');
            this.assert(ds.getBoolean(0, 4) == true, 'row 1: invalid boolean');
            this.assert(ds.getMolecule(1, 0).numAtoms == 1, 'row 2: invalid molecule');
            for (let n = 1; n < ds.numCols; n++)
                this.assert(ds.isNull(1, n), 'row 2, column#' + (n + 1) + ' supposed to be null');
        }
        parseSDfile() {
            this.assert(!!this.strSDfile, 'datasheet not loaded');
            let rdr = new WebMolKit.MDLSDFReader(this.strSDfile);
            rdr.parse();
            let ds = rdr.ds;
            this.assert(ds != null, 'parsing failed');
            this.assert(ds.numRows == 2 && ds.numCols == 5, 'wrong row/column count');
            let colTypes = [WebMolKit.DataSheet.COLTYPE_MOLECULE, WebMolKit.DataSheet.COLTYPE_STRING, WebMolKit.DataSheet.COLTYPE_INTEGER, WebMolKit.DataSheet.COLTYPE_REAL, WebMolKit.DataSheet.COLTYPE_BOOLEAN];
            for (let n = 0; n < colTypes.length; n++)
                this.assert(ds.colType(n) == colTypes[n], 'column#' + (n + 1) + ' wrong type');
            this.assert(ds.getMolecule(0, 0).numAtoms == 1, 'row 1: invalid molecule');
            this.assert(ds.getString(0, 1) == 'string', 'row 1: invalid string');
            this.assert(ds.getInteger(0, 2) == 1, 'row 1: invalid integer');
            this.assert(ds.getReal(0, 3) == 1.5, 'row 1: invalid real');
            this.assert(ds.getBoolean(0, 4) == true, 'row 1: invalid boolean');
            this.assert(ds.getMolecule(1, 0).numAtoms == 1, 'row 2: invalid molecule');
            for (let n = 1; n < ds.numCols; n++)
                this.assert(ds.isNull(1, n), 'row 2, column#' + (n + 1) + ' supposed to be null');
        }
        calcStrictArom() {
            this.assert(this.molStereo != null, 'molecule not loaded');
            let meta = WebMolKit.MetaMolecule.createStrict(this.molStereo);
            this.assert(meta.atomArom != null, 'no aromaticity obtained');
            for (let n = 1; n <= 10; n++)
                this.assert(meta.isAtomAromatic(n), 'atom #' + n + ' supposed to be aromatic');
            for (let n = 1; n <= 10; n++)
                this.assert(meta.isBondAromatic(n), 'bond #' + n + ' supposed to be aromatic');
        }
        calcStereoChem() {
            this.assert(this.molStereo != null, 'molecule not loaded');
            let meta = WebMolKit.MetaMolecule.createStrictRubric(this.molStereo);
            this.assert(meta.rubricTetra != null, 'no tetrahedral rubric obtained');
            this.assert(meta.rubricSides != null, 'no cis/trans rubric obtained');
            let stereo = WebMolKit.Stereochemistry.create(meta);
            let tet11 = stereo.atomTetraChirality(11);
            this.assert(tet11 == WebMolKit.Stereochemistry.STEREO_NEG, 'atom 11: incorrect stereochemistry, got ' + tet11);
            let tet19 = stereo.atomTetraChirality(19);
            this.assert(tet19 == WebMolKit.Stereochemistry.STEREO_POS, 'atom 19: incorrect stereochemistry, got ' + tet19);
            let tet20 = stereo.atomTetraChirality(20);
            this.assert(tet20 == WebMolKit.Stereochemistry.STEREO_POS, 'atom 20: incorrect stereochemistry, got ' + tet20);
            let side26 = stereo.bondSideStereo(26);
            this.assert(side26 == WebMolKit.Stereochemistry.STEREO_NEG, 'bond 26: incorrect stereochemistry, got ' + side26);
        }
        calcFingerprints() {
            this.assert(this.dsCircular != null, 'datasheet not loaded');
            const ds = this.dsCircular;
            for (let n = 0; n < ds.numRows; n++) {
                let mol = ds.getMolecule(n, 'Molecule');
                let ecfp0 = [], ecfp2 = [], ecfp4 = [], ecfp6 = [];
                for (let fp of ds.getString(n, 'ECFP0').split(','))
                    if (fp.length > 0)
                        ecfp0.push(parseInt(fp));
                for (let fp of ds.getString(n, 'ECFP2').split(','))
                    if (fp.length > 0)
                        ecfp2.push(parseInt(fp));
                for (let fp of ds.getString(n, 'ECFP4').split(','))
                    if (fp.length > 0)
                        ecfp4.push(parseInt(fp));
                for (let fp of ds.getString(n, 'ECFP6').split(','))
                    if (fp.length > 0)
                        ecfp6.push(parseInt(fp));
                WebMolKit.Vec.sort(ecfp0);
                WebMolKit.Vec.sort(ecfp2);
                WebMolKit.Vec.sort(ecfp4);
                WebMolKit.Vec.sort(ecfp6);
                let circ = WebMolKit.CircularFingerprints.create(mol, WebMolKit.CircularFingerprints.CLASS_ECFP6);
                let got = [[], [], [], []];
                for (let fp of circ.getFingerprints())
                    if (got[fp.iteration].indexOf(fp.hashCode) < 0)
                        got[fp.iteration].push(fp.hashCode);
                for (let ecfp of got)
                    WebMolKit.Vec.sort(ecfp);
                this.assert(WebMolKit.Vec.equals(ecfp0, got[0]), 'row#' + (n + 1) + ', iter#0: wanted ' + ecfp0 + ', got ' + got[0]);
                this.assert(WebMolKit.Vec.equals(ecfp2, got[1]), 'row#' + (n + 1) + ', iter#1: wanted ' + ecfp2 + ', got ' + got[1]);
                this.assert(WebMolKit.Vec.equals(ecfp4, got[2]), 'row#' + (n + 1) + ', iter#2: wanted ' + ecfp4 + ', got ' + got[2]);
                this.assert(WebMolKit.Vec.equals(ecfp6, got[3]), 'row#' + (n + 1) + ', iter#3: wanted ' + ecfp6 + ', got ' + got[3]);
            }
        }
        molfileRoundTrip() {
            const ds = this.dsRoundtrip;
            for (let n = 0; n < ds.numRows; n++) {
                let strRow = 'row#' + (n + 1);
                let mol = ds.getMolecule(n, 'Molecule');
                let mdl = new WebMolKit.MDLMOLWriter(mol).write();
                let alt = new WebMolKit.MDLMOLReader(mdl).parse();
                this.assert(mol.numAtoms == alt.numAtoms && mol.numBonds == alt.numBonds, strRow + ', atom/bond count differs');
                let problems = [];
                for (let i = 1; i <= mol.numAtoms; i++) {
                    if (mol.atomElement(i) != alt.atomElement(i))
                        problems.push(strRow + '/atom #' + i + ': elements different');
                    if (mol.atomCharge(i) != alt.atomCharge(i))
                        problems.push(strRow + '/atom #' + i + ': charges different');
                    if (mol.atomUnpaired(i) != alt.atomUnpaired(i))
                        problems.push(strRow + '/atom #' + i + ': unpaired different');
                    if (mol.atomIsotope(i) != alt.atomIsotope(i))
                        problems.push(strRow + '/atom #' + i + ': isotope different');
                    if (mol.atomMapNum(i) != alt.atomMapNum(i))
                        problems.push(strRow + '/atom #' + i + ': mapnum different');
                    if (mol.atomHydrogens(i) != alt.atomHydrogens(i))
                        problems.push(strRow + '/atom #' + i + ': hydrogens different');
                    if (mol.atomHExplicit(i) != alt.atomHExplicit(i))
                        problems.push(strRow + '/atom #' + i + ': explicitH different');
                }
                for (let i = 1; i <= mol.numBonds; i++) {
                    if (mol.bondOrder(i) != alt.bondOrder(i))
                        problems.push(strRow + '/bond #' + i + ': bond orders different');
                    if (mol.bondType(i) != alt.bondType(i))
                        problems.push(strRow + '/bond #' + i + ': bond types different');
                }
                if (problems.length > 0) {
                    console.log('Round trip problems:');
                    for (let p of problems)
                        console.log(p);
                    console.log('Original molecule:\n' + mol);
                    console.log('MDL Molfile CTAB:\n' + mdl);
                    console.log('Parsed back molecule:\n' + alt);
                }
                this.assert(problems.length == 0, problems.join('; '));
                let wantMDL = ds.getString(n, 'Molfile');
                if (mdl.trim() != WebMolKit.orBlank(wantMDL).trim()) {
                    if (wantMDL)
                        console.log('Molfile missing from validation data.');
                    else
                        console.log('Desired Molfile:\n' + wantMDL);
                    console.log('Got Molfile:\n' + mdl);
                    this.assert(false, strRow + ': initial Molfile invalid');
                }
            }
        }
    }
    WebMolKit.ValidationHeadlessMolecule = ValidationHeadlessMolecule;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class ValidationHeadlessReaction extends WebMolKit.Validation {
        constructor(urlBase) {
            super();
            this.urlBase = urlBase;
            this.add('Experiment aspect', this.confirmAspect);
        }
        init(donefunc) {
            const self = this;
            let FILES = ['experiment.ds'];
            let files = FILES;
            let fetchResult = function (data) {
                let fn = files.shift();
                if (fn == 'experiment.ds')
                    self.strExperiment = data;
                if (files.length > 0)
                    $.get(self.urlBase + files[0], fetchResult);
                else
                    donefunc.call(self);
            };
            $.get(self.urlBase + files[0], fetchResult);
        }
        confirmAspect() {
            this.assert(!!this.strExperiment, 'datasheet not loaded');
            let ds = WebMolKit.DataSheetStream.readXML(this.strExperiment);
            this.assert(ds != null, 'parsing failed');
            this.assert(WebMolKit.Experiment.isExperiment(ds), 'aspect claimed not an Experiment');
            let xs = new WebMolKit.Experiment(ds);
            let entry = xs.getEntry(0);
            this.assert(entry != null, 'null entry returned');
            this.assert(entry.steps.length == 2, 'reaction supposed to be 2 steps, got ' + entry.steps.length);
            this.assert(entry.steps[0].reactants.length == 1, 'require step 1: #reactants = 1');
            this.assert(entry.steps[0].reagents.length == 3, 'require step 1: #reagents = 3');
            this.assert(entry.steps[0].products.length == 2, 'require step 1: #products = 2');
            this.assert(entry.steps[1].reactants.length == 0, 'require step 2: #reactants = 0');
            this.assert(entry.steps[1].reagents.length == 1, 'require step 2: #reagents = 1');
            this.assert(entry.steps[1].products.length == 2, 'require step 2: #products = 2');
        }
    }
    WebMolKit.ValidationHeadlessReaction = ValidationHeadlessReaction;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class WebValExec {
        constructor(validation) {
            this.validation = validation;
        }
        runTests(domParent) {
            domParent.empty();
            if (this.validation.setupError) {
                let div = $('<div></div>').appendTo(domParent);
                div.css('color', 'red');
                div.text('Setup failed: ' + this.validation.setupError);
                return;
            }
            let table = $('<table></table>').appendTo(domParent);
            let tdStatus = [], tdInfo = [];
            for (let n = 0; n < this.validation.count; n++) {
                let tr = $('<tr></tr>').appendTo(table);
                let td = $('<td valign="top"></td>').appendTo(tr);
                tdStatus.push(td);
                td = $('<td valign="top"></td>').appendTo(tr);
                td.text(this.validation.getTitle(n));
                tdInfo.push(td);
            }
            for (let n = 0; n < this.validation.count; n++) {
                tdStatus[n].html('&#9744;');
                let [success, message, time] = this.validation.runTest(n);
                if (success) {
                    tdStatus[n].html('&#9745;');
                    if (time >= 0.001) {
                        let span = $('<span style="color: #909090;"></span>').appendTo(tdInfo[n]);
                        span.text(' (' + time.toFixed(3) + ' sec)');
                    }
                }
                else {
                    tdStatus[n].html('<span style="color: red;">&#9746;</span>');
                    let para = $('<p style="color: purple; margin-top: 0;"></p>').appendTo(tdInfo[n]);
                    para.text(message ? message : 'failed');
                    tdStatus[n].css('background-color', '#FFF0F0');
                    tdInfo[n].css('background-color', '#FFF0F0');
                }
            }
        }
    }
    WebMolKit.WebValExec = WebValExec;
})(WebMolKit || (WebMolKit = {}));
//# sourceMappingURL=webmolkit-build.js.map