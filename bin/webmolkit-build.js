var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var WebMolKit;
(function (WebMolKit) {
    class Aspect {
        constructor(code, ds, allowModify) {
            this.code = code;
            this.allowModify = true;
            this.ds = ds ? ds : new WebMolKit.DataSheet();
            if (allowModify != null)
                this.allowModify = allowModify;
        }
        isColumnReserved(colName) { return false; }
        areColumnsReserved(colNames) {
            let resMask = WebMolKit.Vec.booleanArray(false, colNames.length);
            for (let n = 0; n < colNames.length; n++)
                resMask[n] = this.isColumnReserved(colNames[n]);
            return resMask;
        }
        rowFirstBlock(row) { return true; }
        rowBlockCount(row) { return 1; }
        aspectUnion(other) { }
        initiateNewRow(row) { }
        columnEffectivelyBlank(row) { return []; }
        numTextRenderings(row) { return 0; }
        produceTextRendering(row, idx) { return null; }
        numGraphicRenderings(row) { return 0; }
        produceGraphicRendering(row, idx, policy) { return null; }
        numHeaderRenderings() { return 0; }
        produceHeaderRendering(idx) { return null; }
    }
    Aspect.TEXT_PLAIN = 0;
    Aspect.TEXT_LINK = 1;
    Aspect.TEXT_HTML = 2;
    WebMolKit.Aspect = Aspect;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let supportedAspects = {};
    function registerAspect(classdef) {
        let code = classdef.CODE, name = classdef.NAME;
        supportedAspects[code] = { code, name, classdef };
    }
    WebMolKit.registerAspect = registerAspect;
    class AspectList {
        constructor(ds) {
            this.ds = ds;
        }
        list() {
            let present = [], absent = [];
            let codes = new Set();
            for (let n = 0; n < this.ds.numExtensions; n++)
                codes.add(this.ds.getExtType(n));
            for (let code in supportedAspects)
                if (codes.has(code))
                    present.push(code);
                else
                    absent.push(code);
            return [present, absent];
        }
        instantiate(code) {
            let supp = supportedAspects[code];
            if (supp)
                return new supp.classdef(this.ds);
            return null;
        }
        enumerate() {
            let aspects = [];
            for (let n = 0; n < this.ds.numExtensions; n++) {
                let code = this.ds.getExtType(n);
                if (supportedAspects[code])
                    aspects.push(this.instantiate(code));
            }
            return aspects;
        }
        aspectName(code) {
            let supp = supportedAspects[code];
            return supp ? supp.name : null;
        }
    }
    WebMolKit.AspectList = AspectList;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class AssayProvenanceHeader {
        constructor() {
            this.prefixes = {};
            this.targetName = '';
            this.targetURI = '';
            this.organismName = '';
            this.organismURI = '';
            this.targetTypeName = '';
            this.targetTypeURI = '';
            this.cellName = '';
            this.cellURI = '';
            this.assayTypeName = '';
            this.assayTypeURI = '';
            this.assayDescription = '';
            this.sourceName = '';
            this.sourceURI = '';
            this.sourceVersion = '';
            this.documentName = '';
            this.documentURI = '';
            this.measureTypeName = '';
            this.measureTypeURI = '';
            this.unitNames = [];
            this.unitURIs = [];
        }
    }
    WebMolKit.AssayProvenanceHeader = AssayProvenanceHeader;
    class AssayProvenance extends WebMolKit.Aspect {
        constructor(ds, allowModify) {
            super(AssayProvenance.CODE, ds, allowModify);
            this.setup();
        }
        static isAssayProvenance(ds) {
            for (let n = 0; n < ds.numExtensions; n++)
                if (ds.getExtType(n) == AssayProvenance.CODE)
                    return true;
            return false;
        }
        getHeader() {
            for (let n = 0; n < this.ds.numExtensions; n++)
                if (this.ds.getExtType(n) == AssayProvenance.CODE)
                    return this.parseMetaData(this.ds.getExtData(n));
            return null;
        }
        setHeader(header) {
            let content = this.formatMetaData(header);
            for (let n = 0; n < this.ds.numExtensions; n++)
                if (this.ds.getExtType(n) == AssayProvenance.CODE) {
                    this.ds.setExtData(n, content);
                    return;
                }
            this.ds.appendExtension(AssayProvenance.NAME, AssayProvenance.CODE, content);
        }
        getMolecule(row) {
            let col = this.ds.findColByName(AssayProvenance.COLNAME_MOLECULE);
            return col < 0 ? null : this.ds.getMolecule(row, col);
        }
        getName(row) {
            let col = this.ds.findColByName(AssayProvenance.COLNAME_NAME);
            return col < 0 ? null : this.ds.getString(row, col);
        }
        getValue(row) {
            let col = this.ds.findColByName(AssayProvenance.COLNAME_VALUE);
            return col < 0 ? null : this.ds.isNull(row, col) ? Number.NaN : this.ds.getReal(row, col);
        }
        getError(row) {
            let col = this.ds.findColByName(AssayProvenance.COLNAME_ERROR);
            if (col < 0)
                return null;
            if (this.ds.isNull(row, col))
                return Number.NaN;
            let err = this.ds.getReal(row, col);
            if (err <= 0)
                return Number.NaN;
            return err;
        }
        getUnits(row) {
            let col = this.ds.findColByName(AssayProvenance.COLNAME_UNITS);
            return col < 0 ? null : this.ds.getString(row, col);
        }
        getRelation(row) {
            let col = this.ds.findColByName(AssayProvenance.COLNAME_RELATION);
            return col < 0 ? null : this.ds.getString(row, col);
        }
        getSourceURI(row) {
            let col = this.ds.findColByName(AssayProvenance.COLNAME_SOURCEURI);
            return col < 0 ? null : this.ds.getString(row, col);
        }
        setMolecule(row, v) {
            let col = this.ds.findColByName(AssayProvenance.COLNAME_MOLECULE);
            if (col >= 0)
                this.ds.setMolecule(row, col, v);
        }
        setName(row, v) {
            let col = this.ds.findColByName(AssayProvenance.COLNAME_NAME);
            if (col >= 0)
                this.ds.setString(row, col, v);
        }
        setValue(row, v) {
            let col = this.ds.findColByName(AssayProvenance.COLNAME_VALUE);
            if (col < 0) { }
            else if (Number.isNaN(v))
                this.ds.setToNull(row, col);
            else
                this.ds.setReal(row, col, v);
        }
        setError(row, v) {
            let col = this.ds.findColByName(AssayProvenance.COLNAME_ERROR);
            if (col < 0) { }
            else if (Number.isNaN(v))
                this.ds.setToNull(row, col);
            else
                this.ds.setReal(row, col, v);
        }
        setUnits(row, v) {
            let col = this.ds.findColByName(AssayProvenance.COLNAME_UNITS);
            if (col >= 0)
                this.ds.setString(row, col, v);
        }
        setRelation(row, v) {
            let col = this.ds.findColByName(AssayProvenance.COLNAME_RELATION);
            if (col >= 0)
                this.ds.setString(row, col, v);
        }
        setSourceURI(row, v) {
            let col = this.ds.findColByName(AssayProvenance.COLNAME_SOURCEURI);
            if (col >= 0)
                this.ds.setString(row, col, v);
        }
        setup() {
            this.parseAndCorrect();
        }
        parseAndCorrect() {
            let header = new AssayProvenanceHeader();
            let got = false;
            for (let n = 0; n < this.ds.numExtensions; n++)
                if (this.ds.getExtType(n) == AssayProvenance.CODE) {
                    header = this.parseMetaData(this.ds.getExtData(n));
                    got = true;
                    break;
                }
            if (this.allowModify) {
                this.ds.ensureColumn(AssayProvenance.COLNAME_MOLECULE, "molecule", 'Molecular structure of compound being measured');
                this.ds.ensureColumn(AssayProvenance.COLNAME_NAME, "string", 'Name of compound');
                this.ds.ensureColumn(AssayProvenance.COLNAME_VALUE, "real", 'Measured value');
                this.ds.ensureColumn(AssayProvenance.COLNAME_ERROR, "real", 'Experimental error of measurement');
                this.ds.ensureColumn(AssayProvenance.COLNAME_UNITS, "string", 'Units of measurement');
                this.ds.ensureColumn(AssayProvenance.COLNAME_RELATION, "string", 'Relation: exact, greater or less');
                this.ds.ensureColumn(AssayProvenance.COLNAME_SOURCEURI, "string", 'Source identifier for activity measurement');
            }
            if (!got && this.allowModify) {
                let content = this.formatMetaData(header);
                this.ds.appendExtension(AssayProvenance.NAME, AssayProvenance.CODE, content);
            }
        }
        parseMetaData(content) {
            let header = new AssayProvenanceHeader();
            for (let line of content.split(/\r?\n/)) {
                let eq = line.indexOf('=');
                if (eq < 0)
                    continue;
                if (line.startsWith('pfx:'))
                    header.prefixes[WebMolKit.MoleculeStream.skUnescape(line.substring(4, eq))] = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('targetName='))
                    header.targetName = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('targetURI='))
                    header.targetURI = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('organismName='))
                    header.organismName = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('organismURI='))
                    header.organismURI = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('targetTypeName='))
                    header.targetTypeName = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('targetTypeURI='))
                    header.targetTypeURI = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('cellName='))
                    header.cellName = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('cellURI='))
                    header.cellURI = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('assayTypeName='))
                    header.assayTypeName = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('assayTypeURI='))
                    header.assayTypeURI = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('assayDescription='))
                    header.assayDescription = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('sourceName='))
                    header.sourceName = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('sourceURI='))
                    header.sourceURI = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('sourceVersion='))
                    header.sourceVersion = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('documentName='))
                    header.documentName = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('documentURI='))
                    header.documentURI = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('measureTypeName='))
                    header.measureTypeName = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('measureTypeURI='))
                    header.measureTypeURI = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('unit:')) {
                    header.unitNames.push(WebMolKit.MoleculeStream.skUnescape(line.substring(5, eq)));
                    header.unitURIs.push(WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1)));
                }
            }
            return header;
        }
        formatMetaData(header) {
            let content = '';
            for (let pfx in header.prefixes)
                content += 'pfx:' + WebMolKit.MoleculeStream.skEscape(pfx) + '=' + WebMolKit.MoleculeStream.skEscape(header.prefixes[pfx]) + '\n';
            content += 'targetName=' + WebMolKit.MoleculeStream.skEscape(header.targetName) + '\n';
            content += 'targetURI=' + WebMolKit.MoleculeStream.skEscape(header.targetURI) + '\n';
            content += 'organismName=' + WebMolKit.MoleculeStream.skEscape(header.organismName) + '\n';
            content += 'organismURI=' + WebMolKit.MoleculeStream.skEscape(header.organismURI) + '\n';
            content += 'targetTypeName=' + WebMolKit.MoleculeStream.skEscape(header.targetTypeName) + '\n';
            content += 'targetTypeURI=' + WebMolKit.MoleculeStream.skEscape(header.targetTypeURI) + '\n';
            content += 'cellName=' + WebMolKit.MoleculeStream.skEscape(header.cellName) + '\n';
            content += 'cellURI=' + WebMolKit.MoleculeStream.skEscape(header.cellURI) + '\n';
            content += 'assayTypeName=' + WebMolKit.MoleculeStream.skEscape(header.assayTypeName) + '\n';
            content += 'assayTypeURI=' + WebMolKit.MoleculeStream.skEscape(header.assayTypeURI) + '\n';
            content += 'assayDescription=' + WebMolKit.MoleculeStream.skEscape(header.assayDescription) + '\n';
            content += 'sourceName=' + WebMolKit.MoleculeStream.skEscape(header.sourceName) + '\n';
            content += 'sourceURI=' + WebMolKit.MoleculeStream.skEscape(header.sourceURI) + '\n';
            content += 'sourceVersion=' + WebMolKit.MoleculeStream.skEscape(header.sourceVersion) + '\n';
            content += 'documentName=' + WebMolKit.MoleculeStream.skEscape(header.documentName) + '\n';
            content += 'documentURI=' + WebMolKit.MoleculeStream.skEscape(header.documentURI) + '\n';
            content += 'measureTypeName=' + WebMolKit.MoleculeStream.skEscape(header.measureTypeName) + '\n';
            content += 'measureTypeURI=' + WebMolKit.MoleculeStream.skEscape(header.measureTypeURI) + '\n';
            for (let n = 0, num = Math.min(header.unitNames.length, header.unitURIs.length); n < num; n++)
                content += 'unit:' + WebMolKit.MoleculeStream.skEscape(header.unitNames[n]) + '=' + WebMolKit.MoleculeStream.skEscape(header.unitURIs[n]) + '\n';
            return content;
        }
        plainHeading() { return AssayProvenance.NAME; }
        isColumnReserved(colName) {
            return colName == AssayProvenance.COLNAME_VALUE || colName == AssayProvenance.COLNAME_ERROR ||
                colName == AssayProvenance.COLNAME_UNITS || colName == AssayProvenance.COLNAME_RELATION ||
                colName == AssayProvenance.COLNAME_SOURCEURI;
        }
        numTextRenderings(row) { return 2; }
        produceTextRendering(row, idx) {
            let header = this.getHeader();
            if (idx == 0) {
                let tr = {
                    'name': 'Activity',
                    'descr': 'Activity measurement details for this record',
                    'text': '',
                    'type': WebMolKit.Aspect.TEXT_PLAIN
                };
                let val = this.getValue(row), error = this.getError(row);
                let units = this.getUnits(row), rel = this.getRelation(row);
                tr.text = '';
                if (!Number.isNaN(val)) {
                    if (rel)
                        tr.text += rel + ' ';
                    tr.text += val;
                    if (!Number.isNaN(error))
                        tr.text += ' \u{00B1} ' + error;
                    if (units)
                        tr.text += ' ' + units;
                }
                return tr;
            }
            else if (idx == 1) {
                let tr = {
                    'name': 'Source',
                    'descr': 'Origin of the structure and activity measurement',
                    'text': '',
                    'type': WebMolKit.Aspect.TEXT_LINK
                };
                let url = this.getSourceURI(row);
                for (let pfx in header.prefixes)
                    if (url.startsWith(pfx + ':')) {
                        url = header.prefixes[pfx] + url.substring(pfx.length + 1);
                        break;
                    }
                tr.text = url;
                return tr;
            }
            return null;
        }
    }
    AssayProvenance.CODE = 'org.mmi.aspect.AssayProvenance';
    AssayProvenance.NAME = 'Assay Provenance';
    AssayProvenance.COLNAME_MOLECULE = 'Molecule';
    AssayProvenance.COLNAME_NAME = 'Name';
    AssayProvenance.COLNAME_VALUE = 'Value';
    AssayProvenance.COLNAME_ERROR = 'Error';
    AssayProvenance.COLNAME_UNITS = 'Units';
    AssayProvenance.COLNAME_RELATION = 'Relation';
    AssayProvenance.COLNAME_SOURCEURI = 'SourceURI';
    AssayProvenance.URI_UNIT_M = 'http://purl.obolibrary.org/obo/UO_0000062';
    AssayProvenance.URI_UNIT_mM = 'http://purl.obolibrary.org/obo/UO_0000063';
    AssayProvenance.URI_UNIT_uM = 'http://purl.obolibrary.org/obo/UO_0000064';
    AssayProvenance.URI_UNIT_nM = 'http://purl.obolibrary.org/obo/UO_0000065';
    AssayProvenance.URI_UNIT_pM = 'http://purl.obolibrary.org/obo/UO_0000066';
    AssayProvenance.URI_UNIT_logM = 'http://www.bioassayontology.org/bao#BAO_0000101';
    AssayProvenance.URI_UNIT_perM = 'http://www.bioassayontology.org/bao#BAO_0000102';
    AssayProvenance.URI_UNIT_gL = 'http://purl.obolibrary.org/obo/UO_0000175';
    AssayProvenance.URI_UNIT_mgL = 'http://purl.obolibrary.org/obo/UO_0000273';
    AssayProvenance.URI_UNIT_ugL = 'http://purl.obolibrary.org/obo/UO_0000275';
    AssayProvenance.URI_UNIT_binary = 'http://www.bioassayontology.org/bao#BAO_0080023';
    WebMolKit.AssayProvenance = AssayProvenance;
    WebMolKit.registerAspect(AssayProvenance);
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class BayesianPredictionModel {
    }
    WebMolKit.BayesianPredictionModel = BayesianPredictionModel;
    class BayesianPredictionOutcome {
    }
    WebMolKit.BayesianPredictionOutcome = BayesianPredictionOutcome;
    class BayesianPrediction extends WebMolKit.Aspect {
        constructor(ds, allowModify) {
            super(BayesianPrediction.CODE, ds, allowModify);
            this.setup();
        }
        static isBayesianPrediction(ds) {
            for (let n = 0; n < ds.numExtensions; n++)
                if (ds.getExtType(n) == BayesianPrediction.CODE)
                    return true;
            return false;
        }
        getModels() {
            let content = '';
            for (let n = 0; n < this.ds.numExtensions; n++)
                if (this.ds.getExtType(n) == BayesianPrediction.CODE) {
                    content = this.ds.getExtData(n);
                    break;
                }
            let models = [];
            let m = null;
            for (let line of content.split('\n')) {
                if (line == 'model:') {
                    if (m != null)
                        models.push(m);
                    m = {};
                    continue;
                }
                if (m == null)
                    continue;
                let eq = line.indexOf('=');
                if (eq < 0)
                    continue;
                if (line.startsWith('colMolecule='))
                    m.colMolecule = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('colRaw='))
                    m.colRaw = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('colScaled='))
                    m.colScaled = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('colArcTan='))
                    m.colArcTan = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('colDomain='))
                    m.colDomain = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('colAtoms='))
                    m.colAtoms = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('name='))
                    m.name = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('description='))
                    m.description = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('targetName='))
                    m.targetName = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('isOffTarget='))
                    m.isOffTarget = line.substring(eq + 1) == 'true';
            }
            if (m != null)
                models.push(m);
            return models;
        }
        setModels(models) {
            let lines = [];
            for (let m of models) {
                lines.push('model:');
                lines.push('colMolecule=' + WebMolKit.MoleculeStream.skEscape(m.colMolecule));
                lines.push('colRaw=' + WebMolKit.MoleculeStream.skEscape(m.colRaw));
                lines.push('colScaled=' + WebMolKit.MoleculeStream.skEscape(m.colScaled));
                lines.push('colArcTan=' + WebMolKit.MoleculeStream.skEscape(m.colArcTan));
                lines.push('colDomain=' + WebMolKit.MoleculeStream.skEscape(m.colDomain));
                lines.push('colAtoms=' + WebMolKit.MoleculeStream.skEscape(m.colAtoms));
                lines.push('name=' + WebMolKit.MoleculeStream.skEscape(m.name));
                lines.push('description=' + WebMolKit.MoleculeStream.skEscape(m.description));
                lines.push('targetName=' + WebMolKit.MoleculeStream.skEscape(m.targetName));
                lines.push('isOffTarget=' + m.isOffTarget);
            }
            let content = lines.join('\n');
            for (let n = 0; n < this.ds.numExtensions; n++)
                if (this.ds.getExtType(n) == WebMolKit.BayesianSource.CODE) {
                    this.ds.setExtData(n, content.toString());
                    return;
                }
            this.ds.appendExtension('BayesianPrediction', BayesianPrediction.CODE, content.toString());
        }
        getOutcome(row, model) {
            let outcome = new BayesianPredictionOutcome();
            outcome.raw = this.ds.getReal(row, model.colRaw);
            outcome.scaled = this.ds.getReal(row, model.colScaled);
            outcome.arctan = this.ds.getReal(row, model.colArcTan);
            outcome.domain = this.ds.getReal(row, model.colDomain);
            let strAtoms = this.ds.getString(row, model.colAtoms);
            if (strAtoms) {
                outcome.atoms = [];
                for (let b of strAtoms.split(','))
                    outcome.atoms.push(parseFloat(b));
            }
            return outcome;
        }
        setOutcome(row, model, outcome) {
            let col = this.ds.findColByName(model.colRaw, "real");
            if (col >= 0)
                this.ds.setReal(row, col, outcome.raw);
            col = this.ds.findColByName(model.colScaled, "real");
            if (col >= 0)
                this.ds.setReal(row, col, outcome.scaled);
            col = this.ds.findColByName(model.colArcTan, "real");
            if (col >= 0)
                this.ds.setReal(row, col, outcome.arctan);
            col = this.ds.findColByName(model.colDomain, "real");
            if (col >= 0)
                this.ds.setReal(row, col, outcome.domain);
            col = this.ds.findColByName(model.colAtoms, "string");
            if (col >= 0)
                this.ds.setString(row, col, outcome.atoms ? outcome.atoms.toString() : null);
        }
        setup() {
            if (this.allowModify) {
                let models = this.getModels();
                this.setModels(models);
            }
        }
        plainHeading() { return WebMolKit.BayesianSource.NAME; }
    }
    BayesianPrediction.CODE = 'org.mmi.aspect.BayesianPrediction';
    BayesianPrediction.NAME = 'Bayesian Prediction';
    WebMolKit.BayesianPrediction = BayesianPrediction;
    WebMolKit.registerAspect(BayesianPrediction);
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class BayesianSourceModel {
        constructor() {
            this.colNameMolecule = '';
            this.colNameValue = '';
            this.thresholdValue = 0.5;
            this.thresholdRelation = '>=';
            this.folding = 0;
            this.noteField = '';
            this.noteTitle = '';
            this.noteOrigin = '';
            this.noteComment = '';
        }
    }
    WebMolKit.BayesianSourceModel = BayesianSourceModel;
    class BayesianSource extends WebMolKit.Aspect {
        constructor(ds, allowModify) {
            super(BayesianSource.CODE, ds, allowModify);
            this.setup();
        }
        static isBayesianSource(ds) {
            for (let n = 0; n < ds.numExtensions; n++)
                if (ds.getExtType(n) == BayesianSource.CODE)
                    return true;
            return false;
        }
        getModels() {
            let content = '';
            for (let n = 0; n < this.ds.numExtensions; n++)
                if (this.ds.getExtType(n) == BayesianSource.CODE) {
                    content = this.ds.getExtData(n);
                    break;
                }
            let models = [];
            let m = null;
            for (let line of content.split('\n')) {
                if (line == 'model:') {
                    if (m != null)
                        models.push(m);
                    m = {};
                    continue;
                }
                if (m == null)
                    continue;
                let eq = line.indexOf('=');
                if (eq < 0)
                    continue;
                if (line.startsWith('colNameMolecule='))
                    m.colNameMolecule = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('colNameValue='))
                    m.colNameValue = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('thresholdValue='))
                    m.thresholdValue = parseFloat(line.substring(eq + 1));
                else if (line.startsWith('thresholdRelation='))
                    m.thresholdRelation = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('folding='))
                    m.folding = parseInt(line.substring(eq + 1));
                else if (line.startsWith('noteField='))
                    m.noteField = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('noteTitle='))
                    m.noteTitle = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('noteOrigin='))
                    m.noteOrigin = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('noteComment='))
                    m.noteComment = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
            }
            if (m != null)
                models.push(m);
            return models;
        }
        setModels(models) {
            let lines = [];
            for (let m of models) {
                lines.push('model:');
                lines.push('colNameMolecule=' + WebMolKit.MoleculeStream.skEscape(m.colNameMolecule));
                lines.push('colNameValue=' + WebMolKit.MoleculeStream.skEscape(m.colNameValue));
                lines.push('thresholdValue=' + m.thresholdValue);
                lines.push('thresholdRelation=' + WebMolKit.MoleculeStream.skEscape(m.thresholdRelation));
                lines.push('folding=%d' + m.folding);
                lines.push('noteField=' + WebMolKit.MoleculeStream.skEscape(m.noteField));
                lines.push('noteTitle=' + WebMolKit.MoleculeStream.skEscape(m.noteTitle));
                lines.push('noteOrigin=' + WebMolKit.MoleculeStream.skEscape(m.noteOrigin));
                lines.push('noteComment=' + WebMolKit.MoleculeStream.skEscape(m.noteComment));
            }
            let content = lines.join('\n');
            for (let n = 0; n < this.ds.numExtensions; n++)
                if (this.ds.getExtType(n) == BayesianSource.CODE) {
                    this.ds.setExtData(n, content.toString());
                    return;
                }
            this.ds.appendExtension('BayesianSource', BayesianSource.CODE, content.toString());
        }
        setup() {
            if (this.allowModify) {
                let models = this.getModels();
                this.setModels(models);
            }
        }
        plainHeading() { return BayesianSource.NAME; }
    }
    BayesianSource.CODE = 'org.mmi.aspect.BayesianSource';
    BayesianSource.NAME = 'Bayesian Source';
    WebMolKit.BayesianSource = BayesianSource;
    WebMolKit.registerAspect(BayesianSource);
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class BinaryDataField {
    }
    WebMolKit.BinaryDataField = BinaryDataField;
    class BinaryData extends WebMolKit.Aspect {
        constructor(ds, allowModify) {
            super(BinaryData.CODE, ds, allowModify);
            this.fields = [];
            this.setup();
        }
        static isBinaryData(ds) {
            for (let n = 0; n < ds.numExtensions; n++)
                if (ds.getExtType(n) == BinaryData.CODE)
                    return true;
            return false;
        }
        getFields() {
            return WebMolKit.deepClone(this.fields);
        }
        setFields(fields) {
            this.fields = WebMolKit.deepClone(fields);
            let content = this.formatMetaData(fields);
            for (let n = 0; n < this.ds.numExtensions; n++)
                if (this.ds.getExtType(n) == WebMolKit.MeasurementData.CODE) {
                    this.ds.setExtData(n, content);
                    return;
                }
            this.ds.appendExtension(WebMolKit.MeasurementData.NAME, WebMolKit.MeasurementData.CODE, content);
        }
        getValue(row, field) {
            let value = this.getDestValue(row, field);
            if (value != null)
                return value;
            return this.getSourceValue(row, field);
        }
        getSourceValue(row, field) {
            let col = this.ds.findColByName(field.colNameSource);
            if (col < 0 || this.ds.isNull(row, col))
                return null;
            let ct = this.ds.colType(col);
            let value = 0;
            if (ct == "boolean")
                return this.ds.getBoolean(row, col);
            else if (ct == "integer")
                value = this.ds.getInteger(row, col);
            else if (ct == "real")
                value = this.ds.getReal(row, col);
            else
                return null;
            if (field.thresholdRelation == '>')
                return value > field.thresholdValue;
            if (field.thresholdRelation == '<')
                return value < field.thresholdValue;
            if (field.thresholdRelation == '>=')
                return value >= field.thresholdValue;
            if (field.thresholdRelation == '<=')
                return value <= field.thresholdValue;
            return null;
        }
        getDestValue(row, field) {
            return this.ds.getBoolean(row, field.colNameDest);
        }
        setup() {
            this.parseAndCorrect();
        }
        parseAndCorrect() {
            let got = false;
            for (let n = 0; n < this.ds.numExtensions; n++)
                if (this.ds.getExtType(n) == WebMolKit.MeasurementData.CODE) {
                    this.fields = this.parseMetaData(this.ds.getExtData(n));
                    got = true;
                    break;
                }
            if (!got && this.allowModify) {
                let content = this.formatMetaData(this.fields);
                this.ds.appendExtension(WebMolKit.MeasurementData.NAME, WebMolKit.MeasurementData.CODE, content);
            }
        }
        parseMetaData(content) {
            let fields = [];
            let f = null;
            for (let line of content.split(/\r?\n/)) {
                if (line == 'field:') {
                    if (f != null)
                        fields.push(f);
                    f = { 'colNameSource': '', 'colNameDest': '', 'thresholdValue': 0.5, 'thresholdRelation': '>=' };
                    continue;
                }
                if (f == null)
                    continue;
                let eq = line.indexOf('=');
                if (eq < 0)
                    continue;
                if (line.startsWith('colNameSource='))
                    f.colNameSource = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('colNameDest='))
                    f.colNameDest = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                else if (line.startsWith('thresholdValue='))
                    f.thresholdValue = parseFloat(line.substring(eq + 1));
                else if (line.startsWith('thresholdRelation='))
                    f.thresholdRelation = WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
            }
            if (f != null)
                fields.push(f);
            return fields;
        }
        formatMetaData(fields) {
            let lines = [];
            for (let f of fields) {
                lines.push('field:');
                lines.push('colNameSource=' + WebMolKit.MoleculeStream.skEscape(f.colNameSource));
                lines.push('colNameDest=' + WebMolKit.MoleculeStream.skEscape(f.colNameDest));
                lines.push('thresholdValue=' + f.thresholdValue);
                lines.push('thresholdRelation=' + WebMolKit.MoleculeStream.skEscape(f.thresholdRelation));
            }
            return lines.join('\n');
        }
        plainHeading() { return BinaryData.NAME; }
        isColumnReserved(colName) { return false; }
    }
    BinaryData.CODE = 'org.mmi.aspect.BinaryData';
    BinaryData.NAME = 'Binary Data';
    WebMolKit.BinaryData = BinaryData;
    WebMolKit.registerAspect(BinaryData);
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let ExperimentComponentType;
    (function (ExperimentComponentType) {
        ExperimentComponentType[ExperimentComponentType["Reactant"] = 0] = "Reactant";
        ExperimentComponentType[ExperimentComponentType["Reagent"] = 1] = "Reagent";
        ExperimentComponentType[ExperimentComponentType["Product"] = 2] = "Product";
    })(ExperimentComponentType = WebMolKit.ExperimentComponentType || (WebMolKit.ExperimentComponentType = {}));
    class ExperimentComponent {
        constructor(mol, name) {
            this.mol = null;
            this.name = '';
            this.stoich = '';
            this.mass = null;
            this.volume = null;
            this.moles = null;
            this.density = null;
            this.conc = null;
            this.yield = null;
            this.primary = false;
            this.waste = false;
            this.equiv = null;
            this.meta = '';
            this.mol = mol;
            if (name)
                this.name = name;
        }
        clone() {
            let dup = new ExperimentComponent(this.mol, this.name);
            dup.stoich = this.stoich;
            dup.mass = this.mass;
            dup.volume = this.volume;
            dup.moles = this.moles;
            dup.density = this.density;
            dup.conc = this.conc;
            dup.yield = this.yield;
            dup.primary = this.primary;
            dup.waste = this.waste;
            dup.equiv = this.equiv;
            dup.meta = this.meta;
            return dup;
        }
        equals(other) {
            if (this.name != other.name)
                return false;
            if (this.stoich != other.stoich || this.mass != other.mass || this.volume != other.volume || this.moles != other.moles ||
                this.density != other.density || this.conc != other.conc || this.yield != other.yield || this.primary != other.primary ||
                this.waste != other.waste || this.equiv != other.equiv || this.meta != other.meta)
                return false;
            if (this.mol === other.mol)
                return true;
            if (this.mol == null || other.mol == null)
                return false;
            return this.mol.compareTo(other.mol) == 0;
        }
        isBlank() {
            return WebMolKit.MolUtil.isBlank(this.mol) && !this.name;
        }
    }
    WebMolKit.ExperimentComponent = ExperimentComponent;
    class ExperimentStep {
        constructor() {
            this.reactants = [];
            this.reagents = [];
            this.products = [];
            this.meta = '';
        }
        clone() {
            let dup = new ExperimentStep();
            for (let c of this.reactants)
                dup.reactants.push(c.clone());
            for (let c of this.reagents)
                dup.reagents.push(c.clone());
            for (let c of this.products)
                dup.products.push(c.clone());
            dup.meta = this.meta;
            return dup;
        }
        equals(other) {
            if (this.reactants.length != other.reactants.length)
                return false;
            if (this.reagents.length != other.reagents.length)
                return false;
            if (this.products.length != other.products.length)
                return false;
            if (this.meta != other.meta)
                return false;
            for (let n = 0; n < this.reactants.length; n++)
                if (!this.reactants[n].equals(other.reactants[n]))
                    return false;
            for (let n = 0; n < this.reagents.length; n++)
                if (!this.reagents[n].equals(other.reagents[n]))
                    return false;
            for (let n = 0; n < this.products.length; n++)
                if (!this.products[n].equals(other.products[n]))
                    return false;
            return true;
        }
    }
    WebMolKit.ExperimentStep = ExperimentStep;
    class ExperimentEntry {
        constructor() {
            this.title = '';
            this.createDate = null;
            this.modifyDate = null;
            this.doi = '';
            this.meta = '';
            this.steps = [];
        }
        clone() {
            let dup = new ExperimentEntry();
            dup.title = this.title;
            dup.createDate = this.createDate;
            dup.modifyDate = this.modifyDate;
            dup.doi = this.doi;
            dup.meta = this.meta;
            for (let s of this.steps)
                dup.steps.push(s.clone());
            return dup;
        }
        deepClone() {
            let dup = this.clone();
            for (let step of dup.steps) {
                for (let comp of step.reactants)
                    if (comp.mol != null)
                        comp.mol = comp.mol.clone();
                for (let comp of step.reagents)
                    if (comp.mol != null)
                        comp.mol = comp.mol.clone();
                for (let comp of step.products)
                    if (comp.mol != null)
                        comp.mol = comp.mol.clone();
            }
            return dup;
        }
        equals(other) {
            if (this.title != other.title)
                return false;
            let d1 = this.createDate == null ? 0 : this.createDate.getTime(), d2 = other.createDate == null ? 0 : other.createDate.getTime();
            if (d1 != d2)
                return false;
            let d3 = this.modifyDate == null ? 0 : this.modifyDate.getTime(), d4 = other.modifyDate == null ? 0 : other.modifyDate.getTime();
            if (d3 != d4)
                return false;
            if (this.doi != other.doi || this.meta != other.meta)
                return false;
            if (this.steps.length != other.steps.length)
                return false;
            for (let n = 0; n < this.steps.length; n++)
                if (!this.steps[n].equals(other.steps[n]))
                    return false;
            return true;
        }
        getComponent(step, type, idx) {
            if (type == ExperimentComponentType.Reactant)
                return this.steps[step].reactants[idx];
            if (type == ExperimentComponentType.Reagent)
                return this.steps[step].reagents[idx];
            if (type == ExperimentComponentType.Product)
                return this.steps[step].products[idx];
            return new ExperimentComponent();
        }
    }
    WebMolKit.ExperimentEntry = ExperimentEntry;
    class Experiment extends WebMolKit.Aspect {
        constructor(ds, allowModify) {
            super(Experiment.CODE, ds, allowModify);
            if (Object.keys(Experiment.COLUMN_DESCRIPTIONS).length == 0) {
                let v = Experiment.COLUMN_DESCRIPTIONS;
                v[Experiment.COLNAME_EXPERIMENT_TITLE] = 'Title description for the experiment';
                v[Experiment.COLNAME_EXPERIMENT_CREATEDATE] = 'Date the experiment was created (seconds since 1970)';
                v[Experiment.COLNAME_EXPERIMENT_MODIFYDATE] = 'Date the experiment was last modified (seconds since 1970)';
                v[Experiment.COLNAME_EXPERIMENT_DOI] = 'Digital object identifiers (DOI) for the experiment (whitespace separated)';
                v[Experiment.COLNAME_EXPERIMENT_META] = 'Additional experiment metadata';
                v[Experiment.COLNAME_STEP_META] = 'Additional step metadata';
                v[Experiment.COLNAME_REACTANT_MOL] = 'Molecular structure of reactant';
                v[Experiment.COLNAME_REACTANT_NAME] = 'Name of reactant';
                v[Experiment.COLNAME_REACTANT_STOICH] = 'Stoichiometry of reactant';
                v[Experiment.COLNAME_REACTANT_MASS] = 'Mass quantity of reactant (g)';
                v[Experiment.COLNAME_REACTANT_VOLUME] = 'Volume quantity of reactant (mL)';
                v[Experiment.COLNAME_REACTANT_MOLES] = 'Molar quantity of reactant (mol)';
                v[Experiment.COLNAME_REACTANT_DENSITY] = 'Density of reactant (g/mL)';
                v[Experiment.COLNAME_REACTANT_CONC] = 'Concentration of reactant (mol/L)';
                v[Experiment.COLNAME_REACTANT_PRIMARY] = 'Whether the reactant is used for yield calculation';
                v[Experiment.COLNAME_REACTANT_META] = 'Additional reactant metadata';
                v[Experiment.COLNAME_REAGENT_MOL] = 'Molecular structure of reagent';
                v[Experiment.COLNAME_REAGENT_NAME] = 'Name of reagent';
                v[Experiment.COLNAME_REAGENT_EQUIV] = 'Molar equivalents of reagent';
                v[Experiment.COLNAME_REAGENT_MASS] = 'Mass quantity of reagent (g)';
                v[Experiment.COLNAME_REAGENT_VOLUME] = 'Volume quantity of reagent (mL)';
                v[Experiment.COLNAME_REAGENT_MOLES] = 'Molar quantity of reagent (mol)';
                v[Experiment.COLNAME_REAGENT_DENSITY] = 'Density of reagent (g/mL)';
                v[Experiment.COLNAME_REAGENT_CONC] = 'Concentration of reagent (mol/L)';
                v[Experiment.COLNAME_REAGENT_META] = 'Additional reagent metadata';
                v[Experiment.COLNAME_PRODUCT_MOL] = 'Molecular structure of product';
                v[Experiment.COLNAME_PRODUCT_NAME] = 'Name of product';
                v[Experiment.COLNAME_PRODUCT_STOICH] = 'Stoichiometry of product';
                v[Experiment.COLNAME_PRODUCT_MASS] = 'Mass quantity of reactant (g)';
                v[Experiment.COLNAME_PRODUCT_VOLUME] = 'Volume quantity of reactant (mL)';
                v[Experiment.COLNAME_PRODUCT_MOLES] = 'Molar quantity of reactant (mol)';
                v[Experiment.COLNAME_PRODUCT_DENSITY] = 'Density of reactant (g/mL)';
                v[Experiment.COLNAME_PRODUCT_CONC] = 'Concentration of reactant (mol/L)';
                v[Experiment.COLNAME_PRODUCT_YIELD] = 'Yield of product (%)';
                v[Experiment.COLNAME_PRODUCT_WASTE] = 'Whether the product is an unwanted byproduct';
                v[Experiment.COLNAME_PRODUCT_META] = 'Additional product metadata';
            }
            this.setup();
        }
        static isExperiment(ds) {
            for (let n = 0; n < ds.numExtensions; n++)
                if (ds.getExtType(n) == Experiment.CODE)
                    return true;
            return false;
        }
        isFirstStep(row) {
            if (this.ds.notNull(row, Experiment.COLNAME_EXPERIMENT_CREATEDATE))
                return true;
            let mol = this.ds.getMolecule(row, Experiment.COLNAME_REACTANT_MOL + '1');
            if (WebMolKit.MolUtil.notBlank(mol))
                return true;
            let name = this.ds.getString(row, Experiment.COLNAME_REACTANT_NAME + '1');
            if (name)
                return true;
            return false;
        }
        numberOfSteps(row) {
            if (row >= this.ds.numRows)
                return 0;
            let steps = 1;
            while (row + steps < this.ds.numRows) {
                if (this.isFirstStep(row + steps))
                    break;
                steps++;
            }
            return steps;
        }
        getEntry(row) {
            let entry = new ExperimentEntry();
            let title = this.ds.getString(row, Experiment.COLNAME_EXPERIMENT_TITLE);
            if (title)
                entry.title = title;
            let createDate = this.ds.getReal(row, Experiment.COLNAME_EXPERIMENT_CREATEDATE);
            if (createDate)
                entry.createDate = new Date(createDate * 1000);
            let modifyDate = this.ds.getReal(row, Experiment.COLNAME_EXPERIMENT_MODIFYDATE);
            if (modifyDate)
                entry.modifyDate = new Date(modifyDate * 1000);
            let doi = this.ds.getString(row, Experiment.COLNAME_EXPERIMENT_DOI);
            if (doi)
                entry.doi = doi;
            let meta = this.ds.getString(row, Experiment.COLNAME_EXPERIMENT_META);
            if (meta)
                entry.meta = meta;
            let [nreactants, nproducts, nreagents] = this.countComponents();
            for (let pos = row; pos < this.ds.numRows; pos++) {
                if (pos > row && this.isFirstStep(pos))
                    break;
                let step = new ExperimentStep();
                if (pos == row)
                    for (let n = 1; n <= nreactants; n++) {
                        let comp = this.fetchReactant(pos, n);
                        if (comp != null)
                            step.reactants.push(comp);
                        else
                            break;
                    }
                for (let n = 1; n <= nproducts; n++) {
                    let comp = this.fetchProduct(pos, n);
                    if (comp != null)
                        step.products.push(comp);
                    else
                        break;
                }
                for (let n = 1; n <= nreagents; n++) {
                    let comp = this.fetchReagent(pos, n);
                    if (comp != null)
                        step.reagents.push(comp);
                    else
                        break;
                }
                step.meta = this.ds.getString(pos, Experiment.COLNAME_STEP_META);
                entry.steps.push(step);
            }
            return entry;
        }
        setEntry(row, entry) {
            this.putEntry(row, entry, true);
        }
        addEntry(entry) {
            this.putEntry(this.ds.numRows, entry, false);
        }
        insertEntry(row, entry) {
            this.putEntry(row, entry, false);
        }
        deleteEntry(row) {
            let nsteps = this.numberOfSteps(row);
            for (let n = row + nsteps - 1; n >= row; n--)
                this.ds.deleteRow(n);
        }
        setup() {
            this.parseAndCorrect();
        }
        parseAndCorrect() {
            let ds = this.ds;
            let idxRxn = -1, idxYld = -1, idxExp = -1;
            let extRxn = '', extYld = '', extExp = '';
            for (let n = 0; n < ds.numExtensions; n++) {
                if (ds.getExtType(n) == Experiment.CODE_RXN) {
                    idxRxn = n;
                    extRxn = ds.getExtData(n);
                }
                else if (ds.getExtType(n) == Experiment.CODE_YLD) {
                    idxYld = n;
                    extYld = ds.getExtData(n);
                }
                else if (ds.getExtType(n) == Experiment.CODE) {
                    idxExp = n;
                    extExp = ds.getExtData(n);
                }
            }
            let [nreactants, nproducts, nreagents] = this.parseReactionMetaData(extRxn);
            let meta = `nreactants=${nreactants}\nnproducts=${nproducts}\nnreagents=${nreagents}\n`;
            if (idxRxn >= 0)
                ds.setExtData(idxRxn, meta);
            else
                ds.appendExtension(Experiment.NAME_RXN, Experiment.CODE_RXN, meta);
            if (idxYld >= 0)
                ds.setExtData(idxYld, '');
            else
                ds.appendExtension(Experiment.NAME_YLD, Experiment.CODE_YLD, '');
            if (idxExp >= 0)
                ds.setExtData(idxExp, '');
            else
                ds.appendExtension(Experiment.NAME, Experiment.CODE, '');
            this.forceColumn(Experiment.COLNAME_EXPERIMENT_TITLE, "string");
            this.forceColumn(Experiment.COLNAME_EXPERIMENT_CREATEDATE, "real");
            this.forceColumn(Experiment.COLNAME_EXPERIMENT_MODIFYDATE, "real");
            this.forceColumn(Experiment.COLNAME_EXPERIMENT_DOI, "string");
            this.forceColumn(Experiment.COLNAME_EXPERIMENT_META, "string");
            this.forceColumn(Experiment.COLNAME_STEP_META, "string");
            for (let n = 1; n <= nreactants; n++)
                this.forceReactantColumns(n);
            for (let n = 1; n <= nreagents; n++)
                this.forceReagentColumns(n);
            for (let n = 1; n <= nproducts; n++)
                this.forceProductColumns(n);
        }
        forceColumn(colName, type, suffix) {
            let useName = colName + (suffix == null ? '' : suffix);
            this.ds.ensureColumn(useName, type, Experiment.COLUMN_DESCRIPTIONS[colName]);
        }
        forceReactantColumns(suffix) {
            this.forceColumn(Experiment.COLNAME_REACTANT_MOL, "molecule", suffix);
            this.forceColumn(Experiment.COLNAME_REACTANT_NAME, "string", suffix);
            this.forceColumn(Experiment.COLNAME_REACTANT_STOICH, "string", suffix);
            this.forceColumn(Experiment.COLNAME_REACTANT_MASS, "real", suffix);
            this.forceColumn(Experiment.COLNAME_REACTANT_VOLUME, "real", suffix);
            this.forceColumn(Experiment.COLNAME_REACTANT_MOLES, "real", suffix);
            this.forceColumn(Experiment.COLNAME_REACTANT_DENSITY, "real", suffix);
            this.forceColumn(Experiment.COLNAME_REACTANT_CONC, "real", suffix);
            this.forceColumn(Experiment.COLNAME_REACTANT_PRIMARY, "boolean", suffix);
            this.forceColumn(Experiment.COLNAME_REACTANT_META, "string", suffix);
        }
        forceReagentColumns(suffix) {
            this.forceColumn(Experiment.COLNAME_REAGENT_MOL, "molecule", suffix);
            this.forceColumn(Experiment.COLNAME_REAGENT_NAME, "string", suffix);
            this.forceColumn(Experiment.COLNAME_REAGENT_EQUIV, "real", suffix);
            this.forceColumn(Experiment.COLNAME_REAGENT_MASS, "real", suffix);
            this.forceColumn(Experiment.COLNAME_REAGENT_VOLUME, "real", suffix);
            this.forceColumn(Experiment.COLNAME_REAGENT_MOLES, "real", suffix);
            this.forceColumn(Experiment.COLNAME_REAGENT_DENSITY, "real", suffix);
            this.forceColumn(Experiment.COLNAME_REAGENT_CONC, "real", suffix);
            this.forceColumn(Experiment.COLNAME_REAGENT_META, "string", suffix);
        }
        forceProductColumns(suffix) {
            this.forceColumn(Experiment.COLNAME_PRODUCT_MOL, "molecule", suffix);
            this.forceColumn(Experiment.COLNAME_PRODUCT_NAME, "string", suffix);
            this.forceColumn(Experiment.COLNAME_PRODUCT_STOICH, "string", suffix);
            this.forceColumn(Experiment.COLNAME_PRODUCT_MASS, "real", suffix);
            this.forceColumn(Experiment.COLNAME_PRODUCT_VOLUME, "real", suffix);
            this.forceColumn(Experiment.COLNAME_PRODUCT_MOLES, "real", suffix);
            this.forceColumn(Experiment.COLNAME_PRODUCT_DENSITY, "real", suffix);
            this.forceColumn(Experiment.COLNAME_PRODUCT_CONC, "real", suffix);
            this.forceColumn(Experiment.COLNAME_PRODUCT_YIELD, "real", suffix);
            this.forceColumn(Experiment.COLNAME_PRODUCT_WASTE, "boolean", suffix);
            this.forceColumn(Experiment.COLNAME_PRODUCT_META, "string", suffix);
        }
        parseReactionMetaData(content) {
            let nreactants = 1, nproducts = 1, nreagents = 0;
            for (let line of content.split(/\r?\n/)) {
                if (line.startsWith('nreactants='))
                    nreactants = Math.max(nreactants, Math.min(100, parseInt(line.substring(11))));
                else if (line.startsWith('nproducts='))
                    nproducts = Math.max(nproducts, Math.min(100, parseInt(line.substring(10))));
                else if (line.startsWith('nreagents='))
                    nreagents = Math.max(nreagents, Math.min(100, parseInt(line.substring(10))));
            }
            return [nreactants, nproducts, nreagents];
        }
        countComponents() {
            let nreactants = 0, nproducts = 0, nreagents = 0;
            for (let n = 0; n < this.ds.numExtensions; n++)
                if (this.ds.getExtType(n) == Experiment.CODE_RXN) {
                    [nreactants, nproducts, nreagents] = this.parseReactionMetaData(this.ds.getExtData(n));
                    break;
                }
            return [nreactants, nproducts, nreagents];
        }
        fetchReactant(row, idx) {
            let mol = this.ds.getMolecule(row, `${Experiment.COLNAME_REACTANT_MOL}${idx}`);
            let name = this.ds.getString(row, `${Experiment.COLNAME_REACTANT_NAME}${idx}`);
            if (WebMolKit.MolUtil.isBlank(mol) && !name)
                return null;
            let comp = new ExperimentComponent(mol, name);
            let stoich = this.ds.getString(row, `${Experiment.COLNAME_REACTANT_STOICH}${idx}`);
            if (stoich)
                comp.stoich = stoich;
            comp.mass = this.ds.getReal(row, `${Experiment.COLNAME_REACTANT_MASS}${idx}`);
            comp.volume = this.ds.getReal(row, `${Experiment.COLNAME_REACTANT_VOLUME}${idx}`);
            comp.moles = this.ds.getReal(row, `${Experiment.COLNAME_REACTANT_MOLES}${idx}`);
            comp.density = this.ds.getReal(row, `${Experiment.COLNAME_REACTANT_DENSITY}${idx}`);
            comp.conc = this.ds.getReal(row, `${Experiment.COLNAME_REACTANT_CONC}${idx}`);
            let primary = this.ds.getBoolean(row, `${Experiment.COLNAME_REACTANT_PRIMARY}${idx}`);
            if (primary != null)
                comp.primary = primary;
            comp.meta = this.ds.getString(row, `${Experiment.COLNAME_REACTANT_META}${idx}`);
            return comp;
        }
        fetchProduct(row, idx) {
            let mol = this.ds.getMolecule(row, `${Experiment.COLNAME_PRODUCT_MOL}${idx}`);
            let name = this.ds.getString(row, `${Experiment.COLNAME_PRODUCT_NAME}${idx}`);
            if (WebMolKit.MolUtil.isBlank(mol) && !name)
                return null;
            let comp = new ExperimentComponent(mol, name);
            let stoich = this.ds.getString(row, `${Experiment.COLNAME_PRODUCT_STOICH}${idx}`);
            if (stoich)
                comp.stoich = stoich;
            comp.mass = this.ds.getReal(row, `${Experiment.COLNAME_PRODUCT_MASS}${idx}`);
            comp.volume = this.ds.getReal(row, `${Experiment.COLNAME_PRODUCT_VOLUME}${idx}`);
            comp.moles = this.ds.getReal(row, `${Experiment.COLNAME_PRODUCT_MOLES}${idx}`);
            comp.density = this.ds.getReal(row, `${Experiment.COLNAME_PRODUCT_DENSITY}${idx}`);
            comp.conc = this.ds.getReal(row, `${Experiment.COLNAME_PRODUCT_CONC}${idx}`);
            comp.yield = this.ds.getReal(row, `${Experiment.COLNAME_PRODUCT_YIELD}${idx}`);
            let waste = this.ds.getBoolean(row, `${Experiment.COLNAME_PRODUCT_WASTE}${idx}`);
            if (waste != null)
                comp.waste = waste;
            comp.meta = this.ds.getString(row, `${Experiment.COLNAME_PRODUCT_META}${idx}`);
            return comp;
        }
        fetchReagent(row, idx) {
            let mol = this.ds.getMolecule(row, `${Experiment.COLNAME_REAGENT_MOL}${idx}`);
            let name = this.ds.getString(row, `${Experiment.COLNAME_REAGENT_NAME}${idx}`);
            if (WebMolKit.MolUtil.isBlank(mol) && !name)
                return null;
            let comp = new ExperimentComponent(mol, name);
            comp.mass = this.ds.getReal(row, `${Experiment.COLNAME_REAGENT_MASS}${idx}`);
            comp.volume = this.ds.getReal(row, `${Experiment.COLNAME_REAGENT_VOLUME}${idx}`);
            comp.moles = this.ds.getReal(row, `${Experiment.COLNAME_REAGENT_MOLES}${idx}`);
            comp.density = this.ds.getReal(row, `${Experiment.COLNAME_REAGENT_DENSITY}${idx}`);
            comp.conc = this.ds.getReal(row, `${Experiment.COLNAME_REAGENT_CONC}${idx}`);
            comp.equiv = this.ds.getReal(row, `${Experiment.COLNAME_REAGENT_EQUIV}${idx}`);
            comp.meta = this.ds.getString(row, `${Experiment.COLNAME_REAGENT_META}${idx}`);
            return comp;
        }
        putEntry(row, entry, replace) {
            let [preactants, pproducts, preagents] = this.countComponents();
            let [nreactants, nproducts, nreagents] = [preactants, pproducts, preagents];
            for (let step of entry.steps) {
                nreactants = Math.max(nreactants, step.reactants.length);
                nproducts = Math.max(nproducts, step.products.length);
                nreagents = Math.max(nreagents, step.reagents.length);
            }
            if (nreactants != preactants || nproducts != pproducts || nreagents != preagents) {
                let meta = `nreactants=${nreactants}\nnproducts=${nproducts}\nnreagents=${nreagents}`;
                let got = false;
                for (let n = 0; n < this.ds.numExtensions; n++)
                    if (this.ds.getExtType(n) == Experiment.CODE_RXN) {
                        this.ds.setExtData(n, meta);
                        got = true;
                        break;
                    }
                if (!got)
                    this.ds.appendExtension(Experiment.NAME_RXN, Experiment.CODE_RXN, meta);
            }
            for (let n = 1; n <= nreactants; n++)
                this.forceReactantColumns(n);
            for (let n = 1; n <= nreagents; n++)
                this.forceReagentColumns(n);
            for (let n = 1; n <= nproducts; n++)
                this.forceProductColumns(n);
            let oldSteps = replace ? this.numberOfSteps(row) : 0, newSteps = entry.steps.length;
            if (oldSteps > newSteps) {
                for (let n = newSteps; n < oldSteps; n++)
                    this.ds.deleteRow(row + newSteps - 1);
            }
            else if (newSteps > oldSteps) {
                for (let n = oldSteps; n < newSteps; n++)
                    this.ds.insertRow(row + oldSteps);
            }
            this.ds.setString(row, Experiment.COLNAME_EXPERIMENT_TITLE, entry.title);
            this.ds.setReal(row, Experiment.COLNAME_EXPERIMENT_CREATEDATE, entry.createDate == null ? null : entry.createDate.getTime() * 1E-3);
            this.ds.setReal(row, Experiment.COLNAME_EXPERIMENT_MODIFYDATE, entry.modifyDate == null ? null : entry.modifyDate.getTime() * 1E-3);
            this.ds.setString(row, Experiment.COLNAME_EXPERIMENT_DOI, entry.doi);
            this.ds.setString(row, Experiment.COLNAME_EXPERIMENT_META, entry.meta);
            for (let s = 0; s < entry.steps.length; s++) {
                let r = row + s, step = entry.steps[s];
                if (s == 0)
                    for (let n = 0; n < step.reactants.length; n++) {
                        let comp = step.reactants[n], i = n + 1;
                        this.ds.setMolecule(r, `${Experiment.COLNAME_REACTANT_MOL}${i}`, comp.mol);
                        this.ds.setString(r, `${Experiment.COLNAME_REACTANT_NAME}${i}`, comp.name);
                        this.ds.setString(r, `${Experiment.COLNAME_REACTANT_STOICH}${i}`, comp.stoich);
                        this.ds.setReal(r, `${Experiment.COLNAME_REACTANT_MASS}${i}`, comp.mass);
                        this.ds.setReal(r, `${Experiment.COLNAME_REACTANT_VOLUME}${i}`, comp.volume);
                        this.ds.setReal(r, `${Experiment.COLNAME_REACTANT_MOLES}${i}`, comp.moles);
                        this.ds.setReal(r, `${Experiment.COLNAME_REACTANT_DENSITY}${i}`, comp.density);
                        this.ds.setReal(r, `${Experiment.COLNAME_REACTANT_CONC}${i}`, comp.conc);
                        this.ds.setBoolean(r, `${Experiment.COLNAME_REACTANT_PRIMARY}${i}`, comp.primary);
                        this.ds.setString(r, `${Experiment.COLNAME_REACTANT_META}${i}`, comp.meta);
                    }
                for (let n = 0; n < step.reagents.length; n++) {
                    let comp = step.reagents[n], i = n + 1;
                    this.ds.setMolecule(r, `${Experiment.COLNAME_REAGENT_MOL}${i}`, comp.mol);
                    this.ds.setString(r, `${Experiment.COLNAME_REAGENT_NAME}${i}`, comp.name);
                    this.ds.setReal(r, `${Experiment.COLNAME_REAGENT_EQUIV}${i}`, comp.equiv);
                    this.ds.setReal(r, `${Experiment.COLNAME_REAGENT_MASS}${i}`, comp.mass);
                    this.ds.setReal(r, `${Experiment.COLNAME_REAGENT_VOLUME}${i}`, comp.volume);
                    this.ds.setReal(r, `${Experiment.COLNAME_REAGENT_MOLES}${i}`, comp.moles);
                    this.ds.setReal(r, `${Experiment.COLNAME_REAGENT_DENSITY}${i}`, comp.density);
                    this.ds.setReal(r, `${Experiment.COLNAME_REAGENT_CONC}${i}`, comp.conc);
                    this.ds.setString(r, `${Experiment.COLNAME_REAGENT_META}${i}`, comp.meta);
                }
                for (let n = 0; n < step.products.length; n++) {
                    let comp = step.products[n], i = n + 1;
                    this.ds.setMolecule(r, `${Experiment.COLNAME_PRODUCT_MOL}${i}`, comp.mol);
                    this.ds.setString(r, `${Experiment.COLNAME_PRODUCT_NAME}${i}`, comp.name);
                    this.ds.setString(r, `${Experiment.COLNAME_PRODUCT_STOICH}${i}`, comp.stoich);
                    this.ds.setReal(r, `${Experiment.COLNAME_PRODUCT_MASS}${i}`, comp.mass);
                    this.ds.setReal(r, `${Experiment.COLNAME_PRODUCT_VOLUME}${i}`, comp.volume);
                    this.ds.setReal(r, `${Experiment.COLNAME_PRODUCT_MOLES}${i}`, comp.moles);
                    this.ds.setReal(r, `${Experiment.COLNAME_PRODUCT_DENSITY}${i}`, comp.density);
                    this.ds.setReal(r, `${Experiment.COLNAME_PRODUCT_CONC}${i}`, comp.conc);
                    this.ds.setReal(r, `${Experiment.COLNAME_PRODUCT_YIELD}${i}`, comp.yield);
                    this.ds.setBoolean(r, `${Experiment.COLNAME_PRODUCT_WASTE}${i}`, comp.waste);
                    this.ds.setString(r, `${Experiment.COLNAME_PRODUCT_META}${i}`, comp.meta);
                }
                this.ds.setString(r, Experiment.COLNAME_STEP_META, step.meta);
            }
            for (let s = 0; s < entry.steps.length; s++) {
                let r = row + s;
                let start = s > 0 ? 0 : entry.steps[s].reactants.length;
                for (let n = start; n < nreactants; n++) {
                    let i = n + 1;
                    this.ds.setToNull(r, `${Experiment.COLNAME_REACTANT_MOL}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REACTANT_NAME}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REACTANT_STOICH}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REACTANT_MASS}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REACTANT_VOLUME}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REACTANT_MOLES}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REACTANT_DENSITY}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REACTANT_CONC}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REACTANT_PRIMARY}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REACTANT_META}${i}`);
                }
                for (let n = entry.steps[s].reagents.length; n < nreagents; n++) {
                    let i = n + 1;
                    this.ds.setToNull(r, `${Experiment.COLNAME_REAGENT_MOL}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REAGENT_NAME}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REAGENT_EQUIV}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REAGENT_MASS}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REAGENT_VOLUME}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REAGENT_MOLES}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REAGENT_DENSITY}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REAGENT_CONC}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_REAGENT_META}${i}`);
                }
                for (let n = entry.steps[s].products.length; n < nproducts; n++) {
                    let i = n + 1;
                    this.ds.setToNull(r, `${Experiment.COLNAME_PRODUCT_MOL}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_PRODUCT_NAME}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_PRODUCT_STOICH}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_PRODUCT_MASS}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_PRODUCT_VOLUME}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_PRODUCT_MOLES}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_PRODUCT_DENSITY}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_PRODUCT_CONC}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_PRODUCT_WASTE}${i}`);
                    this.ds.setToNull(r, `${Experiment.COLNAME_PRODUCT_META}${i}`);
                }
            }
        }
        plainHeading() { return Experiment.NAME; }
        rowFirstBlock(row) { return this.isFirstStep(row); }
        rowBlockCount(row) { return this.numberOfSteps(row); }
        initiateNewRow(row) {
            let curTime = new Date().getTime() * 1E-3;
            this.ds.setReal(row, Experiment.COLNAME_EXPERIMENT_CREATEDATE, curTime);
        }
        columnEffectivelyBlank(row) {
            return [Experiment.COLNAME_EXPERIMENT_CREATEDATE];
        }
        isColumnReserved(colName) {
            return this.areColumnsReserved([colName])[0];
        }
        areColumnsReserved(colNames) {
            let resv = WebMolKit.Vec.booleanArray(false, colNames.length);
            for (let n = 0; n < colNames.length; n++) {
                let name = colNames[n];
                if (Experiment.ALL_COLUMN_LITERALS.indexOf(name) >= 0) {
                    resv[n] = true;
                    continue;
                }
                for (let pfx of Experiment.ALL_COLUMN_PREFIXES)
                    if (name.startsWith(pfx)) {
                        resv[n] = true;
                        break;
                    }
            }
            return resv;
        }
        numGraphicRenderings(row) { return 1; }
        produceGraphicRendering(row, idx, policy) {
            let measure = new WebMolKit.OutlineMeasurement(0, 0, policy.data.pointScale);
            let layout = new WebMolKit.ArrangeExperiment(this.getEntry(row), measure, policy);
            layout.limitTotalW = 50 * policy.data.pointScale;
            layout.limitTotalH = 50 * policy.data.pointScale;
            layout.includeStoich = true;
            layout.includeAnnot = false;
            layout.arrange();
            let metavec = new WebMolKit.MetaVector();
            new WebMolKit.DrawExperiment(layout, metavec).draw();
            metavec.normalise();
            return { 'name': 'Scheme', 'metavec': metavec };
        }
    }
    Experiment.CODE = 'org.mmi.aspect.Experiment';
    Experiment.CODE_RXN = 'org.mmi.aspect.Reaction';
    Experiment.CODE_YLD = 'org.mmi.aspect.Yield';
    Experiment.NAME = 'Experiment';
    Experiment.NAME_RXN = 'Reaction';
    Experiment.NAME_YLD = 'Yield';
    Experiment.COLNAME_EXPERIMENT_TITLE = 'ExperimentTitle';
    Experiment.COLNAME_EXPERIMENT_CREATEDATE = 'ExperimentCreateDate';
    Experiment.COLNAME_EXPERIMENT_MODIFYDATE = 'ExperimentModifyDate';
    Experiment.COLNAME_EXPERIMENT_DOI = 'ExperimentDOI';
    Experiment.COLNAME_EXPERIMENT_META = 'ExperimentMeta';
    Experiment.COLNAME_STEP_META = 'ExperimentStepMeta';
    Experiment.COLNAME_REACTANT_MOL = 'ReactantMol';
    Experiment.COLNAME_REACTANT_NAME = 'ReactantName';
    Experiment.COLNAME_REACTANT_STOICH = 'ReactantStoich';
    Experiment.COLNAME_REACTANT_MASS = 'ReactantMass';
    Experiment.COLNAME_REACTANT_VOLUME = 'ReactantVolume';
    Experiment.COLNAME_REACTANT_MOLES = 'ReactantMoles';
    Experiment.COLNAME_REACTANT_DENSITY = 'ReactantDensity';
    Experiment.COLNAME_REACTANT_CONC = 'ReactantConc';
    Experiment.COLNAME_REACTANT_PRIMARY = 'ReactantPrimary';
    Experiment.COLNAME_REACTANT_META = 'ReactantMeta';
    Experiment.COLNAME_REAGENT_MOL = 'ReagentMol';
    Experiment.COLNAME_REAGENT_NAME = 'ReagentName';
    Experiment.COLNAME_REAGENT_EQUIV = 'ReagentEquiv';
    Experiment.COLNAME_REAGENT_MASS = 'ReagentMass';
    Experiment.COLNAME_REAGENT_VOLUME = 'ReagentVolume';
    Experiment.COLNAME_REAGENT_MOLES = 'ReagentMoles';
    Experiment.COLNAME_REAGENT_DENSITY = 'ReagentDensity';
    Experiment.COLNAME_REAGENT_CONC = 'ReagentConc';
    Experiment.COLNAME_REAGENT_META = 'ReagentMeta';
    Experiment.COLNAME_PRODUCT_MOL = 'ProductMol';
    Experiment.COLNAME_PRODUCT_NAME = 'ProductName';
    Experiment.COLNAME_PRODUCT_STOICH = 'ProductStoich';
    Experiment.COLNAME_PRODUCT_MASS = 'ProductMass';
    Experiment.COLNAME_PRODUCT_VOLUME = 'ProductVolume';
    Experiment.COLNAME_PRODUCT_MOLES = 'ProductMoles';
    Experiment.COLNAME_PRODUCT_DENSITY = 'ProductDensity';
    Experiment.COLNAME_PRODUCT_CONC = 'ProductConc';
    Experiment.COLNAME_PRODUCT_YIELD = 'ProductYield';
    Experiment.COLNAME_PRODUCT_WASTE = 'ProductWaste';
    Experiment.COLNAME_PRODUCT_META = 'ProductMeta';
    Experiment.COLUMN_DESCRIPTIONS = {};
    Experiment.ALL_COLUMN_LITERALS = [
        Experiment.COLNAME_EXPERIMENT_TITLE,
        Experiment.COLNAME_EXPERIMENT_CREATEDATE,
        Experiment.COLNAME_EXPERIMENT_MODIFYDATE,
        Experiment.COLNAME_EXPERIMENT_DOI,
        Experiment.COLNAME_EXPERIMENT_META,
        Experiment.COLNAME_STEP_META,
    ];
    Experiment.ALL_COLUMN_PREFIXES = [
        Experiment.COLNAME_REACTANT_MOL,
        Experiment.COLNAME_REACTANT_NAME,
        Experiment.COLNAME_REACTANT_STOICH,
        Experiment.COLNAME_REACTANT_MASS,
        Experiment.COLNAME_REACTANT_VOLUME,
        Experiment.COLNAME_REACTANT_MOLES,
        Experiment.COLNAME_REACTANT_DENSITY,
        Experiment.COLNAME_REACTANT_CONC,
        Experiment.COLNAME_REACTANT_PRIMARY,
        Experiment.COLNAME_REACTANT_META,
        Experiment.COLNAME_REAGENT_MOL,
        Experiment.COLNAME_REAGENT_NAME,
        Experiment.COLNAME_REAGENT_EQUIV,
        Experiment.COLNAME_REAGENT_MASS,
        Experiment.COLNAME_REAGENT_VOLUME,
        Experiment.COLNAME_REAGENT_MOLES,
        Experiment.COLNAME_REAGENT_DENSITY,
        Experiment.COLNAME_REAGENT_CONC,
        Experiment.COLNAME_REAGENT_META,
        Experiment.COLNAME_PRODUCT_MOL,
        Experiment.COLNAME_PRODUCT_NAME,
        Experiment.COLNAME_PRODUCT_STOICH,
        Experiment.COLNAME_PRODUCT_MASS,
        Experiment.COLNAME_PRODUCT_VOLUME,
        Experiment.COLNAME_PRODUCT_MOLES,
        Experiment.COLNAME_PRODUCT_DENSITY,
        Experiment.COLNAME_PRODUCT_CONC,
        Experiment.COLNAME_PRODUCT_YIELD,
        Experiment.COLNAME_PRODUCT_WASTE,
        Experiment.COLNAME_PRODUCT_META,
    ];
    WebMolKit.Experiment = Experiment;
    WebMolKit.registerAspect(Experiment);
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class MeasurementData extends WebMolKit.Aspect {
        constructor(ds, allowModify) {
            super(MeasurementData.CODE, ds, allowModify);
            this.header = { 'units': [], 'fields': [] };
            this.setup();
        }
        static isMeasurementData(ds) {
            for (let n = 0; n < ds.numExtensions; n++)
                if (ds.getExtType(n) == MeasurementData.CODE)
                    return true;
            return false;
        }
        getHeader() {
            return this.header;
        }
        setHeader(header) {
            this.header = header;
            let content = this.formatMetaData(header);
            for (let n = 0; n < this.ds.numExtensions; n++)
                if (this.ds.getExtType(n) == MeasurementData.CODE) {
                    this.ds.setExtData(n, content);
                    return;
                }
            this.ds.appendExtension(MeasurementData.NAME, MeasurementData.CODE, content);
        }
        effectHeader(header) {
            this.setHeader(header);
            this.ensureFields();
        }
        rename(fldidx, newName) {
            let oldName = this.header.fields[fldidx].name;
            if (oldName == newName)
                return;
            this.header.fields[fldidx].name = newName;
            this.setHeader(this.header);
            for (let sfx of [MeasurementData.SUFFIX_VALUE, MeasurementData.SUFFIX_ERROR, MeasurementData.SUFFIX_UNITS, MeasurementData.SUFFIX_MOD]) {
                let col = this.ds.findColByName(oldName + sfx);
                if (col >= 0)
                    this.ds.changeColumnName(col, newName + sfx, this.ds.colDescr(col));
            }
        }
        reservedColumns(fldidx) {
            let fieldName = this.header.fields[fldidx].name;
            return [fieldName + MeasurementData.SUFFIX_VALUE, fieldName + MeasurementData.SUFFIX_ERROR,
                fieldName + MeasurementData.SUFFIX_UNITS, fieldName + MeasurementData.SUFFIX_MOD];
        }
        getValue(row, fldidx) {
            return this.getValueField(row, this.header.fields[fldidx]);
        }
        getValueField(row, field) {
            let value = { 'value': Number.NaN, 'error': Number.NaN, 'units': '', 'mod': '' };
            let colValue = this.ds.findColByName(field.name + MeasurementData.SUFFIX_VALUE, "real");
            let colError = this.ds.findColByName(field.name + MeasurementData.SUFFIX_ERROR, "real");
            let colUnits = this.ds.findColByName(field.name + MeasurementData.SUFFIX_UNITS, "string");
            let colMod = this.ds.findColByName(field.name + MeasurementData.SUFFIX_MOD, "string");
            if (colValue >= 0 && this.ds.notNull(row, colValue))
                value.value = this.ds.getReal(row, colValue);
            if (colError >= 0 && this.ds.notNull(row, colError))
                value.error = this.ds.getReal(row, colError);
            if (colUnits >= 0)
                value.units = this.ds.getString(row, colUnits);
            if (colMod >= 0)
                value.mod = this.ds.getString(row, colMod);
            return value;
        }
        setValue(row, fldidx, value) {
            let fieldName = this.header.fields[fldidx].name;
            let colValue = this.ds.findColByName(fieldName + MeasurementData.SUFFIX_VALUE, "real");
            let colError = this.ds.findColByName(fieldName + MeasurementData.SUFFIX_ERROR, "real");
            let colUnits = this.ds.findColByName(fieldName + MeasurementData.SUFFIX_UNITS, "string");
            let colMod = this.ds.findColByName(fieldName + MeasurementData.SUFFIX_MOD, "string");
            if (colValue >= 0)
                if (isNaN(value.value))
                    this.ds.setToNull(row, colValue);
                else
                    this.ds.setReal(row, colValue, value.value);
            if (colError >= 0)
                if (isNaN(value.error))
                    this.ds.setToNull(row, colError);
                else
                    this.ds.setReal(row, colError, value.error);
            if (colUnits >= 0)
                this.ds.setString(row, colUnits, value.units);
            if (colMod >= 0)
                this.ds.setString(row, colMod, value.mod);
        }
        clearValue(row, fldidx) {
            let fieldName = this.header.fields[fldidx].name;
            let colValue = this.ds.findColByName(fieldName + MeasurementData.SUFFIX_VALUE, "real");
            let colError = this.ds.findColByName(fieldName + MeasurementData.SUFFIX_ERROR, "real");
            let colUnits = this.ds.findColByName(fieldName + MeasurementData.SUFFIX_UNITS, "string");
            let colMod = this.ds.findColByName(fieldName + MeasurementData.SUFFIX_MOD, "string");
            if (colValue >= 0)
                this.ds.setToNull(row, colValue);
            if (colError >= 0)
                this.ds.setToNull(row, colError);
            if (colUnits >= 0)
                this.ds.setToNull(row, colUnits);
            if (colMod >= 0)
                this.ds.setToNull(row, colMod);
        }
        getDescr(row, fldidx) {
            let col = this.ds.findColByName(this.header.fields[fldidx].name);
            return col < 0 ? '' : this.ds.colDescr(col);
        }
        setDescr(row, fldidx, descr) {
            let col = this.ds.findColByName(this.header.fields[fldidx].name);
            if (col >= 0)
                this.ds.changeColumnName(col, this.ds.colName(col), descr);
        }
        setup() {
            this.parseAndCorrect();
        }
        parseAndCorrect() {
            this.header = { 'units': [], 'fields': [] };
            let got = false;
            for (let n = 0; n < this.ds.numExtensions; n++)
                if (this.ds.getExtType(n) == MeasurementData.CODE) {
                    this.header = this.parseMetaData(this.ds.getExtData(n));
                    got = true;
                    break;
                }
            this.ensureFields();
            if (!got && this.allowModify) {
                let content = this.formatMetaData(this.header);
                this.ds.appendExtension(MeasurementData.NAME, MeasurementData.CODE, content);
            }
        }
        ensureFields() {
            for (let f of this.header.fields) {
                let descr = 'Measurement';
                let colidx = this.ds.findColByName(f.name);
                if (colidx >= 0)
                    descr = this.ds.colDescr(colidx);
                if (this.allowModify) {
                    this.ds.ensureColumn(f.name + MeasurementData.SUFFIX_VALUE, "real", descr);
                    this.ds.ensureColumn(f.name + MeasurementData.SUFFIX_ERROR, "real", 'Error');
                    this.ds.ensureColumn(f.name + MeasurementData.SUFFIX_UNITS, "string", 'Units');
                    this.ds.ensureColumn(f.name + MeasurementData.SUFFIX_MOD, "string", 'Modifier');
                }
            }
        }
        parseMetaData(content) {
            let header = { 'units': [], 'fields': [] };
            for (let line of content.split(/\r?\n/)) {
                let eq = line.indexOf('=');
                if (eq < 0)
                    continue;
                if (line.startsWith('unit=')) {
                    let bits = line.substring(eq + 1).split(',');
                    if (bits.length >= 2)
                        header.units.push({ 'name': WebMolKit.MoleculeStream.skUnescape(bits[0]), 'uri': WebMolKit.MoleculeStream.skUnescape(bits[1]) });
                }
                else if (line.startsWith('field=')) {
                    let bits = line.substring(eq + 1).split(',');
                    let f = { 'name': WebMolKit.MoleculeStream.skUnescape(bits[0]), 'units': [], 'defnURI': [] };
                    for (let n = 1; n < bits.length; n++)
                        f.units.push(WebMolKit.MoleculeStream.skUnescape(bits[n]));
                    header.fields.push(f);
                }
                else if (line.startsWith('definition=')) {
                    let bits = line.substring(eq + 1).split(',');
                    if (bits.length >= 2) {
                        let f = header.fields.find((f) => f.name == bits[0]);
                        if (!f)
                            continue;
                        for (let n = 1; n < bits.length; n++)
                            f.defnURI.push(WebMolKit.MoleculeStream.skUnescape(bits[n]));
                    }
                }
            }
            return header;
        }
        formatMetaData(header) {
            let lines = [];
            for (let u of header.units) {
                lines.push('unit=' + WebMolKit.MoleculeStream.skEscape(u.name) + ',' + WebMolKit.MoleculeStream.skEscape(u.uri));
            }
            for (let f of header.fields) {
                let line = 'field=' + WebMolKit.MoleculeStream.skEscape(f.name);
                for (let u of f.units)
                    line += ',' + WebMolKit.MoleculeStream.skEscape(u);
                lines.push(line);
                if (WebMolKit.Vec.notBlank(f.defnURI)) {
                    line = 'definition=' + WebMolKit.MoleculeStream.skEscape(f.name);
                    for (let d of f.defnURI)
                        line += ',' + WebMolKit.MoleculeStream.skEscape(d);
                    lines.push(line);
                }
            }
            return lines.join('\n');
        }
        plainHeading() { return MeasurementData.NAME; }
        isColumnReserved(colName) {
            return this.areColumnsReserved([colName])[0];
        }
        areColumnsReserved(colNames) {
            let names = new Set();
            for (let f of this.header.fields) {
                names.add(f.name + MeasurementData.SUFFIX_VALUE);
                names.add(f.name + MeasurementData.SUFFIX_ERROR);
                names.add(f.name + MeasurementData.SUFFIX_UNITS);
                names.add(f.name + MeasurementData.SUFFIX_MOD);
            }
            let resv = [];
            for (let col of colNames)
                resv.push(names.has(col));
            return resv;
        }
        numTextRenderings(row) { return this.header.fields.length; }
        produceTextRendering(row, idx) {
            let field = this.header.fields[idx];
            let colField = this.ds.findColByName(field.name);
            let tr = {
                'name': field.name,
                'descr': colField < 0 ? '' : this.ds.colDescr(colField),
                'text': '',
                'type': WebMolKit.Aspect.TEXT_PLAIN
            };
            let datum = this.getValue(row, idx);
            if (!Number.isNaN(datum.value)) {
                if (datum.mod)
                    tr.text += datum.mod + ' ';
                tr.text += datum.value;
                if (!Number.isNaN(datum.error))
                    tr.text += ' \u{00B1} ' + datum.error;
                if (datum.units)
                    tr.text += ' ' + datum.units;
            }
            return tr;
        }
    }
    MeasurementData.CODE = 'org.mmi.aspect.MeasurementData';
    MeasurementData.NAME = 'Measurement Data';
    MeasurementData.SUFFIX_VALUE = '';
    MeasurementData.SUFFIX_ERROR = '_error';
    MeasurementData.SUFFIX_UNITS = '_units';
    MeasurementData.SUFFIX_MOD = '_mod';
    WebMolKit.MeasurementData = MeasurementData;
    WebMolKit.registerAspect(MeasurementData);
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let MixtureAttributeType;
    (function (MixtureAttributeType) {
        MixtureAttributeType["Structure"] = "structure";
        MixtureAttributeType["Name"] = "name";
        MixtureAttributeType["Quantity"] = "quantity";
        MixtureAttributeType["Bound"] = "bound";
        MixtureAttributeType["Error"] = "error";
        MixtureAttributeType["Ratio"] = "ratio";
        MixtureAttributeType["Units"] = "units";
        MixtureAttributeType["Relation"] = "relation";
        MixtureAttributeType["Identifier"] = "identifier";
        MixtureAttributeType["Link"] = "link";
        MixtureAttributeType["Property"] = "property";
    })(MixtureAttributeType = WebMolKit.MixtureAttributeType || (WebMolKit.MixtureAttributeType = {}));
    class Mixture extends WebMolKit.Aspect {
        constructor(ds, allowModify) {
            super(Mixture.CODE, ds, allowModify);
            this.header = { 'attributes': [] };
            this.setup();
        }
        static isMixture(ds) {
            for (let n = 0; n < ds.numExtensions; n++)
                if (ds.getExtType(n) == Mixture.CODE)
                    return true;
            return false;
        }
        getHeader() {
            return this.header;
        }
        setHeader(header) {
            this.header = header;
            let content = this.formatMetaData(header);
            for (let n = 0; n < this.ds.numExtensions; n++)
                if (this.ds.getExtType(n) == Mixture.CODE) {
                    this.ds.setExtData(n, content);
                    return;
                }
            this.ds.appendExtension(Mixture.NAME, Mixture.CODE, content);
        }
        setup() {
            this.parseAndCorrect();
        }
        parseAndCorrect() {
            this.header = { 'attributes': [] };
            let got = false;
            for (let n = 0; n < this.ds.numExtensions; n++)
                if (this.ds.getExtType(n) == Mixture.CODE) {
                    this.header = this.parseMetaData(this.ds.getExtData(n));
                    got = true;
                    break;
                }
            if (!got && this.allowModify) {
                let content = this.formatMetaData(this.header);
                this.ds.appendExtension(Mixture.NAME, Mixture.CODE, content);
            }
        }
        parseMetaData(content) {
            let header = { 'attributes': [] };
            for (let line of content.split(/\r?\n/)) {
                let eq = line.indexOf('=');
                if (eq < 0)
                    continue;
                if (line.startsWith('attr=')) {
                    let bits = line.substring(eq + 1).split(',');
                    if (bits.length < 3)
                        continue;
                    let column = WebMolKit.MoleculeStream.skUnescape(bits[0]);
                    let position = [];
                    if (bits[1] != '0')
                        position = bits[1].split('.').map((str) => parseInt(str));
                    let type = bits[2];
                    let info = [];
                    for (let n = 3; n < bits.length; n++)
                        info.push(WebMolKit.MoleculeStream.skUnescape(bits[n]));
                    header.attributes.push({ column, position, type, info });
                }
            }
            return header;
        }
        formatMetaData(header) {
            let lines = [];
            for (let a of header.attributes) {
                let bits = [WebMolKit.MoleculeStream.skEscape(a.column)];
                if (WebMolKit.Vec.isBlank(a.position))
                    bits.push('0');
                else
                    bits.push(a.position.join('.'));
                bits.push(a.type);
                if (a.info)
                    for (let str of a.info)
                        bits.push(WebMolKit.MoleculeStream.skEscape(str));
                lines.push('attr=' + bits.join(','));
            }
            return lines.join('\n');
        }
        plainHeading() { return WebMolKit.MeasurementData.NAME; }
        isColumnReserved(colName) {
            return this.areColumnsReserved([colName])[0];
        }
        areColumnsReserved(colNames) {
            let names = new Set();
            for (let a of this.header.attributes)
                names.add(a.column);
            let resv = [];
            for (let col of colNames)
                resv.push(names.has(col));
            return resv;
        }
    }
    Mixture.CODE = 'org.mmi.aspect.Mixture';
    Mixture.NAME = 'Mixture';
    Mixture.SUFFIX_VALUE = '';
    WebMolKit.Mixture = Mixture;
    WebMolKit.registerAspect(Mixture);
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class SARTable extends WebMolKit.Aspect {
        constructor(ds, allowModify) {
            super(SARTable.CODE, ds, allowModify);
            this.setup();
        }
        static isSARTable(ds) {
            for (let n = 0; n < ds.numExtensions; n++)
                if (ds.getExtType(n) == SARTable.CODE)
                    return true;
            return false;
        }
        getFields() {
            for (let n = 0; n < this.ds.numExtensions; n++)
                if (this.ds.getExtType(n) == SARTable.CODE)
                    return this.parseMetaData(this.ds.getExtData(n));
            return null;
        }
        setFields(fields) {
            let content = this.formatMetaData(fields);
            for (let n = 0; n < this.ds.numExtensions; n++)
                if (this.ds.getExtType(n) == SARTable.CODE) {
                    this.ds.setExtData(n, content);
                    return;
                }
            this.ds.appendExtension(SARTable.NAME, SARTable.CODE, content);
        }
        getEntry(row) {
            let fields = this.getFields();
            let entry = {
                'construct': this.ds.getMolecule(row, fields.construct),
                'locked': !!this.ds.getBoolean(row, fields.locked),
                'scaffold': this.ds.getMolecule(row, fields.scaffold),
                'substNames': [],
                'substituents': []
            };
            for (let subst of fields.substituents) {
                entry.substNames.push(subst);
                entry.substituents.push(this.ds.getMolecule(row, subst));
            }
            return entry;
        }
        setEntry(row, entry) {
            let fields = this.getFields();
            let colConstruct = this.ds.findColByName(fields.construct, "molecule");
            if (colConstruct >= 0)
                this.ds.setMolecule(row, colConstruct, entry.construct);
            let colLocked = this.ds.findColByName(fields.locked, "boolean");
            if (colLocked >= 0)
                this.ds.setBoolean(row, colLocked, entry.locked);
            let colScaffold = this.ds.findColByName(fields.scaffold, "molecule");
            if (colScaffold >= 0)
                this.ds.setMolecule(row, colScaffold, entry.scaffold);
            for (let n = 0; n < fields.substituents.length; n++) {
                let colSubst = this.ds.findColByName(fields.substituents[n], "molecule");
                if (colSubst >= 0)
                    this.ds.setMolecule(row, colSubst, entry.substituents[n]);
            }
        }
        createSubstituents(tobeAdded) {
            if (tobeAdded.length == 0)
                return;
            let fields = this.getFields();
            let modified = false;
            for (let name of tobeAdded)
                if (fields.substituents.indexOf(name) < 0) {
                    fields.substituents.push(name);
                    this.ds.ensureColumn(name, "molecule", SARTable.DESCR_SUBSTITUENT);
                    modified = true;
                }
            if (modified)
                this.setFields(fields);
        }
        static isAttachment(mol, atom) {
            return mol.atomicNumber(atom) == 0 && !WebMolKit.MolUtil.hasAbbrev(mol, atom) && mol.atomAdjCount(atom) == 1;
        }
        setup() {
            this.parseAndCorrect();
        }
        parseAndCorrect() {
            let fields = {
                'construct': 'Molecule',
                'locked': 'Molecule_locked',
                'scaffold': 'Scaffold',
                'substituents': [],
                'metadata': []
            };
            let got = false;
            for (let n = 0; n < this.ds.numExtensions; n++)
                if (this.ds.getExtType(n) == SARTable.CODE) {
                    fields = this.parseMetaData(this.ds.getExtData(n));
                    got = true;
                    break;
                }
            this.ds.ensureColumn(fields.construct, "molecule", SARTable.DESCR_CONSTRUCT);
            this.ds.ensureColumn(fields.locked, "boolean", SARTable.DESCR_LOCKED);
            this.ds.ensureColumn(fields.scaffold, "molecule", SARTable.DESCR_SCAFFOLD);
            for (let subst of fields.substituents)
                this.ds.ensureColumn(subst, "molecule", SARTable.DESCR_SUBSTITUENT);
            if (!got) {
                let content = this.formatMetaData(fields);
                this.ds.appendExtension(SARTable.NAME, SARTable.CODE, content);
            }
        }
        parseMetaData(content) {
            let fields = { 'construct': null, 'locked': null, 'scaffold': null, 'substituents': [], 'metadata': [] };
            for (let line of content.split(/\r?\n/)) {
                let pos = line.indexOf('=');
                if (pos < 0)
                    continue;
                let key = line.substring(0, pos), val = line.substring(pos + 1);
                if (key == 'field') {
                    let bits = val.split(',');
                    if (bits.length >= 3) {
                        let type = bits[0], name = WebMolKit.MoleculeStream.skUnescape(bits[1]);
                        if (type == 'construct') {
                            fields.construct = name;
                            fields.locked = name + '_locked';
                            continue;
                        }
                        else if (type == 'scaffold') {
                            fields.scaffold = name;
                            continue;
                        }
                        else if (type == 'substituent') {
                            fields.substituents.push(name);
                            continue;
                        }
                    }
                }
                fields.metadata.push(line);
            }
            return fields;
        }
        formatMetaData(fields) {
            let content = '';
            content += 'field=construct,' + WebMolKit.MoleculeStream.skEscape(fields.construct) + ',\n';
            content += 'field=scaffold,' + WebMolKit.MoleculeStream.skEscape(fields.scaffold) + ',\n';
            for (let subst of fields.substituents)
                content += 'field=substituent,' + WebMolKit.MoleculeStream.skEscape(subst) + ',\n';
            for (let meta of fields.metadata)
                content += meta + '\n';
            return content;
        }
        plainHeading() { return SARTable.NAME; }
        isColumnReserved(colName) {
            return this.areColumnsReserved([colName])[0];
        }
        areColumnsReserved(colNames) {
            let fields = this.getFields();
            let used = new Set();
            used.add(fields.construct);
            used.add(fields.locked);
            used.add(fields.scaffold);
            for (let subst of fields.substituents)
                used.add(subst);
            let reserved = WebMolKit.Vec.booleanArray(false, colNames.length);
            for (let n = 0; n < colNames.length; n++)
                reserved[n] = used.has(colNames[n]);
            return reserved;
        }
        numGraphicRenderings(row) {
            let fields = this.getFields();
            return 2 + fields.substituents.length;
        }
        produceGraphicRendering(row, idx, policy) {
            let fields = this.getFields(), ds = this.ds;
            if (idx == SARTable.RENDER_CONSTRUCT) {
                let mol = ds.getMolecule(row, fields.construct);
                let metavec = new WebMolKit.MetaVector();
                if (WebMolKit.MolUtil.notBlank(mol)) {
                    let effects = new WebMolKit.RenderEffects();
                    for (let n = 1; n <= mol.numAtoms; n++)
                        if (mol.atomMapNum(n) > 0)
                            effects.colAtom[n] = 0x096E6F;
                    for (let n = 1; n <= mol.numBonds; n++) {
                        let m1 = mol.atomMapNum(mol.bondFrom(n)), m2 = mol.atomMapNum(mol.bondTo(n));
                        if (m1 > 0 && m2 > 0)
                            effects.colBond[n] = 0x096E6F;
                        else if (m1 > 0 || m2 > 0)
                            effects.dottedBondCross[n] = 0x606060;
                    }
                    let measure = new WebMolKit.OutlineMeasurement(0, 0, policy.data.pointScale);
                    let layout = new WebMolKit.ArrangeMolecule(mol, measure, policy, effects);
                    layout.arrange();
                    new WebMolKit.DrawMolecule(layout, metavec).draw();
                }
                else
                    metavec.drawText(0, 0, '?', 15, 0x000000);
                metavec.normalise();
                return { 'name': fields.construct, 'metavec': metavec };
            }
            else if (idx == SARTable.RENDER_SCAFFOLD) {
                let mol = ds.getMolecule(row, fields.scaffold);
                let metavec = new WebMolKit.MetaVector();
                if (WebMolKit.MolUtil.notBlank(mol)) {
                    let effects = new WebMolKit.RenderEffects();
                    for (let n = 1; n <= mol.numAtoms; n++)
                        if (SARTable.isAttachment(mol, n)) {
                            let isDefined = false;
                            let el = mol.atomElement(n);
                            outer: for (let colName of fields.substituents) {
                                let subst = ds.getMolecule(row, colName);
                                if (subst != null)
                                    for (let i = 1; i <= subst.numAtoms; i++)
                                        if (subst.atomElement(i) == el || (subst.atomElement(i) == 'R' && el == colName)) {
                                            isDefined = true;
                                            break outer;
                                        }
                            }
                            effects.colAtom[n] = isDefined ? 0x096E6F : 0xFF0000;
                            effects.dottedRectOutline[n] = isDefined ? 0x808080 : 0xFF0000;
                        }
                    let measure = new WebMolKit.OutlineMeasurement(0, 0, policy.data.pointScale);
                    let layout = new WebMolKit.ArrangeMolecule(mol, measure, policy, effects);
                    layout.arrange();
                    new WebMolKit.DrawMolecule(layout, metavec).draw();
                }
                else
                    metavec.drawText(0, 0, '?', 15, 0x000000);
                metavec.normalise();
                return { 'name': fields.scaffold, 'metavec': metavec };
            }
            else if (idx >= SARTable.RENDER_SUBSTITUENT && idx < SARTable.RENDER_SUBSTITUENT + fields.substituents.length) {
                let sidx = idx - SARTable.RENDER_SUBSTITUENT, sname = fields.substituents[sidx];
                let mol = ds.getMolecule(row, sname);
                let metavec = new WebMolKit.MetaVector();
                if (WebMolKit.MolUtil.notBlank(mol)) {
                    let effects = new WebMolKit.RenderEffects();
                    for (let n = 1; n <= mol.numAtoms; n++)
                        if (SARTable.isAttachment(mol, n)) {
                            effects.colAtom[n] = 0x096E6F;
                            effects.dottedRectOutline[n] = 0x808080;
                        }
                    let measure = new WebMolKit.OutlineMeasurement(0, 0, policy.data.pointScale);
                    let layout = new WebMolKit.ArrangeMolecule(mol, measure, policy, effects);
                    layout.arrange();
                    new WebMolKit.DrawMolecule(layout, metavec).draw();
                }
                else {
                    let txt = '?';
                    let scaff = ds.getMolecule(row, fields.scaffold);
                    if (WebMolKit.MolUtil.notBlank(scaff)) {
                        txt = 'n/a';
                        for (let n = 1; n <= scaff.numAtoms; n++)
                            if (scaff.atomElement(n) == sname) {
                                txt = '?';
                                break;
                            }
                        if (txt == '?')
                            for (let n = 0; n < fields.substituents.length; n++)
                                if (n != sidx) {
                                    let subst = ds.getMolecule(row, fields.substituents[n]);
                                    if (WebMolKit.MolUtil.notBlank(subst)) {
                                        for (let i = 1; i <= subst.numAtoms; i++)
                                            if (subst.atomElement(i) == sname) {
                                                txt = 'n/a';
                                                break;
                                            }
                                    }
                                }
                    }
                    metavec.drawText(0, 0, txt, 15, 0x000000);
                }
                metavec.normalise();
                return { 'name': sname, 'metavec': metavec };
            }
            return null;
        }
    }
    SARTable.CODE = 'org.mmi.aspect.SARTable';
    SARTable.NAME = 'SAR Table';
    SARTable.DESCR_CONSTRUCT = 'Structure of constructed molecule';
    SARTable.DESCR_LOCKED = 'Whether constructed molecule should be rebuilt';
    SARTable.DESCR_SCAFFOLD = 'Decorated core scaffold of molecule';
    SARTable.DESCR_SUBSTITUENT = 'Substituent fragment to be attached to scaffold';
    SARTable.RENDER_CONSTRUCT = 0;
    SARTable.RENDER_SCAFFOLD = 1;
    SARTable.RENDER_SUBSTITUENT = 2;
    WebMolKit.SARTable = SARTable;
    WebMolKit.registerAspect(SARTable);
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class BayesianModel {
        constructor(classType, folding) {
            this.classType = classType;
            this.folding = folding;
            this.numActive = 0;
            this.inHash = {};
            this.training = [];
            this.activity = [];
            this.contribs = {};
            this.lowThresh = 0;
            this.highThresh = 0;
            this.range = 0;
            this.invRange = 0;
            this.estimates = null;
            this.rocX = null;
            this.rocY = null;
            this.rocType = null;
            this.rocAUC = Number.NaN;
            this.trainingSize = 0;
            this.trainingActives = 0;
            this.atomicSlopeA = Number.NaN;
            this.atomicInterceptB = Number.NaN;
            this.truthTP = 0;
            this.truthFP = 0;
            this.truthTN = 0;
            this.truthFN = 0;
            this.precision = Number.NaN;
            this.recall = Number.NaN;
            this.specificity = Number.NaN;
            this.statF1 = Number.NaN;
            this.statKappa = Number.NaN;
            this.statMCC = Number.NaN;
            this.noteTitle = null;
            this.noteOrigin = null;
            this.noteField = null;
            this.noteComments = null;
            if (this.folding == null)
                this.folding = 0;
        }
        addMolecule(mol, active, hashes) {
            if (WebMolKit.MolUtil.isBlank(mol) && hashes == null)
                throw 'Molecule cannot be blank or null.';
            if (hashes == null) {
                let meta = WebMolKit.MetaMolecule.createStrictRubric(mol);
                let circ = new WebMolKit.CircularFingerprints(meta, this.classType);
                circ.calculate();
                hashes = this.folding == 0 ? circ.getUniqueHashes() : circ.getFoldedHashes(this.folding);
            }
            if (active)
                this.numActive++;
            this.training.push(hashes);
            this.activity.push(active);
            for (let h of hashes) {
                let stash = this.inHash[h];
                if (stash == null)
                    stash = [0, 0];
                if (active)
                    stash[0]++;
                stash[1]++;
                this.inHash[h] = stash;
            }
        }
        build() {
            this.trainingSize = this.training.length;
            this.trainingActives = this.numActive;
            this.contribs = [];
            const sz = this.training.length;
            const invSz = 1.0 / sz;
            const P_AT = this.numActive * invSz;
            for (let hashStr in this.inHash) {
                let hash = parseInt(hashStr);
                const AT = this.inHash[hash];
                const A = AT[0], T = AT[1];
                const Pcorr = (A + 1) / (T * P_AT + 1);
                const P = Math.log(Pcorr);
                this.contribs[hash] = P;
            }
            this.lowThresh = Number.POSITIVE_INFINITY;
            this.highThresh = Number.NEGATIVE_INFINITY;
            for (let fp of this.training) {
                let val = 0;
                for (let hash of fp)
                    val += this.contribs[hash];
                this.lowThresh = Math.min(this.lowThresh, val);
                this.highThresh = Math.max(this.highThresh, val);
            }
            this.range = this.highThresh - this.lowThresh;
            this.invRange = this.range > 0 ? 1 / this.range : 0;
        }
        predictMolecule(mol) {
            if (WebMolKit.MolUtil.isBlank(mol))
                throw 'Molecule cannot be blank or null.';
            let meta = WebMolKit.MetaMolecule.createStrictRubric(mol);
            let circ = new WebMolKit.CircularFingerprints(meta, this.classType);
            circ.calculate();
            let hashes = this.folding == 0 ? circ.getUniqueHashes() : circ.getFoldedHashes(this.folding);
            return this.predictFP(hashes);
        }
        predictFP(hashes) {
            let val = 0;
            for (let h of hashes) {
                let c = this.contribs[h];
                if (c != null)
                    val += c;
            }
            return val;
        }
        scalePredictor(pred) {
            if (this.range == 0)
                return pred >= this.highThresh ? 1 : 0;
            return (pred - this.lowThresh) * this.invRange;
        }
        scaleArcTan(scaled) {
            const INVPI = 1.0 / Math.PI;
            return Math.atan(2 * scaled - 1) * INVPI + 0.5;
        }
        calculateOverlap(mol) {
            if (WebMolKit.MolUtil.isBlank(mol))
                throw 'Molecule cannot be blank or null.';
            let meta = WebMolKit.MetaMolecule.createStrictRubric(mol);
            let circ = new WebMolKit.CircularFingerprints(meta, this.classType);
            circ.calculate();
            let hashes = this.folding == 0 ? circ.getUniqueHashes() : circ.getFoldedHashes(this.folding);
            return this.calculateOverlapFP(hashes);
        }
        calculateOverlapFP(hashes) {
            if (hashes.length == 0)
                return 0;
            let count = 0.0;
            for (let h of hashes)
                if (this.contribs[h] != null)
                    count++;
            return hashes.length == 1 ? count : count / hashes.length;
        }
        calculateAtomPredictors(mol) {
            const na = mol.numAtoms;
            let atomic = WebMolKit.Vec.numberArray(0, na);
            let predHashes = new Set();
            let cover = this.determineCoverage(mol, predHashes);
            for (let h in cover) {
                let c = this.contribs[h];
                if (c == null)
                    continue;
                let mask = cover[h];
                let msz = WebMolKit.Vec.maskCount(mask);
                let invSz = 1.0 / msz;
                for (let n = 0; n < na; n++)
                    if (mask[n])
                        atomic[n] += c * invSz;
            }
            if (!isNaN(this.atomicSlopeA)) {
                for (let n = 0; n < na; n++)
                    atomic[n] = (this.atomicSlopeA * atomic[n]) + this.atomicInterceptB;
                return atomic;
            }
            let pred = 0;
            for (let h of predHashes) {
                let c = this.contribs[h];
                if (c != null)
                    pred += c;
            }
            const SCALE_STDDEV_TO = 0.25;
            const invN = 1.0 / na;
            WebMolKit.Vec.addTo(atomic, -WebMolKit.Vec.sum(atomic) * invN);
            let stdDev = 0;
            for (let a of atomic)
                stdDev += a * a;
            stdDev = Math.sqrt(stdDev * invN);
            if (stdDev > 1E-3)
                WebMolKit.Vec.mulBy(atomic, SCALE_STDDEV_TO / stdDev);
            let scaled = (this.scalePredictor(pred) - 0.5) * 2;
            if (scaled < -1)
                scaled = -1;
            else if (scaled > 1)
                scaled = 1;
            WebMolKit.Vec.addTo(atomic, scaled);
            return atomic;
        }
        validateLeaveOneOut() {
            const sz = this.training.length;
            this.estimates = [];
            for (let n = 0; n < sz; n++)
                this.estimates.push(this.singleLeaveOneOut(n));
            this.calculateROC();
            this.calculateTruth();
            this.rocType = 'leave-one-out';
        }
        validateFiveFold() {
            this.rocType = 'five-fold';
            this.validateNfold(5);
        }
        validateThreeFold() {
            this.rocType = 'three-fold';
            this.validateNfold(3);
        }
        clearTraining() {
            this.training = [];
            this.activity = [];
        }
        serialise() {
            let lines = [];
            let fpname = this.classType == WebMolKit.CircularFingerprints.CLASS_ECFP0 ? 'ECFP0' : this.classType == WebMolKit.CircularFingerprints.CLASS_ECFP2 ? 'ECFP2'
                : this.classType == WebMolKit.CircularFingerprints.CLASS_ECFP4 ? 'ECFP4' : this.classType == WebMolKit.CircularFingerprints.CLASS_ECFP6 ? 'ECFP6'
                    : '?';
            lines.push('Bayesian!(' + fpname + ',' + this.folding + ',' + this.lowThresh + ',' + this.highThresh + ')');
            let sorted = [];
            for (let hash in this.contribs)
                sorted.push(parseInt(hash));
            WebMolKit.Vec.sort(sorted);
            for (let hash of sorted) {
                const c = this.contribs[hash];
                lines.push(hash + '=' + c);
            }
            lines.push('training:size=' + this.trainingSize);
            lines.push('training:actives=' + this.trainingActives);
            if (!Number.isNaN(this.rocAUC))
                lines.push('roc:auc=' + this.rocAUC);
            if (this.rocType != null)
                lines.push('roc:type=' + this.rocType);
            if (this.rocX != null && this.rocY != null) {
                let x = 'roc:x=';
                for (let n = 0; n < this.rocX.length; n++)
                    x += (n == 0 ? '' : ',') + this.rocX[n];
                lines.push(x);
                let y = 'roc:y=';
                for (let n = 0; n < this.rocY.length; n++)
                    y += (n == 0 ? '' : ',') + this.rocY[n];
                lines.push(y);
            }
            if (this.truthTP > 0 || this.truthFP > 0 || this.truthTN > 0 || this.truthFP > 0) {
                lines.push('truth:TP=' + this.truthTP);
                lines.push('truth:FP=' + this.truthFP);
                lines.push('truth:TN=' + this.truthTN);
                lines.push('truth:FN=' + this.truthFN);
                lines.push('truth:precision=' + this.precision);
                lines.push('truth:recall=' + this.recall);
                lines.push('truth:specificity=' + this.specificity);
                lines.push('truth:F1=' + this.statF1);
                lines.push('truth:kappa=' + this.statKappa);
                lines.push('truth:MCC=' + this.statMCC);
            }
            if (!isNaN(this.atomicSlopeA) && !isNaN(this.atomicInterceptB)) {
                lines.push('atomic:slope=' + this.atomicSlopeA);
                lines.push('atomic:intercept=' + this.atomicInterceptB);
            }
            if (this.noteTitle)
                lines.push('note:title=' + this.noteTitle);
            if (this.noteOrigin)
                lines.push('note:origin=' + this.noteOrigin);
            if (this.noteField)
                lines.push('note:field=' + this.noteField);
            if (this.noteComments)
                for (let comment of this.noteComments)
                    lines.push('note:comment=' + comment);
            lines.push('!End');
            return lines.join('\n');
        }
        static deserialise(str) {
            let lines = str.split('\n'), lnum = 0;
            function readLine() { return lnum >= lines.length ? null : lines[lnum++].trim(); }
            let line = readLine();
            if (line == null || !line.startsWith('Bayesian!(') || !line.endsWith(')'))
                throw 'Not a serialised Bayesian model.';
            let bits = line.substring(10, line.length - 1).split(',');
            if (bits.length < 4)
                throw 'Invalid header content';
            let classType = bits[0] == 'ECFP0' ? WebMolKit.CircularFingerprints.CLASS_ECFP0 : bits[0] == 'ECFP2' ? WebMolKit.CircularFingerprints.CLASS_ECFP2
                : bits[0] == 'ECFP4' ? WebMolKit.CircularFingerprints.CLASS_ECFP4 : bits[0] == 'ECFP6' ? WebMolKit.CircularFingerprints.CLASS_ECFP6
                    : 0;
            if (classType == 0)
                throw 'Unknown fingerprint type: ' + bits[0];
            let folding = parseInt(bits[1]);
            if (folding > 0)
                for (let f = folding; f > 0; f = f >> 1) {
                    if ((f & 1) == 1 && f != 1) {
                        folding = -1;
                        break;
                    }
                }
            if (folding < 0)
                throw 'Fingerprint folding ' + bits[1] + ' invalid: must be 0 or power of 2.';
            let model = new BayesianModel(classType, folding);
            model.lowThresh = parseFloat(bits[2]);
            model.highThresh = parseFloat(bits[3]);
            model.range = model.highThresh - model.lowThresh;
            model.invRange = model.range > 0 ? 1 / model.range : 0;
            const PTN_HASHLINE = new RegExp('^(-?\\d+)=([\\d\\.Ee-]+)');
            while (true) {
                line = readLine();
                if (line == null)
                    throw 'Missing correct terminator line.';
                if (line == '!End')
                    break;
                let match = PTN_HASHLINE.exec(line);
                if (match != null) {
                    let hash = parseInt(match[1]);
                    let c = parseFloat(match[2]);
                    model.contribs[hash] = c;
                }
                else if (line.startsWith('training:size='))
                    model.trainingSize = parseInt(line.substring(14));
                else if (line.startsWith('training:actives='))
                    model.trainingActives = parseInt(line.substring(17));
                else if (line.startsWith('roc:auc='))
                    model.rocAUC = parseFloat(line.substring(8));
                else if (line.startsWith('roc:type='))
                    model.rocType = line.substring(9);
                else if (line.startsWith('roc:x=')) {
                    model.rocX = [];
                    for (let s of line.substring(6).split(','))
                        model.rocX.push(parseFloat(s));
                }
                else if (line.startsWith('roc:y=')) {
                    model.rocY = [];
                    for (let s of line.substring(6).split(','))
                        model.rocY.push(parseFloat(s));
                }
                else if (line.startsWith('truth:TP='))
                    model.truthTP = parseInt(line.substring(9), 0);
                else if (line.startsWith('truth:FP='))
                    model.truthFP = parseInt(line.substring(9), 0);
                else if (line.startsWith('truth:TN='))
                    model.truthTN = parseInt(line.substring(9), 0);
                else if (line.startsWith('truth:FN='))
                    model.truthFN = parseInt(line.substring(9), 0);
                else if (line.startsWith('truth:precision='))
                    model.precision = parseFloat(line.substring(16));
                else if (line.startsWith('truth:recall='))
                    model.recall = parseFloat(line.substring(13));
                else if (line.startsWith('truth:specificity='))
                    model.specificity = parseFloat(line.substring(18));
                else if (line.startsWith('truth:F1='))
                    model.statF1 = parseFloat(line.substring(9));
                else if (line.startsWith('truth:kappa='))
                    model.statKappa = parseFloat(line.substring(12));
                else if (line.startsWith('truth:MCC='))
                    model.statMCC = parseFloat(line.substring(10));
                else if (line.startsWith('atomic:slope='))
                    model.atomicSlopeA = parseFloat(line.substring(13));
                else if (line.startsWith('atomic:intercept='))
                    model.atomicInterceptB = parseFloat(line.substring(17));
                else if (line.startsWith('note:title='))
                    model.noteTitle = line.substring(11);
                else if (line.startsWith('note:origin='))
                    model.noteOrigin = line.substring(12);
                else if (line.startsWith('note:field='))
                    model.noteField = line.substring(11);
                else if (line.startsWith('note:comment=')) {
                    if (model.noteComments == null)
                        model.noteComments = [];
                    model.noteComments.push(line.substring(13));
                }
            }
            return model;
        }
        singleLeaveOneOut(idx) {
            let exclActive = this.activity[idx];
            let exclSet = new Set();
            for (let fp of this.training[idx])
                exclSet.add(fp);
            const sz = this.training.length, szN = sz - 1;
            const invSzN = 1.0 / szN;
            const activeN = exclActive ? this.numActive - 1 : this.numActive;
            const P_AT = activeN * invSzN;
            let val = 0;
            for (let hashStr in this.inHash) {
                const hash = parseInt(hashStr);
                if (!exclSet.has(hash))
                    continue;
                const AT = this.inHash[hash];
                const A = AT[0] - (exclActive ? 1 : 0), T = AT[1] - 1;
                const Pcorr = (A + 1) / (T * P_AT + 1);
                const P = Math.log(Pcorr);
                val += P;
            }
            return val;
        }
        validateNfold(nsegs) {
            const sz = this.training.length;
            let order = WebMolKit.Vec.numberArray(0, sz);
            let p = 0;
            for (let n = 0; n < sz; n++)
                if (this.activity[n])
                    order[p++] = n;
            for (let n = 0; n < sz; n++)
                if (!this.activity[n])
                    order[p++] = n;
            let segContribs = [];
            for (let n = 0; n < nsegs; n++)
                segContribs.push(this.buildPartial(order, n, nsegs));
            this.estimates = WebMolKit.Vec.numberArray(0, sz);
            for (let n = 0; n < sz; n++)
                this.estimates[order[n]] = this.estimatePartial(order, n, segContribs[n % nsegs]);
            this.calculateROC();
            this.calculateTruth();
        }
        buildPartial(order, seg, div) {
            const sz = this.training.length;
            let na = 0, nt = 0;
            let ih = {};
            for (let n = 0; n < sz; n++) {
                if (n % div != seg) {
                    const active = this.activity[order[n]];
                    if (active)
                        na++;
                    nt++;
                    for (let h of this.training[order[n]]) {
                        let stash = ih[h];
                        if (stash == null)
                            stash = [0, 0];
                        if (active)
                            stash[0]++;
                        stash[1]++;
                        ih[h] = stash;
                    }
                }
            }
            let segContribs = {};
            const invSz = 1.0 / nt;
            const P_AT = na * invSz;
            for (let hashStr in ih) {
                let hash = parseInt(hashStr);
                const AT = ih[hash];
                const A = AT[0], T = AT[1];
                const Pcorr = (A + 1) / (T * P_AT + 1);
                const P = Math.log(Pcorr);
                segContribs[hash] = P;
            }
            return segContribs;
        }
        estimatePartial(order, idx, segContrib) {
            let val = 0;
            for (let h of this.training[order[idx]]) {
                let c = segContrib[h];
                if (c != null)
                    val += c;
            }
            return val;
        }
        calculateROC() {
            const sz = this.training.length;
            let idx = WebMolKit.Vec.idxSort(this.estimates);
            let thresholds = [];
            thresholds.push(this.lowThresh - 0.01 * this.range);
            for (let n = 0; n < sz - 1; n++) {
                const th1 = this.estimates[idx[n]], th2 = this.estimates[idx[n + 1]];
                if (th1 == th2)
                    continue;
                thresholds.push(0.5 * (th1 + th2));
            }
            thresholds.push(this.highThresh + 0.01 * this.range);
            this.rocX = [];
            this.rocY = [];
            let rocT = [];
            let posTrue = 0, posFalse = 0, ipos = 0;
            let invPos = 1.0 / this.numActive, invNeg = 1.0 / (sz - this.numActive);
            for (let n = 0; n < thresholds.length; n++) {
                const th = thresholds[n];
                for (; ipos < sz; ipos++) {
                    if (th < this.estimates[idx[ipos]])
                        break;
                    if (this.activity[idx[ipos]])
                        posTrue++;
                    else
                        posFalse++;
                }
                const x = posFalse * invNeg;
                const y = posTrue * invPos;
                const rsz = rocT.length;
                if (rsz > 0 && x == this.rocX[rsz - 1] && y == this.rocY[rsz - 1])
                    continue;
                this.rocX[rsz] = 1 - x;
                this.rocY[rsz] = 1 - y;
                rocT[rsz] = th;
            }
            this.rocX = WebMolKit.Vec.reverse(this.rocX);
            this.rocY = WebMolKit.Vec.reverse(this.rocY);
            rocT = WebMolKit.Vec.reverse(rocT);
            this.calibrateThresholds(this.rocX, this.rocY, rocT);
            this.rocAUC = 0;
            for (let n = 0; n < rocT.length - 1; n++) {
                const w = this.rocX[n + 1] - this.rocX[n], h = 0.5 * (this.rocY[n] + this.rocY[n + 1]);
                this.rocAUC += w * h;
            }
            const DIST = 0.002, DSQ = DIST * DIST;
            let gx = [], gy = [];
            gx.push(this.rocX[0]);
            gy.push(this.rocY[0]);
            for (let i = 1; i < rocT.length - 1; i++) {
                const dx = this.rocX[i] - gx[gx.length - 1], dy = this.rocY[i] - gy[gy.length - 1];
                if (WebMolKit.norm2_xy(dx, dy) < DSQ)
                    continue;
                gx.push(this.rocX[i]);
                gy.push(this.rocY[i]);
            }
            gx.push(this.rocX[rocT.length - 1]);
            gy.push(this.rocY[rocT.length - 1]);
        }
        calculateTruth() {
            let thresh = 0.5 * (this.lowThresh + this.highThresh);
            this.truthTP = this.truthFP = this.truthTN = this.truthFN = 0;
            for (let n = 0; n < this.activity.length; n++) {
                let actual = this.activity[n], predicted = this.estimates[n] >= thresh;
                if (actual && predicted)
                    this.truthTP++;
                else if (!actual && predicted)
                    this.truthFP++;
                else if (actual && !predicted)
                    this.truthFN++;
                else if (!actual && !predicted)
                    this.truthTN++;
            }
            const TP = this.truthTP, FP = this.truthFP, TN = this.truthTN, FN = this.truthFN;
            let invSize = 1.0 / this.activity.length;
            this.precision = TP / (TP + FP);
            this.recall = TP / (TP + FN);
            this.specificity = TN / (TN + FP);
            this.statF1 = 2 * (this.precision * this.recall) / (this.precision + this.recall);
            let Pyes = (TP + FP) * invSize * (TP + FN) * invSize;
            let Pno = (FP + TN) * invSize * (FN + TN) * invSize;
            let P0 = (TP + TN) * invSize, Pe = Pyes + Pno;
            this.statKappa = (P0 - Pe) / (1 - Pe);
            let mccOver = TP * TN - FP * FN;
            let mccUnder = (TP + FP) * (TP + FN) * (TN + FP) * (TN + FN);
            this.statMCC = mccOver / Math.sqrt(mccUnder);
        }
        calibrateThresholds(x, y, t) {
            const sz = t.length;
            let idx = 0;
            for (let n = 1; n < sz; n++)
                if (y[n] - x[n] > y[idx] - x[idx])
                    idx = n;
            const midThresh = t[idx];
            let idxX = 0, idxY = sz - 1;
            for (; idxX < idx - 1; idxX++)
                if (x[idxX] > 0)
                    break;
            for (; idxY > idx + 1; idxY--)
                if (y[idxY] < 1)
                    break;
            let delta = Math.min(t[idxX] - midThresh, midThresh - t[idxY]);
            this.lowThresh = midThresh - delta;
            this.highThresh = midThresh + delta;
            this.range = 2 * delta;
            this.invRange = this.range > 0 ? 1 / this.range : 0;
        }
        determineCoverage(mol, approvedHashes) {
            const na = mol.numAtoms;
            let cover = {};
            const andBits = this.folding == 0 ? 0xFFFFFFFF : this.folding - 1;
            let meta = WebMolKit.MetaMolecule.createStrictRubric(mol);
            let circ = new WebMolKit.CircularFingerprints(meta, this.classType);
            let collectFP = (fp) => {
                let idx = fp.hashCode & andBits;
                if (this.contribs[idx] == null)
                    return;
                let mask = cover[idx];
                if (mask == null) {
                    mask = WebMolKit.Vec.booleanArray(false, na);
                    cover[idx] = mask;
                }
                for (let a of fp.atoms)
                    mask[a - 1] = true;
            };
            circ.hookApplyNewFP = collectFP;
            circ.hookConsiderNewFP = collectFP;
            circ.calculate();
            if (approvedHashes != null) {
                let hashes = this.folding == 0 ? circ.getUniqueHashes() : circ.getFoldedHashes(this.folding);
                for (let h of hashes)
                    approvedHashes.add(h);
            }
            return cover;
        }
    }
    WebMolKit.BayesianModel = BayesianModel;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class BuildSMILES {
        constructor(mol, pri = null) {
            this.mol = mol;
            this.pri = pri;
        }
        generate() {
            if (this.mol.numAtoms == 0)
                return '';
            this.walkSequence();
            this.findLinks();
            return this.assemble();
        }
        walkSequence() {
            const mol = this.mol, na = mol.numAtoms, pri = this.pri;
            this.seq = [];
            let visited = WebMolKit.Vec.booleanArray(false, na);
            let pos = 1;
            if (pri != null)
                pos = WebMolKit.Vec.idxMin(pri) + 1;
            for (let count = 0; count < na; count++) {
                this.seq.push(pos);
                visited[pos - 1] = true;
                if (count == na - 1)
                    break;
                let adj = mol.atomAdjList(pos);
                let cc = mol.atomConnComp(pos);
                pos = 0;
                for (let n = 0; n < adj.length; n++)
                    if (!visited[adj[n] - 1]) {
                        if (pri == null) {
                            pos = adj[n];
                            break;
                        }
                        if (pos == 0 || pri[adj[n] - 1] < pri[pos - 1])
                            pos = adj[n];
                    }
                if (pos > 0)
                    continue;
                for (let n = 1; n <= na; n++)
                    if (!visited[n - 1] && mol.atomConnComp(n) == cc) {
                        if (pri == null) {
                            pos = n;
                            break;
                        }
                        if (pos == 0 || pri[n - 1] < pri[pos - 1])
                            pos = n;
                    }
                if (pos > 0)
                    continue;
                for (let n = 1; n <= na; n++)
                    if (!visited[n - 1]) {
                        if (pri == null) {
                            pos = n;
                            break;
                        }
                        if (pos == 0 || pri[n - 1] < pri[pos - 1])
                            pos = n;
                    }
                if (pos == 0)
                    throw 'Walk sequence failed.';
            }
        }
        findLinks() {
            const mol = this.mol, na = mol.numAtoms, pri = this.pri, seq = this.seq;
            this.link = [];
            this.conn = [];
            for (let n = 0; n < na; n++) {
                this.link.push([]);
                this.conn.push([]);
            }
            let invseq = WebMolKit.Vec.numberArray(0, na);
            for (let n = 0; n < na; n++)
                invseq[seq[n] - 1] = n;
            let inPlay = WebMolKit.Vec.numberArray(-1, na + 1);
            for (let n = 0; n < na; n++) {
                let prev = n > 0 ? seq[n - 1] : 0;
                let cur = seq[n];
                let next = n < na - 1 ? seq[n + 1] : 0;
                for (let i = 1; i <= na; i++)
                    if (inPlay[i] >= 0 && n > inPlay[i])
                        inPlay[i] = -1;
                let adj = mol.atomAdjList(cur);
                if (pri != null)
                    for (let p = 0; p < adj.length - 1;) {
                        if (invseq[adj[p] - 1] > invseq[adj[p + 1] - 1]) {
                            WebMolKit.Vec.swap(adj, p, p + 1);
                            if (p > 0)
                                p--;
                        }
                        else
                            p++;
                    }
                for (let i = 0; i < adj.length; i++) {
                    if (adj[i] == prev || adj[i] == next)
                        continue;
                    let nbr = adj[i];
                    if (invseq[cur - 1] > invseq[nbr - 1])
                        continue;
                    let num = -1;
                    for (let j = 1; j <= na; j++)
                        if (inPlay[j] < 0) {
                            num = j;
                            inPlay[j] = Math.max(invseq[cur - 1], invseq[nbr - 1]);
                            break;
                        }
                    this.link[cur - 1].push(num);
                    this.conn[cur - 1].push(nbr);
                    this.link[nbr - 1].push(num);
                    this.conn[nbr - 1].push(cur);
                }
            }
        }
        assemble() {
            const mol = this.mol, na = mol.numAtoms, seq = this.seq, link = this.link, conn = this.conn;
            let smiles = '';
            const NON_ESCAPED = ['C', 'N', 'O', 'P', 'S'];
            for (let n = 0; n < na; n++) {
                let prev = n > 0 ? seq[n - 1] : 0, cur = seq[n];
                let bidx = prev > 0 ? mol.findBond(prev, cur) : 0;
                if (prev > 0 && bidx == 0)
                    smiles += '.';
                if (bidx > 0) {
                    let bo = mol.bondOrder(bidx);
                    if (bo == 2)
                        smiles += '=';
                    else if (bo == 3)
                        smiles += '#';
                }
                let el = mol.atomElement(cur);
                if (WebMolKit.Chemistry.ELEMENTS.indexOf(el) < 0)
                    el = '*';
                let chg = mol.atomCharge(cur);
                if (NON_ESCAPED.indexOf(el) >= 0 && chg == 0) {
                    smiles += el;
                }
                else {
                    smiles += '[' + el;
                    if (chg > 0)
                        smiles += '+' + chg;
                    if (chg < 0)
                        smiles += chg;
                    smiles += ']';
                }
                let num = link[cur - 1];
                if (num != null)
                    for (let i = 0; i < num.length; i++) {
                        bidx = mol.findBond(cur, conn[cur - 1][i]);
                        let bo = mol.bondOrder(bidx);
                        if (bo == 2)
                            smiles += '=';
                        else if (bo == 3)
                            smiles += '#';
                        if (num[i] < 10)
                            smiles += num[i];
                        else
                            smiles += '%' + num[i];
                    }
            }
            return smiles;
        }
    }
    WebMolKit.BuildSMILES = BuildSMILES;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let crc_table = [];
    function make_crc_table() {
        if (crc_table.length > 0)
            return;
        for (let n = 0; n < 256; n++) {
            let c = n;
            for (let i = 0; i < 8; i++)
                if ((c & 1) != 0)
                    c = 0xEDB88320 ^ (c >>> 1);
                else
                    c = (c >>> 1);
            crc_table.push(c);
        }
    }
    const BOOT_CRC = 0xFFFFFFFF;
    function start_crc() { return BOOT_CRC; }
    function feed_crc(crc, byte) {
        let idx = (crc ^ byte) & 0xFF;
        return crc_table[idx] ^ (crc >>> 8);
    }
    function end_crc(crc) { return crc ^ BOOT_CRC; }
    class CircularFingerprints {
        constructor(meta, kind) {
            this.meta = meta;
            this.kind = kind;
            this.hookApplyNewFP = null;
            this.hookConsiderNewFP = null;
            this.identity = [];
            this.resolvedChiral = [];
            this.atomGroup = [];
            this.fplist = [];
            this.amask = [];
            this.atomAdj = [];
            this.bondAdj = [];
            make_crc_table();
        }
        calculate() {
            let mol = this.meta.mol, na = mol.numAtoms;
            this.identity = WebMolKit.Vec.numberArray(0, na);
            this.resolvedChiral = WebMolKit.Vec.booleanArray(false, na);
            for (let n = 0; n < na; n++)
                this.atomGroup.push([]);
            this.amask = WebMolKit.Vec.booleanArray(false, na);
            for (let n = 0; n < na; n++) {
                this.amask[n] = mol.atomicNumber(n + 1) >= 2 && !WebMolKit.MolUtil.hasAbbrev(mol, n + 1);
                this.atomAdj.push([]);
                this.bondAdj.push([]);
            }
            for (let n = 0; n < na; n++) {
                if (!this.amask[n])
                    continue;
                this.atomAdj[n] = mol.atomAdjList(n + 1);
                this.bondAdj[n] = mol.atomAdjBonds(n + 1);
                for (let i = this.atomAdj[n].length - 1; i >= 0; i--)
                    if (!this.amask[this.atomAdj[n][i] - 1]) {
                        this.atomAdj[n].splice(i, 1);
                        this.bondAdj[n].splice(i, 1);
                    }
            }
            for (let n = 0; n < na; n++)
                if (this.amask[n]) {
                    this.identity[n] = this.initialIdentityECFP(n + 1);
                    this.atomGroup[n] = [n + 1];
                    this.applyNewFP({ 'hashCode': this.identity[n], 'iteration': 0, 'atoms': this.atomGroup[n], 'centralAtom': n + 1 });
                }
            let niter = this.kind;
            for (let iter = 1; iter <= niter; iter++) {
                let newident = WebMolKit.Vec.numberArray(0, na);
                for (let n = 0; n < na; n++)
                    if (this.amask[n])
                        newident[n] = this.circularIterate(iter, n + 1);
                this.identity = newident;
                for (let n = 0; n < na; n++)
                    if (this.amask[n]) {
                        this.atomGroup[n] = this.growAtoms(this.atomGroup[n]);
                        this.considerNewFP({ 'hashCode': this.identity[n], 'iteration': iter, 'atoms': this.atomGroup[n], 'centralAtom': n + 1 });
                    }
            }
        }
        static create(meta, kind) {
            if (meta instanceof WebMolKit.Molecule)
                meta = WebMolKit.MetaMolecule.createStrictRubric(meta);
            let circ = new CircularFingerprints(meta, kind);
            circ.calculate();
            return circ;
        }
        getMolecule() { return this.meta.mol; }
        get numFP() { return this.fplist.length; }
        getFP(idx) { return this.fplist[idx]; }
        getFingerprints() { return this.fplist.slice(0); }
        getUniqueHashes() {
            let hashes = new Set();
            for (let fp of this.fplist)
                hashes.add(fp.hashCode);
            return WebMolKit.Vec.sorted(Array.from(hashes));
        }
        getFoldedHashes(maxBits) {
            let andBits = maxBits - 1;
            let hashes = new Set();
            for (let fp of this.fplist)
                hashes.add(fp.hashCode & andBits);
            return WebMolKit.Vec.sorted(Array.from(hashes));
        }
        static tanimoto(hash1, hash2) {
            let shared = 0, total = 0;
            let sz1 = hash1.length, sz2 = hash2.length;
            if (sz1 == 0 && sz2 == 0)
                return 0;
            let i1 = 0, i2 = 0;
            while (i1 < sz1 || i2 < sz2) {
                if (i1 == sz1) {
                    total += sz2 - i2;
                    break;
                }
                if (i2 == sz2) {
                    total += sz1 - i1;
                    break;
                }
                let v1 = hash1[i1], v2 = hash2[i2];
                if (v1 == v2) {
                    shared += 1;
                    i1 += 1;
                    i2 += 1;
                }
                else if (v1 < v2)
                    i1 += 1;
                else
                    i2 += 1;
                total += 1;
            }
            return shared / total;
        }
        initialIdentityECFP(atom) {
            const mol = this.meta.mol;
            let adj = mol.atomAdjList(atom);
            let nheavy = 0, nhydr = mol.atomHydrogens(atom);
            for (let a of adj)
                if (mol.atomElement(a) == 'H')
                    nhydr++;
                else
                    nheavy++;
            let atno = mol.atomicNumber(atom);
            let degree = Math.max(0, WebMolKit.Chemistry.ELEMENT_BONDING[atno] - nhydr);
            let chg = mol.atomCharge(atom);
            let inring = mol.atomRingBlock(atom) > 0 ? 1 : 0;
            let crc = start_crc();
            crc = feed_crc(crc, (nheavy << 4) | degree);
            crc = feed_crc(crc, atno);
            crc = feed_crc(crc, chg + 0x80);
            crc = feed_crc(crc, (nhydr << 4) | inring);
            return end_crc(crc);
        }
        circularIterate(iter, atom) {
            let adj = this.atomAdj[atom - 1], adjb = this.bondAdj[atom - 1];
            let seq = WebMolKit.Vec.numberArray(0, 2 + 2 * adj.length);
            seq[0] = iter;
            seq[1] = this.identity[atom - 1];
            for (let n = 0; n < adj.length; n++) {
                seq[2 * n + 2] = this.meta.isBondAromatic(adjb[n]) ? 0xF : this.meta.mol.bondOrder(adjb[n]);
                seq[2 * n + 3] = this.identity[adj[n] - 1];
            }
            let p = 0;
            while (p < adj.length - 1) {
                let i = 2 + 2 * p;
                if (seq[i] > seq[i + 2] || (seq[i] == seq[i + 2] && seq[i + 1] > seq[i + 3])) {
                    WebMolKit.Vec.swap(seq, i, i + 2);
                    WebMolKit.Vec.swap(seq, i + 1, i + 3);
                    if (p > 0)
                        p--;
                }
                else
                    p++;
            }
            let crc = start_crc();
            for (let n = 0; n < seq.length; n += 2) {
                crc = feed_crc(crc, seq[n]);
                let v = seq[n + 1];
                crc = feed_crc(crc, v >> 24);
                crc = feed_crc(crc, (v >> 16) & 0xFF);
                crc = feed_crc(crc, (v >> 8) & 0xFF);
                crc = feed_crc(crc, v & 0xFF);
            }
            if (!this.resolvedChiral[atom - 1] && WebMolKit.Vec.len(this.meta.rubricTetra) > 0 && this.meta.rubricTetra[atom - 1] != null) {
                let ru = this.meta.rubricTetra[atom - 1];
                let par = [
                    ru[0] == 0 ? 0 : this.identity[ru[0] - 1],
                    ru[1] == 0 ? 0 : this.identity[ru[1] - 1],
                    ru[2] == 0 ? 0 : this.identity[ru[2] - 1],
                    ru[3] == 0 ? 0 : this.identity[ru[3] - 1]
                ];
                if (par[0] != par[1] && par[0] != par[2] && par[0] != par[3] && par[1] != par[2] && par[1] != par[3] && par[2] != par[3]) {
                    crc = feed_crc(crc, WebMolKit.Permutation.parityOrder(par) + 1);
                    this.resolvedChiral[atom - 1] = true;
                }
            }
            return end_crc(crc);
        }
        growAtoms(atoms) {
            let mask = WebMolKit.Vec.booleanArray(false, this.meta.mol.numAtoms);
            for (let n = 0; n < atoms.length; n++) {
                mask[atoms[n] - 1] = true;
                for (let a of this.atomAdj[atoms[n] - 1])
                    mask[a - 1] = true;
            }
            return WebMolKit.Vec.add(WebMolKit.Vec.maskIdx(mask), 1);
        }
        applyNewFP(newFP) {
            if (this.hookConsiderNewFP)
                this.hookConsiderNewFP(newFP);
            if (this.hookApplyNewFP)
                this.hookApplyNewFP(newFP);
            this.fplist.push(newFP);
        }
        considerNewFP(newFP) {
            if (this.hookConsiderNewFP)
                this.hookConsiderNewFP(newFP);
            let hit = -1;
            let fp = null;
            for (let n = 0; n < this.fplist.length; n++) {
                let lookFP = this.fplist[n];
                if (WebMolKit.Vec.equals(lookFP.atoms, newFP.atoms)) {
                    fp = lookFP;
                    hit = n;
                    break;
                }
            }
            if (hit < 0) {
                this.fplist.push(newFP);
                return;
            }
            if (fp.iteration < newFP.iteration || fp.hashCode < newFP.hashCode)
                return;
            this.fplist[hit] = newFP;
            if (this.hookApplyNewFP)
                this.hookApplyNewFP(newFP);
        }
    }
    CircularFingerprints.CLASS_ECFP0 = 0;
    CircularFingerprints.CLASS_ECFP2 = 1;
    CircularFingerprints.CLASS_ECFP4 = 2;
    CircularFingerprints.CLASS_ECFP6 = 3;
    WebMolKit.CircularFingerprints = CircularFingerprints;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class ResonanceRemover {
        constructor(mol, resBonds, atomHyd = []) {
            this.mol = mol;
            this.resBonds = resBonds;
            this.atomHyd = atomHyd;
            this.maxIter = 1000;
            this.bondOrders = [];
            this.tolerant = false;
            this.mol = mol;
            this.resBonds = resBonds;
            this.atomHyd = atomHyd;
            for (let n = 1; n <= mol.numBonds; n++)
                this.bondOrders.push(mol.bondOrder(n));
        }
        perform() {
            const { mol } = this;
            if (this.atomHyd == null) {
                this.atomHyd = [];
                for (let n = 1; n <= mol.numAtoms; n++)
                    this.atomHyd.push(mol.atomHExplicit(n));
            }
            this.correctInputMask();
            let g = new WebMolKit.Graph(mol.numAtoms);
            for (let n = 1; n <= mol.numBonds; n++)
                if (this.resBonds[n - 1])
                    g.addEdge(mol.bondFrom(n) - 1, mol.bondTo(n) - 1);
            let cc = g.calculateComponentGroups();
            for (let n = 0; n < cc.length; n++)
                if (cc[n].length >= 2)
                    this.processComponent(cc[n]);
        }
        correctInputMask() {
            const { mol, atomHyd } = this;
            const na = mol.numAtoms, nb = mol.numBonds;
            let exclude = WebMolKit.Vec.booleanArray(false, na);
            for (let n = 1; n <= na; n++) {
                let atno = mol.atomicNumber(n);
                let val = atno == WebMolKit.Chemistry.ELEMENT_C ? 4 :
                    atno == WebMolKit.Chemistry.ELEMENT_N || atno == WebMolKit.Chemistry.ELEMENT_P || atno == WebMolKit.Chemistry.ELEMENT_B ? 3 :
                        atno == WebMolKit.Chemistry.ELEMENT_O || atno == WebMolKit.Chemistry.ELEMENT_S ? 2 : -1;
                if (val < 0) {
                    exclude[n - 1] = true;
                    continue;
                }
                val += mol.atomCharge(n);
                if (atomHyd[n - 1] > 0)
                    val -= atomHyd[n - 1];
                if (mol.atomAdjCount(n) >= val)
                    exclude[n - 1] = true;
            }
            for (let n = 1; n <= nb; n++)
                if (!this.resBonds[n - 1] && mol.bondOrder(n) != 1) {
                    exclude[mol.bondFrom(n) - 1] = true;
                    exclude[mol.bondTo(n) - 1] = true;
                }
            this.resBonds = this.resBonds.slice(0);
            for (let n = 0; n < nb; n++)
                if (this.resBonds[n] && (exclude[mol.bondFrom(n + 1) - 1] || exclude[mol.bondTo(n + 1) - 1])) {
                    this.bondOrders[n] = 1;
                    this.resBonds[n] = false;
                }
        }
        processComponent(nodes) {
            const { mol, resBonds, bondOrders, atomHyd } = this;
            let sz = nodes.length;
            if (sz == 2) {
                let b = mol.findBond(nodes[0] + 1, nodes[1] + 1);
                bondOrders[b - 1] = 2;
                return;
            }
            let optionalH = WebMolKit.Vec.booleanArray(false, sz);
            for (let n = 0; n < sz; n++) {
                let i = nodes[n], a = i + 1;
                optionalH[n] = atomHyd[i] == WebMolKit.Molecule.HEXPLICIT_UNKNOWN && mol.atomElement(a) == 'N' && mol.atomAdjCount(a) - mol.atomCharge(a) <= 2;
            }
            let g = new WebMolKit.Graph(sz);
            let gravity = g.calculateGravity();
            let mask = WebMolKit.Vec.idxMask(nodes, mol.numAtoms);
            let bsz = 0;
            for (let n = 1; n <= mol.numBonds; n++)
                if (resBonds[n - 1] && mask[mol.bondFrom(n) - 1] && mask[mol.bondTo(n) - 1])
                    bsz++;
            let bfr = WebMolKit.Vec.numberArray(0, bsz), bto = WebMolKit.Vec.numberArray(0, bsz), bgrav = WebMolKit.Vec.numberArray(0, bsz), bidx = WebMolKit.Vec.numberArray(0, bsz);
            bsz = 0;
            for (let n = 1; n <= mol.numBonds; n++)
                if (resBonds[n - 1] && mask[mol.bondFrom(n) - 1] && mask[mol.bondTo(n) - 1]) {
                    let f = nodes.indexOf(mol.bondFrom(n) - 1), t = nodes.indexOf(mol.bondTo(n) - 1);
                    bfr[bsz] = f;
                    bto[bsz] = t;
                    bgrav[bsz] = gravity[f] + gravity[t];
                    bidx[bsz] = n;
                    g.addEdge(f, t);
                    bsz++;
                }
            let seq = WebMolKit.Vec.numberArray(0, bsz);
            seq[0] = WebMolKit.Vec.idxMax(bgrav);
            let visited = WebMolKit.Vec.booleanArray(false, bsz);
            visited[seq[0]] = true;
            for (let i = 1; i < bsz; i++) {
                let b = -1;
                for (let j = i - 1; j >= 0; j--) {
                    for (let n = 0; n < bsz; n++) {
                        if (!visited[n])
                            if (bfr[n] == bfr[seq[j]] || bfr[n] == bto[seq[j]] || bto[n] == bfr[seq[j]] || bto[n] == bto[seq[j]]) {
                                if (b < 0 || bgrav[n] > bgrav[b])
                                    b = n;
                            }
                    }
                    if (b >= 0)
                        break;
                }
                if (b < 0)
                    throw 'Graph walk failed';
                seq[i] = b;
                visited[b] = true;
            }
            let paths = [];
            paths.push([true]);
            paths.push([false]);
            let result = null;
            let resultCount = 0;
            let definiteMatch = Math.ceil(0.5 * bsz);
            let iter = 0;
            while (paths.length > 0) {
                let p = paths[0];
                let p1 = WebMolKit.Vec.append(p, false), p2 = WebMolKit.Vec.append(p, true);
                if (!this.validPath(p1, seq, bfr, bto, g, optionalH))
                    p1 = null;
                if (!this.validPath(p2, seq, bfr, bto, g, optionalH))
                    p2 = null;
                if (WebMolKit.Vec.len(p1) == bsz) {
                    let c = WebMolKit.Vec.maskCount(p1);
                    if (c > resultCount) {
                        result = p1;
                        resultCount = c;
                    }
                    p1 = null;
                }
                if (WebMolKit.Vec.len(p2) == bsz) {
                    let c = WebMolKit.Vec.maskCount(p2);
                    if (c > resultCount) {
                        result = p2;
                        resultCount = c;
                    }
                    p2 = null;
                }
                if (resultCount >= definiteMatch)
                    break;
                if (p1 == null && p2 == null)
                    paths.shift();
                else if (p1 != null && p2 != null) {
                    paths[0] = p1;
                    paths.splice(1, 0, p2);
                }
                else if (p1 != null)
                    paths[0] = p1;
                else
                    paths[0] = p2;
                iter++;
                if (iter > this.maxIter) {
                    if (result != null)
                        break;
                    if (this.tolerant)
                        return;
                    throw 'Resonance localisation exceeded maximum iteration count';
                }
            }
            if (result == null) {
                if (this.tolerant)
                    return;
                throw 'Unable to find a solution to the resonance block.';
            }
            for (let n = 0; n < bsz; n++)
                bondOrders[bidx[seq[n]] - 1] = result[n] ? 2 : 1;
        }
        validPath(path, seq, bfr, bto, g, optionalH) {
            let sz = g.numNodes;
            let count1 = WebMolKit.Vec.numberArray(0, sz), count2 = WebMolKit.Vec.numberArray(0, sz);
            for (let n = 0; n < path.length; n++) {
                let a1 = bfr[seq[n]], a2 = bto[seq[n]];
                if (path[n]) {
                    count2[a1]++;
                    count2[a2]++;
                }
                else {
                    count1[a1]++;
                    count1[a2]++;
                }
            }
            for (let n = 0; n < sz; n++) {
                if (count2[n] > 1)
                    return false;
                if (!optionalH[n] && g.numEdges(n) > 1 && count1[n] == g.numEdges(n))
                    return false;
            }
            return true;
        }
    }
    WebMolKit.ResonanceRemover = ResonanceRemover;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    WebMolKit.TEMPLATE_FILES = [
        'rings',
        'termgrp',
        'funcgrp',
        'protgrp',
        'nonplrings',
        'largerings',
        'crownethers',
        'ligmonodent',
        'ligbident',
        'ligtrident',
        'ligmultident',
        'cagecmplx',
        'aminoacids',
        'biomolecules',
        'saccharides'
    ];
    class AbbrevContainer {
        constructor() {
            this.abbrevs = [];
        }
        static needsSetup() { return !this.main; }
        static setupData() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.main)
                    return;
                if (!WebMolKit.Theme.RESOURCE_URL)
                    throw ('RPC resource URL not defined.');
                this.main = new AbbrevContainer();
                for (let tfn of WebMolKit.TEMPLATE_FILES) {
                    let url = WebMolKit.Theme.RESOURCE_URL + '/data/templates/' + tfn + '.ds';
                    let dsstr = yield WebMolKit.readTextURL(url);
                    let ds = WebMolKit.DataSheetStream.readXML(dsstr);
                    let colMol = ds.firstColOfType("molecule"), colAbbrev = ds.findColByName('Abbrev', "string");
                    if (colMol < 0 || colAbbrev < 0)
                        continue;
                    for (let n = 0; n < ds.numRows; n++) {
                        let frag = ds.getMoleculeClone(n, colMol), name = ds.getString(n, colAbbrev);
                        if (!frag || !name)
                            continue;
                        let attcount = 0, firstConn = 0;
                        for (let i = 1; i <= frag.numAtoms; i++)
                            if (frag.atomElement(i) == WebMolKit.MolUtil.TEMPLATE_ATTACHMENT) {
                                if (firstConn == 0)
                                    firstConn = i;
                                frag.setAtomElement(i, WebMolKit.MolUtil.ABBREV_ATTACHMENT);
                                attcount++;
                            }
                        if (attcount != 1)
                            continue;
                        if (firstConn > 1)
                            frag.swapAtoms(1, firstConn);
                        this.main.submitAbbreviation(name, frag);
                    }
                }
            });
        }
        getAbbrevs() {
            return this.abbrevs.slice(0);
        }
        submitAbbreviation(name, infrag, promote = false) {
            let frag = infrag.clone();
            this.submitFragment(name, frag, promote);
        }
        submitMolecule(inmol, promote = false) {
            let mol = inmol.clone();
            for (let n = 1; n <= mol.numAtoms; n++) {
                let frag = WebMolKit.MolUtil.getAbbrev(mol, n);
                if (!frag)
                    continue;
                this.submitFragment(mol.atomElement(n), frag, promote);
            }
        }
        substituteAbbrevName(mol, atom) {
            let frag = WebMolKit.MolUtil.getAbbrev(mol, atom);
            if (!frag)
                return false;
            for (let abbrev of this.abbrevs)
                if (abbrev.frag.numAtoms == frag.numAtoms) {
                    if (WebMolKit.CoordUtil.sketchEquivalent(frag, abbrev.frag)) {
                        mol.setAtomElement(atom, abbrev.name);
                        return true;
                    }
                }
            return false;
        }
        submitFragment(name, frag, promote) {
            if (name == '?')
                return;
            let vx = 0, vy = 0;
            let adj = frag.atomAdjList(1);
            for (let a of adj) {
                vx += frag.atomX(a) - frag.atomX(1);
                vy += frag.atomY(a) - frag.atomY(1);
            }
            if (adj.length > 1) {
                let inv = 1.0 / adj.length;
                vx *= inv;
                vy *= inv;
            }
            if (WebMolKit.norm_xy(vx, vy) > 0.1 * 0.1) {
                let theta = Math.atan2(vy, vx);
                if (Math.abs(theta) > 2 * WebMolKit.DEGRAD)
                    WebMolKit.CoordUtil.rotateMolecule(frag, -theta);
            }
            let hit = -1;
            for (let n = 0; n < this.abbrevs.length; n++) {
                let a = this.abbrevs[n];
                if (a.name != name)
                    continue;
                hit = n;
                break;
            }
            let [html, search] = this.formatAbbrevLabel(name);
            let abv = { 'name': name, 'frag': frag, 'nameHTML': html, 'nameSearch': search };
            if (hit < 0) {
                if (promote)
                    this.abbrevs.unshift(abv);
                else
                    this.abbrevs.push(abv);
            }
            else {
                if (promote && hit > 0) {
                    this.abbrevs.splice(hit, 1);
                    this.abbrevs.unshift(abv);
                }
                else
                    this.abbrevs[hit] = abv;
            }
        }
        formatAbbrevLabel(name) {
            let html = '', search = '';
            let append = (bit, tag) => {
                if (tag)
                    html += '<' + tag + '>';
                html += WebMolKit.escapeHTML(bit);
                search += bit;
                if (tag)
                    html += '</' + tag + '>';
            };
            for (let bit of name.split('|')) {
                while (true) {
                    let match = bit.match(/^(.*?)\{(.*?)\}(.*)$/);
                    if (!match)
                        break;
                    let pre = match[1], mid = match[2], post = match[3];
                    append(pre, null);
                    if (mid.startsWith('^'))
                        append(mid.substring(1), 'sup');
                    else
                        append(mid, 'sub');
                    bit = post;
                }
                append(bit, null);
            }
            return [html, search.toLowerCase()];
        }
    }
    AbbrevContainer.main = null;
    WebMolKit.AbbrevContainer = AbbrevContainer;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    WebMolKit.BONDARTIFACT_EXTRA_RESPATH = 'xRESPATH:';
    WebMolKit.BONDARTIFACT_EXTRA_RESRING = 'xRESRING:';
    WebMolKit.BONDARTIFACT_EXTRA_ARENE = 'xARENE:';
    class BondArtifact {
        constructor(mol) {
            this.mol = mol;
            this.resPaths = new Map();
            this.resRings = new Map();
            this.arenes = new Map();
            for (let n = 1; n <= this.mol.numAtoms; n++) {
                for (let str of this.mol.atomExtra(n)) {
                    if (str.startsWith(WebMolKit.BONDARTIFACT_EXTRA_RESPATH))
                        this.appendResPath(n, str.substring(WebMolKit.BONDARTIFACT_EXTRA_RESPATH.length).split(':'));
                    else if (str.startsWith(WebMolKit.BONDARTIFACT_EXTRA_RESRING))
                        this.appendResRing(n, str.substring(WebMolKit.BONDARTIFACT_EXTRA_RESRING.length).split(':'));
                    else if (str.startsWith(WebMolKit.BONDARTIFACT_EXTRA_ARENE))
                        this.appendArene(n, str.substring(WebMolKit.BONDARTIFACT_EXTRA_ARENE.length).split(':'));
                }
            }
            for (let [blk, res] of this.resPaths.entries()) {
                res.atoms = this.pack(res.atoms);
                if (!this.pathify(res.atoms, false))
                    this.resPaths.delete(blk);
            }
            for (let [blk, res] of this.resRings.entries()) {
                res.atoms = this.pack(res.atoms);
                if (!this.pathify(res.atoms, true))
                    this.resRings.delete(blk);
            }
            for (let [blk, res] of this.arenes.entries()) {
                res.atoms = this.pack(res.atoms);
                if (res.atoms.length > 1)
                    res.centre = res.atoms.shift();
                if (!this.pathify(res.atoms, false))
                    this.arenes.delete(blk);
            }
        }
        getPathBlocks() { return Array.from(this.resPaths.keys()); }
        getRingBlocks() { return Array.from(this.resRings.keys()); }
        getAreneBlocks() { return Array.from(this.arenes.keys()); }
        getResPaths() {
            let list = [];
            for (let key of WebMolKit.Vec.sorted(Array.from(this.resPaths.keys())))
                list.push(this.resPaths.get(key));
            return list;
        }
        getResRings() {
            let list = [];
            for (let key of WebMolKit.Vec.sorted(Array.from(this.resRings.keys())))
                list.push(this.resRings.get(key));
            return list;
        }
        getArenes() {
            let list = [];
            for (let key of WebMolKit.Vec.sorted(Array.from(this.arenes.keys())))
                list.push(this.arenes.get(key));
            return list;
        }
        rewriteMolecule() {
            const mol = this.mol;
            for (let n = 1; n <= mol.numAtoms; n++) {
                let extra = mol.atomExtra(n), modified = false;
                for (let i = extra.length - 1; i >= 0; i--) {
                    if (extra[i].startsWith(WebMolKit.BONDARTIFACT_EXTRA_RESPATH) || extra[i].startsWith(WebMolKit.BONDARTIFACT_EXTRA_RESRING) || extra[i].startsWith(WebMolKit.BONDARTIFACT_EXTRA_ARENE)) {
                        extra.splice(i);
                        modified = true;
                    }
                }
                if (modified)
                    mol.setAtomExtra(n, extra);
            }
            for (let [blk, path] of this.resPaths.entries()) {
                for (let n = 0; n < path.atoms.length; n++) {
                    let extra = mol.atomExtra(path.atoms[n]);
                    extra.push(WebMolKit.BONDARTIFACT_EXTRA_RESPATH + blk + ':' + (n + 1));
                    mol.setAtomExtra(path.atoms[n], extra);
                }
            }
            for (let [blk, ring] of this.resRings.entries()) {
                for (let n = 0; n < ring.atoms.length; n++) {
                    let extra = mol.atomExtra(ring.atoms[n]);
                    extra.push(WebMolKit.BONDARTIFACT_EXTRA_RESRING + blk + ':' + (n + 1));
                    mol.setAtomExtra(ring.atoms[n], extra);
                }
            }
            for (let [blk, arene] of this.arenes.entries()) {
                for (let n = -1; n < arene.atoms.length; n++) {
                    let atom = n < 0 ? arene.centre : arene.atoms[n];
                    let extra = mol.atomExtra(atom);
                    extra.push(WebMolKit.BONDARTIFACT_EXTRA_ARENE + blk + ':' + (n + 2));
                    mol.setAtomExtra(atom, extra);
                }
            }
        }
        harmoniseNumbering(other) {
            let blocks = other.getPathBlocks();
            let stashPaths = this.getResPaths();
            this.resPaths.clear();
            for (let path of stashPaths) {
                let blk = this.nextIdentifier(blocks);
                this.resPaths.set(blk, path);
                blocks.push(blk);
            }
            blocks = other.getRingBlocks();
            let stashRings = this.getResRings();
            this.resRings.clear();
            for (let ring of stashRings) {
                let blk = this.nextIdentifier(blocks);
                this.resRings.set(blk, ring);
                blocks.push(blk);
            }
            blocks = other.getAreneBlocks();
            let stashArenes = this.getArenes();
            this.arenes.clear();
            for (let arene of stashArenes) {
                let blk = this.nextIdentifier(blocks);
                this.arenes.set(blk, arene);
                blocks.push(blk);
            }
        }
        createPath(atoms) {
            if (this.alreadyExists(atoms))
                return false;
            let path = this.atomsAsPath(atoms);
            if (path) {
                let id = this.nextIdentifier(Array.from(this.resPaths.keys()));
                this.resPaths.set(id, path);
                return true;
            }
            return false;
        }
        createRing(atoms) {
            if (this.alreadyExists(atoms))
                return false;
            let ring = this.atomsAsRing(atoms);
            if (ring) {
                let id = this.nextIdentifier(Array.from(this.resRings.keys()));
                this.resRings.set(id, ring);
                return true;
            }
            return false;
        }
        createArene(atoms) {
            if (this.alreadyExists(atoms))
                return false;
            let arene = this.atomsAsArene(atoms);
            if (arene) {
                let id = this.nextIdentifier(Array.from(this.arenes.keys()));
                this.arenes.set(id, arene);
                return true;
            }
            return false;
        }
        removeArtifact(atoms) {
            let type = 0, pick = 0, overlap = 0;
            for (let [blk, path] of this.resPaths.entries()) {
                let count = 0;
                for (let a of path.atoms)
                    if (atoms.indexOf(a) >= 0)
                        count++;
                if (count > overlap) {
                    type = 1;
                    pick = blk;
                    overlap = count;
                }
            }
            for (let [blk, ring] of this.resRings.entries()) {
                let count = 0;
                for (let a of ring.atoms)
                    if (atoms.indexOf(a) >= 0)
                        count++;
                if (count > overlap) {
                    type = 2;
                    pick = blk;
                    overlap = count;
                }
            }
            for (let [blk, arene] of this.arenes.entries()) {
                let count = atoms.indexOf(arene.centre) >= 0 ? 1 : 0;
                for (let a of arene.atoms)
                    if (atoms.indexOf(a) >= 0)
                        count++;
                if (count > overlap) {
                    type = 3;
                    pick = blk;
                    overlap = count;
                }
            }
            if (type == 0)
                return false;
            else if (type == 1)
                this.resPaths.delete(pick);
            else if (type == 2)
                this.resRings.delete(pick);
            else if (type == 3)
                this.arenes.delete(pick);
            return true;
        }
        static removeAll(mol) {
            for (let n = 1; n <= mol.numAtoms; n++) {
                let extra = mol.atomExtra(n);
                let modified = false;
                for (let i = extra.length - 1; i >= 0; i--) {
                    if (!extra[i].startsWith(WebMolKit.BONDARTIFACT_EXTRA_RESPATH) && !extra[i].startsWith(WebMolKit.BONDARTIFACT_EXTRA_RESRING) &&
                        !extra[i].startsWith(WebMolKit.BONDARTIFACT_EXTRA_ARENE))
                        continue;
                    extra = WebMolKit.Vec.remove(extra, i);
                    modified = true;
                }
                if (modified)
                    mol.setAtomExtra(n, extra);
            }
        }
        appendResPath(atom, bits) {
            let blk = WebMolKit.safeInt(bits[0], 0);
            if (blk <= 0)
                return;
            let res = this.resPaths.get(blk);
            if (res == null)
                this.resPaths.set(blk, res = { 'atoms': WebMolKit.Vec.numberArray(0, this.mol.numAtoms) });
            let idx = bits.length >= 2 ? WebMolKit.safeInt(bits[1], 0) : 0;
            if (res.atoms.indexOf(atom) >= 0)
                return;
            if (idx >= 1 && idx <= this.mol.numAtoms)
                res.atoms[idx - 1] = atom;
            else
                res.atoms.push(atom);
        }
        appendResRing(atom, bits) {
            let blk = WebMolKit.safeInt(bits[0], 0);
            if (blk <= 0)
                return;
            let res = this.resRings.get(blk);
            if (res == null)
                this.resRings.set(blk, res = { 'atoms': WebMolKit.Vec.numberArray(0, this.mol.numAtoms) });
            let idx = bits.length >= 2 ? WebMolKit.safeInt(bits[1], 0) : 0;
            if (res.atoms.indexOf(atom) >= 0)
                return;
            if (idx >= 1 && idx <= this.mol.numAtoms)
                res.atoms[idx - 1] = atom;
            else
                res.atoms.push(atom);
        }
        appendArene(atom, bits) {
            let blk = WebMolKit.safeInt(bits[0], 0);
            if (blk <= 0)
                return;
            let res = this.arenes.get(blk);
            if (res == null)
                this.arenes.set(blk, res = { 'centre': 0, 'atoms': WebMolKit.Vec.numberArray(0, this.mol.numAtoms) });
            let idx = bits.length >= 2 ? WebMolKit.safeInt(bits[1], 0) : 0;
            if (res.atoms.indexOf(atom) >= 0)
                return;
            if (idx >= 1 && idx <= this.mol.numAtoms)
                res.atoms[idx - 1] = atom;
            else
                res.atoms.push(atom);
        }
        pack(arr) {
            let ret = [];
            for (let v of arr)
                if (v != 0)
                    ret.push(v);
            return ret;
        }
        pathify(atoms, requireRing) {
            let sz = atoms.length;
            if (sz < 2)
                return false;
            let g = WebMolKit.Graph.fromMolecule(this.mol);
            for (let n = 0; n < this.mol.numAtoms; n++)
                g.setIndex(n, n + 1);
            g = g.subgraphIndex(WebMolKit.Vec.add(atoms, -1));
            let pos = 0;
            for (let n = 1; n < sz; n++)
                if (g.numEdges(n) < g.numEdges(pos))
                    pos = n;
            WebMolKit.Vec.setTo(atoms, -1);
            for (let n = 0; n < sz; n++) {
                atoms[n] = pos;
                if (n == sz - 1) {
                    if (requireRing)
                        if (g.getEdges(pos).indexOf(atoms[0]) < 0)
                            return false;
                }
                else {
                    let next = sz;
                    for (let i of g.getEdges(pos))
                        if (atoms.indexOf(i) < 0 && i < next)
                            next = i;
                    if (next == sz)
                        return false;
                    pos = next;
                }
            }
            for (let n = 0; n < sz; n++)
                atoms[n] = g.getIndex(atoms[n]);
            return true;
        }
        alreadyExists(atoms) {
            atoms = WebMolKit.Vec.sorted(atoms);
            for (let path of this.resPaths.values()) {
                if (WebMolKit.Vec.equals(atoms, WebMolKit.Vec.sorted(path.atoms)))
                    return true;
            }
            for (let ring of this.resRings.values()) {
                if (WebMolKit.Vec.equals(atoms, WebMolKit.Vec.sorted(ring.atoms)))
                    return true;
            }
            for (let arene of this.arenes.values()) {
                let areneAtoms = WebMolKit.Vec.append(arene.atoms, arene.centre);
                if (WebMolKit.Vec.equals(atoms, WebMolKit.Vec.sorted(areneAtoms)))
                    return true;
            }
            return false;
        }
        atomsAsPath(atoms) {
            if (atoms.length < 2)
                return null;
            let path = { 'atoms': atoms };
            if (!this.pathify(path.atoms, false))
                return null;
            return path;
        }
        atomsAsRing(atoms) {
            if (atoms.length < 3)
                return null;
            let ring = { 'atoms': atoms };
            if (!this.pathify(ring.atoms, true))
                return null;
            return ring;
        }
        atomsAsArene(atoms) {
            const sz = atoms.length;
            if (sz < 3)
                return null;
            let g = WebMolKit.Graph.fromMolecule(this.mol).subgraphIndex(WebMolKit.Vec.add(atoms, -1));
            let best = 0;
            if (sz == 3) {
                let bsum = [0, 0, 0];
                for (let n = 0; n < sz; n++) {
                    if (g.numEdges(n) != 2)
                        return null;
                    for (let e of g.getEdges(n))
                        bsum[n] += this.mol.bondOrder(this.mol.findBond(atoms[n], atoms[e]));
                    best = WebMolKit.Vec.idxMin(bsum);
                }
            }
            else {
                for (let n = 1; n < sz; n++)
                    if (g.numEdges(n) > g.numEdges(best))
                        best = n;
            }
            let arene = { 'centre': atoms[best], 'atoms': WebMolKit.Vec.remove(atoms, best) };
            if (!this.pathify(arene.atoms, false))
                return null;
            return arene;
        }
        nextIdentifier(inkeys) {
            if (inkeys.length == 0)
                return 1;
            let keys = WebMolKit.Vec.sorted(inkeys);
            for (let n = 0; n < keys.length - 1; n++)
                if (keys[n + 1] != keys[n] + 1)
                    return keys[n] + 1;
            return keys[keys.length - 1] + 1;
        }
    }
    WebMolKit.BondArtifact = BondArtifact;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class Chemistry {
    }
    Chemistry.ELEMENTS = [
        null,
        'H', 'He',
        'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne',
        'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar',
        'K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr',
        'Rb', 'Sr', 'Y', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I', 'Xe',
        'Cs', 'Ba',
        'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb',
        'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn',
        'Fr', 'Ra',
        'Ac', 'Th', 'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', 'Md', 'No',
        'Lr', 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt', 'Ds', 'Rg', 'Cn'
    ];
    Chemistry.ELEMENT_GROUPS = [
        0,
        1, 18,
        1, 2, 13, 14, 15, 16, 17, 18,
        1, 2, 13, 14, 15, 16, 17, 18,
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
        1, 2,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
        1, 2,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 4, 5, 6, 7, 8, 9, 10, 11, 12
    ];
    Chemistry.ELEMENT_ROWS = [
        0,
        1, 1,
        2, 2, 2, 2, 2, 2, 2, 2,
        3, 3, 3, 3, 3, 3, 3, 3,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7
    ];
    Chemistry.ELEMENT_BLOCKS = [
        0,
        1, 2,
        1, 1, 2, 2, 2, 2, 2, 2,
        1, 1, 2, 2, 2, 2, 2, 2,
        1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2,
        1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2,
        1, 1,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2,
        1, 1,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3
    ];
    Chemistry.ELEMENT_VALENCE = [
        0,
        1, 2,
        1, 2, 3, 4, 5, 6, 7, 8,
        1, 2, 3, 4, 5, 6, 7, 8,
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 3, 4, 5, 6, 7, 8,
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 3, 4, 5, 6, 7, 8,
        1, 2,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 3, 4, 5, 6, 7, 8,
        1, 1,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        3, 4, 5, 6, 7, 8, 9, 10, 11, 12
    ];
    Chemistry.ELEMENT_BONDING = [
        0,
        1, 0,
        1, 2, 3, 4, 3, 2, 1, 0,
        1, 2, 3, 4, 3, 2, 1, 0,
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 3, 4, 3, 2, 1, 0,
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 3, 4, 3, 2, 1, 0,
        1, 2,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 3, 4, 3, 2, 1, 0,
        1, 1,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        3, 4, 5, 6, 7, 8, 9, 10, 11, 12
    ];
    Chemistry.ELEMENT_SHELL = [
        0,
        2, 2,
        8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 8, 8, 8, 8, 8, 8,
        8, 8, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 8, 8, 8, 8, 8, 8,
        8, 8,
        18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
        18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
        8, 8,
        18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
        18, 18, 18, 18, 18, 18, 18, 18, 18, 18
    ];
    Chemistry.NATURAL_ATOMIC_WEIGHTS = [
        0, 1.00794, 4.002602, 6.941, 9.012182, 10.811, 12.0107, 14.0067, 15.9994, 18.9984032, 20.1797,
        22.989770, 24.3050, 26.981538, 28.0855, 30.973761, 32.065, 35.453, 39.948, 39.0983, 40.078,
        44.955910, 47.867, 50.9415, 51.9961, 54.938049, 55.845, 58.933200, 58.6934, 63.546, 65.409,
        69.723, 72.64, 74.92160, 78.96, 79.904, 83.798, 85.4678, 87.62, 88.90585, 91.224, 92.90638,
        95.94, 98, 101.07, 102.90550, 106.42, 107.8682, 112.411, 114.818, 118.710, 121.760, 127.60,
        126.90447, 131.293, 132.90545, 137.327, 138.9055, 140.116, 140.90765, 144.24, 145, 150.36,
        151.964, 157.25, 158.92534, 162.500, 164.93032, 167.259, 168.93421, 173.04, 174.967, 178.49,
        180.9479, 183.84, 186.207, 190.23, 192.217, 195.078, 196.96655, 200.59, 204.3833, 207.2, 208.98038,
        209, 210, 222, 223, 226, 227, 230.0331266, 231.03588, 233.039628, 237, 244, 243, 247, 247, 251, 252, 257,
        258, 259, 262, 261, 262, 266, 264, 277, 268, 271, 272, 285
    ];
    Chemistry.ELEMENT_H = 1;
    Chemistry.ELEMENT_He = 2;
    Chemistry.ELEMENT_Li = 3;
    Chemistry.ELEMENT_Be = 4;
    Chemistry.ELEMENT_B = 5;
    Chemistry.ELEMENT_C = 6;
    Chemistry.ELEMENT_N = 7;
    Chemistry.ELEMENT_O = 8;
    Chemistry.ELEMENT_F = 9;
    Chemistry.ELEMENT_Ne = 10;
    Chemistry.ELEMENT_Na = 11;
    Chemistry.ELEMENT_Mg = 12;
    Chemistry.ELEMENT_Al = 13;
    Chemistry.ELEMENT_Si = 14;
    Chemistry.ELEMENT_P = 15;
    Chemistry.ELEMENT_S = 16;
    Chemistry.ELEMENT_Cl = 17;
    Chemistry.ELEMENT_Ar = 18;
    Chemistry.ELEMENT_K = 19;
    Chemistry.ELEMENT_Ca = 20;
    Chemistry.ELEMENT_Sc = 21;
    Chemistry.ELEMENT_Ti = 22;
    Chemistry.ELEMENT_V = 23;
    Chemistry.ELEMENT_Cr = 24;
    Chemistry.ELEMENT_Mn = 25;
    Chemistry.ELEMENT_Fe = 26;
    Chemistry.ELEMENT_Co = 27;
    Chemistry.ELEMENT_Ni = 28;
    Chemistry.ELEMENT_Cu = 29;
    Chemistry.ELEMENT_Zn = 30;
    Chemistry.ELEMENT_Ga = 31;
    Chemistry.ELEMENT_Ge = 32;
    Chemistry.ELEMENT_As = 33;
    Chemistry.ELEMENT_Se = 34;
    Chemistry.ELEMENT_Br = 35;
    Chemistry.ELEMENT_Kr = 36;
    Chemistry.ELEMENT_Rb = 37;
    Chemistry.ELEMENT_Sr = 38;
    Chemistry.ELEMENT_Y = 39;
    Chemistry.ELEMENT_Zr = 40;
    Chemistry.ELEMENT_Nb = 41;
    Chemistry.ELEMENT_Mo = 42;
    Chemistry.ELEMENT_Tc = 43;
    Chemistry.ELEMENT_Ru = 44;
    Chemistry.ELEMENT_Rh = 45;
    Chemistry.ELEMENT_Pd = 46;
    Chemistry.ELEMENT_Ag = 47;
    Chemistry.ELEMENT_Cd = 48;
    Chemistry.ELEMENT_In = 49;
    Chemistry.ELEMENT_Sn = 50;
    Chemistry.ELEMENT_Sb = 51;
    Chemistry.ELEMENT_Te = 52;
    Chemistry.ELEMENT_I = 53;
    Chemistry.ELEMENT_Xe = 54;
    Chemistry.ELEMENT_Cs = 55;
    Chemistry.ELEMENT_Ba = 56;
    Chemistry.ELEMENT_La = 57;
    Chemistry.ELEMENT_Ce = 58;
    Chemistry.ELEMENT_Pr = 59;
    Chemistry.ELEMENT_Nd = 60;
    Chemistry.ELEMENT_Pm = 61;
    Chemistry.ELEMENT_Sm = 62;
    Chemistry.ELEMENT_Eu = 63;
    Chemistry.ELEMENT_Gd = 64;
    Chemistry.ELEMENT_Tb = 65;
    Chemistry.ELEMENT_Dy = 66;
    Chemistry.ELEMENT_Ho = 67;
    Chemistry.ELEMENT_Er = 68;
    Chemistry.ELEMENT_Tm = 69;
    Chemistry.ELEMENT_Yb = 70;
    Chemistry.ELEMENT_Lu = 71;
    Chemistry.ELEMENT_Hf = 72;
    Chemistry.ELEMENT_Ta = 73;
    Chemistry.ELEMENT_W = 74;
    Chemistry.ELEMENT_Re = 75;
    Chemistry.ELEMENT_Os = 76;
    Chemistry.ELEMENT_Ir = 77;
    Chemistry.ELEMENT_Pt = 78;
    Chemistry.ELEMENT_Au = 79;
    Chemistry.ELEMENT_Hg = 80;
    Chemistry.ELEMENT_Tl = 81;
    Chemistry.ELEMENT_Pb = 82;
    Chemistry.ELEMENT_Bi = 83;
    Chemistry.ELEMENT_Po = 84;
    Chemistry.ELEMENT_At = 85;
    Chemistry.ELEMENT_Rn = 86;
    Chemistry.ELEMENT_Fr = 87;
    Chemistry.ELEMENT_Ra = 88;
    Chemistry.ELEMENT_Ac = 89;
    Chemistry.ELEMENT_Th = 90;
    Chemistry.ELEMENT_Pa = 91;
    Chemistry.ELEMENT_U = 92;
    Chemistry.ELEMENT_Np = 93;
    Chemistry.ELEMENT_Pu = 94;
    Chemistry.ELEMENT_Am = 95;
    Chemistry.ELEMENT_Cm = 96;
    Chemistry.ELEMENT_Bk = 97;
    Chemistry.ELEMENT_Cf = 98;
    Chemistry.ELEMENT_Es = 99;
    Chemistry.ELEMENT_Fm = 100;
    Chemistry.ELEMENT_Md = 101;
    Chemistry.ELEMENT_No = 102;
    Chemistry.ELEMENT_Lr = 103;
    Chemistry.ELEMENT_Rf = 104;
    Chemistry.ELEMENT_Db = 105;
    Chemistry.ELEMENT_Sg = 106;
    Chemistry.ELEMENT_Bh = 107;
    Chemistry.ELEMENT_Hs = 108;
    Chemistry.ELEMENT_Mt = 109;
    Chemistry.ELEMENT_Ds = 110;
    Chemistry.ELEMENT_Rg = 111;
    Chemistry.ELEMENT_Cn = 112;
    WebMolKit.Chemistry = Chemistry;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class CoordUtil {
        static atomAtPoint(mol, x, y, tolerance) {
            if (tolerance == null)
                tolerance = CoordUtil.OVERLAP_THRESHOLD;
            const tolsq = tolerance * tolerance;
            for (let n = 1; n <= mol.numAtoms; n++)
                if (WebMolKit.norm2_xy(mol.atomX(n) - x, mol.atomY(n) - y) < tolsq)
                    return n;
            return 0;
        }
        static sketchEquivalent(mol1, mol2, tolerance) {
            if (tolerance == null)
                tolerance = CoordUtil.DEFAULT_EQUIV_TOLERANCE;
            const na = mol1.numAtoms, nb = mol1.numBonds;
            if (na != mol2.numAtoms || nb != mol2.numBonds)
                return false;
            const tolsq = tolerance * tolerance;
            let box1 = mol1.boundary(), box2 = mol2.boundary();
            if (Math.abs(box1.minX() - box2.minX()) > tolerance)
                return false;
            if (Math.abs(box1.minY() - box2.minY()) > tolerance)
                return false;
            if (Math.abs(box1.maxX() - box2.maxX()) > tolerance)
                return false;
            if (Math.abs(box1.maxY() - box2.maxY()) > tolerance)
                return false;
            let mx1 = WebMolKit.MolUtil.arrayAtomX(mol1), my1 = WebMolKit.MolUtil.arrayAtomY(mol1);
            let mx2 = WebMolKit.MolUtil.arrayAtomX(mol2), my2 = WebMolKit.MolUtil.arrayAtomY(mol2);
            let map = WebMolKit.Vec.numberArray(0, na);
            let mask = WebMolKit.Vec.booleanArray(false, na);
            for (let i = 0; i < na; i++) {
                let j = -1;
                if (WebMolKit.norm2_xy(mx1[i] - mx2[i], my1[i] - my2[i]) < tolsq)
                    j = i;
                if (j < 0) {
                    let bestdsq = Number.MAX_VALUE;
                    for (let n = 0; n < na; n++)
                        if (!mask[n]) {
                            let dsq = WebMolKit.norm2_xy(mx1[i] - mx2[n], my1[i] - my2[n]);
                            if (dsq < bestdsq) {
                                bestdsq = dsq;
                                j = n;
                            }
                        }
                    if (j < 0 || bestdsq > tolsq)
                        return false;
                }
                map[i] = j + 1;
                mask[j] = true;
                if (mol1.atomElement(i + 1) != mol2.atomElement(j + 1))
                    return false;
                if (mol1.atomCharge(i + 1) != mol2.atomCharge(j + 1))
                    return false;
                if (mol1.atomUnpaired(i + 1) != mol2.atomUnpaired(j + 1))
                    return false;
                if (mol1.atomHExplicit(i + 1) != mol2.atomHExplicit(j + 1) &&
                    mol1.atomHExplicit(i + 1) != WebMolKit.Molecule.HEXPLICIT_UNKNOWN &&
                    mol2.atomHExplicit(j + 1) != WebMolKit.Molecule.HEXPLICIT_UNKNOWN)
                    return false;
            }
            for (let i = 1; i <= nb; i++) {
                let i1 = mol1.bondFrom(i), i2 = mol1.bondTo(i), j1 = map[i1 - 1], j2 = map[i2 - 1];
                let j = mol2.findBond(j1, j2);
                if (j == 0)
                    return false;
                if (mol1.bondOrder(i) != mol2.bondOrder(j) || mol1.bondType(i) != mol2.bondType(j))
                    return false;
                if (mol2.bondFrom(j) == j1 && mol2.bondTo(j) == j2) { }
                else if (mol2.bondType(j) != WebMolKit.Molecule.BONDTYPE_INCLINED &&
                    mol2.bondType(j) != WebMolKit.Molecule.BONDTYPE_DECLINED &&
                    mol2.bondFrom(j) == j2 && mol2.bondTo(j) == j1) { }
                else
                    return false;
            }
            return true;
        }
        static sketchMappable(mol1, mol2, tolerance) {
            if (tolerance == null)
                tolerance = CoordUtil.DEFAULT_EQUIV_TOLERANCE;
            let box1 = mol1.boundary(), box2 = mol2.boundary();
            let dx = box1.minX() - box2.minX(), dy = box1.minY() - box2.minY();
            if (Math.abs(dx) > tolerance * 0.1 || Math.abs(dy) > tolerance * 0.1) {
                mol2 = mol2.clone();
                for (let n = 1; n <= mol2.numAtoms; n++)
                    mol2.setAtomPos(n, mol2.atomX(n) + dx, mol2.atomY(n) + dy);
            }
            return CoordUtil.sketchEquivalent(mol1, mol2, tolerance);
        }
        static atomBondAngles(mol, atom, adj) {
            if (adj == null)
                adj = mol.atomAdjList(atom);
            let bndang = [];
            let cx = mol.atomX(atom), cy = mol.atomY(atom);
            for (let a of adj)
                bndang.push(Math.atan2(mol.atomY(a) - cy, mol.atomX(a) - cx));
            return bndang;
        }
        static overlapsAtom(mol, x, y, tol) {
            const tolsq = tol * tol;
            for (let n = 1; n <= mol.numAtoms; n++)
                if (WebMolKit.norm2_xy(mol.atomX(n) - x, mol.atomY(n) - y) < tolsq)
                    return true;
            return false;
        }
        static overlappingAtomMask(mol, thresh) {
            if (thresh == null)
                thresh = CoordUtil.OVERLAP_THRESHOLD;
            const sz = mol.numAtoms;
            let box = mol.boundary();
            let p1, p2;
            if (box.w > box.h) {
                p1 = WebMolKit.MolUtil.arrayAtomX(mol);
                p2 = WebMolKit.MolUtil.arrayAtomY(mol);
            }
            else {
                p1 = WebMolKit.MolUtil.arrayAtomY(mol);
                p2 = WebMolKit.MolUtil.arrayAtomX(mol);
            }
            let omask = WebMolKit.Vec.booleanArray(false, sz);
            let idx = WebMolKit.Vec.idxSort(p1);
            const threshSQ = thresh * thresh;
            for (let i = 1; i < sz - 1; i++) {
                for (let j = i - 1; j >= 0; j--) {
                    let d1 = p1[idx[i]] - p1[idx[j]];
                    if (d1 > thresh)
                        break;
                    if (WebMolKit.norm2_xy(d1, p2[idx[i]] - p2[idx[j]]) < threshSQ) {
                        omask[idx[i]] = true;
                        omask[idx[j]] = true;
                    }
                }
                for (let j = i + 1; j < sz; j++) {
                    let d1 = p1[idx[j]] - p1[idx[i]];
                    if (d1 > thresh)
                        break;
                    if (WebMolKit.norm2_xy(d1, p2[idx[j]] - p2[idx[i]]) < threshSQ) {
                        omask[idx[i]] = true;
                        omask[idx[j]] = true;
                    }
                }
            }
            return omask;
        }
        static overlappingAtomList(mol, thresh) {
            if (thresh == null)
                thresh = CoordUtil.OVERLAP_THRESHOLD;
            return WebMolKit.Vec.add(WebMolKit.Vec.maskIdx(CoordUtil.overlappingAtomMask(mol, thresh)), 1);
        }
        static congestionPoint(mol, x, y, approach) {
            if (approach == null)
                approach = 1E-5;
            let score = 0;
            let na = mol.numAtoms;
            for (let n = 1; n <= na; n++)
                score += 1.0 / (approach + WebMolKit.norm2_xy(mol.atomX(n) - x, mol.atomY(n) - y));
            return score;
        }
        static congestionMolecule(mol, approach) {
            if (approach == null)
                approach = 1E-5;
            let score = 0;
            const na = mol.numAtoms;
            let mx = WebMolKit.MolUtil.arrayAtomX(mol), my = WebMolKit.MolUtil.arrayAtomY(mol);
            for (let i = 0; i < na - 1; i++)
                for (let j = i + 1; j < na; j++)
                    score += 1.0 / (approach + WebMolKit.norm2_xy(mx[i] - mx[j], my[i] - my[j]));
            return score;
        }
        static translateMolecule(mol, ox, oy) {
            for (let n = 1; n <= mol.numAtoms; n++)
                mol.setAtomPos(n, mol.atomX(n) + ox, mol.atomY(n) + oy);
        }
        static rotateMolecule(mol, theta, cx, cy) {
            if (cx == null || cy == null) {
                let box = mol.boundary();
                cx = box.midX();
                cy = box.midY();
            }
            let cosTheta = Math.cos(theta), sinTheta = Math.sin(theta);
            for (let n = 1; n <= mol.numAtoms; n++) {
                let x = mol.atomX(n) - cx, y = mol.atomY(n) - cy;
                mol.setAtomPos(n, cx + x * cosTheta - y * sinTheta, cy + x * sinTheta + y * cosTheta);
            }
        }
        static rotateBond(mol, centre, atom, theta) {
            theta = WebMolKit.angleNorm(theta);
            if (Math.abs(theta) < 0.1 * WebMolKit.DEGRAD)
                return;
            let g = WebMolKit.Graph.fromMolecule(mol);
            g.isolateNode(centre - 1);
            let cc = g.calculateComponents();
            let cx = mol.atomX(centre), cy = mol.atomY(centre);
            let cosTheta = Math.cos(theta), sinTheta = Math.sin(theta);
            for (let n = 1; n <= mol.numAtoms; n++)
                if (cc[n - 1] == cc[atom - 1]) {
                    let x = mol.atomX(n) - cx, y = mol.atomY(n) - cy;
                    mol.setAtomPos(n, cx + x * cosTheta - y * sinTheta, cy + x * sinTheta + y * cosTheta);
                }
        }
        static rotateAtoms(mol, mask, cx, cy, theta) {
            let cosTheta = Math.cos(theta), sinTheta = Math.sin(theta);
            for (let n = 1; n <= mol.numAtoms; n++)
                if (mask[n - 1]) {
                    let x = mol.atomX(n) - cx, y = mol.atomY(n) - cy;
                    mol.setAtomPos(n, cx + x * cosTheta - y * sinTheta, cy + x * sinTheta + y * cosTheta);
                }
        }
        static angleNeighbours(mol, atom) {
            let adj = mol.atomAdjList(atom);
            if (adj.length <= 1)
                return null;
            let th = [];
            for (let n = 0; n < adj.length; n++)
                th.push(Math.atan2(mol.atomY(adj[n]) - mol.atomY(atom), mol.atomX(adj[n]) - mol.atomX(atom)));
            if (adj.length == 2) {
                if (WebMolKit.angleDiff(th[1], th[0]) > 0)
                    return adj;
                return [adj[1], adj[0]];
            }
            let idx = WebMolKit.Vec.idxSort(th);
            return WebMolKit.Vec.idxGet(adj, idx);
        }
        static mergeAtoms(mol, oldN, newN) {
            for (let n = 1; n <= mol.numBonds; n++) {
                if (mol.bondFrom(n) == oldN)
                    mol.setBondFrom(n, newN);
                if (mol.bondTo(n) == oldN)
                    mol.setBondTo(n, newN);
            }
            mol.deleteAtomAndBonds(oldN);
        }
        static normaliseBondDistances(mol) {
            const nb = mol.numBonds;
            if (nb == 0)
                return;
            let dsq = [];
            for (let n = 1; n <= nb; n++) {
                let bfr = mol.bondFrom(n), bto = mol.bondTo(n);
                dsq.push(WebMolKit.norm2_xy(mol.atomX(bto) - mol.atomX(bfr), mol.atomY(bto) - mol.atomY(bfr)));
            }
            WebMolKit.Vec.sort(dsq);
            let median = (nb & 1) == 1 ? Math.sqrt(dsq[nb >> 1]) : 0.5 * (Math.sqrt(dsq[nb >> 1]) + Math.sqrt(dsq[(nb >> 1) - 1]));
            if (median < 0.1 || (median > WebMolKit.Molecule.IDEALBOND * 0.9 && median < WebMolKit.Molecule.IDEALBOND * 1.1))
                return;
            let box = mol.boundary();
            let cx = box.midX(), cy = box.midY();
            let scale = WebMolKit.Molecule.IDEALBOND / median;
            for (let n = mol.numAtoms; n >= 1; n--) {
                let x = (mol.atomX(n) - cx) * scale + cx;
                let y = (mol.atomY(n) - cy) * scale + cy;
                mol.setAtomPos(n, x, y);
            }
        }
        static mirrorImage(mol) {
            mol = mol.clone();
            for (let n = 1; n <= mol.numAtoms; n++)
                mol.setAtomX(n, -mol.atomX(n));
            for (let n = 1; n <= mol.numBonds; n++) {
                if (mol.bondType(n) == WebMolKit.Molecule.BONDTYPE_DECLINED)
                    mol.setBondType(n, WebMolKit.Molecule.BONDTYPE_INCLINED);
                else if (mol.bondType(n) == WebMolKit.Molecule.BONDTYPE_INCLINED)
                    mol.setBondType(n, WebMolKit.Molecule.BONDTYPE_DECLINED);
            }
            return mol;
        }
        static alignOrientFlip(mol1, idx1, mol2, idx2) {
            if (idx1.length < 2 || idx1.length != idx2.length)
                throw 'Invalid mapping indices.';
            let x0 = mol1.atomX(idx1[0]), y0 = mol1.atomY(idx1[0]);
            CoordUtil.translateMolecule(mol2, x0 - mol2.atomX(idx2[0]), y0 - mol2.atomY(idx2[0]));
            const sz = idx1.length - 1;
            let th1 = [], th2 = [];
            let deltaA = 0, deltaB = 0;
            for (let n = 0; n < sz; n++) {
                th1.push(Math.atan2(mol1.atomY(idx1[n + 1]) - y0, mol1.atomX(idx1[n + 1]) - x0));
                th2.push(Math.atan2(mol2.atomY(idx2[n + 1]) - y0, mol2.atomX(idx2[n + 1]) - x0));
                let dthA = WebMolKit.angleDiff(th1[n], th2[n]), dthB = WebMolKit.angleDiff(th1[n], -th2[n]);
                if (dthA < -175 * WebMolKit.DEGRAD && deltaA > 0)
                    dthA += WebMolKit.TWOPI;
                else if (dthA > 175 * WebMolKit.DEGRAD && deltaA < 0)
                    dthA -= WebMolKit.TWOPI;
                if (dthB < -175 * WebMolKit.DEGRAD && deltaB > 0)
                    dthB += WebMolKit.TWOPI;
                else if (dthB > 175 * WebMolKit.DEGRAD && deltaB < 0)
                    dthB -= WebMolKit.TWOPI;
                deltaA += dthA;
                deltaB += dthB;
            }
            if (sz > 1) {
                let inv = 1.0 / sz;
                deltaA *= inv;
                deltaB *= inv;
            }
            let scoreA = 0, scoreB = 0;
            for (let n = 0; n < sz; n++) {
                scoreA += Math.abs(WebMolKit.angleDiff(th1[n], th2[n] + deltaA));
                scoreB += Math.abs(WebMolKit.angleDiff(th1[n], -th2[n] + deltaB));
            }
            if (scoreB < scoreA) {
                for (let n = 1; n <= mol2.numAtoms; n++)
                    mol2.setAtomY(n, 2 * y0 - mol2.atomY(n));
                for (let n = 1; n <= mol2.numBonds; n++) {
                    if (mol2.bondType(n) == WebMolKit.Molecule.BONDTYPE_DECLINED)
                        mol2.setBondType(n, WebMolKit.Molecule.BONDTYPE_INCLINED);
                    else if (mol2.bondType(n) == WebMolKit.Molecule.BONDTYPE_INCLINED)
                        mol2.setBondType(n, WebMolKit.Molecule.BONDTYPE_DECLINED);
                }
                CoordUtil.rotateMolecule(mol2, x0, y0, deltaB);
            }
            else
                CoordUtil.rotateMolecule(mol2, x0, y0, deltaA);
        }
    }
    CoordUtil.OVERLAP_THRESHOLD = 0.2;
    CoordUtil.OVERLAP_THRESHOLD_SQ = CoordUtil.OVERLAP_THRESHOLD * CoordUtil.OVERLAP_THRESHOLD;
    CoordUtil.DEFAULT_EQUIV_TOLERANCE = 0.2;
    WebMolKit.CoordUtil = CoordUtil;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let DataSheetColumn;
    (function (DataSheetColumn) {
        DataSheetColumn["Molecule"] = "molecule";
        DataSheetColumn["String"] = "string";
        DataSheetColumn["Real"] = "real";
        DataSheetColumn["Integer"] = "integer";
        DataSheetColumn["Boolean"] = "boolean";
        DataSheetColumn["Extend"] = "extend";
    })(DataSheetColumn = WebMolKit.DataSheetColumn || (WebMolKit.DataSheetColumn = {}));
    class DataSheet {
        constructor(data) {
            if (!data)
                data = {};
            if (!data.title)
                data.title = '';
            if (!data.description)
                data.description = '';
            if (data.numCols == null)
                data.numCols = WebMolKit.Vec.len(data.colData);
            if (data.numRows == null)
                data.numRows = WebMolKit.Vec.len(data.rowData);
            if (data.numExtens == null)
                data.numExtens = WebMolKit.Vec.len(data.extData);
            if (data.colData == null)
                data.colData = [];
            if (data.rowData == null)
                data.rowData = [];
            if (data.extData == null)
                data.extData = [];
            this.data = data;
        }
        clone(withRows = true) {
            let { numCols, numRows, colData, rowData } = this.data;
            let data = {
                'title': this.data.title,
                'description': this.data.description,
                'numCols': numCols,
                'numRows': withRows ? numRows : 0,
                'numExtens': this.data.numExtens,
                'colData': WebMolKit.deepClone(colData),
                'rowData': withRows ? new Array(numRows) : [],
                'extData': WebMolKit.deepClone(this.data.extData),
            };
            if (withRows)
                for (let r = 0; r < numRows; r++) {
                    let inRow = rowData[r], outRow = new Array(numCols);
                    for (let c = 0; c < numCols; c++) {
                        if (inRow[c] != null && colData[c].type == "molecule" && inRow[c] instanceof WebMolKit.Molecule)
                            outRow[c] = inRow[c].clone();
                        else
                            outRow[c] = inRow[c];
                    }
                    data.rowData[r] = outRow;
                }
            return new DataSheet(data);
        }
        cloneMask(colMask, rowMask = null, inclExtn = true) {
            let { numCols, numRows, colData, rowData } = this.data;
            let data = {
                'title': this.data.title,
                'description': this.data.description,
                'numCols': WebMolKit.Vec.maskCount(colMask),
                'numRows': rowMask ? WebMolKit.Vec.maskCount(rowMask) : 0,
                'numExtens': inclExtn ? this.data.numExtens : 0,
                'colData': WebMolKit.deepClone(WebMolKit.Vec.maskGet(colData, colMask)),
                'rowData': [],
                'extData': inclExtn ? WebMolKit.deepClone(this.data.extData) : [],
            };
            if (rowMask)
                for (let r = 0; r < numRows; r++)
                    if (rowMask[r]) {
                        let inRow = rowData[r], outRow = WebMolKit.Vec.maskGet(inRow, colMask);
                        data.rowData.push(outRow);
                    }
            const { 'colData': outCols, 'rowData': outRows } = data;
            for (let c = outCols.length - 1; c >= 0; c--)
                if (outCols[c].type == "molecule") {
                    for (let r = outRows.length - 1; r >= 0; r--)
                        if (outRows[r][c] != null && outRows[r][c] instanceof WebMolKit.Molecule)
                            outRows[r][c] = outRows[r][c].clone();
                }
            return new DataSheet(data);
        }
        getData() {
            return this.data;
        }
        get numCols() {
            return this.data.numCols;
        }
        get numRows() {
            return this.data.numRows;
        }
        get title() { return this.data.title; }
        set title(title) { this.data.title = title; }
        get description() { return this.data.description; }
        set description(description) { this.data.description = description; }
        get numExtensions() {
            return this.data.numExtens;
        }
        getExtName(idx) {
            return this.data.extData[idx].name;
        }
        getExtType(idx) {
            return this.data.extData[idx].type;
        }
        getExtData(idx) {
            return this.data.extData[idx].data;
        }
        setExtName(idx, val) {
            this.data.extData[idx].name = val;
        }
        setExtType(idx, val) {
            this.data.extData[idx].type = val;
        }
        setExtData(idx, val) {
            this.data.extData[idx].data = val;
        }
        appendExtension(name, type, data) {
            this.data.numExtens++;
            this.data.extData.push({ 'name': name, 'type': type, 'data': data });
            return this.data.numExtens - 1;
        }
        insertExtension(idx, name, type, data) {
            this.data.numExtens++;
            this.data.extData.splice(idx, 0, { 'name': name, 'type': type, 'data': data });
        }
        deleteExtension(idx) {
            this.data.extData.splice(idx, 1);
            this.data.numExtens--;
        }
        colName(col) {
            return this.data.colData[col].name;
        }
        colType(col) {
            return this.data.colData[col].type;
        }
        colDescr(col) {
            return this.data.colData[col].descr;
        }
        isNull(row, col) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return null;
            return this.data.rowData[row][col] == null;
        }
        notNull(row, col) {
            return !this.isNull(row, col);
        }
        isBlank(row, col) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (this.isNull(row, col))
                return true;
            let ct = this.colType(col);
            if (ct == "molecule")
                return this.getMolecule(row, col).numAtoms == 0;
            if (ct == "string")
                return this.getString(row, col).length == 0;
            if (ct == "extend")
                return this.getExtend(row, col).length == 0;
            return false;
        }
        notBlank(row, col) {
            return !this.isBlank(row, col);
        }
        getObject(row, col) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            return this.data.rowData[row][col];
        }
        getMolecule(row, col) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return null;
            let datum = this.data.rowData[row][col];
            if (datum == null)
                return null;
            if (typeof datum === 'string') {
                datum = WebMolKit.Molecule.fromString(datum);
                this.data.rowData[row][col] = datum;
            }
            return datum;
        }
        getMoleculeClone(row, col) {
            let mol = this.getMolecule(row, col);
            return mol == null ? null : mol.clone();
        }
        getMoleculeBlank(row, col) {
            let mol = this.getMolecule(row, col);
            return mol ? mol : new WebMolKit.Molecule();
        }
        getString(row, col) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return null;
            let str = this.data.rowData[row][col];
            return str == null ? '' : str;
        }
        getInteger(row, col) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return null;
            return this.data.rowData[row][col];
        }
        getReal(row, col) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return null;
            return this.data.rowData[row][col];
        }
        getBoolean(row, col) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return null;
            return this.data.rowData[row][col];
        }
        getExtend(row, col) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return null;
            return this.data.rowData[row][col];
        }
        setToNull(row, col) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return;
            this.data.rowData[row][col] = null;
        }
        setObject(row, col, val) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return;
            this.data.rowData[row][col] = val;
        }
        setMolecule(row, col, mol) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return;
            this.data.rowData[row][col] = mol ? mol.clone() : null;
        }
        setString(row, col, val) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return;
            this.data.rowData[row][col] = val;
        }
        setInteger(row, col, val) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return;
            this.data.rowData[row][col] = val;
        }
        setReal(row, col, val) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return;
            this.data.rowData[row][col] = val;
        }
        setBoolean(row, col, val) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return;
            this.data.rowData[row][col] = val;
        }
        setExtend(row, col, val) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (col < 0)
                return;
            this.data.rowData[row][col] = val;
        }
        isEqualMolecule(row, col, mol) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (this.isNull(row, col) != (mol == null))
                return false;
            if (mol == null)
                return true;
            return this.getMolecule(row, col).compareTo(mol) == 0;
        }
        isEqualString(row, col, val) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (this.isNull(row, col) != (val == null || val == ''))
                return false;
            if (val == null || val == '')
                return true;
            return this.getString(row, col) == val;
        }
        isEqualInteger(row, col, val) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (this.isNull(row, col) != (val == null))
                return false;
            if (val == null)
                return true;
            return this.getInteger(row, col) == val;
        }
        isEqualReal(row, col, val) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (this.isNull(row, col) != (val == null))
                return false;
            if (val == null)
                return true;
            return this.getReal(row, col) == val;
        }
        isEqualBoolean(row, col, val) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            if (this.isNull(row, col) != (val == null))
                return false;
            if (val == null)
                return true;
            return this.getBoolean(row, col) == val;
        }
        appendColumn(name, type, descr) {
            this.data.numCols++;
            this.data.colData.push({ 'name': name, 'type': type, 'descr': descr });
            for (let n = 0; n < this.data.numRows; n++)
                this.data.rowData[n].push(null);
            return this.data.numCols - 1;
        }
        insertColumn(col, name, type, descr) {
            this.data.numCols++;
            this.data.colData.splice(col, 0, { 'name': name, 'type': type, 'descr': descr });
            for (let n = 0; n < this.data.numRows; n++)
                this.data.rowData[n].splice(col, 0, null);
        }
        deleteColumn(col) {
            this.data.numCols--;
            this.data.colData.splice(col, 1);
            for (let n = 0; n < this.data.numRows; n++)
                this.data.rowData[n].splice(col, 1);
        }
        changeColumnName(col, name, descr) {
            this.data.colData[col].name = name;
            this.data.colData[col].descr = descr;
        }
        changeColumnType(col, newType) {
            let oldType = this.colType(col);
            if (oldType == newType)
                return;
            let incompatible = oldType == "molecule" || newType == "molecule" ||
                oldType == "extend" || newType == "extend";
            for (let n = this.data.rowData.length - 1; n >= 0; n--) {
                let row = this.data.rowData[n];
                if (row[col] == null)
                    continue;
                if (incompatible) {
                    row[col] = null;
                    continue;
                }
                let val = '';
                if (oldType == "string")
                    val = row[col];
                else if (oldType == "integer")
                    val = row[col].toString();
                else if (oldType == "real")
                    val = row[col].toString();
                else if (oldType == "boolean")
                    val = row[col] ? 'true' : 'false';
                row[col] = null;
                if (newType == "string")
                    row[col] = val;
                else if (newType == "integer") {
                    let num = parseInt(val);
                    row[col] = isFinite(num) ? num : null;
                }
                else if (newType == "real") {
                    let num = parseFloat(val);
                    row[col] = isFinite(num) ? num : null;
                }
                else if (newType == "boolean")
                    row[col] = val.toLowerCase() == 'true' ? true : false;
            }
            this.data.colData[col].type = newType;
        }
        ensureColumn(name, type, descr) {
            for (let n = 0; n < this.data.numCols; n++)
                if (this.data.colData[n].name == name) {
                    if (this.data.colData[n].type != type)
                        this.changeColumnType(n, type);
                    this.data.colData[n].descr = descr;
                    return n;
                }
            return this.appendColumn(name, type, descr);
        }
        reorderColumns(order) {
            let identity = true;
            for (let n = 0; n < order.length - 1; n++)
                if (order[n] != order[n + 1] - 1) {
                    identity = false;
                    break;
                }
            if (identity)
                return;
            this.data.colData = WebMolKit.Vec.idxGet(this.data.colData, order);
            for (let n = 0; n < this.data.numRows; n++)
                this.data.rowData[n] = WebMolKit.Vec.idxGet(this.data.rowData[n], order);
        }
        appendRow() {
            this.data.numRows++;
            let row = new Array();
            for (let n = 0; n < this.data.numCols; n++)
                row.push(null);
            this.data.rowData.push(row);
            return this.data.numRows - 1;
        }
        appendRowFrom(srcDS, row) {
            this.data.numRows++;
            this.data.rowData.push(srcDS.data.rowData[row].slice(0));
            return this.data.numRows - 1;
        }
        insertRow(row) {
            this.data.numRows++;
            let data = new Array();
            for (let n = 0; n < this.data.numCols; n++)
                data.push(null);
            this.data.rowData.splice(row, 0, data);
        }
        deleteRow(row) {
            this.data.numRows--;
            this.data.rowData.splice(row, 1);
        }
        deleteAllRows() {
            this.data.numRows = 0;
            this.data.rowData = new Array();
        }
        moveRowUp(row) {
            let data = this.data.rowData[row];
            this.data.rowData[row] = this.data.rowData[row - 1];
            this.data.rowData[row - 1] = data;
        }
        moveRowDown(row) {
            let data = this.data.rowData[row];
            this.data.rowData[row] = this.data.rowData[row + 1];
            this.data.rowData[row + 1] = data;
        }
        swapRows(row1, row2) {
            WebMolKit.Vec.swap(this.data.rowData, row1, row2);
        }
        exciseSingleRow(row) {
            let newData = {
                'title': this.data.title,
                'description': this.data.description,
                'numCols': this.data.numCols,
                'numRows': 1,
                'numExtens': this.data.numExtens,
                'colData': this.data.colData.slice(0),
                'rowData': [this.data.rowData[row].slice(0)],
                'extData': this.data.extData.slice(0)
            };
            return new DataSheet(newData);
        }
        colIsPrimitive(col) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            let ct = this.data.colData[col].type;
            return ct == 'string' || ct == 'real' || ct == 'integer' || ct == 'boolean';
        }
        findColByName(name, type) {
            for (let n = 0; n < this.data.numCols; n++)
                if (this.data.colData[n].name == name) {
                    if (type == null || this.data.colData[n].type == type)
                        return n;
                }
            return -1;
        }
        firstColOfType(type) {
            for (let n = 0; n < this.data.numCols; n++)
                if (this.data.colData[n].type == type)
                    return n;
            return -1;
        }
        copyCell(toRow, toCol, fromDS, fromRow, fromCol) {
            this.setToNull(toRow, toCol);
            if (fromDS.isNull(fromRow, fromCol))
                return;
            let obj = fromDS.getObject(fromRow, fromCol);
            this.setObject(toRow, toCol, DataSheet.convertType(obj, fromDS.colType(fromCol), this.colType(toCol)));
        }
        static convertType(obj, fromType, toType) {
            const ft = fromType, tt = toType;
            if (obj == null || ft == tt || (typeof obj == 'string' && obj == ''))
                return obj;
            if (tt == "string") {
                if (ft == "integer")
                    return obj.toSring();
                else if (ft == "real")
                    return obj.toString();
                else if (ft == "boolean")
                    return obj ? 'true' : 'false';
            }
            else if (tt == "real") {
                if (ft == "string")
                    return WebMolKit.safeFloat(obj, null);
                else if (ft == "integer")
                    return obj;
                else if (ft == "boolean")
                    return obj ? 1 : 0;
            }
            else if (tt == "integer") {
                if (ft == "string")
                    return WebMolKit.safeInt(obj, null);
                else if (ft == "real")
                    return Math.round(obj);
                else if (ft == "boolean")
                    return obj ? 1 : 0;
            }
            else if (tt == "boolean") {
                if (ft == "string")
                    return obj.toLowerCase() == 'true';
                else if (ft == "integer")
                    return obj > 0;
                else if (ft == "real")
                    return obj >= 0.5;
            }
            return null;
        }
        toString(row, col) {
            if (typeof col === 'string')
                col = this.findColByName(col);
            let obj = this.data.rowData[row][col];
            return obj == null ? null : obj.toString();
        }
        toInt(row, col) {
            if (!this.colIsPrimitive(col))
                return null;
            let obj = this.data.rowData[row][col];
            return obj == null ? null : parseInt(obj);
        }
        toReal(row, col) {
            if (!this.colIsPrimitive(col))
                return null;
            let obj = this.data.rowData[row][col];
            return obj == null ? null : parseFloat(obj);
        }
    }
    WebMolKit.DataSheet = DataSheet;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class DataSheetStream {
        static readXML(strXML) {
            let xmlDoc;
            if (WebMolKit.XML.customParser)
                xmlDoc = new WebMolKit.XML.customParser().parseFromString(strXML, 'application/xml');
            else
                xmlDoc = new DOMParser().parseFromString(strXML, 'application/xml');
            if (xmlDoc == null)
                return null;
            let root = xmlDoc.documentElement;
            if (root == null)
                return null;
            let ds = new WebMolKit.DataSheet();
            let summary = WebMolKit.findNode(root, 'Summary');
            if (summary == null)
                return null;
            ds.title = WebMolKit.nodeText(WebMolKit.findNode(summary, 'Title'));
            ds.description = WebMolKit.nodeText(WebMolKit.findNode(summary, 'Description'));
            let extRoot = WebMolKit.findNode(root, 'Extension');
            if (extRoot != null) {
                let extList = WebMolKit.findNodes(extRoot, 'Ext');
                for (let n = 0; n < extList.length; n++) {
                    let ext = extList[n];
                    ds.appendExtension(ext.getAttribute('name'), ext.getAttribute('type'), WebMolKit.nodeText(ext));
                }
            }
            let header = WebMolKit.findNode(root, 'Header');
            let numCols = parseInt(header.getAttribute('ncols'));
            let colList = WebMolKit.findNodes(header, 'Column');
            if (colList.length != numCols)
                return null;
            for (let n = 0; n < numCols; n++) {
                let col = colList[n];
                let id = parseInt(col.getAttribute('id'));
                if (id != n + 1)
                    return null;
                ds.appendColumn(col.getAttribute('name'), col.getAttribute('type'), WebMolKit.nodeText(col));
            }
            let rowidx = 0;
            for (let row of WebMolKit.findNodes(WebMolKit.findNode(root, 'Content'), 'Row')) {
                if (parseInt(row.getAttribute('id')) != rowidx + 1)
                    return null;
                ds.appendRow();
                for (let col of WebMolKit.findNodes(row, 'Cell')) {
                    let colidx = parseInt(col.getAttribute('id')) - 1;
                    let ct = ds.colType(colidx), val = WebMolKit.nodeText(col);
                    if (val == '') { }
                    else if (ct == "molecule")
                        ds.setObject(rowidx, colidx, val);
                    else if (ct == "string")
                        ds.setString(rowidx, colidx, val);
                    else if (ct == "real")
                        ds.setReal(rowidx, colidx, parseFloat(val));
                    else if (ct == "integer")
                        ds.setInteger(rowidx, colidx, parseInt(val));
                    else if (ct == "boolean")
                        ds.setBoolean(rowidx, colidx, val == 'true' ? true : val == 'false' ? false : null);
                    else if (ct == "extend")
                        ds.setExtend(rowidx, colidx, val);
                    col = col.nextElementSibling;
                    colidx++;
                }
                row = row.nextElementSibling;
                rowidx++;
            }
            return ds;
        }
        static readJSON(json) {
            if (!json.colData || !json.rowData)
                throw 'Not a JSON-formatted datasheet.';
            return new WebMolKit.DataSheet(WebMolKit.deepClone(json));
        }
        static writeXML(ds) {
            let xml;
            if (WebMolKit.XML.customParser)
                xml = new WebMolKit.XML.customParser().parseFromString('<DataSheet/>', 'application/xml');
            else
                xml = new DOMParser().parseFromString('<DataSheet/>', 'application/xml');
            let summary = xml.createElement('Summary');
            xml.documentElement.appendChild(summary);
            let title = xml.createElement('Title'), descr = xml.createElement('Description');
            summary.appendChild(title);
            title.appendChild(xml.createTextNode(ds.title));
            summary.appendChild(descr);
            descr.appendChild(xml.createCDATASection(ds.description));
            let extension = xml.createElement('Extension');
            xml.documentElement.appendChild(extension);
            for (let n = 0; n < ds.numExtensions; n++) {
                let ext = xml.createElement('Ext');
                extension.appendChild(ext);
                ext.setAttribute('name', ds.getExtName(n));
                ext.setAttribute('type', ds.getExtType(n));
                ext.appendChild(xml.createCDATASection(ds.getExtData(n)));
            }
            let header = xml.createElement('Header');
            xml.documentElement.appendChild(header);
            header.setAttribute('nrows', ds.numRows.toString());
            header.setAttribute('ncols', ds.numCols.toString());
            for (let n = 0; n < ds.numCols; n++) {
                let column = xml.createElement('Column');
                header.appendChild(column);
                column.setAttribute('id', (n + 1).toString());
                column.setAttribute('name', ds.colName(n));
                column.setAttribute('type', ds.colType(n));
                column.appendChild(xml.createTextNode(ds.colDescr(n)));
            }
            let content = xml.createElement('Content');
            xml.documentElement.appendChild(content);
            for (let r = 0; r < ds.numRows; r++) {
                let row = xml.createElement('Row');
                row.setAttribute('id', (r + 1).toString());
                content.appendChild(row);
                for (let c = 0; c < ds.numCols; c++) {
                    let cell = xml.createElement('Cell');
                    cell.setAttribute('id', (c + 1).toString());
                    row.appendChild(cell);
                    let ct = ds.colType(c);
                    let txtNode = null;
                    if (ds.isNull(r, c)) { }
                    else if (ct == "molecule") {
                        let obj = ds.getObject(r, c);
                        if (obj instanceof WebMolKit.Molecule)
                            obj = WebMolKit.MoleculeStream.writeNative(obj);
                        txtNode = xml.createCDATASection(obj);
                    }
                    else if (ct == "string")
                        txtNode = xml.createCDATASection(ds.getString(r, c));
                    else if (ct == "real")
                        txtNode = xml.createTextNode(ds.getReal(r, c).toString());
                    else if (ct == "integer")
                        txtNode = xml.createTextNode(ds.getInteger(r, c).toString());
                    else if (ct == "boolean")
                        txtNode = xml.createTextNode(ds.getBoolean(r, c).toString());
                    else if (ct == "extend")
                        txtNode = xml.createCDATASection(ds.getExtend(r, c));
                    if (txtNode != null)
                        cell.appendChild(txtNode);
                }
            }
            if (WebMolKit.XML.customSerial)
                return new WebMolKit.XML.customSerial().serializeToString(xml.documentElement);
            else
                return new XMLSerializer().serializeToString(xml.documentElement);
        }
        static writeJSON(ds) {
            let data = ds.data;
            let nrow = ds.numRows, ncol = ds.numCols;
            let rowData = new Array(nrow);
            for (let n = 0; n < nrow; n++)
                rowData[n] = new Array(ncol);
            for (let c = 0; c < ncol; c++) {
                let doConvert = ds.colType(c) == "molecule";
                for (let r = 0; r < nrow; r++) {
                    let val = data.rowData[r][c];
                    if (val != null && doConvert)
                        val = val.toString();
                    rowData[r][c] = val;
                }
            }
            let json = {
                'title': data.title,
                'description': data.description,
                'colData': WebMolKit.deepClone(data.colData),
                'rowData': rowData,
                'extData': WebMolKit.deepClone(data.extData),
            };
            return json;
        }
    }
    WebMolKit.DataSheetStream = DataSheetStream;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let DotPathBond;
    (function (DotPathBond) {
        DotPathBond[DotPathBond["O0"] = 0] = "O0";
        DotPathBond[DotPathBond["O01"] = 1] = "O01";
        DotPathBond[DotPathBond["O1"] = 2] = "O1";
        DotPathBond[DotPathBond["O12"] = 3] = "O12";
        DotPathBond[DotPathBond["O2"] = 4] = "O2";
        DotPathBond[DotPathBond["O23"] = 5] = "O23";
        DotPathBond[DotPathBond["O3"] = 6] = "O3";
        DotPathBond[DotPathBond["O3X"] = 7] = "O3X";
    })(DotPathBond = WebMolKit.DotPathBond || (WebMolKit.DotPathBond = {}));
    let DotPathCharge;
    (function (DotPathCharge) {
        DotPathCharge[DotPathCharge["N1X"] = -3] = "N1X";
        DotPathCharge[DotPathCharge["N1"] = -2] = "N1";
        DotPathCharge[DotPathCharge["N01"] = -1] = "N01";
        DotPathCharge[DotPathCharge["Z0"] = 0] = "Z0";
        DotPathCharge[DotPathCharge["P01"] = 1] = "P01";
        DotPathCharge[DotPathCharge["P1"] = 2] = "P1";
        DotPathCharge[DotPathCharge["P1X"] = 3] = "P1X";
    })(DotPathCharge = WebMolKit.DotPathCharge || (WebMolKit.DotPathCharge = {}));
    class DotPath {
        constructor(mol) {
            this.mol = mol;
            this.paths = [];
            if (mol)
                this.calculate();
        }
        clone() {
            let dup = new DotPath(null);
            dup.mol = this.mol;
            dup.maskBlock = this.maskBlock;
            dup.paths = this.paths.slice(0);
            return dup;
        }
        getBondOrders() {
            const mol = this.mol;
            let orders = [];
            for (let n = 1; n <= mol.numBonds; n++)
                orders.push(mol.bondOrder(n));
            for (let path of this.paths) {
                let fract = path.numer / path.denom;
                for (let n = 1; n <= 5; n++)
                    if (WebMolKit.fltEqual(fract, n))
                        fract = n;
                for (let b of path.bonds)
                    orders[b - 1] = fract;
            }
            return orders;
        }
        getBondClasses() {
            const mol = this.mol;
            let classes = [];
            for (let n = 1; n <= mol.numBonds; n++) {
                let bo = mol.bondOrder(n);
                classes.push(bo == 0 ? 0 :
                    bo == 1 ? 2 :
                        bo == 2 ? 4 :
                            bo == 3 ? 6 : 7);
            }
            for (let path of this.paths) {
                let fract = path.numer / path.denom;
                let bcls = WebMolKit.fltEqual(fract, 0) ? 0 :
                    WebMolKit.fltEqual(fract, 1) ? 2 :
                        WebMolKit.fltEqual(fract, 2) ? 4 :
                            WebMolKit.fltEqual(fract, 3) ? 6 :
                                fract < 1 ? 1 :
                                    fract < 2 ? 3 :
                                        fract < 3 ? 5 : 7;
                for (let b of path.bonds)
                    classes[b - 1] = bcls;
            }
            return classes;
        }
        getChargeClasses() {
            const mol = this.mol;
            let classes = [];
            for (let n = 1; n <= mol.numAtoms; n++) {
                let chg = mol.atomCharge(n);
                classes.push(chg == 0 ? 0 :
                    chg == -1 ? -2 :
                        chg == 1 ? 2 :
                            chg < -1 ? -3 : 3);
            }
            for (let path of this.paths) {
                let chg = 0;
                for (let a of path.atoms)
                    chg += mol.atomCharge(a);
                chg /= path.atoms.length;
                let ccls = WebMolKit.fltEqual(chg, 0) ? 0 :
                    WebMolKit.fltEqual(chg, -1) ? -2 :
                        WebMolKit.fltEqual(chg, 1) ? 2 :
                            chg > -1 && chg < 0 ? -1 :
                                chg > 0 && chg < 1 ? 1 :
                                    chg < -1 ? -3 : 3;
                for (let a of path.atoms)
                    classes[a - 1] = ccls;
            }
            return classes;
        }
        getAggregateCharges() {
            const mol = this.mol;
            let chg = [];
            for (let n = 1; n <= mol.numAtoms; n++)
                chg[n - 1] = mol.atomCharge(n);
            for (let path of this.paths) {
                let total = 0;
                for (let a of path.atoms)
                    total += chg[a - 1];
                for (let a of path.atoms)
                    chg[a - 1] = total;
            }
            return chg;
        }
        toString() {
            let str = 'blocking=' + JSON.stringify(this.maskBlock) + '; paths=' + this.paths.length;
            for (let p of this.paths)
                str += ' [' + p.numer + '/' + p.denom + ';a=' + JSON.stringify(p.atoms) + ';b=' + JSON.stringify(p.bonds) + ']';
            return str;
        }
        calculate() {
            const mol = this.mol, na = mol.numAtoms, nb = mol.numBonds;
            let nonsingle = WebMolKit.Vec.booleanArray(false, na), pibonded = WebMolKit.Vec.booleanArray(false, na), metalbonded = WebMolKit.Vec.booleanArray(false, na);
            let bondsum = WebMolKit.Vec.numberArray(0, na);
            for (let n = 0; n < na; n++)
                bondsum[n] = mol.atomHydrogens(n + 1);
            for (let n = 1; n <= nb; n++) {
                let bo = mol.bondOrder(n), bfr = mol.bondFrom(n), bto = mol.bondTo(n);
                if (bo != 1) {
                    nonsingle[bfr - 1] = true;
                    nonsingle[bto - 1] = true;
                }
                if (bo >= 2) {
                    pibonded[bfr - 1] = true;
                    pibonded[bto - 1] = true;
                }
                else {
                    let blk1 = WebMolKit.Chemistry.ELEMENT_BLOCKS[mol.atomicNumber(bfr)], blk2 = WebMolKit.Chemistry.ELEMENT_BLOCKS[mol.atomicNumber(bto)];
                    if (blk1 >= 3 || blk2 >= 3) {
                        metalbonded[bfr - 1] = true;
                        metalbonded[bto - 1] = true;
                    }
                }
                bondsum[bfr - 1] += bo;
                bondsum[bto - 1] += bo;
                if (mol.bondTransient(n).indexOf(WebMolKit.ForeignMoleculeExtra.BondAromatic) >= 0) {
                    pibonded[bfr - 1] = true;
                    pibonded[bto - 1] = true;
                }
            }
            let impliedPi = WebMolKit.Vec.booleanArray(false, na);
            for (let n = 1; n <= na; n++)
                if (!pibonded[n - 1]) {
                    let adjpi = 0;
                    for (let adj of mol.atomAdjList(n))
                        if (pibonded[adj - 1] || metalbonded[adj - 1])
                            adjpi++;
                    if (adjpi >= 2)
                        impliedPi[n - 1] = true;
                }
            for (let n = 0; n < na; n++)
                if (impliedPi[n])
                    pibonded[n] = true;
            this.maskBlock = WebMolKit.Vec.booleanArray(false, na);
            let maskMaybe = WebMolKit.Vec.booleanArray(false, na);
            const COULD_BLOCK = [
                WebMolKit.Chemistry.ELEMENT_H,
                WebMolKit.Chemistry.ELEMENT_B, WebMolKit.Chemistry.ELEMENT_C, WebMolKit.Chemistry.ELEMENT_N, WebMolKit.Chemistry.ELEMENT_O, WebMolKit.Chemistry.ELEMENT_F,
                WebMolKit.Chemistry.ELEMENT_Al, WebMolKit.Chemistry.ELEMENT_Si, WebMolKit.Chemistry.ELEMENT_P, WebMolKit.Chemistry.ELEMENT_S, WebMolKit.Chemistry.ELEMENT_Cl,
                WebMolKit.Chemistry.ELEMENT_Ga, WebMolKit.Chemistry.ELEMENT_Ge, WebMolKit.Chemistry.ELEMENT_As, WebMolKit.Chemistry.ELEMENT_Se, WebMolKit.Chemistry.ELEMENT_Br,
                WebMolKit.Chemistry.ELEMENT_In, WebMolKit.Chemistry.ELEMENT_Sn, WebMolKit.Chemistry.ELEMENT_Sb, WebMolKit.Chemistry.ELEMENT_Te, WebMolKit.Chemistry.ELEMENT_I,
                WebMolKit.Chemistry.ELEMENT_Tl, WebMolKit.Chemistry.ELEMENT_Pb, WebMolKit.Chemistry.ELEMENT_Bi, WebMolKit.Chemistry.ELEMENT_Po, WebMolKit.Chemistry.ELEMENT_At,
            ];
            const ACIDS = [
                WebMolKit.Chemistry.ELEMENT_B,
                WebMolKit.Chemistry.ELEMENT_Al, WebMolKit.Chemistry.ELEMENT_Si,
                WebMolKit.Chemistry.ELEMENT_Ga, WebMolKit.Chemistry.ELEMENT_Ge,
                WebMolKit.Chemistry.ELEMENT_In, WebMolKit.Chemistry.ELEMENT_Sn,
                WebMolKit.Chemistry.ELEMENT_Tl, WebMolKit.Chemistry.ELEMENT_Pb,
            ];
            const BASES = [
                WebMolKit.Chemistry.ELEMENT_N, WebMolKit.Chemistry.ELEMENT_O, WebMolKit.Chemistry.ELEMENT_F,
                WebMolKit.Chemistry.ELEMENT_P, WebMolKit.Chemistry.ELEMENT_S, WebMolKit.Chemistry.ELEMENT_Cl,
                WebMolKit.Chemistry.ELEMENT_As, WebMolKit.Chemistry.ELEMENT_Se, WebMolKit.Chemistry.ELEMENT_Br,
                WebMolKit.Chemistry.ELEMENT_Sb, WebMolKit.Chemistry.ELEMENT_Te, WebMolKit.Chemistry.ELEMENT_I,
                WebMolKit.Chemistry.ELEMENT_Bi, WebMolKit.Chemistry.ELEMENT_Po, WebMolKit.Chemistry.ELEMENT_At,
            ];
            skip: for (let n = 0; n < na; n++) {
                const a = n + 1;
                if (nonsingle[n] || pibonded[n])
                    continue;
                if (mol.atomCharge(a) != 0 || mol.atomUnpaired(a) != 0)
                    continue;
                const atno = mol.atomicNumber(a);
                if (atno == 0) {
                    this.maskBlock[n] = true;
                    continue;
                }
                if (COULD_BLOCK.indexOf(atno) < 0)
                    continue;
                if (bondsum[n] != WebMolKit.Chemistry.ELEMENT_BONDING[atno])
                    continue;
                if (ACIDS.indexOf(atno) >= 0) {
                    for (let adj of mol.atomAdjList(a))
                        if (BASES.indexOf(mol.atomicNumber(adj)) >= 0)
                            continue skip;
                }
                if (BASES.indexOf(atno) >= 0) {
                    for (let adj of mol.atomAdjList(a))
                        if (ACIDS.indexOf(mol.atomicNumber(adj)) >= 0)
                            continue skip;
                }
                maskMaybe[n] = true;
                if (atno == WebMolKit.Chemistry.ELEMENT_C) {
                    let hasMetal = false;
                    for (let adj of mol.atomAdjList(a))
                        if (COULD_BLOCK.indexOf(mol.atomicNumber(adj)) < 0)
                            hasMetal = true;
                    if (!hasMetal)
                        this.maskBlock[n] = true;
                }
                else if (atno == WebMolKit.Chemistry.ELEMENT_H) {
                    this.maskBlock[n] = true;
                }
            }
            skip: for (let n = 0; n < na; n++)
                if (maskMaybe[n] && !this.maskBlock[n]) {
                    for (let a of mol.atomAdjList(n + 1))
                        if (!maskMaybe[a - 1])
                            continue skip;
                    this.maskBlock[n] = true;
                }
            let g = WebMolKit.Graph.fromMolecule(mol);
            for (let n = 0; n < na; n++)
                if (this.maskBlock[n])
                    g.isolateNode(n);
            for (let cc of g.calculateComponentGroups()) {
                if (cc.length == 1)
                    continue;
                let amask = WebMolKit.Vec.idxMask(cc, na);
                WebMolKit.Vec.addTo(cc, 1);
                let p = {
                    'atoms': cc,
                    'bonds': [],
                    'numer': 0,
                    'denom': 0
                };
                for (let n = 1; n <= nb; n++)
                    if (amask[mol.bondFrom(n) - 1] && amask[mol.bondTo(n) - 1])
                        p.bonds.push(n);
                let totalHave = 0, totalWant = 0;
                for (let a of p.atoms) {
                    let others = mol.atomHydrogens(a);
                    for (let o of mol.atomAdjList(a))
                        if (!amask[o - 1])
                            others++;
                    let atno = mol.atomicNumber(a);
                    let have = WebMolKit.Chemistry.ELEMENT_VALENCE[atno] - mol.atomCharge(a) - others;
                    let want = WebMolKit.Chemistry.ELEMENT_SHELL[atno] - WebMolKit.Chemistry.ELEMENT_VALENCE[atno] - others;
                    totalHave += have;
                    totalWant += want;
                }
                let electrons = Math.min(totalHave, totalWant);
                p.numer = electrons;
                p.denom = 2 * p.bonds.length;
                this.paths.push(p);
            }
        }
    }
    WebMolKit.DotPath = DotPath;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let ExperimentMetaType;
    (function (ExperimentMetaType) {
        ExperimentMetaType["Role"] = "role";
        ExperimentMetaType["Pressure"] = "pressure";
        ExperimentMetaType["TurnoverNumber"] = "turnover_number";
        ExperimentMetaType["EnantiomericExcess"] = "enantiomeric_excess";
        ExperimentMetaType["Time"] = "time";
        ExperimentMetaType["Heat"] = "heat";
        ExperimentMetaType["Light"] = "light";
    })(ExperimentMetaType = WebMolKit.ExperimentMetaType || (WebMolKit.ExperimentMetaType = {}));
    let ExperimentMetaApplic;
    (function (ExperimentMetaApplic) {
        ExperimentMetaApplic[ExperimentMetaApplic["Experiment"] = 0] = "Experiment";
        ExperimentMetaApplic[ExperimentMetaApplic["Step"] = 1] = "Step";
        ExperimentMetaApplic[ExperimentMetaApplic["Reactant"] = 2] = "Reactant";
        ExperimentMetaApplic[ExperimentMetaApplic["Reagent"] = 3] = "Reagent";
        ExperimentMetaApplic[ExperimentMetaApplic["Product"] = 4] = "Product";
    })(ExperimentMetaApplic = WebMolKit.ExperimentMetaApplic || (WebMolKit.ExperimentMetaApplic = {}));
    let ExperimentMetaValue;
    (function (ExperimentMetaValue) {
        ExperimentMetaValue[ExperimentMetaValue["Boolean"] = 0] = "Boolean";
        ExperimentMetaValue[ExperimentMetaValue["Number"] = 1] = "Number";
        ExperimentMetaValue[ExperimentMetaValue["Optional"] = 2] = "Optional";
        ExperimentMetaValue[ExperimentMetaValue["String"] = 3] = "String";
    })(ExperimentMetaValue = WebMolKit.ExperimentMetaValue || (WebMolKit.ExperimentMetaValue = {}));
    let ExperimentMetaRoleType;
    (function (ExperimentMetaRoleType) {
        ExperimentMetaRoleType["Reagent"] = "reagent";
        ExperimentMetaRoleType["Catalyst"] = "catalyst";
        ExperimentMetaRoleType["Solvent"] = "solvent";
    })(ExperimentMetaRoleType = WebMolKit.ExperimentMetaRoleType || (WebMolKit.ExperimentMetaRoleType = {}));
    class ExperimentMeta {
        static unpackMeta(str) {
            if (!str)
                return [];
            let list = [];
            for (let line of str.split('\n'))
                if (line) {
                    let eq = line.indexOf('=');
                    let type = WebMolKit.MoleculeStream.skUnescape(eq < 0 ? line : line.substring(0, eq));
                    let value = eq < 0 ? null : WebMolKit.MoleculeStream.skUnescape(line.substring(eq + 1));
                    let vtype = this.VALUES[type];
                    if (value != null && (vtype == ExperimentMetaValue.Number || vtype == ExperimentMetaValue.Optional))
                        value = parseFloat(value);
                    list.push([type, value]);
                }
            return list;
        }
        static packMeta(list) {
            let lines = [];
            for (let [type, value] of list) {
                if (value == null)
                    lines.push(WebMolKit.MoleculeStream.skEscape(type));
                else
                    lines.push(WebMolKit.MoleculeStream.skEscape(type) + '=' + WebMolKit.MoleculeStream.skEscape(value.toString()));
            }
            return lines.join('\n');
        }
        static withMetaKey(metastr, type, value) {
            let list = this.unpackMeta(metastr);
            let item = list.find((look) => look[0] == type);
            if (value != null) {
                if (item)
                    item[1] = value;
                else
                    list.push([type, value]);
            }
            else {
                list = list.filter((look) => look[0] != type);
            }
            return this.packMeta(list);
        }
        static describeMeta(type, value) {
            let formatFloat = (val, maxSigFig) => {
                if (val == null)
                    return '';
                if (val == 0)
                    return '0';
                let digits = Math.ceil(-Math.log10(Math.abs(val)));
                digits = Math.max(0, Math.max(digits, maxSigFig));
                let str = val.toFixed(digits);
                if (str.indexOf('.') < 0)
                    return str;
                while (str.endsWith('0'))
                    str = str.substring(0, str.length - 1);
                if (str.endsWith('.'))
                    str = str.substring(0, str.length - 1);
                return str;
            };
            if (type == ExperimentMetaType.Role) {
                if (!value)
                    return null;
                return `role: ${value}`;
            }
            else if (type == ExperimentMetaType.Pressure) {
                if (value == null)
                    return null;
                return `${formatFloat(value, 2)} atm`;
            }
            else if (type == ExperimentMetaType.TurnoverNumber) {
                if (value == null)
                    return null;
                return `${formatFloat(value, 2)} turnover${value == 1 ? '' : 's'}`;
            }
            else if (type == ExperimentMetaType.EnantiomericExcess) {
                if (value == null)
                    return null;
                return `${formatFloat(value, 2)}% ee`;
            }
            else if (type == ExperimentMetaType.Time) {
                if (value == null)
                    return null;
                if (value < 1) {
                    let mins = value * 60;
                    return `${formatFloat(mins, 2)} min${mins == 1 ? '' : 's'}`;
                }
                else
                    return `${formatFloat(value, 2)} hour${value == 1 ? '' : 's'}`;
            }
            else if (type == ExperimentMetaType.Heat) {
                if (value == null)
                    return '\u{0394}';
                return `${formatFloat(value, 2)} \u{00B0}C`;
            }
            else if (type == ExperimentMetaType.Light) {
                if (value == null)
                    return 'h\u{03BD}';
                return `${formatFloat(value, 2)} nm`;
            }
            return null;
        }
    }
    ExperimentMeta.APPLICABILITY = {
        [ExperimentMetaType.Role]: [ExperimentMetaApplic.Reagent],
        [ExperimentMetaType.Pressure]: [ExperimentMetaApplic.Reactant, ExperimentMetaApplic.Reagent],
        [ExperimentMetaType.TurnoverNumber]: [ExperimentMetaApplic.Reagent],
        [ExperimentMetaType.EnantiomericExcess]: [ExperimentMetaApplic.Product],
        [ExperimentMetaType.Time]: [ExperimentMetaApplic.Step],
        [ExperimentMetaType.Heat]: [ExperimentMetaApplic.Step],
        [ExperimentMetaType.Light]: [ExperimentMetaApplic.Step],
    };
    ExperimentMeta.NAMES = {
        [ExperimentMetaType.Role]: 'Role',
        [ExperimentMetaType.Pressure]: 'Pressure',
        [ExperimentMetaType.TurnoverNumber]: 'Turnover Number',
        [ExperimentMetaType.EnantiomericExcess]: 'Enantiomeric Excess',
        [ExperimentMetaType.Time]: 'Time',
        [ExperimentMetaType.Heat]: 'Heat',
        [ExperimentMetaType.Light]: 'Light',
    };
    ExperimentMeta.UNITS = {
        [ExperimentMetaType.Pressure]: 'atm',
        [ExperimentMetaType.TurnoverNumber]: null,
        [ExperimentMetaType.EnantiomericExcess]: '%',
        [ExperimentMetaType.Time]: 'hr',
        [ExperimentMetaType.Heat]: '\u{00B0}C',
        [ExperimentMetaType.Light]: 'nm',
    };
    ExperimentMeta.VALUES = {
        [ExperimentMetaType.Role]: ExperimentMetaValue.String,
        [ExperimentMetaType.Pressure]: ExperimentMetaValue.Number,
        [ExperimentMetaType.TurnoverNumber]: ExperimentMetaValue.Number,
        [ExperimentMetaType.EnantiomericExcess]: ExperimentMetaValue.Number,
        [ExperimentMetaType.Time]: ExperimentMetaValue.Number,
        [ExperimentMetaType.Heat]: ExperimentMetaValue.Optional,
        [ExperimentMetaType.Light]: ExperimentMetaValue.Optional,
    };
    WebMolKit.ExperimentMeta = ExperimentMeta;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let ForeignMoleculeExtra;
    (function (ForeignMoleculeExtra) {
        ForeignMoleculeExtra["AtomAromatic"] = "yAROMATIC";
        ForeignMoleculeExtra["BondAromatic"] = "yAROMATIC";
        ForeignMoleculeExtra["AtomChiralMDLOdd"] = "yCHIRAL_MDL_ODD";
        ForeignMoleculeExtra["AtomChiralMDLEven"] = "yCHIRAL_MDL_EVEN";
        ForeignMoleculeExtra["AtomChiralMDLRacemic"] = "yCHIRAL_MDL_RACEMIC";
    })(ForeignMoleculeExtra = WebMolKit.ForeignMoleculeExtra || (WebMolKit.ForeignMoleculeExtra = {}));
    class ForeignMolecule {
        static noteAromaticAtoms(mol) {
            const sz = mol.numAtoms;
            let mask = WebMolKit.Vec.booleanArray(false, sz);
            for (let n = 1; n <= sz; n++)
                mask[n - 1] = mol.atomTransient(n).indexOf(ForeignMoleculeExtra.AtomAromatic) >= 0;
            return mask;
        }
        static noteAromaticBonds(mol) {
            const sz = mol.numBonds;
            let mask = WebMolKit.Vec.booleanArray(false, sz);
            for (let n = 1; n <= sz; n++)
                mask[n - 1] = mol.bondTransient(n).indexOf(ForeignMoleculeExtra.BondAromatic) >= 0;
            return mask;
        }
    }
    WebMolKit.ForeignMolecule = ForeignMolecule;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class FormatList {
    }
    FormatList.FMT_NATIVE = 'native';
    FormatList.FMT_XMLDS = 'xmlds';
    FormatList.FMT_MDLMOL = 'mdlmol';
    FormatList.FMT_MDLSDF = 'mdlsdf';
    FormatList.FMT_MDLRDF = 'mdlrdf';
    FormatList.FMT_MDLRXN = 'mdlrxn';
    FormatList.GFX_PNG = 'png';
    FormatList.GFX_PNGZIP = 'pngzip';
    FormatList.GFX_SVG = 'svg';
    FormatList.GFX_SVGZIP = 'svgzip';
    FormatList.GFX_PDF = 'pdf';
    FormatList.GFX_PDFZIP = 'pdfzip';
    FormatList.GFX_EPS = 'eps';
    FormatList.GFX_HTML = 'html';
    FormatList.GFX_OPENDOC_ODG = 'odg';
    FormatList.GFX_OPENDOC_ODT = 'odt';
    FormatList.GFX_OPENDOC_ODS = 'ods';
    FormatList.GFX_OOXML_DOCX = 'docx';
    FormatList.GFX_OOXML_XLSX = 'xlsx';
    FormatList.FORMAT_DESCR = {
        'native': 'SketchEl Molecule',
        'xmlds': 'DataSheet XML',
        'mdlmol': 'MDL MOL (single molecule)',
        'mdlsdf': 'MDL SDF (molecules + data)',
        'mdlrdf': 'MDL RDF (reactions + data)',
        'mdlrxn': 'MDL RXN (single reaction)',
        'png': 'PNG image (raster)',
        'pngzip': 'ZIP (multiple PNG files)',
        'svg': 'SVG picture (vector)',
        'svgzip': 'ZIP (multiple SVG files)',
        'pdf': 'PDF diagram (vector)',
        'pdfzip': 'ZIP (multiple PDF files)',
        'eps': 'Encapsulated PostScript (vector)',
        'html': 'HTML with embedded SVG',
        'odg': 'OpenDocument Graphic',
        'odt': 'OpenDocument Text',
        'ods': 'OpenDocument SpreadSheet',
        'docx': 'Microsoft Word',
        'xlsx': 'Microsoft Excel'
    };
    FormatList.FORMAT_EXTN = {
        'native': '.el',
        'xmlds': '.ds',
        'mdlmol': '.mol',
        'mdlsdf': '.sdf',
        'mdlrdf': '.rdf',
        'mdlrxn': '.rxn',
        'png': '.png',
        'pngzip': '_png.zip',
        'svg': '.svg',
        'svgzip': '_svg.zip',
        'pdf': '.pdf',
        'pdfzip': '_pdf.zip',
        'eps': '.eps',
        'html': '.html',
        'odg': '.odg',
        'odt': '.odt',
        'ods': '.ods',
        'docx': '.docx',
        'xlsx': '.xlsx'
    };
    FormatList.FORMAT_MIMETYPE = {
        'native': 'chemical/x-sketchel',
        'xmlds': 'chemical/x-datasheet',
        'mdlmol': 'chemical/x-mdl-molfile',
        'mdlsdf': 'chemical/x-mdl-sdfile',
        'mdlrdf': 'chemical/x-mdl-rdfile',
        'mdlrxn': 'chemical/x-mdl-rxnfile',
        'png': 'image/png',
        'pngzip': 'application/zip',
        'svg': 'image/png',
        'svgzip': 'application/zip',
        'pdf': 'application/pdf',
        'pdfzip': 'application/zip',
        'eps': 'image/eps',
        'html': 'text/html',
        'odg': 'application/vnd.oasis.opendocument.graphics',
        'odt': 'application/vnd.oasis.opendocument.text',
        'ods': 'application/vnd.oasis.opendocument.spreadsheet',
        'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    };
    WebMolKit.FormatList = FormatList;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class Graph {
        constructor(sz, edge1, edge2) {
            this.nbrs = [];
            this.indices = null;
            this.labels = null;
            this.props = null;
            if (sz != null)
                for (let n = 0; n < sz; n++)
                    this.nbrs.push([]);
            if (edge1 != null && edge2 != null) {
                for (let n = 0; n < edge1.length; n++) {
                    this.nbrs[edge1[n]].push(edge2[n]);
                    this.nbrs[edge2[n]].push(edge1[n]);
                }
            }
        }
        clone() {
            let g = new Graph();
            for (let nbr of this.nbrs)
                g.nbrs.push(nbr.slice(0));
            g.indices = this.indices == null ? null : this.indices.slice(0);
            g.labels = this.labels == null ? null : this.labels.slice(0);
            g.props = this.props == null ? null : this.props.slice(0);
            return g;
        }
        static fromMolecule(mol) {
            let g = new Graph();
            g.indices = [];
            for (let n = 0; n < mol.numAtoms; n++) {
                g.nbrs.push([]);
                g.indices.push(n + 1);
            }
            for (let n = 1; n <= mol.numBonds; n++) {
                let bfr = mol.bondFrom(n) - 1, bto = mol.bondTo(n) - 1;
                g.nbrs[bfr].push(bto);
                g.nbrs[bto].push(bfr);
            }
            return g;
        }
        static fromNeighbours(nbrs) {
            let g = new Graph();
            g.nbrs = nbrs;
            return g;
        }
        toString() {
            let buff = '#nodes=' + this.nbrs.length;
            for (let n = 0; n < this.nbrs.length; n++) {
                buff += ' ' + n + ':{' + this.nbrs[n] + '}';
                if (n < WebMolKit.Vec.len(this.indices))
                    buff += '[i=' + this.indices[n] + ']';
                if (n < WebMolKit.Vec.len(this.labels))
                    buff += '[l=' + this.labels[n] + ']';
            }
            return buff;
        }
        get numNodes() { return this.nbrs.length; }
        numEdges(node) { return this.nbrs[node].length; }
        getEdge(node, edge) { return this.nbrs[node][edge]; }
        getEdges(node) { return this.nbrs[node]; }
        getIndex(node) { return this.indices == null ? 0 : this.indices[node]; }
        setIndex(node, idx) {
            if (this.indices == null)
                this.indices = WebMolKit.Vec.numberArray(0, this.nbrs.length);
            this.indices[node] = idx;
        }
        getLabel(node) { return this.labels == null ? null : this.labels[node]; }
        setLabel(node, lbl) {
            if (this.labels == null)
                this.labels = WebMolKit.Vec.stringArray('', this.nbrs.length);
            this.labels[node] = lbl;
        }
        getProperty(node) { return this.props == null ? null : this.props[node]; }
        setProperty(node, prp) {
            if (this.props == null)
                this.props = new Array(this.nbrs.length);
            this.props[node] = prp;
        }
        addNode() {
            this.nbrs.push([]);
            if (this.indices != null)
                this.indices.push(0);
            if (this.labels != null)
                this.labels.push('');
            if (this.props != null)
                this.props.push(null);
            return this.nbrs.length - 1;
        }
        hasEdge(node1, node2) {
            if (this.nbrs[node1].length <= this.nbrs[node2].length)
                return this.nbrs[node1].indexOf(node2) >= 0;
            else
                return this.nbrs[node2].indexOf(node1) >= 0;
        }
        addEdge(node1, node2) {
            this.nbrs[node1].push(node2);
            this.nbrs[node2].push(node1);
        }
        removeEdge(node1, node2) {
            let i1 = this.nbrs[node1].indexOf(node2), i2 = this.nbrs[node2].indexOf(node1);
            if (i1 >= 0)
                this.nbrs[node1].splice(i1, 1);
            if (i2 >= 0)
                this.nbrs[node2].splice(i2, 1);
        }
        isolateNode(node) {
            for (let o of this.nbrs[node]) {
                let i = this.nbrs[o].indexOf(node);
                if (i >= 0)
                    this.nbrs[o].splice(i, 1);
            }
            this.nbrs[node] = [];
        }
        keepNodesMask(mask) {
            const oldsz = this.nbrs.length, newsz = WebMolKit.Vec.maskCount(mask);
            if (newsz == oldsz)
                return;
            if (newsz == 0) {
                this.nbrs = [];
                this.indices = null;
                this.labels = null;
                this.props = null;
                return;
            }
            let newmap = WebMolKit.Vec.maskMap(mask);
            let newnbrs = [];
            for (let n = 0; n < newsz; n++)
                newnbrs.push([]);
            for (let n = 0, pos = 0; n < oldsz; n++)
                if (mask[n]) {
                    for (let i of this.nbrs[n])
                        if (mask[i])
                            newnbrs[pos].push(newmap[i]);
                    pos++;
                }
            this.nbrs = newnbrs;
            if (this.indices != null)
                this.indices = WebMolKit.Vec.maskGet(this.indices, mask);
            if (this.labels != null)
                this.labels = WebMolKit.Vec.maskGet(this.labels, mask);
            if (this.props != null)
                this.props = WebMolKit.Vec.maskGet(this.props, mask);
        }
        keepNodesIndex(idx) { this.keepNodesMask(WebMolKit.Vec.idxMask(idx, this.numNodes)); }
        removeNodesMask(mask) { this.keepNodesMask(WebMolKit.Vec.notMask(mask)); }
        removeNodesIndex(idx) { this.removeNodesMask(WebMolKit.Vec.idxMask(idx, this.numNodes)); }
        subgraphIndex(idx) {
            const nsz = idx.length;
            let g = new Graph(nsz);
            if (this.indices != null || this.labels != null || this.props != null)
                for (let n = 0; n < nsz; n++) {
                    if (this.indices != null)
                        g.setIndex(n, this.indices[idx[n]]);
                    if (this.labels != null)
                        g.setLabel(n, this.labels[idx[n]]);
                    if (this.props != null)
                        g.setProperty(n, this.props[idx[n]]);
                }
            for (let i = 0; i < nsz; i++) {
                for (let n of this.nbrs[idx[i]]) {
                    let j = idx.indexOf(n);
                    if (j > i)
                        g.addEdge(i, j);
                }
            }
            return g;
        }
        subgraphMask(mask) {
            let g = this.clone();
            g.keepNodesMask(mask);
            return g;
        }
        calculateComponents() {
            const sz = this.nbrs.length;
            if (sz == 0)
                return [];
            let cc = WebMolKit.Vec.numberArray(0, sz);
            cc[0] = 1;
            let first = 1, high = 1;
            while (true) {
                while (first < sz && cc[first] > 0) {
                    first++;
                }
                if (first >= sz)
                    break;
                let anything = false;
                for (let i = first; i < sz; i++)
                    if (cc[i] == 0) {
                        for (let j = 0; j < this.nbrs[i].length; j++) {
                            if (cc[this.nbrs[i][j]] != 0) {
                                cc[i] = cc[this.nbrs[i][j]];
                                anything = true;
                            }
                        }
                    }
                if (!anything)
                    cc[first] = ++high;
            }
            return cc;
        }
        calculateComponentGroups() {
            if (this.nbrs.length == 0)
                return [];
            let cc = this.calculateComponents();
            let sz = WebMolKit.Vec.max(cc);
            let grp = [];
            for (let n = 0; n < sz; n++)
                grp.push([]);
            for (let n = 0; n < cc.length; n++)
                grp[cc[n] - 1].push(n);
            return grp;
        }
        calculateRingBlocks() {
            let sz = this.numNodes, nbrs = this.nbrs;
            if (sz == 0)
                return [[], 0];
            let rblk = new Array(this.numNodes);
            let visited = WebMolKit.Vec.booleanArray(false, sz);
            WebMolKit.Vec.setTo(rblk, 0);
            let path = new Array(sz + 1);
            let plen = 0, numVisited = 0;
            while (true) {
                let last, current;
                if (plen == 0) {
                    last = -1;
                    for (current = 0; visited[current]; current++) { }
                }
                else {
                    last = path[plen - 1];
                    current = -1;
                    for (let n = 0; n < nbrs[last].length; n++)
                        if (!visited[nbrs[last][n]]) {
                            current = nbrs[last][n];
                            break;
                        }
                }
                if (current >= 0 && plen >= 2) {
                    let back = path[plen - 1];
                    for (let n = 0; n < nbrs[current].length; n++) {
                        let join = nbrs[current][n];
                        if (join != back && visited[join]) {
                            path[plen] = current;
                            for (let i = plen; i == plen || path[i + 1] != join; i--) {
                                let id = rblk[path[i]];
                                if (id == 0)
                                    rblk[path[i]] = last;
                                else if (id != last) {
                                    for (let j = 0; j < sz; j++)
                                        if (rblk[j] == id)
                                            rblk[j] = last;
                                }
                            }
                        }
                    }
                }
                if (current >= 0) {
                    visited[current] = true;
                    path[plen++] = current;
                    numVisited++;
                }
                else {
                    plen--;
                }
                if (numVisited == sz)
                    break;
            }
            let nextID = 0;
            for (let i = 0; i < sz; i++)
                if (rblk[i] > 0) {
                    nextID--;
                    for (let j = sz - 1; j >= i; j--)
                        if (rblk[j] == rblk[i])
                            rblk[j] = nextID;
                }
            for (let i = 0; i < sz; i++)
                rblk[i] = -rblk[i];
            return [rblk, -nextID];
        }
        calculateRingBlockGroups() {
            let [rblk, sz] = this.calculateRingBlocks();
            if (sz == 0)
                return [];
            let cap = WebMolKit.Vec.numberArray(0, sz);
            for (let n = 0; n < rblk.length; n++)
                if (rblk[n] > 0)
                    cap[rblk[n] - 1]++;
            let grp = new Array(sz);
            for (let n = 0; n < sz; n++) {
                grp[n] = new Array(cap[n]);
                cap[n] = 0;
            }
            for (let n = 0; n < rblk.length; n++) {
                let i = rblk[n] - 1;
                if (i < 0)
                    continue;
                grp[i][cap[i]++] = n;
            }
            return grp;
        }
        findRingsOfSize(size) {
            let [rblk, num] = this.calculateRingBlocks();
            if (num == 0)
                return [];
            let rings = [];
            let mask = new Array(this.numNodes);
            for (let r = 1; r <= num; r++) {
                for (let n = 0; n < this.numNodes; n++)
                    mask[n] = rblk[n] == r;
                let newRings = this.findRingsOfSizeMask(size, mask);
                for (let n = 0; n < newRings.length; n++)
                    rings.push(newRings[n]);
            }
            return rings;
        }
        findRingsOfSizeMask(size, mask) {
            let rings = [];
            for (let n = 0; n < this.numNodes; n++)
                if (mask[n]) {
                    let path = new Array(size);
                    path[0] = n;
                    this.recursiveRingFind(path, 1, size, mask, rings);
                }
            return rings;
        }
        calculateBFS(idx) {
            let ret = WebMolKit.Vec.numberArray(-1, this.numNodes);
            ret[idx] = 0;
            let curnum = 0, lsz = 1, watermark = 0;
            let list = WebMolKit.Vec.numberArray(0, this.numNodes);
            list[0] = idx;
            while (true) {
                let newsz = lsz;
                for (let n = watermark; n < lsz; n++) {
                    for (let i = 0; i < this.nbrs[list[n]].length; i++) {
                        let j = this.nbrs[list[n]][i];
                        if (ret[j] < 0) {
                            ret[j] = curnum + 1;
                            list[newsz++] = j;
                        }
                    }
                }
                if (newsz == lsz)
                    break;
                watermark = lsz;
                lsz = newsz;
                curnum++;
            }
            return ret;
        }
        calculateGravity() {
            const sz = this.numNodes;
            const { nbrs } = this;
            let wght = WebMolKit.Vec.numberArray(1, sz), wmod = WebMolKit.Vec.numberArray(0, sz);
            for (let n = 0; n < sz; n++) {
                WebMolKit.Vec.setTo(wmod, wght);
                for (let i = 0; i < sz; i++)
                    for (let j = nbrs[i].length - 1; j >= 0; j--)
                        wmod[i] += wght[nbrs[i][j]];
                WebMolKit.Vec.setTo(wght, wmod);
            }
            return wght;
        }
        recursiveRingFind(path, psize, capacity, mask, rings) {
            if (psize < capacity) {
                let last = path[psize - 1];
                for (let n = 0; n < this.nbrs[last].length; n++) {
                    let adj = this.nbrs[last][n];
                    if (!mask[adj])
                        continue;
                    let fnd = false;
                    for (let i = 0; i < psize; i++)
                        if (path[i] == adj) {
                            fnd = true;
                            break;
                        }
                    if (!fnd) {
                        let newPath = WebMolKit.Vec.duplicate(path);
                        newPath[psize] = adj;
                        this.recursiveRingFind(newPath, psize + 1, capacity, mask, rings);
                    }
                }
                return;
            }
            let last = path[psize - 1];
            let fnd = false;
            for (let n = 0; n < this.nbrs[last].length; n++)
                if (this.nbrs[last][n] == path[0]) {
                    fnd = true;
                    break;
                }
            if (!fnd)
                return;
            for (let n = 0; n < path.length; n++) {
                let count = 0, p = path[n];
                for (let i = 0; i < this.nbrs[p].length; i++)
                    if (path.indexOf(this.nbrs[p][i]) >= 0)
                        count++;
                if (count != 2)
                    return;
            }
            let first = 0;
            for (let n = 1; n < psize; n++)
                if (path[n] < path[first])
                    first = n;
            let fm = (first - 1 + psize) % psize, fp = (first + 1) % psize;
            let flip = path[fm] < path[fp];
            if (first != 0 || flip) {
                let newPath = new Array(psize);
                for (let n = 0; n < psize; n++)
                    newPath[n] = path[(first + (flip ? psize - n : n)) % psize];
                path = newPath;
            }
            for (let n = 0; n < rings.length; n++) {
                let look = rings[n];
                let same = true;
                for (let i = 0; i < psize; i++)
                    if (look[i] != path[i]) {
                        same = false;
                        break;
                    }
                if (same)
                    return;
            }
            rings.push(path);
        }
    }
    WebMolKit.Graph = Graph;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    WebMolKit.MDLMOL_VALENCE = {
        'H': [1],
        'B': [3],
        'C': [4],
        'Si': [4],
        'N': [3],
        'P': [3, 5],
        'As': [3, 5],
        'O': [2],
        'S': [2, 4, 6],
        'Se': [2, 4, 6],
        'Te': [2, 4, 6],
        'F': [1],
        'Cl': [1, 3, 5, 7],
        'Br': [1],
        'I': [1, 3, 5, 7],
        'At': [1, 3, 5, 7],
    };
    class MDLMOLReader {
        constructor(strData) {
            this.parseHeader = true;
            this.parseExtended = true;
            this.allowV3000 = true;
            this.considerRescale = true;
            this.relaxed = false;
            this.keepAromatic = false;
            this.keepParity = false;
            this.mol = null;
            this.molName = '';
            this.openmol = new WebMolKit.OpenMolSpec();
            this.atomHyd = null;
            this.resBonds = null;
            this.explicitValence = [];
            this.groupAttachAny = new Map();
            this.groupAttachAll = new Map();
            this.groupStereoAbsolute = [];
            this.groupStereoRacemic = [];
            this.groupStereoRelative = [];
            this.groupLinkNodes = [];
            this.groupMixtures = [];
            this.pos = 0;
            this.lines = strData.split(/\r?\n/);
        }
        parse() {
            if (this.parseHeader) {
                this.molName = this.lines[0];
                if (this.molName) {
                    let src = { 'row': 0, 'col': 0, 'len': this.molName.length };
                    this.openmol.add(WebMolKit.OpenMolType.MoleculeName, null, null, [src]);
                }
                this.pos = 3;
            }
            this.parseCTAB();
            return this.mol;
        }
        nextLine() {
            if (this.pos >= this.lines.length)
                throw 'MDL Molfile parser: premature end, at line ' + (this.pos + 1);
            return this.lines[this.pos++];
        }
        parseCTAB() {
            this.mol = new WebMolKit.Molecule();
            this.mol.keepTransient = true;
            let line = this.nextLine();
            if (!this.relaxed) {
                let version = line.length >= 39 ? line.substring(34, 39) : '';
                if (this.allowV3000 && version == 'V3000') {
                    this.parseV3000();
                    this.openmol.derive(this.mol);
                    return;
                }
                if (version != 'V2000')
                    throw 'Invalid MDL MOL: no Vx000 tag.';
            }
            let numAtoms = parseInt(line.substring(0, 3).trim());
            let numBonds = parseInt(line.substring(3, 6).trim());
            for (let n = 0; n < numAtoms; n++) {
                line = this.nextLine();
                if (line.length < 39)
                    throw 'Invalid MDL MOL: atom line' + (n + 1);
                let x = parseFloat(line.substring(0, 10).trim());
                let y = parseFloat(line.substring(10, 20).trim());
                let z = parseFloat(line.substring(20, 30).trim());
                let el = line.substring(31, 34).trim();
                let chg = parseInt(line.substring(36, 39).trim()), rad = 0;
                let stereo = line.length < 42 ? 0 : parseInt(line.substring(39, 42).trim());
                let hyd = line.length < 45 ? 0 : parseInt(line.substring(42, 45).trim());
                let val = line.length < 51 ? 0 : parseInt(line.substring(48, 51).trim());
                let mapnum = line.length < 63 ? 0 : parseInt(line.substring(60, 63).trim());
                if (chg >= 1 && chg <= 3)
                    chg = 4 - chg;
                else if (chg == 4) {
                    chg = 0;
                    rad = 2;
                }
                else if (chg >= 5 && chg <= 7)
                    chg = 4 - chg;
                else
                    chg = 0;
                let a = this.mol.addAtom(el, x, y, chg, rad);
                if (z != 0) {
                    this.mol.setAtomZ(a, z);
                    this.mol.setIs3D(true);
                }
                this.mol.setAtomMapNum(a, mapnum);
                if (hyd > 0) {
                    this.openmol.addJoin(WebMolKit.OpenMolType.QueryHCount, [a]);
                    if (this.atomHyd == null)
                        this.atomHyd = WebMolKit.Vec.numberArray(WebMolKit.Molecule.HEXPLICIT_UNKNOWN, numAtoms);
                    this.atomHyd[n] = hyd - 1;
                }
                if (stereo > 0 && this.keepParity) {
                }
                this.explicitValence.push(val);
            }
            for (let n = 0; n < numBonds; n++) {
                line = this.nextLine();
                if (line.length < 12)
                    throw 'Invalid MDL MOL: bond line' + (n + 1);
                let bfr = parseInt(line.substring(0, 3).trim()), bto = parseInt(line.substring(3, 6).trim());
                let type = parseInt(line.substring(6, 9).trim()), stereo = parseInt(line.substring(9, 12).trim());
                if (bfr == bto || bfr < 1 || bfr > numAtoms || bto < 1 || bto > numAtoms)
                    throw 'Invalid MDL MOL: bond line' + (n + 1);
                let order = type >= 1 && type <= 3 ? type : type == 8 ? 0 : 1;
                let style = WebMolKit.Molecule.BONDTYPE_NORMAL;
                if (stereo == 1)
                    style = WebMolKit.Molecule.BONDTYPE_INCLINED;
                else if (stereo == 6)
                    style = WebMolKit.Molecule.BONDTYPE_DECLINED;
                else if (stereo == 3 || stereo == 4)
                    style = WebMolKit.Molecule.BONDTYPE_UNKNOWN;
                let b = this.mol.addBond(bfr, bto, order, style);
                if (type == 4) {
                    let src = { 'row': this.pos - 1, 'col': 6, 'len': 3 };
                    this.openmol.addJoin(WebMolKit.OpenMolType.QueryResonance, null, [b], [src]);
                }
            }
            const MBLK_CHG = 1, MBLK_RAD = 2, MBLK_ISO = 3, MBLK_RGP = 4, MBLK_HYD = 5, MBLK_ZCH = 6, MBLK_ZBO = 7, MBLK_ZPA = 8, MBLK_ZRI = 9, MBLK_ZAR = 10;
            let resPaths = new Map(), resRings = new Map(), arenes = new Map();
            let superatoms = new Map(), mixtures = new Map();
            while (true) {
                line = this.nextLine();
                if (line.startsWith('M  END'))
                    break;
                let type = 0;
                if (line.startsWith('M  CHG'))
                    type = MBLK_CHG;
                else if (line.startsWith('M  RAD'))
                    type = MBLK_RAD;
                else if (line.startsWith('M  ISO'))
                    type = MBLK_ISO;
                else if (line.startsWith('M  RGP'))
                    type = MBLK_RGP;
                else if (this.parseExtended && line.startsWith('M  HYD'))
                    type = MBLK_HYD;
                else if (this.parseExtended && line.startsWith('M  ZCH'))
                    type = MBLK_ZCH;
                else if (this.parseExtended && line.startsWith('M  ZBO'))
                    type = MBLK_ZBO;
                else if (this.parseExtended && line.startsWith('M  ZPA'))
                    type = MBLK_ZPA;
                else if (this.parseExtended && line.startsWith('M  ZRI'))
                    type = MBLK_ZRI;
                else if (this.parseExtended && line.startsWith('M  ZAR'))
                    type = MBLK_ZAR;
                else if (line.startsWith('A  ') && line.length >= 6) {
                    let anum = parseInt(line.substring(3, 6).trim());
                    if (anum >= 1 && anum <= this.mol.numAtoms) {
                        line = this.nextLine();
                        if (line == null)
                            break;
                        this.mol.setAtomElement(anum, line);
                        continue;
                    }
                }
                else if (line.startsWith('M  STY')) {
                    let len = parseInt(line.substring(6, 9).trim());
                    for (let n = 0; n < len; n++) {
                        let idx = parseInt(line.substring(9 + 8 * n, 13 + 8 * n).trim());
                        let stype = line.substring(14 + 8 * n, 17 + 8 * n);
                        if (stype == 'SUP')
                            superatoms.set(idx, { 'atoms': [], 'name': null });
                        else if (stype == 'MIX' || stype == 'FOR')
                            mixtures.set(idx, { 'index': idx, 'parent': 0, 'atoms': [], 'type': stype });
                        else if (stype == 'SRU' || stype == 'COP')
                            superatoms.set(idx, { 'atoms': [], 'name': null, 'bracketType': stype });
                    }
                }
                else if (line.startsWith('M  SPL')) {
                    let len = parseInt(line.substring(6, 9).trim());
                    for (let n = 0; n < len; n++) {
                        let child = parseInt(line.substring(9 + 8 * n, 13 + 8 * n).trim());
                        let parent = parseInt(line.substring(13 + 8 * n, 17 + 8 * n).trim());
                        let mix = mixtures.get(child);
                        if (mix != null)
                            mix.parent = parent;
                    }
                }
                else if (line.startsWith('M  SAL')) {
                    let idx = parseInt(line.substring(6, 10).trim());
                    let sup = superatoms.get(idx);
                    if (sup != null) {
                        let len = parseInt(line.substring(10, 13).trim());
                        let atoms = WebMolKit.Vec.numberArray(0, len);
                        for (let n = 0; n < len; n++)
                            atoms[n] = parseInt(line.substring(13 + 4 * n, 17 + 4 * n).trim());
                        sup.atoms = WebMolKit.Vec.concat(sup.atoms, atoms);
                    }
                    let mix = mixtures.get(idx);
                    if (mix != null) {
                        let len = parseInt(line.substring(10, 13).trim());
                        let atoms = WebMolKit.Vec.numberArray(0, len);
                        for (let n = 0; n < len; n++)
                            atoms[n] = parseInt(line.substring(13 + 4 * n, 17 + 4 * n).trim());
                        mix.atoms = WebMolKit.Vec.concat(mix.atoms, atoms);
                    }
                }
                else if (line.startsWith('M  SBL')) {
                    let idx = parseInt(line.substring(6, 10).trim());
                    let sup = superatoms.get(idx);
                    if (sup != null) {
                        let len = parseInt(line.substring(10, 13).trim());
                        let bonds = WebMolKit.Vec.numberArray(0, len);
                        for (let n = 0; n < len; n++)
                            bonds[n] = parseInt(line.substring(13 + 4 * n, 17 + 4 * n).trim());
                        sup.bonds = WebMolKit.Vec.concat(sup.bonds, bonds);
                    }
                }
                else if (line.startsWith('M  SMT')) {
                    let idx = parseInt(line.substring(6, 10).trim());
                    let sup = superatoms.get(idx);
                    if (sup != null)
                        sup.name = line.substring(11).trim();
                }
                else if (line.startsWith('M  SCN')) {
                    let len = parseInt(line.substring(6, 9).trim());
                    for (let n = 0; n < len; n++) {
                        let idx = parseInt(line.substring(9 + 8 * n, 13 + 8 * n).trim());
                        let stype = line.substring(14 + 8 * n, 17 + 8 * n);
                        let sup = superatoms.get(idx);
                        if (sup != null)
                            sup.connectType = stype.trim();
                    }
                }
                else if (line.startsWith('M  CRS')) {
                    let idx = parseInt(line.substring(6, 10).trim());
                    let sup = superatoms.get(idx);
                    if (sup != null) {
                        let len = parseInt(line.substring(10, 13).trim());
                        sup.bondConn = WebMolKit.Vec.numberArray(0, len);
                        for (let n = 0; n < len; n++)
                            sup.bondConn[n] = parseInt(line.substring(13 + 4 * n, 17 + 4 * n).trim());
                    }
                }
                else if (line.startsWith('M  LIN')) {
                    let len = parseInt(line.substring(6, 9).trim());
                    for (let n = 0; n < len; n++) {
                        let node = {
                            'atom': parseInt(line.substring(9 + 8 * n, 13 + 8 * n).trim()),
                            'nbrs': [],
                            'minRep': 1,
                            'maxRep': parseInt(line.substring(13 + 8 * n, 17 + 8 * n).trim()),
                        };
                        let nbr1 = parseInt(line.substring(17 + 8 * n, 21 + 8 * n).trim());
                        let nbr2 = parseInt(line.substring(21 + 8 * n, 25 + 8 * n).trim());
                        if (nbr1 > 0)
                            node.nbrs.push(nbr1);
                        if (nbr2 > 0)
                            node.nbrs.push(nbr2);
                        this.groupLinkNodes.push(node);
                    }
                }
                if (type == MBLK_ZPA || type == MBLK_ZRI || type == MBLK_ZAR) {
                    let len = parseInt(line.substring(6, 9).trim()), blk = parseInt(line.substring(9, 13).trim());
                    let map = type == MBLK_ZPA ? resPaths : type == MBLK_ZRI ? resRings : arenes;
                    for (let n = 0; n < len; n++) {
                        let val = parseInt(line.substring(13 + 4 * n, 17 + 4 * n).trim());
                        if (val < 1 || val > numAtoms)
                            throw 'Invalid MDL MOL: M-block';
                        let atoms = map.get(blk);
                        if (!atoms)
                            map.set(blk, atoms = []);
                        atoms.push(val);
                    }
                }
                else if (type > 0) {
                    let len = parseInt(line.substring(6, 9).trim());
                    for (let n = 0; n < len; n++) {
                        let pos = parseInt(line.substring(9 + 8 * n, 13 + 8 * n).trim());
                        let val = parseInt(line.substring(13 + 8 * n, 17 + 8 * n).trim());
                        if (pos < 1)
                            throw 'Invalid MDL MOL: M-block';
                        if (type == MBLK_CHG)
                            this.mol.setAtomCharge(pos, val);
                        else if (type == MBLK_RAD) {
                            if (val == 1 || val == 3)
                                this.mol.setAtomUnpaired(pos, 2);
                            else if (val == 2)
                                this.mol.setAtomUnpaired(pos, 1);
                        }
                        else if (type == MBLK_ISO)
                            this.mol.setAtomIsotope(pos, val);
                        else if (type == MBLK_RGP)
                            this.mol.setAtomElement(pos, 'R' + val);
                        else if (type == MBLK_HYD) {
                            this.mol.setAtomHExplicit(pos, val);
                            let src = { 'row': this.pos - 1, 'col': 9 + 8 * n, 'len': 8 };
                            this.openmol.addJoin(WebMolKit.OpenMolType.HydrogenCounting, [pos], null, [src]);
                        }
                        else if (type == MBLK_ZCH)
                            this.mol.setAtomCharge(pos, val);
                        else if (type == MBLK_ZBO) {
                            this.mol.setBondOrder(pos, val);
                            let src = { 'row': this.pos - 1, 'col': 9 + 8 * n, 'len': 8 };
                            this.openmol.addJoin(WebMolKit.OpenMolType.ZeroOrderBonds, null, [pos], [src]);
                        }
                    }
                }
            }
            this.postFix();
            if (this.parseExtended) {
                let artifacts = new WebMolKit.BondArtifact(this.mol);
                for (let atoms of resPaths.values())
                    artifacts.createPath(atoms);
                for (let atoms of resRings.values())
                    artifacts.createRing(atoms);
                for (let atoms of arenes.values())
                    artifacts.createArene(atoms);
                artifacts.rewriteMolecule();
            }
            for (let key of WebMolKit.Vec.sorted(Array.from(superatoms.keys()))) {
                let value = superatoms.get(key);
                if (value.bracketType) {
                    superatoms.delete(key);
                    this.applyPolymerBlock(value);
                }
            }
            for (let key of WebMolKit.Vec.sorted(Array.from(superatoms.keys()))) {
                let value = superatoms.get(key);
                superatoms.delete(key);
                this.applySuperAtom(value, Array.from(superatoms.values()));
            }
            for (let key of WebMolKit.Vec.sorted(Array.from(mixtures.keys())))
                this.groupMixtures.push(mixtures.get(key));
            this.openmol.derive(this.mol);
        }
        postFix() {
            const mol = this.mol;
            for (let n = 1; n <= mol.numAtoms; n++) {
                let el = mol.atomElement(n);
                if (el == 'D') {
                    mol.setAtomElement(n, 'H');
                    mol.setAtomIsotope(n, 2);
                }
                else if (el == 'T') {
                    mol.setAtomElement(n, 'H');
                    mol.setAtomIsotope(n, 3);
                }
                let valence = this.explicitValence[n - 1], options = WebMolKit.MDLMOL_VALENCE[el];
                if (valence != 0) {
                    let hcount = valence < 0 || valence > 14 ? 0 : valence;
                    for (let b of mol.atomAdjBonds(n))
                        hcount -= mol.bondOrder(b);
                    if (hcount != mol.atomHydrogens(n))
                        mol.setAtomHExplicit(n, Math.max(0, hcount));
                }
                else if (options) {
                    let chg = mol.atomCharge(n);
                    let chgmod = (el == 'C' || el == 'H') ? Math.abs(chg) : el == 'B' ? -Math.abs(chg) : -chg;
                    let usedValence = chgmod;
                    let unp = mol.atomUnpaired(n);
                    if (unp > 0 && (el == 'C' || el == 'O' || el == 'S' || el == 'N' || el == 'P'))
                        usedValence += unp;
                    for (let b of mol.atomAdjBonds(n))
                        usedValence += mol.bondOrder(b);
                    for (let v of options)
                        if (usedValence <= v) {
                            let hcount = v - usedValence;
                            if (hcount != mol.atomHydrogens(n))
                                mol.setAtomHExplicit(n, Math.max(0, hcount));
                            break;
                        }
                }
            }
            if (this.considerRescale)
                WebMolKit.CoordUtil.normaliseBondDistances(mol);
            mol.keepTransient = false;
        }
        parseV3000() {
            let Section;
            (function (Section) {
                Section[Section["ATOM"] = 0] = "ATOM";
                Section[Section["BOND"] = 1] = "BOND";
                Section[Section["COLL"] = 2] = "COLL";
                Section[Section["SGROUP"] = 3] = "SGROUP";
            })(Section || (Section = {}));
            let inCTAB = false, section = null;
            let lineCounts = null;
            let lineAtom = [], lineBond = [], lineColl = [], lineSgroup = [];
            const ERRPFX = 'Invalid MDL MOL V3000: ';
            while (true) {
                let line = this.nextLine();
                if (line == 'M  END')
                    break;
                if (!line.startsWith('M  V30 '))
                    continue;
                line = line.substring(7);
                if (line.startsWith('COUNTS '))
                    lineCounts = line.substring(7);
                else if (line.startsWith('BEGIN CTAB'))
                    inCTAB = true;
                else if (line.startsWith('BEGIN ATOM'))
                    section = Section.ATOM;
                else if (line.startsWith('BEGIN BOND'))
                    section = Section.BOND;
                else if (line.startsWith('BEGIN COLLECTION'))
                    section = Section.COLL;
                else if (line.startsWith('BEGIN SGROUP'))
                    section = Section.SGROUP;
                else if (line.startsWith('END '))
                    section = null;
                else if (inCTAB && section == Section.ATOM)
                    lineAtom.push(line);
                else if (inCTAB && section == Section.BOND)
                    lineBond.push(line);
                else if (inCTAB && section == Section.COLL)
                    lineColl.push(line);
                else if (inCTAB && section == Section.SGROUP)
                    lineSgroup.push(line);
                else if (inCTAB && section == null) {
                    if (line.startsWith('LINKNODE ')) {
                        let bits = this.splitWithQuotes(line.substring(9));
                        let node = {
                            'atom': 0,
                            'nbrs': [],
                            'minRep': parseInt(bits[0]),
                            'maxRep': parseInt(bits[1])
                        };
                        let nb = parseInt(bits[2]);
                        let atoms = [];
                        for (let n = 0; n < nb * 2; n++)
                            atoms.push(parseInt(bits[3 + n]));
                        WebMolKit.Vec.sort(atoms);
                        for (let n = 0; n < atoms.length; n++) {
                            if (n < atoms.length - 1 && atoms[n] == atoms[n + 1])
                                node.atom = atoms[n++];
                            else
                                node.nbrs.push(atoms[n]);
                        }
                        this.groupLinkNodes.push(node);
                    }
                }
            }
            let counts = lineCounts.split(/\s+/);
            if (counts.length < 2)
                throw ERRPFX + 'counts line malformatted';
            let numAtoms = parseInt(counts[0]), numBonds = parseInt(counts[1]);
            if (numAtoms < 0 || numAtoms > lineAtom.length)
                throw ERRPFX + 'unreasonable atom count: ' + numAtoms;
            if (numBonds < 0 || numBonds > lineBond.length)
                throw ERRPFX + 'unreasonable bond count: ' + numBonds;
            let atomBits = [], bondBits = [];
            for (let n = 0; n < lineAtom.length; n++) {
                let line = lineAtom[n];
                while (n < lineAtom.length - 1 && line.endsWith('-')) {
                    n++;
                    line = line.substring(0, line.length - 1) + lineAtom[n];
                }
                let bits = this.splitWithQuotes(line);
                if (bits.length < 6)
                    throw ERRPFX + 'atom line has too few components: ' + line;
                let idx = parseInt(bits[0], 0);
                if (idx < 1 || idx > numAtoms)
                    throw ERRPFX + 'invalid atom index: ' + bits[0];
                if (atomBits[idx - 1] != null)
                    throw ERRPFX + 'duplicate atom index: ' + idx;
                atomBits[idx - 1] = bits;
            }
            for (let n = 0; n < lineBond.length; n++) {
                let line = lineBond[n];
                while (n < lineBond.length - 1 && line.endsWith('-')) {
                    n++;
                    line = line.substring(0, line.length - 1) + lineBond[n];
                }
                let bits = this.splitWithQuotes(line);
                if (bits.length < 4)
                    throw ERRPFX + 'bond line has too few components: ' + line;
                let idx = parseInt(bits[0], 0);
                if (idx < 1 || idx > numBonds)
                    throw ERRPFX + 'invalid bond index: ' + bits[0];
                if (bondBits[idx - 1] != null)
                    throw ERRPFX + 'duplicate bond index: ' + idx;
                bondBits[idx - 1] = bits;
            }
            this.explicitValence = WebMolKit.Vec.numberArray(0, numAtoms);
            for (let a = 1; a <= numAtoms; a++) {
                let bits = atomBits[a - 1];
                if (bits == null)
                    throw ERRPFX + 'atom definition missing for #' + a;
                let type = bits[1];
                let x = parseFloat(bits[2]), y = parseFloat(bits[3]), z = parseFloat(bits[4]);
                let map = parseInt(bits[5]);
                this.mol.addAtom(type, x, y);
                this.mol.setAtomMapNum(a, map);
                for (let i = 6; i < bits.length; i++) {
                    let eq = bits[i].indexOf('=');
                    if (eq < 0)
                        continue;
                    let key = bits[i].substring(0, eq), val = bits[i].substring(eq + 1);
                    if (key == 'CHG')
                        this.mol.setAtomCharge(a, parseInt(val));
                    else if (key == 'RAD') {
                        let spin = parseInt(val);
                        if (spin == 1 || spin == 3)
                            this.mol.setAtomUnpaired(a, 2);
                        else if (spin == 2)
                            this.mol.setAtomUnpaired(a, 1);
                    }
                    else if (key == 'MASS')
                        this.mol.setAtomIsotope(a, parseInt(val));
                    else if (key == 'CFG') {
                        let stereo = parseInt(val);
                        if (stereo > 0 && this.keepParity) {
                        }
                    }
                    else if (key == 'VAL')
                        this.explicitValence[a - 1] = parseInt(val);
                }
            }
            for (let b = 1; b <= numBonds; b++) {
                let bits = bondBits[b - 1];
                if (bits == null)
                    throw ERRPFX + 'bond definition missing for #' + b;
                let type = parseInt(bits[1]), bfr = parseInt(bits[2]), bto = parseInt(bits[3]);
                let order = type >= 1 && type <= 3 ? type : type == 9 || type == 10 ? 0 : 1;
                this.mol.addBond(bfr, bto, order);
                if (type == 4) {
                }
                let endpts = null;
                let attach = null;
                for (let i = 4; i < bits.length; i++) {
                    let eq = bits[i].indexOf('=');
                    if (eq < 0)
                        continue;
                    let key = bits[i].substring(0, eq), val = bits[i].substring(eq + 1);
                    if (key == 'CFG') {
                        let dir = parseInt(val);
                        this.mol.setBondType(b, dir == 1 ? WebMolKit.Molecule.BONDTYPE_INCLINED :
                            dir == 2 ? WebMolKit.Molecule.BONDTYPE_UNKNOWN :
                                dir == 3 ? WebMolKit.Molecule.BONDTYPE_DECLINED : WebMolKit.Molecule.BONDTYPE_NORMAL);
                    }
                    else if (key == 'DISP') {
                        if (val == 'COORD')
                            this.mol.setBondOrder(b, 0);
                    }
                    else if (key == 'ENDPTS')
                        endpts = this.unpackList(val);
                    else if (key == 'ATTACH')
                        attach = val;
                }
                if (attach != null && endpts != null) {
                    if (attach == 'ALL')
                        this.groupAttachAll.set(b, endpts);
                    else if (attach == 'ANY')
                        this.groupAttachAny.set(b, endpts);
                }
            }
            this.postFix();
            for (let n = 0; n < lineColl.length; n++) {
                let line = lineColl[n];
                while (n < lineColl.length - 1 && line.endsWith('-')) {
                    n++;
                    line = line.substring(0, line.length - 1) + lineColl[n];
                }
                let bits = this.splitWithQuotes(line);
                if (bits[0].startsWith('MDLV30/STEABS')) {
                    if (bits[1].startsWith('ATOMS='))
                        this.groupStereoAbsolute = this.unpackList(bits[1].substring(5));
                }
                else if (bits[0].startsWith('MDLV30/STERAC')) {
                    if (bits[1].startsWith('ATOMS='))
                        this.groupStereoRacemic.push(this.unpackList(bits[1].substring(6)));
                }
                else if (bits[0].startsWith('MDLV30/STEREL')) {
                    if (bits[1].startsWith('ATOMS='))
                        this.groupStereoRelative.push(this.unpackList(bits[1].substring(6)));
                }
            }
            let superatoms = new Map();
            for (let n = 0; n < lineSgroup.length; n++) {
                let line = lineSgroup[n];
                while (n < lineSgroup.length - 1 && line.endsWith('-')) {
                    n++;
                    line = line.substring(0, line.length - 1) + lineSgroup[n];
                }
                let bits = this.splitWithQuotes(line);
                let idx = parseInt(bits[0]);
                if (bits.length > 3 && idx > 0 && bits[1] == 'SUP' && parseInt(bits[2]) == idx) {
                    let sup = { 'atoms': [], 'name': null };
                    for (let i = 3; i < bits.length; i++) {
                        if (bits[i].startsWith('ATOMS='))
                            sup.atoms = this.unpackList(bits[i].substring(6));
                        else if (bits[i].startsWith('LABEL='))
                            sup.name = this.withoutQuotes(bits[i].substring(6));
                    }
                    superatoms.set(idx, sup);
                }
                else if (bits.length > 3 && idx > 0 && (bits[1] == 'MIX' || bits[1] == 'FOR') && parseInt(bits[2]) == idx) {
                    let mix = { 'index': idx, 'parent': 0, 'atoms': null, 'type': bits[1] };
                    for (let i = 3; i < bits.length; i++) {
                        if (bits[i].startsWith('ATOMS='))
                            mix.atoms = this.unpackList(bits[i].substring(6));
                        else if (bits[i].startsWith('PARENT='))
                            mix.parent = parseInt(bits[i].substring(7));
                    }
                    this.groupMixtures.push(mix);
                }
                else if (bits.length > 3 && idx > 0 && (bits[1] == 'SRU' || bits[1] == 'COP') && parseInt(bits[2]) == idx) {
                    let sup = { 'atoms': [], 'name': null, 'bracketType': bits[1] };
                    for (let i = 3; i < bits.length; i++) {
                        if (bits[i].startsWith('ATOMS='))
                            sup.atoms = this.unpackList(bits[i].substring(6));
                        else if (bits[i].startsWith('BONDS='))
                            sup.bonds = this.unpackList(bits[i].substring(6));
                        else if (bits[i].startsWith('LABEL='))
                            sup.name = this.withoutQuotes(bits[i].substring(6));
                        else if (bits[i].startsWith('CONNECT='))
                            sup.connectType = bits[i].substring(8);
                        else if (bits[i].startsWith('XBCORR='))
                            sup.bondConn = this.unpackList(bits[i].substring(7));
                    }
                    superatoms.set(idx, sup);
                }
            }
            for (let key of WebMolKit.Vec.sorted(Array.from(superatoms.keys()))) {
                let value = superatoms.get(key);
                if (value.bracketType) {
                    superatoms.delete(key);
                    this.applyPolymerBlock(value);
                }
            }
            for (let key of WebMolKit.Vec.sorted(Array.from(superatoms.keys()))) {
                let value = superatoms.get(key);
                superatoms.delete(key);
                this.applySuperAtom(value, Array.from(superatoms.values()));
            }
        }
        applySuperAtom(sup, residual) {
            if (sup.name == null || WebMolKit.Vec.isBlank(sup.atoms))
                return;
            let mask = WebMolKit.Vec.booleanArray(true, this.mol.numAtoms);
            for (let a of sup.atoms)
                mask[a - 1] = false;
            let name = sup.name;
            let i;
            while ((i = name.indexOf('\\S')) >= 0)
                name = name.substring(0, i) + '{^' + name.substring(i + 2);
            while ((i = name.indexOf('\\s')) >= 0)
                name = name.substring(0, i) + '{' + name.substring(i + 2);
            while ((i = name.indexOf('\\n')) >= 0)
                name = name.substring(0, i) + '}' + name.substring(i + 2);
            let [mod, abvAtom] = WebMolKit.MolUtil.convertToAbbrevIndex(this.mol, mask, name);
            if (mod == null)
                return;
            this.mol = mod;
            let map = WebMolKit.Vec.maskMap(mask);
            for (let res of residual) {
                let subsumed = false;
                for (let n = res.atoms.length - 1; n >= 0; n--) {
                    let atom = map[res.atoms[n] - 1] + 1;
                    if (atom == 0) {
                        res.atoms = WebMolKit.Vec.remove(res.atoms, n);
                        subsumed = true;
                    }
                    else
                        res.atoms[n] = atom;
                }
                if (subsumed)
                    res.atoms = WebMolKit.Vec.sorted(WebMolKit.Vec.append(res.atoms, abvAtom));
            }
        }
        applyPolymerBlock(sup) {
            let poly = new WebMolKit.PolymerBlock(this.mol);
            let connect = null;
            if (sup.connectType == null) { }
            else if (sup.connectType == 'HT')
                connect = WebMolKit.PolymerBlockConnectivity.HeadToTail;
            else if (sup.connectType == 'HH')
                connect = WebMolKit.PolymerBlockConnectivity.HeadToHead;
            else if (sup.connectType == 'EU')
                connect = WebMolKit.PolymerBlockConnectivity.Random;
            else
                return;
            let bondConn = null;
            if (WebMolKit.Vec.len(sup.bondConn) == 3) {
                let b1 = sup.bondConn[0], b2 = sup.bondConn[2], b3 = sup.bondConn[1], b4 = 0;
                for (let n = 1; n <= this.mol.numBonds; n++)
                    if (n != b1 && n != b2 && n != b3) {
                        let in1 = sup.atoms.indexOf(this.mol.bondFrom(n)) >= 0, in2 = sup.atoms.indexOf(this.mol.bondTo(n)) >= 0;
                        if ((in1 && !in2) || (!in1 && in2)) {
                            if (b4 > 0) {
                                b4 = 0;
                                break;
                            }
                            b4 = n;
                        }
                    }
                bondConn = [b1, b2, b3, b4];
            }
            else if (WebMolKit.Vec.len(sup.bondConn) == 4) {
                bondConn = sup.bondConn;
            }
            let unit = new WebMolKit.PolymerBlockUnit(sup.atoms);
            unit.connect = connect;
            unit.bondConn = bondConn;
            poly.createUnit(unit);
        }
        withoutQuotes(str) {
            if (str.length >= 2 && str.startsWith('"') && str.endsWith('"'))
                return str.substring(1, str.length - 1);
            return str;
        }
        splitWithQuotes(line) {
            let segments = [];
            let seg = '';
            let depth = 0, quote = false;
            for (let n = 0; n < line.length; n++) {
                let ch = line.charAt(n);
                if (ch == ' ' && depth == 0 && !quote) {
                    if (seg.length > 0)
                        segments.push(seg);
                    seg = '';
                }
                else {
                    seg += ch;
                    if (ch == '"')
                        quote = !quote;
                    else if (ch == '(' || ch == '[')
                        depth++;
                    else if (ch == ')' || ch == ']')
                        depth--;
                }
            }
            if (seg.length > 0)
                segments.push(seg);
            return segments;
        }
        unpackList(str) {
            if (!str.startsWith('(') || !str.endsWith(')'))
                return null;
            str = str.substring(1, str.length - 1);
            let values = [];
            for (let bit of str.split(' '))
                values.push(parseInt(bit));
            if (values[0] != values.length - 1)
                return null;
            return WebMolKit.Vec.remove(values, 0);
        }
    }
    WebMolKit.MDLMOLReader = MDLMOLReader;
    class MDLSDFReader {
        constructor(strData) {
            this.ds = new WebMolKit.DataSheet();
            this.upcastColumns = true;
            this.pos = 0;
            this.lines = strData.split(/\r?\n/);
        }
        parse() {
            this.parseStream();
            if (this.upcastColumns)
                this.upcastStringColumns();
            return this.ds;
        }
        parseStream() {
            let ds = this.ds;
            ds.appendColumn('Molecule', "molecule", 'Molecular structure');
            let colName = -1;
            let entry = [];
            while (this.pos < this.lines.length) {
                let line = this.lines[this.pos++];
                if (!line.startsWith('$$$$')) {
                    entry.push(line);
                    continue;
                }
                let rn = ds.appendRow();
                let molstr = '';
                let pos = 0;
                while (pos < entry.length) {
                    line = entry[pos];
                    if (line.startsWith('> '))
                        break;
                    molstr += line + '\n';
                    pos++;
                    if (line.startsWith('M	END'))
                        break;
                }
                let mol = null, name = null;
                try {
                    if (molstr.length > 0) {
                        let mdl = new MDLMOLReader(molstr);
                        mdl.parse();
                        mol = mdl.mol;
                        name = mdl.molName;
                    }
                }
                catch (ex) {
                }
                if (mol != null)
                    ds.setMolecule(rn, 0, mol);
                if (name) {
                    if (colName < 0)
                        colName = ds.appendColumn('Name', "string", 'Molecule name');
                    ds.setString(rn, colName, name);
                }
                if (rn == 0 && mol != null) {
                    let str1 = entry[0], str3 = entry[2];
                    if (str1.length >= 7 && str1.startsWith('$name=')) {
                        ds.changeColumnName(0, str1.substring(6), ds.colDescr(0));
                    }
                    if (str3.length >= 8 && str3.startsWith('$title=')) {
                        ds.title = str3.substring(7);
                    }
                }
                for (; pos + 1 < entry.length; pos += 3) {
                    let key = entry[pos], val = entry[pos + 1];
                    if (!key.startsWith('>'))
                        continue;
                    let z = key.indexOf('<');
                    if (z < 0)
                        continue;
                    key = key.substring(z + 1);
                    z = key.indexOf('>');
                    if (z < 0)
                        continue;
                    key = key.substring(0, z);
                    if (key.length == 0)
                        continue;
                    while (pos + 2 < entry.length && entry[pos + 2].length > 0) {
                        val += '\n' + entry[pos + 2];
                        pos++;
                    }
                    let cn = ds.findColByName(key);
                    if (cn < 0)
                        cn = ds.appendColumn(key, "string", '');
                    if (val.length == 0)
                        ds.setToNull(rn, cn);
                    else
                        ds.setString(rn, cn, val);
                }
                entry = [];
            }
            if (ds.numRows == 0)
                this.ds = null;
        }
        upcastStringColumns() {
            let ds = this.ds;
            for (let i = 0; i < ds.numCols; i++)
                if (ds.colType(i) == "string") {
                    let allnull = true, allreal = true, allint = true, allbool = true;
                    for (let j = 0; j < ds.numRows; j++) {
                        if (!allreal && !allint && !allbool)
                            break;
                        if (ds.isNull(j, i))
                            continue;
                        allnull = false;
                        let val = ds.getString(j, i);
                        if (allbool) {
                            let lc = val.toLowerCase();
                            if (lc != 'true' && lc != 'false')
                                allbool = false;
                        }
                        if (allint) {
                            let int = parseInt(val);
                            if (!isFinite(int) || int != parseFloat(val))
                                allint = false;
                        }
                        if (allreal) {
                            if (!isFinite(parseFloat(val)))
                                allreal = false;
                        }
                    }
                    if (allnull) { }
                    else if (allint)
                        ds.changeColumnType(i, "integer");
                    else if (allreal)
                        ds.changeColumnType(i, "real");
                    else if (allbool)
                        ds.changeColumnType(i, "boolean");
                }
        }
    }
    WebMolKit.MDLSDFReader = MDLSDFReader;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class MDLMOLWriter {
        constructor(mol) {
            this.mol = mol;
            this.includeHeader = true;
            this.enhancedFields = true;
            this.chargeSeparate = false;
            this.abbrevSgroups = true;
            this.polymerBlocks = true;
            this.molName = '';
            this.sgroupNames = [];
            this.sgroupAtoms = [];
            this.lines = [];
        }
        write() {
            if (this.includeHeader) {
                this.lines.push(this.molName);
                this.lines.push('Generated by WebMolKit');
                this.lines.push('');
                this.writeCTAB();
            }
            return this.lines.join('\n');
        }
        getResult() {
            return this.lines.join('\n');
        }
        writeCTAB() {
            let mol = this.mol;
            if (WebMolKit.MolUtil.hasAnyAbbrev(mol)) {
                mol = this.mol = mol.clone();
                if (this.abbrevSgroups) {
                    this.partialAbbrevExpansion();
                    this.prepareSgroups();
                }
                else
                    WebMolKit.MolUtil.expandAbbrevs(mol, true);
            }
            this.lines.push(this.intrpad(mol.numAtoms, 3) + this.intrpad(mol.numBonds, 3) + '  0  0  0  0  0  0  0  0999 V2000');
            let chgidx = [], chgval = [];
            let radidx = [], radval = [];
            let isoidx = [], isoval = [];
            let rgpidx = [], rgpval = [];
            let hydidx = [], hydval = [];
            let zchidx = [], zchval = [];
            let zboidx = [], zboval = [];
            for (let n = 1; n <= mol.numAtoms; n++) {
                let x = mol.atomX(n), y = mol.atomY(n), z = 0;
                let line = this.rpad(x.toFixed(4), 10) + this.rpad(y.toFixed(4), 10) + this.rpad(z.toFixed(4), 10);
                let el = mol.atomElement(n);
                let str = el;
                if (str.length > 3)
                    str = str.substring(0, 3);
                if (str.length > 1 && str.charAt(0) == 'R' && str.charAt(1) >= '0' && str.charAt(1) <= '9') {
                    rgpidx.push(n);
                    rgpval.push(parseInt(str.substring(1)));
                    str = 'R#';
                }
                while (str.length < 4)
                    str += ' ';
                line += ' ' + str + '0';
                let chg = mol.atomCharge(n), rad = mol.atomUnpaired(n), mapnum = mol.atomMapNum(n);
                if (chg >= -3 && chg <= -1)
                    chg = 4 - chg;
                else if (chg == 0 && rad == 2)
                    chg = 4;
                else if (chg >= 1 && chg <= 3)
                    chg = 4 - chg;
                else
                    chg = 0;
                let val = this.mdlValence(mol, n, 15);
                line += this.intrpad(chg, 3) + '  0  0  0' + this.intrpad(val, 3) + '  0  0  0' + this.intrpad(mapnum, 3) + '  0  0';
                this.lines.push(line);
                if (mol.atomCharge(n) != 0) {
                    chgidx.push(n);
                    chgval.push(mol.atomCharge(n));
                }
                if (this.enhancedFields) {
                    if (mol.atomHExplicit(n) != WebMolKit.Molecule.HEXPLICIT_UNKNOWN) {
                        hydidx.push(n);
                        hydval.push(mol.atomHExplicit(n));
                    }
                }
                if (rad == 1) {
                    radidx.push(n);
                    radval.push(2);
                }
                if (rad == 2) {
                    radidx.push(n);
                    radval.push(1);
                }
                if (mol.atomIsotope(n) != WebMolKit.Molecule.ISOTOPE_NATURAL) {
                    isoidx.push(n);
                    isoval.push(mol.atomIsotope(n));
                }
            }
            for (let n = 1; n <= mol.numBonds; n++) {
                let order = mol.bondOrder(n), type = order;
                if (type == 0)
                    type = 8;
                else if (type > 3)
                    type = 3;
                let stereo = mol.bondType(n);
                if (stereo == WebMolKit.Molecule.BONDTYPE_NORMAL) { }
                else if (stereo == WebMolKit.Molecule.BONDTYPE_INCLINED) {
                    stereo = 1;
                }
                else if (stereo == WebMolKit.Molecule.BONDTYPE_DECLINED) {
                    stereo = 6;
                }
                else if (stereo == WebMolKit.Molecule.BONDTYPE_UNKNOWN) {
                    if (type == 1)
                        stereo = 4;
                    else
                        stereo = 3;
                }
                else
                    stereo = 0;
                let line = this.intrpad(mol.bondFrom(n), 3) + this.intrpad(mol.bondTo(n), 3) +
                    this.intrpad(type, 3) + this.intrpad(stereo, 3) + '  0  0  0';
                this.lines.push(line);
                if (this.enhancedFields) {
                    if ((order < 1 || order > 3) || type != order) {
                        zboidx.push(n);
                        zboval.push(order);
                    }
                }
            }
            this.writeMBlockPair('CHG', chgidx, chgval);
            this.writeMBlockPair('RAD', radidx, radval);
            this.writeMBlockPair('ISO', isoidx, isoval);
            this.writeMBlockPair('RGP', rgpidx, rgpval);
            this.writeMBlockPair('HYD', hydidx, hydval);
            this.writeMBlockPair('ZCH', zchidx, zchval);
            this.writeMBlockPair('ZBO', zboidx, zboval);
            if (this.enhancedFields) {
                let artifacts = new WebMolKit.BondArtifact(this.mol);
                let idx = 0;
                for (let path of artifacts.getResPaths())
                    this.writeMBlockFlat('ZPA', ++idx, path.atoms);
                for (let ring of artifacts.getResRings())
                    this.writeMBlockFlat('ZRI', ++idx, ring.atoms);
                for (let arene of artifacts.getArenes())
                    this.writeMBlockFlat('ZAR', ++idx, WebMolKit.Vec.prepend(arene.atoms, arene.centre));
            }
            let inSgroup = WebMolKit.Vec.booleanArray(false, mol.numAtoms);
            for (let s = 0; s < this.sgroupAtoms.length; s++) {
                let sgroup = this.sgroupAtoms[s];
                for (let n of sgroup)
                    inSgroup[n - 1] = true;
                let sidx = this.intrpad(s + 1, 4);
                this.lines.push('M  STY  1' + sidx + ' SUP');
                for (let n = 0; n < sgroup.length; n += 15) {
                    let sz = Math.min(sgroup.length - n, 15);
                    let line = 'M  SAL' + sidx + this.intrpad(sz, 3);
                    for (let i = 0; i < sz; i++)
                        line += this.intrpad(sgroup[n + i], 4);
                    this.lines.push(line);
                }
                this.lines.push('M  SMT' + sidx + ' ' + this.sgroupNames[s]);
            }
            if (this.polymerBlocks)
                this.encodePolymerBlocks(this.sgroupAtoms.length);
            for (let n = 1; n <= mol.numAtoms; n++)
                if (mol.atomElement(n).length > 2) {
                    this.lines.push('A  ' + this.intrpad(n, 3));
                    this.lines.push(mol.atomElement(n));
                }
            this.lines.push('M  END');
        }
        writeMBlockPair(token, idx, val) {
            const sz = idx.length;
            for (let i = 0; i < sz; i += 8) {
                let count = Math.min(8, sz - i);
                let line = 'M  ' + token + this.intrpad(count, 3);
                for (let j = 0; j < count; j++)
                    line += this.intrpad(idx[i + j], 4) + this.intrpad(val[i + j], 4);
                this.lines.push(line);
            }
        }
        writeMBlockFlat(token, idx, val) {
            const sz = val.length;
            for (let i = 0; i < sz; i += 15) {
                let count = Math.min(15, sz - i);
                let line = 'M  ' + token + this.intrpad(count, 3) + this.intrpad(idx, 4);
                for (let j = 0; j < count; j++)
                    line += this.intrpad(val[i + j], 4);
                this.lines.push(line);
            }
        }
        writeMBlockFlatIdxFirst(token, idx, val) {
            const sz = val.length;
            for (let i = 0; i < sz; i += 15) {
                let count = Math.min(15, sz - i);
                let line = 'M  ' + token + this.intrpad(idx, 4) + this.intrpad(count, 3);
                for (let j = 0; j < count; j++)
                    line += this.intrpad(val[i + j], 4);
                this.lines.push(line);
            }
        }
        intrpad(num, sz) {
            return this.rpad(num.toString(), sz);
        }
        rpad(str, sz) {
            while (str.length < sz)
                str = ' ' + str;
            return str;
        }
        mdlValence(mol, atom, zeroVal) {
            let hyd = mol.atomHydrogens(atom), el = mol.atomElement(atom);
            let options = WebMolKit.MDLMOL_VALENCE[el];
            if (options == null && hyd == 0)
                return 0;
            let chg = mol.atomCharge(atom);
            let chgmod = (el == 'C' || el == 'H') ? Math.abs(chg) : el == 'B' ? -Math.abs(chg) : -chg;
            let bondSum = 0;
            for (let b of mol.atomAdjBonds(atom))
                bondSum += mol.bondOrder(b);
            let nativeVal = chgmod + hyd + bondSum;
            if (options && options[0] == nativeVal)
                return 0;
            let val = nativeVal - chgmod;
            return val <= 0 || val > 14 ? zeroVal : val;
        }
        partialAbbrevExpansion() {
            const { mol } = this;
            for (let n = 1; n <= mol.numAtoms; n++)
                if (WebMolKit.MolUtil.hasAbbrev(mol, n)) {
                    let frag = WebMolKit.MolUtil.getAbbrev(mol, n);
                    if (frag == null || mol.atomAdjCount(n) != 1) {
                        WebMolKit.MolUtil.clearAbbrev(mol, n);
                        continue;
                    }
                    if (WebMolKit.MolUtil.hasAnyAbbrev(frag)) {
                        WebMolKit.MolUtil.expandAbbrevs(frag, true);
                        WebMolKit.MolUtil.setAbbrev(mol, n, frag);
                    }
                    let order = mol.bondOrder(mol.atomAdjBonds(n)[0]);
                    if (frag.atomAdjCount(1) == 1 && order == frag.bondOrder(frag.atomAdjBonds(1)[0]))
                        continue;
                    WebMolKit.MolUtil.expandOneAbbrev(mol, n, true);
                    n--;
                }
        }
        prepareSgroups() {
            const { mol } = this;
            for (let n = 1; n <= mol.numAtoms; n++)
                if (mol.atomMapNum(n) < 0)
                    mol.setAtomMapNum(n, 0);
            let next = 0;
            for (let n = 1; n <= mol.numAtoms; n++)
                if (WebMolKit.MolUtil.hasAbbrev(mol, n)) {
                    this.sgroupNames.push(mol.atomElement(n));
                    let mask = WebMolKit.MolUtil.expandOneAbbrev(mol, n, true);
                    if (mask == null)
                        continue;
                    next--;
                    for (let i = 0; i < mask.length; i++)
                        if (mask[i])
                            mol.setAtomMapNum(i + 1, next);
                    n--;
                }
            for (let idx = -1; idx >= next; idx--) {
                let atoms = [];
                for (let n = 1; n <= mol.numAtoms; n++)
                    if (mol.atomMapNum(n) == idx) {
                        atoms.push(n);
                        mol.setAtomMapNum(n, 0);
                    }
                this.sgroupAtoms.push(atoms);
            }
        }
        encodePolymerBlocks(idx) {
            let polymers = new WebMolKit.PolymerBlock(this.mol);
            for (let id of polymers.getIDList()) {
                let unit = polymers.getUnit(id);
                let sidx = this.intrpad(++idx, 4);
                this.lines.push('M  STY  1' + sidx + ' SRU');
                if (unit.connect == WebMolKit.PolymerBlockConnectivity.HeadToTail)
                    this.lines.push('M  SCN  1' + sidx + ' HT ');
                else if (unit.connect == WebMolKit.PolymerBlockConnectivity.HeadToHead)
                    this.lines.push('M  SCN  1' + sidx + ' HH ');
                else if (unit.connect == WebMolKit.PolymerBlockConnectivity.Random)
                    this.lines.push('M  SCN  1' + sidx + ' EU ');
                this.writeMBlockFlatIdxFirst('SAL', idx, unit.atoms);
                let bonds = null;
                for (let n = 1; n <= this.mol.numBonds; n++) {
                    let fl1 = unit.atoms.indexOf(this.mol.bondFrom(n)) >= 0, fl2 = unit.atoms.indexOf(this.mol.bondTo(n)) >= 0;
                    if ((fl1 && !fl2) || (!fl1 && fl2))
                        bonds = WebMolKit.Vec.append(bonds, n);
                }
                if (bonds != null)
                    this.writeMBlockFlatIdxFirst('SBL', idx, bonds);
                if (WebMolKit.Vec.len(unit.bondConn) == 4) {
                    let bcrs = [unit.bondConn[0], unit.bondConn[2], unit.bondConn[1]];
                    this.writeMBlockFlatIdxFirst('CRS', idx, bcrs);
                }
                this.lines.push('M  SMT' + sidx + ' n');
            }
        }
    }
    WebMolKit.MDLMOLWriter = MDLMOLWriter;
    class MDLSDFWriter {
        constructor(ds) {
            this.ds = ds;
            this.enhancedFields = true;
            this.chargeSeparate = false;
            this.abbrevSgroups = true;
            this.lines = [];
        }
        write() {
            let ds = this.ds, lines = this.lines;
            let colMol = this.ds.firstColOfType("molecule");
            for (let i = 0; i < ds.numRows; i++) {
                let mol = colMol < 0 ? null : ds.getMolecule(i, colMol);
                if (mol != null) {
                    let wtr = new MDLMOLWriter(mol);
                    wtr.enhancedFields = this.enhancedFields;
                    wtr.chargeSeparate = this.chargeSeparate;
                    wtr.abbrevSgroups = this.abbrevSgroups;
                    let molstr = wtr.write();
                    lines.push(molstr);
                }
                for (let j = 0; j < ds.numCols; j++)
                    if (j != colMol && ds.notNull(i, j)) {
                        let ct = ds.colType(j);
                        let val = '';
                        if (ct == "string")
                            val = ds.getString(i, j);
                        else if (ct == "integer")
                            val = ds.getInteger(i, j).toString();
                        else if (ct == "real")
                            val = ds.getReal(i, j).toString();
                        else if (ct == "boolean")
                            val = ds.getBoolean(i, j) ? 'true' : 'false';
                        if (val != '') {
                            lines.push('> <' + ds.colName(j) + '>');
                            lines.push(val);
                            lines.push('');
                        }
                    }
                lines.push('$$$$');
            }
            return lines.join('\n');
        }
        getResult() {
            return this.lines.join('\n');
        }
    }
    WebMolKit.MDLSDFWriter = MDLSDFWriter;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class MetaMolecule {
        constructor(mol) {
            this.mol = mol;
            this.atomArom = null;
            this.bondArom = null;
            this.rubricTetra = null;
            this.rubricSquare = null;
            this.rubricBipy = null;
            this.rubricOcta = null;
            this.rubricSides = null;
            this.hash = null;
            this.heavyHash = null;
            this.uniqueElements = null;
            this.dots = null;
            this.piAtom = null;
        }
        calculateStrictAromaticity() {
            let mol = this.mol;
            this.atomArom = WebMolKit.Vec.booleanArray(false, mol.numAtoms);
            this.bondArom = WebMolKit.Vec.booleanArray(false, mol.numBonds);
            let rings = mol.findRingsOfSize(6);
            const nr = rings.length;
            if (nr == 0)
                return;
            this.ensurePiAtoms();
            let mask = WebMolKit.Vec.booleanArray(false, nr);
            for (let n = 0; n < nr; n++) {
                for (let i = 0; i < rings[n].length; i++) {
                    let a = rings[n][i];
                    if (!this.piAtom[a - 1]) {
                        mask[n] = true;
                        break;
                    }
                    let b = mol.findBond(a, rings[n][i == rings[n].length - 1 ? 0 : i + 1]);
                    let bo = mol.bondOrder(b);
                    if (bo != 1 && bo != 2) {
                        mask[n] = true;
                        break;
                    }
                }
            }
            while (true) {
                let anyChange = false;
                for (let n = 0; n < nr; n++)
                    if (!mask[n]) {
                        let phase1 = true, phase2 = true;
                        for (let i = 0; i < rings[n].length; i++) {
                            let b = mol.findBond(rings[n][i], rings[n][i == rings[n].length - 1 ? 0 : i + 1]);
                            if (this.bondArom[b - 1])
                                continue;
                            let bo = mol.bondOrder(b);
                            phase1 = phase1 && bo == (2 - (i & 1));
                            phase2 = phase2 && bo == (1 + (i & 1));
                        }
                        if (!phase1 && !phase2)
                            continue;
                        for (let i = 0; i < rings[n].length; i++) {
                            let b = mol.findBond(rings[n][i], rings[n][i == rings[n].length - 1 ? 0 : i + 1]);
                            this.bondArom[b - 1] = true;
                        }
                        mask[n] = true;
                        anyChange = true;
                    }
                if (!anyChange)
                    break;
            }
            for (let n = 0; n < this.bondArom.length; n++)
                if (this.bondArom[n]) {
                    this.atomArom[mol.bondFrom(n + 1) - 1] = true;
                    this.atomArom[mol.bondTo(n + 1) - 1] = true;
                }
        }
        calculateRelaxedAromaticity() {
            let mol = this.mol;
            this.atomArom = WebMolKit.Vec.booleanArray(false, mol.numAtoms);
            this.bondArom = WebMolKit.Vec.booleanArray(false, mol.numBonds);
            this.ensurePiAtoms();
            const na = mol.numAtoms, nb = mol.numBonds;
            let electrons = WebMolKit.Vec.numberArray(0, na);
            let exocyclic = WebMolKit.Vec.booleanArray(false, na);
            for (let n = 1; n <= na; n++) {
                let atno = mol.atomicNumber(n);
                electrons[n - 1] = (WebMolKit.Chemistry.ELEMENT_BLOCKS[atno] == 2 ? WebMolKit.Chemistry.ELEMENT_VALENCE[atno] : 0) - mol.atomCharge(n) - mol.atomHydrogens(n)
                    - mol.atomUnpaired(n);
            }
            for (let n = 1; n <= nb; n++) {
                const bfr = mol.bondFrom(n), bto = mol.bondTo(n), bo = mol.bondOrder(n);
                electrons[bfr - 1] -= bo;
                electrons[bto - 1] -= bo;
                if (bo == 2) {
                    const rblk1 = mol.atomRingBlock(bfr), rblk2 = mol.atomRingBlock(bto);
                    if (rblk1 > 0 && rblk1 != rblk2)
                        exocyclic[bfr - 1] = true;
                    if (rblk2 > 0 && rblk2 != rblk1)
                        exocyclic[bto - 1] = true;
                }
            }
            let rings = [];
            for (let rsz = 3; rsz <= 7; rsz++)
                for (let rng of mol.findRingsOfSize(rsz)) {
                    let valid = true;
                    for (let n = 0; n < rsz; n++) {
                        const a = rng[n];
                        if (!this.piAtom[a - 1] && electrons[a - 1] < 2 && !exocyclic[a - 1]) {
                            valid = false;
                            break;
                        }
                        let b = mol.findBond(a, rng[n < rsz - 1 ? n + 1 : 0]);
                        let bo = mol.bondOrder(b);
                        if (bo != 1 && bo != 2) {
                            valid = false;
                            break;
                        }
                    }
                    if (valid)
                        rings.push(rng);
                }
            while (rings.length > 0) {
                let anyChange = false;
                for (let n = 0; n < rings.length; n++) {
                    let r = rings[n];
                    let paths = [0];
                    for (let i = 0; i < r.length; i++) {
                        const a = r[i];
                        const b1 = mol.findBond(a, r[i < r.length - 1 ? i + 1 : 0]);
                        const b2 = mol.findBond(a, r[i > 0 ? i - 1 : r.length - 1]);
                        if (this.bondArom[b1 - 1]) {
                            for (let j = paths.length - 1; j >= 0; j--) {
                                const e = paths[j] + 2;
                                if (paths.indexOf(e) < 0)
                                    paths = WebMolKit.Vec.append(paths, e);
                            }
                        }
                        else if (mol.bondOrder(b1) == 2)
                            WebMolKit.Vec.addTo(paths, 2);
                        else if (electrons[a - 1] >= 2 && mol.bondOrder(b1) == 1 && mol.bondOrder(b2) == 1)
                            WebMolKit.Vec.addTo(paths, 2);
                    }
                    let arom = false;
                    for (let e of paths) {
                        if (e == 2 && r.length == 3) {
                            arom = true;
                            break;
                        }
                        if (e == 6) {
                            arom = true;
                            break;
                        }
                    }
                    if (arom) {
                        for (let i = 0; i < r.length; i++) {
                            let a = r[i], b = mol.findBond(a, r[i < r.length - 1 ? i + 1 : 0]);
                            this.atomArom[a - 1] = true;
                            this.bondArom[b - 1] = true;
                        }
                        rings.splice(n, 1);
                        n--;
                        anyChange = true;
                    }
                }
                if (!anyChange)
                    break;
            }
        }
        calculateStereoRubric() {
            const mol = this.mol, na = mol.numAtoms, nb = mol.numBonds;
            this.rubricTetra = new Array(na);
            this.rubricSquare = new Array(na);
            this.rubricBipy = new Array(na);
            this.rubricOcta = new Array(na);
            this.rubricSides = new Array(nb);
            for (let n = 1; n <= na; n++) {
                let blk = WebMolKit.Chemistry.ELEMENT_BLOCKS[mol.atomicNumber(n)];
                let adjc = mol.atomAdjCount(n), hc = mol.atomHydrogens(n);
                let ninc = 0, ndec = 0;
                for (let b of mol.atomAdjBonds(n)) {
                    if (mol.bondType(b) == WebMolKit.Molecule.BONDTYPE_INCLINED && mol.bondFrom(b) == n)
                        ninc++;
                    else if (mol.bondType(b) == WebMolKit.Molecule.BONDTYPE_DECLINED && mol.bondFrom(b) == n)
                        ndec++;
                }
                if (blk == 2 && ((adjc == 3 && hc == 1) || (adjc == 4 && hc == 0))) {
                    this.rubricTetra[n - 1] = WebMolKit.Stereochemistry.rubricTetrahedral(mol, n);
                }
                else if (blk >= 3 && adjc == 4 && ninc == 1 && ndec == 1) {
                    this.rubricTetra[n - 1] = WebMolKit.Stereochemistry.rubricTetrahedral(mol, n);
                }
                if (blk >= 3 && adjc == 4 && hc == 0) {
                    this.rubricSquare[n - 1] = WebMolKit.Stereochemistry.rubricSquarePlanar(mol, n);
                }
                if (blk >= 3 && (adjc == 4 || adjc == 5) && hc == 0) {
                    this.rubricBipy[n - 1] = WebMolKit.Stereochemistry.rubricBipyrimidal(mol, n);
                }
                if (blk >= 3 && (adjc == 5 || adjc == 6) && hc == 0) {
                    this.rubricOcta[n - 1] = WebMolKit.Stereochemistry.rubricOctahedral(mol, n);
                }
                else if (blk == 2 && adjc == 6 && hc == 0) {
                    this.rubricOcta[n - 1] = WebMolKit.Stereochemistry.rubricOctahedral(mol, n);
                }
            }
            for (let n = 1; n <= mol.numBonds; n++) {
                if (mol.bondOrder(n) != 2 || mol.bondType(n) == WebMolKit.Molecule.BONDTYPE_UNKNOWN || this.isBondAromatic(n))
                    continue;
                let bfr = mol.bondFrom(n), bto = mol.bondTo(n);
                let blk1 = WebMolKit.Chemistry.ELEMENT_BLOCKS[mol.atomicNumber(bfr)];
                let blk2 = WebMolKit.Chemistry.ELEMENT_BLOCKS[mol.atomicNumber(bto)];
                let adjc1 = mol.atomAdjCount(bfr), hc1 = mol.atomHydrogens(bfr);
                let adjc2 = mol.atomAdjCount(bto), hc2 = mol.atomHydrogens(bto);
                if (blk1 == 2 && blk2 == 2 && (adjc1 + hc1 == 3 && hc1 <= 1) && (adjc2 + hc2 == 3 && hc2 <= 1)) {
                    this.rubricSides[n - 1] = WebMolKit.Stereochemistry.rubricBondSides(mol, n);
                }
            }
        }
        removeHydrogens() {
            let mol = this.mol, na = mol.numAtoms, nb = mol.numBonds;
            let atomMask = WebMolKit.Vec.booleanArray(true, na), bondMask = WebMolKit.Vec.booleanArray(true, nb);
            for (let n = 1; n <= na; n++)
                if (WebMolKit.MolUtil.boringHydrogen(mol, n)) {
                    atomMask[n - 1] = false;
                    bondMask[mol.atomAdjBonds(n)[0] - 1] = false;
                }
            if (WebMolKit.Vec.allTrue(atomMask))
                return;
            mol = WebMolKit.MolUtil.subgraphMask(mol, atomMask);
            if (this.atomArom)
                this.atomArom = WebMolKit.Vec.maskGet(this.atomArom, atomMask);
            if (this.bondArom)
                this.bondArom = WebMolKit.Vec.maskGet(this.bondArom, bondMask);
            if (this.rubricTetra || this.rubricSquare || this.rubricOcta || this.rubricSides) {
                if (this.rubricTetra)
                    this.rubricTetra = WebMolKit.Vec.maskGet(this.rubricTetra, atomMask);
                if (this.rubricSquare)
                    this.rubricSquare = WebMolKit.Vec.maskGet(this.rubricSquare, atomMask);
                if (this.rubricOcta)
                    this.rubricOcta = WebMolKit.Vec.maskGet(this.rubricOcta, atomMask);
                if (this.rubricSides)
                    this.rubricSides = WebMolKit.Vec.maskGet(this.rubricSides, bondMask);
                let atomMap = WebMolKit.Vec.prepend(WebMolKit.Vec.add(WebMolKit.Vec.maskMap(atomMask), 1), 0);
                for (let n = 0; n < WebMolKit.Vec.len(this.rubricTetra); n++)
                    if (this.rubricTetra[n])
                        this.rubricTetra[n] = WebMolKit.Vec.idxGet(atomMap, this.rubricTetra[n]);
                for (let n = 0; n < WebMolKit.Vec.len(this.rubricSquare); n++)
                    if (this.rubricSquare[n])
                        this.rubricSquare[n] = WebMolKit.Vec.idxGet(atomMap, this.rubricSquare[n]);
                for (let n = 0; n < WebMolKit.Vec.len(this.rubricOcta); n++)
                    if (this.rubricOcta[n])
                        this.rubricOcta[n] = WebMolKit.Vec.idxGet(atomMap, this.rubricOcta[n]);
                for (let n = 0; n < WebMolKit.Vec.len(this.rubricSides); n++)
                    if (this.rubricSides[n])
                        this.rubricSides[n] = WebMolKit.Vec.idxGet(atomMap, this.rubricSides[n]);
            }
        }
        calculateSkeletonHash() {
            if (MetaMolecule.skeletonHash == null)
                throw 'Skeleton hash not available.';
            this.hash = MetaMolecule.skeletonHash(this.mol);
        }
        calculateHeavyHash() {
            let anyH = false;
            for (let n = 1; n <= this.mol.numAtoms; n++)
                if (this.mol.atomElement(n) == 'H') {
                    anyH = true;
                    break;
                }
            if (!anyH) {
                this.heavyHash = this.getSkeletonHash();
                return;
            }
            let hvy = this.mol.clone();
            for (let n = hvy.numAtoms; n >= 1; n--)
                if (hvy.atomElement(n) == 'H')
                    hvy.deleteAtomAndBonds(n);
            this.heavyHash = MetaMolecule.skeletonHash(hvy);
        }
        isAtomAromatic(atom) {
            return this.atomArom == null ? false : this.atomArom[atom - 1];
        }
        isBondAromatic(bond) {
            return this.bondArom == null ? false : this.bondArom[bond - 1];
        }
        bondOrderArom(bond) {
            return this.bondArom != null && this.bondArom[bond - 1] ? -1 : this.mol.bondOrder(bond);
        }
        getAtomAromaticity() {
            return this.atomArom == null ? null : this.atomArom.slice(0);
        }
        getBondAromaticity() {
            return this.bondArom == null ? null : this.bondArom.slice(0);
        }
        getSkeletonHash() {
            if (this.hash == null)
                this.calculateSkeletonHash();
            return this.hash;
        }
        getHeavyHash() {
            if (this.heavyHash == null)
                this.calculateHeavyHash();
            return this.heavyHash;
        }
        getDotPath() {
            if (this.dots == null)
                this.dots = new WebMolKit.DotPath(this.mol);
            return this.dots;
        }
        getUniqueElements() {
            if (this.uniqueElements == null) {
                this.uniqueElements = [];
                for (let n = 1; n <= this.mol.numAtoms; n++) {
                    let el = this.mol.atomElement(n);
                    if (this.uniqueElements.indexOf(el) < 0)
                        this.uniqueElements.push(el);
                }
            }
            return this.uniqueElements;
        }
        equivalentTo(other, timeout = 1000) {
            if (MetaMolecule.isomorphMatch == null)
                throw 'Isomorph search unavailable.';
            if (this.mol.numAtoms != other.mol.numAtoms || this.mol.numBonds != other.mol.numBonds)
                return false;
            if (this.hash == null)
                this.calculateSkeletonHash();
            if (other.hash == null)
                other.calculateSkeletonHash();
            if (this.hash != other.hash)
                return false;
            if (this.mol.compareTo(other.mol) == 0)
                return true;
            let uniq1 = this.getUniqueElements(), uniq2 = other.getUniqueElements();
            for (let n = 0; n < uniq1.length; n++) {
                if (!uniq2.includes(uniq1[n]))
                    return false;
            }
            return MetaMolecule.isomorphMatch(this, other, timeout);
        }
        static createRubric(mol) {
            if (mol == null)
                return null;
            let meta = new MetaMolecule(mol);
            meta.calculateStereoRubric();
            return meta;
        }
        static createStrict(mol) {
            if (mol == null)
                return null;
            let meta = new MetaMolecule(mol);
            meta.calculateStrictAromaticity();
            return meta;
        }
        static createStrictRubric(mol) {
            if (mol == null)
                return null;
            let meta = new MetaMolecule(mol);
            meta.calculateStrictAromaticity();
            meta.calculateStereoRubric();
            return meta;
        }
        static createRelaxed(mol) {
            if (mol == null)
                return null;
            let meta = new MetaMolecule(mol);
            meta.calculateRelaxedAromaticity();
            return meta;
        }
        static createRelaxedRubric(mol) {
            if (mol == null)
                return null;
            let meta = new MetaMolecule(mol);
            meta.calculateRelaxedAromaticity();
            meta.calculateStereoRubric();
            return meta;
        }
        ensurePiAtoms() {
            if (this.piAtom != null)
                return;
            this.piAtom = WebMolKit.Vec.booleanArray(false, this.mol.numAtoms);
            for (let n = 1; n <= this.mol.numBonds; n++)
                if (this.mol.bondOrder(n) == 2) {
                    {
                        this.piAtom[this.mol.bondFrom(n) - 1] = true;
                        this.piAtom[this.mol.bondTo(n) - 1] = true;
                    }
                }
        }
    }
    MetaMolecule.skeletonHash = null;
    MetaMolecule.isomorphMatch = null;
    WebMolKit.MetaMolecule = MetaMolecule;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class MolUtil {
        static isBlank(mol) {
            if (mol == null)
                return true;
            return mol.numAtoms == 0;
        }
        static notBlank(mol) {
            if (mol == null)
                return false;
            return mol.numAtoms > 0;
        }
        static orBlank(mol) { return mol == null ? new WebMolKit.Molecule() : mol; }
        static hasAnyAbbrev(mol) {
            for (let n = 1; n <= mol.numAtoms; n++)
                if (MolUtil.hasAbbrev(mol, n))
                    return true;
            return false;
        }
        static hasAbbrev(mol, atom) {
            let extra = mol.atomExtra(atom);
            for (let n = 0; n < (extra == null ? 0 : extra.length); n++)
                if (extra[n].startsWith('a'))
                    return true;
            return false;
        }
        static getAbbrev(mol, atom) {
            let extra = mol.atomExtra(atom);
            for (let n = 0; n < (extra != null ? extra.length : 0); n++)
                if (extra[n].startsWith('a')) {
                    return WebMolKit.Molecule.fromString(extra[n].substring(1));
                }
            return null;
        }
        static setAbbrev(mol, atom, frag) {
            let attidx = 0;
            for (let n = 1; n <= frag.numAtoms; n++)
                if (frag.atomElement(n) == MolUtil.ABBREV_ATTACHMENT) {
                    if (attidx > 0)
                        throw 'Multiple attachment points indicated: invalid.';
                    attidx = n;
                }
            if (attidx == 0)
                throw 'No attachment points indicated.';
            if (attidx >= 2) {
                frag = frag.clone();
                frag.swapAtoms(attidx, 1);
            }
            let adj = mol.atomAdjList(atom);
            if (adj.length > 1)
                throw 'Setting abbreviation for non-terminal atom.';
            if (frag.atomAdjCount(1) == 1 && mol.atomAdjCount(atom) > 0) {
                let b1 = mol.findBond(atom, mol.atomAdjList(atom)[0]);
                let b2 = frag.findBond(1, frag.atomAdjList(1)[0]);
                mol.setBondOrder(b1, frag.bondOrder(b2));
            }
            let extra = mol.atomExtra(atom);
            let idx = -1;
            for (let n = 0; n < (extra != null ? extra.length : 0); n++)
                if (extra[n].startsWith('a')) {
                    idx = n;
                    break;
                }
            if (idx < 0)
                idx = extra.push(null) - 1;
            extra[idx] = 'a' + frag.toString();
            mol.setAtomExtra(atom, extra);
        }
        static validateAbbrevs(mol) {
            for (let n = 1; n <= mol.numAtoms; n++)
                if (MolUtil.hasAbbrev(mol, n)) {
                    if (mol.atomAdjCount(n) > 1)
                        MolUtil.clearAbbrev(mol, n);
                    if (mol.atomCharge(n) != 0)
                        mol.setAtomCharge(n, 0);
                    if (mol.atomUnpaired(n) != 0)
                        mol.setAtomUnpaired(n, 0);
                    if (mol.atomIsotope(n) != 0)
                        mol.setAtomIsotope(n, WebMolKit.Molecule.ISOTOPE_NATURAL);
                    if (mol.atomHExplicit(n) != WebMolKit.Molecule.HEXPLICIT_UNKNOWN)
                        mol.setAtomHExplicit(n, WebMolKit.Molecule.HEXPLICIT_UNKNOWN);
                }
        }
        static convertToAbbrev(mol, srcmask, abbrevName) {
            let molidx = this.convertToAbbrevIndex(mol, srcmask, abbrevName);
            return molidx ? molidx[0] : null;
        }
        static convertToAbbrevIndex(mol, srcmask, abbrevName) {
            let junction = 0;
            let polymerExtra = null;
            for (let n = 1; n <= mol.numBonds; n++) {
                let b1 = mol.bondFrom(n), b2 = mol.bondTo(n), atom = 0;
                if (srcmask[b1 - 1] && !srcmask[b2 - 1]) {
                    atom = b1;
                    polymerExtra = WebMolKit.PolymerBlock.getPolymerExtensions(mol, b2);
                }
                else if (!srcmask[b1 - 1] && srcmask[b2 - 1]) {
                    atom = b2;
                    polymerExtra = WebMolKit.PolymerBlock.getPolymerExtensions(mol, b1);
                }
                if (atom == 0)
                    continue;
                if (junction > 0 && atom != junction)
                    return null;
                junction = atom;
            }
            if (junction == 0)
                return null;
            let na = mol.numAtoms, molidx = 0, fragidx = 0;
            let maskmol = WebMolKit.Vec.booleanArray(false, na), maskfrag = WebMolKit.Vec.booleanArray(false, na);
            for (let n = 0; n < na; n++) {
                maskmol[n] = srcmask[n];
                maskfrag[n] = !srcmask[n] || n + 1 == junction;
                if (maskmol[n] && n + 1 <= junction)
                    molidx++;
                if (maskfrag[n] && n + 1 <= junction)
                    fragidx++;
            }
            let bondType = WebMolKit.Molecule.BONDTYPE_NORMAL, nadj = 0;
            for (let a of mol.atomAdjList(junction))
                if (!srcmask[a - 1]) {
                    if (nadj != 0) {
                        bondType = WebMolKit.Molecule.BONDTYPE_NORMAL;
                        break;
                    }
                    let b = mol.findBond(junction, a);
                    if (mol.bondFrom(b) == junction)
                        bondType = mol.bondType(b);
                    nadj++;
                }
            let frag = MolUtil.subgraphMask(mol, maskfrag);
            frag.setAtomElement(fragidx, MolUtil.ABBREV_ATTACHMENT);
            frag.setAtomCharge(fragidx, 0);
            frag.setAtomUnpaired(fragidx, 0);
            frag.setAtomHExplicit(fragidx, WebMolKit.Molecule.HEXPLICIT_UNKNOWN);
            frag.setAtomMapNum(fragidx, 0);
            frag.setAtomExtra(fragidx, []);
            frag.setAtomTransient(fragidx, []);
            let adj = frag.atomAdjList(fragidx);
            let x = 0, y = 0, inv = 1.0 / adj.length;
            let bondOrder = 1;
            for (let n = 0; n < adj.length; n++) {
                x += frag.atomX(adj[n]);
                y += frag.atomY(adj[n]);
                let b = frag.findBond(fragidx, adj[n]);
                if (n == 0)
                    bondOrder = frag.bondOrder(b);
                else if (bondOrder != frag.bondOrder(b))
                    bondOrder = 1;
            }
            x *= inv;
            y *= inv;
            let newmol = MolUtil.subgraphMask(mol, maskmol);
            let newatom = newmol.addAtom(abbrevName, x, y);
            newmol.addBond(molidx, newatom, bondOrder, bondType);
            MolUtil.setAbbrev(newmol, newatom, frag);
            if (polymerExtra != null)
                newmol.setAtomExtra(newatom, WebMolKit.Vec.concat(newmol.atomExtra(newatom), polymerExtra));
            return [newmol, newatom];
        }
        static expandAbbrevs(mol, alignCoords) {
            while (true) {
                let anything = false;
                for (let n = 1; n <= mol.numAtoms; n++)
                    if (MolUtil.hasAbbrev(mol, n)) {
                        if (MolUtil.expandOneAbbrev(mol, n, alignCoords))
                            anything = true;
                        n--;
                    }
                if (!anything)
                    break;
            }
        }
        static expandOneAbbrev(mol, atom, alignCoords) {
            let frag = MolUtil.getAbbrev(mol, atom);
            if (frag == null)
                return null;
            if (mol.atomAdjCount(atom) != 1 || frag.numAtoms == 0) {
                MolUtil.clearAbbrev(mol, atom);
                return null;
            }
            let m = mol.atomMapNum(atom);
            if (m > 0)
                for (let n of frag.atomAdjList(1))
                    frag.setAtomMapNum(n, m);
            return MolUtil.expandOneAbbrevFrag(mol, atom, frag, alignCoords);
        }
        static expandOneAbbrevFrag(mol, atom, frag, alignCoords) {
            let polymerExtra = WebMolKit.PolymerBlock.getPolymerExtensions(mol, atom);
            let nbr = mol.atomAdjCount(atom) == 1 ? mol.atomAdjList(atom)[0] : 0;
            let connBond = mol.findBond(atom, nbr), connType = WebMolKit.Molecule.BONDTYPE_NORMAL;
            if (connBond > 0) {
                connType = mol.bondType(connBond);
                if (mol.bondFrom(connBond) != nbr && (connType == WebMolKit.Molecule.BONDTYPE_INCLINED || connType == WebMolKit.Molecule.BONDTYPE_DECLINED))
                    connType = WebMolKit.Molecule.BONDTYPE_NORMAL;
            }
            if (alignCoords) {
                let vx1 = mol.atomX(atom) - mol.atomX(nbr), vy1 = mol.atomY(atom) - mol.atomY(nbr);
                let adj = frag.atomAdjList(1);
                let vx2 = 0, vy2 = 0, inv = 1.0 / adj.length;
                for (let n = 0; n < adj.length; n++) {
                    vx2 += frag.atomX(adj[n]) - frag.atomX(1);
                    vy2 += frag.atomY(adj[n]) - frag.atomY(1);
                }
                vx2 *= inv;
                vy2 *= inv;
                let th1 = Math.atan2(vy1, vx1), th2 = Math.atan2(vy2, vx2);
                WebMolKit.CoordUtil.rotateMolecule(frag, th1 - th2);
                WebMolKit.CoordUtil.translateMolecule(frag, mol.atomX(nbr) - frag.atomX(1), mol.atomY(nbr) - frag.atomY(1));
            }
            if (polymerExtra != null) {
                for (let n = 1; n <= frag.numAtoms; n++) {
                    let extra = frag.atomExtra(n);
                    for (let i = extra.length - 1; i >= 0; i--)
                        if (polymerExtra.indexOf(extra[i]) >= 0)
                            extra.splice(i, 1);
                    frag.setAtomExtra(n, WebMolKit.Vec.concat(extra, polymerExtra));
                }
            }
            let join = mol.numAtoms + 1;
            mol.append(frag);
            for (let n = 1; n <= mol.numBonds; n++) {
                if (mol.bondFrom(n) == join) {
                    mol.setBondFrom(n, nbr);
                    mol.setBondType(n, connType);
                }
                else if (mol.bondTo(n) == join) {
                    mol.setBondFromTo(n, nbr, mol.bondFrom(n));
                    mol.setBondType(n, connType);
                }
            }
            let mask = WebMolKit.Vec.booleanArray(false, mol.numAtoms);
            for (let n = mask.length - frag.numAtoms; n < mask.length; n++)
                mask[n] = true;
            mol.deleteAtomAndBonds(join);
            mol.deleteAtomAndBonds(atom);
            mask.splice(join - 1, 1);
            mask.splice(atom - 1, 1);
            return mask;
        }
        static clearAbbrev(mol, atom) {
            let extra = mol.atomExtra(atom);
            for (let n = 0; n < (extra != null ? extra.length : 0); n++)
                if (extra[n].startsWith('a')) {
                    extra.splice(n, 1);
                    mol.setAtomExtra(atom, extra);
                    mol.setAtomElement(atom, 'C');
                    return;
                }
        }
        static setAtomElement(mol, atom, el) {
            if (mol.atomElement(atom) == el)
                return;
            this.clearAbbrev(mol, atom);
            mol.setAtomElement(atom, el);
        }
        static addBond(mol, bfr, bto, order, type) {
            if (type == null)
                type = WebMolKit.Molecule.BONDTYPE_NORMAL;
            if (mol.atomAdjCount(bfr) >= 1)
                this.clearAbbrev(mol, bfr);
            if (mol.atomAdjCount(bto) >= 1)
                this.clearAbbrev(mol, bto);
            let b = mol.findBond(bfr, bto);
            if (b > 0)
                mol.deleteBond(b);
            return mol.addBond(bfr, bto, order, type);
        }
        static subgraphMask(mol, mask) {
            let invidx = [];
            let sum = 0;
            for (let n = 0; n < mol.numAtoms; n++) {
                if (mask[n])
                    invidx.push(++sum);
                else
                    invidx.push(0);
            }
            if (sum == 0)
                return new WebMolKit.Molecule();
            if (sum == mol.numAtoms)
                return mol.clone();
            let frag = new WebMolKit.Molecule();
            for (let n = 1; n <= mol.numAtoms; n++)
                if (mask[n - 1]) {
                    let num = frag.addAtom(mol.atomElement(n), mol.atomX(n), mol.atomY(n), mol.atomCharge(n), mol.atomUnpaired(n));
                    frag.setAtomIsotope(num, mol.atomIsotope(n));
                    frag.setAtomHExplicit(num, mol.atomHExplicit(n));
                    frag.setAtomMapNum(num, mol.atomMapNum(n));
                    frag.setAtomExtra(num, mol.atomExtra(n));
                }
            for (let n = 1; n <= mol.numBonds; n++) {
                let bfr = invidx[mol.bondFrom(n) - 1], bto = invidx[mol.bondTo(n) - 1];
                if (bfr > 0 && bto > 0) {
                    let num = frag.addBond(bfr, bto, mol.bondOrder(n), mol.bondType(n));
                    frag.setBondExtra(num, mol.bondExtra(n));
                }
            }
            return frag;
        }
        static subgraphIndex(mol, idx) {
            let invidx = WebMolKit.Vec.numberArray(0, mol.numAtoms);
            for (let n = 0; n < invidx.length; n++)
                invidx[n] = 0;
            for (let n = 0; n < idx.length; n++)
                invidx[idx[n] - 1] = n + 1;
            let frag = new WebMolKit.Molecule();
            frag.keepTransient = mol.keepTransient;
            for (let n = 0; n < idx.length; n++) {
                let num = frag.addAtom(mol.atomElement(idx[n]), mol.atomX(idx[n]), mol.atomY(idx[n]), mol.atomCharge(idx[n]), mol.atomUnpaired(idx[n]));
                frag.setAtomIsotope(num, mol.atomIsotope(idx[n]));
                frag.setAtomHExplicit(num, mol.atomHExplicit(idx[n]));
                frag.setAtomMapNum(num, mol.atomMapNum(idx[n]));
                frag.setAtomExtra(num, mol.atomExtra(idx[n]));
                if (mol.keepTransient)
                    frag.setAtomTransient(num, mol.atomTransient(idx[n]));
            }
            for (let n = 1; n <= mol.numBonds; n++) {
                let bfr = invidx[mol.bondFrom(n) - 1], bto = invidx[mol.bondTo(n) - 1];
                if (bfr > 0 && bto > 0) {
                    let num = frag.addBond(bfr, bto, mol.bondOrder(n), mol.bondType(n));
                    frag.setBondExtra(num, mol.bondExtra(n));
                    if (mol.keepTransient)
                        frag.setBondTransient(num, mol.bondTransient(n));
                }
            }
            return frag;
        }
        static subgraphWithAttachments(mol, mask) {
            let xmask = mask.slice(0);
            for (let n = 1; n <= mol.numBonds; n++) {
                let bfr = mol.bondFrom(n) - 1, bto = mol.bondTo(n) - 1;
                if (mask[bfr] && !mask[bto])
                    xmask[bto] = true;
                else if (mask[bto] && !mask[bfr])
                    xmask[bfr] = true;
            }
            let xmol = mol.clone();
            for (let n = 1; n <= xmol.numAtoms; n++)
                if (xmask[n - 1] && !mask[n - 1]) {
                    xmol.setAtomElement(n, 'X');
                    xmol.setAtomCharge(n, 0);
                    xmol.setAtomUnpaired(n, 0);
                    xmol.setAtomHExplicit(n, WebMolKit.Molecule.HEXPLICIT_UNKNOWN);
                    xmol.setAtomExtra(n, []);
                }
            return MolUtil.subgraphMask(xmol, xmask);
        }
        static append(mol, frag) {
            let boxm = mol.boundary(), boxf = frag.boundary();
            let dx = boxm.maxX() + WebMolKit.Molecule.IDEALBOND - boxm.minX();
            let dy = 0.5 * (boxm.minY() + boxm.maxY() - boxf.minY() - boxf.maxY());
            let top = mol.numAtoms;
            mol.append(frag);
            for (let n = top + 1; n <= mol.numAtoms; n++)
                mol.setAtomPos(n, mol.atomX(n) + dx, mol.atomY(n) + dy);
        }
        static deleteAtoms(mol, idx) {
            let mask = WebMolKit.Vec.booleanArray(true, mol.numAtoms);
            for (let n = 0; n < idx.length; n++)
                mask[idx[n] - 1] = false;
            return MolUtil.subgraphMask(mol, mask);
        }
        static componentList(mol) {
            let sz = mol.numAtoms;
            if (sz == 0)
                return null;
            let g = WebMolKit.Graph.fromMolecule(mol);
            let groups = g.calculateComponentGroups();
            for (let grp of groups)
                WebMolKit.Vec.addTo(grp, 1);
            return groups;
        }
        static getAtomSides(mol, atom) {
            let g = WebMolKit.Graph.fromMolecule(mol);
            let cc = g.calculateComponents();
            let mask = [];
            for (let n = 0; n < cc.length; n++)
                mask.push(cc[n] == cc[atom - 1]);
            mask[atom - 1] = false;
            let oldmap = WebMolKit.Vec.maskIdx(mask);
            g.keepNodesMask(mask);
            cc = g.calculateComponents();
            let ccmax = WebMolKit.Vec.max(cc);
            let grps = [];
            for (let n = 0; n < ccmax; n++)
                grps.push([atom]);
            for (let n = 0; n < cc.length; n++)
                grps[cc[n] - 1].push(oldmap[n] + 1);
            return grps;
        }
        static getBondSides(mol, bond) {
            let bf = mol.bondFrom(bond), bt = mol.bondTo(bond);
            let inRing = mol.bondInRing(bond);
            let g = WebMolKit.Graph.fromMolecule(mol);
            let cc = g.calculateComponents();
            let mask = [];
            for (let n = 0; n < cc.length; n++)
                mask.push(cc[n] == cc[bf - 1]);
            if (!inRing)
                g.removeEdge(bf - 1, bt - 1);
            else {
                mask[bf - 1] = false;
                mask[bt - 1] = false;
            }
            let oldmap = WebMolKit.Vec.maskIdx(mask);
            g.keepNodesMask(mask);
            cc = g.calculateComponents();
            let ccmax = WebMolKit.Vec.max(cc);
            let grps = [];
            for (let n = 0; n < ccmax; n++) {
                grps[n] = [];
                if (inRing) {
                    grps[n].push(bf);
                    grps[n].push(bt);
                }
            }
            for (let n = 0; n < cc.length; n++)
                grps[cc[n] - 1].push(oldmap[n] + 1);
            return grps;
        }
        static arrayAtomX(mol) {
            let x = WebMolKit.Vec.numberArray(0, mol.numAtoms);
            for (let n = x.length - 1; n >= 0; n--)
                x[n] = mol.atomX(n + 1);
            return x;
        }
        static arrayAtomY(mol) {
            let y = WebMolKit.Vec.numberArray(0, mol.numAtoms);
            for (let n = y.length - 1; n >= 0; n--)
                y[n] = mol.atomY(n + 1);
            return y;
        }
        static arrayAtomMapNum(mol) {
            let mapnum = WebMolKit.Vec.numberArray(0, mol.numAtoms);
            for (let n = mapnum.length - 1; n >= 0; n--)
                mapnum[n] = mol.atomMapNum(n + 1);
            return mapnum;
        }
        static molecularFormula(mol, punctuation) {
            let puncEnter = '', puncExit = '', puncEnterSuper = '', puncExitSuper = '';
            if (punctuation == true)
                [puncEnter, puncExit] = ['{', '}', '{^', '}'];
            else if (punctuation instanceof Array) {
                puncEnter = punctuation[0];
                puncExit = punctuation[1];
                puncEnterSuper = punctuation[2];
                puncExitSuper = punctuation[3];
            }
            for (let n = 1; n <= mol.numAtoms; n++)
                if (MolUtil.hasAbbrev(mol, n)) {
                    mol = mol.clone();
                    MolUtil.expandAbbrevs(mol, false);
                    break;
                }
            let countC = 0, countH = 0;
            let elements = WebMolKit.Vec.stringArray('', mol.numAtoms);
            for (let n = 1; n <= mol.numAtoms; n++) {
                countH += mol.atomHydrogens(n);
                let el = mol.atomElement(n);
                if (mol.atomIsotope(n) != WebMolKit.Molecule.ISOTOPE_NATURAL)
                    el = puncEnterSuper + mol.atomIsotope(n) + puncExitSuper + el;
                if (el == 'C')
                    countC++;
                else if (el == 'H')
                    countH++;
                else
                    elements[n - 1] = el;
            }
            elements.sort();
            let formula = '';
            if (countC > 0)
                formula += 'C';
            if (countC > 1) {
                if (punctuation)
                    formula += puncEnter;
                formula += countC;
                if (punctuation)
                    formula += puncExit;
            }
            if (countH > 0)
                formula += 'H';
            if (countH > 1) {
                if (punctuation)
                    formula += puncEnter;
                formula += countH;
                if (punctuation)
                    formula += puncExit;
            }
            for (let n = 0; n < elements.length; n++)
                if (elements[n].length > 0) {
                    let count = 1;
                    for (; n + 1 < elements.length && elements[n] == elements[n + 1]; n++)
                        count++;
                    formula += elements[n];
                    if (count > 1) {
                        if (punctuation)
                            formula += puncEnter;
                        formula += count;
                        if (punctuation)
                            formula += puncExit;
                    }
                }
            return formula.toString();
        }
        static molecularWeight(mol) {
            for (let n = 1; n <= mol.numAtoms; n++)
                if (MolUtil.hasAbbrev(mol, n)) {
                    mol = mol.clone();
                    MolUtil.expandAbbrevs(mol, false);
                    break;
                }
            let mw = 0;
            for (let n = 1; n <= mol.numAtoms; n++) {
                mw += mol.atomHydrogens(n) * WebMolKit.Chemistry.NATURAL_ATOMIC_WEIGHTS[1];
                let iso = mol.atomIsotope(n);
                if (iso != WebMolKit.Molecule.ISOTOPE_NATURAL) {
                    mw += iso;
                    continue;
                }
                let an = WebMolKit.Molecule.elementAtomicNumber(mol.atomElement(n));
                if (an > 0 && an < WebMolKit.Chemistry.NATURAL_ATOMIC_WEIGHTS.length)
                    mw += WebMolKit.Chemistry.NATURAL_ATOMIC_WEIGHTS[an];
            }
            return mw;
        }
        static removeDuplicateBonds(mol) {
            let bpri = [];
            for (let n = 1; n <= mol.numBonds; n++) {
                let p = Math.min(mol.bondFrom(n), mol.bondTo(n)) * mol.numAtoms + Math.max(mol.bondFrom(n), mol.bondTo(n));
                bpri.push(p);
            }
            let bidx = WebMolKit.Vec.idxSort(bpri);
            let keepmask = WebMolKit.Vec.booleanArray(false, bidx.length);
            let p = 0;
            while (p < bidx.length) {
                let sz = 1;
                while (p + sz < bidx.length && bpri[bidx[p]] == bpri[bidx[p + sz]])
                    sz++;
                let best = p;
                for (let n = p + 1; n < p + sz; n++) {
                    let b1 = bidx[best] + 1, b2 = bidx[n] + 1;
                    let a1 = mol.bondFrom(b1), a2 = mol.bondTo(b1);
                    let el1 = mol.atomElement(a1), el2 = mol.atomElement(a2);
                    let limit1 = 0, limit2 = 0;
                    if (el1 == 'C' || el1 == 'N')
                        limit1 = 4;
                    else if (el1 == 'O')
                        limit1 = 3;
                    if (el2 == 'C' || el2 == 'N')
                        limit2 = 4;
                    else if (el2 == 'O')
                        limit2 = 3;
                    if (limit1 > 0 || limit2 > 0) {
                        let boB1A1 = 0, boB1A2 = 0, boB2A1 = 0, boB2A2 = 0;
                        for (let i = 1; i <= mol.numBonds; i++) {
                            if (i != b2 && (mol.bondFrom(i) == a1 || mol.bondTo(i) == a1))
                                boB1A1 += mol.bondOrder(i);
                            if (i != b2 && (mol.bondFrom(i) == a2 || mol.bondTo(i) == a2))
                                boB1A2 += mol.bondOrder(i);
                            if (i != b1 && (mol.bondFrom(i) == a1 || mol.bondTo(i) == a1))
                                boB2A1 += mol.bondOrder(i);
                            if (i != b1 && (mol.bondFrom(i) == a2 || mol.bondTo(i) == a2))
                                boB2A2 += mol.bondOrder(i);
                        }
                        let bad1 = 0, bad2 = 0;
                        if (limit1 > 0 && boB1A1 > limit1)
                            bad1++;
                        if (limit2 > 0 && boB1A2 > limit2)
                            bad1++;
                        if (limit1 > 0 && boB2A1 > limit1)
                            bad2++;
                        if (limit2 > 0 && boB2A2 > limit2)
                            bad2++;
                        if (bad1 < bad2)
                            continue;
                        if (bad1 > bad2) {
                            best = n;
                            continue;
                        }
                    }
                    let exotic1 = 2 * mol.bondOrder(b1), exotic2 = 2 * mol.bondOrder(b2);
                    exotic1 += (exotic1 == 0 ? 4 : 0) + (mol.bondType(b1) != WebMolKit.Molecule.BONDTYPE_NORMAL ? 1 : 0);
                    exotic2 += (exotic2 == 0 ? 4 : 0) + (mol.bondType(b2) != WebMolKit.Molecule.BONDTYPE_NORMAL ? 1 : 0);
                    if (exotic2 > exotic1)
                        best = n;
                }
                keepmask[bidx[best]] = true;
                p += sz;
            }
            for (let n = mol.numBonds; n >= 1; n--)
                if (!keepmask[n - 1] || mol.bondFrom(n) == mol.bondTo(n))
                    mol.deleteBond(n);
        }
        static calculateWalkWeight(mol, atom) {
            let ccsz = 0, cc = WebMolKit.Graph.fromMolecule(mol).calculateComponents();
            for (let n = 0; n < cc.length; n++)
                if (cc[n] == cc[atom - 1])
                    ccsz++;
            let w = WebMolKit.Vec.numberArray(1, mol.numAtoms), wn = WebMolKit.Vec.numberArray(0, mol.numAtoms);
            w[atom - 1] = 0;
            for (; ccsz > 0; ccsz--) {
                for (let n = 0; n < mol.numAtoms; n++)
                    wn[n] = w[n];
                for (let n = 1; n <= mol.numBonds; n++) {
                    let a1 = mol.bondFrom(n) - 1, a2 = mol.bondTo(n) - 1;
                    w[a1] += wn[a2] * 0.1;
                    w[a2] += wn[a1] * 0.1;
                }
                w[atom - 1] = 0;
            }
            return w;
        }
        static totalHydrogens(mol, atom) {
            let hc = mol.atomHydrogens(atom);
            let adj = mol.atomAdjList(atom);
            for (let n = 0; n < adj.length; n++)
                if (mol.atomElement(adj[n]) == 'H')
                    hc++;
            return hc;
        }
        static stripHydrogens(mol, force = false) {
            for (let n = mol.numAtoms; n >= 1; n--)
                if ((force && mol.atomElement(n) == 'H') || this.boringHydrogen(mol, n))
                    mol.deleteAtomAndBonds(n);
        }
        static boringHydrogen(mol, atom) {
            if (mol.atomElement(atom) != 'H')
                return false;
            if (mol.atomCharge(atom) != 0 || mol.atomUnpaired(atom) != 0)
                return false;
            if (mol.atomIsotope(atom) != WebMolKit.Molecule.ISOTOPE_NATURAL)
                return false;
            if (WebMolKit.Vec.notBlank(mol.atomExtra(atom)) || WebMolKit.Vec.notBlank(mol.atomTransient(atom)))
                return false;
            if (mol.atomAdjCount(atom) != 1)
                return false;
            let other = mol.atomAdjList(atom)[0];
            if (mol.atomElement(other) == 'H')
                return false;
            let bond = mol.atomAdjBonds(atom)[0];
            if (mol.bondOrder(bond) != 1 || mol.bondType(bond) != WebMolKit.Molecule.BONDTYPE_NORMAL)
                return false;
            if (mol.atomHExplicit(other) != WebMolKit.Molecule.HEXPLICIT_UNKNOWN)
                return false;
            if (WebMolKit.Molecule.HYVALENCE_EL.indexOf(mol.atomElement(other)) < 0)
                return false;
            return true;
        }
        static createHydrogens(mol, position) {
            if (position == null)
                position = false;
            let na = mol.numAtoms;
            for (let n = 1; n <= na; n++) {
                let hc = mol.atomHydrogens(n);
                if (hc == 0)
                    continue;
                if (mol.atomHExplicit(n) != WebMolKit.Molecule.HEXPLICIT_UNKNOWN)
                    mol.setAtomHExplicit(n, 0);
                if (!position) {
                    for (; hc > 0; hc--) {
                        let a = mol.addAtom('H', mol.atomX(n), mol.atomY(n));
                        mol.addBond(n, a, 1);
                    }
                }
                else
                    WebMolKit.SketchUtil.placeAdditionalHydrogens(mol, n, hc);
            }
            return mol.numAtoms - na;
        }
        static atomVec3(mol, atom) {
            if (mol.is3D())
                return [mol.atomX(atom), mol.atomY(atom), mol.atomZ(atom)];
            else
                return [mol.atomX(atom), mol.atomY(atom), 0];
        }
        static atomOxidationState(mol, atom) {
            if (mol.atomAdjCount(atom) == 0)
                return null;
            if (this.hasAbbrev(mol, atom))
                return null;
            let atno = mol.atomicNumber(atom);
            if (atno == 0)
                return null;
            let nonMetal = atno == WebMolKit.Chemistry.ELEMENT_H || WebMolKit.Chemistry.ELEMENT_BLOCKS[atno] == 2;
            let oxstate = mol.atomHydrogens(atom) + (nonMetal ? -mol.atomCharge(atom) : mol.atomCharge(atom));
            for (let b of mol.atomAdjBonds(atom)) {
                let bo = mol.bondOrder(b);
                if (nonMetal)
                    oxstate += bo;
                else
                    oxstate += bo % 2;
            }
            if (atno == WebMolKit.Chemistry.ELEMENT_H && oxstate == 1)
                return null;
            if (atno == WebMolKit.Chemistry.ELEMENT_B && oxstate == 3)
                return null;
            if (atno == WebMolKit.Chemistry.ELEMENT_C && oxstate == 4)
                return null;
            if (atno == WebMolKit.Chemistry.ELEMENT_N && oxstate == 3)
                return null;
            if (atno == WebMolKit.Chemistry.ELEMENT_O && oxstate == 2)
                return null;
            if (atno == WebMolKit.Chemistry.ELEMENT_S && (oxstate == 2 || oxstate == 4 || oxstate == 6))
                return null;
            if (atno == WebMolKit.Chemistry.ELEMENT_P && (oxstate == 3 || oxstate == 5))
                return null;
            if ((atno == WebMolKit.Chemistry.ELEMENT_F || atno == WebMolKit.Chemistry.ELEMENT_Cl ||
                atno == WebMolKit.Chemistry.ELEMENT_Br || atno == WebMolKit.Chemistry.ELEMENT_I) && oxstate == 1)
                return null;
            return oxstate;
        }
        static oxidationStateText(oxstate) {
            if (oxstate == 0)
                return '0';
            let str = oxstate < 0 ? '-' : '';
            let absox = Math.abs(oxstate);
            if (absox == 1)
                str += 'I';
            else if (absox == 2)
                str += 'II';
            else if (absox == 3)
                str += 'III';
            else if (absox == 4)
                str += 'IV';
            else if (absox == 5)
                str += 'V';
            else if (absox == 6)
                str += 'VI';
            else if (absox == 7)
                str += 'VII';
            else if (absox == 8)
                str += 'VIII';
            else if (absox == 9)
                str += 'IX';
            else if (absox == 10)
                str += 'X';
            else if (absox == 11)
                str += 'XI';
            else if (absox == 12)
                str += 'XII';
            else
                str = (oxstate > 0 ? '+' : '') + oxstate;
            return str;
        }
    }
    MolUtil.TEMPLATE_ATTACHMENT = 'X';
    MolUtil.ABBREV_ATTACHMENT = '*';
    WebMolKit.MolUtil = MolUtil;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class Atom {
    }
    class Bond {
    }
    class Molecule {
        constructor() {
            this.atoms = [];
            this.bonds = [];
            this.hasZCoord = false;
            this.keepTransient = false;
            this.hasTransient = false;
            this.graph = null;
            this.graphBond = null;
            this.ringID = null;
            this.compID = null;
            this.ring3 = null;
            this.ring4 = null;
            this.ring5 = null;
            this.ring6 = null;
            this.ring7 = null;
        }
        clone() {
            let dup = new Molecule();
            dup.atoms = WebMolKit.deepClone(this.atoms);
            dup.bonds = WebMolKit.deepClone(this.bonds);
            dup.hasZCoord = this.hasZCoord;
            dup.keepTransient = this.keepTransient;
            dup.hasTransient = this.hasTransient;
            dup.graph = this.graph;
            dup.graphBond = this.graphBond;
            dup.ringID = this.ringID;
            dup.compID = this.compID;
            dup.ring3 = this.ring3;
            dup.ring4 = this.ring4;
            dup.ring5 = this.ring5;
            dup.ring6 = this.ring6;
            dup.ring7 = this.ring7;
            return dup;
        }
        static fromString(strData) { return WebMolKit.MoleculeStream.readNative(strData); }
        toString() { return WebMolKit.MoleculeStream.writeNative(this); }
        append(frag) {
            let base = this.atoms.length;
            for (let n = 1; n <= frag.numAtoms; n++) {
                let num = this.addAtom(frag.atomElement(n), frag.atomX(n), frag.atomY(n), frag.atomCharge(n), frag.atomUnpaired(n));
                this.setAtomIsotope(num, frag.atomIsotope(n));
                this.setAtomHExplicit(num, frag.atomHExplicit(n));
                this.setAtomMapNum(num, frag.atomMapNum(n));
                this.setAtomExtra(num, frag.atomExtra(n));
            }
            for (let n = 1; n <= frag.numBonds; n++) {
                let num = this.addBond(frag.bondFrom(n) + base, frag.bondTo(n) + base, frag.bondOrder(n), frag.bondType(n));
                this.setBondExtra(num, frag.bondExtra(n));
            }
            this.trashTransient();
        }
        get numAtoms() { return this.atoms.length; }
        getAtom(idx) {
            if (idx < 1 || idx > this.atoms.length)
                throw new Error(`Molecule.getAtom: index ${idx} out of range (#atoms=${this.atoms.length})`);
            return this.atoms[idx - 1];
        }
        atomElement(idx) { return this.getAtom(idx).element; }
        atomX(idx) { return this.getAtom(idx).x; }
        atomY(idx) { return this.getAtom(idx).y; }
        atomCharge(idx) { return this.getAtom(idx).charge; }
        atomUnpaired(idx) { return this.getAtom(idx).unpaired; }
        atomIsotope(idx) { return this.getAtom(idx).isotope; }
        atomHExplicit(idx) { return this.getAtom(idx).hExplicit; }
        atomMapNum(idx) { return this.getAtom(idx).mapNum; }
        atomExtra(idx) { return this.getAtom(idx).extra.slice(0); }
        atomTransient(idx) { return this.getAtom(idx).transient.slice(0); }
        get numBonds() { return this.bonds.length; }
        getBond(idx) {
            if (idx < 1 || idx > this.bonds.length)
                throw new Error(`Molecule.getBond: index ${idx} out of range (#bonds=${this.bonds.length})`);
            return this.bonds[idx - 1];
        }
        bondFrom(idx) { return this.getBond(idx).from; }
        bondTo(idx) { return this.getBond(idx).to; }
        bondOrder(idx) { return this.getBond(idx).order; }
        bondType(idx) { return this.getBond(idx).type; }
        bondExtra(idx) { return this.getBond(idx).extra.slice(0); }
        bondTransient(idx) { return this.getBond(idx).transient.slice(0); }
        bondFromTo(idx) { let b = this.getBond(idx); return [b.from, b.to]; }
        addAtom(element, x, y, charge = 0, unpaired = 0) {
            let a = new Atom();
            a.element = element;
            a.x = x;
            a.y = y;
            a.charge = charge;
            a.unpaired = unpaired;
            a.isotope = Molecule.ISOTOPE_NATURAL;
            a.hExplicit = Molecule.HEXPLICIT_UNKNOWN;
            a.mapNum = 0;
            a.extra = [];
            a.transient = [];
            this.atoms.push(a);
            this.trashTransient();
            this.trashGraph();
            return this.atoms.length;
        }
        setAtomElement(idx, element) {
            this.getAtom(idx).element = element;
            this.trashTransient();
        }
        setAtomPos(idx, x, y, z) {
            let a = this.getAtom(idx);
            a.x = x;
            a.y = y;
            a.z = z == null ? 0 : z;
            this.trashTransient();
        }
        setAtomX(idx, x) {
            this.getAtom(idx).x = x;
            this.trashTransient();
        }
        setAtomY(idx, y) {
            this.getAtom(idx).y = y;
            this.trashTransient();
        }
        setAtomCharge(idx, charge) {
            this.getAtom(idx).charge = charge;
            this.trashTransient();
        }
        setAtomUnpaired(idx, unpaired) {
            this.getAtom(idx).unpaired = unpaired;
            this.trashTransient();
        }
        setAtomIsotope(idx, isotope) {
            this.getAtom(idx).isotope = isotope;
            this.trashTransient();
        }
        setAtomHExplicit(idx, hExplicit) {
            this.getAtom(idx).hExplicit = hExplicit;
            this.trashTransient();
        }
        setAtomMapNum(idx, mapNum) {
            this.getAtom(idx).mapNum = mapNum;
            this.trashTransient();
        }
        setAtomExtra(idx, extra) {
            this.getAtom(idx).extra = extra.slice(0);
        }
        setAtomTransient(idx, transi) {
            this.getAtom(idx).transient = transi.slice(0);
            if (transi.length > 0)
                this.hasTransient = true;
        }
        swapAtoms(a1, a2) {
            let a = this.atoms[a1 - 1];
            this.atoms[a1 - 1] = this.atoms[a2 - 1];
            this.atoms[a2 - 1] = a;
            for (let n = 0; n < this.bonds.length; n++) {
                let b = this.bonds[n];
                if (b.from == a2)
                    b.from = a1;
                else if (b.from == a1)
                    b.from = a2;
                if (b.to == a2)
                    b.to = a1;
                else if (b.to == a1)
                    b.to = a2;
            }
            this.trashGraph();
        }
        addBond(from, to, order, type = Molecule.BONDTYPE_NORMAL) {
            let b = new Bond();
            b.from = from;
            b.to = to;
            b.order = order;
            b.type = type;
            b.extra = [];
            b.transient = [];
            this.bonds.push(b);
            this.trashTransient();
            this.trashGraph();
            return this.bonds.length;
        }
        setBondFrom(idx, bfr) {
            this.getBond(idx).from = bfr;
            this.trashTransient();
            this.trashGraph();
        }
        setBondTo(idx, to) {
            this.getBond(idx).to = to;
            this.trashTransient();
            this.trashGraph();
        }
        setBondFromTo(idx, bfr, bto) {
            this.getBond(idx).from = bfr;
            this.getBond(idx).to = bto;
            this.trashTransient();
            this.trashGraph();
        }
        setBondOrder(idx, order) {
            this.getBond(idx).order = order;
            this.trashTransient();
        }
        setBondType(idx, type) {
            this.getBond(idx).type = type;
            this.trashTransient();
        }
        setBondExtra(idx, extra) {
            this.getBond(idx).extra = extra.slice(0);
        }
        setBondTransient(idx, transi) {
            this.getBond(idx).transient = transi.slice(0);
            if (transi.length > 0)
                this.hasTransient = true;
        }
        deleteAtomAndBonds(idx) {
            for (let n = this.numBonds; n >= 1; n--) {
                if (this.bondFrom(n) == idx || this.bondTo(n) == idx)
                    this.deleteBond(n);
                else {
                    if (this.bondFrom(n) > idx)
                        this.setBondFrom(n, this.bondFrom(n) - 1);
                    if (this.bondTo(n) > idx)
                        this.setBondTo(n, this.bondTo(n) - 1);
                }
            }
            this.atoms.splice(idx - 1, 1);
            this.trashTransient();
            this.trashGraph();
        }
        deleteBond(idx) {
            this.bonds.splice(idx - 1, 1);
            this.trashTransient();
            this.trashGraph();
        }
        atomHydrogens(idx) {
            let hy = this.atomHExplicit(idx);
            if (hy != Molecule.HEXPLICIT_UNKNOWN)
                return hy;
            for (let n = 0; n < Molecule.HYVALENCE_EL.length; n++)
                if (Molecule.HYVALENCE_EL[n] == this.atomElement(idx)) {
                    hy = Molecule.HYVALENCE_VAL[n];
                    break;
                }
            if (hy == Molecule.HEXPLICIT_UNKNOWN)
                return 0;
            let ch = this.atomCharge(idx);
            if (this.atomElement(idx) == 'C')
                ch = -Math.abs(ch);
            hy += ch - this.atomUnpaired(idx);
            let adjBonds = this.atomAdjBonds(idx);
            for (let n = 0; n < adjBonds.length; n++)
                hy -= this.bondOrder(adjBonds[n]);
            return hy < 0 ? 0 : hy;
        }
        findBond(a1, a2) {
            for (let n = 1; n <= this.numBonds; n++) {
                let b1 = this.bondFrom(n), b2 = this.bondTo(n);
                if ((a1 == b1 && a2 == b2) || (a1 == b2 && a2 == b1))
                    return n;
            }
            return 0;
        }
        bondOther(idx, ref) {
            let b1 = this.bondFrom(idx), b2 = this.bondTo(idx);
            if (b1 == ref)
                return b2;
            if (b2 == ref)
                return b1;
            return 0;
        }
        atomExplicit(idx) {
            let a = this.atoms[idx - 1];
            if (a.isotope != Molecule.ISOTOPE_NATURAL)
                return true;
            if (a.element != 'C' || a.charge != 0 || a.unpaired != 0)
                return true;
            if (this.atomAdjCount(idx) == 0)
                return true;
            return false;
        }
        atomRingBlock(idx) {
            if (this.graph == null)
                this.buildGraph();
            if (this.ringID == null)
                this.buildRingID();
            return this.ringID[idx - 1];
        }
        bondInRing(idx) {
            let r1 = this.atomRingBlock(this.bondFrom(idx)), r2 = this.atomRingBlock(this.bondTo(idx));
            return r1 > 0 && r1 == r2;
        }
        atomConnComp(idx) {
            if (this.graph == null)
                this.buildGraph();
            if (this.compID == null)
                this.buildConnComp();
            return this.compID[idx - 1];
        }
        atomAdjCount(idx) {
            this.buildGraph();
            return this.graph[idx - 1].length;
        }
        atomAdjList(idx) {
            this.buildGraph();
            let adj = this.graph[idx - 1].slice(0);
            for (let n = adj.length - 1; n >= 0; n--)
                adj[n]++;
            return adj;
        }
        atomAdjBonds(idx) {
            this.buildGraph();
            return this.graphBond[idx - 1].slice(0);
        }
        findRingsOfSize(size) {
            let rings = null;
            if (size == 3 && this.ring3 != null)
                rings = this.ring3;
            if (size == 4 && this.ring4 != null)
                rings = this.ring4;
            if (size == 5 && this.ring5 != null)
                rings = this.ring5;
            if (size == 6 && this.ring6 != null)
                rings = this.ring6;
            if (size == 7 && this.ring7 != null)
                rings = this.ring7;
            if (rings == null) {
                if (this.graph == null)
                    this.buildGraph();
                if (this.ringID == null)
                    this.buildRingID();
                rings = [];
                for (let n = 1; n <= this.atoms.length; n++) {
                    if (this.ringID[n - 1] > 0) {
                        let path = WebMolKit.Vec.numberArray(0, size);
                        path[0] = n;
                        this.recursiveRingFind(path, 1, size, this.ringID[n - 1], rings);
                    }
                }
                if (size == 3)
                    this.ring3 = rings;
                if (size == 4)
                    this.ring4 = rings;
                if (size == 5)
                    this.ring5 = rings;
                if (size == 6)
                    this.ring6 = rings;
                if (size == 7)
                    this.ring7 = rings;
            }
            let ret = [];
            for (let n = 0; n < rings.length; n++)
                ret.push(rings[n].slice(0));
            return ret;
        }
        boundary() {
            if (this.atoms.length == 0)
                return WebMolKit.Box.zero();
            let x1 = this.atoms[0].x, x2 = x1;
            let y1 = this.atoms[0].y, y2 = y1;
            for (let n = 1; n < this.atoms.length; n++) {
                x1 = Math.min(x1, this.atoms[n].x);
                y1 = Math.min(y1, this.atoms[n].y);
                x2 = Math.max(x2, this.atoms[n].x);
                y2 = Math.max(y2, this.atoms[n].y);
            }
            return new WebMolKit.Box(x1, y1, x2 - x1, y2 - y1);
        }
        atomicNumber(idx) {
            return Molecule.elementAtomicNumber(this.atomElement(idx));
        }
        static elementAtomicNumber(element) {
            return Math.max(0, WebMolKit.Chemistry.ELEMENTS.indexOf(element));
        }
        is3D() { return this.hasZCoord; }
        setIs3D(v) { this.hasZCoord = v; }
        atomZ(idx) { return this.getAtom(idx).z; }
        setAtomZ(idx, z) { this.getAtom(idx).z = z; }
        compareTo(other) {
            if (other == null || other.numAtoms == 0)
                return this.numAtoms == 0 ? 0 : 1;
            if (this.numAtoms < other.numAtoms)
                return -1;
            if (this.numAtoms > other.numAtoms)
                return 1;
            if (this.numBonds < other.numBonds)
                return -1;
            if (this.numBonds > other.numBonds)
                return 1;
            for (let n = 1; n <= this.numAtoms; n++) {
                if (this.atomElement(n) < other.atomElement(n))
                    return -1;
                if (this.atomElement(n) > other.atomElement(n))
                    return 1;
                if (this.atomX(n) < other.atomX(n))
                    return -1;
                if (this.atomX(n) > other.atomX(n))
                    return 1;
                if (this.atomY(n) < other.atomY(n))
                    return -1;
                if (this.atomY(n) > other.atomY(n))
                    return 1;
                if (this.atomCharge(n) < other.atomCharge(n))
                    return -1;
                if (this.atomCharge(n) > other.atomCharge(n))
                    return 1;
                if (this.atomUnpaired(n) < other.atomUnpaired(n))
                    return -1;
                if (this.atomUnpaired(n) > other.atomUnpaired(n))
                    return 1;
                if (this.atomHExplicit(n) < other.atomHExplicit(n))
                    return -1;
                if (this.atomHExplicit(n) > other.atomHExplicit(n))
                    return 1;
                if (this.atomIsotope(n) < other.atomIsotope(n))
                    return -1;
                if (this.atomIsotope(n) > other.atomIsotope(n))
                    return 1;
                if (this.atomMapNum(n) < other.atomMapNum(n))
                    return -1;
                if (this.atomMapNum(n) > other.atomMapNum(n))
                    return 1;
                let tx1 = this.atomExtra(n), tx2 = other.atomExtra(n);
                if (tx1.length < tx2.length)
                    return -1;
                if (tx1.length > tx2.length)
                    return 1;
                for (let i = 0; i < tx1.length; i++)
                    if (tx1[i] < tx2[i])
                        return -1;
                    else if (tx1[i] > tx2[i])
                        return 1;
                tx1 = this.atomTransient(n);
                tx2 = other.atomTransient(n);
                if (tx1.length < tx2.length)
                    return -1;
                if (tx1.length > tx2.length)
                    return 1;
                for (let i = 0; i < tx1.length; i++)
                    if (tx1[i] < tx2[i])
                        return -1;
                    else if (tx1[i] > tx2[i])
                        return 1;
            }
            for (let n = 1; n <= this.numBonds; n++) {
                if (this.bondFrom(n) < other.bondFrom(n))
                    return -1;
                if (this.bondFrom(n) > other.bondFrom(n))
                    return 1;
                if (this.bondTo(n) < other.bondTo(n))
                    return -1;
                if (this.bondTo(n) > other.bondTo(n))
                    return 1;
                if (this.bondOrder(n) < other.bondOrder(n))
                    return -1;
                if (this.bondOrder(n) > other.bondOrder(n))
                    return 1;
                if (this.bondType(n) < other.bondType(n))
                    return -1;
                if (this.bondType(n) > other.bondType(n))
                    return 1;
                let tx1 = this.bondExtra(n), tx2 = other.bondExtra(n);
                if (tx1.length < tx2.length)
                    return -1;
                if (tx1.length > tx2.length)
                    return 1;
                for (let i = 0; i < tx1.length; i++)
                    if (tx1[i] < tx2[i])
                        return -1;
                    else if (tx1[i] > tx2[i])
                        return 1;
                tx1 = this.bondTransient(n);
                tx2 = other.bondTransient(n);
                if (tx1.length < tx2.length)
                    return -1;
                if (tx1.length > tx2.length)
                    return 1;
                for (let i = 0; i < tx1.length; i++)
                    if (tx1[i] < tx2[i])
                        return -1;
                    else if (tx1[i] > tx2[i])
                        return 1;
            }
            return 0;
        }
        trashGraph() {
            this.graph = null;
            this.graphBond = null;
            this.ringID = null;
            this.compID = null;
            this.ring3 = null;
            this.ring4 = null;
            this.ring5 = null;
            this.ring6 = null;
            this.ring7 = null;
        }
        trashTransient() {
            if (this.keepTransient || !this.hasTransient)
                return;
            for (let a of this.atoms)
                a.transient = [];
            for (let b of this.bonds)
                b.transient = [];
            this.hasTransient = false;
        }
        buildGraph() {
            if (this.graph != null && this.graphBond != null)
                return;
            let graph = [], graphBond = [];
            let na = this.numAtoms, nb = this.numBonds;
            for (let n = 0; n < na; n++) {
                graph.push([]);
                graphBond.push([]);
            }
            for (let n = 1; n <= nb; n++) {
                let b = this.getBond(n);
                graph[b.from - 1].push(b.to - 1);
                graph[b.to - 1].push(b.from - 1);
                graphBond[b.from - 1].push(n);
                graphBond[b.to - 1].push(n);
            }
            this.graph = graph;
            this.graphBond = graphBond;
        }
        buildConnComp() {
            const numAtoms = this.atoms.length;
            this.compID = WebMolKit.Vec.numberArray(0, numAtoms);
            for (let n = 0; n < numAtoms; n++)
                this.compID[n] = 0;
            let comp = 1;
            this.compID[0] = comp;
            while (true) {
                let anything = false;
                for (let n = 0; n < numAtoms; n++)
                    if (this.compID[n] == comp) {
                        for (let i = 0; i < this.graph[n].length; i++) {
                            if (this.compID[this.graph[n][i]] == 0) {
                                this.compID[this.graph[n][i]] = comp;
                                anything = true;
                            }
                        }
                    }
                if (!anything) {
                    for (let n = 0; n < numAtoms; n++) {
                        if (this.compID[n] == 0) {
                            this.compID[n] = ++comp;
                            anything = true;
                            break;
                        }
                    }
                    if (!anything)
                        break;
                }
            }
        }
        buildRingID() {
            const numAtoms = this.atoms.length;
            this.ringID = WebMolKit.Vec.numberArray(0, numAtoms);
            if (numAtoms == 0)
                return;
            let visited = WebMolKit.Vec.booleanArray(false, numAtoms);
            for (let n = 0; n < numAtoms; n++) {
                this.ringID[n] = 0;
                visited[n] = false;
            }
            let path = WebMolKit.Vec.numberArray(0, numAtoms + 1), plen = 0, numVisited = 0;
            while (true) {
                let last, current;
                if (plen == 0) {
                    last = -1;
                    for (current = 0; visited[current]; current++) { }
                }
                else {
                    last = path[plen - 1];
                    current = -1;
                    for (let n = 0; n < this.graph[last].length; n++) {
                        if (!visited[this.graph[last][n]]) {
                            current = this.graph[last][n];
                            break;
                        }
                    }
                }
                if (current >= 0 && plen >= 2) {
                    let back = path[plen - 1];
                    for (let n = 0; n < this.graph[current].length; n++) {
                        let join = this.graph[current][n];
                        if (join != back && visited[join]) {
                            path[plen] = current;
                            for (let i = plen; i == plen || path[i + 1] != join; i--) {
                                let id = this.ringID[path[i]];
                                if (id == 0)
                                    this.ringID[path[i]] = last;
                                else if (id != last) {
                                    for (let j = 0; j < numAtoms; j++)
                                        if (this.ringID[j] == id)
                                            this.ringID[j] = last;
                                }
                            }
                        }
                    }
                }
                if (current >= 0) {
                    visited[current] = true;
                    path[plen++] = current;
                    numVisited++;
                }
                else {
                    plen--;
                }
                if (numVisited == numAtoms)
                    break;
            }
            let nextID = 0;
            for (let i = 0; i < numAtoms; i++) {
                if (this.ringID[i] > 0) {
                    nextID--;
                    for (let j = numAtoms - 1; j >= i; j--)
                        if (this.ringID[j] == this.ringID[i])
                            this.ringID[j] = nextID;
                }
            }
            for (let i = 0; i < numAtoms; i++)
                this.ringID[i] = -this.ringID[i];
        }
        recursiveRingFind(path, psize, capacity, rblk, rings) {
            const { graph } = this;
            if (psize < capacity) {
                let last = path[psize - 1];
                for (let n = 0; n < graph[last - 1].length; n++) {
                    let adj = graph[last - 1][n] + 1;
                    if (this.ringID[adj - 1] != rblk)
                        continue;
                    let fnd = false;
                    for (let i = 0; i < psize; i++) {
                        if (path[i] == adj) {
                            fnd = true;
                            break;
                        }
                    }
                    if (!fnd) {
                        let newPath = path.slice(0);
                        newPath[psize] = adj;
                        this.recursiveRingFind(newPath, psize + 1, capacity, rblk, rings);
                    }
                }
                return;
            }
            let last = path[psize - 1];
            let fnd = false;
            for (let n = 0; n < graph[last - 1].length; n++) {
                if (graph[last - 1][n] + 1 == path[0]) {
                    fnd = true;
                    break;
                }
            }
            if (!fnd)
                return;
            for (let n = 0; n < path.length; n++) {
                let count = 0, p = path[n] - 1;
                for (let i = 0; i < graph[p].length; i++)
                    if (path.indexOf(graph[p][i] + 1) >= 0)
                        count++;
                if (count != 2)
                    return;
            }
            let first = 0;
            for (let n = 1; n < psize; n++)
                if (path[n] < path[first])
                    first = n;
            let fm = (first - 1 + psize) % psize, fp = (first + 1) % psize;
            let flip = path[fm] < path[fp];
            if (first != 0 || flip) {
                let newPath = WebMolKit.Vec.numberArray(0, psize);
                for (let n = 0; n < psize; n++)
                    newPath[n] = path[(first + (flip ? psize - n : n)) % psize];
                path = newPath;
            }
            for (let n = 0; n < rings.length; n++) {
                let look = rings[n];
                let same = true;
                for (let i = 0; i < psize; i++) {
                    if (look[i] != path[i]) {
                        same = false;
                        break;
                    }
                }
                if (same)
                    return;
            }
            rings.push(path);
        }
    }
    Molecule.IDEALBOND = 1.5;
    Molecule.HEXPLICIT_UNKNOWN = -1;
    Molecule.ISOTOPE_NATURAL = 0;
    Molecule.BONDTYPE_NORMAL = 0;
    Molecule.BONDTYPE_INCLINED = 1;
    Molecule.BONDTYPE_DECLINED = 2;
    Molecule.BONDTYPE_UNKNOWN = 3;
    Molecule.HYVALENCE_EL = ['C', 'N', 'O', 'S', 'P'];
    Molecule.HYVALENCE_VAL = [4, 3, 2, 2, 3];
    Molecule.PREFIX_EXTRA = 'x';
    Molecule.PREFIX_TRANSIENT = 'y';
    WebMolKit.Molecule = Molecule;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class MoleculeStream {
        static readUnknown(strData) {
            if (strData.startsWith('"')) {
                try {
                    let jsonStr = JSON.parse(strData);
                    let mol = MoleculeStream.readNative(jsonStr);
                    if (mol)
                        return mol;
                }
                catch (ex) { }
            }
            let mol = MoleculeStream.readNative(strData);
            if (mol)
                return mol;
            try {
                mol = MoleculeStream.readMDLMOL(strData);
            }
            catch (e) { }
            return mol;
        }
        static readNative(strData) {
            let mol = new WebMolKit.Molecule();
            mol.keepTransient = true;
            let lines = strData.split(/\r?\n/);
            if (lines.length < 2)
                return null;
            if (!lines[0].startsWith('SketchEl!') && lines.length >= 4 && lines[3].indexOf('V2000') >= 0) {
                let i = strData.indexOf('SketchEl!');
                if (i < 0)
                    return null;
                lines = strData.substring(i).split(/r?\n/);
            }
            let bits = lines[0].match(/^SketchEl\!\((\d+)\,(\d+)\)/);
            if (!bits)
                return null;
            let numAtoms = parseInt(bits[1]), numBonds = parseInt(bits[2]);
            if (lines.length < 2 + numAtoms + numBonds)
                return null;
            if (!lines[1 + numAtoms + numBonds].match(/^!End/))
                return null;
            for (let n = 0; n < numAtoms; n++) {
                bits = lines[1 + n].split(/[=,;]/);
                let num = mol.addAtom(MoleculeStream.skUnescape(bits[0]), parseFloat(bits[1]), parseFloat(bits[2]), parseInt(bits[3]), parseInt(bits[4]));
                let extra = [], trans = [];
                for (let i = 5; i < bits.length; i++) {
                    let ch = bits[i].charAt(0);
                    if (bits[i].charAt(0) == 'i') { }
                    else if (bits[i].charAt(0) == 'e')
                        mol.setAtomHExplicit(num, parseInt(bits[i].substring(1)));
                    else if (bits[i].charAt(0) == 'm')
                        mol.setAtomIsotope(num, parseInt(bits[i].substring(1)));
                    else if (bits[i].charAt(0) == 'n')
                        mol.setAtomMapNum(num, parseInt(bits[i].substring(1)));
                    else if (bits[i].charAt(0) == 'x')
                        extra.push(MoleculeStream.skUnescape(bits[i]));
                    else if (bits[i].charAt(0) == 'y')
                        trans.push(MoleculeStream.skUnescape(bits[i]));
                    else if (bits[i].charAt(0) == 'z') {
                        mol.setAtomZ(num, parseFloat(bits[i].substring(1)));
                        mol.setIs3D(true);
                    }
                    else
                        extra.push(MoleculeStream.skUnescape(bits[i]));
                }
                mol.setAtomExtra(num, extra);
                mol.setAtomTransient(num, trans);
            }
            for (let n = 0; n < numBonds; n++) {
                bits = lines[1 + numAtoms + n].split(/[=,]/);
                let frto = bits[0].split('-');
                let bfr = parseInt(frto[0].trim()), bto = parseInt(frto[1].trim());
                if (bfr == bto)
                    continue;
                let num = mol.addBond(bfr, bto, parseInt(bits[1]), parseInt(bits[2]));
                let extra = new Array(), trans = new Array();
                for (let i = 3; i < bits.length; i++) {
                    let ch = bits[i].charAt(0);
                    if (bits[i].charAt(0) == 'x')
                        extra.push(MoleculeStream.skUnescape(bits[i]));
                    else if (bits[i].charAt(0) == 'y')
                        trans.push(MoleculeStream.skUnescape(bits[i]));
                    else
                        extra.push(MoleculeStream.skUnescape(bits[i]));
                }
                mol.setBondExtra(num, extra);
                mol.setBondTransient(num, trans);
            }
            mol.keepTransient = false;
            return mol;
        }
        static writeNative(mol) {
            let ret = 'SketchEl!(' + mol.numAtoms + ',' + mol.numBonds + ')\n';
            for (let n = 1; n <= mol.numAtoms; n++) {
                let el = mol.atomElement(n), x = mol.atomX(n), y = mol.atomY(n), charge = mol.atomCharge(n), unpaired = mol.atomUnpaired(n);
                let hy = mol.atomHExplicit(n) != WebMolKit.Molecule.HEXPLICIT_UNKNOWN ? ('e' + mol.atomHExplicit(n)) : ('i' + mol.atomHydrogens(n));
                ret += MoleculeStream.skEscape(el) + '=' + x.toFixed(4) + ',' + y.toFixed(4) + ';' + charge + ',' + unpaired + ',' + hy;
                if (mol.is3D())
                    ret += ',z' + mol.atomZ(n);
                if (mol.atomIsotope(n) != WebMolKit.Molecule.ISOTOPE_NATURAL)
                    ret += ',m' + mol.atomIsotope(n);
                if (mol.atomMapNum(n) > 0)
                    ret += ',n' + mol.atomMapNum(n);
                ret += MoleculeStream.skEncodeExtra(mol.atomExtra(n));
                ret += MoleculeStream.skEncodeExtra(mol.atomTransient(n));
                ret += '\n';
            }
            for (let n = 1; n <= mol.numBonds; n++) {
                ret += mol.bondFrom(n) + '-' + mol.bondTo(n) + '=' + mol.bondOrder(n) + ',' + mol.bondType(n);
                ret += MoleculeStream.skEncodeExtra(mol.bondExtra(n));
                ret += MoleculeStream.skEncodeExtra(mol.bondTransient(n));
                ret += '\n';
            }
            ret += '!End\n';
            return ret;
        }
        static readMDLMOL(strData) {
            let src = new WebMolKit.MDLMOLReader(strData);
            src.parseHeader = true;
            src.parse();
            return src.mol;
        }
        static writeMDLMOL(mol) {
            return new WebMolKit.MDLMOLWriter(mol).write();
        }
        static skUnescape(str) {
            let ret = '', match;
            while (match = str.match(/^(.*?)\\([0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f])(.*)/)) {
                ret += match[1] + String.fromCharCode(parseInt('0x' + match[2]));
                str = match[3];
            }
            return ret + str;
        }
        static skEscape(str) {
            let ret = '';
            for (let n = 0; n < str.length; n++) {
                let ch = str.charAt(n), code = str.charCodeAt(n);
                if (code <= 32 || code > 127 || ch == '\\' || ch == ',' || ch == ';' || ch == '=') {
                    let hex = (code & 0xFFFF).toString(16).toUpperCase();
                    ret += '\\';
                    for (let i = 4 - hex.length; i > 0; i--)
                        ret += '0';
                    ret += hex;
                }
                else
                    ret += ch;
            }
            return ret;
        }
        static skEncodeExtra(extra) {
            let ret = '';
            for (let n = 0; n < extra.length; n++)
                ret += ',' + MoleculeStream.skEscape(extra[n]);
            return ret;
        }
    }
    WebMolKit.MoleculeStream = MoleculeStream;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let globalInstance = null;
    const ONTOLOGY_FILES = [
        'units'
    ];
    class OntologyTree {
        constructor() {
            this.roots = [];
            this.mapTerms = new Map();
            this.alreadyLoaded = new Set();
        }
        static get main() { return globalInstance; }
        static init() {
            return __awaiter(this, void 0, void 0, function* () {
                if (globalInstance)
                    return;
                globalInstance = new OntologyTree();
                for (let fn of ONTOLOGY_FILES) {
                    let url = WebMolKit.Theme.RESOURCE_URL + '/data/ontology/' + fn + '.onto';
                    globalInstance.loadFromURL(url);
                }
            });
        }
        getRoots() {
            return this.roots;
        }
        hasTerm(uri) { return this.mapTerms.has(uri); }
        getBranch(uri) {
            return this.mapTerms.get(uri);
        }
        getBranchList(root) {
            if (typeof root == 'string') {
                let look = this.mapTerms.get(root);
                if (!look)
                    throw `Unknown branch URI: ${root}`;
                if (look.length > 1)
                    throw `Ambiguous branch URI occurs more than once: ${root}`;
                root = look[0];
            }
            let list = [];
            let accumulate = (branch) => {
                list.push(branch);
                for (let child of WebMolKit.Vec.safeArray(branch.children))
                    accumulate(child);
            };
            accumulate(root);
            return list;
        }
        loadFromURL(url) {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.alreadyLoaded.has(url))
                    return;
                this.alreadyLoaded.add(url);
                let text = yield WebMolKit.readTextURL(url);
                if (!text)
                    throw `Resource not found: ${url}`;
                this.loadContent(text);
            });
        }
        loadContent(text) {
            let termList = [];
            let pos = 0;
            for (let line of text.split(/\n/)) {
                pos++;
                line = line.trim();
                if (!line || line.startsWith('#'))
                    continue;
                let idx = line.indexOf('http');
                if (idx < 0)
                    throw `Line ${pos} invalid, no URI term: ${line}`;
                let depth = 0;
                for (let n = 0; n < idx; n++)
                    if (line.charAt(n) == '-')
                        depth++;
                let uri = line.substring(idx);
                idx = uri.indexOf(' ');
                if (idx < 0)
                    throw `Line ${pos} invalid, no label: ${line}`;
                let label = uri.substring(idx + 1);
                uri = uri.substring(0, idx);
                let term = null;
                if (depth == 0)
                    term = this.roots.find((look) => look.uri == uri);
                if (!term) {
                    term = { uri, label, 'parent': null, 'children': [], depth };
                    if (depth == 0)
                        this.roots.push(term);
                    else {
                        for (let n = termList.length - 1; n >= 0; n--)
                            if (termList[n].depth == depth - 1) {
                                term.parent = termList[n];
                                termList[n].children.push(term);
                                break;
                            }
                        if (!term.parent)
                            throw `Line ${pos} invalid hierarchy, no parent found`;
                    }
                    let list = this.mapTerms.get(uri);
                    if (list)
                        list.push(term);
                    else
                        this.mapTerms.set(uri, [term]);
                }
                termList.push(term);
            }
        }
        debugString(term) {
            let lines = [];
            let emit = (term) => {
                lines.push('* '.repeat(term.depth) + `<${term.uri}> "${term.label}"`);
                for (let child of term.children)
                    emit(child);
            };
            emit(term);
            return lines.join('\n');
        }
    }
    WebMolKit.OntologyTree = OntologyTree;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let OpenMolType;
    (function (OpenMolType) {
        OpenMolType[OpenMolType["None"] = 0] = "None";
        OpenMolType[OpenMolType["AtomCount1000"] = 1] = "AtomCount1000";
        OpenMolType[OpenMolType["BondCount1000"] = 2] = "BondCount1000";
        OpenMolType[OpenMolType["InlineAbbreviations"] = 3] = "InlineAbbreviations";
        OpenMolType[OpenMolType["ZeroOrderBonds"] = 4] = "ZeroOrderBonds";
        OpenMolType[OpenMolType["HydrogenCounting"] = 5] = "HydrogenCounting";
        OpenMolType[OpenMolType["MoleculeName"] = 6] = "MoleculeName";
        OpenMolType[OpenMolType["QueryResonance"] = 7] = "QueryResonance";
        OpenMolType[OpenMolType["QueryHCount"] = 8] = "QueryHCount";
    })(OpenMolType = WebMolKit.OpenMolType || (WebMolKit.OpenMolType = {}));
    const OPENMOL_LEVEL_1_1 = [
        OpenMolType.AtomCount1000,
        OpenMolType.BondCount1000,
    ];
    const OPENMOL_LEVEL_1_2 = [
        OpenMolType.InlineAbbreviations,
    ];
    const OPENMOL_LEVEL_1_3 = [
        OpenMolType.ZeroOrderBonds,
        OpenMolType.HydrogenCounting,
    ];
    const OPENMOL_INVALID = [
        OpenMolType.QueryResonance,
        OpenMolType.QueryHCount,
    ];
    class OpenMolSpec {
        constructor() {
            this.level = 1.0;
            this.invalid = false;
            this.notes = [];
        }
        add(type, atoms, bonds, source) {
            this.addNote({ 'type': type, 'atoms': atoms, 'bonds': bonds, 'source': source });
        }
        addNote(note) {
            this.notes.push(note);
            note.level = 1.0;
            if (OPENMOL_LEVEL_1_1.indexOf(note.type) >= 0)
                note.level = 1.1;
            else if (OPENMOL_LEVEL_1_2.indexOf(note.type) >= 0)
                note.level = 1.2;
            else if (OPENMOL_LEVEL_1_3.indexOf(note.type) >= 0)
                note.level = 1.3;
            this.level = Math.max(this.level, note.level);
            this.invalid = this.invalid || OPENMOL_INVALID.indexOf(note.type) >= 0;
        }
        addJoin(type, atoms, bonds, source) {
            for (let note of this.notes)
                if (note.type == type) {
                    if (atoms && note.atoms)
                        note.atoms = note.atoms.concat(atoms);
                    else if (atoms)
                        note.atoms = atoms;
                    if (bonds && note.bonds)
                        note.bonds = note.bonds.concat(bonds);
                    else if (bonds)
                        note.bonds = bonds;
                    if (source && note.source)
                        note.source = note.source.concat(source);
                    else if (source)
                        note.source = source;
                    return;
                }
            this.add(type, atoms, bonds, source);
        }
        derive(mol) {
            if (mol.numAtoms >= 1000)
                this.add(OpenMolType.AtomCount1000);
            if (mol.numBonds >= 1000)
                this.add(OpenMolType.BondCount1000);
        }
    }
    WebMolKit.OpenMolSpec = OpenMolSpec;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    WebMolKit.POLYMERBLOCK_EXTRA_POLYMER = 'xPOLYMER:';
    WebMolKit.POLYMERBLOCK_SPECIAL_UNCAPPED = '*';
    let PolymerBlockConnectivity;
    (function (PolymerBlockConnectivity) {
        PolymerBlockConnectivity["HeadToTail"] = "ht";
        PolymerBlockConnectivity["HeadToHead"] = "hh";
        PolymerBlockConnectivity["Random"] = "rnd";
    })(PolymerBlockConnectivity = WebMolKit.PolymerBlockConnectivity || (WebMolKit.PolymerBlockConnectivity = {}));
    class PolymerBlockUnit {
        constructor(atoms) {
            this.atoms = atoms;
            this.connect = null;
            this.bondConn = null;
            this.atomName = new Map();
            this.bondIncl = new Map();
            this.bondExcl = new Map();
        }
        clone() {
            let dup = new PolymerBlockUnit(this.atoms.slice(0));
            dup.connect = this.connect;
            if (this.bondConn)
                dup.bondConn = this.bondConn.slice(0);
            for (let [k, v] of this.atomName.entries())
                dup.atomName.set(k, v.slice(0));
            for (let [k, v] of this.bondIncl.entries())
                dup.bondIncl.set(k, v.slice(0));
            for (let [k, v] of this.bondExcl.entries())
                dup.bondExcl.set(k, v.slice(0));
            return dup;
        }
    }
    WebMolKit.PolymerBlockUnit = PolymerBlockUnit;
    class PolymerBlock {
        constructor(mol) {
            this.mol = mol;
            this.units = new Map();
            let blockAtoms = new Map();
            for (let n = 1; n <= mol.numAtoms; n++) {
                let extra = mol.atomExtra(n);
                for (let str of extra)
                    if (str.startsWith(WebMolKit.POLYMERBLOCK_EXTRA_POLYMER)) {
                        let bits = str.substring(WebMolKit.POLYMERBLOCK_EXTRA_POLYMER.length).split(':');
                        let id = parseInt(bits[0]);
                        if (id > 0) {
                            let atoms = blockAtoms.get(id);
                            if (atoms)
                                atoms.push(n);
                            else
                                atoms = [n];
                            blockAtoms.set(id, atoms);
                        }
                    }
            }
            for (let key of WebMolKit.Vec.sorted(Array.from(blockAtoms.keys())))
                this.appendBlock(key, blockAtoms.get(key));
        }
        getIDList() { return WebMolKit.Vec.sorted(Array.from(this.units.keys())); }
        getUnit(id) { return this.units.get(id); }
        getUnits() { return Array.from(this.units.values()); }
        rewriteMolecule() {
            this.purgeExtraFields();
            for (let key of WebMolKit.Vec.sorted(Array.from(this.units.keys())))
                this.writeUnit(key, this.units.get(key));
        }
        harmoniseNumbering(other) {
            let allKeys = other.getIDList();
            for (let key of this.getIDList())
                if (allKeys.includes(key)) {
                    let unit = this.units.get(key);
                    this.units.delete(key);
                    key = this.nextIdentifier(allKeys);
                    this.units.set(key, unit);
                    allKeys.push(key);
                }
        }
        removeUnit(id) {
            let unit = this.units.get(id);
            if (unit == null)
                return;
            this.units.delete(id);
            let pfx = WebMolKit.POLYMERBLOCK_EXTRA_POLYMER + id + ':';
            for (let a of unit.atoms) {
                let extra = this.mol.atomExtra(a);
                for (let i = extra.length - 1; i >= 0; i--)
                    if (extra[i].startsWith(pfx))
                        extra = WebMolKit.Vec.remove(extra, i);
                this.mol.setAtomExtra(a, extra);
            }
            for (let b = 1; b <= this.mol.numBonds; b++) {
                let extra = this.mol.bondExtra(b);
                if (WebMolKit.Vec.isBlank(extra))
                    continue;
                for (let i = extra.length - 1; i >= 0; i--)
                    if (extra[i].startsWith(pfx))
                        extra = WebMolKit.Vec.remove(extra, i);
                this.mol.setBondExtra(b, extra);
            }
        }
        removeAll() {
            this.units.clear();
            this.purgeExtraFields();
        }
        createUnit(unit) {
            let id = this.nextIdentifier();
            this.units.set(id, unit.clone());
            this.writeUnit(id, unit);
            return id;
        }
        static hasPolymerExtensions(mol) {
            for (let n = 1; n <= mol.numAtoms; n++) {
                let extra = mol.atomExtra(n);
                if (extra != null)
                    for (let str of extra)
                        if (str.startsWith(WebMolKit.POLYMERBLOCK_EXTRA_POLYMER))
                            return true;
            }
            return false;
        }
        static getPolymerExtensions(mol, atom) {
            let extra = mol.atomExtra(atom), polext = null;
            if (extra == null)
                return null;
            for (let str of extra)
                if (str.startsWith(WebMolKit.POLYMERBLOCK_EXTRA_POLYMER))
                    polext = WebMolKit.Vec.append(polext, str);
            return polext;
        }
        static removePolymerExtensions(mol, atom) {
            let extra = mol.atomExtra(atom);
            if (extra == null)
                return;
            let modified = false;
            for (let i = extra.length - 1; i >= 0; i--)
                if (extra[i].startsWith(WebMolKit.POLYMERBLOCK_EXTRA_POLYMER)) {
                    extra = WebMolKit.Vec.remove(extra, i);
                    modified = true;
                }
            if (modified)
                mol.setAtomExtra(atom, extra);
        }
        appendBlock(id, atoms) {
            const { mol } = this;
            let nattach = 0;
            let unit = new PolymerBlockUnit(atoms);
            for (let atom of atoms)
                for (let extra of mol.atomExtra(atom))
                    if (extra.startsWith(WebMolKit.POLYMERBLOCK_EXTRA_POLYMER)) {
                        let bits = extra.substring(WebMolKit.POLYMERBLOCK_EXTRA_POLYMER.length).split(':');
                        if (bits.length < 2 || parseInt(bits[0]) != id)
                            continue;
                        nattach = parseInt(bits[1]);
                        for (let n = 2; n < bits.length; n++) {
                            if (bits[n] == PolymerBlockConnectivity.HeadToTail)
                                unit.connect = PolymerBlockConnectivity.HeadToTail;
                            else if (bits[n] == PolymerBlockConnectivity.HeadToHead)
                                unit.connect = PolymerBlockConnectivity.HeadToHead;
                            else if (bits[n] == PolymerBlockConnectivity.Random)
                                unit.connect = PolymerBlockConnectivity.Random;
                            else if (bits[n].startsWith('n')) {
                                let hasOuter = false;
                                for (let adj of mol.atomAdjList(atom))
                                    if (!atoms.includes(adj)) {
                                        hasOuter = true;
                                        break;
                                    }
                                if (hasOuter) {
                                    let subBits = bits[n].substring(1).split(',');
                                    unit.atomName.set(atom, subBits.map((str) => parseInt(str)));
                                }
                            }
                        }
                    }
            if (nattach < 0)
                return;
            for (let n = 1; n <= mol.numBonds; n++) {
                let in1 = atoms.indexOf(mol.bondFrom(n)) >= 0, in2 = atoms.indexOf(mol.bondTo(n)) >= 0;
                if ((in1 && !in2) || (!in1 && in2))
                    nattach--;
            }
            if (nattach != 0)
                return;
            let bonds = null, order = null;
            for (let n = 1; n <= mol.numBonds; n++) {
                for (let extra of mol.bondExtra(n))
                    if (extra.startsWith(WebMolKit.POLYMERBLOCK_EXTRA_POLYMER)) {
                        let bits = extra.substring(WebMolKit.POLYMERBLOCK_EXTRA_POLYMER.length).split(':');
                        if (bits.length < 2 || parseInt(bits[0]) != id)
                            continue;
                        for (let i = 1; i < bits.length; i++) {
                            if (bits[i].startsWith('i')) {
                                let subBits = bits[i].substring(1).split(',');
                                unit.bondIncl.set(n, subBits.map((str) => parseInt(str)));
                            }
                            else if (bits[i].startsWith('e')) {
                                let subBits = bits[i].substring(1).split(',');
                                unit.bondExcl.set(n, subBits.map((str) => parseInt(str)));
                            }
                            else {
                                let o = parseInt(bits[i]);
                                if (o > 0) {
                                    bonds = WebMolKit.Vec.append(bonds, n);
                                    order = WebMolKit.Vec.append(order, o);
                                }
                            }
                        }
                    }
            }
            if (bonds != null) {
                if (bonds.length % 2 == 1)
                    return;
                unit.bondConn = WebMolKit.Vec.idxGet(bonds, WebMolKit.Vec.idxSort(order));
            }
            this.units.set(id, unit);
        }
        formatBlockAtom(id, unit, atom) {
            let nbonds = 0;
            for (let n = 1; n <= this.mol.numBonds; n++) {
                let in1 = unit.atoms.indexOf(this.mol.bondFrom(n)) >= 0, in2 = unit.atoms.indexOf(this.mol.bondTo(n)) >= 0;
                if ((in1 && !in2) || (!in1 && in2))
                    nbonds++;
            }
            let str = WebMolKit.POLYMERBLOCK_EXTRA_POLYMER + id + ':' + nbonds;
            if (unit.connect != null)
                str += ':' + unit.connect;
            let names = unit.atomName.get(atom);
            if (WebMolKit.Vec.notBlank(names))
                str += ':n' + names.join(',');
            return str;
        }
        formatBlockBond(id, unit, bond) {
            let in1 = unit.atoms.includes(this.mol.bondFrom(bond)), in2 = unit.atoms.includes(this.mol.bondTo(bond));
            let isBoundary = (in1 && !in2) || (in2 && !in1);
            if (!isBoundary)
                return null;
            let idxConn = unit.bondConn ? unit.bondConn.indexOf(bond) : -1;
            let incl = unit.bondIncl.get(bond), excl = unit.bondExcl.get(bond);
            if (idxConn < 0 && WebMolKit.Vec.isBlank(incl) && WebMolKit.Vec.isBlank(excl))
                return null;
            let str = WebMolKit.POLYMERBLOCK_EXTRA_POLYMER + id;
            if (idxConn >= 0)
                str += ':' + (idxConn + 1);
            if (WebMolKit.Vec.notBlank(incl))
                str += ':i' + incl.join(',');
            if (WebMolKit.Vec.notBlank(excl))
                str += ':e' + excl.join(',');
            return str;
        }
        purgeExtraFields() {
            for (let n = 1; n <= this.mol.numAtoms; n++) {
                let extra = this.mol.atomExtra(n);
                let modified = false;
                for (let i = extra.length - 1; i >= 0; i--)
                    if (extra[i].startsWith(WebMolKit.POLYMERBLOCK_EXTRA_POLYMER)) {
                        extra = WebMolKit.Vec.remove(extra, i);
                        modified = true;
                    }
                if (modified)
                    this.mol.setAtomExtra(n, extra);
            }
            for (let n = 1; n <= this.mol.numBonds; n++) {
                let extra = this.mol.bondExtra(n);
                let modified = false;
                for (let i = extra.length - 1; i >= 0; i--)
                    if (extra[i].startsWith(WebMolKit.POLYMERBLOCK_EXTRA_POLYMER)) {
                        extra = WebMolKit.Vec.remove(extra, i);
                        modified = true;
                    }
                if (modified)
                    this.mol.setBondExtra(n, extra);
            }
        }
        writeUnit(id, unit) {
            const { mol } = this;
            for (let a of unit.atoms) {
                let codeAtom = this.formatBlockAtom(id, unit, a);
                mol.setAtomExtra(a, WebMolKit.Vec.append(mol.atomExtra(a), codeAtom));
            }
            for (let b = 1; b <= mol.numBonds; b++) {
                let codeBond = this.formatBlockBond(id, unit, b);
                if (codeBond)
                    mol.setBondExtra(b, WebMolKit.Vec.append(mol.bondExtra(b), codeBond));
            }
        }
        nextIdentifier(keys) {
            if (!keys)
                keys = this.getIDList();
            if (keys.length == 0)
                return 1;
            for (let n = 0; n < keys.length - 1; n++)
                if (keys[n + 1] != keys[n] + 1)
                    return keys[n] + 1;
            return keys[keys.length - 1] + 1;
        }
    }
    WebMolKit.PolymerBlock = PolymerBlock;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let QuantityCalcRole;
    (function (QuantityCalcRole) {
        QuantityCalcRole[QuantityCalcRole["Primary"] = 1] = "Primary";
        QuantityCalcRole[QuantityCalcRole["Secondary"] = 2] = "Secondary";
        QuantityCalcRole[QuantityCalcRole["Product"] = 3] = "Product";
        QuantityCalcRole[QuantityCalcRole["Independent"] = 4] = "Independent";
    })(QuantityCalcRole = WebMolKit.QuantityCalcRole || (WebMolKit.QuantityCalcRole = {}));
    let QuantityCalcStat;
    (function (QuantityCalcStat) {
        QuantityCalcStat[QuantityCalcStat["Unknown"] = 0] = "Unknown";
        QuantityCalcStat[QuantityCalcStat["Actual"] = 1] = "Actual";
        QuantityCalcStat[QuantityCalcStat["Virtual"] = 2] = "Virtual";
        QuantityCalcStat[QuantityCalcStat["Conflict"] = 3] = "Conflict";
    })(QuantityCalcStat = WebMolKit.QuantityCalcStat || (WebMolKit.QuantityCalcStat = {}));
    class QuantityCalcComp {
        constructor(comp, step, type, idx) {
            this.comp = comp;
            this.step = step;
            this.type = type;
            this.idx = idx;
            this.role = 0;
            this.molw = 0;
            this.valueEquiv = 0;
            this.statEquiv = 0;
            this.valueMass = QuantityCalc.UNSPECIFIED;
            this.statMass = 0;
            this.valueVolume = QuantityCalc.UNSPECIFIED;
            this.statVolume = 0;
            this.valueMoles = QuantityCalc.UNSPECIFIED;
            this.statMoles = 0;
            this.valueDensity = QuantityCalc.UNSPECIFIED;
            this.statDensity = 0;
            this.valueConc = QuantityCalc.UNSPECIFIED;
            this.statConc = 0;
            this.valueYield = QuantityCalc.UNSPECIFIED;
            this.statYield = 0;
        }
    }
    WebMolKit.QuantityCalcComp = QuantityCalcComp;
    class GreenMetrics {
        constructor() {
            this.step = 0;
            this.idx = 0;
            this.massReact = [];
            this.massProd = [];
            this.massWaste = [];
            this.massProdWaste = [];
            this.molwReact = [];
            this.molwProd = [];
            this.impliedWaste = 0;
            this.isBlank = false;
        }
    }
    WebMolKit.GreenMetrics = GreenMetrics;
    class QuantityCalc {
        constructor(entry) {
            this.entry = entry;
            this.quantities = [];
            this.primaryMoles = [];
            this.idxPrimary = [];
            this.idxYield = [];
            this.allMassReact = [];
            this.allMassProd = [];
            this.allMassWaste = [];
            this.greenMetrics = [];
        }
        static isStoichZero(stoich) {
            if (this.isStoichUnity(stoich))
                return false;
            if (parseFloat(stoich) == 0)
                return true;
            return false;
        }
        static isStoichUnity(stoich) {
            if (!stoich || stoich == '1')
                return true;
            let [numer, denom] = this.extractStoichFraction(stoich);
            return numer != 0 && numer == denom;
        }
        static extractStoichFraction(stoich) {
            if (!stoich)
                return [1, 1];
            let numer = 1, denom = 1;
            let i = stoich.indexOf('/');
            if (i < 0) {
                let v = parseFloat(stoich);
                if (v >= 0)
                    numer = v;
            }
            else {
                let v1 = parseFloat(stoich.substring(0, i)), v2 = parseFloat(stoich.substring(i + 1));
                if (v1 >= 0)
                    numer = v1;
                if (v2 >= 0)
                    denom = v2;
            }
            return [numer, denom];
        }
        static extractStoichValue(stoich) {
            let [numer, denom] = this.extractStoichFraction(stoich);
            return denom <= 1 ? numer : numer / denom;
        }
        static stoichAsRatio(stoich) {
            let [numer, denom] = this.extractStoichFraction(stoich);
            if (numer == Math.floor(numer))
                return [numer, denom];
            return this.stoichFractAsRatio(numer);
        }
        static stoichFractAsRatio(fract) {
            if (fract == Math.floor(fract))
                return [fract, 1];
            const MAX_DENOM = QuantityCalc.MAX_DENOM;
            if (QuantityCalc.RATIO_FRACT == null) {
                QuantityCalc.RATIO_FRACT = [];
                for (let p = 0, j = 2; j <= MAX_DENOM; j++)
                    for (let i = 1; i < j && i < MAX_DENOM - 1; i++)
                        QuantityCalc.RATIO_FRACT.push(i * 1.0 / j);
            }
            let whole = Math.floor(fract);
            let resid = fract - whole;
            let bestDiff = Number.MAX_VALUE;
            let bestOver = 1, bestUnder = 1;
            for (let p = 0, j = 2; j <= MAX_DENOM; j++)
                for (let i = 1; i < j && i < MAX_DENOM - 1; i++) {
                    let diff = Math.abs(QuantityCalc.RATIO_FRACT[p++] - resid);
                    if (diff < bestDiff) {
                        bestDiff = diff;
                        bestOver = i;
                        bestUnder = j;
                    }
                }
            return [bestOver + (whole * bestUnder), bestUnder];
        }
        static impliedReagentStoich(reagent, products) {
            if (WebMolKit.MolUtil.isBlank(reagent.mol) || products.length == 0)
                return 0;
            let pstoich = WebMolKit.Vec.numberArray(-1, products.length);
            let rmol = reagent.mol;
            let highest = 0;
            for (let n = 1; n <= rmol.numAtoms; n++) {
                let m = rmol.atomMapNum(n);
                if (m == 0)
                    continue;
                let total = 0;
                for (let i = 0; i < products.length; i++) {
                    let pmol = products[i].mol;
                    if (WebMolKit.MolUtil.isBlank(pmol))
                        continue;
                    let pcount = 0;
                    for (let j = 1; j <= pmol.numAtoms; j++)
                        if (pmol.atomMapNum(j) == m)
                            pcount++;
                    if (pcount > 0) {
                        let rcount = 0;
                        for (let k = 1; k <= rmol.numAtoms; k++)
                            if (rmol.atomMapNum(k) == m)
                                rcount++;
                        if (pstoich[i] < 0)
                            pstoich[i] = QuantityCalc.extractStoichValue(products[i].stoich);
                        total += pcount * pstoich[i] / rcount;
                    }
                }
                highest = Math.max(highest, total);
            }
            return highest;
        }
        static componentRatio(entry, step) {
            let numer = [], denom = [];
            let reactants = step == 0 ? entry.steps[0].reactants : entry.steps[step - 1].products;
            for (let comp of reactants) {
                let [num, den] = this.stoichAsRatio(comp.stoich);
                numer.push(num);
                denom.push(den);
            }
            for (let comp of entry.steps[step].reagents) {
                let fract = this.impliedReagentStoich(comp, entry.steps[step].products);
                let [num, den] = fract == 0 ? [0, 1] : this.stoichFractAsRatio(fract);
                numer.push(num == 0 ? 1 : num);
                denom.push(den);
            }
            for (let comp of entry.steps[step].products) {
                let [num, den] = this.stoichAsRatio(comp.stoich);
                numer.push(num == 0 ? 1 : num);
                denom.push(den);
            }
            let bigDenom = 1;
            for (let n = 0; n < numer.length; n++)
                if (denom[n] > 1 && bigDenom % denom[n] != 0)
                    bigDenom *= denom[n];
            let ratioReactants = [], ratioReagents = [], ratioProducts = [];
            let p = 0;
            for (let n = 0; n < reactants.length; n++, p++)
                ratioReactants.push(numer[p] * bigDenom / denom[p]);
            for (let n = 0; n < entry.steps[step].reagents.length; n++, p++)
                ratioReagents.push(numer[p] * bigDenom / denom[p]);
            for (let n = 0; n < entry.steps[step].products.length; n++, p++)
                ratioProducts.push(numer[p] * bigDenom / denom[p]);
            return [ratioReactants, ratioReagents, ratioProducts];
        }
        calculate() {
            this.classifyTypes();
            while (this.calculateSomething()) { }
            this.allMassReact = [];
            this.allMassProd = [];
            this.allMassWaste = [];
            for (let n = 0; n < this.quantities.length; n++) {
                let qc = this.quantities[n];
                if (qc.type == WebMolKit.ExperimentComponentType.Reactant || qc.type == WebMolKit.ExperimentComponentType.Reagent) {
                    if (qc.valueEquiv == 0 && qc.type == WebMolKit.ExperimentComponentType.Reagent)
                        continue;
                    this.allMassReact.push(qc.valueMass);
                }
                else if (qc.type == WebMolKit.ExperimentComponentType.Product) {
                    if (!qc.comp.waste) {
                        this.allMassProd.push(qc.valueMass);
                        this.calculateGreenMetrics(n);
                    }
                    else {
                        this.allMassWaste.push(qc.valueMass);
                    }
                }
            }
        }
        get numQuantities() { return this.quantities.length; }
        getQuantity(idx) { return this.quantities[idx]; }
        getAllQuantities() { return this.quantities.slice(0); }
        get numGreenMetrics() { return this.greenMetrics.length; }
        getGreenMetrics(idx) { return this.greenMetrics[idx]; }
        getAllGreenMetrics() { return this.greenMetrics.slice(0); }
        getAllMassReact() { return this.allMassReact.slice(0); }
        getAllMassProd() { return this.allMassProd.slice(0); }
        getAllMassWaste() { return this.allMassWaste.slice(0); }
        findComponent(step, type, idx) {
            for (let qc of this.quantities)
                if (qc.step == step && qc.type == type && qc.idx == idx)
                    return qc;
            return null;
        }
        static formatMolWeight(value) {
            if (value == QuantityCalc.UNSPECIFIED)
                return '';
            return WebMolKit.formatDouble(value, 6) + ' g/mol';
        }
        static formatMass(value) {
            if (value == QuantityCalc.UNSPECIFIED)
                return '';
            if (value <= 1E-6)
                return WebMolKit.formatDouble(value * 1E6, 6) + ' \u03BCg';
            if (value <= 1E-3)
                return WebMolKit.formatDouble(value * 1E3, 6) + ' mg';
            if (value >= 1E3)
                return WebMolKit.formatDouble(value * 1E-3, 6) + ' kg';
            return WebMolKit.formatDouble(value, 6) + ' g';
        }
        static formatVolume(value) {
            if (value == QuantityCalc.UNSPECIFIED)
                return '';
            if (value <= 1E-6)
                return WebMolKit.formatDouble(value * 1E6, 6) + ' nL';
            if (value <= 1E-3)
                return WebMolKit.formatDouble(value * 1E3, 6) + ' \u03BCL';
            if (value >= 1E3)
                return WebMolKit.formatDouble(value * 1E-3, 6) + ' L';
            return WebMolKit.formatDouble(value, 6) + ' mL';
        }
        static formatMoles(value) {
            if (value == QuantityCalc.UNSPECIFIED)
                return '';
            if (value <= 1E-9)
                return WebMolKit.formatDouble(value * 1E9, 6) + ' nmol';
            if (value <= 1E-6)
                return WebMolKit.formatDouble(value * 1E6, 6) + ' \u03BCmol';
            if (value <= 1E-3)
                return WebMolKit.formatDouble(value * 1E3, 6) + ' mmol';
            return WebMolKit.formatDouble(value, 6) + ' mol';
        }
        static formatDensity(value) {
            if (value == QuantityCalc.UNSPECIFIED)
                return '';
            return WebMolKit.formatDouble(value, 6) + ' g/mL';
        }
        static formatConc(value) {
            if (value == QuantityCalc.UNSPECIFIED)
                return '';
            if (value <= 1E-9)
                return WebMolKit.formatDouble(value * 1E9, 6) + ' nmol/L';
            if (value <= 1E-6)
                return WebMolKit.formatDouble(value * 1E6, 6) + ' \u03BCmol/L';
            if (value <= 1E-3)
                return WebMolKit.formatDouble(value * 1E3, 6) + ' mmol/L';
            return WebMolKit.formatDouble(value, 6) + ' mol/L';
        }
        static formatPercent(value) {
            if (value == QuantityCalc.UNSPECIFIED)
                return '';
            return WebMolKit.formatDouble(value, 6) + '%';
        }
        static formatEquiv(value) {
            if (value == QuantityCalc.UNSPECIFIED)
                return '';
            return WebMolKit.formatDouble(value, 4) + ' equiv';
        }
        classifyTypes() {
            for (let s = 0; s < this.entry.steps.length; s++) {
                let step = this.entry.steps[s];
                for (let n = 0; n < step.reactants.length; n++)
                    this.quantities.push(new QuantityCalcComp(step.reactants[n], s, WebMolKit.ExperimentComponentType.Reactant, n));
                for (let n = 0; n < step.reagents.length; n++)
                    this.quantities.push(new QuantityCalcComp(step.reagents[n], s, WebMolKit.ExperimentComponentType.Reagent, n));
                for (let n = 0; n < step.products.length; n++)
                    this.quantities.push(new QuantityCalcComp(step.products[n], s, WebMolKit.ExperimentComponentType.Product, n));
            }
            for (let n = 0; n < this.quantities.length; n++) {
                let qc = this.quantities[n];
                if (qc.type == WebMolKit.ExperimentComponentType.Reagent) {
                    if (qc.comp.equiv != null)
                        qc.valueEquiv = qc.comp.equiv;
                    else {
                        let eq = QuantityCalc.impliedReagentStoich(qc.comp, this.entry.steps[qc.step].products);
                        if (eq > 0)
                            qc.valueEquiv = eq;
                    }
                }
                else {
                    qc.valueEquiv = QuantityCalc.extractStoichValue(qc.comp.stoich);
                }
                if (qc.comp.mol != null)
                    qc.molw = WebMolKit.MolUtil.molecularWeight(qc.comp.mol);
                qc.role = 4;
                if (qc.step == 0 && qc.type == WebMolKit.ExperimentComponentType.Reactant) {
                    if (qc.comp.primary) {
                        qc.role = 1;
                        this.idxPrimary.push(n);
                    }
                    else
                        qc.role = 2;
                }
                else if (qc.type == WebMolKit.ExperimentComponentType.Reagent) {
                    if (qc.valueEquiv > 0)
                        qc.role = 2;
                }
                else if (qc.type == WebMolKit.ExperimentComponentType.Product && !qc.comp.waste) {
                    qc.role = 3;
                    this.idxYield.push(n);
                }
                else if (qc.valueEquiv > 0) {
                    qc.role = 2;
                }
                if (qc.comp.mass != null)
                    qc.valueMass = qc.comp.mass;
                if (qc.comp.volume != null)
                    qc.valueVolume = qc.comp.volume;
                if (qc.comp.moles != null)
                    qc.valueMoles = qc.comp.moles;
                if (qc.comp.density != null)
                    qc.valueDensity = qc.comp.density;
                if (qc.comp.conc != null)
                    qc.valueConc = qc.comp.conc;
                if (qc.comp.yield != null)
                    qc.valueYield = qc.comp.yield;
                qc.statEquiv = qc.valueEquiv == QuantityCalc.UNSPECIFIED ? 0 : 1;
                qc.statMass = qc.valueMass == QuantityCalc.UNSPECIFIED ? 0 : 1;
                qc.statVolume = qc.valueVolume == QuantityCalc.UNSPECIFIED ? 0 : 1;
                qc.statMoles = qc.valueMoles == QuantityCalc.UNSPECIFIED ? 0 : 1;
                qc.statDensity = qc.valueDensity == QuantityCalc.UNSPECIFIED ? 0 : 1;
                qc.statConc = qc.valueConc == QuantityCalc.UNSPECIFIED ? 0 : 1;
                qc.statYield = qc.valueYield == QuantityCalc.UNSPECIFIED ? 0 : 1;
            }
            if (this.idxPrimary.length == 0) {
                for (let n = 0; n < this.quantities.length; n++) {
                    let qc = this.quantities[n];
                    if (qc.type == WebMolKit.ExperimentComponentType.Reactant && qc.step == 0) {
                        qc.role = 1;
                        this.idxPrimary.push(n);
                    }
                }
            }
        }
        calculateSomething() {
            let anything = false;
            for (let qc of this.quantities) {
                if (qc.molw > 0 && qc.valueMass == QuantityCalc.UNSPECIFIED && qc.statMoles == 1) {
                    qc.valueMass = qc.valueMoles * qc.molw;
                    qc.statMass = 2;
                    anything = true;
                }
                if (qc.molw > 0 && qc.valueMass != QuantityCalc.UNSPECIFIED && qc.valueMoles == QuantityCalc.UNSPECIFIED) {
                    qc.valueMoles = qc.valueMass / qc.molw;
                    qc.statMoles = 2;
                    anything = true;
                }
                if (qc.molw > 0 && qc.statMass == 1 && qc.statMoles == 1) {
                    let calcMoles = qc.valueMass / qc.molw;
                    if (!this.closeEnough(qc.valueMoles, calcMoles)) {
                        qc.statMass = 3;
                        qc.statMoles = 3;
                    }
                }
                let isSoln = qc.statConc == 1 ||
                    (qc.statVolume == 1 && (qc.statMass == 1 || qc.statMoles == 1));
                if (!isSoln) {
                    if (qc.valueDensity > 0 && qc.valueMass == QuantityCalc.UNSPECIFIED && qc.valueVolume != QuantityCalc.UNSPECIFIED) {
                        qc.valueMass = qc.valueVolume * qc.valueDensity;
                        qc.statMass = 2;
                        anything = true;
                    }
                    if (qc.valueDensity > 0 && qc.valueMass != QuantityCalc.UNSPECIFIED && qc.valueVolume == QuantityCalc.UNSPECIFIED) {
                        qc.valueVolume = qc.valueMass / qc.valueDensity;
                        qc.statVolume = 2;
                        anything = true;
                    }
                    if (qc.valueDensity == QuantityCalc.UNSPECIFIED && qc.valueMass != QuantityCalc.UNSPECIFIED &&
                        qc.valueVolume != QuantityCalc.UNSPECIFIED && qc.valueConc == QuantityCalc.UNSPECIFIED) {
                        if (qc.statMass == 1 || qc.statMoles == 1) {
                            qc.valueDensity = qc.valueMass / qc.valueVolume;
                            qc.statDensity = 2;
                            anything = true;
                        }
                    }
                }
                if (isSoln) {
                    if (qc.valueConc > 0 && qc.valueMoles == QuantityCalc.UNSPECIFIED && qc.valueVolume != QuantityCalc.UNSPECIFIED) {
                        qc.valueMoles = 0.001 * qc.valueVolume * qc.valueConc;
                        qc.statMoles = 2;
                        anything = true;
                    }
                    if (qc.valueConc > 0 && qc.valueMoles != QuantityCalc.UNSPECIFIED && qc.valueVolume == QuantityCalc.UNSPECIFIED) {
                        qc.valueVolume = 1000 * qc.valueMoles / qc.valueConc;
                        qc.statVolume = 2;
                        anything = true;
                    }
                    if (qc.valueConc == QuantityCalc.UNSPECIFIED && qc.valueMass != QuantityCalc.UNSPECIFIED && qc.valueVolume != QuantityCalc.UNSPECIFIED) {
                        qc.valueConc = 1000 * qc.valueMoles / qc.valueVolume;
                        qc.statConc = 2;
                        anything = true;
                    }
                    if (qc.statConc == 1 && qc.valueMoles > 0 && qc.statVolume == 1) {
                        let calcVolume = 1000 * qc.valueMoles / qc.valueConc;
                        if (!this.closeEnough(qc.valueVolume, calcVolume)) {
                            qc.statConc = 3;
                            if (qc.statMass == 1)
                                qc.statMass = 3;
                            if (qc.statMoles == 1)
                                qc.statMoles = 3;
                            qc.statVolume = 3;
                        }
                    }
                }
                if (qc.molw > 0 && qc.valueMass == QuantityCalc.UNSPECIFIED && qc.valueMoles != QuantityCalc.UNSPECIFIED) {
                    qc.valueMass = qc.valueMoles * qc.molw;
                    qc.statMass = 2;
                    anything = true;
                }
                if (qc.statDensity == 1 && qc.statConc == 1) {
                    qc.statDensity = 3;
                    qc.statConc = 3;
                }
            }
            if (anything)
                return true;
            let hasRef = false;
            let numSteps = this.entry.steps.length;
            let primaryCounts = WebMolKit.Vec.numberArray(0, numSteps);
            let primaryEquivs = WebMolKit.Vec.numberArray(0, numSteps);
            let primaryMoles = this.primaryMoles = WebMolKit.Vec.numberArray(0, numSteps);
            for (let qc of this.quantities) {
                let ref = -1;
                if (qc.step == 0 && qc.type == WebMolKit.ExperimentComponentType.Reactant && qc.comp.primary)
                    ref = qc.step;
                else if (qc.step < numSteps - 1 && qc.type == WebMolKit.ExperimentComponentType.Product && !qc.comp.waste)
                    ref = qc.step + 1;
                else
                    continue;
                if (primaryEquivs[ref] < 0)
                    continue;
                if (qc.statMoles == 1) {
                    primaryEquivs[ref] = -1;
                    continue;
                }
                primaryCounts[ref]++;
                primaryEquivs[ref] += qc.valueEquiv;
                primaryMoles[ref] += qc.valueMoles;
            }
            if (primaryEquivs[0] <= 0) {
                primaryCounts[0] = 0;
                primaryEquivs[0] = 0;
                primaryMoles[0] = 0;
                for (let i of this.idxPrimary) {
                    let qc = this.quantities[i];
                    if (qc.statMoles == 0) {
                        primaryCounts[0] = 0;
                        primaryEquivs[0] = -1;
                        primaryMoles[0] = 0;
                        break;
                    }
                    primaryCounts[0]++;
                    primaryEquivs[0] += qc.valueEquiv;
                    primaryMoles[0] += qc.valueMoles;
                }
            }
            let refMoles = WebMolKit.Vec.numberArray(0, numSteps);
            for (let n = 0; n < numSteps; n++) {
                refMoles[n] = primaryCounts[n] == 0 || primaryEquivs[n] <= 0 ? 0 : primaryMoles[n] / primaryEquivs[n];
                if (refMoles[n] > 0)
                    hasRef = true;
            }
            if (!hasRef) {
                for (let n = 0; n < numSteps; n++) {
                    let prodMolar = [];
                    for (let qc of this.quantities) {
                        if (qc.step != n || qc.role != 3)
                            continue;
                        if (qc.statMoles == 0 || qc.valueMoles <= 0 || qc.valueEquiv <= 0)
                            continue;
                        let yld = qc.valueYield > 0 ? qc.valueYield * 0.01 : 1;
                        prodMolar.push(qc.valueMoles / (qc.valueEquiv * yld));
                    }
                    if (prodMolar.length > 0) {
                        refMoles[n] = WebMolKit.Vec.sum(prodMolar) / prodMolar.length;
                        hasRef = true;
                    }
                }
            }
            if (!hasRef)
                return false;
            for (let qc of this.quantities) {
                if (qc.type != WebMolKit.ExperimentComponentType.Product)
                    continue;
                if (refMoles[qc.step] == 0)
                    continue;
                if (qc.valueYield == QuantityCalc.UNSPECIFIED && qc.valueMoles != QuantityCalc.UNSPECIFIED) {
                    qc.valueYield = 100 * qc.valueMoles / (refMoles[qc.step] * qc.valueEquiv);
                    qc.statYield = 2;
                    anything = true;
                }
                if (qc.valueYield != QuantityCalc.UNSPECIFIED && qc.valueMoles == QuantityCalc.UNSPECIFIED) {
                    qc.valueMoles = qc.valueYield * 0.01 * (refMoles[qc.step] * qc.valueEquiv);
                    qc.statMoles = 2;
                    anything = true;
                }
                if (qc.valueMoles > 0 && qc.statYield == 1) {
                    let calcYield = 100 * qc.valueMoles / (refMoles[qc.step] * qc.valueEquiv);
                    if (!this.closeEnough(qc.valueYield, calcYield)) {
                        if (qc.statMass == 1)
                            qc.statMass = 3;
                        if (qc.statMoles == 1)
                            qc.statMoles = 3;
                        qc.statYield = 3;
                    }
                }
            }
            if (anything)
                return true;
            for (let qc of this.quantities) {
                if (refMoles[qc.step] == 0)
                    continue;
                if (qc.valueMass == QuantityCalc.UNSPECIFIED && qc.valueMoles == QuantityCalc.UNSPECIFIED && qc.valueEquiv > 0) {
                    qc.valueMoles = refMoles[qc.step] * qc.valueEquiv;
                    qc.statMoles = 2;
                    anything = true;
                }
                if (qc.valueMoles != QuantityCalc.UNSPECIFIED && qc.valueEquiv == QuantityCalc.UNSPECIFIED) {
                    qc.valueEquiv = qc.valueMoles / refMoles[qc.step];
                    qc.statEquiv = 2;
                    anything = true;
                }
            }
            return anything;
        }
        calculateGreenMetrics(idx) {
            let qc = this.quantities[idx];
            let gm = new GreenMetrics();
            gm.step = qc.step;
            gm.idx = qc.idx;
            gm.isBlank = true;
            for (let n = 0; n < this.quantities.length; n++) {
                let sub = this.quantities[n];
                if (sub.step > gm.step)
                    continue;
                let eq = sub.valueEquiv;
                if (eq == 0 && sub.type == WebMolKit.ExperimentComponentType.Reagent)
                    continue;
                if (sub.valueMass != QuantityCalc.UNSPECIFIED)
                    gm.isBlank = false;
                if (sub.type == WebMolKit.ExperimentComponentType.Reactant || sub.type == WebMolKit.ExperimentComponentType.Reagent) {
                    gm.massReact.push(sub.valueMass);
                    if (sub.step == gm.step && eq > 0 && sub.molw > 0)
                        gm.molwReact.push(eq * sub.molw);
                }
                else if (sub.type == WebMolKit.ExperimentComponentType.Product) {
                    if (!sub.comp.waste) {
                        if (sub.step == gm.step)
                            gm.massProd.push(sub.valueMass);
                        if (eq > 0 && sub.molw > 0) {
                            if (sub.step == gm.step)
                                gm.molwProd.push(eq * sub.molw);
                            else if (sub.step == gm.step - 1)
                                gm.molwReact.push(eq * sub.molw);
                        }
                    }
                    else {
                        gm.massWaste.push(sub.valueMass);
                    }
                    if (sub.step == gm.step)
                        gm.massProdWaste.push(sub.valueMass);
                }
            }
            gm.impliedWaste = WebMolKit.Vec.sum(gm.massReact) - WebMolKit.Vec.sum(gm.massProdWaste);
            if (Math.abs(gm.impliedWaste) > 1E-3)
                gm.impliedWaste = 0;
            this.greenMetrics.push(gm);
        }
        closeEnough(value1, value2) {
            if (value1 <= 0 || value2 <= 0)
                return true;
            let ratio = value1 / value2;
            return ratio >= 0.99 && ratio <= 1.01;
        }
    }
    QuantityCalc.UNSPECIFIED = -1;
    QuantityCalc.MAX_DENOM = 16;
    QuantityCalc.RATIO_FRACT = null;
    WebMolKit.QuantityCalc = QuantityCalc;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    function safeInt(str, def = 0) {
        if (str == null || str.length == 0)
            return def;
        let val = str.startsWith('0x') ? parseInt(str.substring(2), 16) :
            str.startsWith('#') ? parseInt(str.substring(1), 16) : parseInt(str);
        return isNaN(val) ? def : val;
    }
    WebMolKit.safeInt = safeInt;
    function safeFloat(str, def = 0) {
        if (str == null || str.length == 0)
            return def;
        let val = parseFloat(str);
        return isNaN(val) ? def : val;
    }
    WebMolKit.safeFloat = safeFloat;
    function newElement(parent, tag, attr) {
        let domNew = WebMolKit.dom(`<${tag}/>`);
        if (attr)
            domNew.attr(attr);
        WebMolKit.domLegacy(parent).append(domNew);
        return domNew.el;
    }
    WebMolKit.newElement = newElement;
    function addText(parent, text) {
        let el = $(parent)[0];
        el.appendChild(document.createTextNode(text));
    }
    WebMolKit.addText = addText;
    function plural(count) {
        return count == 1 ? '' : 's';
    }
    WebMolKit.plural = plural;
    function formatDouble(value, sigfig) {
        if (value == null)
            return '';
        let str = value.toPrecision(sigfig);
        if (str.indexOf('.') > 0) {
            while (str.endsWith('0'))
                str = str.substring(0, str.length - 1);
            if (str.endsWith('.'))
                str = str.substring(0, str.length - 1);
        }
        return str;
    }
    WebMolKit.formatDouble = formatDouble;
    function htmlToRGB(col) {
        if (col == null || col.charAt(0) != '#' || col.length != 7)
            return null;
        return parseInt(col.substring(1), 16);
    }
    WebMolKit.htmlToRGB = htmlToRGB;
    function colourCode(col) {
        let hex = (col & 0xFFFFFF).toString(16);
        while (hex.length < 6)
            hex = '0' + hex;
        return '#' + hex;
    }
    WebMolKit.colourCode = colourCode;
    function colourAlpha(col) {
        let transp = (col >>> 24) & 0xFF;
        return transp == 0 ? 1 : transp == 0xFF ? 0 : 1 - (transp * (1.0 / 255));
    }
    WebMolKit.colourAlpha = colourAlpha;
    const ONE_OVER_255 = 1.0 / 255;
    function colourCanvas(col) {
        if (col == 0xFFFFFF)
            return 'white';
        if (col == 0x000000)
            return 'black';
        if (col == -1)
            return null;
        if (col >= 0 && col <= 0xFFFFFF)
            return colourCode(col);
        const t = ((col >> 24) & 0xFF) * ONE_OVER_255;
        const r = ((col >> 16) & 0xFF);
        const g = ((col >> 8) & 0xFF);
        const b = (col & 0xFF);
        return 'rgba(' + r + ',' + g + ',' + b + ',' + (1 - t) + ')';
    }
    WebMolKit.colourCanvas = colourCanvas;
    function blendRGB(fract, rgb1, rgb2, rgb3) {
        fract = Math.max(0, Math.min(1, fract));
        let r1 = ((rgb1 >> 16) & 0xFF) * ONE_OVER_255, g1 = ((rgb1 >> 8) & 0xFF) * ONE_OVER_255, b1 = (rgb1 & 0xFF) * ONE_OVER_255;
        let r2 = ((rgb2 >> 16) & 0xFF) * ONE_OVER_255, g2 = ((rgb2 >> 8) & 0xFF) * ONE_OVER_255, b2 = (rgb2 & 0xFF) * ONE_OVER_255;
        let R, G, B;
        if (rgb3 == null) {
            let f1 = 1 - fract, f2 = fract;
            R = Math.round(0xFF * (f1 * r1 + f2 * r2));
            G = Math.round(0xFF * (f1 * g1 + f2 * g2));
            B = Math.round(0xFF * (f1 * b1 + f2 * b2));
        }
        else {
            let r3 = ((rgb3 >> 16) & 0xFF) * ONE_OVER_255, g3 = ((rgb3 >> 8) & 0xFF) * ONE_OVER_255, b3 = (rgb3 & 0xFF) * ONE_OVER_255;
            if (fract < 0.5) {
                let f2 = fract * 2, f1 = 1 - f2;
                R = Math.round(0xFF * (f1 * r1 + f2 * r2));
                G = Math.round(0xFF * (f1 * g1 + f2 * g2));
                B = Math.round(0xFF * (f1 * b1 + f2 * b2));
            }
            else {
                let f2 = (fract - 0.5) * 2, f1 = 1 - f2;
                R = Math.round(0xFF * (f1 * r2 + f2 * r3));
                G = Math.round(0xFF * (f1 * g2 + f2 * g3));
                B = Math.round(0xFF * (f1 * b2 + f2 * b3));
            }
        }
        return (R << 16) | (G << 8) | B;
    }
    WebMolKit.blendRGB = blendRGB;
    function formatDate(date) {
        const MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        let day = date.getDate(), mon = date.getMonth(), year = date.getFullYear();
        return day + '-' + MONTHS[mon] + '-' + year;
    }
    WebMolKit.formatDate = formatDate;
    function nodeText(node) {
        let ret = '';
        if (!node)
            return '';
        node = node.firstChild;
        while (node) {
            if (node.nodeType == 3 || node.nodeType == 4)
                ret += node.nodeValue;
            node = node.nextSibling;
        }
        return ret;
    }
    WebMolKit.nodeText = nodeText;
    function isDef(v) {
        return !(v === null || typeof v === 'undefined');
    }
    WebMolKit.isDef = isDef;
    function notDef(v) {
        return v === null || typeof v === 'undefined';
    }
    WebMolKit.notDef = notDef;
    function eventCoords(event, container) {
        let pos = WebMolKit.domLegacy(container).offset();
        let relX = event.pageX - pos.x;
        let relY = event.pageY - pos.y;
        return [relX, relY];
    }
    WebMolKit.eventCoords = eventCoords;
    function setBoundaryPixels(dom, x, y, w, h) {
        dom.css({ 'left': x + 'px', 'top': y + 'px', 'width': w + 'px', 'height': h + 'px' });
    }
    WebMolKit.setBoundaryPixels = setBoundaryPixels;
    function getBoundaryPixels(dom) {
        let offset = dom.offset();
        return [offset.left, offset.top, dom.width(), dom.height()];
    }
    WebMolKit.getBoundaryPixels = getBoundaryPixels;
    function getBoundaryPixelsDOM(dom) {
        let offset = dom.offset();
        return [offset.x, offset.y, dom.width(), dom.height()];
    }
    WebMolKit.getBoundaryPixelsDOM = getBoundaryPixelsDOM;
    function getOffsetPixelsDOM(dom) {
        return [dom.elHTML.offsetLeft, dom.elHTML.offsetTop, dom.elHTML.offsetWidth, dom.elHTML.offsetHeight];
    }
    WebMolKit.getOffsetPixelsDOM = getOffsetPixelsDOM;
    function norm_xy(dx, dy) {
        return Math.sqrt(dx * dx + dy * dy);
    }
    WebMolKit.norm_xy = norm_xy;
    function norm_xyz(dx, dy, dz) {
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }
    WebMolKit.norm_xyz = norm_xyz;
    function norm2_xy(dx, dy) {
        return dx * dx + dy * dy;
    }
    WebMolKit.norm2_xy = norm2_xy;
    function norm2_xyz(dx, dy, dz) {
        return dx * dx + dy * dy + dz * dz;
    }
    WebMolKit.norm2_xyz = norm2_xyz;
    function signum(v) {
        return v < 0 ? -1 : v > 0 ? 1 : 0;
    }
    WebMolKit.signum = signum;
    function sqr(v) {
        return v * v;
    }
    WebMolKit.sqr = sqr;
    function invZ(v) { return v == 0 ? 0 : 1.0 / v; }
    WebMolKit.invZ = invZ;
    function fltEqual(v1, v2) { return v1 == v2 || Math.abs(v1 - v2) <= 1E-7 * Math.max(v1, v2); }
    WebMolKit.fltEqual = fltEqual;
    function realEqual(v1, v2) { return v1 == v2 || Math.abs(v1 - v2) <= 1E-14 * Math.max(v1, v2); }
    WebMolKit.realEqual = realEqual;
    function randomInt(size) {
        if (size <= 1)
            return 0;
        return Math.floor(Math.random() * size);
    }
    WebMolKit.randomInt = randomInt;
    WebMolKit.TWOPI = 2 * Math.PI;
    WebMolKit.INV_TWOPI = 1.0 / WebMolKit.TWOPI;
    WebMolKit.DEGRAD = Math.PI / 180;
    WebMolKit.RADDEG = 180 / Math.PI;
    function angleNorm(th) {
        if (th == -Math.PI)
            return Math.PI;
        if (th < -Math.PI) {
            let mod = Math.ceil((-th - Math.PI) * WebMolKit.INV_TWOPI);
            return th + mod * WebMolKit.TWOPI;
        }
        if (th > Math.PI) {
            let mod = Math.ceil((th - Math.PI) * WebMolKit.INV_TWOPI);
            return th - mod * WebMolKit.TWOPI;
        }
        return th;
    }
    WebMolKit.angleNorm = angleNorm;
    function angleDiff(th1, th2) {
        let theta = angleNorm(th1) - angleNorm(th2);
        return theta - (theta > Math.PI ? WebMolKit.TWOPI : 0) + (theta <= -Math.PI ? WebMolKit.TWOPI : 0);
    }
    WebMolKit.angleDiff = angleDiff;
    function angleDiffPos(th1, th2) {
        let theta = angleNorm(th1) - angleNorm(th2);
        return theta + (theta < 0 ? WebMolKit.TWOPI : 0);
    }
    WebMolKit.angleDiffPos = angleDiffPos;
    function sortAngles(theta) {
        if (theta == null || theta.length < 2)
            return theta;
        theta = theta.slice(0);
        for (let n = 0; n < theta.length; n++)
            theta[n] = angleNorm(theta[n]);
        WebMolKit.Vec.sort(theta);
        while (true) {
            let a = theta[theta.length - 1], b = theta[0], c = theta[1];
            if (angleDiff(b, a) <= angleDiff(c, b))
                break;
            for (let n = theta.length - 1; n > 0; n--)
                theta[n] = theta[n - 1];
            theta[0] = a;
        }
        return theta;
    }
    WebMolKit.sortAngles = sortAngles;
    function uniqueAngles(theta, threshold) {
        theta = sortAngles(theta);
        for (let n = 1; n < theta.length; n++) {
            if (Math.abs(angleDiff(theta[n], theta[n - 1])) <= threshold) {
                theta.splice(n, 1);
                n--;
            }
        }
        return theta;
    }
    WebMolKit.uniqueAngles = uniqueAngles;
    function minArray(a) {
        if (a == null || a.length == 0)
            return 0;
        let v = a[0];
        for (let n = 1; n < a.length; n++)
            v = Math.min(v, a[n]);
        return v;
    }
    WebMolKit.minArray = minArray;
    function maxArray(a) {
        if (a == null || a.length == 0)
            return 0;
        let v = a[0];
        for (let n = 1; n < a.length; n++)
            v = Math.max(v, a[n]);
        return v;
    }
    WebMolKit.maxArray = maxArray;
    function findNode(parent, name) {
        if (parent == null)
            return null;
        let node = parent.firstChild;
        while (node) {
            if (node.nodeName == name)
                return node;
            node = node.nextSibling;
        }
        return null;
    }
    WebMolKit.findNode = findNode;
    function findNodes(parent, name) {
        if (parent == null)
            return null;
        let node = parent.firstChild;
        let list = [];
        while (node) {
            if (node.nodeName == name)
                list.push(node);
            node = node.nextSibling;
        }
        return list;
    }
    WebMolKit.findNodes = findNodes;
    function pathRoundedRect(x1, y1, x2, y2, rad) {
        let path = new Path2D();
        path.moveTo(x2 - rad, y1);
        path.quadraticCurveTo(x2, y1, x2, y1 + rad);
        path.lineTo(x2, y2 - rad);
        path.quadraticCurveTo(x2, y2, x2 - rad, y2);
        path.lineTo(x1 + rad, y2);
        path.quadraticCurveTo(x1, y2, x1, y2 - rad);
        path.lineTo(x1, y1 + rad);
        path.quadraticCurveTo(x1, y1, x1 + rad, y1);
        path.closePath();
        return path;
    }
    WebMolKit.pathRoundedRect = pathRoundedRect;
    function drawLine(ctx, x1, y1, x2, y2) {
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
    }
    WebMolKit.drawLine = drawLine;
    WebMolKit.ASCENT_FUDGE = 1.4;
    function fontSansSerif(ascent) { return `${ascent * WebMolKit.ASCENT_FUDGE}px sans-serif`; }
    WebMolKit.fontSansSerif = fontSansSerif;
    function pixelDensity() {
        if ('devicePixelRatio' in window && window.devicePixelRatio > 1)
            return window.devicePixelRatio;
        return 1;
    }
    WebMolKit.pixelDensity = pixelDensity;
    function clone(data) {
        if (data == null)
            return null;
        if (Array.isArray(data))
            return data.slice(0);
        if (typeof data != 'object')
            return data;
        let result = {};
        for (let key in data)
            result[key] = data[key];
        return result;
    }
    WebMolKit.clone = clone;
    function deepClone(data) {
        if (data == null)
            return null;
        if (typeof data == 'function')
            return null;
        if (typeof data != 'object')
            return data;
        let result = Array.isArray(data) ? [] : {};
        for (let key in data) {
            let val = data[key];
            result[key] = typeof val === 'object' ? deepClone(val) : val;
        }
        return result;
    }
    WebMolKit.deepClone = deepClone;
    function escapeHTML(text) {
        if (!text)
            return '';
        const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
        return text.replace(/[&<>"']/g, (m) => map[m]);
    }
    WebMolKit.escapeHTML = escapeHTML;
    function orBlank(str) { return str == null ? '' : str; }
    WebMolKit.orBlank = orBlank;
    function dictValues(dict) {
        let list = [];
        for (let key in dict)
            list.push(dict[key]);
        return list;
    }
    WebMolKit.dictValues = dictValues;
    function zip(u, v) {
        return u.map((a, i) => [a, v[i]]);
    }
    WebMolKit.zip = zip;
    function toUTF8(str) {
        let data = [], stripe = '';
        const sz = str.length;
        for (let n = 0; n < sz; n++) {
            let charcode = str.charCodeAt(n);
            if (charcode < 0x80)
                stripe += str.charAt(n);
            else if (charcode < 0x800) {
                stripe += String.fromCharCode(0xc0 | (charcode >> 6));
                stripe += String.fromCharCode(0x80 | (charcode & 0x3F));
            }
            else if (charcode < 0xd800 || charcode >= 0xe000) {
                stripe += String.fromCharCode(0xe0 | (charcode >> 12));
                stripe += String.fromCharCode(0x80 | ((charcode >> 6) & 0x3F));
                stripe += String.fromCharCode(0x80 | (charcode & 0x3F));
            }
            else {
                n++;
                charcode = 0x10000 + (((charcode & 0x3FF) << 10) | (str.charCodeAt(n) & 0x3FF));
                stripe += String.fromCharCode(0xf0 | (charcode >> 18));
                stripe += String.fromCharCode(0x80 | ((charcode >> 12) & 0x3F));
                stripe += String.fromCharCode(0x80 | ((charcode >> 6) & 0x3F));
                stripe += String.fromCharCode(0x80 | (charcode & 0x3F));
            }
            if (stripe.length > 100) {
                data.push(stripe);
                stripe = '';
            }
        }
        data.push(stripe);
        return data.join('');
    }
    WebMolKit.toUTF8 = toUTF8;
    function fromUTF8(str) {
        let data = [], stripe = '';
        const sz = str.length;
        for (let n = 0; n < sz; n++) {
            let value = str.charCodeAt(n);
            if (value < 0x80)
                stripe += str.charAt(n);
            else if (value > 0xBF && value < 0xE0) {
                stripe += String.fromCharCode((value & 0x1F) << 6 | str.charCodeAt(n + 1) & 0x3F);
                n++;
            }
            else if (value > 0xDF && value < 0xF0) {
                str += String.fromCharCode((value & 0x0F) << 12 | (str.charCodeAt(n + 1) & 0x3F) << 6 | str.charCodeAt(n + 2) & 0x3F);
                n += 2;
            }
            else {
                let charCode = ((value & 0x07) << 18 | (str.charCodeAt(n + 1) & 0x3F) << 12 | (str.charCodeAt(n + 2) & 0x3F) << 6 | str.charCodeAt(n + 3) & 0x3F) - 0x010000;
                stripe += String.fromCharCode(charCode >> 10 | 0xD800, charCode & 0x03FF | 0xDC00);
                n += 3;
            }
            if (stripe.length > 100) {
                data.push(stripe);
                stripe = '';
            }
        }
        data.push(stripe);
        return data.join('');
    }
    WebMolKit.fromUTF8 = fromUTF8;
    function jsonPrettyPrint(json) {
        let lines = JSON.stringify(json, null, 1).split(/\n/);
        for (let n = 0; n < lines.length; n++) {
            lines[n] = lines[n].trim();
            if (lines[n].length > 1 && (lines[n].endsWith('{') || lines[n].endsWith('['))) {
                let ch = lines[n].charAt(lines[n].length - 1);
                lines[n] = lines[n].substring(0, lines[n].length - 1);
                lines.splice(n + 1, 0, ch);
                n--;
            }
        }
        let indent = 0;
        for (let n = 0; n < lines.length; n++) {
            let orig = lines[n];
            if (orig == ']' || orig == '}' || orig == '],' || orig == '},')
                indent--;
            lines[n] = '\t'.repeat(indent) + orig;
            if (orig == '[' || orig == '{')
                indent++;
        }
        return lines.join('\n');
    }
    WebMolKit.jsonPrettyPrint = jsonPrettyPrint;
    let KeyCode;
    (function (KeyCode) {
        KeyCode["Backspace"] = "Backspace";
        KeyCode["Tab"] = "Tab";
        KeyCode["Enter"] = "Enter";
        KeyCode["Escape"] = "Escape";
        KeyCode["Space"] = " ";
        KeyCode["PageUp"] = "PageUp";
        KeyCode["PageDown"] = "PageDown";
        KeyCode["End"] = "End";
        KeyCode["Home"] = "Home";
        KeyCode["Left"] = "ArrowLeft";
        KeyCode["Right"] = "ArrowRight";
        KeyCode["Up"] = "ArrowUp";
        KeyCode["Down"] = "ArrowDown";
        KeyCode["Delete"] = "Delete";
        KeyCode["Insert"] = "Insert";
    })(KeyCode = WebMolKit.KeyCode || (WebMolKit.KeyCode = {}));
    function readTextURL(url) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                let request = new XMLHttpRequest();
                request.open('GET', url.toString(), true);
                request.responseType = 'text';
                request.onload = () => resolve(request.response.toString());
                request.onerror = () => resolve(null);
                request.send();
            });
        });
    }
    WebMolKit.readTextURL = readTextURL;
    function yieldDOM() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => setTimeout(() => resolve()));
        });
    }
    WebMolKit.yieldDOM = yieldDOM;
    let staticScrollerSize = null;
    function empiricalScrollerSize() {
        if (staticScrollerSize)
            return staticScrollerSize;
        let outer = WebMolKit.dom('<div/>').css({ 'visibility': 'hidden', 'width': '100px', 'height': '100px', 'overflow': 'scroll' }).appendTo(WebMolKit.dom(document.body));
        let inner = WebMolKit.dom('<div/>').css({ 'width': '100%', 'height': '100%' }).appendTo(outer);
        staticScrollerSize = new WebMolKit.Size(100 - inner.elHTML.offsetWidth, 100 - inner.elHTML.offsetHeight);
        outer.remove();
        return staticScrollerSize;
    }
    WebMolKit.empiricalScrollerSize = empiricalScrollerSize;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let QueryTypeAtom;
    (function (QueryTypeAtom) {
        QueryTypeAtom["Charges"] = "qC:";
        QueryTypeAtom["Aromatic"] = "qA:";
        QueryTypeAtom["Elements"] = "qE:";
        QueryTypeAtom["ElementsNot"] = "qE!";
        QueryTypeAtom["RingSizes"] = "qR:";
        QueryTypeAtom["RingSizesNot"] = "qR!";
        QueryTypeAtom["RingBlock"] = "qB:";
        QueryTypeAtom["NumRings"] = "qN:";
        QueryTypeAtom["Adjacency"] = "qJ:";
        QueryTypeAtom["BondSums"] = "qO:";
        QueryTypeAtom["Valences"] = "qV:";
        QueryTypeAtom["Hydrogens"] = "qH:";
        QueryTypeAtom["Isotopes"] = "qI:";
        QueryTypeAtom["SubFrags"] = "qX:";
        QueryTypeAtom["SubFragsNot"] = "qX!";
    })(QueryTypeAtom = WebMolKit.QueryTypeAtom || (WebMolKit.QueryTypeAtom = {}));
    let QueryTypeBond;
    (function (QueryTypeBond) {
        QueryTypeBond["RingSizes"] = "qR:";
        QueryTypeBond["RingSizesNot"] = "qR!";
        QueryTypeBond["RingBlock"] = "qB:";
        QueryTypeBond["NumRings"] = "qN:";
        QueryTypeBond["Orders"] = "qO:";
    })(QueryTypeBond = WebMolKit.QueryTypeBond || (WebMolKit.QueryTypeBond = {}));
    class QueryUtil {
        static hasAnyQueryAtom(mol, atom) {
            let extra = mol.atomExtra(atom);
            for (let n = extra.length - 1; n >= 0; n--)
                if (extra[n].startsWith('q'))
                    return true;
            return false;
        }
        static hasAnyQueryBond(mol, bond) {
            let extra = mol.bondExtra(bond);
            for (let n = extra.length - 1; n >= 0; n--)
                if (extra[n].startsWith('q'))
                    return true;
            return false;
        }
        static hasQueryAtom(mol, atom, type) {
            let extra = mol.atomExtra(atom);
            for (let n = extra.length - 1; n >= 0; n--)
                if (extra[n].startsWith(type))
                    return true;
            return false;
        }
        static hasQueryBond(mol, bond, type) {
            let extra = mol.bondExtra(bond);
            for (let n = extra.length - 1; n >= 0; n--)
                if (extra[n].startsWith(type))
                    return true;
            return false;
        }
        static deleteQueryAtom(mol, atom, type) {
            let extra = mol.atomExtra(atom);
            let modified = false;
            for (let n = extra.length - 1; n >= 0; n--)
                if (extra[n].startsWith(type)) {
                    extra.splice(n, 1);
                    modified = true;
                }
            if (modified)
                mol.setAtomExtra(atom, extra);
        }
        static deleteQueryBond(mol, bond, type) {
            let extra = mol.bondExtra(bond);
            let modified = false;
            for (let n = extra.length - 1; n >= 0; n--)
                if (extra[n].startsWith(type)) {
                    extra.splice(n, 1);
                    modified = true;
                }
            if (modified)
                mol.setBondExtra(bond, extra);
        }
        static deleteQueryAtomAll(mol, atom) {
            mol.setAtomExtra(atom, mol.atomExtra(atom).filter((xtra) => !xtra.startsWith('q')));
        }
        static deleteQueryBondAll(mol, bond) {
            mol.setBondExtra(bond, mol.bondExtra(bond).filter((xtra) => !xtra.startsWith('q')));
        }
        static queryAtomString(mol, atom, type) {
            let extra = mol.atomExtra(atom);
            for (let n = extra.length - 1; n >= 0; n--)
                if (extra[n].startsWith(type))
                    return extra[n].substring(type.length);
            return null;
        }
        static queryAtomStringList(mol, atom, type) {
            let extra = mol.atomExtra(atom), list = null;
            if (extra != null)
                for (let str of extra)
                    if (str.startsWith(type))
                        list = WebMolKit.Vec.append(list, str.substring(type.length));
            return list;
        }
        static queryBondString(mol, bond, type) {
            let extra = mol.bondExtra(bond);
            for (let n = extra.length - 1; n >= 0; n--)
                if (extra[n].startsWith(type))
                    return extra[n].substring(type.length);
            return null;
        }
        static setQueryAtom(mol, atom, type, str) {
            if (!str) {
                this.deleteQueryAtom(mol, atom, type);
                return;
            }
            let value = type + str;
            let extra = mol.atomExtra(atom);
            for (let n = extra.length - 1; n >= 0; n--) {
                if (extra[n].startsWith(type)) {
                    if (value != null) {
                        extra[n] = value;
                        value = null;
                    }
                    else
                        extra.splice(n, 1);
                }
            }
            if (value != null)
                extra.push(value);
            mol.setAtomExtra(atom, extra);
        }
        static setQueryAtomList(mol, atom, type, list) {
            if (WebMolKit.Vec.isBlank(list)) {
                this.deleteQueryAtom(mol, atom, type);
                return;
            }
            let extra = mol.atomExtra(atom);
            for (let n = extra.length - 1; n >= 0; n--)
                if (extra[n].startsWith(type))
                    extra.splice(n, 1);
            for (let str of list)
                extra.push(type + str);
            mol.setAtomExtra(atom, extra);
        }
        static setQueryBond(mol, bond, type, str) {
            if (!str) {
                this.deleteQueryBond(mol, bond, type);
                return;
            }
            let value = type + str;
            let extra = mol.bondExtra(bond);
            for (let n = extra.length - 1; n >= 0; n--) {
                if (extra[n].startsWith(type)) {
                    if (value != null) {
                        extra[n] = value;
                        value = null;
                    }
                    else
                        extra.splice(n, 1);
                }
            }
            if (value != null)
                extra.push(value);
            mol.setBondExtra(bond, extra);
        }
        static queryAtomCharges(mol, atom) { return this.parseIntegers(this.queryAtomString(mol, atom, QueryTypeAtom.Charges)); }
        static queryAtomAromatic(mol, atom) { return this.parseBoolean(this.queryAtomString(mol, atom, QueryTypeAtom.Aromatic)); }
        static queryAtomElements(mol, atom) { return this.parseStrings(this.queryAtomString(mol, atom, QueryTypeAtom.Elements)); }
        static queryAtomElementsNot(mol, atom) { return this.parseStrings(this.queryAtomString(mol, atom, QueryTypeAtom.ElementsNot)); }
        static queryAtomRingSizes(mol, atom) { return this.parseIntegers(this.queryAtomString(mol, atom, QueryTypeAtom.RingSizes)); }
        static queryAtomRingSizesNot(mol, atom) { return this.parseIntegers(this.queryAtomString(mol, atom, QueryTypeAtom.RingSizesNot)); }
        static queryAtomRingBlock(mol, atom) { return this.parseBoolean(this.queryAtomString(mol, atom, QueryTypeAtom.RingBlock)); }
        static queryAtomNumRings(mol, atom) { return this.parseIntegers(this.queryAtomString(mol, atom, QueryTypeAtom.NumRings)); }
        static queryAtomAdjacency(mol, atom) { return this.parseIntegers(this.queryAtomString(mol, atom, QueryTypeAtom.Adjacency)); }
        static queryAtomBondSums(mol, atom) { return this.parseIntegers(this.queryAtomString(mol, atom, QueryTypeAtom.BondSums)); }
        static queryAtomValences(mol, atom) { return this.parseIntegers(this.queryAtomString(mol, atom, QueryTypeAtom.Valences)); }
        static queryAtomHydrogens(mol, atom) { return this.parseIntegers(this.queryAtomString(mol, atom, QueryTypeAtom.Hydrogens)); }
        static queryAtomIsotope(mol, atom) { return this.parseIntegers(this.queryAtomString(mol, atom, QueryTypeAtom.Isotopes)); }
        static queryAtomSubFrags(mol, atom) { return this.parseMolecules(this.queryAtomStringList(mol, atom, QueryTypeAtom.SubFrags)); }
        static queryAtomSubFragsNot(mol, atom) { return this.parseMolecules(this.queryAtomStringList(mol, atom, QueryTypeAtom.SubFragsNot)); }
        static queryBondRingSizes(mol, bond) { return this.parseIntegers(this.queryBondString(mol, bond, QueryTypeBond.RingSizes)); }
        static queryBondRingSizesNot(mol, bond) { return this.parseIntegers(this.queryBondString(mol, bond, QueryTypeBond.RingSizesNot)); }
        static queryBondRingBlock(mol, bond) { return this.parseBoolean(this.queryBondString(mol, bond, QueryTypeBond.RingBlock)); }
        static queryBondNumRings(mol, bond) { return this.parseIntegers(this.queryBondString(mol, bond, QueryTypeBond.NumRings)); }
        static queryBondOrders(mol, bond) { return this.parseIntegers(this.queryBondString(mol, bond, QueryTypeBond.Orders)); }
        static setQueryAtomCharges(mol, atom, value) { this.setQueryAtom(mol, atom, QueryTypeAtom.Charges, this.formatIntegers(value)); }
        static setQueryAtomAromatic(mol, atom, value) { this.setQueryAtom(mol, atom, QueryTypeAtom.Aromatic, this.formatBoolean(value)); }
        static setQueryAtomElements(mol, atom, value) { this.setQueryAtom(mol, atom, QueryTypeAtom.Elements, this.formatStrings(value)); }
        static setQueryAtomElementsNot(mol, atom, value) { this.setQueryAtom(mol, atom, QueryTypeAtom.ElementsNot, this.formatStrings(value)); }
        static setQueryAtomRingSizes(mol, atom, value) { this.setQueryAtom(mol, atom, QueryTypeAtom.RingSizes, this.formatIntegers(value)); }
        static setQueryAtomRingSizesNot(mol, atom, value) { this.setQueryAtom(mol, atom, QueryTypeAtom.RingSizesNot, this.formatIntegers(value)); }
        static setQueryAtomRingBlock(mol, atom, value) { this.setQueryAtom(mol, atom, QueryTypeAtom.RingBlock, this.formatBoolean(value)); }
        static setQueryAtomNumRings(mol, atom, value) { this.setQueryAtom(mol, atom, QueryTypeAtom.NumRings, this.formatIntegers(value)); }
        static setQueryAtomAdjacency(mol, atom, value) { this.setQueryAtom(mol, atom, QueryTypeAtom.Adjacency, this.formatIntegers(value)); }
        static setQueryAtomBondSums(mol, atom, value) { this.setQueryAtom(mol, atom, QueryTypeAtom.BondSums, this.formatIntegers(value)); }
        static setQueryAtomValences(mol, atom, value) { this.setQueryAtom(mol, atom, QueryTypeAtom.Valences, this.formatIntegers(value)); }
        static setQueryAtomHydrogens(mol, atom, value) { this.setQueryAtom(mol, atom, QueryTypeAtom.Hydrogens, this.formatIntegers(value)); }
        static setQueryAtomIsotope(mol, atom, value) { this.setQueryAtom(mol, atom, QueryTypeAtom.Isotopes, this.formatIntegers(value)); }
        static setQueryAtomSubFrags(mol, atom, value) { this.setQueryAtomList(mol, atom, QueryTypeAtom.SubFrags, this.formatMolecules(value)); }
        static setQueryAtomSubFragsNot(mol, atom, value) { this.setQueryAtomList(mol, atom, QueryTypeAtom.SubFragsNot, this.formatMolecules(value)); }
        static setQueryBondRingSizes(mol, bond, value) { this.setQueryBond(mol, bond, QueryTypeBond.RingSizes, this.formatIntegers(value)); }
        static setQueryBondRingSizesNot(mol, bond, value) { this.setQueryBond(mol, bond, QueryTypeBond.RingSizesNot, this.formatIntegers(value)); }
        static setQueryBondRingBlock(mol, bond, value) { this.setQueryBond(mol, bond, QueryTypeBond.RingBlock, this.formatBoolean(value)); }
        static setQueryBondNumRings(mol, bond, value) { this.setQueryBond(mol, bond, QueryTypeBond.NumRings, this.formatIntegers(value)); }
        static setQueryBondOrders(mol, bond, value) { this.setQueryBond(mol, bond, QueryTypeBond.Orders, this.formatIntegers(value)); }
        static parseIntegers(str) {
            if (!str)
                return null;
            let strlist = str.split(',');
            let intlist = new Array(strlist.length);
            for (let n = 0; n < strlist.length; n++)
                intlist[n] = parseInt(strlist[n]);
            return intlist;
        }
        static parseStrings(str) {
            if (!str)
                return null;
            return str.split(',');
        }
        static parseBoolean(str) {
            return !str ? null : str == 'yes';
        }
        static parseMolecules(list) {
            if (!list)
                return null;
            let mols = [];
            for (let molstr of list) {
                let mol = WebMolKit.Molecule.fromString(molstr);
                if (WebMolKit.MolUtil.notBlank(mol))
                    mols.push(mol);
            }
            return mols;
        }
        static formatIntegers(list) {
            if (WebMolKit.Vec.isBlank(list))
                return null;
            let str = '';
            for (let n = 0; n < list.length; n++) {
                if (n > 0)
                    str += ',';
                str += list[n];
            }
            return str;
        }
        static formatStrings(list) {
            if (WebMolKit.Vec.isBlank(list))
                return null;
            let str = '';
            for (let n = 0; n < list.length; n++) {
                if (n > 0)
                    str += ',';
                str += list[n];
            }
            return str;
        }
        static formatBoolean(value) {
            return value ? 'yes' : 'no';
        }
        static formatMolecules(mols) {
            if (WebMolKit.Vec.isBlank(mols))
                return null;
            let list = [];
            for (let mol of mols)
                if (WebMolKit.MolUtil.notBlank(mol))
                    list.push(mol.toString());
            return list;
        }
    }
    WebMolKit.QueryUtil = QueryUtil;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let Geometry;
    (function (Geometry) {
        Geometry[Geometry["Linear"] = 0] = "Linear";
        Geometry[Geometry["Bent"] = 1] = "Bent";
        Geometry[Geometry["Trigonal"] = 2] = "Trigonal";
        Geometry[Geometry["Tetra1"] = 3] = "Tetra1";
        Geometry[Geometry["Tetra2"] = 4] = "Tetra2";
        Geometry[Geometry["SqPlan"] = 5] = "SqPlan";
        Geometry[Geometry["BasePyram"] = 6] = "BasePyram";
        Geometry[Geometry["TrigBip"] = 7] = "TrigBip";
        Geometry[Geometry["Octa1"] = 8] = "Octa1";
        Geometry[Geometry["Octa2"] = 9] = "Octa2";
    })(Geometry = WebMolKit.Geometry || (WebMolKit.Geometry = {}));
    class SketchUtil {
        static placeNewAtom(mol, el) {
            let box = mol.boundary();
            let x = box.maxX() + WebMolKit.Molecule.IDEALBOND, y = box.maxY();
            return mol.addAtom(el, x, y);
        }
        static placeNewFragment(mol, frag) {
            if (frag.numAtoms == 0)
                return;
            let dirX = [1, 0, -1, 1, -1, 1, 0, -1], dirY = [1, 1, 1, 0, 0, -1, -1, -1];
            let dx = WebMolKit.Vec.numberArray(0, 8), dy = WebMolKit.Vec.numberArray(0, 8), score = WebMolKit.Vec.numberArray(0, 8);
            let mbox = mol.boundary(), fbox = frag.boundary();
            for (let n = 0; n < 8; n++) {
                let vx = dirX[n], vy = dirY[n];
                if (n == 0 || n == 3 || n == 5)
                    dx[n] = mbox.minX() - fbox.maxX();
                else if (n == 2 || n == 4 || n == 7)
                    dx[n] = mbox.maxX() - fbox.minX();
                else
                    dx[n] = 0.5 * (mbox.minX() + mbox.maxX() - fbox.minX() - fbox.maxX());
                if (n == 5 || n == 6 || n == 7)
                    dy[n] = mbox.minY() - fbox.maxY();
                else if (n == 0 || n == 1 || n == 2)
                    dy[n] = mbox.maxY() - fbox.minY();
                else
                    dy[n] = 0.5 * (mbox.minY() + mbox.maxY() - fbox.minY() - fbox.maxY());
                dx[n] -= vx;
                dy[n] -= vy;
                score[n] = SketchUtil.fragPosScore(mol, frag, dx[n], dy[n]);
                vx *= 0.25;
                vy *= 0.25;
                for (let iter = 100; iter > 0; iter--) {
                    let iscore = SketchUtil.fragPosScore(mol, frag, dx[n] + vx, dy[n] + vy);
                    if (iscore <= score[n])
                        break;
                    score[n] = iscore;
                    dx[n] += vx;
                    dy[n] += vy;
                }
                for (let iter = 100; iter > 0; iter--)
                    for (let d = 0; d < 8; d++) {
                        vx = dirX[d] * 0.1;
                        vy = dirY[d] * 0.1;
                        let iscore = SketchUtil.fragPosScore(mol, frag, dx[n] + vx, dy[n] + vy);
                        if (iscore <= score[n])
                            break;
                        score[n] = iscore;
                        dx[n] += vx;
                        dy[n] += vy;
                    }
            }
            let best = 0;
            for (let n = 1; n < 8; n++)
                if (score[n] > score[best])
                    best = n;
            frag = frag.clone();
            for (let n = 1; n <= frag.numAtoms; n++)
                frag.setAtomPos(n, frag.atomX(n) + dx[best], frag.atomY(n) + dy[best]);
            mol.append(frag);
        }
        static fragPosScore(mol, frag, dx, dy) {
            let score = 0;
            for (let i = 1; i <= mol.numAtoms; i++)
                for (let j = 1; j <= frag.numAtoms; j++) {
                    let ox = frag.atomX(j) + dx - mol.atomX(i), oy = frag.atomY(j) + dy - mol.atomY(i);
                    let dist2 = ox * ox + oy * oy;
                    if (dist2 < 1)
                        return 0;
                    score += 1 / dist2;
                }
            let mbox = mol.boundary(), fbox = frag.boundary();
            let minX = Math.min(fbox.minX() + dx, mbox.minX()), maxX = Math.max(fbox.maxX() + dx, mbox.maxX());
            let minY = Math.min(fbox.minY() + dy, mbox.minY()), maxY = Math.max(fbox.maxY() + dy, mbox.maxY());
            let rangeX = Math.max(1, maxX - minX), rangeY = Math.max(1, maxY - minY);
            let ratio = Math.max(rangeX / rangeY, rangeY / rangeX);
            return score / ratio;
        }
        static mergeOverlappingAtoms(mol) {
            return SketchUtil.mergeFragmentsDiv(mol, 0);
        }
        static mergeFragmentsDiv(mol, div) {
            const na = mol.numAtoms;
            let omask = WebMolKit.CoordUtil.overlappingAtomMask(mol);
            let chopmask = WebMolKit.Vec.booleanArray(false, na);
            let mx = WebMolKit.MolUtil.arrayAtomX(mol), my = WebMolKit.MolUtil.arrayAtomY(mol);
            let remap = [];
            for (let n = 0; n < na; n++)
                remap.push(n + 1);
            let div1 = div, div2 = div + 1;
            if (div == 0)
                div1 = na;
            for (let i = 1; i <= div1; i++)
                if (omask[i - 1] && !chopmask[i - 1]) {
                    if (div == 0)
                        div2 = i + 1;
                    for (let j = div2; j <= na; j++)
                        if (omask[j - 1] && !chopmask[j - 1]) {
                            if (WebMolKit.norm2_xy(mx[i - 1] - mx[j - 1], my[i - 1] - my[j - 1]) > WebMolKit.CoordUtil.OVERLAP_THRESHOLD_SQ)
                                continue;
                            let oldN = j, newN = i;
                            let exotic = [0, 0];
                            for (let k = 0; k < 2; k++) {
                                let a = k == 0 ? i : j;
                                exotic[k] = (mol.atomElement(a) == 'C' ? 0 : 1)
                                    + (mol.atomElement(a) == 'X' ? -100 : 0)
                                    + (mol.atomCharge(a) != 0 ? 1 : 0)
                                    + (mol.atomUnpaired(a) != 0 ? 1 : 0)
                                    + (mol.atomIsotope(a) != WebMolKit.Molecule.ISOTOPE_NATURAL ? 1 : 0)
                                    + (mol.atomHExplicit(a) != WebMolKit.Molecule.HEXPLICIT_UNKNOWN ? 1 : 0)
                                    + (WebMolKit.MolUtil.hasAbbrev(mol, a) ? 1000 : 0);
                            }
                            if (exotic[1] > exotic[0]) {
                                oldN = i;
                                newN = j;
                            }
                            for (let n = 1; n <= mol.numBonds; n++) {
                                if (mol.bondFrom(n) == oldN)
                                    mol.setBondFrom(n, newN);
                                if (mol.bondTo(n) == oldN)
                                    mol.setBondTo(n, newN);
                            }
                            chopmask[oldN - 1] = true;
                            remap[oldN - 1] = newN;
                        }
                }
            for (let n = na; n >= 1; n--)
                if (chopmask[n - 1]) {
                    if (n <= div)
                        div--;
                    mol.deleteAtomAndBonds(n);
                    for (let i = 0; i < na; i++)
                        if (remap[i] > n)
                            remap[i]--;
                }
            for (let n = mol.numAtoms; n > div; n--)
                if (mol.atomElement(n) == 'X') {
                    mol.deleteAtomAndBonds(n);
                    for (let i = 0; i < na; i++)
                        if (remap[i] > n)
                            remap[i]--;
                }
            WebMolKit.MolUtil.removeDuplicateBonds(mol);
            return remap;
        }
        static mergeFragmentsMask(mol, mask) {
            let chopmask = WebMolKit.Vec.booleanArray(false, mol.numAtoms);
            let na = mol.numAtoms;
            let mx = WebMolKit.MolUtil.arrayAtomX(mol), my = WebMolKit.MolUtil.arrayAtomY(mol);
            for (let i = 1; i <= na; i++)
                if (mask[i - 1])
                    for (let j = 1; j <= na; j++)
                        if (!mask[j - 1] && !chopmask[j - 1])
                            if (WebMolKit.norm2_xy(mx[i - 1] - mx[j - 1], my[i - 1] - my[j - 1]) < WebMolKit.CoordUtil.OVERLAP_THRESHOLD_SQ) {
                                let oldN = j, newN = i;
                                if (mol.atomElement(i) == 'C' && mol.atomElement(j) != 'C' && mol.atomElement(j) != 'X')
                                    [oldN, newN] = [i, j];
                                if (mol.atomHExplicit(newN) == WebMolKit.Molecule.HEXPLICIT_UNKNOWN)
                                    mol.setAtomHExplicit(newN, mol.atomHExplicit(oldN));
                                mol.setAtomUnpaired(newN, mol.atomUnpaired(newN) + mol.atomUnpaired(oldN));
                                mol.setAtomCharge(newN, mol.atomCharge(newN) + mol.atomCharge(oldN));
                                mol.setAtomExtra(newN, WebMolKit.Vec.concat(mol.atomExtra(oldN), mol.atomExtra(newN)));
                                for (let n = 1; n <= mol.numBonds; n++) {
                                    if (mol.bondFrom(n) == oldN)
                                        mol.setBondFrom(n, newN);
                                    if (mol.bondTo(n) == oldN)
                                        mol.setBondTo(n, newN);
                                }
                                chopmask[oldN - 1] = true;
                            }
            for (let n = chopmask.length; n >= 1; n--)
                if (chopmask[n - 1])
                    mol.deleteAtomAndBonds(n);
            WebMolKit.MolUtil.removeDuplicateBonds(mol);
        }
        static matchAngleGeometry(geom, theta) {
            if (theta.length <= 1)
                return true;
            let match = SketchUtil.GEOM_ANGLES[geom], mtheta = WebMolKit.Vec.numberArray(0, theta.length);
            let hit = WebMolKit.Vec.booleanArray(false, match.length);
            for (let n = 0; n < theta.length; n++)
                for (let s = 1; s >= -1; s -= 2) {
                    for (let i = 0; i < theta.length; i++)
                        mtheta[i] = (theta[i] - theta[0]) * s;
                    WebMolKit.Vec.setTo(hit, false);
                    let gotall = true;
                    for (let i = 0; i < mtheta.length; i++) {
                        let got = false;
                        for (let j = 0; j < match.length; j++)
                            if (!hit[j] && Math.abs(WebMolKit.angleDiff(mtheta[i], match[j])) < 3 * WebMolKit.DEGRAD) {
                                hit[j] = true;
                                got = true;
                                break;
                            }
                        if (!got) {
                            gotall = false;
                            break;
                        }
                    }
                    if (gotall)
                        return true;
                }
            return false;
        }
        static primeDirections(mol, atom) {
            let angles = SketchUtil.calculateNewBondAngles(mol, atom, 1);
            let exits = SketchUtil.exitVectors(mol, atom);
            return WebMolKit.GeomUtil.uniqueAngles(angles.concat(exits), 2 * WebMolKit.DEGRAD);
        }
        static exitVectors(mol, atom) {
            let adj = mol.atomAdjList(atom), sz = adj.length;
            if (sz == 0)
                return [0, 90 * WebMolKit.DEGRAD, 180 * WebMolKit.DEGRAD, -90 * WebMolKit.DEGRAD];
            if (sz == 1)
                return [];
            let ret = [];
            let ang = WebMolKit.GeomUtil.sortAngles(WebMolKit.CoordUtil.atomBondAngles(mol, atom, adj));
            for (let n = 0; n < sz; n++) {
                let nn = n < sz - 1 ? n + 1 : 0;
                ret.push(WebMolKit.angleNorm(ang[n] + 0.5 * WebMolKit.angleDiffPos(ang[nn], ang[n])));
            }
            return ret;
        }
        static calculateNewBondAngles(mol, atom, order) {
            let adj = mol.atomAdjList(atom);
            const sz = adj.length;
            if (sz == 0) {
                let atno = mol.atomicNumber(atom), atblk = WebMolKit.Chemistry.ELEMENT_BLOCKS[atno];
                if (atblk <= 2)
                    return [0, 90 * WebMolKit.DEGRAD, 180 * WebMolKit.DEGRAD, -90 * WebMolKit.DEGRAD];
                else
                    return [90 * WebMolKit.DEGRAD, -90 * WebMolKit.DEGRAD, 30 * WebMolKit.DEGRAD, 150 * WebMolKit.DEGRAD, 210 * WebMolKit.DEGRAD, -30 * WebMolKit.DEGRAD, 180 * WebMolKit.DEGRAD, 0 * WebMolKit.DEGRAD];
            }
            let geom = SketchUtil.guessAtomGeometry(mol, atom, order);
            let ang = WebMolKit.CoordUtil.atomBondAngles(mol, atom, adj);
            for (let n = 0; n < geom.length; n++) {
                let ret = SketchUtil.mapAngleSubstituent(geom[n], ang);
                if (ret != null)
                    return ret;
            }
            return [];
        }
        static guessAtomGeometry(mol, atom, order) {
            let adj = mol.atomAdjList(atom);
            let sz = adj.length, atno = mol.atomicNumber(atom);
            let atblk = WebMolKit.Chemistry.ELEMENT_BLOCKS[atno], elrow = WebMolKit.Chemistry.ELEMENT_ROWS[atno];
            let el = mol.atomElement(atom);
            let adjBO = [], adjAN = [], pri = [];
            let allSingle = true;
            for (let n = 0; n < sz; n++) {
                adjBO.push(mol.bondOrder(mol.findBond(atom, adj[n])));
                adjAN.push(mol.atomicNumber(adj[n]));
                pri.push(adjBO[n] * 200 + adjAN[n]);
                if (adjBO[n] != 1)
                    allSingle = true;
            }
            for (let p = 0; p < sz - 1;) {
                if (pri[p] > pri[p + 1]) {
                    WebMolKit.Vec.swap(adj, p, p + 1);
                    WebMolKit.Vec.swap(adjBO, p, p + 1);
                    WebMolKit.Vec.swap(adjAN, p, p + 1);
                    WebMolKit.Vec.swap(pri, p, p + 1);
                    if (p > 0)
                        p--;
                }
                else
                    p++;
            }
            let ang = WebMolKit.CoordUtil.atomBondAngles(mol, atom, adj);
            if (sz == 1) {
                if (el == 'C' || el == 'N') {
                    if (adjBO[0] == 2 && order == 2)
                        return [Geometry.Linear];
                    if ((adjBO[0] == 3 && order == 1) || (adjBO[0] == 1 && order == 3))
                        return [Geometry.Linear];
                }
                if (atblk > 2)
                    return [Geometry.Octa1, Geometry.Octa2];
                if (order != 0 && (el == 'C' || el == 'N' || el == 'O'))
                    return [Geometry.Trigonal];
                return [Geometry.Trigonal, Geometry.Linear];
            }
            if (sz == 2 && Math.abs(WebMolKit.angleDiff(ang[0], ang[1])) >= 175 * WebMolKit.DEGRAD) {
                if (atblk <= 2)
                    return [Geometry.SqPlan];
                else
                    return [Geometry.Octa1, Geometry.Octa2];
            }
            let geom = [];
            if (atblk == 0)
                geom = [Geometry.Trigonal, Geometry.SqPlan];
            else if (atblk == 1)
                geom = [Geometry.Trigonal, Geometry.SqPlan, Geometry.Octa1, Geometry.Octa2];
            else if (atblk == 2) {
                geom.push(Geometry.Trigonal);
                if (el == 'C' && allSingle) {
                    geom.push(Geometry.Tetra1);
                    geom.push(Geometry.Tetra2);
                    geom.push(Geometry.SqPlan);
                }
                else if (el == 'C' && !allSingle) {
                }
                else if (elrow <= 3) {
                    geom.push(Geometry.Tetra1);
                    geom.push(Geometry.Tetra2);
                    geom.push(Geometry.SqPlan);
                }
                else {
                    geom.push(Geometry.Tetra1);
                    geom.push(Geometry.Tetra2);
                    geom.push(Geometry.SqPlan);
                    geom.push(Geometry.Octa1);
                    geom.push(Geometry.Octa2);
                }
            }
            else {
                geom.push(Geometry.Octa1);
                geom.push(Geometry.Octa2);
            }
            for (let n = geom.length - 1; n >= 0; n--) {
                if (!SketchUtil.matchAngleGeometry(geom[n], ang))
                    geom.splice(n, 1);
            }
            return geom;
        }
        static mapAngleSubstituent(geom, ang) {
            let gtheta = SketchUtil.GEOM_ANGLES[geom];
            const asz = ang.length, gsz = gtheta.length;
            if (asz >= gsz)
                return null;
            if (asz == 0)
                return gtheta.slice(0);
            let vac = [];
            for (let n = 0; n < asz; n++)
                for (let k = 0; k < gsz; k++)
                    for (let s = 1; s >= -1; s -= 2) {
                        let gang = [];
                        for (let i = 0; i < gsz; i++)
                            gang.push(WebMolKit.angleNorm(ang[n] + s * (gtheta[i] - gtheta[k])));
                        let mask = WebMolKit.Vec.booleanArray(false, gsz);
                        let mcount = 0;
                        for (let i = 0; i < gsz; i++)
                            if (!mask[i])
                                for (let j = 0; j < asz; j++)
                                    if (Math.abs(WebMolKit.angleDiff(gang[i], ang[j])) < 3 * WebMolKit.DEGRAD) {
                                        mask[i] = true;
                                        mcount++;
                                        break;
                                    }
                        if (mcount != asz)
                            continue;
                        for (let i = 0; i < gsz; i++)
                            if (!mask[i])
                                vac.push(gang[i]);
                    }
            if (vac.length == 0)
                return null;
            vac = WebMolKit.GeomUtil.sortAngles(vac);
            for (let n = 0; n < vac.length - 1; n++) {
                let th1 = vac[n], th2 = vac[n + 1], dth = WebMolKit.angleDiff(th2, th1);
                if (Math.abs(dth) < 5 * WebMolKit.DEGRAD) {
                    vac[n] = th1 + 0.5 * dth;
                    vac.splice(n + 1, 1);
                    n--;
                }
            }
            return vac;
        }
        static refitAtomGeometry(mol, atom, geom) {
            let gtheta = SketchUtil.GEOM_ANGLES[geom];
            let gsz = gtheta.length;
            let adj = mol.atomAdjList(atom);
            let asz = adj.length;
            if (asz <= 1 || asz > gsz)
                return null;
            let ang = WebMolKit.CoordUtil.atomBondAngles(mol, atom, adj);
            let inRing = WebMolKit.Vec.booleanArray(false, asz);
            let allInRing = true;
            for (let n = 0; n < asz; n++) {
                inRing[n] = mol.bondInRing(mol.findBond(atom, adj[n]));
                if (!inRing[n])
                    allInRing = false;
            }
            if (allInRing)
                return null;
            let bestAng = null;
            let bestScore = 0;
            let ww = WebMolKit.MolUtil.calculateWalkWeight(mol, atom);
            for (let i = 0; i < gsz; i++)
                for (let j = 0; j < asz; j++)
                    for (let s = 1; s >= -1; s -= 2) {
                        let newAng = WebMolKit.Vec.numberArray(0, asz);
                        let mask = WebMolKit.Vec.booleanArray(false, gsz);
                        for (let n1 = 0; n1 < asz; n1++) {
                            let best = -1;
                            let bdiff = 0;
                            for (let n2 = 0; n2 < gsz; n2++)
                                if (!mask[n2]) {
                                    let th = WebMolKit.angleNorm(gtheta[n2] * s - gtheta[i] + ang[j]);
                                    let diff = Math.abs(WebMolKit.angleDiff(th, ang[n1]));
                                    if (best < 0 || diff < bdiff) {
                                        best = n2;
                                        bdiff = diff;
                                        newAng[n1] = th;
                                    }
                                }
                            mask[best] = true;
                        }
                        let ringClash = false;
                        for (let n = 0; n < asz; n++)
                            if (inRing[n] && Math.abs(WebMolKit.angleDiff(newAng[n], ang[n])) > 2 * WebMolKit.DEGRAD) {
                                ringClash = true;
                                break;
                            }
                        if (ringClash)
                            continue;
                        let score = 0;
                        for (let n = 0; n < asz; n++)
                            score += ww[adj[n] - 1] * Math.abs(WebMolKit.angleDiff(newAng[n], ang[n]));
                        if (bestAng == null || score < bestScore) {
                            bestAng = newAng;
                            bestScore = score;
                        }
                    }
            if (bestAng == null)
                return null;
            let same = true;
            for (let n = 0; n < asz; n++)
                if (Math.abs(WebMolKit.angleDiff(bestAng[n], ang[n])) > 2 * WebMolKit.DEGRAD) {
                    same = false;
                    break;
                }
            if (same)
                return null;
            mol = mol.clone();
            for (let n = 0; n < asz; n++)
                if (!inRing[n])
                    WebMolKit.CoordUtil.rotateBond(mol, atom, adj[n], bestAng[n] - ang[n]);
            return mol;
        }
        static switchAtomGeometry(mol, src, dst, geoms) {
            let bestAtom = 0;
            let bestAng = 0, bestX = 0, bestY = 0;
            let adj = mol.atomAdjList(src);
            let ang = WebMolKit.CoordUtil.atomBondAngles(mol, src, adj), theta = WebMolKit.Vec.numberArray(0, ang.length - 1);
            let cx = mol.atomX(src), cy = mol.atomY(src);
            for (let i = 0; i < dst.length; i++) {
                let a = adj.indexOf(dst[i]);
                let curth = ang[a];
                for (let n = 0, p = 0; n < adj.length; n++)
                    if (n != a)
                        theta[p++] = ang[n];
                let r = WebMolKit.norm_xy(mol.atomX(dst[i]) - cx, mol.atomY(dst[i]) - cy);
                for (let j = 0; j < geoms.length; j++) {
                    if (adj.length >= SketchUtil.GEOM_ANGLES[geoms[j]].length)
                        continue;
                    let newAng = SketchUtil.mapAngleSubstituent(geoms[j], theta);
                    if (newAng != null)
                        for (let n = 0; n < newAng.length; n++) {
                            let dth = WebMolKit.angleDiff(newAng[n], curth);
                            if (Math.abs(dth) < 3 * WebMolKit.DEGRAD)
                                continue;
                            if (dth < 0)
                                dth += WebMolKit.TWOPI;
                            if (bestAtom == 0 || dth < bestAng - 2 * WebMolKit.DEGRAD || (dth < bestAng + 2 * WebMolKit.DEGRAD && dst[i] < bestAtom)) {
                                let x = cx + r * Math.cos(newAng[n]);
                                let y = cy + r * Math.sin(newAng[n]);
                                if (WebMolKit.CoordUtil.atomAtPoint(mol, x, y) != 0)
                                    continue;
                                bestAtom = dst[i];
                                bestAng = dth;
                                bestX = x;
                                bestY = y;
                            }
                        }
                    break;
                }
            }
            if (bestAtom == 0)
                return null;
            mol = mol.clone();
            mol.setAtomPos(bestAtom, bestX, bestY);
            return mol;
        }
        static pickAtomsToConnect(mol, aidx) {
            if (aidx.length < 2)
                return null;
            if (aidx.length == 2) {
                if (mol.findBond(aidx[0], aidx[1]) > 0)
                    return null;
                return aidx;
            }
            const AUTO_DSQ = WebMolKit.sqr(WebMolKit.Molecule.IDEALBOND + 0.1);
            let bestDSQ = Number.MAX_VALUE;
            let bestA1 = 0, bestA2 = 0;
            let conn = [];
            for (let i = 0; i < aidx.length - 1; i++)
                for (let j = i + 1; j < aidx.length; j++) {
                    if (mol.findBond(aidx[i], aidx[j]) > 0)
                        continue;
                    let dsq = WebMolKit.norm2_xy(mol.atomX(aidx[i]) - mol.atomX(aidx[j]), mol.atomY(aidx[i]) - mol.atomY(aidx[j]));
                    if (dsq < AUTO_DSQ) {
                        conn.push(aidx[i]);
                        conn.push(aidx[j]);
                    }
                    else if (dsq < bestDSQ) {
                        bestDSQ = dsq;
                        bestA1 = aidx[i];
                        bestA2 = aidx[j];
                    }
                }
            if (conn.length == 0 && bestA1 != 0) {
                conn.push(bestA1);
                conn.push(bestA2);
            }
            return conn.length == 0 ? null : conn;
        }
        static pickNewAtomDirection(mol, atom, theta) {
            if (theta.length == 1)
                return theta[0];
            let bestTheta = theta[0], bestScore = Number.MAX_VALUE;
            for (let n = 0; n < theta.length; n++) {
                let px = mol.atomX(atom) + WebMolKit.Molecule.IDEALBOND * Math.cos(theta[n]);
                let py = mol.atomY(atom) + WebMolKit.Molecule.IDEALBOND * Math.sin(theta[n]);
                let score = WebMolKit.CoordUtil.congestionPoint(mol, px, py);
                if (score > bestScore)
                    continue;
                if (WebMolKit.CoordUtil.overlapsAtom(mol, px, py, 0.2))
                    score += 1E5;
                if (score < bestScore) {
                    bestTheta = theta[n];
                    bestScore = score;
                }
            }
            return bestTheta;
        }
        static joinOverlappingAtoms(mol, mask) {
            mol = mol.clone();
            mask = mask.slice(0);
            const na = mol.numAtoms;
            let mx = WebMolKit.MolUtil.arrayAtomX(mol), my = WebMolKit.MolUtil.arrayAtomY(mol);
            let groups = [];
            let groupX = [], groupY = [];
            for (let i = 0; i < na - 1; i++)
                if (mask[i]) {
                    let g = [i + 1];
                    let x = mx[i], y = my[i];
                    for (let j = i + 1; j < na; j++)
                        if (mask[j]) {
                            if (WebMolKit.norm2_xy(mx[j] - mx[i], my[j] - my[i]) > WebMolKit.CoordUtil.OVERLAP_THRESHOLD_SQ)
                                continue;
                            g.push(j + 1);
                            x += mx[j];
                            y += my[j];
                            let adjb = mol.atomAdjBonds(j + 1);
                            for (let n = 0; n < adjb.length; n++) {
                                if (mol.bondFrom(adjb[n]) == j + 1)
                                    mol.setBondFrom(adjb[n], i + 1);
                                else if (mol.bondTo(adjb[n]) == j + 1)
                                    mol.setBondTo(adjb[n], i + 1);
                            }
                        }
                    if (g.length == 1)
                        continue;
                    groups.push(g);
                    groupX.push(x / g.length);
                    groupY.push(y / g.length);
                }
            if (groups.length == 0)
                return null;
            let keepmask = WebMolKit.Vec.booleanArray(true, na);
            for (let n = 0; n < groups.length; n++) {
                let g = groups[n];
                mol.setAtomPos(g[0], groupX[n], groupY[n]);
                for (let i = 1; i < g.length; i++)
                    keepmask[g[i] - 1] = false;
            }
            mol = WebMolKit.MolUtil.subgraphMask(mol, keepmask);
            WebMolKit.MolUtil.removeDuplicateBonds(mol);
            return mol;
        }
        static moveToEdge(mol, mask, dx, dy) {
            let gotS = false, gotN = false;
            let sx1 = 0, sy1 = 0, sx2 = 0, sy2 = 0;
            let nx1 = 0, ny1 = 0, nx2 = 0, ny2 = 0;
            for (let n = 1; n <= mol.numAtoms; n++) {
                let x = mol.atomX(n), y = mol.atomY(n);
                if (mask[n - 1]) {
                    if (!gotS || x < sx1)
                        sx1 = x;
                    if (!gotS || y < sy1)
                        sy1 = y;
                    if (!gotS || x > sx2)
                        sx2 = x;
                    if (!gotS || y > sy2)
                        sy2 = y;
                    gotS = true;
                }
                else {
                    if (!gotN || x < nx1)
                        nx1 = x;
                    if (!gotN || y < ny1)
                        ny1 = y;
                    if (!gotN || x > nx2)
                        nx2 = x;
                    if (!gotN || y > ny2)
                        ny2 = y;
                    gotN = true;
                }
            }
            const SEPARATE = 1.0, SEPTEST = 0.9;
            if ((dx < 0 && dy == 0 && sx2 <= nx1 - SEPTEST) ||
                (dx > 0 && dy == 0 && sx1 >= nx2 + SEPTEST) ||
                (dx == 0 && dy < 0 && sy2 <= ny1 - SEPTEST) ||
                (dx == 0 && dy > 0 && sy1 >= ny2 + SEPTEST)) {
                return null;
            }
            mol = mol.clone();
            let ox = 0, oy = 0;
            if (dx < 0)
                ox = nx1 - sx2 - SEPARATE;
            if (dx > 0)
                ox = nx2 - sx1 + SEPARATE;
            if (dy < 0)
                oy = ny1 - sy2 - SEPARATE;
            if (dy > 0)
                oy = ny2 - sy1 + SEPARATE;
            for (let n = 1; n <= mol.numAtoms; n++)
                if (mask[n - 1])
                    mol.setAtomPos(n, mol.atomX(n) + ox, mol.atomY(n) + oy);
            return mol;
        }
        static placeAdditionalHydrogens(mol, atom, numH) {
            let base = mol.numAtoms;
            const x0 = mol.atomX(atom), y0 = mol.atomY(atom);
            let adj = mol.atomAdjList(atom);
            if (adj.length == 2 && numH == 2) {
                const th1 = Math.atan2(mol.atomY(adj[0]) - y0, mol.atomX(adj[0]) - x0);
                const th2 = Math.atan2(mol.atomY(adj[1]) - y0, mol.atomX(adj[1]) - x0);
                if (Math.abs(WebMolKit.angleDiff(th1, th2)) < 170 * WebMolKit.DEGRAD) {
                    let theta = 0.5 * (th1 + th2) + Math.PI;
                    let th3 = theta - 30 * WebMolKit.DEGRAD, th4 = theta + 30 * WebMolKit.DEGRAD;
                    mol.addAtom('H', x0 + WebMolKit.Molecule.IDEALBOND * Math.cos(th3), y0 + WebMolKit.Molecule.IDEALBOND * Math.sin(th3));
                    mol.addAtom('H', x0 + WebMolKit.Molecule.IDEALBOND * Math.cos(th4), y0 + WebMolKit.Molecule.IDEALBOND * Math.sin(th4));
                    mol.addBond(atom, base + 1, 1);
                    mol.addBond(atom, base + 2, 1);
                    return;
                }
            }
            if (adj.length == 1 && numH == 3) {
                let th1 = Math.atan2(mol.atomY(adj[0]) - y0, mol.atomX(adj[0]) - x0);
                let th2 = th1 + 90 * WebMolKit.DEGRAD, th3 = th1 + 180 * WebMolKit.DEGRAD, th4 = th1 + 270 * WebMolKit.DEGRAD;
                mol.addAtom('H', x0 + WebMolKit.Molecule.IDEALBOND * Math.cos(th2), y0 + WebMolKit.Molecule.IDEALBOND * Math.sin(th2));
                mol.addAtom('H', x0 + WebMolKit.Molecule.IDEALBOND * Math.cos(th3), y0 + WebMolKit.Molecule.IDEALBOND * Math.sin(th3));
                mol.addAtom('H', x0 + WebMolKit.Molecule.IDEALBOND * Math.cos(th4), y0 + WebMolKit.Molecule.IDEALBOND * Math.sin(th4));
                mol.addBond(atom, base + 1, 1);
                mol.addBond(atom, base + 2, 1);
                mol.addBond(atom, base + 3, 1);
                return;
            }
            let theta = SketchUtil.pickNewAtomDirection(mol, atom, SketchUtil.primeDirections(mol, atom));
            mol.addAtom('H', x0 + WebMolKit.Molecule.IDEALBOND * Math.cos(theta), y0 + WebMolKit.Molecule.IDEALBOND * Math.sin(theta));
            mol.addBond(atom, base + 1, 1);
            if (numH > 1)
                SketchUtil.placeAdditionalHydrogens(mol, atom, numH - 1);
        }
        static allViableDirections(mol, atom, order) {
            if (mol.atomAdjCount(atom) == 0) {
                let angles = [];
                for (let n = 0; n < 12; n++)
                    angles.push(30 * WebMolKit.DEGRAD);
                return angles;
            }
            let adj = mol.atomAdjList(atom);
            let angles = SketchUtil.exitVectors(mol, atom);
            let geom = SketchUtil.guessAtomGeometry(mol, atom, order);
            if (adj.length == 1 && geom.indexOf(Geometry.Linear) < 0)
                geom.push(Geometry.Linear);
            let bndang = WebMolKit.CoordUtil.atomBondAngles(mol, atom, adj);
            for (let g of geom) {
                let map = SketchUtil.mapAngleSubstituent(g, bndang);
                if (map != null)
                    for (let th of map)
                        angles.push(th);
            }
            return WebMolKit.GeomUtil.uniqueAngles(angles, 2 * WebMolKit.DEGRAD);
        }
        static proposeNewRing(mol, rsz, x, y, dx, dy, snap) {
            let theta = Math.atan2(dy, dx);
            if (snap) {
                const chunk = 30 * WebMolKit.DEGRAD;
                theta = Math.round(theta / chunk) * chunk;
            }
            return SketchUtil.positionSimpleRing(mol, rsz, x, y, theta);
        }
        static proposeAtomRing(mol, rsz, atom, dx, dy) {
            let thsnap = [];
            let cx = mol.atomX(atom), cy = mol.atomY(atom);
            if (mol.atomAdjCount(atom) == 0) {
                for (let n = 0; n < 12; n++)
                    thsnap.push(WebMolKit.TWOPI * n / 12);
            }
            else if (mol.atomAdjCount(atom) == 1) {
                let nbr = mol.atomAdjList(atom)[0];
                thsnap.push(WebMolKit.angleNorm(Math.atan2(mol.atomY(nbr) - cy, mol.atomX(nbr) - cx) + Math.PI));
            }
            else {
                let angs = [];
                for (let nbr of mol.atomAdjList(atom))
                    angs.push(Math.atan2(mol.atomY(nbr) - cy, mol.atomX(nbr) - cx));
                angs = WebMolKit.sortAngles(angs);
                for (let n = 0; n < angs.length; n++) {
                    let th1 = angs[n], th2 = angs[n < angs.length - 1 ? n + 1 : 0];
                    thsnap.push(th1 + 0.5 * WebMolKit.angleDiffPos(th2, th1));
                }
            }
            let theta = Math.atan2(dy, dx);
            let bestTheta = 0, bestDelta = Number.MAX_VALUE;
            for (let th of thsnap) {
                let delta = Math.abs(WebMolKit.angleDiff(th, theta));
                if (delta < bestDelta) {
                    bestTheta = th;
                    bestDelta = delta;
                }
            }
            return SketchUtil.positionSimpleRing(mol, rsz, mol.atomX(atom), mol.atomY(atom), bestTheta);
        }
        static proposeBondRing(mol, rsz, bond, dx, dy) {
            let bfr = mol.bondFrom(bond), bto = mol.bondTo(bond);
            let bx = mol.atomX(bto) - mol.atomX(bfr), by = mol.atomY(bto) - mol.atomY(bfr);
            let sign = dx * by - dy * bx;
            let delta = sign > 0 ? -90 * WebMolKit.DEGRAD : 90 * WebMolKit.DEGRAD;
            let theta = Math.atan2(by, bx) + delta;
            let dth = WebMolKit.TWOPI / rsz;
            let rad = WebMolKit.Molecule.IDEALBOND / (2.0 * Math.sin(0.5 * dth)), brad = rad * Math.cos(0.5 * dth);
            let cx = 0.5 * (mol.atomX(bfr) + mol.atomX(bto)) + brad * Math.cos(theta);
            let cy = 0.5 * (mol.atomY(bfr) + mol.atomY(bto)) + brad * Math.sin(theta);
            let rx = [], ry = [];
            for (let n = 0; n < rsz; n++) {
                let th = theta - Math.PI + (n - 0.5) * dth;
                rx.push(cx + Math.cos(th) * rad);
                ry.push(cy + Math.sin(th) * rad);
            }
            let [i1, i2] = sign < 0 ? [bfr, bto] : [bto, bfr];
            rx[0] = mol.atomX(i1);
            ry[0] = mol.atomY(i1);
            rx[1] = mol.atomX(i2);
            ry[1] = mol.atomY(i2);
            return [rx, ry];
        }
        static positionSimpleRing(mol, rsz, x, y, theta) {
            let dth = WebMolKit.TWOPI / rsz;
            let rad = WebMolKit.Molecule.IDEALBOND / (2 * Math.sin(0.5 * dth));
            let cx = x + rad * Math.cos(theta), cy = y + rad * Math.sin(theta);
            let rx = [], ry = [];
            for (let n = 0; n < rsz; n++) {
                let th = theta - Math.PI + n * dth;
                rx.push(cx + Math.cos(th) * rad);
                ry.push(cy + Math.sin(th) * rad);
            }
            return [rx, ry];
        }
        static guidelineSprouts(mol, atom) {
            let sprouts = [];
            let angs = [], ords = [];
            for (let n = 0; n < 3; n++) {
                angs.push(SketchUtil.allViableDirections(mol, atom, n + 1));
                ords.push([n + 1]);
                for (let i = 0; i < n; i++)
                    if (angs[i] != null && WebMolKit.Vec.equals(angs[n], angs[i])) {
                        angs[n] = null;
                        ords[i].push(n + 1);
                    }
            }
            const cx = mol.atomX(atom), cy = mol.atomY(atom);
            for (let n = 0; n < 3; n++)
                if (angs[n] != null) {
                    let sprout = {
                        'atom': atom,
                        'orders': ords[n],
                        'x': [],
                        'y': [],
                    };
                    for (let i = 0; i < angs[n].length; i++) {
                        sprout.x[i] = cx + Math.cos(angs[n][i]) * WebMolKit.Molecule.IDEALBOND;
                        sprout.y[i] = cy + Math.sin(angs[n][i]) * WebMolKit.Molecule.IDEALBOND;
                    }
                    sprouts.push(sprout);
                }
            return sprouts;
        }
    }
    SketchUtil.GEOM_ANGLES = [
        [0, 180 * WebMolKit.DEGRAD],
        [0, 120 * WebMolKit.DEGRAD],
        [0, 120 * WebMolKit.DEGRAD, 240 * WebMolKit.DEGRAD],
        [0, 90 * WebMolKit.DEGRAD, 150 * WebMolKit.DEGRAD, 240 * WebMolKit.DEGRAD],
        [0, 120 * WebMolKit.DEGRAD, 180 * WebMolKit.DEGRAD, 240 * WebMolKit.DEGRAD],
        [0, 90 * WebMolKit.DEGRAD, 180 * WebMolKit.DEGRAD, 270 * WebMolKit.DEGRAD],
        [0, 90 * WebMolKit.DEGRAD, 150 * WebMolKit.DEGRAD, 210 * WebMolKit.DEGRAD, 270 * WebMolKit.DEGRAD],
        [0, 60 * WebMolKit.DEGRAD, 90 * WebMolKit.DEGRAD, 180 * WebMolKit.DEGRAD, 210 * WebMolKit.DEGRAD],
        [0, 60 * WebMolKit.DEGRAD, 120 * WebMolKit.DEGRAD, 180 * WebMolKit.DEGRAD, 240 * WebMolKit.DEGRAD, 300 * WebMolKit.DEGRAD],
        [0, 45 * WebMolKit.DEGRAD, 90 * WebMolKit.DEGRAD, 180 * WebMolKit.DEGRAD, 225 * WebMolKit.DEGRAD, 270 * WebMolKit.DEGRAD]
    ];
    WebMolKit.SketchUtil = SketchUtil;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class Stereochemistry {
        constructor(meta) {
            this.meta = meta;
            this.mol = meta.mol;
            this.priority = WebMolKit.Vec.numberArray(0, this.mol.numAtoms);
            this.chiralTetra = WebMolKit.Vec.numberArray(Stereochemistry.STEREO_NONE, this.mol.numAtoms);
            this.cistransBond = WebMolKit.Vec.numberArray(Stereochemistry.STEREO_NONE, this.mol.numBonds);
            this.squarePlanar = WebMolKit.Vec.numberArray(Stereochemistry.STEREO_NONE, this.mol.numAtoms);
        }
        calculate() {
            this.isH = WebMolKit.Vec.booleanArray(false, this.mol.numAtoms);
            for (let n = this.mol.numAtoms; n >= 1; n--)
                this.isH[n - 1] = this.mol.atomElement(n) == 'H';
            this.buildPriority();
            this.buildTetraChirality();
            this.buildBondCisTrans();
            this.buildPlanarCisTrans();
            this.buildOctaChirality();
        }
        atomPriority(atom) { return this.priority[atom - 1]; }
        atomTetraChirality(atom) { return this.chiralTetra[atom - 1]; }
        bondSideStereo(bond) { return this.cistransBond[bond - 1]; }
        atomPlanarStereo(atom) { return this.squarePlanar[atom - 1]; }
        getPriorities() { return this.priority.slice(0); }
        getAtomTetraChiral() { return this.chiralTetra.slice(0); }
        getBondSideStereo() { return this.cistransBond.slice(0); }
        static create(meta) {
            let stereo = new Stereochemistry(meta);
            stereo.calculate();
            return stereo;
        }
        static rubricTetrahedral(mol, atom) {
            if (mol.atomAdjCount(atom) < 3 || mol.atomAdjCount(atom) + mol.atomHydrogens(atom) != 4)
                return null;
            let adjBonds = mol.atomAdjBonds(atom);
            let hasWedge = false;
            for (let n = 0; n < adjBonds.length; n++) {
                let bt = mol.bondType(adjBonds[n]);
                if (bt == WebMolKit.Molecule.BONDTYPE_UNKNOWN)
                    return null;
                if (mol.bondFrom(adjBonds[n]) != atom)
                    continue;
                if (bt == WebMolKit.Molecule.BONDTYPE_INCLINED || bt == WebMolKit.Molecule.BONDTYPE_DECLINED)
                    hasWedge = true;
            }
            if (!hasWedge && !mol.is3D())
                return null;
            let adj = mol.atomAdjList(atom);
            let x = [0, 0, 0, 0];
            let y = [0, 0, 0, 0];
            let z = [0, 0, 0, 0];
            let numShort = 0, numWedges = 0;
            for (let n = 0; n < adjBonds.length; n++) {
                const bfr = mol.bondFrom(adjBonds[n]), bt = mol.bondType(adjBonds[n]);
                x[n] = mol.atomX(adj[n]) - mol.atomX(atom);
                y[n] = mol.atomY(adj[n]) - mol.atomY(atom);
                if (mol.is3D()) {
                    z[n] = mol.atomZ(adj[n]) - mol.atomZ(atom);
                }
                else if (bfr == atom) {
                    if (bt == WebMolKit.Molecule.BONDTYPE_INCLINED) {
                        z[n] = 1;
                        numWedges++;
                    }
                    else if (bt == WebMolKit.Molecule.BONDTYPE_DECLINED) {
                        z[n] = -1;
                        numWedges++;
                    }
                }
                let dsq = WebMolKit.norm_xyz(x[n], y[n], z[n]);
                if (dsq < 0.01 * 0.01) {
                    numShort++;
                    if (numShort > 1)
                        return null;
                }
            }
            if (adjBonds.length == 3) {
                adj.push(0);
                if (!mol.is3D() && numWedges == 1) {
                    let th0 = Math.atan2(y[0], x[0]), th1 = Math.atan2(y[1], x[1]), th2 = Math.atan2(y[2], x[2]);
                    let i1 = 1, i2 = 2;
                    if (WebMolKit.angleDiffPos(th1, th0) > WebMolKit.angleDiffPos(th2, th0)) {
                        i2 = 1;
                        i1 = 2;
                    }
                    x[0] = 1.5;
                    y[0] = 0;
                    x[1] = -0.75;
                    y[i1] = 1.3;
                    x[2] = -0.75;
                    y[i2] = -1.3;
                }
                else {
                    x[3] = -(x[0] + x[1] + x[2]);
                    y[3] = -(y[0] + y[1] + y[2]);
                    z[3] = -(z[0] + z[1] + z[2]);
                    let dsq = WebMolKit.norm2_xyz(x[3], y[3], z[3]);
                    if (dsq < 0.01 * 0.01)
                        return null;
                    let inv = 1.0 / Math.sqrt(dsq);
                    x[3] *= inv;
                    y[3] *= inv;
                    z[3] *= inv;
                }
            }
            let one = 0, two = 0;
            for (let i = 1; i <= 6; i++) {
                let a = 0, b = 0;
                if (i == 1) {
                    a = 1;
                    b = 2;
                }
                else if (i == 2) {
                    a = 2;
                    b = 3;
                }
                else if (i == 3) {
                    a = 3;
                    b = 1;
                }
                else if (i == 4) {
                    a = 2;
                    b = 1;
                }
                else if (i == 5) {
                    a = 3;
                    b = 2;
                }
                else if (i == 6) {
                    a = 1;
                    b = 3;
                }
                let xx = y[a] * z[b] - y[b] * z[a] - x[0];
                let yy = z[a] * x[b] - z[b] * x[a] - y[0];
                let zz = x[a] * y[b] - x[b] * y[a] - z[0];
                if (i <= 3)
                    one += xx * xx + yy * yy + zz * zz;
                else
                    two += xx * xx + yy * yy + zz * zz;
            }
            if (two > one)
                WebMolKit.Vec.swap(adj, 2, 3);
            return adj;
        }
        static rubricSquarePlanar(mol, atom) {
            if (mol.atomAdjCount(atom) != 4)
                return null;
            if (!mol.is3D()) {
                let ninc = 0, ndec = 0;
                for (let b of mol.atomAdjBonds(atom)) {
                    let bt = mol.bondType(b);
                    if (bt == WebMolKit.Molecule.BONDTYPE_INCLINED)
                        ninc++;
                    else if (bt == WebMolKit.Molecule.BONDTYPE_DECLINED)
                        ndec++;
                }
                if (ninc == 2 && ndec == 2) { }
                else if (ninc == 2 && ndec == 0) { }
                else if (ninc == 0 && ndec == 2) { }
                else
                    return null;
            }
            let adj = mol.atomAdjList(atom);
            let v0 = WebMolKit.MolUtil.atomVec3(mol, atom);
            let v1 = WebMolKit.Vec.sub(WebMolKit.MolUtil.atomVec3(mol, adj[0]), v0);
            let v2 = WebMolKit.Vec.sub(WebMolKit.MolUtil.atomVec3(mol, adj[1]), v0);
            let v3 = WebMolKit.Vec.sub(WebMolKit.MolUtil.atomVec3(mol, adj[2]), v0);
            let v4 = WebMolKit.Vec.sub(WebMolKit.MolUtil.atomVec3(mol, adj[3]), v0);
            for (let v of [v1, v2, v3, v4]) {
                let dsq = WebMolKit.norm2_xyz(v[0], v[1], v[2]);
                if (dsq < 0.01 * 0.01)
                    continue;
                let inv = 1.0 / Math.sqrt(dsq);
                v[0] *= inv;
                v[1] *= inv;
                v[2] *= inv;
            }
            let d2 = WebMolKit.GeomUtil.dist2(v1, v2), d3 = WebMolKit.GeomUtil.dist2(v1, v3), d4 = WebMolKit.GeomUtil.dist2(v1, v4);
            if (d2 > d3 && d2 >= d4) {
                WebMolKit.Vec.swap(adj, 1, 2);
                [v2, v3] = [v3, v2];
            }
            else if (d4 > d3) {
                WebMolKit.Vec.swap(adj, 3, 2);
                [v3, v4] = [v4, v3];
            }
            const MIN_ANGLE = (mol.is3D() ? 80 : 45) * WebMolKit.DEGRAD;
            const MAX_ANGLE = (mol.is3D() ? 100 : 135) * WebMolKit.DEGRAD;
            const th12 = WebMolKit.GeomUtil.acuteAngle(v1, v2);
            if (th12 < MIN_ANGLE || th12 > MAX_ANGLE)
                return null;
            const th23 = WebMolKit.GeomUtil.acuteAngle(v2, v3);
            if (th23 < MIN_ANGLE || th23 > MAX_ANGLE)
                return null;
            const th34 = WebMolKit.GeomUtil.acuteAngle(v3, v4);
            if (th34 < MIN_ANGLE || th34 > MAX_ANGLE)
                return null;
            const th41 = WebMolKit.GeomUtil.acuteAngle(v4, v1);
            if (th41 < MIN_ANGLE || th41 > MAX_ANGLE)
                return null;
            return adj;
        }
        static rubricBipyrimidal(mol, atom) {
            const nadj = mol.atomAdjCount(atom);
            if (nadj != 4 && nadj != 5)
                return null;
            let atom2 = 0, atom3 = 0;
            let adj = mol.atomAdjList(atom), bonds = mol.atomAdjBonds(atom);
            if (!mol.is3D()) {
                for (let n = 0; n < adj.length; n++) {
                    if (mol.bondType(bonds[n]) == WebMolKit.Molecule.BONDTYPE_INCLINED) {
                        if (atom2 > 0)
                            return null;
                        atom2 = adj[n];
                    }
                    else if (mol.bondType(bonds[n]) == WebMolKit.Molecule.BONDTYPE_DECLINED) {
                        if (atom3 > 0)
                            return null;
                        atom3 = adj[n];
                    }
                }
                if (atom2 == 0 || atom3 == 0)
                    return null;
                let th1 = Math.atan2(mol.atomY(atom2) - mol.atomY(atom), mol.atomX(atom2) - mol.atomX(atom));
                let th2 = Math.atan2(mol.atomY(atom3) - mol.atomY(atom), mol.atomX(atom3) - mol.atomX(atom));
                if (Math.abs(WebMolKit.angleDiff(th1, th2)) > 160 * WebMolKit.DEGRAD)
                    return null;
            }
            let v0 = WebMolKit.MolUtil.atomVec3(mol, atom);
            let v = [[], [], [], [], []];
            const THRESH = 0.1;
            for (let n = 0; n < nadj; n++) {
                v[n] = WebMolKit.Vec.sub(WebMolKit.MolUtil.atomVec3(mol, adj[n]), v0);
                const mag = WebMolKit.GeomUtil.magnitude(v[n]);
                if (mag < THRESH)
                    return null;
                WebMolKit.Vec.mulBy(v[n], 1.0 / mag);
                if (adj[n] == atom2)
                    v[n][2] += 1;
                else if (adj[n] == atom3)
                    v[n][2] -= 1;
            }
            let atom4 = 0, atom5 = 0;
            const ANGLE_OPPOSITE = 175 * WebMolKit.DEGRAD;
            for (let i = 0; i < nadj - 1; i++)
                if (adj[i] != atom2 && adj[i] != atom3) {
                    for (let j = i + 1; j < nadj; j++)
                        if (adj[j] != atom2 && adj[j] != atom3) {
                            let theta = WebMolKit.GeomUtil.acuteAngle(v[i], v[j]);
                            if (theta > ANGLE_OPPOSITE) {
                                if (atom4 != 0)
                                    return null;
                                atom4 = adj[i];
                                atom5 = adj[j];
                            }
                        }
                }
            if (mol.is3D()) {
                for (let a of adj)
                    if (a != atom4 && a != atom5) {
                        if (atom2 == 0)
                            atom2 = a;
                        else if (atom3 == 0)
                            atom3 = a;
                    }
            }
            if (!atom4 || !atom5)
                return null;
            let v1 = null;
            let v2 = v[adj.indexOf(atom2)];
            let v3 = v[adj.indexOf(atom3)];
            let v4 = v[adj.indexOf(atom4)];
            let v5 = v[adj.indexOf(atom5)];
            let atom1 = 0;
            if (nadj == 5) {
                for (let n = 0; n < nadj; n++)
                    if (adj[n] != atom2 && adj[n] != atom3 && adj[n] != atom4 && adj[n] != atom5) {
                        atom1 = adj[n];
                        v1 = v[n];
                        break;
                    }
            }
            else {
                v1 = [0, 0, 0];
                v1 = WebMolKit.Vec.sub(v1, v2);
                v1 = WebMolKit.Vec.sub(v1, v3);
                const mag = WebMolKit.GeomUtil.magnitude(v1);
                if (mag < THRESH)
                    return null;
                WebMolKit.Vec.mulBy(v1, 1.0 / mag);
            }
            let v45 = WebMolKit.Vec.sub(v5, v4);
            let cross = WebMolKit.GeomUtil.crossProduct(v45, v1);
            let dsq2 = WebMolKit.GeomUtil.dist2(cross, v2), dsq3 = WebMolKit.GeomUtil.dist2(cross, v3);
            if (dsq2 < dsq3)
                return [atom1, atom2, atom3, atom4, atom5];
            else
                return [atom1, atom2, atom3, atom5, atom4];
        }
        static rubricOctahedral(mol, atom) {
            const nadj = mol.atomAdjCount(atom);
            if (nadj != 5 && nadj != 6)
                return null;
            let adj = mol.atomAdjList(atom), bonds = mol.atomAdjBonds(atom);
            if (nadj == 5) {
                adj.push(0);
                bonds.push(0);
            }
            if (!mol.is3D()) {
                let numWedges = 0;
                for (let b of bonds)
                    if (b > 0) {
                        const bt = mol.bondType(b);
                        if (bt == WebMolKit.Molecule.BONDTYPE_INCLINED || bt == WebMolKit.Molecule.BONDTYPE_DECLINED)
                            numWedges++;
                    }
                if ((nadj == 5 && numWedges < 1) || (nadj == 6 && numWedges < 2))
                    return null;
            }
            const THRESH = 0.1;
            let v0 = WebMolKit.MolUtil.atomVec3(mol, atom);
            let v = [[], [], [], [], [], []];
            for (let n = 0; n < nadj; n++) {
                v[n] = WebMolKit.MolUtil.atomVec3(mol, adj[n]);
                WebMolKit.Vec.subFromArray(v[n], v0);
                let mag = WebMolKit.GeomUtil.magnitude(v[n]);
                if (mag < THRESH)
                    return null;
                WebMolKit.Vec.mulBy(v[n], 1 / mag);
                let bt = mol.bondType(bonds[n]);
                if (bt == WebMolKit.Molecule.BONDTYPE_INCLINED) {
                    if (mol.bondFrom(bonds[n]) == atom)
                        v[n][2] += 1;
                    else
                        v[n][2] -= 1;
                }
                else if (bt == WebMolKit.Molecule.BONDTYPE_DECLINED) {
                    if (mol.bondFrom(bonds[n]) == atom)
                        v[n][2] -= 1;
                    else
                        v[n][2] += 1;
                }
            }
            if (nadj == 5) {
                v[5] = [0, 0, 0];
                for (let n = 0; n < 5; n++)
                    WebMolKit.Vec.subFromArray(v[5], v[n]);
                let mag = WebMolKit.GeomUtil.magnitude(v[5]);
                if (mag < THRESH)
                    return null;
                WebMolKit.Vec.mulBy(v[5], 1 / mag);
            }
            let slots = [-1, -1, -1, -1, 0, 1];
            let bestOpposite = WebMolKit.GeomUtil.acuteAngle(v[0], v[1]);
            for (let i = 0; i < 5; i++)
                for (let j = (i == 0 ? 2 : i + 1); j < 6; j++) {
                    let theta = WebMolKit.GeomUtil.acuteAngle(v[i], v[j]);
                    if (theta > bestOpposite) {
                        slots[4] = i;
                        slots[5] = j;
                        bestOpposite = theta;
                    }
                }
            let axial = WebMolKit.Vec.sub(v[slots[5]], v[slots[4]]);
            let bestOrthogonal = Number.POSITIVE_INFINITY;
            for (let n = 0; n < 6; n++)
                if (n != slots[4] && n != slots[5]) {
                    let delta = Math.abs((90 * WebMolKit.DEGRAD) - WebMolKit.GeomUtil.acuteAngle(v[n], axial));
                    if (delta < bestOrthogonal) {
                        slots[0] = n;
                        bestOrthogonal = delta;
                    }
                }
            for (let s = 1; s <= 2; s++) {
                let cross = WebMolKit.GeomUtil.crossProduct(axial, v[slots[s - 1]]);
                let bestOrient = Number.POSITIVE_INFINITY;
                for (let n = 0; n < 6; n++) {
                    if (n == slots[4] || n == slots[5] || n == slots[0] || n == slots[1])
                        continue;
                    let delta = WebMolKit.GeomUtil.acuteAngle(v[n], cross);
                    if (delta < bestOrient) {
                        slots[s] = n;
                        bestOrient = delta;
                    }
                }
            }
            for (let n = 0; n < 6; n++)
                if (slots.indexOf(n) < 0) {
                    slots[3] = n;
                    break;
                }
            let rubric = [0, 0, 0, 0, 0, 0];
            for (let n = 0; n < 6; n++)
                rubric[n] = slots[n] < 0 ? 0 : adj[slots[n]];
            return rubric;
        }
        static rubricBondSides(mol, bond) {
            const bfr = mol.bondFrom(bond), bto = mol.bondTo(bond);
            const nfr = mol.atomAdjCount(bfr), nto = mol.atomAdjCount(bto);
            if (nfr < 2 || nfr > 3 || nto < 2 || nto > 3)
                return null;
            let adj1 = mol.atomAdjList(bfr), adj2 = mol.atomAdjList(bto);
            let f1 = 0, f2 = 0, t1 = 0, t2 = 0;
            for (let i = 0; i < adj1.length; i++) {
                if (adj1[i] != bto) {
                    if (f1 == 0)
                        f1 = adj1[i];
                    else
                        f2 = adj1[i];
                }
            }
            for (let i = 0; i < adj2.length; i++) {
                if (adj2[i] != bfr) {
                    if (t1 == 0)
                        t1 = adj2[i];
                    else
                        t2 = adj2[i];
                }
            }
            if (f1 > 0 && f2 > 0 && mol.atomElement(f1) == 'H') {
                let f = f1;
                f1 = f2;
                f2 = f;
            }
            if (t1 > 0 && t2 > 0 && mol.atomElement(t1) == 'H') {
                let t = t1;
                t1 = t2;
                t2 = t;
            }
            let vfr = WebMolKit.MolUtil.atomVec3(mol, bfr), vto = WebMolKit.MolUtil.atomVec3(mol, bto);
            let vbond = WebMolKit.Vec.sub(vto, vfr);
            let vf1 = WebMolKit.Vec.sub(WebMolKit.MolUtil.atomVec3(mol, f1), vfr), vt1 = WebMolKit.Vec.sub(WebMolKit.MolUtil.atomVec3(mol, t1), vto);
            const THRESHSQ = 0.1 * 0.1;
            let xf1 = WebMolKit.GeomUtil.crossProduct(vf1, vbond);
            if (WebMolKit.GeomUtil.magnitude2(xf1) < THRESHSQ)
                return null;
            let xt1 = WebMolKit.GeomUtil.crossProduct(vt1, vbond);
            if (WebMolKit.GeomUtil.magnitude2(xt1) < THRESHSQ)
                return null;
            let xf1N = WebMolKit.Vec.neg(xf1);
            let keepF1T1 = WebMolKit.GeomUtil.dist2(xf1, xt1) < WebMolKit.GeomUtil.dist2(xf1N, xt1);
            let keepF2T1 = keepF1T1, keepF1T2 = keepF1T1, keepF2T2 = keepF1T1;
            let vf2 = null, vt2 = null, xf2 = null, xt2 = null, xf2N = null;
            if (f2 > 0) {
                vf2 = WebMolKit.Vec.sub(WebMolKit.MolUtil.atomVec3(mol, f2), vfr);
                if (WebMolKit.GeomUtil.magnitude2(vf2) < THRESHSQ) {
                    if (mol.atomElement(f2) != 'H')
                        return null;
                }
                else {
                    xf2 = WebMolKit.GeomUtil.crossProduct(vf2, vbond);
                    if (WebMolKit.GeomUtil.magnitude2(xf2) < THRESHSQ)
                        return null;
                    xf2N = WebMolKit.Vec.neg(xf2);
                    keepF2T1 = WebMolKit.GeomUtil.dist2(xf2, xt1) > WebMolKit.GeomUtil.dist2(xf2N, xt1);
                }
            }
            if (t2 > 0) {
                vt2 = WebMolKit.Vec.sub(WebMolKit.MolUtil.atomVec3(mol, t2), vto);
                if (WebMolKit.GeomUtil.magnitude2(vt2) < THRESHSQ) {
                    if (mol.atomElement(t2) != 'H')
                        return null;
                }
                else {
                    xt2 = WebMolKit.GeomUtil.crossProduct(vt2, vbond);
                    if (WebMolKit.GeomUtil.magnitude2(xt2) < THRESHSQ)
                        return null;
                    keepF1T2 = WebMolKit.GeomUtil.dist2(xf1, xt2) > WebMolKit.GeomUtil.dist2(xf1N, xt2);
                }
            }
            if (xf2 != null && xt2 != null) {
                keepF2T2 = WebMolKit.GeomUtil.dist2(xf2, xt2) < WebMolKit.GeomUtil.dist2(xf2N, xt2);
            }
            if (keepF1T1 && keepF2T1 && keepF1T2 && keepF2T2)
                return [f1, f2, t1, t2];
            if (!keepF1T1 && !keepF2T1 && !keepF1T2 && !keepF2T2)
                return [f1, f2, t2, t1];
            return null;
        }
        buildTetraChirality() {
            const mol = this.mol, na = mol.numAtoms, nb = mol.numBonds;
            let haswedge = WebMolKit.Vec.booleanArray(false, na);
            for (let n = 1; n <= nb; n++) {
                if (mol.bondType(n) == WebMolKit.Molecule.BONDTYPE_INCLINED || mol.bondType(n) == WebMolKit.Molecule.BONDTYPE_DECLINED)
                    haswedge[mol.bondFrom(n) - 1] = true;
            }
            skip_atom: for (let n = 1; n <= na; n++) {
                this.chiralTetra[n - 1] = Stereochemistry.STEREO_NONE;
                let adj = mol.atomAdjList(n);
                if (!(adj.length == 4 || (adj.length == 3 && mol.atomHydrogens(n) == 1)))
                    continue;
                if (adj.length == 3 && (this.isH[adj[0] - 1] || this.isH[adj[1] - 1] || this.isH[adj[2] - 1]))
                    continue;
                for (let i = 0; i < adj.length - 1; i++) {
                    for (let j = i + 1; j < adj.length; j++) {
                        if (this.priority[adj[i] - 1] == this.priority[adj[j] - 1])
                            continue skip_atom;
                    }
                }
                if (!haswedge[n - 1] && !mol.is3D()) {
                    this.chiralTetra[n - 1] = Stereochemistry.STEREO_UNKNOWN;
                    continue;
                }
                let rubric = Stereochemistry.rubricTetrahedral(mol, n);
                if (rubric == null)
                    continue;
                let pri = [
                    rubric[0] == 0 ? 0 : this.priority[rubric[0] - 1],
                    rubric[1] == 0 ? 0 : this.priority[rubric[1] - 1],
                    rubric[2] == 0 ? 0 : this.priority[rubric[2] - 1],
                    rubric[3] == 0 ? 0 : this.priority[rubric[3] - 1]
                ];
                pri = WebMolKit.Vec.idxSort(pri);
                let parity = WebMolKit.Permutation.parityIdentity(pri);
                this.chiralTetra[n - 1] = (parity & 1) == 0 ? Stereochemistry.STEREO_POS : Stereochemistry.STEREO_NEG;
            }
        }
        buildBondCisTrans() {
            const mol = this.mol, na = mol.numAtoms, nb = mol.numBonds;
            let sf = [0, 0], st = [0, 0];
            let ringMask = WebMolKit.Vec.booleanArray(false, nb);
            for (let rsz = 3; rsz <= 7; rsz++) {
                for (let r of mol.findRingsOfSize(rsz)) {
                    for (let n = 0; n < r.length; n++) {
                        let b = mol.findBond(r[n], r[n < r.length - 1 ? n + 1 : 0]);
                        ringMask[b - 1] = true;
                    }
                }
            }
            skip_bond: for (let n = 1; n <= nb; n++) {
                this.cistransBond[n - 1] = Stereochemistry.STEREO_NONE;
                if (mol.bondOrder(n) != 2 || this.meta.isBondAromatic(n) || ringMask[n - 1])
                    continue;
                let bfr = mol.bondFrom(n), bto = mol.bondTo(n);
                let adj1 = mol.atomAdjList(bfr), adj2 = mol.atomAdjList(bto);
                if (adj1.length <= 1 || adj2.length <= 1 || adj1.length > 3 || adj2.length > 3)
                    continue;
                if (adj1.length == 2 && (this.isH[adj1[0] - 1] || this.isH[adj1[1] - 1]))
                    continue;
                if (adj2.length == 2 && (this.isH[adj2[0] - 1] || this.isH[adj2[1] - 1]))
                    continue;
                for (let i = 0; i < adj1.length - 1; i++)
                    if (adj1[i] != bfr)
                        for (let j = i + 1; j < adj1.length; j++)
                            if (adj1[j] != bfr)
                                if (this.priority[adj1[i] - 1] == this.priority[adj1[j] - 1])
                                    continue skip_bond;
                for (let i = 0; i < adj2.length - 1; i++)
                    if (adj2[i] != bto)
                        for (let j = i + 1; j < adj2.length; j++)
                            if (adj2[j] != bto)
                                if (this.priority[adj2[i] - 1] == this.priority[adj2[j] - 1])
                                    continue skip_bond;
                if (mol.bondType(n) == WebMolKit.Molecule.BONDTYPE_UNKNOWN) {
                    this.cistransBond[n - 1] = Stereochemistry.STEREO_UNKNOWN;
                    continue;
                }
                let rubric = Stereochemistry.rubricBondSides(mol, n);
                if (rubric == null)
                    continue;
                let pf1 = rubric[0] == 0 ? 0 : this.priority[rubric[0] - 1];
                let pf2 = rubric[1] == 0 ? 0 : this.priority[rubric[1] - 1];
                let pt1 = rubric[2] == 0 ? 0 : this.priority[rubric[2] - 1];
                let pt2 = rubric[3] == 0 ? 0 : this.priority[rubric[3] - 1];
                this.cistransBond[n - 1] = ((pf1 < pf2) == (pt1 < pt2)) ? Stereochemistry.STEREO_POS : Stereochemistry.STEREO_NEG;
            }
        }
        buildPlanarCisTrans() {
            const mol = this.mol, na = mol.numAtoms, nb = mol.numBonds;
            skip_atom: for (let n = 1; n <= na; n++) {
                this.squarePlanar[n - 1] = Stereochemistry.STEREO_NONE;
                if (mol.atomAdjCount(n) != 4)
                    continue;
                if (WebMolKit.Chemistry.ELEMENT_BLOCKS[mol.atomicNumber(n)] < 3)
                    continue;
                let adj = mol.atomAdjList(n);
                for (let i = 0; i < adj.length; i++) {
                    let count = 0;
                    for (let j = 0; j < adj.length; j++) {
                        if (this.priority[adj[i] - 1] == this.priority[adj[j] - 1])
                            count++;
                    }
                    if (count >= 3)
                        continue skip_atom;
                }
                let rubric = Stereochemistry.rubricSquarePlanar(mol, n);
                if (rubric == null)
                    continue;
                let pri = [
                    rubric[0] == 0 ? 0 : this.priority[rubric[0] - 1],
                    rubric[1] == 0 ? 0 : this.priority[rubric[1] - 1],
                    rubric[2] == 0 ? 0 : this.priority[rubric[2] - 1],
                    rubric[3] == 0 ? 0 : this.priority[rubric[3] - 1]
                ];
                let parity = WebMolKit.Permutation.parityOrder(pri);
                this.squarePlanar[n - 1] = (parity & 1) == 0 ? Stereochemistry.STEREO_POS : Stereochemistry.STEREO_NEG;
            }
        }
        buildOctaChirality() {
        }
        buildPriority() {
            const mol = this.mol, na = mol.numAtoms, nb = mol.numBonds;
            let cipgr = [];
            for (let n = 0; n < na; n++)
                cipgr.push(WebMolKit.Vec.numberArray(-1, mol.atomHydrogens(n + 1)));
            for (let n = 1; n <= nb; n++) {
                let bf = mol.bondFrom(n) - 1, bt = mol.bondTo(n) - 1, bo = mol.bondOrder(n);
                if (this.meta.isBondAromatic(n))
                    bo = 2;
                if (bf != bt)
                    for (let i = 0; i < bo; i++) {
                        cipgr[bf].push(bt);
                        cipgr[bt].push(bf);
                    }
            }
            this.priority = WebMolKit.Vec.numberArray(0, na);
            let anyActualH = false;
            for (let n = 0; n < na; n++) {
                this.priority[n] = mol.atomicNumber(n + 1);
                if (this.priority[n] == 1)
                    anyActualH = true;
            }
            let prigr = [];
            for (let n = 0; n < na; n++)
                prigr.push([]);
            while (true) {
                for (let n = 0; n < na; n++) {
                    let cip = cipgr[n], pri = [];
                    for (let i = 0; i < cip.length; i++)
                        pri.push(cip[i] < 0 ? 1 : this.priority[cip[i]]);
                    WebMolKit.Vec.sort(pri);
                    prigr[n] = pri;
                }
                let groups = this.sortAndGroup(this.priority);
                let nextpri = anyActualH ? 0 : 1;
                let repartitioned = false;
                for (let n = 0; n < groups.length; n++) {
                    let g = groups[n];
                    for (let p = 0; p < g.length - 1;) {
                        const i1 = g[p], i2 = g[p + 1];
                        let cmp = 0, sz = Math.max(prigr[i1].length, prigr[i2].length);
                        for (let i = 0; i < sz; i++) {
                            let v1 = i < prigr[i1].length ? prigr[i1][i] : 0, v2 = i < prigr[i2].length ? prigr[i2][i] : 0;
                            if (v1 < v2) {
                                cmp = -1;
                                break;
                            }
                            if (v1 > v2) {
                                cmp = 1;
                                break;
                            }
                        }
                        if (cmp > 0) {
                            g[p] = i2;
                            g[p + 1] = i1;
                            if (p > 0)
                                p--;
                        }
                        else
                            p++;
                    }
                    for (let i = 0; i < g.length; i++) {
                        if (i == 0)
                            nextpri++;
                        else if (prigr[g[i]].length != prigr[g[i - 1]].length) {
                            nextpri++;
                            repartitioned = true;
                        }
                        else {
                            for (let j = 0; j < prigr[g[i]].length; j++)
                                if (prigr[g[i]][j] != prigr[g[i - 1]][j]) {
                                    nextpri++;
                                    repartitioned = true;
                                    break;
                                }
                        }
                        this.priority[g[i]] = nextpri;
                    }
                }
                if (!repartitioned)
                    break;
            }
        }
        sortAndGroup(val) {
            let uset = new Set();
            for (let v of val)
                uset.add(v);
            let unique = Array.from(uset);
            WebMolKit.Vec.sort(unique);
            let ret = [];
            for (let n = 0; n < unique.length; n++)
                ret.push([]);
            for (let n = 0; n < val.length; n++) {
                let grp = unique.indexOf(val[n]);
                ret[grp].push(n);
            }
            return ret;
        }
    }
    Stereochemistry.STEREO_NONE = 0;
    Stereochemistry.STEREO_POS = 1;
    Stereochemistry.STEREO_NEG = 2;
    Stereochemistry.STEREO_UNKNOWN = 3;
    Stereochemistry.STEREO_BROKEN = 4;
    Stereochemistry.RUBRIC_EQUIV_TETRA = [
        [0, 1, 2, 3], [0, 2, 3, 1], [0, 3, 1, 2], [1, 0, 3, 2], [1, 2, 0, 3], [1, 3, 2, 0],
        [2, 0, 1, 3], [2, 1, 3, 0], [2, 3, 0, 1], [3, 0, 2, 1], [3, 1, 0, 2], [3, 2, 1, 0]
    ];
    Stereochemistry.RUBRIC_EQUIV_SIDES = [
        [0, 1, 2, 3], [1, 0, 3, 2], [2, 3, 0, 1], [3, 2, 1, 0]
    ];
    Stereochemistry.RUBRIC_EQUIV_SQUARE = [
        [0, 1, 2, 3], [0, 3, 2, 1], [1, 2, 3, 0], [1, 0, 3, 2],
        [2, 1, 0, 3], [2, 3, 0, 1], [3, 2, 1, 0], [3, 0, 1, 2]
    ];
    Stereochemistry.RUBRIC_EQUIV_BIPY = [
        [0, 1, 2, 3, 4], [1, 2, 0, 3, 4], [2, 0, 1, 3, 4],
        [0, 2, 1, 4, 3], [1, 0, 2, 4, 3], [2, 1, 0, 4, 3],
    ];
    Stereochemistry.RUBRIC_EQUIV_OCTA = [
        [0, 1, 2, 3, 4, 5], [0, 3, 2, 1, 5, 4], [0, 4, 2, 5, 3, 1], [0, 5, 2, 4, 1, 3],
        [1, 0, 3, 2, 5, 4], [1, 2, 3, 0, 4, 5], [1, 4, 3, 5, 0, 2], [1, 5, 3, 4, 2, 0],
        [2, 1, 0, 3, 5, 4], [2, 3, 0, 1, 4, 5], [2, 4, 0, 5, 1, 3], [2, 5, 0, 4, 3, 1],
        [3, 0, 1, 2, 4, 5], [3, 2, 1, 0, 5, 4], [3, 4, 1, 5, 2, 0], [3, 5, 1, 4, 0, 2],
        [4, 0, 5, 2, 1, 3], [4, 1, 5, 3, 2, 0], [4, 2, 5, 0, 3, 1], [4, 3, 5, 1, 0, 2],
        [5, 0, 4, 2, 3, 1], [5, 1, 4, 3, 0, 2], [5, 2, 4, 0, 1, 3], [5, 3, 4, 1, 2, 0]
    ];
    WebMolKit.Stereochemistry = Stereochemistry;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    const CSS_DIALOG = `
    *.wmk-dialog
    {
        font-family: 'Open Sans', sans-serif;
		font-size: 16px;
		color: black;
		user-select: none;
    }
`;
    class Dialog {
        constructor(parent = null) {
            this.minPortionWidth = 80;
            this.maxPortionWidth = 80;
            this.maximumWidth = 0;
            this.maximumHeight = 0;
            this.minPortionHeight = 20;
            this.maxPortionHeight = 0;
            this.topMargin = 50;
            this.title = 'Dialog';
            this.allowScroller = true;
            this.callbackClose = null;
            this.callbackShown = null;
            this.parent = WebMolKit.domLegacy(parent);
            WebMolKit.installInlineCSS('dialog', CSS_DIALOG);
        }
        get obscureBackground() { return $(this.domObscureBackground.el); }
        get obscureForeground() { return $(this.domObscureForeground.el); }
        get panelBoundary() { return $(this.domPanelBoundary.el); }
        get titleDiv() { return $(this.domTitle.el); }
        get titleButtons() { return $(this.domTitleButtons.el); }
        get bodyDiv() { return $(this.domBody.el); }
        get btnClose() { return $(this.domClose.el); }
        onClose(callback) {
            this.callbackClose = callback;
        }
        onShown(callback) {
            this.callbackShown = callback;
        }
        open() {
            let body = this.parent || WebMolKit.dom(document.body);
            let zindex = 20000;
            let bg = this.domObscureBackground = WebMolKit.dom('<div/>').appendTo(body);
            bg.css({ 'position': 'fixed', 'z-index': zindex });
            bg.css({ 'left': '0', 'right': '0', 'top': '0', 'bottom': '0' });
            bg.css({ 'background-color': 'black', 'opacity': 0.8 });
            bg.onClick(() => this.close());
            let fg = this.domObscureForeground = WebMolKit.dom('<div/>').appendTo(body);
            fg.css({ 'position': 'fixed', 'z-index': zindex + 1 });
            fg.css({ 'left': '0', 'right': '0', 'top': '0', 'bottom': '0' });
            let pb = this.domPanelBoundary = WebMolKit.dom('<div class="wmk-dialog"/>').appendTo(fg);
            pb.css({ 'min-width': this.minPortionWidth + '%' });
            if (this.maximumWidth > 0)
                pb.css({ 'max-width': this.maximumWidth + 'px' });
            else if (this.maxPortionWidth != null)
                pb.css({ 'max-width': this.maxPortionWidth + '%' });
            if (this.maximumHeight > 0)
                pb.css({ 'max-height': this.maximumHeight + 'px' });
            else if (this.maxPortionHeight > 0)
                pb.css({ 'max-height': this.maxPortionHeight + 'vh' });
            pb.css({ 'background-color': 'white', 'border-radius': '6px', 'border': '1px solid black' });
            pb.css({ 'position': 'absolute' });
            pb.css({ 'left': (50 - 0.5 * this.minPortionWidth) + '%' });
            pb.css({ 'top': this.topMargin + 'px' });
            pb.css({ 'min-height': this.minPortionHeight + '%' });
            let divOuter = WebMolKit.dom('<div/>').appendTo(pb).css({ 'display': 'flex' });
            divOuter.css({ 'flex-direction': 'column', 'align-items': 'stretch' });
            if (this.maximumHeight > 0)
                divOuter.css({ 'max-height': this.maximumHeight + 'px' });
            else if (this.maxPortionHeight > 0)
                divOuter.css({ 'max-height': this.maxPortionHeight + 'vh' });
            let tdiv = this.domTitle = WebMolKit.dom('<div/>').appendTo(divOuter);
            tdiv.css({ 'flex-shrink': '0', 'flex-grow': '0' });
            tdiv.css({ 'margin': '0', 'padding': '0' });
            tdiv.css({ 'background-color': '#F0F0F0' });
            tdiv.css({ 'background-image': 'linear-gradient(to right bottom, #FFFFFF, #E0E0E0)' });
            tdiv.css({ 'border-bottom': '1px solid #C0C0C0' });
            tdiv.css({ 'border-radius': '6px 6px 0 0' });
            let bdiv = WebMolKit.dom('<div/>').appendTo(divOuter).css({ 'width': '100%' });
            bdiv.css({ 'flex-shrink': '1', 'flex-grow': '0' });
            if (this.allowScroller)
                bdiv.css({ 'overflow-y': 'auto' });
            this.domBody = WebMolKit.dom('<div/>').appendTo(bdiv).css({ 'padding': '0.5em' });
            let ttlTable = WebMolKit.dom('<table/>').appendTo(tdiv), tr = WebMolKit.dom('<tr/>').appendTo(ttlTable);
            ttlTable.attr({ 'width': '100%' });
            let tdTitle = WebMolKit.dom('<td valign="center"/>').appendTo(tr).css({ 'padding': '0.5em' });
            let ttl = WebMolKit.dom('<font/>').appendTo(tdTitle).css({ 'font-size': '1.5em', 'font-weight': '600' });
            ttl.setText(this.title);
            let tdButtons = this.domTitleButtons = WebMolKit.dom('<td align="right" valign="center"/>').appendTo(tr).css({ 'padding': '0.5em' });
            this.domClose = WebMolKit.dom('<button class="wmk-button wmk-button-default">Close</button>').appendTo(tdButtons);
            this.domClose.onClick(() => this.close());
            this.populate();
            this.repositionSize();
            if (this.callbackShown)
                this.callbackShown(this);
        }
        close() {
            this.domObscureBackground.remove();
            this.domObscureForeground.remove();
            if (this.callbackClose)
                this.callbackClose(this);
        }
        bump() {
            this.repositionSize();
        }
        body() { return this.bodyDiv; }
        buttons() { return this.titleButtons; }
        bodyDOM() { return this.domBody; }
        buttonsDOM() { return this.domTitleButtons; }
        populate() {
            this.bodyDOM().setText('Empty dialog box.');
        }
        repositionSize() {
            let docW = window.innerWidth, dlgW = this.domPanelBoundary.width();
            this.domPanelBoundary.css({ 'left': (0.5 * (docW - dlgW)) + 'px' });
        }
    }
    WebMolKit.Dialog = Dialog;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class EditCompound extends WebMolKit.Dialog {
        constructor(mol, parent = null) {
            super(parent);
            this.mol = mol;
            this.sketcher = new WebMolKit.Sketcher();
            this.proxyClip = null;
            this.proxyMenu = null;
            this.callbackSave = null;
            this.title = 'Edit Compound';
            this.minPortionWidth = 20;
            this.maxPortionWidth = 95;
        }
        onSave(callback) {
            this.callbackSave = callback;
        }
        getMolecule() { return this.sketcher.getMolecule(); }
        getSketcher() { return this.sketcher; }
        defineClipboard(proxy) {
            this.proxyClip = proxy;
            let handler = new WebMolKit.ClipboardProxyHandler();
            handler.copyEvent = (andCut, proxy) => {
                this.sketcher.performCopySelection(andCut);
                return true;
            };
            handler.pasteEvent = (proxy) => {
                this.sketcher.pasteText(proxy.getString());
                return true;
            };
            proxy.pushHandler(handler);
            this.sketcher.defineClipboard(proxy);
        }
        defineContext(proxy) {
            this.proxyMenu = proxy;
            this.sketcher.defineContext(this.proxyMenu);
        }
        close() {
            if (this.proxyClip)
                this.proxyClip.popHandler();
            super.close();
        }
        populate() {
            let buttons = this.buttonsDOM(), body = this.bodyDOM();
            this.btnClear = WebMolKit.dom('<button class="wmk-button wmk-button-default">Clear</button>').appendTo(buttons).css({ 'margin-left': '0.5em' });
            this.btnClear.onClick(() => this.sketcher.clearMolecule());
            this.btnCopy = WebMolKit.dom('<button class="wmk-button wmk-button-default">Copy</button>').appendTo(buttons).css({ 'margin-left': '0.5em' });
            this.btnCopy.onClick(() => this.actionCopy());
            buttons.append(this.domClose);
            this.domClose.css({ 'margin-left': '0.5em' });
            this.btnSave = WebMolKit.dom('<button class="wmk-button wmk-button-primary">Save</button>').appendTo(buttons).css({ 'margin-left': '0.5em' });
            this.btnSave.onClick(() => { if (this.callbackSave)
                this.callbackSave(this); });
            let skw = 800, skh = 650;
            let skdiv = WebMolKit.dom('<div/>').appendTo(body).css({ 'width': `${skw}px`, 'height': `${skh}px` });
            this.sketcher.setSize(skw, skh);
            this.sketcher.defineMolecule(this.mol);
            this.sketcher.setup(() => this.sketcher.render(skdiv));
        }
        actionCopy() {
            this.sketcher.performCopySelection(false);
        }
        actionCut() {
            this.sketcher.performCopySelection(true);
        }
        actionPaste() {
            this.sketcher.performPaste();
        }
        actionUndo() {
            this.sketcher.performUndo();
        }
        actionRedo() {
            this.sketcher.performRedo();
        }
    }
    WebMolKit.EditCompound = EditCompound;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    const ARROWWIDTH = 30;
    const COLCYCLE = ['#89A54E', '#71588F', '#4198AF', '#DB843D', '#93A9CF', '#D19392', '#4572A7', '#AA4643'];
    class MapReaction extends WebMolKit.Dialog {
        constructor(mol1, mol2) {
            super();
            this.callbackSave = null;
            this.scale = 1;
            this.highlighted = [0, 0];
            this.pressed = [0, 0];
            this.mol1 = mol1.clone();
            this.mol2 = mol2.clone();
            this.policy = WebMolKit.RenderPolicy.defaultBlackOnWhite();
            this.policy.data.pointScale = 40;
            this.title = 'Map Reaction Atoms';
            this.minPortionWidth = 20;
            this.maxPortionWidth = 95;
        }
        getMolecule1() { return this.mol1; }
        getMolecule2() { return this.mol2; }
        populate() {
            let buttons = this.buttons(), body = this.body();
            this.btnClear = $('<button class="button button-default">Clear</button>').appendTo(buttons);
            this.btnClear.click(() => this.clearAllMappings());
            buttons.append(' ');
            buttons.append(this.btnClose);
            buttons.append(' ');
            this.btnSave = $('<button class="button button-primary">Save</button>').appendTo(buttons);
            this.btnSave.click(() => { if (this.callbackSave)
                this.callbackSave(this); });
            let measure = new WebMolKit.OutlineMeasurement(0, 0, this.policy.data.pointScale);
            let effects = new WebMolKit.RenderEffects();
            this.layout1 = new WebMolKit.ArrangeMolecule(this.mol1, measure, this.policy, effects);
            this.layout1.arrange();
            this.layout2 = new WebMolKit.ArrangeMolecule(this.mol2, measure, this.policy, effects);
            this.layout2.arrange();
            this.setupPanel();
        }
        setupPanel() {
            let bounds1 = this.layout1.determineBoundary(), w1 = bounds1[2] - bounds1[0], h1 = bounds1[3] - bounds1[1];
            let bounds2 = this.layout2.determineBoundary(), w2 = bounds2[2] - bounds2[0], h2 = bounds2[3] - bounds2[1];
            let maxWidth = 0.9 * $(window).width(), maxHeight = 0.8 * $(window).height();
            this.padding = 1 * this.policy.data.pointScale;
            let scale1 = (maxWidth - ARROWWIDTH) / (w1 + w2 + 4 * this.padding);
            let scale2 = maxHeight / (h1 + 2 * this.padding);
            let scale3 = maxHeight / (bounds2[3] - bounds2[1] + 2 * this.padding);
            this.scale = Math.min(1, Math.min(scale1, Math.min(scale2, scale3)));
            this.canvasW = Math.ceil((w1 + w2 + 4 * this.padding) * this.scale + ARROWWIDTH);
            this.canvasH = Math.ceil((Math.max(h1, h2) + 2 * this.padding) * this.scale);
            this.box1 = new WebMolKit.Box(0, 0, w1 + 2 * this.padding, this.canvasH);
            this.boxArrow = new WebMolKit.Box(this.box1.maxX(), 0, ARROWWIDTH, this.canvasH);
            this.box2 = new WebMolKit.Box(this.boxArrow.maxX(), 0, w2 + 2 * this.padding, this.canvasH);
            this.layout1.squeezeInto(this.box1.x, this.box1.y, this.box1.w, this.box1.h);
            this.layout2.squeezeInto(this.box2.x, this.box2.y, this.box2.w, this.box2.h);
            let div = $('<div></div>').appendTo(this.body());
            div.css('position', 'relative');
            div.css('width', this.canvasW + 'px');
            div.css('height', this.canvasH + 'px');
            let density = WebMolKit.pixelDensity();
            let styleCanvas = 'position: absolute; left: 0; top: 0; width: ' + this.canvasW + 'px; height: ' + this.canvasH + 'px;';
            let styleOverlay = styleCanvas + 'pointer-events: none;';
            this.canvas = WebMolKit.newElement(div, 'canvas', { 'width': this.canvasW * density, 'height': this.canvasH * density, 'style': styleCanvas });
            let ctx = this.canvas.getContext('2d');
            ctx.scale(density, density);
            this.redrawCanvas();
            $(this.canvas).mousedown((event) => { event.preventDefault(); this.mouseDown(event); });
            $(this.canvas).mouseup((event) => this.mouseUp(event));
            $(this.canvas).mouseenter((event) => this.mouseEnter(event));
            $(this.canvas).mouseleave((event) => this.mouseLeave(event));
            $(this.canvas).mousemove((event) => this.mouseMove(event));
            this.drawnMols = WebMolKit.newElement(div, 'canvas', { 'width': this.canvasW * density, 'height': this.canvasH * density, 'style': styleOverlay });
            ctx = this.drawnMols.getContext('2d');
            ctx.scale(density, density);
            let vg1 = new WebMolKit.MetaVector(), vg2 = new WebMolKit.MetaVector();
            new WebMolKit.DrawMolecule(this.layout1, vg1).draw();
            new WebMolKit.DrawMolecule(this.layout2, vg2).draw();
            vg1.renderContext(ctx);
            vg2.renderContext(ctx);
            this.bump();
        }
        redrawCanvas() {
            let ctx = this.canvas.getContext('2d');
            let w = this.canvasW, h = this.canvasH;
            ctx.clearRect(0, 0, w, h);
            let arrowX1 = this.boxArrow.minX(), arrowX2 = this.boxArrow.maxX(), arrowY = this.boxArrow.midY();
            ctx.beginPath();
            ctx.moveTo(arrowX1, arrowY);
            ctx.lineTo(arrowX2 - 2, arrowY);
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(arrowX2, arrowY);
            ctx.lineTo(arrowX2 - 8, arrowY - 5);
            ctx.lineTo(arrowX2 - 8, arrowY + 5);
            ctx.fillStyle = 'black';
            ctx.fill();
            this.drawHighlights(ctx, 1, this.highlighted[0] == 1 ? this.highlighted[1] : 0);
            this.drawHighlights(ctx, 2, this.highlighted[0] == 2 ? this.highlighted[1] : 0);
            if (this.pressed[0] > 0) {
                let compatMask = this.compatibilityMask(this.pressed[0], this.pressed[1]);
                ctx.strokeStyle = '#808080';
                ctx.lineWidth = 1;
                if (this.pressed[0] == 1) {
                    for (let n = 1; n <= this.mol2.numAtoms; n++)
                        if (compatMask[n - 1]) {
                            let [cx, cy, rw, rh] = this.getAtomPos(2, n);
                            ctx.beginPath();
                            ctx.ellipse(cx, cy, rw, rh, 0, 0, WebMolKit.TWOPI, false);
                            ctx.stroke();
                        }
                }
                else {
                    for (let n = 1; n <= this.mol1.numAtoms; n++)
                        if (compatMask[n - 1]) {
                            let [cx, cy, rw, rh] = this.getAtomPos(1, n);
                            ctx.beginPath();
                            ctx.ellipse(cx, cy, rw, rh, 0, 0, WebMolKit.TWOPI, false);
                            ctx.stroke();
                        }
                }
                let [cx1, cy1, rw1, rh1] = this.getAtomPos(this.pressed[0], this.pressed[1]);
                ctx.beginPath();
                ctx.ellipse(cx1, cy1, rw1, rh1, 0, 0, WebMolKit.TWOPI, false);
                ctx.fillStyle = '#808080';
                ctx.fill();
                let dx = this.dragToX, dy = this.dragToY;
                let dest = this.pickAtom(dx, dy, this.pressed[0] == 2 ? compatMask : null, this.pressed[0] == 1 ? compatMask : null);
                if (dest[0] == 3 - this.pressed[0]) {
                    let [cx2, cy2, rw2, rh2] = this.getAtomPos(dest[0], dest[1]);
                    ctx.beginPath();
                    ctx.ellipse(cx2, cy2, rw2, rh2, 0, 0, WebMolKit.TWOPI, false);
                    ctx.fillStyle = '#808080';
                    ctx.fill();
                    dx = cx2;
                    dy = cy2;
                }
                ctx.beginPath();
                ctx.moveTo(cx1, cy1);
                ctx.lineTo(dx, dy);
                ctx.strokeStyle = '#808080';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }
        drawHighlights(ctx, side, highlight) {
            const mol = side == 1 ? this.mol1 : this.mol2;
            const layout = side == 1 ? this.layout1 : this.layout2;
            const offsetX = side == 1 ? this.offsetX1 : this.offsetX2;
            const offsetY = side == 1 ? this.offsetY1 : this.offsetY2;
            const scale = this.scale;
            for (let n = 1; n <= mol.numAtoms; n++) {
                let mapnum = mol.atomMapNum(n);
                if (mapnum == 0 && n != highlight)
                    continue;
                let [cx, cy, rw, rh] = this.getAtomPos(side, n);
                if (mapnum > 0) {
                    let col = COLCYCLE[(mapnum - 1) % COLCYCLE.length];
                    ctx.beginPath();
                    ctx.ellipse(cx, cy, rw, rh, 0, 0, WebMolKit.TWOPI, false);
                    ctx.fillStyle = col;
                    ctx.fill();
                    if (n == highlight) {
                        let oside = 3 - side, omol = side == 1 ? this.mol2 : this.mol1;
                        for (let i = 1; i <= omol.numAtoms; i++)
                            if (omol.atomMapNum(i) == mapnum) {
                                let [dx, dy] = this.getAtomPos(oside, i);
                                ctx.beginPath();
                                ctx.moveTo(cx, cy);
                                ctx.lineTo(dx, dy);
                                ctx.strokeStyle = col;
                                ctx.lineWidth = 1;
                                ctx.stroke();
                            }
                    }
                }
                if (n == highlight) {
                    ctx.beginPath();
                    ctx.ellipse(cx, cy, rw, rh, 0, 0, WebMolKit.TWOPI, false);
                    ctx.strokeStyle = '#404040';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }
        }
        pickAtom(x, y, mask1, mask2) {
            let ret = [0, 0];
            let bestDist = Number.POSITIVE_INFINITY;
            let threshsq = WebMolKit.sqr(this.layout1.getScale() * 1.0 * this.policy.data.pointScale);
            for (let n = 0; n < this.mol1.numAtoms; n++) {
                if (mask1 && !mask1[n])
                    continue;
                let pt = this.layout1.getPoint(n);
                let dsq = WebMolKit.norm2_xy(x - pt.oval.cx, y - pt.oval.cy);
                if (dsq < threshsq && dsq < bestDist) {
                    ret = [1, n + 1];
                    bestDist = dsq;
                }
            }
            threshsq = WebMolKit.sqr(this.layout2.getScale() * 1.0 * this.policy.data.pointScale);
            for (let n = 0; n < this.mol2.numAtoms; n++) {
                if (mask2 && !mask2[n])
                    continue;
                let pt = this.layout2.getPoint(n);
                let dsq = WebMolKit.norm2_xy(x - pt.oval.cx, y - pt.oval.cy);
                if (dsq < threshsq && dsq < bestDist) {
                    ret = [2, n + 1];
                    bestDist = dsq;
                }
            }
            return ret;
        }
        getAtomPos(side, atom) {
            let layout = side == 1 ? this.layout1 : this.layout2;
            let ox = side == 1 ? this.offsetX1 : this.offsetX2, oy = side == 1 ? this.offsetY1 : this.offsetY2;
            let pt = layout.getPoint(atom - 1);
            let rw = Math.max(0.5 * this.policy.data.pointScale, pt.oval.rw) * this.scale, rh = Math.max(0.5 * this.policy.data.pointScale, pt.oval.rh) * this.scale;
            return [pt.oval.cx, pt.oval.cy, rw, rh];
        }
        compatibilityMask(side, atom) {
            let mask = [];
            let mol1 = side == 1 ? this.mol1 : this.mol2, mol2 = side == 1 ? this.mol2 : this.mol1;
            let el = mol1.atomElement(atom), iso = mol1.atomIsotope(atom), map = mol1.atomMapNum(atom);
            for (let n = 1; n <= mol2.numAtoms; n++) {
                let match = el == mol2.atomElement(n) && iso == mol2.atomIsotope(n);
                match = match && (map == 0 || mol2.atomMapNum(n) == 0);
                mask.push(match);
            }
            return mask;
        }
        connectAtoms(side, atom1, atom2) {
            let mol1 = side == 1 ? this.mol1 : this.mol2, mol2 = side == 1 ? this.mol2 : this.mol1;
            let map = mol1.atomMapNum(atom1);
            if (map == 0)
                map = mol2.atomMapNum(atom2);
            if (map == 0) {
                let allnums = new Set();
                for (let n = 1; n <= mol1.numAtoms; n++)
                    allnums.add(mol1.atomMapNum(n));
                for (let n = 1; n <= mol2.numAtoms; n++)
                    allnums.add(mol2.atomMapNum(n));
                for (map = 1; allnums.has(map); map++)
                    ;
            }
            mol1.setAtomMapNum(atom1, map);
            mol2.setAtomMapNum(atom2, map);
        }
        autoConnect() {
        }
        clearAllMappings() {
            let anything = false;
            for (let n = 1; n <= this.mol1.numAtoms; n++)
                if (this.mol1.atomMapNum(n) > 0) {
                    this.mol1.setAtomMapNum(n, 0);
                    anything = true;
                }
            for (let n = 1; n <= this.mol2.numAtoms; n++)
                if (this.mol2.atomMapNum(n) > 0) {
                    this.mol2.setAtomMapNum(n, 0);
                    anything = true;
                }
            if (anything)
                this.redrawCanvas();
        }
        clearMapping(side, atom) {
            let map = side == 1 ? this.mol1.atomMapNum(atom) : this.mol2.atomMapNum(atom);
            if (map == 0)
                return;
            for (let n = 1; n <= this.mol1.numAtoms; n++)
                if (this.mol1.atomMapNum(n) == map)
                    this.mol1.setAtomMapNum(n, 0);
            for (let n = 1; n <= this.mol2.numAtoms; n++)
                if (this.mol2.atomMapNum(n) == map)
                    this.mol2.setAtomMapNum(n, 0);
        }
        mouseDown(event) {
            let xy = WebMolKit.eventCoords(event, this.canvas);
            this.pressed = this.pickAtom(xy[0], xy[1]);
            this.dragToX = xy[0];
            this.dragToY = xy[1];
            this.redrawCanvas();
        }
        mouseUp(event) {
            let xy = WebMolKit.eventCoords(event, this.canvas);
            if (this.pressed[0] > 0) {
                let dest = this.pickAtom(xy[0], xy[1]);
                if (dest[0] == this.pressed[0] && dest[1] == this.pressed[1]) {
                    this.clearMapping(dest[0], dest[1]);
                }
                else {
                    let compatMask = this.compatibilityMask(this.pressed[0], this.pressed[1]);
                    dest = this.pickAtom(xy[0], xy[1], this.pressed[0] == 2 ? compatMask : null, this.pressed[0] == 1 ? compatMask : null);
                    if (dest[0] == 3 - this.pressed[0]) {
                        this.connectAtoms(this.pressed[0], this.pressed[1], dest[1]);
                        this.autoConnect();
                    }
                }
                this.pressed = [0, 0];
            }
            this.highlighted = this.pickAtom(xy[0], xy[1]);
            this.redrawCanvas();
        }
        mouseEnter(event) {
        }
        mouseLeave(event) {
            if (this.highlighted[0] > 0 || this.pressed[0] > 0) {
                this.highlighted = [0, 0];
                this.pressed = [0, 0];
                this.redrawCanvas();
            }
        }
        mouseMove(event) {
            let xy = WebMolKit.eventCoords(event, this.canvas);
            if (this.pressed[0] > 0) {
                this.dragToX = xy[0];
                this.dragToY = xy[1];
                this.redrawCanvas();
            }
            else {
                let high = this.pickAtom(xy[0], xy[1]);
                if (high[0] != this.highlighted[0] || high[1] != this.highlighted[1]) {
                    this.highlighted = high;
                    this.redrawCanvas();
                }
            }
        }
    }
    WebMolKit.MapReaction = MapReaction;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let ArrangeComponentType;
    (function (ArrangeComponentType) {
        ArrangeComponentType[ArrangeComponentType["Arrow"] = 1] = "Arrow";
        ArrangeComponentType[ArrangeComponentType["Plus"] = 2] = "Plus";
        ArrangeComponentType[ArrangeComponentType["Reactant"] = 3] = "Reactant";
        ArrangeComponentType[ArrangeComponentType["Reagent"] = 4] = "Reagent";
        ArrangeComponentType[ArrangeComponentType["Product"] = 5] = "Product";
        ArrangeComponentType[ArrangeComponentType["StepNote"] = 6] = "StepNote";
    })(ArrangeComponentType = WebMolKit.ArrangeComponentType || (WebMolKit.ArrangeComponentType = {}));
    let ArrangeComponentAnnot;
    (function (ArrangeComponentAnnot) {
        ArrangeComponentAnnot[ArrangeComponentAnnot["None"] = 0] = "None";
        ArrangeComponentAnnot[ArrangeComponentAnnot["Primary"] = 1] = "Primary";
        ArrangeComponentAnnot[ArrangeComponentAnnot["Waste"] = 2] = "Waste";
        ArrangeComponentAnnot[ArrangeComponentAnnot["Implied"] = 3] = "Implied";
    })(ArrangeComponentAnnot = WebMolKit.ArrangeComponentAnnot || (WebMolKit.ArrangeComponentAnnot = {}));
    class ArrangeComponent {
        constructor() {
            this.annot = ArrangeComponentAnnot.None;
            this.box = new WebMolKit.Box();
        }
        clone() {
            let dup = new ArrangeComponent();
            dup.type = this.type;
            dup.srcIdx = this.srcIdx;
            dup.step = this.step;
            dup.side = this.side;
            dup.refIdx = this.refIdx;
            dup.mol = this.mol;
            dup.text = this.text;
            dup.leftNumer = this.leftNumer;
            dup.leftDenom = this.leftDenom;
            dup.fszText = this.fszText;
            dup.fszLeft = this.fszLeft;
            dup.annot = this.annot;
            dup.box = this.box.clone();
            dup.padding = this.padding;
            return dup;
        }
    }
    WebMolKit.ArrangeComponent = ArrangeComponent;
    const PADDING = 0.25;
    const PLUSSZ = 0.5;
    const ARROW_W = 2;
    const ARROW_H = 0.5;
    const REAGENT_SCALE = 0.7;
    const PLACEHOLDER_W = 2;
    const PLACEHOLDER_H = 2;
    class ArrangeExperiment {
        constructor(entry, measure, policy) {
            this.entry = entry;
            this.measure = measure;
            this.policy = policy;
            this.width = 0;
            this.height = 0;
            this.components = [];
            this.limitTotalW = 1000;
            this.limitTotalH = 1000;
            this.limitStructW = 0;
            this.limitStructH = 0;
            this.includeReagents = true;
            this.includeNames = false;
            this.includeStoich = true;
            this.includeAnnot = false;
            this.includeBlank = false;
            this.includeDetails = false;
            this.padding = 0;
            this.scale = policy.data.pointScale;
            this.limitStructW = this.limitStructH = this.scale * 10;
            this.padding = PADDING * this.scale;
        }
        arrange() {
            this.createComponents();
            let fszText = this.scale * this.policy.data.fontSize, fszLeft = this.scale * this.policy.data.fontSize * 1.5;
            for (let xc of this.components) {
                if (xc.type == ArrangeComponentType.Plus)
                    xc.box = new WebMolKit.Box(0, 0, this.scale * PLUSSZ, this.scale * PLUSSZ);
                else if (xc.type == ArrangeComponentType.Arrow) { }
                else {
                    let w = 0, h = 0;
                    if (WebMolKit.MolUtil.notBlank(xc.mol)) {
                        let sz = WebMolKit.Size.fromArray(WebMolKit.ArrangeMolecule.guestimateSize(xc.mol, this.policy));
                        if (xc.type == ArrangeComponentType.Reagent)
                            sz.scaleBy(REAGENT_SCALE);
                        if (xc.leftNumer) {
                            xc.fszLeft = fszLeft;
                            let wad = this.measure.measureText(xc.leftNumer, fszLeft);
                            let lw = wad[0], lh = wad[1] + wad[2];
                            if (xc.leftDenom)
                                lw = Math.max(lw, this.measure.measureText(xc.leftDenom, fszLeft)[0]);
                            sz.w += lw + ArrangeExperiment.COMP_GAP_LEFT * lh;
                            sz.h = Math.max(sz.h, lh * (xc.leftDenom ? 2 : 1));
                        }
                        sz.fitInto(this.limitStructW, this.limitStructH);
                        w = sz.w;
                        h = sz.h;
                    }
                    if (WebMolKit.Vec.notBlank(xc.text)) {
                        if (WebMolKit.MolUtil.notBlank(xc.mol))
                            h += 0.5 * fszText;
                        for (let line of xc.text) {
                            xc.fszText = fszText;
                            let wad = this.measure.measureText(line, fszText);
                            w = Math.max(w, wad[0]);
                            h += wad[1] + wad[2];
                        }
                    }
                    if (xc.annot != 0)
                        w += ArrangeExperiment.COMP_ANNOT_SIZE * this.scale;
                    if ((WebMolKit.MolUtil.isBlank(xc.mol) && !xc.text && this.includeBlank) || w == 0 || h == 0) {
                        w = Math.max(w, PLACEHOLDER_W * this.scale);
                        h = Math.max(h, PLACEHOLDER_H * this.scale);
                    }
                    xc.box = new WebMolKit.Box(0, 0, w, h);
                }
                xc.padding = this.padding;
                xc.box = new WebMolKit.Box(0, 0, xc.box.w + 2 * this.padding, xc.box.h + 2 * this.padding);
            }
            let best = null;
            let bestScore = 0;
            for (let bend = this.entry.steps.length + 1; bend >= 1; bend--)
                for (let vert = 0; vert <= 1; vert++) {
                    let trial = [];
                    for (let xc of this.components)
                        trial.push(xc.clone());
                    this.arrangeComponents(trial, bend, vert > 0);
                    let score = this.scoreArrangement(trial);
                    if (best == null || score > bestScore) {
                        best = trial;
                        bestScore = score;
                    }
                }
            this.components = best;
            this.width = this.height = 0;
            for (let xc of this.components) {
                this.width = Math.max(this.width, xc.box.maxX());
                this.height = Math.max(this.height, xc.box.maxY());
            }
        }
        get numComponents() { return this.components.length; }
        getComponent(idx) { return this.components[idx]; }
        getComponents() { return this.components; }
        scaleComponents(modScale) {
            if (modScale == 1)
                return;
            this.scale *= modScale;
            this.width *= modScale;
            this.height *= modScale;
            for (let xc of this.components) {
                xc.box.scaleBy(modScale);
                xc.fszText *= modScale;
                xc.fszLeft *= modScale;
                xc.padding *= modScale;
            }
        }
        static toExpType(compType) {
            if (compType == ArrangeComponentType.Reactant)
                return WebMolKit.ExperimentComponentType.Reactant;
            if (compType == ArrangeComponentType.Reagent)
                return WebMolKit.ExperimentComponentType.Reagent;
            if (compType == ArrangeComponentType.Product)
                return WebMolKit.ExperimentComponentType.Product;
            return null;
        }
        createComponents() {
            for (let n = 0; n < this.entry.steps[0].reactants.length; n++) {
                if (n > 0)
                    this.createSegregator(ArrangeComponentType.Plus, 0, -1);
                this.createReactant(n, 0);
            }
            if (this.components.length == 0 && this.includeBlank)
                this.createBlank(ArrangeComponentType.Reactant, 0);
            for (let s = 0; s < this.entry.steps.length; s++) {
                this.createSegregator(ArrangeComponentType.Arrow, s, 0);
                if (this.includeReagents) {
                    let any = false;
                    for (let n = 0; n < this.entry.steps[s].reagents.length; n++) {
                        this.createReagent(n, s);
                        any = true;
                    }
                    if (!any && this.includeBlank)
                        this.createBlank(ArrangeComponentType.Reagent, s);
                }
                if (this.includeDetails)
                    this.createStepMeta(s);
                let any = false;
                for (let n = 0; n < this.entry.steps[s].products.length; n++) {
                    if (n > 0)
                        this.createSegregator(ArrangeComponentType.Plus, s, 1);
                    this.createProduct(n, s);
                    any = true;
                }
                if (!any && this.includeBlank)
                    this.createBlank(ArrangeComponentType.Product, s);
            }
        }
        createReactant(idx, step) {
            let comp = this.entry.steps[step].reactants[idx];
            let xc = new ArrangeComponent();
            xc.type = ArrangeComponentType.Reactant;
            xc.srcIdx = idx;
            xc.step = step;
            xc.side = -1;
            if (WebMolKit.MolUtil.notBlank(comp.mol))
                xc.mol = comp.mol;
            if (comp.name && (this.includeNames || WebMolKit.MolUtil.isBlank(comp.mol)))
                xc.text = [comp.name];
            if (this.includeDetails)
                this.supplementText(xc, comp);
            if (WebMolKit.MolUtil.notBlank(comp.mol) && this.includeStoich && !WebMolKit.QuantityCalc.isStoichZero(comp.stoich) && !WebMolKit.QuantityCalc.isStoichUnity(comp.stoich)) {
                let slash = comp.stoich.indexOf('/');
                if (slash >= 0) {
                    xc.leftNumer = comp.stoich.substring(0, slash);
                    xc.leftDenom = comp.stoich.substring(slash + 1);
                }
                else
                    xc.leftNumer = comp.stoich;
            }
            if (this.includeAnnot && WebMolKit.MolUtil.notBlank(comp.mol) && comp.primary)
                xc.annot = ArrangeComponentAnnot.Primary;
            this.components.push(xc);
        }
        createReagent(idx, step) {
            let comp = this.entry.steps[step].reagents[idx];
            let xc = new ArrangeComponent();
            xc.type = ArrangeComponentType.Reagent;
            xc.srcIdx = idx;
            xc.step = step;
            xc.side = 0;
            if (WebMolKit.MolUtil.notBlank(comp.mol))
                xc.mol = comp.mol;
            if (comp.name && (this.includeNames || WebMolKit.MolUtil.isBlank(comp.mol)))
                xc.text = [comp.name];
            if (this.includeDetails)
                this.supplementText(xc, comp);
            if (this.includeAnnot) {
                let stoich = WebMolKit.QuantityCalc.impliedReagentStoich(comp, this.entry.steps[step].products);
                if (stoich > 0)
                    xc.annot = ArrangeComponentAnnot.Implied;
                if (stoich > 0 && stoich != 1) {
                    if (WebMolKit.realEqual(stoich, Math.round(stoich)))
                        xc.leftNumer = Math.round(stoich).toString();
                    else
                        xc.leftNumer = stoich.toString();
                }
            }
            this.components.push(xc);
        }
        createProduct(idx, step) {
            let comp = this.entry.steps[step].products[idx];
            let xc = new ArrangeComponent();
            xc.type = ArrangeComponentType.Product;
            xc.srcIdx = idx;
            xc.step = step;
            xc.side = 1;
            if (WebMolKit.MolUtil.notBlank(comp.mol))
                xc.mol = comp.mol;
            if (comp.name && (this.includeNames || WebMolKit.MolUtil.isBlank(comp.mol)))
                xc.text = [comp.name];
            if (this.includeDetails)
                this.supplementText(xc, comp);
            if (this.includeStoich && !WebMolKit.QuantityCalc.isStoichZero(comp.stoich) && !WebMolKit.QuantityCalc.isStoichUnity(comp.stoich)) {
                let slash = comp.stoich.indexOf('/');
                if (slash >= 0) {
                    xc.leftNumer = comp.stoich.substring(0, slash);
                    xc.leftDenom = comp.stoich.substring(slash + 1);
                }
                else
                    xc.leftNumer = comp.stoich;
            }
            if (this.includeAnnot && WebMolKit.MolUtil.notBlank(comp.mol) && comp.waste)
                xc.annot = ArrangeComponentAnnot.Waste;
            this.components.push(xc);
        }
        createSegregator(type, step, side) {
            let xc = new ArrangeComponent();
            xc.type = type;
            xc.step = step;
            xc.side = side;
            this.components.push(xc);
        }
        createStepMeta(step) {
            let lines = [];
            for (let [type, value] of WebMolKit.ExperimentMeta.unpackMeta(this.entry.steps[step].meta)) {
                if (!WebMolKit.Vec.safeArray(WebMolKit.ExperimentMeta.APPLICABILITY[type]).includes(WebMolKit.ExperimentMetaApplic.Step))
                    continue;
                let descr = WebMolKit.ExperimentMeta.describeMeta(type, value);
                if (descr != null)
                    lines.push(descr);
            }
            if (lines.length == 0)
                return;
            let xc = new ArrangeComponent();
            xc.type = ArrangeComponentType.StepNote;
            xc.step = step;
            xc.side = 0;
            xc.text = lines;
            this.components.push(xc);
        }
        createBlank(type, step) {
            let xc = new ArrangeComponent();
            xc.type = type;
            xc.step = step;
            xc.side = type == ArrangeComponentType.Reactant ? -1 : type == ArrangeComponentType.Product ? 1 : 0;
            xc.srcIdx = -1;
            this.components.push(xc);
        }
        arrangeComponents(comps, bendStep, vertComp) {
            let blkMain = [];
            let blkArrow = [];
            let szMain = [], szArrow = [];
            let midMain = [], midArrow = [];
            blkMain.push(this.gatherBlock(comps, 0, -1));
            szMain.push(this.arrangeMainBlock(blkMain[0], vertComp));
            midMain.push(this.findMidBlock(blkMain[0], szMain[0]));
            for (let n = 0; n < this.entry.steps.length; n++) {
                let bent = n + 1 >= bendStep;
                blkMain.push(this.gatherBlock(comps, n, 1));
                szMain.push(this.arrangeMainBlock(blkMain[n + 1], vertComp && !bent));
                midMain.push(this.findMidBlock(blkMain[n + 1], szMain[n + 1]));
                blkArrow.push(this.gatherBlock(comps, n, 0));
                if (!bent)
                    szArrow.push(this.arrangeHorizontalArrowBlock(blkArrow[n]));
                else
                    szArrow.push(this.arrangeVerticalArrowBlock(blkArrow[n]));
                midArrow.push(this.findMidBlock(blkArrow[n], szArrow[n]));
            }
            let midH = 0;
            for (let n = 0; n < bendStep; n++) {
                midH = Math.max(midH, midMain[n].y);
                if (n > 0)
                    midH = Math.max(midH, midArrow[n - 1].y);
            }
            let sz = WebMolKit.Size.zero();
            for (let n = 0; n < bendStep; n++) {
                sz.w += szMain[n].w;
                sz.h = Math.max(sz.h, midH + (szMain[n].h - midMain[n].y));
                if (n > 0) {
                    sz.w += szArrow[n - 1].w;
                    sz.h = Math.max(sz.h, midH + (szArrow[n - 1].h - midArrow[n - 1].y));
                }
            }
            let x = 0, arrowX = 0;
            for (let n = 0; n < bendStep; n++) {
                if (n > 0) {
                    this.originateBlock(blkArrow[n - 1], x, midH - midArrow[n - 1].y);
                    x += szArrow[n - 1].w;
                }
                this.originateBlock(blkMain[n], x, midH - midMain[n].y);
                arrowX = x + midMain[n].x;
                x += szMain[n].w;
            }
            let y = sz.h, lowX = 0;
            for (let n = bendStep; n <= this.entry.steps.length; n++) {
                x = arrowX - midArrow[n - 1].x;
                lowX = Math.min(lowX, x);
                this.originateBlock(blkArrow[n - 1], x, y);
                y += szArrow[n - 1].h;
                sz.w = Math.max(sz.w, x + szArrow[n - 1].w);
                x = arrowX - midMain[n].x;
                lowX = Math.min(lowX, x);
                this.originateBlock(blkMain[n], x, y);
                y += szMain[n].h;
                sz.w = Math.max(sz.w, x + szMain[n].w);
            }
            if (lowX < 0) {
                for (let xc of comps)
                    xc.box.x -= lowX;
            }
        }
        gatherBlock(comps, step, side) {
            let block = [];
            for (let xc of comps)
                if (xc.side == side && xc.step == step)
                    block.push(xc);
            return block;
        }
        arrangeMainBlock(block, vertComp) {
            let sz = WebMolKit.Size.zero();
            if (!vertComp) {
                for (let xc of block) {
                    sz.w += xc.box.w;
                    sz.h = Math.max(sz.h, xc.box.h);
                }
            }
            else {
                for (let xc of block) {
                    sz.w = Math.max(sz.w, xc.box.w);
                    sz.h += xc.box.h;
                }
            }
            sz.w = Math.max(sz.w, this.scale * 2.0);
            sz.h = Math.max(sz.h, this.scale * 2.0);
            if (!vertComp) {
                let x = 0;
                for (let xc of block) {
                    xc.box.x = x;
                    xc.box.y = 0.5 * (sz.h - xc.box.h);
                    x += xc.box.w;
                }
            }
            else {
                let y = 0;
                for (let xc of block) {
                    xc.box.x = 0.5 * (sz.w - xc.box.w);
                    xc.box.y = y;
                    y += xc.box.h;
                }
            }
            return sz;
        }
        arrangeHorizontalArrowBlock(block) {
            let arrow = null;
            for (let xc of block)
                if (xc.type == ArrangeComponentType.Arrow) {
                    arrow = xc;
                    xc.box.w = ARROW_W * this.scale + 2 * xc.padding;
                    xc.box.h = ARROW_H * this.scale + 2 * xc.padding;
                }
            let mid = block.length >> 1;
            for (let xc of block)
                arrow.box.w = Math.max(xc.box.w, arrow.box.w);
            let sz = WebMolKit.Size.zero();
            let n = 0;
            let y = 0;
            let arrowPlaced = false;
            for (let xc of block)
                if (xc.type != ArrangeComponentType.Arrow) {
                    xc.box.x = 0.5 * (arrow.box.w - xc.box.w);
                    xc.box.y = y;
                    y += xc.box.h;
                    n++;
                    if (n == mid) {
                        arrow.box.x = 0;
                        arrow.box.y = y;
                        y += arrow.box.h;
                        arrowPlaced = true;
                    }
                }
            if (!arrowPlaced) {
                arrow.box.x = 0;
                arrow.box.y = y;
                y += arrow.box.h;
            }
            sz.w = arrow.box.w;
            sz.h = y;
            return sz;
        }
        arrangeVerticalArrowBlock(block) {
            let arrow = null;
            for (let xc of block)
                if (xc.type == ArrangeComponentType.Arrow) {
                    arrow = xc;
                    xc.box.w = ARROW_H * this.scale + 2 * xc.padding;
                    xc.box.h = ARROW_W * this.scale + 2 * xc.padding;
                }
            let mid = block.length >> 1;
            let sz1 = WebMolKit.Size.zero(), sz2 = WebMolKit.Size.zero();
            let n = 0;
            for (let xc of block)
                if (xc.type != ArrangeComponentType.Arrow) {
                    if (n < mid) {
                        sz1.w = Math.max(sz1.w, xc.box.w);
                        sz1.h += xc.box.h;
                    }
                    else {
                        sz2.w = Math.max(sz2.w, xc.box.w);
                        sz2.h += xc.box.h;
                    }
                    n++;
                }
            let sz = new WebMolKit.Size(sz1.w + sz2.w + arrow.box.w, Math.max(arrow.box.h, Math.max(sz1.h, sz2.h)));
            arrow.box = new WebMolKit.Box(sz1.w, 0, arrow.box.w, sz.h);
            let y1 = 0.5 * (sz.h - sz1.h), y2 = 0.5 * (sz.h - sz2.h);
            n = 0;
            for (let xc of block)
                if (xc.type != ArrangeComponentType.Arrow) {
                    if (n < mid) {
                        xc.box.x = sz1.w - xc.box.w;
                        xc.box.y = y1;
                        y1 += xc.box.h;
                    }
                    else {
                        xc.box.x = sz.w - sz2.w;
                        xc.box.y = y2;
                        y2 += xc.box.h;
                    }
                    n++;
                }
            return sz;
        }
        findMidBlock(block, sz) {
            let count = 0;
            let mid = WebMolKit.Pos.zero();
            for (let xc of block)
                if (xc.type == ArrangeComponentType.Plus || xc.type == ArrangeComponentType.Arrow) {
                    mid.x += xc.box.midX();
                    mid.y += xc.box.midY();
                    count++;
                }
            if (count == 0) {
                mid.x = 0.5 * sz.w;
                mid.y = 0.5 * sz.h;
            }
            else if (count > 1) {
                let inv = 1.0 / count;
                mid.x *= inv;
                mid.y *= inv;
            }
            return mid;
        }
        scoreArrangement(comps) {
            let w = 0;
            for (let xc of comps)
                w = Math.max(w, xc.box.maxX());
            let score = 0;
            score -= Math.abs(w - this.limitTotalW);
            return score;
        }
        originateBlock(block, x, y) {
            for (let xc of block) {
                xc.box.x += x;
                xc.box.y += y;
            }
        }
        supplementText(xc, comp) {
            if (!xc.text)
                xc.text = [];
            if (comp.mass > 0)
                xc.text.push(WebMolKit.QuantityCalc.formatMass(comp.mass));
            if (comp.volume > 0)
                xc.text.push(WebMolKit.QuantityCalc.formatVolume(comp.volume));
            if (comp.moles > 0)
                xc.text.push(WebMolKit.QuantityCalc.formatMoles(comp.moles));
            if (comp.conc > 0)
                xc.text.push(WebMolKit.QuantityCalc.formatConc(comp.conc));
            if (comp.yield != null && comp.yield >= 0)
                xc.text.push(WebMolKit.QuantityCalc.formatPercent(comp.yield));
            if (comp.equiv > 0)
                xc.text.push(WebMolKit.QuantityCalc.formatEquiv(comp.equiv));
            for (let [type, value] of WebMolKit.ExperimentMeta.unpackMeta(comp.meta)) {
                let descr = WebMolKit.ExperimentMeta.describeMeta(type, value);
                if (descr)
                    xc.text.push(descr);
            }
        }
    }
    ArrangeExperiment.COMP_GAP_LEFT = 0.5;
    ArrangeExperiment.COMP_ANNOT_SIZE = 1;
    WebMolKit.ArrangeExperiment = ArrangeExperiment;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class OutlineMeasurement {
        constructor(offsetX, offsetY, pointScale) {
            this.offsetX = offsetX;
            this.offsetY = offsetY;
            this.pointScale = pointScale;
            this.invScale = 1 / pointScale;
        }
        scale() { return this.pointScale; }
        angToX(ax) { return ax * this.pointScale + this.offsetX; }
        angToY(ay) { return ay * -this.pointScale + this.offsetY; }
        xToAng(px) { return (px - this.offsetX) * this.invScale; }
        yToAng(py) { return (py - this.offsetY) * -this.invScale; }
        yIsUp() { return false; }
        measureText(str, fontSize) { return WebMolKit.FontData.main.measureText(str, fontSize); }
    }
    WebMolKit.OutlineMeasurement = OutlineMeasurement;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let BLineType;
    (function (BLineType) {
        BLineType[BLineType["Normal"] = 1] = "Normal";
        BLineType[BLineType["Inclined"] = 2] = "Inclined";
        BLineType[BLineType["Declined"] = 3] = "Declined";
        BLineType[BLineType["Unknown"] = 4] = "Unknown";
        BLineType[BLineType["Dotted"] = 5] = "Dotted";
        BLineType[BLineType["DotDir"] = 6] = "DotDir";
        BLineType[BLineType["IncDouble"] = 7] = "IncDouble";
        BLineType[BLineType["IncTriple"] = 8] = "IncTriple";
        BLineType[BLineType["IncQuadruple"] = 9] = "IncQuadruple";
    })(BLineType = WebMolKit.BLineType || (WebMolKit.BLineType = {}));
    const MINBOND_LINE = 0.25;
    const MINBOND_EXOTIC = 0.5;
    class ArrangeMolecule {
        constructor(mol, measure, policy, effects = new WebMolKit.RenderEffects()) {
            this.mol = mol;
            this.measure = measure;
            this.policy = policy;
            this.effects = effects;
            this.points = [];
            this.lines = [];
            this.rings = [];
            this.paths = [];
            this.space = [];
            this.wantArtifacts = true;
            this.artifacts = null;
            this.bondOrder = [];
            this.atomCharge = [];
            this.atomUnpaired = [];
            this.artifactCharge = new Map();
            this.artifactUnpaired = new Map();
            this.artifactFract = new Map();
        }
        static guestimateSize(mol, policy, maxW, maxH) {
            let box = mol.boundary();
            let minX = box.minX(), minY = box.minY(), maxX = box.maxX(), maxY = box.maxY();
            let fontSize = policy.data.fontSize * this.FONT_CORRECT;
            for (let n = 1; n <= mol.numAtoms; n++)
                if (mol.atomExplicit(n)) {
                    let numsym = 0;
                    for (let ch of mol.atomElement(n))
                        if (!'|{}^'.includes(ch))
                            numsym++;
                    let plusH = mol.atomHydrogens(n) > 0 ? 1 : 0;
                    const aw = 0.5 * 0.7 * fontSize * (numsym + plusH);
                    const ah = 0.5 * fontSize * (1 + plusH);
                    const ax = mol.atomX(n), ay = mol.atomY(n);
                    minX = Math.min(minX, ax - aw);
                    maxX = Math.max(maxX, ax + aw);
                    minY = Math.min(minY, ay - ah);
                    maxY = Math.max(maxY, ay + ah);
                }
            let w = Math.max(1, (maxX - minX)) * policy.data.pointScale;
            let h = Math.max(1, (maxY - minY)) * policy.data.pointScale;
            if (maxW > 0 && w > maxW) {
                h *= maxW / w;
                w = maxW;
            }
            if (maxH > 0 && h > maxH) {
                w *= maxH / h;
                h = maxH;
            }
            return [w, h];
        }
        getMolecule() { return this.mol; }
        getMeasure() { return this.measure; }
        getPolicy() { return this.policy; }
        getEffects() { return this.effects; }
        getScale() { return this.scale; }
        setWantArtifacts(want) { this.wantArtifacts = want; }
        getArtifacts() { return this.artifacts; }
        setArtifacts(artifacts) { this.artifacts = artifacts; }
        arrange() {
            const { mol, measure, policy, effects } = this;
            this.scale = measure.scale();
            this.bondSepPix = policy.data.bondSep * measure.scale();
            this.lineSizePix = policy.data.lineSize * measure.scale();
            this.fontSizePix = policy.data.fontSize * measure.scale() * ArrangeMolecule.FONT_CORRECT;
            this.ymul = measure.yIsUp() ? -1 : 1;
            let artmask = null;
            if (this.wantArtifacts && this.artifacts == null) {
                this.artifacts = new WebMolKit.BondArtifact(mol);
                artmask = WebMolKit.Vec.booleanArray(false, mol.numAtoms);
                for (let path of this.artifacts.getResPaths())
                    for (let a of path.atoms)
                        artmask[a - 1] = true;
                for (let ring of this.artifacts.getResRings())
                    for (let a of ring.atoms)
                        artmask[a - 1] = true;
                for (let arene of this.artifacts.getArenes()) {
                    artmask[arene.centre - 1] = true;
                    for (let a of arene.atoms)
                        artmask[a - 1] = true;
                }
            }
            this.setupBondOrders();
            for (let n = 1; n <= mol.numAtoms; n++) {
                if (mol.atomElement(n).length > 2 && mol.atomHydrogens(n) == 0) {
                    this.points.push(null);
                    this.space.push(null);
                    continue;
                }
                let a = {
                    'anum': n,
                    'text': mol.atomExplicit(n) || this.atomIsWeirdLinear(n) ? mol.atomElement(n) : null,
                    'fsz': this.fontSizePix,
                    'bold': mol.atomMapNum(n) > 0,
                    'col': this.policy.data.atomCols[mol.atomicNumber(n)],
                    'oval': new WebMolKit.Oval(this.measure.angToX(mol.atomX(n)), this.measure.angToY(mol.atomY(n)), 0, 0)
                };
                let overCol = this.effects.colAtom[n];
                if (overCol)
                    a.col = overCol;
                if (artmask && artmask[n - 1] && mol.atomElement(n) == 'C')
                    a.text = null;
                if (a.text != null) {
                    let wad = this.measure.measureText(a.text, a.fsz);
                    const PADDING = 1.1;
                    a.oval.rw = 0.5 * wad[0] * PADDING;
                    a.oval.rh = 0.5 * wad[1] * PADDING;
                }
                this.points.push(a);
                this.space.push(this.computeSpacePoint(a));
            }
            for (let n = 1; n <= mol.numAtoms; n++)
                if (this.points[n - 1] == null)
                    this.processLabel(n);
            let bdbl = WebMolKit.Vec.booleanArray(false, mol.numBonds);
            for (let n = 1; n <= mol.numBonds; n++) {
                let bfr = mol.bondFrom(n), bto = mol.bondTo(n);
                let bt = mol.bondType(n), bo = this.bondOrder[n - 1];
                if (bo < 0)
                    continue;
                let col = this.effects.colBond[n];
                if (!col)
                    col = this.policy.data.foreground;
                bdbl[n - 1] = bo == 2 && (bt == WebMolKit.Molecule.BONDTYPE_NORMAL || bt == WebMolKit.Molecule.BONDTYPE_UNKNOWN);
                let a1 = this.points[bfr - 1], a2 = this.points[bto - 1];
                let x1 = a1.oval.cx, y1 = a1.oval.cy, x2 = a2.oval.cx, y2 = a2.oval.cy;
                if (Math.abs(x2 - x1) <= 1 && Math.abs(y2 - y1) <= 1) {
                    bdbl[n - 1] = false;
                    continue;
                }
                if (bdbl[n - 1])
                    continue;
                let minDist = (bo == 1 && bt == WebMolKit.Molecule.BONDTYPE_NORMAL ? MINBOND_LINE : MINBOND_EXOTIC) * measure.scale();
                let xy1 = this.backOffAtom(bfr, x1, y1, x2, y2, minDist);
                let xy2 = this.backOffAtom(bto, x2, y2, x1, y1, minDist);
                this.ensureMinimumBondLength(xy1, xy2, x1, y1, x2, y2, minDist);
                let sz = this.lineSizePix, head = 0;
                let ltype = BLineType.Normal;
                if (bo == 1 && bt == WebMolKit.Molecule.BONDTYPE_INCLINED) {
                    ltype = BLineType.Inclined;
                    head = 0.15 * measure.scale();
                }
                else if (bo == 1 && bt == WebMolKit.Molecule.BONDTYPE_DECLINED) {
                    ltype = BLineType.Declined;
                    head = 0.15 * measure.scale();
                }
                else if (bt == WebMolKit.Molecule.BONDTYPE_UNKNOWN) {
                    ltype = BLineType.Unknown;
                    head = 0.2 * measure.scale();
                }
                else if (bo == 0) {
                    if (bt == WebMolKit.Molecule.BONDTYPE_INCLINED || bt == WebMolKit.Molecule.BONDTYPE_DECLINED)
                        ltype = BLineType.DotDir;
                    else
                        ltype = BLineType.Dotted;
                }
                else if ((bo == 2 || bo == 3 || bo == 4) && (bt == WebMolKit.Molecule.BONDTYPE_INCLINED || bt == WebMolKit.Molecule.BONDTYPE_DECLINED)) {
                    ltype = bo == 2 ? BLineType.IncDouble : bo == 3 ? BLineType.IncTriple : BLineType.IncQuadruple;
                    head = (bo == 2 ? 0.20 : 0.25) * measure.scale();
                }
                if (bo == 0) {
                    let dx = xy2[0] - xy1[0], dy = xy2[1] - xy1[1];
                    let d = WebMolKit.norm_xy(dx, dy), invD = 1 / d;
                    let ox = 0.5 * dx * invD * this.bondSepPix, oy = 0.5 * dy * invD * this.bondSepPix;
                    if (mol.atomAdjCount(bfr) > 1) {
                        xy1[0] += ox;
                        xy1[1] += oy;
                    }
                    if (mol.atomAdjCount(bto) > 1) {
                        xy2[0] -= ox;
                        xy2[1] -= oy;
                    }
                }
                if (bo != 1 && bt == WebMolKit.Molecule.BONDTYPE_DECLINED)
                    [xy1, xy2] = [xy2, xy1];
                if (bo > 1 && (bt == WebMolKit.Molecule.BONDTYPE_NORMAL || bt == WebMolKit.Molecule.BONDTYPE_UNKNOWN)) {
                    let oxy = this.orthogonalDelta(xy1[0], xy1[1], xy2[0], xy2[1], this.bondSepPix);
                    let v = -0.5 * (bo - 1);
                    for (let i = 0; i < bo; i++, v++) {
                        let lx1 = xy1[0] + v * oxy[0], ly1 = xy1[1] + v * oxy[1], lx2 = xy2[0] + v * oxy[0], ly2 = xy2[1] + v * oxy[1];
                        let b = {
                            'bnum': n,
                            'bfr': bfr,
                            'bto': bto,
                            'type': ltype,
                            'line': new WebMolKit.Line(lx1, ly1, lx2, ly2),
                            'size': sz,
                            'head': head,
                            'col': col
                        };
                        this.lines.push(b);
                        this.space.push(this.computeSpaceLine(b));
                    }
                }
                else {
                    let b = {
                        'bnum': n,
                        'bfr': bfr,
                        'bto': bto,
                        'type': ltype,
                        'line': new WebMolKit.Line(xy1[0], xy1[1], xy2[0], xy2[1]),
                        'size': sz,
                        'head': head,
                        'col': col
                    };
                    this.lines.push(b);
                    this.space.push(this.computeSpaceLine(b));
                }
            }
            let rings = this.orderedRingList();
            for (let i = 0; i < rings.length; i++) {
                for (let j = 0; j < rings[i].length; j++) {
                    let k = mol.findBond(rings[i][j], rings[i][j < rings[i].length - 1 ? j + 1 : 0]);
                    if (bdbl[k - 1]) {
                        this.processDoubleBond(k, rings[i]);
                        bdbl[k - 1] = false;
                    }
                }
            }
            for (let i = 1; i <= mol.numBonds; i++)
                if (bdbl[i - 1])
                    this.processDoubleBond(i, this.priorityDoubleSubstit(i));
            let hcount = WebMolKit.Vec.numberArray(0, mol.numAtoms);
            for (let n = 1; n <= mol.numAtoms; n++)
                hcount[n - 1] = this.points[n - 1].text == null ? 0 : mol.atomHydrogens(n);
            for (let n = 0; n < mol.numAtoms; n++)
                if (hcount[n] > 0 && this.placeHydrogen(n, hcount[n], true))
                    hcount[n] = 0;
            for (let n = 0; n < mol.numAtoms; n++)
                if (hcount[n] > 0)
                    this.placeHydrogen(n, hcount[n], false);
            for (let n = 1; n <= mol.numAtoms; n++)
                if (mol.atomIsotope(n) != WebMolKit.Molecule.ISOTOPE_NATURAL) {
                    let isostr = mol.atomIsotope(n).toString();
                    let col = policy.data.atomCols[mol.atomicNumber(n)];
                    this.placeAdjunct(n, isostr, this.fontSizePix * 0.6, col, 150 * WebMolKit.DEGRAD);
                }
            for (let n = 1; n <= mol.numAtoms; n++) {
                let str = '';
                let chg = this.atomCharge[n - 1];
                if (chg == -1)
                    str = '-';
                else if (chg == 1)
                    str = '+';
                else if (chg < -1)
                    str = Math.abs(chg) + '-';
                else if (chg > 1)
                    str = chg + '+';
                for (let i = this.atomUnpaired[n - 1]; i > 0; i--)
                    str += '.';
                if (str.length == 0)
                    continue;
                let col = policy.data.atomCols[mol.atomicNumber(n)];
                this.placeAdjunct(n, str, str.length == 1 ? 0.8 * this.fontSizePix : 0.6 * this.fontSizePix, col, 30 * WebMolKit.DEGRAD);
            }
            for (let n = 0; n < effects.atomDecoText.length; n++) {
                let txt = effects.atomDecoText[n];
                if (!txt)
                    continue;
                this.annotateAtom(n + 1, txt, effects.atomDecoCol[n], effects.atomDecoSize[n] * this.scale * ArrangeMolecule.FONT_CORRECT);
            }
            for (let n = 0; n < effects.bondDecoText.length; n++) {
                let txt = effects.bondDecoText[n];
                if (!txt)
                    continue;
                this.annotateBond(n + 1, txt, effects.bondDecoCol[n], effects.bondDecoSize[n] * this.scale * ArrangeMolecule.FONT_CORRECT);
            }
            for (let n = 0; n < Math.min(effects.atomCircleSz.length, mol.numAtoms); n++)
                if (effects.atomCircleSz[n] > 0) {
                    let dw = effects.atomCircleSz[n] * this.scale;
                    let a = this.points[n];
                    let box = new WebMolKit.Box(a.oval.cx - dw, a.oval.cy - dw, 2 * dw, 2 * dw);
                    let spc = {
                        'anum': 0,
                        'bnum': 0,
                        'box': box,
                        'px': [box.minX(), box.maxX(), box.maxX(), box.minX()],
                        'py': [box.minY(), box.minY(), box.maxY(), box.maxY()]
                    };
                    this.space.push(spc);
                }
            if (this.artifacts != null) {
                for (let path of this.artifacts.getResPaths()) {
                    this.createCurvedPath(path.atoms, this.artifactFract.get(path), 0);
                    this.delocalisedAnnotation(path.atoms, this.artifactCharge.get(path), this.artifactUnpaired.get(path));
                }
                for (let ring of this.artifacts.getResRings()) {
                    this.createCircularRing(ring.atoms);
                    this.delocalisedAnnotation(ring.atoms, this.artifactCharge.get(ring), this.artifactUnpaired.get(ring));
                }
                for (let arene of this.artifacts.getArenes()) {
                    let isRing = arene.atoms.length > 2;
                    if (isRing)
                        for (let n = 0; n < arene.atoms.length; n++) {
                            let nn = n < arene.atoms.length - 1 ? n + 1 : 0;
                            if (mol.findBond(arene.atoms[n], arene.atoms[nn]) == 0) {
                                isRing = false;
                                break;
                            }
                        }
                    this.createBondCentroid(arene.centre, arene.atoms);
                    if (isRing)
                        this.createCircularRing(arene.atoms);
                    else
                        this.createCurvedPath(arene.atoms, false, arene.centre);
                    this.delocalisedAnnotation(arene.atoms, this.artifactCharge.get(arene), this.artifactUnpaired.get(arene));
                }
            }
            let polymers = new WebMolKit.PolymerBlock(mol);
            for (let id of polymers.getIDList())
                this.processPolymerUnit(polymers.getUnit(id), polymers.getUnits());
        }
        numPoints() { return this.points.length; }
        getPoint(idx) { return this.points[idx]; }
        getPoints() { return this.points; }
        numLines() { return this.lines.length; }
        getLine(idx) { return this.lines[idx]; }
        getLines() { return this.lines; }
        numRings() { return this.rings.length; }
        getRing(idx) { return this.rings[idx]; }
        getRings() { return this.rings; }
        numPaths() { return this.paths.length; }
        getPath(idx) { return this.paths[idx]; }
        getPaths() { return this.paths; }
        numSpace() { return this.space.length; }
        getSpace(idx) { return this.space[idx]; }
        getSpaces() { return this.space; }
        offsetEverything(dx, dy) {
            for (let a of this.points)
                a.oval.offsetBy(dx, dy);
            for (let b of this.lines)
                b.line.offsetBy(dx, dy);
            for (let r of this.rings) {
                r.cx += dx;
                r.cy += dy;
            }
            for (let p of this.paths) {
                WebMolKit.Vec.addTo(p.px, dx);
                WebMolKit.Vec.addTo(p.py, dy);
            }
            for (let spc of this.space) {
                spc.box.offsetBy(dx, dy);
                WebMolKit.Vec.addTo(spc.px, dx);
                WebMolKit.Vec.addTo(spc.py, dy);
            }
        }
        offsetOrigin() {
            let bounds = this.determineBoundary();
            if (bounds[0] != 0 || bounds[1] != 0)
                this.offsetEverything(-bounds[0], -bounds[1]);
        }
        scaleEverything(scaleBy) {
            if (scaleBy == 1)
                return;
            this.scale *= scaleBy;
            for (let a of this.points) {
                a.oval.scaleBy(scaleBy);
                a.fsz *= scaleBy;
            }
            for (let b of this.lines) {
                b.line.scaleBy(scaleBy);
                b.size *= scaleBy;
                b.head *= scaleBy;
            }
            for (let r of this.rings) {
                r.cx *= scaleBy;
                r.cy *= scaleBy;
                r.rw *= scaleBy;
                r.rh *= scaleBy;
                r.size *= scaleBy;
            }
            for (let p of this.paths) {
                WebMolKit.Vec.mulBy(p.px, scaleBy);
                WebMolKit.Vec.mulBy(p.py, scaleBy);
                p.size *= scaleBy;
            }
            for (let spc of this.space) {
                spc.box.scaleBy(scaleBy);
                WebMolKit.Vec.mulBy(spc.px, scaleBy);
                WebMolKit.Vec.mulBy(spc.py, scaleBy);
            }
        }
        determineBoundary(padding) {
            if (padding == null)
                padding = 0;
            if (this.space.length == 0)
                return [0, 0, 2 * padding, 2 * padding];
            let bounds = WebMolKit.Vec.numberArray(0, 4);
            let spc = this.space[0];
            bounds[0] = spc.box.x;
            bounds[1] = spc.box.y;
            bounds[2] = spc.box.x + spc.box.w;
            bounds[3] = spc.box.y + spc.box.h;
            for (let n = this.space.length - 1; n > 0; n--) {
                spc = this.space[n];
                bounds[0] = Math.min(bounds[0], spc.box.x);
                bounds[1] = Math.min(bounds[1], spc.box.y);
                bounds[2] = Math.max(bounds[2], spc.box.x + spc.box.w);
                bounds[3] = Math.max(bounds[3], spc.box.y + spc.box.h);
            }
            return bounds;
        }
        determineBoundaryBox() {
            let [x1, y1, x2, y2] = this.determineBoundary();
            return new WebMolKit.Box(x1, y1, x2 - x1, y2 - y1);
        }
        squeezeInto(x, y, w, h, padding) {
            if (padding != null && padding > 0) {
                x += padding;
                y += padding;
                w -= 2 * padding;
                h -= 2 * padding;
            }
            let bounds = this.determineBoundary(0);
            let bw = bounds[2] - bounds[0], bh = bounds[3] - bounds[1];
            if (bw > w || bh > h) {
                let downScale = 1;
                if (bw > w)
                    downScale = w / bw;
                if (bh > h)
                    downScale = Math.min(downScale, h / bh);
                this.scaleEverything(downScale);
                WebMolKit.Vec.mulBy(bounds, downScale);
            }
            this.offsetEverything(x - bounds[0] + 0.5 * (w - bounds[2] + bounds[0]), y - bounds[1] + 0.5 * (h - bounds[3] + bounds[1]));
        }
        limitBounds(w, h) {
            let bounds = this.determineBoundary(0);
            if (bounds[0] == bounds[2] && bounds[1] == bounds[3])
                return;
            let scale = Math.min(1, Math.min(w / (bounds[2] - bounds[0]), h / (bounds[3] - bounds[1])));
            this.offsetEverything(-bounds[0], -bounds[1]);
            this.scaleEverything(scale);
        }
        monochromate(col) {
            for (let a of this.points)
                a.col = col;
            for (let b of this.lines)
                b.col = col;
        }
        clone() {
            let dup = new ArrangeMolecule(this.mol, this.measure, this.policy, this.effects);
            dup.scale = this.scale;
            dup.bondSepPix = this.bondSepPix;
            dup.lineSizePix = this.lineSizePix;
            dup.fontSizePix = this.fontSizePix;
            dup.ymul = this.ymul;
            for (let a of this.points)
                dup.points.push(WebMolKit.clone(a));
            for (let b of this.lines)
                dup.lines.push(WebMolKit.clone(b));
            for (let s of this.space)
                dup.space.push(WebMolKit.clone(s));
            return dup;
        }
        setupBondOrders() {
            const mol = this.mol;
            for (let n = 0; n < mol.numBonds; n++)
                this.bondOrder[n] = mol.bondOrder(n + 1);
            for (let n = 0; n < mol.numAtoms; n++) {
                this.atomCharge[n] = mol.atomCharge(n + 1);
                this.atomUnpaired[n] = mol.atomUnpaired(n + 1);
            }
            let delocalise = (obj, atoms) => {
                let charge = 0, unpaired = 0;
                for (let a of atoms) {
                    charge += this.atomCharge[a - 1];
                    unpaired += this.atomUnpaired[a - 1];
                    this.atomCharge[a - 1] = this.atomUnpaired[a - 1] = 0;
                }
                this.artifactCharge.set(obj, charge);
                this.artifactUnpaired.set(obj, unpaired);
            };
            if (this.artifacts == null)
                return;
            for (let path of this.artifacts.getResPaths()) {
                let charge = 0, unpaired = 0, orders = 0;
                for (let n = 0; n < path.atoms.length; n++) {
                    charge += mol.atomCharge(path.atoms[n]);
                    unpaired += mol.atomUnpaired(path.atoms[n]);
                    let b = mol.findBond(path.atoms[n], path.atoms[n < path.atoms.length - 1 ? n + 1 : 0]);
                    if (b > 0)
                        orders += mol.bondOrder(b);
                }
                let fractional = (2 * orders - charge + unpaired) / path.atoms.length < 1;
                this.artifactFract.set(path, fractional);
                for (let n = 0; n < path.atoms.length - 1; n++) {
                    let b = mol.findBond(path.atoms[n], path.atoms[n + 1]);
                    if (b > 0)
                        this.bondOrder[b - 1] = fractional ? -1 : 1;
                }
                delocalise(path, path.atoms);
            }
            for (let ring of this.artifacts.getResRings()) {
                for (let n = 0; n < ring.atoms.length; n++) {
                    let b = mol.findBond(ring.atoms[n], ring.atoms[n < ring.atoms.length - 1 ? n + 1 : 0]);
                    if (b > 0)
                        this.bondOrder[b - 1] = 1;
                }
                delocalise(ring, ring.atoms);
            }
            for (let arene of this.artifacts.getArenes()) {
                for (let n = 0; n < arene.atoms.length; n++) {
                    let b = mol.findBond(arene.atoms[n], arene.atoms[n < arene.atoms.length - 1 ? n + 1 : 0]);
                    if (b > 0)
                        this.bondOrder[b - 1] = 1;
                    b = mol.findBond(arene.centre, arene.atoms[n]);
                    if (b > 0)
                        this.bondOrder[b - 1] = -1;
                }
                delocalise(arene, arene.atoms);
            }
        }
        placeAdjunct(atom, str, fsz, col, angdir) {
            let wad = this.measure.measureText(str, fsz);
            let a = this.points[atom - 1];
            let cx = a.oval.cx, cy = a.oval.cy, rw = 0.55 * wad[0], rh = 0.55 * wad[1];
            if (str == '..') {
                let zeroBonds = this.mol.atomAdjBonds(atom).filter((b) => this.mol.bondOrder(b) == 0);
                if (zeroBonds.length == 1) {
                    let zpt = this.getPoint(this.mol.bondOther(zeroBonds[0], atom) - 1);
                    let dx = zpt.oval.cx - cx, dy = zpt.oval.cy - cy, inv = 1 / WebMolKit.norm_xy(dx, dy);
                    let r = fsz * 0.15;
                    let ox = dy * inv * 2.5 * r, oy = -dx * inv * 2.5 * r;
                    let ext = 1.2 * (rw + rh) * inv;
                    [dx, dy] = [dx * ext, dy * ext];
                    this.points.push({ 'anum': 0, 'text': '.', 'fsz': fsz, 'bold': false, 'col': col, 'oval': new WebMolKit.Oval(cx + dx + ox, cy + dy + oy, r, r) });
                    this.points.push({ 'anum': 0, 'text': '.', 'fsz': fsz, 'bold': false, 'col': col, 'oval': new WebMolKit.Oval(cx + dx - ox, cy + dy - oy, r, r) });
                    return;
                }
            }
            let bestScore = 0, bestDX = 0, bestDY = 0;
            let px = WebMolKit.Vec.numberArray(0, 4), py = WebMolKit.Vec.numberArray(0, 4);
            let angThresh = 10;
            let shorted = false;
            for (let ext = 0.5 * (a.oval.rw + a.oval.rh); !shorted && ext < 1.5 * this.measure.scale(); ext += 0.1 * this.measure.scale()) {
                const DELTA = 5 * WebMolKit.DEGRAD;
                for (let d = 0; !shorted && d < Math.PI - 0.0001; d += DELTA)
                    for (let s = -1; s <= 1; s += 2) {
                        let dang = d * s + (s > 0 ? DELTA : 0), ang = angdir + dang;
                        let dx = ext * Math.cos(ang), dy = ext * Math.sin(ang) * -this.ymul;
                        let x1 = cx + dx - rw, x2 = cx + dx + rw, y1 = cy + dy - rh, y2 = cy + dy + rh;
                        px[0] = x1;
                        py[0] = y1;
                        px[1] = x2;
                        py[1] = y1;
                        px[2] = x2;
                        py[2] = y2;
                        px[3] = x1;
                        py[3] = y2;
                        let viol = this.countPolyViolations(px, py, null, false);
                        let score = 10 * viol + Math.abs(dang) + 10 * ext;
                        let shortCircuit = viol == 0 && Math.abs(dang) < (angThresh + 1) * WebMolKit.DEGRAD;
                        if (bestScore == 0 || shortCircuit || score < bestScore) {
                            bestScore = score;
                            bestDX = dx;
                            bestDY = dy;
                        }
                        if (shortCircuit) {
                            shorted = true;
                            break;
                        }
                    }
                angThresh += 5;
            }
            a =
                {
                    'anum': 0,
                    'text': str,
                    'fsz': fsz,
                    'bold': false,
                    'col': col,
                    'oval': new WebMolKit.Oval(cx + bestDX, cy + bestDY, rw, rh)
                };
            this.points.push(a);
            let spc = {
                'anum': 0,
                'bnum': 0,
                'box': new WebMolKit.Box(a.oval.cx - rw, a.oval.cy - rh, 2 * rw, 2 * rh),
                'px': [a.oval.cx - rw, a.oval.cx + rw, a.oval.cx + rw, a.oval.cx - rw],
                'py': [a.oval.cy - rh, a.oval.cy - rh, a.oval.cy + rh, a.oval.cy + rh]
            };
            this.space.push(spc);
        }
        processLabel(anum) {
            let ax = this.mol.atomX(anum), ay = this.mol.atomY(anum);
            let left = 0, right = 0;
            let adj = this.mol.atomAdjList(anum);
            for (let n = 0; n < adj.length; n++) {
                let theta = Math.atan2(this.mol.atomY(adj[n]) - ay, this.mol.atomX(adj[n]) - ax) * WebMolKit.RADDEG;
                if (theta >= -15 && theta <= 15)
                    right += 3;
                else if (theta >= -85 && theta <= 85)
                    right++;
                else if (theta > 85 && theta < 95) { }
                else if (theta < -85 && theta > -95) { }
                else if (theta > 165 || theta < -165)
                    left += 3;
                else
                    left++;
            }
            let label = this.mol.atomElement(anum);
            let ibar = label.indexOf('|'), ibrace = label.indexOf('{');
            let side = 0;
            if (left == 0 && right == 0 && ibar < 0 && ibrace < 0) { }
            else if (left < right)
                side = -1;
            else if (right < left)
                side = 1;
            else {
                let score1 = WebMolKit.CoordUtil.congestionPoint(this.mol, ax - 1, ay);
                let score2 = WebMolKit.CoordUtil.congestionPoint(this.mol, ax + 1, ay);
                if (score1 < 0.5 * score2)
                    side = -1;
                else
                    side = 1;
            }
            let chunks = null;
            let position = null;
            let primary = null;
            let refchunk = 0;
            if (ibar < 0 && ibrace < 0) {
                if (side == 0)
                    chunks = [label];
                else if (side < 0) {
                    chunks = [label.substring(0, label.length - 1), label.substring(label.length - 1)];
                    refchunk = 1;
                }
                else
                    chunks = [label.substring(0, 1), label.substring(1)];
            }
            else {
                let bits = [];
                let bpos = [];
                let bpri = [];
                let blocks = label.split('|');
                if (side < 0)
                    blocks = WebMolKit.Vec.reverse(blocks);
                let buff = '';
                for (let i = 0; i < blocks.length; i++) {
                    let isPrimary = (side >= 0 && i == 0) || (side < 0 && i == blocks.length - 1);
                    if (side < 0 && refchunk == 0 && i == blocks.length - 1)
                        refchunk = bits.length;
                    let pos = 0;
                    buff = '';
                    for (let j = 0; j < blocks[i].length; j++) {
                        let ch = blocks[i].charAt(j);
                        if (ch == '{' || ch == '}') {
                            if (buff.length > 0) {
                                bits.push(buff.toString());
                                bpos.push(pos);
                                bpri.push(isPrimary);
                            }
                            buff = '';
                            pos = ch == '{' ? -1 : 0;
                        }
                        else if (ch == '^' && pos == -1 && buff.length == 0)
                            pos = 1;
                        else
                            buff += ch;
                    }
                    if (buff.length > 0) {
                        bits.push(buff.toString());
                        bpos.push(pos);
                        bpri.push(isPrimary);
                    }
                }
                chunks = bits;
                position = bpos;
                primary = bpri;
                while (refchunk < chunks.length - 1 && position[refchunk] != 0)
                    refchunk++;
            }
            let PADDING = 1.1;
            let SSFRACT = 0.6;
            let chunkw = WebMolKit.Vec.numberArray(0, chunks.length);
            let tw = 0;
            for (let n = 0; n < chunks.length; n++) {
                chunkw[n] = this.measure.measureText(chunks[n], this.fontSizePix)[0];
                if (position != null && position[n] != 0)
                    chunkw[n] *= SSFRACT;
                tw += chunkw[n];
            }
            let x = this.measure.angToX(ax), y = this.measure.angToY(ay);
            for (let n = 0; n < refchunk; n++)
                x -= chunkw[n];
            x -= 0.5 * chunkw[refchunk];
            for (let n = 0; n < chunks.length; n++) {
                let a = {
                    'anum': (n == refchunk || (primary != null && primary[n])) ? anum : 0,
                    'text': chunks[n],
                    'fsz': this.fontSizePix,
                    'bold': false,
                    'col': this.policy.data.atomCols[this.mol.atomicNumber(anum)],
                    'oval': new WebMolKit.Oval(x + 0.5 * chunkw[n], y, 0.5 * chunkw[n] * PADDING, 0.5 * this.fontSizePix * PADDING)
                };
                if (position != null && position[n] != 0) {
                    a.fsz *= SSFRACT;
                    if (position[n] < 0)
                        a.oval.cy += a.fsz * 0.7 * (this.measure.yIsUp() ? -1 : 1);
                    else
                        a.oval.cy -= a.fsz * 0.3 * (this.measure.yIsUp() ? -1 : 1);
                }
                if (n == refchunk) {
                    this.points[anum - 1] = a;
                    this.space[anum - 1] = this.computeSpacePoint(a);
                }
                else {
                    this.points.push(a);
                    this.space.push(this.computeSpacePoint(a));
                }
                x += chunkw[n];
            }
        }
        atomIsWeirdLinear(idx) {
            let bonds = this.mol.atomAdjBonds(idx);
            if (bonds.length != 2)
                return false;
            for (let n = 0; n < bonds.length; n++)
                if (this.mol.bondOrder(bonds[n]) == 3)
                    return false;
            let adj = this.mol.atomAdjList(idx);
            let th1 = Math.atan2(this.mol.atomY(adj[0]) - this.mol.atomY(idx), this.mol.atomX(adj[0]) - this.mol.atomX(idx));
            let th2 = Math.atan2(this.mol.atomY(adj[1]) - this.mol.atomY(idx), this.mol.atomX(adj[1]) - this.mol.atomX(idx));
            return Math.abs(WebMolKit.angleDiff(th1, th2)) >= 175 * WebMolKit.DEGRAD;
        }
        backOffAtom(atom, x, y, fx, fy, minDist) {
            if (x == fx && y == fy)
                return [x, y];
            let active = false;
            let dx = 0, dy = 0, dst = 0, ext = 0;
            for (let s = 0; s < this.space.length; s++) {
                let spc = this.space[s];
                if (spc.anum != atom)
                    continue;
                const sz = spc.px.length;
                if (sz == 0)
                    continue;
                for (let n = 0; n < sz; n++) {
                    let nn = n < sz - 1 ? n + 1 : 0;
                    let x1 = spc.px[n], y1 = spc.py[n], x2 = spc.px[nn], y2 = spc.py[nn];
                    if (!WebMolKit.GeomUtil.doLineSegsIntersect(x, y, fx, fy, x1, y1, x2, y2))
                        continue;
                    let xy = WebMolKit.GeomUtil.lineIntersect(x, y, fx, fy, x1, y1, x2, y2);
                    if (!active) {
                        dx = x - fx;
                        dy = y - fy;
                        dst = WebMolKit.norm_xy(dx, dy);
                        ext = dst;
                        active = true;
                    }
                    ext = Math.min(ext, WebMolKit.norm_xy(xy[0] - fx, xy[1] - fy));
                }
            }
            if (active) {
                ext = Math.max(minDist, ext - 0.1 * this.measure.scale());
                let idst = 1.0 / dst;
                return [fx + ext * idst * dx, fy + ext * idst * dy];
            }
            else
                return [x, y];
        }
        ensureMinimumBondLength(xy1, xy2, x1, y1, x2, y2, minDist) {
            let dx = xy2[0] - xy1[0], dy = xy2[1] - xy1[1];
            let dsq = WebMolKit.norm2_xy(dx, dy);
            minDist = Math.min(minDist, WebMolKit.norm_xy(x2 - x1, y2 - y1));
            if (dsq >= WebMolKit.sqr(minDist - 0.0001))
                return;
            let d12 = Math.sqrt(dsq), d1 = WebMolKit.norm_xy(xy1[0] - x1, xy1[1] - y1), d2 = WebMolKit.norm_xy(x2 - xy2[0], y2 - xy2[1]);
            let mag = 1 - minDist / d12, invD12 = 1.0 / (d1 + d2), mag1 = d1 * mag * invD12, mag2 = d2 * mag * invD12;
            xy1[0] -= dx * mag1;
            xy1[1] -= dy * mag1;
            xy2[0] += dx * mag2;
            xy2[1] += dy * mag2;
        }
        orderedRingList() {
            let rings = [];
            let SIZE_ORDER = [6, 5, 7, 4, 3];
            for (let i = 0; i < SIZE_ORDER.length; i++) {
                let nring = this.mol.findRingsOfSize(SIZE_ORDER[i]);
                for (let j = 0; j < nring.length; j++)
                    rings.push(nring[j]);
            }
            let ringsz = rings.length;
            let ringbusy = WebMolKit.Vec.numberArray(0, this.mol.numAtoms);
            for (let n = 0; n < ringsz; n++) {
                let r = rings[n];
                for (let i = 0; i < r.length; i++)
                    ringbusy[r[i] - 1]++;
            }
            let ringscore = WebMolKit.Vec.numberArray(0, ringsz);
            for (let n = 0; n < ringsz; n++) {
                let r = rings[n];
                for (let i = 0; i < r.length; i++)
                    ringscore[n] += ringbusy[r[i] - 1];
            }
            let ringorder = WebMolKit.Vec.idxSort(ringscore);
            let resbcount = WebMolKit.Vec.numberArray(0, ringsz), maxbcount = 0;
            for (let n = 0; n < ringsz; n++) {
                let r = rings[ringorder[n]];
                for (let i = 0; i < r.length; i++) {
                    let j = this.mol.findBond(r[i], r[i + 1 < r.length ? i + 1 : 0]);
                    if (this.mol.bondOrder(j) == 2)
                        resbcount[n]++;
                }
                maxbcount = Math.max(maxbcount, resbcount[n]);
            }
            let pos = 0, ret = [];
            for (let sz = maxbcount; sz >= 0; sz--) {
                for (let n = 0; n < ringsz; n++)
                    if (resbcount[n] == sz)
                        ret.push(rings[ringorder[n]]);
            }
            return ret;
        }
        orthogonalDelta(x1, y1, x2, y2, d) {
            let ox = y1 - y2, oy = x2 - x1, dsq = WebMolKit.norm2_xy(ox, oy);
            let sc = dsq > 0 ? d / Math.sqrt(dsq) : 1;
            return [ox * sc, oy * sc];
        }
        processDoubleBond(idx, priority) {
            let bfr = this.mol.bondFrom(idx), bto = this.mol.bondTo(idx);
            let nfr = this.mol.atomAdjList(bfr), nto = this.mol.atomAdjList(bto);
            let a1 = this.points[bfr - 1], a2 = this.points[bto - 1];
            let x1 = a1.oval.cx, y1 = a1.oval.cy, x2 = a2.oval.cx, y2 = a2.oval.cy;
            const minDist = MINBOND_EXOTIC * this.measure.scale();
            let xy1 = this.backOffAtom(bfr, x1, y1, x2, y2, minDist);
            let xy2 = this.backOffAtom(bto, x2, y2, x1, y1, minDist);
            this.ensureMinimumBondLength(xy1, xy2, x1, y1, x2, y2, minDist);
            x1 = xy1[0];
            y1 = xy1[1];
            x2 = xy2[0];
            y2 = xy2[1];
            let dx = x2 - x1, dy = y2 - y1, btheta = Math.atan2(dy, dx);
            let countFLeft = 0, countFRight = 0, countTLeft = 0, countTRight = 0;
            let idxFLeft = 0, idxFRight = 0, idxTLeft = 0, idxTRight = 0;
            let noshift = false;
            for (let n = 0; n < nfr.length; n++)
                if (nfr[n] != bto) {
                    let bo = this.mol.bondOrder(this.mol.findBond(bfr, nfr[n]));
                    if (bo == 0)
                        continue;
                    if (bo > 1) {
                        noshift = true;
                        break;
                    }
                    let ispri = false;
                    for (let i = 0; i < (priority == null ? 0 : priority.length); i++)
                        if (priority[i] == nfr[n])
                            ispri = true;
                    let theta = WebMolKit.angleDiff(Math.atan2(this.points[nfr[n] - 1].oval.cy - y1, this.points[nfr[n] - 1].oval.cx - x1), btheta);
                    if (Math.abs(theta) * WebMolKit.RADDEG > 175) {
                        noshift = true;
                        break;
                    }
                    if (theta > 0) {
                        if (ispri)
                            countFLeft++;
                        idxFLeft = nfr[n];
                    }
                    else {
                        if (ispri)
                            countFRight++;
                        idxFRight = nfr[n];
                    }
                }
            for (let n = 0; n < nto.length; n++)
                if (nto[n] != bfr) {
                    let bo = this.mol.bondOrder(this.mol.findBond(bto, nto[n]));
                    if (bo == 0)
                        continue;
                    if (bo > 1) {
                        noshift = true;
                        break;
                    }
                    let ispri = false;
                    for (let i = 0; i < (priority == null ? 0 : priority.length); i++)
                        if (priority[i] == nto[n])
                            ispri = true;
                    let theta = WebMolKit.angleDiff(Math.atan2(this.points[nto[n] - 1].oval.cy - y2, this.points[nto[n] - 1].oval.cx - x2), btheta);
                    if (Math.abs(theta) * WebMolKit.RADDEG > 175) {
                        noshift = true;
                        break;
                    }
                    if (theta > 0) {
                        if (ispri)
                            countTLeft++;
                        idxTLeft = nto[n];
                    }
                    else {
                        if (ispri)
                            countTRight++;
                        idxTRight = nto[n];
                    }
                }
            let side = 0;
            if (noshift || countFLeft > 1 || countFRight > 1 || countTLeft > 1 || countTRight > 1) { }
            else if (countFLeft > 0 && countFRight > 0) { }
            else if (countTLeft > 0 && countTRight > 0) { }
            else if (countFLeft > 0 || countTLeft > 0)
                side = 1;
            else if (countFRight > 0 || countTRight > 0)
                side = -1;
            let sz = this.lineSizePix;
            let oxy = this.orthogonalDelta(x1, y1, x2, y2, this.bondSepPix);
            let ax1 = x1, ay1 = y1, ax2 = x2, ay2 = y2;
            let bx1 = 0, by1 = 0, bx2 = 0, by2 = 0;
            if (side == 0) {
                ax1 = x1 + 0.5 * oxy[0];
                ay1 = y1 + 0.5 * oxy[1];
                ax2 = x2 + 0.5 * oxy[0];
                ay2 = y2 + 0.5 * oxy[1];
                bx1 = x1 - 0.5 * oxy[0];
                by1 = y1 - 0.5 * oxy[1];
                bx2 = x2 - 0.5 * oxy[0];
                by2 = y2 - 0.5 * oxy[1];
            }
            else if (side > 0) {
                bx1 = x1 + oxy[0];
                by1 = y1 + oxy[1];
                bx2 = x2 + oxy[0];
                by2 = y2 + oxy[1];
                if (nfr.length > 1 && this.points[bfr - 1].text == null) {
                    bx1 += oxy[1];
                    by1 -= oxy[0];
                }
                if (nto.length > 1 && this.points[bto - 1].text == null) {
                    bx2 -= oxy[1];
                    by2 += oxy[0];
                }
            }
            else if (side < 0) {
                bx1 = x1 - oxy[0];
                by1 = y1 - oxy[1];
                bx2 = x2 - oxy[0];
                by2 = y2 - oxy[1];
                if (nfr.length > 1 && this.points[bfr - 1].text == null) {
                    bx1 += oxy[1];
                    by1 -= oxy[0];
                }
                if (nto.length > 1 && this.points[bto - 1].text == null) {
                    bx2 -= oxy[1];
                    by2 += oxy[0];
                }
            }
            if (side != 0) {
                if (this.mol.atomElement(bfr).length <= 2 && this.mol.atomAdjCount(bfr) == 1 && this.points[bfr - 1].text != null) {
                    this.bumpAtomPosition(bfr, 0.5 * oxy[0] * side, 0.5 * oxy[1] * side);
                }
                if (this.mol.atomElement(bto).length <= 2 && this.mol.atomAdjCount(bto) == 1 && this.points[bto - 1].text != null) {
                    this.bumpAtomPosition(bto, 0.5 * oxy[0] * side, 0.5 * oxy[1] * side);
                }
            }
            if (side == 0 && !noshift) {
                let xy = null;
                if (this.points[bfr - 1].text == null && !this.mol.bondInRing(idx)) {
                    xy = this.adjustBondPosition(idxFLeft, bfr, ax1, ay1, ax2, ay2);
                    if (xy != null) {
                        ax1 = xy[0];
                        ay1 = xy[1];
                    }
                    xy = this.adjustBondPosition(idxFRight, bfr, bx1, by1, bx2, by2);
                    if (xy != null) {
                        bx1 = xy[0];
                        by1 = xy[1];
                    }
                }
                if (this.points[bto - 1].text == null && !this.mol.bondInRing(idx)) {
                    xy = this.adjustBondPosition(idxTLeft, bto, ax2, ay2, ax1, ay1);
                    if (xy != null) {
                        ax2 = xy[0];
                        ay2 = xy[1];
                    }
                    xy = this.adjustBondPosition(idxTRight, bto, bx2, by2, bx1, by1);
                    if (xy != null) {
                        bx2 = xy[0];
                        by2 = xy[1];
                    }
                }
            }
            let lt = this.mol.bondType(idx) == WebMolKit.Molecule.BONDTYPE_UNKNOWN ? BLineType.Unknown : BLineType.Normal;
            let head = lt == BLineType.Unknown ? 0.1 * this.scale : 0;
            let col = this.effects.colBond[idx];
            if (!col)
                col = this.policy.data.foreground;
            let b1 = {
                'bnum': idx,
                'bfr': bfr,
                'bto': bto,
                'type': lt,
                'line': new WebMolKit.Line(ax1, ay1, ax2, ay2),
                'size': sz,
                'head': head,
                'col': col
            };
            let b2 = {
                'bnum': idx,
                'bfr': bfr,
                'bto': bto,
                'type': lt,
                'line': new WebMolKit.Line(bx1, by1, bx2, by2),
                'size': sz,
                'head': head,
                'col': col
            };
            this.lines.push(b1);
            this.lines.push(b2);
            this.space.push(this.computeSpaceLine(b1));
            this.space.push(this.computeSpaceLine(b2));
        }
        placeHydrogen(idx, hcount, fussy) {
            let font = WebMolKit.FontData.main;
            const SSFRACT = 0.6;
            const GLYPH_H = font.getIndex('H');
            let a = this.points[idx];
            let emscale = a.fsz * font.INV_UNITS_PER_EM;
            let sub = hcount >= 2 ? hcount.toString() : '';
            let outlineX = font.getOutlineX(GLYPH_H), outlineY = font.getOutlineY(GLYPH_H);
            let firstEMW = font.HORIZ_ADV_X[GLYPH_H], emw = firstEMW;
            for (let n = 0; n < sub.length; n++) {
                let ch = sub.charAt(n), g = font.getIndex(ch);
                if (n == 0) {
                    emw += font.getKerning('H', ch);
                }
                else {
                    let chp = sub.charAt(n - 1);
                    emw += font.getKerning(chp, ch) * SSFRACT;
                }
                let extraX = font.getOutlineX(g), extraY = font.getOutlineY(g);
                WebMolKit.Vec.addTo(extraX, emw / SSFRACT);
                WebMolKit.Vec.addTo(extraY, (SSFRACT - 1) * font.ASCENT);
                WebMolKit.Vec.mulBy(extraX, SSFRACT);
                WebMolKit.Vec.mulBy(extraY, SSFRACT);
                outlineX = outlineX.concat(extraX);
                outlineY = outlineY.concat(extraY);
                emw += font.HORIZ_ADV_X[g] * SSFRACT;
            }
            if (sub.length > 0) {
                let qh = new WebMolKit.QuickHull(outlineX, outlineY, 0);
                outlineX = qh.hullX;
                outlineY = qh.hullY;
            }
            let emdx = -0.5 * firstEMW, emdy = 0.5 * font.ASCENT;
            for (let n = 0; n < outlineX.length; n++) {
                outlineX[n] = a.oval.cx + (emdx + outlineX[n]) * emscale;
                outlineY[n] = a.oval.cy + (emdy - outlineY[n]) * emscale * this.ymul;
            }
            let dx = 0, dy = 0;
            let srcWAD = this.measure.measureText(a.text, a.fsz);
            if (fussy) {
                let RIGHTLEFT = [0, 1, 2, 3];
                let LEFTRIGHT = [1, 0, 2, 3];
                let UPDOWN = [2, 3, 0, 1];
                let DOWNUP = [3, 2, 0, 1];
                let quad = RIGHTLEFT, adj = this.mol.atomAdjList(a.anum);
                if (adj.length == 0) {
                    let LEFTIES = ['O', 'S', 'F', 'Cl', 'Br', 'I'];
                    if (this.mol.atomCharge(a.anum) == 0 && this.mol.atomUnpaired(a.anum) == 0 &&
                        LEFTIES.indexOf(this.mol.atomElement(a.anum)) >= 0)
                        quad = LEFTRIGHT;
                    else
                        quad = RIGHTLEFT;
                }
                else {
                    let allLeft = true, allRight = true, allUp = true, allDown = true;
                    const ax = this.mol.atomX(a.anum), ay = this.mol.atomY(a.anum);
                    for (let n = 0; n < adj.length; n++) {
                        const bx = this.mol.atomX(adj[n]), by = this.mol.atomY(adj[n]);
                        if (bx > ax + 0.01)
                            allLeft = false;
                        if (bx < ax - 0.01)
                            allRight = false;
                        if (by < ay - 0.01)
                            allUp = false;
                        if (by > ay + 0.01)
                            allDown = false;
                    }
                    if (allLeft) { }
                    else if (allRight)
                        quad = LEFTRIGHT;
                    else if (allUp)
                        quad = DOWNUP;
                    else if (allDown)
                        quad = UPDOWN;
                }
                for (let n = 0; n < 4; n++) {
                    let tx = 0, ty = 0;
                    if (quad[n] == 0)
                        tx = 0.5 * srcWAD[0] + 0.5 * firstEMW * emscale;
                    else if (quad[n] == 1)
                        tx = -0.5 * srcWAD[0] - (emw - 0.5 * firstEMW) * emscale;
                    else if (quad[n] == 2)
                        ty = (1.1 * srcWAD[1] + 0.5 * srcWAD[2]) * -this.ymul;
                    else if (quad[n] == 3)
                        ty = (1.1 * srcWAD[1] + 0.5 * srcWAD[2]) * this.ymul;
                    WebMolKit.Vec.addTo(outlineX, tx);
                    WebMolKit.Vec.addTo(outlineY, ty);
                    let viol = this.countPolyViolations(outlineX, outlineY, null, true);
                    WebMolKit.Vec.addTo(outlineX, -tx);
                    WebMolKit.Vec.addTo(outlineY, -ty);
                    if (viol == 0) {
                        dx = tx;
                        dy = ty;
                        break;
                    }
                }
                if (dx == 0 && dy == 0)
                    return false;
            }
            else {
                const mx1 = WebMolKit.Vec.min(outlineY), mx2 = WebMolKit.Vec.max(outlineX), my1 = WebMolKit.Vec.min(outlineY), my2 = WebMolKit.Vec.max(outlineY), cx = 0.5 * (mx1 + mx2), cy = 0.5 * (my1 + my2);
                const mag = 1 + this.measure.scale() * this.policy.data.fontSize * ArrangeMolecule.FONT_CORRECT * 0.1 / Math.max(mx2 - cx, my2 - cy);
                const psz = outlineX.length;
                let magPX = outlineX.slice(0), magPY = outlineY.slice(0);
                for (let n = 0; n < psz; n++) {
                    magPX[n] = (magPX[n] - cx) * mag + cx;
                    magPY[n] = (magPY[n] - cy) * mag + cy;
                }
                let bestScore = 0, bestExt = 0, bestAng = 0;
                for (let ext = 0.5 * (a.oval.rw + a.oval.rh); ext < 1.5 * this.measure.scale(); ext += 0.1 * this.measure.scale()) {
                    let anyNoClash = false;
                    for (let ang = 0; ang < 2 * Math.PI; ang += 5 * WebMolKit.DEGRAD) {
                        let tx = ext * Math.cos(ang), ty = ext * Math.sin(ang);
                        WebMolKit.Vec.addTo(magPX, tx);
                        WebMolKit.Vec.addTo(magPY, ty);
                        let viol = this.countPolyViolations(magPX, magPY, null, false);
                        WebMolKit.Vec.addTo(magPX, -tx);
                        WebMolKit.Vec.addTo(magPY, -ty);
                        if (viol == 0)
                            anyNoClash = true;
                        let score = 10 * viol + this.spatialCongestion(a.oval.cx + tx, a.oval.cy + ty, 0.5) + 2 * ext;
                        if (bestScore == 0 || score < bestScore) {
                            bestScore = score;
                            bestExt = ext;
                            bestAng = ang;
                            dx = tx;
                            dy = ty;
                        }
                    }
                    if (anyNoClash)
                        break;
                }
            }
            let wad = this.measure.measureText('H', a.fsz);
            const PADDING = 1.1;
            let ah = {
                'anum': 0,
                'text': 'H',
                'fsz': a.fsz,
                'bold': a.bold,
                'col': a.col,
                'oval': new WebMolKit.Oval(a.oval.cx + dx, a.oval.cy + dy, 0.5 * wad[0] * PADDING, 0.5 * wad[1] * PADDING)
            };
            this.points.push(ah);
            if (sub.length > 0) {
                const subFsz = SSFRACT * a.fsz;
                wad = this.measure.measureText(sub, subFsz);
                let an = {
                    'anum': 0,
                    'text': sub,
                    'fsz': subFsz,
                    'bold': a.bold,
                    'col': a.col,
                    'oval': new WebMolKit.Oval(ah.oval.cx + 0.5 * firstEMW * a.fsz * font.INV_UNITS_PER_EM + 0.5 * wad[0], ah.oval.cy + (1 - SSFRACT) * a.fsz, 0.5 * wad[0] * PADDING, 0.5 * wad[1] * PADDING)
                };
                this.points.push(an);
            }
            WebMolKit.Vec.addTo(outlineX, dx);
            WebMolKit.Vec.addTo(outlineY, dy);
            let minX = WebMolKit.Vec.min(outlineX), minY = WebMolKit.Vec.min(outlineY);
            let spc = {
                'anum': 0,
                'bnum': 0,
                'box': new WebMolKit.Box(minX, minY, WebMolKit.Vec.max(outlineX) - minX, WebMolKit.Vec.max(outlineY) - minY),
                'px': outlineX,
                'py': outlineY
            };
            this.space.push(spc);
            return true;
        }
        computeSpacePoint(a) {
            let s = {
                'anum': a.anum,
                'bnum': 0,
                'box': new WebMolKit.Box(),
                'px': [],
                'py': []
            };
            const font = WebMolKit.FontData.main;
            let outlineX = [], outlineY = [];
            let emw = 0, nglyphs = 0;
            if (a.text != null) {
                for (let n = 0; n < a.text.length; n++) {
                    let ch1 = a.text.charAt(n);
                    let i = font.getIndex(ch1);
                    if (i >= 0) {
                        if (emw == 0) {
                            outlineX = font.getOutlineX(i);
                            outlineY = font.getOutlineY(i);
                            nglyphs = 1;
                        }
                        else {
                            let extraX = font.getOutlineX(i), extraY = font.getOutlineY(i);
                            if (extraX.length > 0) {
                                WebMolKit.Vec.addTo(extraX, emw);
                                outlineX = outlineX.concat(extraX);
                                outlineY = outlineY.concat(extraY);
                                nglyphs++;
                            }
                        }
                        emw += font.HORIZ_ADV_X[i];
                    }
                    else
                        emw += font.MISSING_HORZ;
                    if (n < a.text.length - 1) {
                        let ch2 = a.text.charAt(n + 1);
                        emw += font.getKerning(ch1, ch2);
                    }
                }
            }
            if (outlineX.length > 0) {
                if (nglyphs > 1) {
                    let qh = new WebMolKit.QuickHull(outlineX, outlineY, 0);
                    outlineX = qh.hullX;
                    outlineY = qh.hullY;
                }
                let emdx = -0.5 * emw, emdy = 0.5 * font.ASCENT;
                let emscale = a.fsz * font.INV_UNITS_PER_EM;
                for (let n = 0; n < outlineX.length; n++) {
                    outlineX[n] = a.oval.cx + (emdx + outlineX[n]) * emscale;
                    outlineY[n] = a.oval.cy + (emdy - outlineY[n]) * emscale * this.ymul;
                }
                s.px = outlineX;
                s.py = outlineY;
                let minX = WebMolKit.Vec.min(outlineX), minY = WebMolKit.Vec.min(outlineY);
                s.box = new WebMolKit.Box(minX, minY, WebMolKit.Vec.max(outlineX) - minX, WebMolKit.Vec.max(outlineY) - minY);
            }
            else {
                s.box = WebMolKit.Box.fromOval(a.oval);
                if (s.box.w > 0 && s.box.h > 0) {
                    s.px = [s.box.minX(), s.box.maxX(), s.box.maxX(), s.box.minX()];
                    s.py = [s.box.minY(), s.box.minY(), s.box.maxY(), s.box.maxY()];
                }
            }
            return s;
        }
        computeSpaceLine(b) {
            let s = {
                'anum': 0,
                'bnum': b.bnum,
                'box': new WebMolKit.Box(),
                'px': [],
                'py': []
            };
            if (b.type == BLineType.Normal || b.type == BLineType.Dotted || b.type == BLineType.DotDir) {
                s.px = [b.line.x1, b.line.x2];
                s.py = [b.line.y1, b.line.y2];
            }
            else {
                const dx = b.line.x2 - b.line.x1, dy = b.line.y2 - b.line.y1;
                const norm = b.head / Math.sqrt(dx * dx + dy * dy);
                const ox = norm * dy, oy = -norm * dx;
                if (b.type == BLineType.Unknown) {
                    s.px = [b.line.x1 + ox, b.line.x1 - ox, b.line.x2 - ox, b.line.x2 + ox];
                    s.py = [b.line.y1 + oy, b.line.y1 - oy, b.line.y2 - oy, b.line.y2 + oy];
                }
                else {
                    s.px = [b.line.x1, b.line.x2 - ox, b.line.x2 + ox];
                    s.py = [b.line.y1, b.line.y2 - oy, b.line.y2 + oy];
                }
            }
            s.box.x = WebMolKit.Vec.min(s.px) - b.size;
            s.box.y = WebMolKit.Vec.min(s.py) - b.size;
            s.box.w = WebMolKit.Vec.max(s.px) - s.box.x + b.size;
            s.box.h = WebMolKit.Vec.max(s.py) - s.box.y + b.size;
            return s;
        }
        bumpAtomPosition(atom, dx, dy) {
            let p = this.points[atom - 1];
            p.oval.cx += dx;
            p.oval.cy += dy;
            for (let n = this.space.length - 1; n >= 0; n--) {
                let s = this.space[n - 1];
                if (s == null || s.anum != atom)
                    continue;
                s.box.x += dx;
                s.box.y += dy;
                WebMolKit.Vec.addTo(s.px, dx);
                WebMolKit.Vec.addTo(s.py, dy);
            }
        }
        spaceSubset(x, y, w, h) {
            let subset = [];
            for (let s of this.space)
                if (WebMolKit.GeomUtil.rectsIntersect(x, y, w, h, s.box.x, s.box.y, s.box.w, s.box.h))
                    subset.push(s);
            return subset;
        }
        countPolyViolations(px, py, space, shortCircuit) {
            if (space == null)
                space = this.space;
            let hits = 0;
            const psz = px.length, nspc = space.length;
            let pr = new WebMolKit.Box(), sr = new WebMolKit.Box();
            for (let i1 = 0; i1 < psz; i1++) {
                let i2 = i1 < psz - 1 ? i1 + 1 : 0;
                pr.x = Math.min(px[i1], px[i2]) - 1;
                pr.y = Math.min(py[i1], py[i2]) - 1;
                pr.w = Math.max(px[i1], px[i2]) - pr.x + 2;
                pr.h = Math.max(py[i1], py[i2]) - pr.y + 2;
                for (let j = 0; j < nspc; j++) {
                    let spc = space[j];
                    if (spc.px == null)
                        continue;
                    sr.x = spc.box.x - 1;
                    sr.y = spc.box.y - 1;
                    sr.w = spc.box.w + 1;
                    sr.h = spc.box.h + 1;
                    if (!pr.intersects(sr))
                        continue;
                    let ssz = spc.px.length;
                    for (let j1 = 0; j1 < ssz; j1++) {
                        let j2 = j1 < ssz - 1 ? j1 + 1 : 0;
                        sr.x = Math.min(spc.px[j1], spc.px[j2]) - 1;
                        sr.y = Math.min(spc.py[j1], spc.py[j2]) - 1;
                        sr.w = Math.max(spc.px[j1], spc.px[j2]) - sr.x + 2;
                        sr.h = Math.max(spc.py[j1], spc.py[j2]) - sr.y + 2;
                        if (!pr.intersects(sr))
                            continue;
                        if (WebMolKit.GeomUtil.doLineSegsIntersect(px[i1], py[i1], px[i2], py[i2], spc.px[j1], spc.py[j1], spc.px[j2], spc.py[j2])) {
                            if (shortCircuit)
                                return 1;
                            hits++;
                            break;
                        }
                        if (ssz == 1)
                            break;
                    }
                }
            }
            pr.x = WebMolKit.Vec.min(px);
            pr.y = WebMolKit.Vec.min(py);
            pr.w = WebMolKit.Vec.max(px) - pr.x;
            pr.h = WebMolKit.Vec.max(py) - pr.y;
            for (let n = nspc - 1; n >= 0; n--) {
                let spc = space[n];
                sr.x = spc.box.x;
                sr.y = spc.box.y;
                sr.w = spc.box.w;
                sr.h = spc.box.h;
                if (!pr.intersects(sr))
                    continue;
                for (let i = spc.px.length - 1; i >= 0; i--)
                    if (WebMolKit.GeomUtil.pointInPolygon(spc.px[i], spc.py[i], px, py)) {
                        if (shortCircuit)
                            return 1;
                        hits++;
                        break;
                    }
                for (let i = 0; i < psz; i++)
                    if (WebMolKit.GeomUtil.pointInPolygon(px[i], py[i], spc.px, spc.py)) {
                        if (shortCircuit)
                            return 1;
                        hits++;
                        break;
                    }
            }
            return hits;
        }
        adjustBondPosition(bf, bt, x1, y1, x2, y2) {
            if (bf == 0 || bt == 0)
                return null;
            for (let n = 0; n < this.lines.length; n++) {
                let b = this.lines[n];
                if (this.mol.bondOrder(b.bnum) != 1 || this.mol.bondType(b.bnum) != WebMolKit.Molecule.BONDTYPE_NORMAL)
                    continue;
                let alt = false;
                if (this.mol.bondFrom(b.bnum) == bf && this.mol.bondTo(b.bnum) == bt) { }
                else if (this.mol.bondFrom(b.bnum) == bt && this.mol.bondTo(b.bnum) == bf)
                    alt = true;
                else
                    continue;
                let th = WebMolKit.angleDiff(Math.atan2(b.line.y2 - b.line.y1, b.line.x2 - b.line.x1), Math.atan2(y2 - y1, x2 - x1)) * WebMolKit.RADDEG;
                if ((th > -5 && th < 5) || th > 175 || th < -175)
                    continue;
                let xy = WebMolKit.GeomUtil.lineIntersect(b.line.x1, b.line.y1, b.line.x2, b.line.y2, x1, y1, x2, y2);
                if (this.mol.atomRingBlock(bt) == 0) {
                    if (alt) {
                        b.line.x1 = xy[0];
                        b.line.y1 = xy[1];
                    }
                    else {
                        b.line.x2 = xy[0];
                        b.line.y2 = xy[1];
                    }
                }
                return xy;
            }
            return null;
        }
        priorityDoubleSubstit(idx) {
            let bf = this.mol.bondFrom(idx), bt = this.mol.bondTo(idx);
            let nf = this.mol.atomAdjList(bf), nt = this.mol.atomAdjList(bt);
            let a1 = this.points[bf - 1], a2 = this.points[bt - 1];
            let x1 = a1.oval.cx, y1 = a1.oval.cy, x2 = a2.oval.cx, y2 = a2.oval.cy;
            let dx = x2 - x1, dy = y2 - y1, btheta = Math.atan2(dy, dx);
            let idxFLeft = 0, idxFRight = 0, idxTLeft = 0, idxTRight = 0;
            for (let n = 0; n < nf.length; n++)
                if (nf[n] != bt) {
                    let theta = WebMolKit.angleDiff(Math.atan2(this.points[nf[n] - 1].oval.cy - y1, this.points[nf[n] - 1].oval.cx - x1), btheta);
                    if (theta > 0) {
                        if (idxFLeft != 0)
                            return null;
                        idxFLeft = nf[n];
                    }
                    else {
                        if (idxFRight != 0)
                            return null;
                        idxFRight = nf[n];
                    }
                }
            for (let n = 0; n < nt.length; n++)
                if (nt[n] != bf) {
                    let theta = WebMolKit.angleDiff(Math.atan2(this.points[nt[n] - 1].oval.cy - y2, this.points[nt[n] - 1].oval.cx - x2), btheta);
                    if (theta > 0) {
                        if (idxTLeft != 0)
                            return null;
                        idxTLeft = nt[n];
                    }
                    else {
                        if (idxTRight != 0)
                            return null;
                        idxTRight = nt[n];
                    }
                }
            let sumFrom = (idxFLeft > 0 ? 1 : 0) + (idxFRight > 0 ? 1 : 0), sumTo = (idxTLeft > 0 ? 1 : 0) + (idxTRight > 0 ? 1 : 0);
            if (sumFrom == 1 && sumTo == 0)
                return [idxFLeft > 0 ? idxFLeft : idxFRight];
            if (sumFrom == 0 && sumTo == 1)
                return [idxTLeft > 0 ? idxTLeft : idxTRight];
            if (sumFrom == 1 && sumTo == 1) {
                if (idxFLeft > 0 && idxTLeft > 0)
                    return [idxFLeft, idxTLeft];
                if (idxFRight > 0 && idxTRight > 0)
                    return [idxFRight, idxTRight];
                let oxy = this.orthogonalDelta(x1, y1, x2, y2, this.bondSepPix);
                let congestLeft = this.spatialCongestion(0.5 * (x1 + x2) + oxy[0], 0.5 * (y1 + y2) + oxy[1]);
                let congestRight = this.spatialCongestion(0.5 * (x1 + x2) - oxy[0], 0.5 * (y1 + y2) - oxy[1]);
                if (congestLeft < congestRight)
                    return [idxFLeft > 0 ? idxFLeft : idxTLeft];
                else
                    return [idxFRight > 0 ? idxFRight : idxTRight];
            }
            if (sumFrom == 2 && sumTo == 1) {
                if (idxTLeft == 0)
                    return [idxFRight, idxTRight];
                else
                    return [idxFLeft, idxTLeft];
            }
            if (sumFrom == 1 && sumTo == 2) {
                if (idxFLeft == 0)
                    return [idxFRight, idxTRight];
                else
                    return [idxFLeft, idxTLeft];
            }
            return null;
        }
        spatialCongestion(x, y, thresh) {
            if (thresh == null)
                thresh = 0.001;
            let congest = 0;
            for (let n = 0; n < this.points.length; n++) {
                let a = this.points[n];
                if (a == null)
                    continue;
                let dx = a.oval.cx - x, dy = a.oval.cy - y;
                congest += 1 / (dx * dx + dy * dy + thresh);
            }
            return congest;
        }
        annotateAtom(atom, text, col, fsz) {
            let [tw, ta] = this.measure.measureText(text, fsz);
            let a = this.points[atom - 1];
            let cx = a.oval.cx, cy = a.oval.cy, rw = 0.6 * tw, rh = 0.6 * ta;
            let otherTheta = [];
            for (let a of this.mol.atomAdjList(atom)) {
                let dx = this.points[a - 1].oval.cx - cx, dy = this.points[a - 1].oval.cy - cy;
                otherTheta.push(Math.atan2(dy, dx));
            }
            let minExt = 0.5 * (a.oval.rw + a.oval.rh), stepsz = 0.1 * this.scale, nsteps = 8;
            let angsteps = 36, angsz = WebMolKit.TWOPI / angsteps;
            let bestScore = Number.POSITIVE_INFINITY, bestDX = 0, bestDY = 0;
            let px = [0, 0, 0, 0], py = [0, 0, 0, 0];
            let limX = rw + minExt + nsteps * stepsz, limY = rh + minExt + nsteps * stepsz;
            let subSpace = this.spaceSubset(cx - limX, cy - limY, 2 * limX, 2 * limY);
            for (let step = 0; step < nsteps; step++) {
                let ext = minExt + step * stepsz;
                for (let ang = 0; ang < angsteps; ang++) {
                    let th = angsz * ang;
                    let dx = ext * Math.cos(th), dy = ext * Math.sin(th);
                    let x1 = cx + dx - rw, x2 = cx + dx + rw, y1 = cy + dy - rh, y2 = cy + dy + rh;
                    px[0] = x1;
                    py[0] = y1;
                    px[1] = x2;
                    py[1] = y1;
                    px[2] = x2;
                    py[2] = y2;
                    px[3] = x1;
                    py[3] = y2;
                    let viol = this.countPolyViolations(px, py, subSpace, false);
                    let score = viol * 1000;
                    for (let oth of otherTheta)
                        score -= Math.abs(WebMolKit.angleDiff(th, oth));
                    if (score < bestScore) {
                        bestScore = score;
                        bestDX = dx;
                        bestDY = dy;
                    }
                }
                if (bestScore < 500)
                    break;
            }
            let x = cx + bestDX, y = cy + bestDY;
            let an = {
                'anum': 0,
                'text': text,
                'fsz': fsz,
                'bold': false,
                'col': col,
                'oval': new WebMolKit.Oval(x, y, rw, rh),
            };
            this.points.push(an);
            let spc = {
                'anum': 0,
                'bnum': 0,
                'box': new WebMolKit.Box(x - rw, y - rh, 2 * rw, 2 * rh),
                'px': [x - rw, x + rw, x + rw, x - rw],
                'py': [y - rh, y - rh, y + rh, y + rh],
            };
            this.space.push(spc);
        }
        annotateBond(bond, text, col, fsz) {
            let [tw, ta] = this.measure.measureText(text, fsz);
            let bfr = this.mol.bondFrom(bond), bto = this.mol.bondTo(bond);
            let a1 = this.points[bfr - 1], a2 = this.points[bto - 1];
            let cx = 0.5 * (a1.oval.cx + a2.oval.cx), cy = 0.5 * (a1.oval.cy + a2.oval.cy), rw = 0.6 * tw, rh = 0.6 * ta;
            let bth = Math.atan2(a2.oval.cy - a1.oval.cy, a2.oval.cx - a1.oval.cx);
            let otherTheta = [bth, bth + Math.PI];
            for (let a of this.mol.atomAdjList(bfr))
                if (a != bto) {
                    let dx = this.points[a - 1].oval.cx - this.points[bfr - 1].oval.cx, dy = this.points[a - 1].oval.cy - this.points[bfr - 1].oval.cy;
                    otherTheta.push(Math.atan2(dy, dx));
                }
            for (let a of this.mol.atomAdjList(bto))
                if (a != bfr) {
                    let dx = this.points[a - 1].oval.cx - this.points[bto - 1].oval.cx, dy = this.points[a - 1].oval.cy - this.points[bto - 1].oval.cy;
                    otherTheta.push(Math.atan2(dy, dx));
                }
            let minExt = 0.2 * this.scale * this.bondOrder[bond - 1], stepsz = 0.1 * this.scale, nsteps = 8;
            let angsteps = 36, angsz = WebMolKit.TWOPI / angsteps;
            let bestScore = Number.POSITIVE_INFINITY, bestDX = 0, bestDY = 0;
            let px = [0, 0, 0, 0], py = [0, 0, 0, 0];
            let limX = rw + minExt + nsteps * stepsz, limY = rh + minExt + nsteps * stepsz;
            let subSpace = this.spaceSubset(cx - limX, cy - limY, 2 * limX, 2 * limY);
            for (let step = 0; step < nsteps; step++) {
                let ext = minExt + step * stepsz;
                for (let ang = 0; ang < angsteps; ang++) {
                    let th = angsz * ang;
                    let dx = ext * Math.cos(th), dy = ext * Math.sin(th);
                    let x1 = cx + dx - rw, x2 = cx + dx + rw, y1 = cy + dy - rh, y2 = cy + dy + rh;
                    px[0] = x1;
                    py[0] = y1;
                    px[1] = x2;
                    py[1] = y1;
                    px[2] = x2;
                    py[2] = y2;
                    px[3] = x1;
                    py[3] = y2;
                    let viol = this.countPolyViolations(px, py, subSpace, false);
                    let score = viol * 1000;
                    for (let oth of otherTheta)
                        score -= Math.abs(WebMolKit.angleDiff(th, oth));
                    if (score < bestScore) {
                        bestScore = score;
                        bestDX = dx;
                        bestDY = dy;
                    }
                }
                if (bestScore < 500)
                    break;
            }
            let x = cx + bestDX, y = cy + bestDY;
            let an = {
                'anum': 0,
                'text': text,
                'fsz': fsz,
                'bold': false,
                'col': col,
                'oval': new WebMolKit.Oval(x, y, rw, rh),
            };
            this.points.push(an);
            let spc = {
                'anum': 0,
                'bnum': 0,
                'box': new WebMolKit.Box(x - rw, y - rh, 2 * rw, 2 * rh),
                'px': [x - rw, x + rw, x + rw, x - rw],
                'py': [y - rh, y - rh, y + rh, y + rh],
            };
            this.space.push(spc);
        }
        boxOverlaps(x, y, w, h, pointmask, linemask) {
            let vx1 = x, vy1 = y, vx2 = x + w, vy2 = y + h;
            for (let n = 0; n < this.points.length; n++) {
                if (pointmask != null && !pointmask[n])
                    continue;
                let a = this.points[n];
                let wx1 = a.oval.cx - a.oval.rw, wy1 = a.oval.cy - a.oval.rh, wx2 = a.oval.cx + a.oval.rw, wy2 = a.oval.cy + a.oval.rh;
                if (vx2 < wx1 || vx1 > wx2 || vy2 < wy1 || vy1 > wy2)
                    continue;
                return true;
            }
            for (let n = 0; n < this.lines.length; n++) {
                if (linemask != null && !linemask[n])
                    continue;
                let b = this.lines[n];
                let wx1 = b.line.x1, wy1 = b.line.y1, wx2 = b.line.x2, wy2 = b.line.y2;
                if (vx2 < Math.min(wx1, wx2) || vx1 > Math.max(wx1, wx2) || vy2 < Math.min(wy1, wy2) || vy1 > Math.max(wy1, wy2))
                    continue;
                if (wx1 >= vx1 && wx1 <= vx2 && wy1 >= vy1 && wy1 <= vy2)
                    return true;
                if (wx2 >= vx1 && wx2 <= vx2 && wy2 >= vy1 && wy2 <= vy2)
                    return true;
                if (WebMolKit.GeomUtil.doLineSegsIntersect(wx1, wy1, wx2, wy2, vx1, vy1, vx2, vy1))
                    return true;
                if (WebMolKit.GeomUtil.doLineSegsIntersect(wx1, wy1, wx2, wy2, vx1, vy2, vx2, vy2))
                    return true;
                if (WebMolKit.GeomUtil.doLineSegsIntersect(wx1, wy1, wx2, wy2, vx1, vy1, vx1, vy2))
                    return true;
                if (WebMolKit.GeomUtil.doLineSegsIntersect(wx1, wy1, wx2, wy2, vx2, vy1, vx2, vy2))
                    return true;
            }
            return false;
        }
        resolveLineCrossings(bondHigher, bondLower) {
            while (true) {
                let anything = false;
                for (let i1 = 0; i1 < this.lines.length; i1++) {
                    let b1 = this.lines[i1];
                    if (b1.bnum != bondHigher)
                        continue;
                    if (b1.type != BLineType.Normal && b1.type != BLineType.Dotted && b1.type != BLineType.DotDir)
                        continue;
                    for (let i2 = 0; i2 < this.lines.length; i2++) {
                        let b2 = this.lines[i2];
                        if (b2.bnum != bondLower)
                            continue;
                        if (b2.type == BLineType.DotDir)
                            b2.type = BLineType.Dotted;
                        if (b2.type != BLineType.Normal && b2.type != BLineType.Dotted)
                            continue;
                        if (b1.bfr == b2.bfr || b1.bfr == b2.bto || b1.bto == b2.bfr || b1.bto == b2.bto)
                            continue;
                        if (!WebMolKit.GeomUtil.doLineSegsIntersect(b1.line.x1, b1.line.y1, b1.line.x2, b1.line.y2, b2.line.x1, b2.line.y1, b2.line.x2, b2.line.y2))
                            continue;
                        let xy = WebMolKit.GeomUtil.lineIntersect(b1.line.x1, b1.line.y1, b1.line.x2, b1.line.y2, b2.line.x1, b2.line.y1, b2.line.x2, b2.line.y2);
                        let dx = b2.line.x2 - b2.line.x1, dy = b2.line.y2 - b2.line.y1;
                        let ext = Math.abs(dx) > Math.abs(dy) ? (xy[0] - b2.line.x1) / dx : (xy[1] - b2.line.y1) / dy;
                        let dist = WebMolKit.norm_xy(dx, dy);
                        let delta = b2.size / dist * (b2.type == BLineType.Normal ? 2 : 4);
                        if (ext > delta && ext < 1 - delta) {
                            let b3 = {
                                'bnum': b2.bnum,
                                'bfr': b2.bfr,
                                'bto': b2.bto,
                                'type': b2.type,
                                'line': b2.line.clone(),
                                'size': b2.size,
                                'head': b2.head,
                                'col': b2.col
                            };
                            this.lines.push(b3);
                            b2.line.x2 = b2.line.x1 + dx * (ext - delta);
                            b2.line.y2 = b2.line.y1 + dy * (ext - delta);
                            b3.line.x1 = b3.line.x1 + dx * (ext + delta);
                            b3.line.y1 = b3.line.y1 + dy * (ext + delta);
                            anything = true;
                        }
                        else if (ext > delta) {
                            b2.line.x2 = b2.line.x1 + dx * (ext - delta);
                            b2.line.y2 = b2.line.y1 + dy * (ext - delta);
                            anything = true;
                        }
                        else if (ext < 1 - delta) {
                            b2.line.x1 = b2.line.x1 + dx * (ext + delta);
                            b2.line.y1 = b2.line.y1 + dy * (ext + delta);
                            anything = true;
                        }
                    }
                }
                if (!anything)
                    break;
            }
        }
        createCircularRing(atoms) {
            let cx = 0, cy = 0;
            for (let a of atoms) {
                let pt = this.points[a - 1];
                cx += pt.oval.cx;
                cy += pt.oval.cy;
            }
            cx /= atoms.length;
            cy /= atoms.length;
            let bx = [], by = [];
            let isRegular = true;
            let regDist = Number.NaN;
            for (let a of atoms) {
                let pt = this.points[a - 1];
                let x0 = pt.oval.cx - cx, y0 = pt.oval.cy - cy, x1 = x0 - pt.oval.rw, x2 = x0 + pt.oval.rw, y1 = y0 - pt.oval.rh, y2 = y0 + pt.oval.rh;
                bx.push(x1);
                by.push(y0);
                bx.push(x1);
                by.push(y1);
                bx.push(x1);
                by.push(y2);
                bx.push(x0);
                by.push(y1);
                bx.push(x0);
                by.push(y2);
                bx.push(x2);
                by.push(y0);
                bx.push(x2);
                by.push(y1);
                bx.push(x2);
                by.push(y2);
                let dist = WebMolKit.norm_xy(x0, y0), theta = Math.atan2(y0, x0);
                const FRACT = 0.7;
                bx.push(FRACT * dist * Math.cos(theta));
                by.push(FRACT * dist * Math.sin(theta));
                for (let b of this.mol.atomAdjList(a))
                    if (atoms.indexOf(b) >= 0) {
                        let pb = this.points[b - 1];
                        let mx = 0.5 * (pt.oval.cx + pb.oval.cx) - cx, my = 0.5 * (pt.oval.cy + pb.oval.cy) - cy;
                        let mdist = WebMolKit.norm_xy(mx, my), mtheta = Math.atan2(my, mx);
                        bx.push(FRACT * mdist * Math.cos(mtheta));
                        by.push(FRACT * mdist * Math.sin(mtheta));
                    }
                if (!isRegular) { }
                else if (Number.isFinite(regDist)) {
                    if (Math.abs(regDist - dist) > 1)
                        isRegular = false;
                }
                else
                    regDist = dist;
            }
            let r = { 'atoms': atoms, 'cx': cx, 'cy': cy, 'rw': 0, 'rh': 0, 'size': 0 };
            if (isRegular) {
                r.rw = r.rh = WebMolKit.GeomUtil.fitCircle(bx, by);
            }
            else {
                let lowX = WebMolKit.Vec.min(bx) - 10 * WebMolKit.Vec.range(bx), highX = WebMolKit.Vec.max(bx) + 10 * WebMolKit.Vec.range(bx);
                let lowY = WebMolKit.Vec.min(by) - 10 * WebMolKit.Vec.range(by), highY = WebMolKit.Vec.max(by) + 10 * WebMolKit.Vec.range(by);
                let minX = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;
                for (let n = 0; n < atoms.length; n++) {
                    let nn = n < atoms.length - 1 ? n + 1 : 0;
                    let p1 = this.points[atoms[n] - 1], p2 = this.points[atoms[nn] - 1];
                    let x1 = p1.oval.cx - cx - 0.1 * (p2.oval.cx - p1.oval.cx), y1 = p1.oval.cy - cy - 0.1 * (p2.oval.cy - p1.oval.cy);
                    let x2 = p2.oval.cx - cx + 0.1 * (p2.oval.cx - p1.oval.cx), y2 = p2.oval.cy - cy + 0.1 * (p2.oval.cy - p1.oval.cy);
                    if (WebMolKit.GeomUtil.doLineSegsIntersect(x1, y1, x2, y2, lowX, 0, highX, 0)) {
                        let xy = WebMolKit.GeomUtil.lineIntersect(x1, y1, x2, y2, lowX, 0, highX, 0);
                        minX = Math.min(minX, xy[0]);
                        maxX = Math.max(maxX, xy[0]);
                    }
                    if (WebMolKit.GeomUtil.doLineSegsIntersect(x1, y1, x2, y2, 0, lowY, 0, highY)) {
                        let xy = WebMolKit.GeomUtil.lineIntersect(x1, y1, x2, y2, 0, lowY, 0, highY);
                        minY = Math.min(minY, xy[1]);
                        maxY = Math.max(maxY, xy[1]);
                    }
                }
                let rwh = WebMolKit.GeomUtil.fitEllipse(bx, by, minX, minY, maxX, maxY);
                r.rw = rwh[0];
                r.rh = rwh[1];
            }
            r.size = this.lineSizePix;
            this.rings.push(r);
        }
        createCurvedPath(atoms, fractional, extAtom) {
            const sz = atoms.length, szn = sz - 1;
            let x = [], y = [], symbol = [];
            for (let n = 0; n < sz; n++) {
                let pt = this.points[atoms[n] - 1];
                x.push(pt.oval.cx);
                y.push(pt.oval.cy);
                symbol.push(pt.text != null);
            }
            let ox = [], oy = [];
            const EXT = WebMolKit.Molecule.IDEALBOND * 0.25 * this.scale;
            for (let n = 0; n < sz - 1; n++) {
                let dx = x[n + 1] - x[n], dy = y[n + 1] - y[n], invD = EXT * WebMolKit.invZ(WebMolKit.norm_xy(dx, dy));
                ox.push(dy * invD);
                oy.push(-dx * invD);
            }
            const FAR = 1.2, CLOSE = 0.7;
            let sx1 = WebMolKit.Vec.numberArray(0, sz), sy1 = WebMolKit.Vec.numberArray(0, sz), sx2 = WebMolKit.Vec.numberArray(0, sz), sy2 = WebMolKit.Vec.numberArray(0, sz);
            const capA = symbol[0] ? FAR : CLOSE;
            if (!fractional) {
                sx1[0] = x[0] + ox[0] * capA;
                sy1[0] = y[0] + oy[0] * capA;
                sx2[0] = x[0] - ox[0] * capA;
                sy2[0] = y[0] - oy[0] * capA;
            }
            else {
                const dx = -oy[0], dy = ox[0];
                sx1[0] = x[0] + dx * capA;
                sy1[0] = y[0] + dy * capA;
                sx2[0] = x[0] + dx * capA;
                sy2[0] = y[0] + dy * capA;
            }
            let ncross1 = 0, ncross2 = 0;
            for (let n = 1; n < sz - 1; n++) {
                const fr1 = symbol[n] ? FAR : CLOSE, fr2 = fr1;
                sx1[n] = x[n] + fr1 * (ox[n - 1] + ox[n]);
                sy1[n] = y[n] + fr1 * (oy[n - 1] + oy[n]);
                sx2[n] = x[n] - fr2 * (ox[n - 1] + ox[n]);
                sy2[n] = y[n] - fr2 * (oy[n - 1] + oy[n]);
                for (let a of this.mol.atomAdjList(atoms[n]))
                    if (atoms.indexOf(a) < 0 && a != extAtom) {
                        let pt = this.points[a - 1];
                        let dx = pt.oval.cx - x[n], dy = pt.oval.cy - y[n];
                        let dot1 = dx * (sx1[n] - x[n]) + dy * (sy1[n] - x[n]);
                        let dot2 = dy * (sx2[n] - x[n]) + dy * (sy2[n] - x[n]);
                        if (dot1 > dot2)
                            ncross1++;
                        else
                            ncross2++;
                    }
            }
            let nn = sz - 1;
            let capB = symbol[nn] ? FAR : CLOSE;
            if (!fractional) {
                sx1[nn] = x[nn] + ox[nn - 1] * capB;
                sy1[nn] = y[nn] + oy[nn - 1] * capB;
                sx2[nn] = x[nn] - ox[nn - 1] * capB;
                sy2[nn] = y[nn] - oy[nn - 1] * capB;
            }
            else {
                let dx = -oy[nn - 1], dy = ox[nn - 1];
                sx1[nn] = x[nn] - dx * capB;
                sy1[nn] = y[nn] - dy * capB;
                sx2[nn] = x[nn] - dx * capB;
                sy2[nn] = y[nn] - dy * capB;
            }
            let score1 = 0, score2 = 0;
            for (let n = 0; n < sz - 1; n++) {
                score1 += WebMolKit.norm_xy(sx1[n + 1] - sx1[n], sy1[n + 1] - sy1[n]);
                score2 += WebMolKit.norm_xy(sx2[n + 1] - sx2[n], sy2[n + 1] - sy2[n]);
            }
            score1 *= ncross1 + 1;
            score2 *= ncross2 + 1;
            let sx = score1 < score2 ? sx1 : sx2;
            let sy = score1 < score2 ? sy1 : sy2;
            let p = { 'atoms': atoms, 'px': null, 'py': null, 'ctrl': null, 'size': this.lineSizePix };
            this.splineInterpolate(p, sx, sy);
            this.paths.push(p);
        }
        createBondCentroid(from, to) {
            let pt = this.points[from - 1];
            let x1 = pt.oval.cx, y1 = pt.oval.cy, x2 = 0, y2 = 0;
            for (let a of to) {
                pt = this.points[a - 1];
                x2 += pt.oval.cx;
                y2 += pt.oval.cy;
            }
            x2 /= to.length;
            y2 /= to.length;
            if (to.length <= 2) {
                x2 -= 0.1 * (x2 - x1);
                y2 -= 0.1 * (y2 - y1);
            }
            const minDist = MINBOND_LINE * this.measure.scale();
            let xy1 = this.backOffAtom(from, x1, y1, x2, y2, minDist);
            this.ensureMinimumBondLength(xy1, [x2, y2], x1, y1, x2, y2, minDist);
            let b = {
                'bnum': 0, 'bfr': from, 'bto': 0,
                'type': BLineType.Normal, 'line': new WebMolKit.Line(xy1[0], xy1[1], x2, y2),
                'size': this.lineSizePix, 'head': 0, 'col': this.policy.data.foreground
            };
            this.lines.push(b);
            this.space.push(this.computeSpaceLine(b));
        }
        splineInterpolate(path, x, y) {
            const sz = x.length;
            const scale = 0.25;
            for (let n = 0; n < sz; n++) {
                if (n == 0) {
                    let dx = x[n + 1] - x[n], dy = y[n + 1] - y[n];
                    let qx = x[n] + scale * dx, qy = y[n] + scale * dy;
                    path.px = WebMolKit.Vec.append(path.px, x[n]);
                    path.py = WebMolKit.Vec.append(path.py, y[n]);
                    path.ctrl = WebMolKit.Vec.append(path.ctrl, false);
                    path.px = WebMolKit.Vec.append(path.px, qx);
                    path.py = WebMolKit.Vec.append(path.py, qy);
                    path.ctrl = WebMolKit.Vec.append(path.ctrl, true);
                }
                else if (n == sz - 1) {
                    let dx = x[n] - x[n - 1], dy = y[n] - y[n - 1];
                    let qx = x[n] - scale * dx, qy = y[n] - scale * dy;
                    path.px = WebMolKit.Vec.append(path.px, qx);
                    path.py = WebMolKit.Vec.append(path.py, qy);
                    path.ctrl = WebMolKit.Vec.append(path.ctrl, true);
                    path.px = WebMolKit.Vec.append(path.px, x[n]);
                    path.py = WebMolKit.Vec.append(path.py, y[n]);
                    path.ctrl = WebMolKit.Vec.append(path.ctrl, false);
                }
                else {
                    let dx = x[n + 1] - x[n - 1], dy = y[n + 1] - y[n - 1];
                    let invD = WebMolKit.invZ(WebMolKit.norm_xy(dx, dy));
                    dx *= invD;
                    dy *= invD;
                    let d1 = scale * WebMolKit.norm_xy(x[n] - x[n - 1], y[n] - y[n - 1]), d2 = scale * WebMolKit.norm_xy(x[n + 1] - x[n], y[n + 1] - y[n]);
                    let qx1 = x[n] - dx * d1, qy1 = y[n] - dy * d1;
                    let qx2 = x[n] + dx * d2, qy2 = y[n] + dy * d2;
                    path.px = WebMolKit.Vec.append(path.px, qx1);
                    path.py = WebMolKit.Vec.append(path.py, qy1);
                    path.ctrl = WebMolKit.Vec.append(path.ctrl, true);
                    path.px = WebMolKit.Vec.append(path.px, x[n]);
                    path.py = WebMolKit.Vec.append(path.py, y[n]);
                    path.ctrl = WebMolKit.Vec.append(path.ctrl, false);
                    path.px = WebMolKit.Vec.append(path.px, qx2);
                    path.py = WebMolKit.Vec.append(path.py, qy2);
                    path.ctrl = WebMolKit.Vec.append(path.ctrl, true);
                }
            }
        }
        delocalisedAnnotation(atoms, charge, unpaired) {
            const mol = this.mol;
            let str = '';
            if (charge == -1)
                str = '-';
            else if (charge == 1)
                str = '+';
            else if (charge < -1)
                str = Math.abs(charge) + '-';
            else if (charge > 1)
                str = charge + '+';
            if (unpaired > 0)
                for (let n = 0; n < unpaired; n++)
                    str += '.';
            if (str.length == 0)
                return;
            const sz = atoms.length;
            let bestX = 0, bestY = 0;
            for (let a of atoms) {
                bestX += mol.atomX(a);
                bestY += mol.atomY(a);
            }
            bestX /= sz;
            bestY /= sz;
            let bestScore = WebMolKit.CoordUtil.congestionPoint(mol, bestX, bestY);
            for (let n = 1; n < sz - 1; n++) {
                let x = 0.5 * (mol.atomX(atoms[n - 1]) + mol.atomX(atoms[n + 1])), y = 0.5 * (mol.atomY(atoms[n - 1]) + mol.atomY(atoms[n + 1]));
                let score = WebMolKit.CoordUtil.congestionPoint(mol, x, y);
                if (score < bestScore) {
                    bestScore = score;
                    bestX = x;
                    bestY = y;
                }
            }
            let fsz = 0.8 * this.fontSizePix;
            let wad = this.measure.measureText(str, fsz);
            let rw = 0.55 * wad[0], rh = 0.55 * wad[1];
            let a = {
                'anum': 0,
                'text': str,
                'fsz': fsz,
                'bold': false,
                'col': this.policy.data.foreground,
                'oval': new WebMolKit.Oval(this.measure.angToX(bestX), this.measure.angToY(bestY), rw, rh)
            };
            this.points.push(a);
            let spc = {
                'anum': 0,
                'bnum': 0,
                'box': new WebMolKit.Box(a.oval.cx - rw, a.oval.cy - rh, 2 * rw, 2 * rh),
                'px': [a.oval.cx - rw, a.oval.cx + rw, a.oval.cx + rw, a.oval.cx - rw],
                'py': [a.oval.cy - rh, a.oval.cy - rh, a.oval.cy + rh, a.oval.cy + rh]
            };
            this.space.push(spc);
        }
        processPolymerUnit(unit, allUnits) {
            if (WebMolKit.Vec.len(unit.bondConn) == 4) {
                this.processPolymerUnitPair(unit);
                return;
            }
            let brackets = [];
            const { mol, measure } = this;
            for (let n = 1; n <= mol.numBonds; n++) {
                let a1 = mol.bondFrom(n), a2 = mol.bondTo(n);
                let in1 = unit.atoms.indexOf(a1) >= 0, in2 = unit.atoms.indexOf(a2) >= 0;
                let bracket = null;
                if (in1 && !in2)
                    bracket = { a1, a2 };
                else if (in2 && !in1)
                    bracket = { 'a1': a2, 'a2': a1 };
                else
                    continue;
                bracket.x1 = mol.atomX(bracket.a1);
                bracket.y1 = mol.atomY(bracket.a1);
                bracket.x2 = mol.atomX(bracket.a2);
                bracket.y2 = mol.atomY(bracket.a2);
                bracket.shared = false;
                for (let other of allUnits)
                    if (unit !== other && other.atoms.includes(bracket.a2)) {
                        bracket.shared = true;
                        break;
                    }
                let nestings = allUnits.filter((look) => look === unit || (look.atoms.includes(bracket.a1) && !look.atoms.includes(bracket.a2)));
                if (nestings.length > 1) {
                    nestings.sort((u1, u2) => u1.atoms.length - u2.atoms.length);
                    for (let i = 0; i < nestings.length; i++)
                        if (nestings[i] === unit)
                            bracket.nestOrder = i;
                    bracket.nestCount = nestings.length;
                }
                brackets.push(bracket);
            }
            let tagidx = 0;
            let atomX = unit.atoms.map((a) => mol.atomX(a)), atomY = unit.atoms.map((a) => mol.atomY(a));
            let minX = WebMolKit.Vec.min(atomX), minY = WebMolKit.Vec.min(atomY);
            let maxX = WebMolKit.Vec.max(atomX), maxY = WebMolKit.Vec.max(atomY);
            for (let n = 1; n < brackets.length; n++) {
                let b1 = brackets[tagidx], b2 = brackets[n];
                let score1 = b1.x2 - minX - b1.y2 + minY;
                let score2 = b2.x2 - minX - b2.y2 + minY;
                if (score2 > score1)
                    tagidx = n;
            }
            let isLinear = false, isOuter = false;
            if (brackets.length == 2) {
                let left = brackets[tagidx == 0 ? 1 : 0], right = brackets[tagidx];
                let theta1 = Math.atan2(left.y2 - left.y1, left.x2 - left.x1);
                let theta2 = Math.atan2(right.y2 - right.y1, right.x2 - right.x1);
                isLinear = (theta1 > 145 * WebMolKit.DEGRAD || theta1 < -145 * WebMolKit.DEGRAD) && theta2 < 35 * WebMolKit.DEGRAD && theta2 > -35 * WebMolKit.DEGRAD;
            }
            else if (brackets.length == 0) {
                let ym = 0.5 * (minY + maxY);
                brackets.push({ 'x1': minX, 'y1': ym, 'x2': minX - 1, 'y2': ym });
                brackets.push({ 'x1': maxX, 'y1': ym, 'x2': maxX + 1, 'y2': ym });
                tagidx = 1;
                isOuter = true;
            }
            let bsz1 = (isOuter ? 0.5 * (maxY - minY + 1) : isLinear ? 1.0 : 0.5) * this.scale, bsz2 = 0.2 * this.scale;
            const BASE_LINE = { 'bnum': 0, 'bfr': 0, 'bto': 0, 'type': BLineType.Normal, 'size': this.lineSizePix, 'head': 0, 'col': this.policy.data.foreground };
            const BASE_TEXT = { 'anum': 0, 'fsz': 0.7 * this.fontSizePix, 'bold': false, 'col': this.policy.data.foreground };
            for (let n = 0; n < brackets.length; n++) {
                let bracket = brackets[n];
                let x1 = measure.angToX(bracket.x1), y1 = measure.angToY(bracket.y1);
                let x2 = measure.angToX(bracket.x2), y2 = measure.angToY(bracket.y2);
                if (bracket.shared) {
                    x2 -= (x2 - x1) * 0.1;
                    y2 -= (y2 - y1) * 0.1;
                }
                if (bracket.nestCount > 1) {
                    let dx = x2 - x1, dy = y2 - y1, fract = (bracket.nestOrder + 1) / bracket.nestCount;
                    x2 = x1 + dx * fract;
                    y2 = y1 + dy * fract;
                }
                let mx = 0.5 * (x1 + x2), my = 0.5 * (y1 + y2);
                if (isLinear) {
                    x1 = x2 = mx;
                    y1 = y2 = my;
                    if (n == tagidx) {
                        x1--;
                        x2++;
                    }
                    else {
                        x1++;
                        x2--;
                    }
                }
                let invDist = WebMolKit.invZ(WebMolKit.norm_xy(x2 - x1, y2 - y1));
                let dx = (x2 - x1) * invDist, dy = (y2 - y1) * invDist;
                let ox = dy, oy = -dx;
                let px2 = mx - bsz1 * ox, py2 = my - bsz1 * oy;
                let px3 = mx + bsz1 * ox, py3 = my + bsz1 * oy;
                let px1 = px2 - bsz2 * dx, py1 = py2 - bsz2 * dy;
                let px4 = px3 - bsz2 * dx, py4 = py3 - bsz2 * dy;
                let line1 = Object.assign(Object.assign({}, BASE_LINE), { 'line': new WebMolKit.Line(px1, py1, px2, py2) });
                let line2 = Object.assign(Object.assign({}, BASE_LINE), { 'line': new WebMolKit.Line(px2, py2, px3, py3) });
                let line3 = Object.assign(Object.assign({}, BASE_LINE), { 'line': new WebMolKit.Line(px3, py3, px4, py4) });
                this.lines.push(line1);
                this.lines.push(line2);
                this.lines.push(line3);
                this.space.push(this.computeSpaceLine(line1));
                this.space.push(this.computeSpaceLine(line2));
                this.space.push(this.computeSpaceLine(line3));
                if (n == tagidx) {
                    let xx, yy;
                    if (bracket.shared)
                        [xx, yy] = [px2 - 0.5 * this.scale * ox, py2 - 0.5 * this.scale * oy];
                    else
                        [xx, yy] = [px2 + bsz2 * 2 * dx, py2 + bsz2 * 2 * dy];
                    let pt1 = Object.assign(Object.assign({}, BASE_TEXT), { 'text': 'n', 'oval': new WebMolKit.Oval(xx, yy, 0, 0) });
                    this.points.push(pt1);
                    this.space.push(this.computeSpacePoint(pt1));
                    if (unit.connect != null) {
                        let text = '?';
                        if (unit.connect == WebMolKit.PolymerBlockConnectivity.HeadToTail)
                            text = 'ht';
                        else if (unit.connect == WebMolKit.PolymerBlockConnectivity.HeadToHead)
                            text = 'hh';
                        else if (unit.connect == WebMolKit.PolymerBlockConnectivity.Random)
                            text = 'eu';
                        if (bracket.shared)
                            [xx, yy] = [px3 + 0.5 * this.scale * ox, py3 + 0.5 * this.scale * oy];
                        else
                            [xx, yy] = [px3 + bsz2 * 2.5 * dx, py3 + bsz2 * 2.5 * dy];
                        let pt2 = Object.assign(Object.assign({}, BASE_TEXT), { 'text': text, 'oval': new WebMolKit.Oval(xx, yy, 0, 0) });
                        this.points.push(pt2);
                        this.space.push(this.computeSpacePoint(pt2));
                    }
                }
            }
        }
        processPolymerUnitPair(unit) {
            const { mol, measure } = this;
            let xpos = [], ypos = [];
            for (let b of unit.bondConn) {
                let bfr = mol.bondFrom(b), bto = mol.bondTo(b);
                xpos.push(measure.angToX(0.5 * (mol.atomX(bfr) + mol.atomX(bto))));
                ypos.push(measure.angToY(0.5 * (mol.atomY(bfr) + mol.atomY(bto))));
            }
            let cx = WebMolKit.Vec.sum(xpos) * 0.25, cy = WebMolKit.Vec.sum(ypos) * 0.25;
            let bsz = 0.5 * this.scale;
            let rx = [], ry = [];
            for (let [i1, i2] of [[0, 1], [2, 3]]) {
                let dx = xpos[i2] - xpos[i1], dy = ypos[i2] - ypos[i1], inv = bsz * WebMolKit.invZ(WebMolKit.norm_xy(dx, dy) + 0.001);
                [dx, dy] = [dx * inv, dy * inv];
                xpos[i1] -= 2 * dx;
                ypos[i1] -= 2 * dy;
                xpos[i2] += 2 * dx;
                ypos[i2] += 2 * dy;
                let ox = dy, oy = -dx;
                let dsq1 = WebMolKit.norm2_xy(0.5 * (xpos[i1] + xpos[i2]) + ox - cx, 0.5 * (ypos[i1] + ypos[i2]) + oy - cy);
                let dsq2 = WebMolKit.norm2_xy(0.5 * (xpos[i1] + xpos[i2]) - ox - cx, 0.5 * (ypos[i1] + ypos[i2]) - oy - cy);
                if (dsq2 < dsq1)
                    [ox, oy] = [-ox, -oy];
                rx.push(...[ox, ox]);
                ry.push(...[oy, oy]);
            }
            const BASE_LINE = { 'bnum': 0, 'bfr': 0, 'bto': 0, 'type': BLineType.Normal, 'size': this.lineSizePix, 'head': 0, 'col': this.policy.data.foreground };
            const BASE_TEXT = { 'anum': 0, 'fsz': 0.7 * this.fontSizePix, 'bold': false, 'col': this.policy.data.foreground };
            let drawLine = (x1, y1, x2, y2) => {
                let line = Object.assign(Object.assign({}, BASE_LINE), { 'line': new WebMolKit.Line(x1, y1, x2, y2) });
                this.lines.push(line);
                this.space.push(this.computeSpaceLine(line));
            };
            let drawText = (x, y, txt) => {
                let pt = Object.assign(Object.assign({}, BASE_TEXT), { 'text': txt, 'oval': new WebMolKit.Oval(x, y, 0, 0) });
                this.points.push(pt);
                this.space.push(this.computeSpacePoint(pt));
            };
            drawLine(xpos[0], ypos[0], xpos[1], ypos[1]);
            drawLine(xpos[0], ypos[0], xpos[0] + rx[0], ypos[0] + ry[0]);
            drawLine(xpos[1], ypos[1], xpos[1] + rx[1], ypos[1] + ry[1]);
            drawLine(xpos[2], ypos[2], xpos[3], ypos[3]);
            drawLine(xpos[2], ypos[2], xpos[2] + rx[2], ypos[2] + ry[2]);
            drawLine(xpos[3], ypos[3], xpos[3] + rx[3], ypos[3] + ry[3]);
            let xmin = WebMolKit.Vec.min(xpos), ymin = WebMolKit.Vec.min(ypos);
            let dist = [];
            for (let n = 0; n < 4; n++)
                dist.push(xpos[n] - xmin + ypos[n] - ymin);
            let idxN = WebMolKit.Vec.idxMax(dist);
            drawText(xpos[idxN] - rx[idxN], ypos[idxN] - ry[idxN], 'n');
            let idxD2 = idxN + (idxN % 2 == 1 ? -1 : 1), idxD1 = (idxD2 + 2) % 4;
            drawText(xpos[idxD1] - 0.5 * rx[idxD1], ypos[idxD1] - 0.5 * ry[idxD1], '*');
            drawText(xpos[idxD2] - 0.5 * rx[idxD2], ypos[idxD2] - 0.5 * ry[idxD2], '*');
        }
    }
    ArrangeMolecule.FONT_CORRECT = 1.5;
    WebMolKit.ArrangeMolecule = ArrangeMolecule;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class AxisLabeller {
        constructor(width, minVal, maxVal, textWidth, inverse) {
            this.width = width;
            this.minVal = minVal;
            this.maxVal = maxVal;
            this.textWidth = textWidth;
            this.inverse = inverse;
            this.notches = [];
        }
        calculate() {
            if (this.minVal == this.maxVal) {
                this.notches.push({
                    'label': this.minVal.toString(),
                    'value': this.minVal,
                    'pos': 0.5 * this.width
                });
                return;
            }
            const width = this.width, minVal = this.minVal, maxVal = this.maxVal;
            const range = maxVal - minVal, invRange = 1.0 / range;
            let position = (val) => width * (val - minVal) * invRange;
            let loT = null, hiT = null;
            const bumpLess = 1 - 1E-5, bumpMore = 1 + 1E-5;
            got: for (let outer = 1E-10; outer <= 1E11; outer *= 10)
                for (let inner of [0.2, 0.5, 1]) {
                    let mag = outer * inner, inv = 1.0 / mag;
                    let t1 = Math.floor(minVal * mag * bumpLess) * inv, t2 = Math.round(minVal * mag) * inv, t3 = Math.ceil(minVal * mag * bumpMore) * inv;
                    let t4 = Math.floor(maxVal * mag * bumpLess) * inv, t5 = Math.round(maxVal * mag) * inv, t6 = Math.ceil(maxVal * mag * bumpMore) * inv;
                    let p1 = position(t1), p2 = position(t2), p3 = position(t3);
                    let p4 = position(t4), p5 = position(t5), p6 = position(t6);
                    if ((WebMolKit.fltEqual(p1, 0) || p1 >= 0) && p1 <= 0.1 * width)
                        loT = t1;
                    else if ((WebMolKit.fltEqual(p2, 0) || p2 >= 0) && p2 <= 0.1 * width)
                        loT = t2;
                    else if ((WebMolKit.fltEqual(p3, 0) || p3 >= 0) && p3 <= 0.1 * width)
                        loT = t3;
                    else
                        continue;
                    if (p6 >= 0.9 * width && (WebMolKit.fltEqual(p6, width) || p6 <= width))
                        hiT = t6;
                    else if (p5 >= 0.9 * width && (WebMolKit.fltEqual(p5, width) || p5 <= width))
                        hiT = t5;
                    else if (p4 >= 0.9 * width && (WebMolKit.fltEqual(p4, width) || p4 <= width))
                        hiT = t4;
                    else
                        continue;
                    break got;
                }
            if (loT == null || hiT == null)
                return;
            let loVal = this.inverse(loT), hiVal = this.inverse(hiT);
            this.notches.push({
                'label': this.formatNumber(loVal),
                'value': loVal,
                'pos': position(loT)
            });
            this.notches.push({
                'label': this.formatNumber(hiVal),
                'value': hiVal,
                'pos': position(hiT)
            });
        }
        formatNumber(num) {
            let str = num.toPrecision(4);
            str = str.replace(/^(-?\d+)\.0+$/, '$1');
            str = str.replace(/^(-?\d+\.0*[1-9]+)0+$/, '$1');
            str = str.replace(/^(-?\d+)\.0+(e[\+\-]\d+)$/, '$1$2');
            str = str.replace(/^(-?\d+\.0*[1-9]+)0+(e[\+\-]\d+)$/, '$1$2');
            return str;
        }
    }
    WebMolKit.AxisLabeller = AxisLabeller;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class DrawExperiment {
        constructor(layout, vg) {
            this.layout = layout;
            this.vg = vg;
            this.preDrawComponent = null;
            this.preDrawMolecule = null;
            this.postDrawMolecule = null;
            this.molDrawn = [];
            this.entry = layout.entry;
            this.measure = layout.measure;
            this.policy = layout.policy;
            this.scale = layout.scale;
            this.invScale = 1.0 / this.scale;
        }
        draw() {
            this.molDrawn = WebMolKit.Vec.anyArray(null, this.layout.components.length);
            for (let n = 0; n < this.layout.components.length; n++) {
                let xc = this.layout.components[n];
                if (xc.type == WebMolKit.ArrangeComponentType.Arrow)
                    this.drawSymbolArrow(xc);
                else if (xc.type == WebMolKit.ArrangeComponentType.Plus)
                    this.drawSymbolPlus(xc);
                else
                    this.drawComponent(n, xc);
            }
        }
        drawComponent(idx, xc) {
            let vg = this.vg, policy = this.policy;
            let bx = xc.box.x + xc.padding, by = xc.box.y + xc.padding;
            let bw = xc.box.w - 2 * xc.padding, bh = xc.box.h - 2 * xc.padding;
            if (this.preDrawComponent)
                this.preDrawComponent(vg, idx, xc);
            if (xc.srcIdx < 0 || (WebMolKit.MolUtil.isBlank(xc.mol) && WebMolKit.Vec.isBlank(xc.text))) {
                let fsz = 0.5 * bh;
                vg.drawText(bx + 0.5 * bw, by + 0.5 * bh, '?', fsz, policy.data.foreground, WebMolKit.TextAlign.Centre | WebMolKit.TextAlign.Middle);
                return;
            }
            if (WebMolKit.Vec.notBlank(xc.text)) {
                let wad = this.measure.measureText('!', xc.fszText), th = wad[1] + wad[2];
                let totalH = th * xc.text.length;
                let ty = by + bh - th * (xc.text.length - 1);
                for (let line of xc.text) {
                    let wad = this.measure.measureText(line, xc.fszText);
                    vg.drawText(bx + 0.5 * bw, ty, line, xc.fszText, policy.data.foreground, WebMolKit.TextAlign.Centre | WebMolKit.TextAlign.Baseline);
                    ty += th;
                }
                bh -= totalH + 0.5 * xc.fszText;
            }
            if (xc.leftNumer) {
                let wad1 = this.measure.measureText(xc.leftNumer, xc.fszLeft);
                if (!xc.leftDenom) {
                    vg.drawText(bx, by + 0.5 * bh, xc.leftNumer, xc.fszLeft, policy.data.foreground, WebMolKit.TextAlign.Left | WebMolKit.TextAlign.Middle);
                    let useW = wad1[0] + WebMolKit.ArrangeExperiment.COMP_GAP_LEFT * (wad1[1] + wad1[2]);
                    bx += useW;
                    bw -= useW;
                }
                else {
                    let wad2 = this.measure.measureText(xc.leftDenom, xc.fszLeft);
                    let tw = Math.max(wad1[0], wad2[0]);
                    let x = bx + 0.5 * tw, y = by + 0.5 * bh;
                    vg.drawText(x, y, xc.leftNumer, xc.fszLeft, policy.data.foreground, WebMolKit.TextAlign.Centre | WebMolKit.TextAlign.Bottom);
                    vg.drawText(x, y + wad1[2], xc.leftDenom, xc.fszLeft, policy.data.foreground, WebMolKit.TextAlign.Centre | WebMolKit.TextAlign.Top);
                    vg.drawLine(bx, y, bx + tw, y, policy.data.foreground, this.scale * 0.03);
                    let useW = tw + WebMolKit.ArrangeExperiment.COMP_GAP_LEFT * (wad1[1] + wad1[2]);
                    bx += useW;
                    bw -= useW;
                }
            }
            if (xc.annot != 0) {
                let aw = WebMolKit.ArrangeExperiment.COMP_ANNOT_SIZE * this.scale;
                bw -= aw;
                this.drawAnnotation(xc.annot, bx + bw, by, aw, bh);
            }
            if (WebMolKit.MolUtil.notBlank(xc.mol)) {
                let arrmol = new WebMolKit.ArrangeMolecule(xc.mol, this.layout.measure, policy, new WebMolKit.RenderEffects());
                arrmol.arrange();
                arrmol.squeezeInto(bx, by, bw, bh, 0);
                if (this.preDrawMolecule)
                    this.preDrawMolecule(vg, idx, xc, arrmol);
                let drawmol = new WebMolKit.DrawMolecule(arrmol, vg);
                drawmol.draw();
                if (this.postDrawMolecule)
                    this.postDrawMolecule(vg, idx, xc, arrmol);
                this.molDrawn[idx] = arrmol;
            }
        }
        drawSymbolArrow(xc) {
            let bx = xc.box.x + xc.padding, by = xc.box.y + xc.padding;
            let bw = xc.box.w - 2 * xc.padding, bh = xc.box.h - 2 * xc.padding;
            if (bw > bh)
                this.drawArrow(bx, by + 0.5 * bh, bx + bw, by + 0.5 * bh, bh, this.policy.data.foreground, this.scale * 0.05);
            else
                this.drawArrow(bx + 0.5 * bw, by, bx + 0.5 * bw, by + bh, bw, this.policy.data.foreground, this.scale * 0.05);
        }
        drawSymbolPlus(xc) {
            let vg = this.vg, policy = this.policy;
            let x1 = xc.box.x + xc.padding, y1 = xc.box.y + xc.padding;
            let x3 = x1 + xc.box.w - 2 * xc.padding, y3 = y1 + xc.box.h - 2 * xc.padding;
            let x2 = 0.5 * (x1 + x3), y2 = 0.5 * (y1 + y3);
            let lw = 0.2 * 0.5 * (x3 - x1 + y3 - y1);
            vg.drawLine(x1, y2, x3, y2, policy.data.foreground, lw);
            vg.drawLine(x2, y1, x2, y3, policy.data.foreground, lw);
        }
        drawAnnotation(annot, bx, by, bw, bh) {
            let vg = this.vg, policy = this.policy;
            let sz = bw, x2 = bx + bw, y2 = by + bh, x1 = x2 - sz, y1 = by;
            if (annot == WebMolKit.ArrangeComponentAnnot.Primary)
                y2 = y1 + sz;
            else if (annot == WebMolKit.ArrangeComponentAnnot.Waste)
                y1 = y2 - sz;
            if (annot == WebMolKit.ArrangeComponentAnnot.Primary) {
                let cx = 0.5 * (x1 + x2), cy = 0.5 * (y1 + y2), ext = 0.25 * sz;
                let px = [cx, cx + 0.866 * ext, cx + 0.866 * ext, cx, cx - 0.866 * ext, cx - 0.866 * ext];
                let py = [cy - ext, cy - 0.5 * ext, cy + 0.5 * ext, cy + ext, cy + 0.5 * ext, cy - 0.5 * ext];
                let lw = 0.05 * this.scale;
                vg.drawLine(px[0], py[0], px[3], py[3], policy.data.foreground, lw);
                vg.drawLine(px[1], py[1], px[4], py[4], policy.data.foreground, lw);
                vg.drawLine(px[2], py[2], px[5], py[5], policy.data.foreground, lw);
                let inset = 0.1 * sz;
                vg.drawOval(x1 + 0.5 * sz, y1 + 0.5 * sz, 0.5 * sz - inset, 0.5 * sz - inset, policy.data.foreground, lw, WebMolKit.MetaVector.NOCOLOUR);
            }
            else if (annot == WebMolKit.ArrangeComponentAnnot.Waste) {
                let cx = x1 + 0.7 * sz, cy = 0.5 * (y1 + y2), quart = 0.25 * sz;
                let lw = 0.05 * this.scale;
                let px = [x1 + 0.1 * sz, cx - quart, cx, cx, cx];
                let py = [y1, y1, y1, cy - quart, cy];
                let ctrl = [false, false, true, false, false];
                vg.drawPath(px, py, ctrl, false, policy.data.foreground, lw, WebMolKit.MetaVector.NOCOLOUR, false);
                for (let n = 0; n < 4; n++) {
                    let y = cy + n * 0.45 * sz * (1.0 / 3), dw = (3.1 - n) * 0.1 * sz;
                    vg.drawLine(cx - dw, y, cx + dw, y, policy.data.foreground, lw);
                }
            }
            else if (annot == WebMolKit.ArrangeComponentAnnot.Implied) {
                let tw = 0.5 * sz, th = 0.75 * sz;
                let cx = x2 - 0.5 * tw, cy = y1 + 0.5 * th;
                let ty = y1 + 0.25 * th, dsz = sz * 0.1, hsz = 0.5 * dsz;
                let lw = 0.05 * this.scale, fg = policy.data.foreground;
                vg.drawLine(cx, y1, cx, y1 + th, fg, lw);
                vg.drawLine(x2 - tw, ty, x2, ty, fg, lw);
                vg.drawLine(x2 - tw, cy, x2, cy, fg, lw);
                vg.drawOval(x2 - tw + hsz, y1 + th - hsz, hsz, hsz, 0, 0, fg);
                vg.drawOval(x2 - hsz, y1 + th - hsz, hsz, hsz, 0, 0, fg);
            }
        }
        drawArrow(x1, y1, x2, y2, headsz, colour, linesz) {
            let dx = x2 - x1, dy = y2 - y1, invD = WebMolKit.invZ(WebMolKit.norm_xy(dx, dy));
            dx *= invD;
            dy *= invD;
            let ox = dy, oy = -dx;
            let hx = x2 - dx * headsz, hy = y2 - dy * headsz;
            let px = [
                x1 + ox * 0.5 * linesz,
                hx + ox * 0.5 * linesz,
                hx + ox * 0.5 * headsz,
                x2,
                hx - ox * 0.5 * headsz,
                hx - ox * 0.5 * linesz,
                x1 - ox * 0.5 * linesz
            ];
            let py = [
                y1 + oy * 0.5 * linesz,
                hy + oy * 0.5 * linesz,
                hy + oy * 0.5 * headsz,
                y2,
                hy - oy * 0.5 * headsz,
                hy - oy * 0.5 * linesz,
                y1 - oy * 0.5 * linesz
            ];
            this.vg.drawPoly(px, py, WebMolKit.MetaVector.NOCOLOUR, 0, colour, true);
        }
    }
    WebMolKit.DrawExperiment = DrawExperiment;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class DrawMolecule {
        constructor(layout, vg) {
            this.layout = layout;
            this.vg = vg;
            this.mol = layout.getMolecule();
            this.policy = layout.getPolicy();
            this.effects = layout.getEffects();
            this.scale = layout.getScale();
            this.invScale = 1.0 / this.scale;
        }
        getMolecule() { return this.mol; }
        getMetaVector() { return this.vg; }
        getLayout() { return this.layout; }
        getPolicy() { return this.policy; }
        getEffects() { return this.effects; }
        draw() {
            let DRAW_SPACE = false;
            if (DRAW_SPACE) {
                let bounds = this.layout.determineBoundary();
                this.vg.drawRect(bounds[0], bounds[1], bounds[2] - bounds[0], bounds[3] - bounds[1], 0xFF0000, 1, WebMolKit.MetaVector.NOCOLOUR);
                for (let n = 0; n < this.layout.numSpace(); n++) {
                    let spc = this.layout.getSpace(n);
                    this.vg.drawRect(spc.box.x, spc.box.y, spc.box.w, spc.box.h, WebMolKit.MetaVector.NOCOLOUR, 0, 0xE0E0E0);
                    if (spc.px != null && spc.py != null && spc.px.length > 2)
                        this.vg.drawPoly(spc.px, spc.py, 0x000000, 1, 0x808080FF, true);
                }
            }
            this.drawUnderEffects();
            let layout = this.layout, effects = this.effects, policy = this.policy, vg = this.vg;
            for (let n = 0; n < layout.numLines(); n++) {
                let b = layout.getLine(n);
                if (effects.hideBonds.has(b.bnum))
                    continue;
                if (b.type == WebMolKit.BLineType.Normal) {
                    vg.drawLine(b.line.x1, b.line.y1, b.line.x2, b.line.y2, b.col, b.size);
                }
                else if (b.type == WebMolKit.BLineType.Inclined)
                    this.drawBondInclined(b);
                else if (b.type == WebMolKit.BLineType.Declined)
                    this.drawBondDeclined(b);
                else if (b.type == WebMolKit.BLineType.Unknown)
                    this.drawBondUnknown(b);
                else if (b.type == WebMolKit.BLineType.Dotted || b.type == WebMolKit.BLineType.DotDir)
                    this.drawBondDotted(b);
                else if (b.type == WebMolKit.BLineType.IncDouble || b.type == WebMolKit.BLineType.IncTriple || b.type == WebMolKit.BLineType.IncQuadruple)
                    this.drawBondIncMulti(b);
            }
            let fg = policy.data.foreground;
            for (let r of layout.getRings())
                vg.drawOval(r.cx, r.cy, r.rw, r.rh, fg, r.size, WebMolKit.MetaVector.NOCOLOUR);
            for (let p of layout.getPaths())
                vg.drawPath(p.px, p.py, p.ctrl, false, fg, p.size, WebMolKit.MetaVector.NOCOLOUR, false);
            for (let n = 0; n < layout.numPoints(); n++) {
                let p = layout.getPoint(n);
                if (effects.hideBonds.has(p.anum))
                    continue;
                let txt = p.text;
                if (txt == null)
                    continue;
                let fsz = p.fsz;
                let cx = p.oval.cx, cy = p.oval.cy, rw = p.oval.rw;
                let col = p.col;
                while (txt.endsWith('.')) {
                    let dw = rw / txt.length;
                    let r = fsz * 0.15;
                    vg.drawOval(cx + rw - dw, cy, r, r, WebMolKit.MetaVector.NOCOLOUR, 0, col);
                    cx -= dw;
                    rw -= dw;
                    txt = txt.substring(0, txt.length - 1);
                }
                while (txt.startsWith('+')) {
                    let dw = rw / txt.length;
                    let x = cx - rw + dw, y = cy, r = fsz * 0.18, lsz = fsz * 0.1;
                    vg.drawLine(x - r, y, x + r, y, col, lsz);
                    vg.drawLine(x, y - r, x, y + r, col, lsz);
                    cx += dw;
                    rw -= dw;
                    txt = txt.substring(1, txt.length);
                }
                while (txt.startsWith('-')) {
                    let dw = rw / txt.length;
                    let x = cx - rw + dw, y = cy, r = fsz * 0.18, lsz = fsz * 0.1;
                    vg.drawLine(x - r, y, x + r, y, col, lsz);
                    cx += dw;
                    rw -= dw;
                    txt = txt.substring(1, txt.length);
                }
                if (txt.length > 0) {
                    vg.drawText(cx, cy, txt, fsz, col, WebMolKit.TextAlign.Centre | WebMolKit.TextAlign.Middle);
                }
            }
            this.drawOverEffects();
        }
        drawUnderEffects() {
            let mol = this.mol, policy = this.policy, effects = this.effects, layout = this.layout, scale = this.scale, vg = this.vg;
            for (let n = 0, num = Math.min(effects.atomFrameDotSz.length, mol.numAtoms); n < num; n++) {
                if (effects.hideAtoms.has(n + 1))
                    continue;
                let dw = effects.atomFrameDotSz[n] * scale, col = effects.atomFrameCol[n];
                let a = layout.getPoint(n);
                let rw = a.oval.rw + 0.1 * scale, rh = a.oval.rh + 0.1 * scale;
                let wdots = Math.ceil(2 * rw / (3 * dw));
                let hdots = Math.ceil(2 * rh / (3 * dw));
                let wspc = 2 * rw / wdots, hspc = 2 * rh / hdots;
                for (let i = 0; i <= wdots; i++) {
                    let x = a.oval.cx - rw + i * wspc;
                    vg.drawOval(x, a.oval.cy - rh, dw, dw, WebMolKit.MetaVector.NOCOLOUR, 0, col);
                    vg.drawOval(x, a.oval.cy + rh, dw, dw, WebMolKit.MetaVector.NOCOLOUR, 0, col);
                }
                for (let i = 1; i < hdots; i++) {
                    let y = a.oval.cy - rh + i * hspc;
                    vg.drawOval(a.oval.cx - rw, y, dw, dw, WebMolKit.MetaVector.NOCOLOUR, 0, col);
                    vg.drawOval(a.oval.cx + rw, y, dw, dw, WebMolKit.MetaVector.NOCOLOUR, 0, col);
                }
            }
            for (let key in effects.dottedRectOutline) {
                let atom = parseInt(key), col = effects.dottedRectOutline[key];
                let a = layout.getPoint(atom - 1);
                let rw = Math.max(a.oval.rw, 0.2 * scale), rh = Math.max(a.oval.rh, 0.2 * scale);
                let sz = 0.05 * scale;
                let xdots = Math.max(1, Math.round(rw / (2 * sz)));
                let ydots = Math.max(1, Math.round(rh / (2 * sz)));
                let invX = (2 * rw) / xdots, invY = (2 * rh) / ydots;
                for (let n = 0; n <= xdots; n++) {
                    let x = a.oval.cx - rw + n * invX;
                    vg.drawOval(x, a.oval.cy - rh, sz, sz, WebMolKit.MetaVector.NOCOLOUR, 0, col);
                    vg.drawOval(x, a.oval.cy + rh, sz, sz, WebMolKit.MetaVector.NOCOLOUR, 0, col);
                }
                for (let n = 1; n < ydots; n++) {
                    let y = a.oval.cy - rh + n * invY;
                    vg.drawOval(a.oval.cx - rw, y, sz, sz, WebMolKit.MetaVector.NOCOLOUR, 0, col);
                    vg.drawOval(a.oval.cx + rw, y, sz, sz, WebMolKit.MetaVector.NOCOLOUR, 0, col);
                }
            }
            for (let key in effects.dottedBondCross) {
                let bond = parseInt(key), col = effects.dottedBondCross[key];
                let x1 = 0, y1 = 0, x2 = 0, y2 = 0, bcount = 0;
                for (let n = 0; n < layout.numLines(); n++) {
                    let b = layout.getLine(n);
                    if (b.bnum == bond) {
                        x1 += b.line.x1;
                        y1 += b.line.y1;
                        x2 += b.line.x2;
                        y2 += b.line.y2;
                        bcount += 1;
                    }
                }
                if (bcount > 1) {
                    let inv = 1 / bcount;
                    [x1, y1, x2, y2] = [x1 * inv, y1 * inv, x2 * inv, y2 * inv];
                }
                let dx = x2 - x1, dy = y2 - y1;
                let inv = 0.2 * scale * WebMolKit.invZ(WebMolKit.norm_xy(dx, dy)), ox = dy * inv, oy = -dx * inv;
                let cx = 0.5 * (x1 + x2), cy = 0.5 * (y1 + y2), sz = 0.05 * scale;
                for (let p of [-2, -1, 1, 2]) {
                    let x = cx + p * ox, y = cy + p * oy;
                    vg.drawOval(x, y, sz, sz, WebMolKit.MetaVector.NOCOLOUR, 0, col);
                }
            }
        }
        drawOverEffects() {
            let mol = this.mol, policy = this.policy, effects = this.effects, layout = this.layout, scale = this.scale, vg = this.vg;
            for (let a of effects.overlapAtoms) {
                let p = layout.getPoint(a - 1);
                let rad = scale * 0.2;
                vg.drawLine(p.oval.cx - rad, p.oval.cy - rad, p.oval.cx + rad, p.oval.cy + rad, 0xFF0000, 1);
                vg.drawLine(p.oval.cx + rad, p.oval.cy - rad, p.oval.cx - rad, p.oval.cy + rad, 0xFF0000, 1);
            }
            for (let n = 0, num = Math.min(effects.atomCircleSz.length, mol.numAtoms); n < num; n++)
                if (effects.atomCircleSz[n] > 0) {
                    let dw = effects.atomCircleSz[n] * scale, col = effects.atomCircleCol[n];
                    let p = layout.getPoint(n);
                    vg.drawOval(p.oval.cx, p.oval.cy, dw, dw, WebMolKit.MetaVector.NOCOLOUR, 0, col);
                }
        }
        drawBondInclined(b) {
            let x1 = b.line.x1, y1 = b.line.y1, x2 = b.line.x2, y2 = b.line.y2;
            let dx = x2 - x1, dy = y2 - y1;
            let col = b.col;
            let size = b.size, head = b.head;
            let norm = head / Math.sqrt(dx * dx + dy * dy);
            let ox = norm * dy, oy = -norm * dx;
            let px = [x1, x2 - ox, x2 + ox], py = [y1, y2 - oy, y2 + oy];
            if (this.layout.getPoint(b.bto - 1).text == null && this.mol.atomAdjCount(b.bto) == 2) {
                let other = null;
                for (let n = 0; n < this.layout.numLines(); n++) {
                    let o = this.layout.getLine(n);
                    if (o.type == WebMolKit.BLineType.Normal && (o.bfr == b.bto || o.bto == b.bto)) {
                        if (other != null) {
                            other = null;
                            break;
                        }
                        other = o;
                    }
                }
                if (other != null) {
                    let th1 = Math.atan2(y1 - y2, x1 - x2);
                    let th2 = Math.atan2(other.line.y1 - other.line.y2, other.line.x1 - other.line.x2);
                    if (b.bto == other.bfr)
                        th2 += Math.PI;
                    let diff = Math.abs(WebMolKit.angleDiff(th1, th2));
                    if (diff > 105 * WebMolKit.DEGRAD && diff < 135 * WebMolKit.DEGRAD) {
                        let ixy1 = WebMolKit.GeomUtil.lineIntersect(px[0], py[0], px[1], py[1], other.line.x1, other.line.y1, other.line.x2, other.line.y2);
                        let ixy2 = WebMolKit.GeomUtil.lineIntersect(px[0], py[0], px[2], py[2], other.line.x1, other.line.y1, other.line.x2, other.line.y2);
                        px[1] = ixy1[0];
                        py[1] = ixy1[1];
                        px[2] = ixy2[0];
                        py[2] = ixy2[1];
                        let dx1 = px[1] - px[0], dy1 = py[1] - py[0], inv1 = 0.5 * other.size / WebMolKit.norm_xy(dx1, dy1);
                        px[1] += dx1 * inv1;
                        py[1] += dy1 * inv1;
                        let dx2 = px[2] - px[0], dy2 = py[2] - py[0], inv2 = 0.5 * other.size / WebMolKit.norm_xy(dx2, dy2);
                        px[2] += dx2 * inv1;
                        py[2] += dy2 * inv1;
                    }
                }
            }
            if (this.layout.getPoint(b.bto - 1).text == null && this.mol.atomAdjCount(b.bto) == 3) {
                let other1 = null, other2 = null;
                for (let n = 0; n < this.layout.numLines(); n++) {
                    let o = this.layout.getLine(n);
                    if (o.type == WebMolKit.BLineType.Normal && (o.bfr == b.bto || o.bto == b.bto)) {
                        if (other1 == null)
                            other1 = o;
                        else if (other2 == null)
                            other2 = o;
                        else {
                            other1 = other2 = null;
                            break;
                        }
                    }
                }
                if (other1 != null && other2 != null) {
                    let th1 = Math.atan2(y1 - y2, x1 - x2);
                    let th2 = Math.atan2(other1.line.y1 - other1.line.y2, other1.line.x1 - other1.line.x2);
                    let th3 = Math.atan2(other2.line.y1 - other2.line.y2, other2.line.x1 - other2.line.x2);
                    if (b.bto == other1.bfr)
                        th2 += Math.PI;
                    if (b.bto == other2.bfr)
                        th3 += Math.PI;
                    let dth1 = WebMolKit.angleDiff(th1, th2), diff1 = Math.abs(dth1);
                    let dth2 = WebMolKit.angleDiff(th1, th3), diff2 = Math.abs(dth2);
                    let diff3 = Math.abs(WebMolKit.angleDiff(th2, th3));
                    if (diff1 > 105 * WebMolKit.DEGRAD && diff1 < 135 * WebMolKit.DEGRAD ||
                        diff2 > 105 * WebMolKit.DEGRAD && diff2 < 135 * WebMolKit.DEGRAD ||
                        diff3 > 105 * WebMolKit.DEGRAD && diff3 < 135 * WebMolKit.DEGRAD) {
                        if (dth1 < 0)
                            [other1, other2] = [other2, other1];
                        let ixy1 = WebMolKit.GeomUtil.lineIntersect(px[0], py[0], px[1], py[1], other1.line.x1, other1.line.y1, other1.line.x2, other1.line.y2);
                        let ixy2 = WebMolKit.GeomUtil.lineIntersect(px[0], py[0], px[2], py[2], other2.line.x1, other2.line.y1, other2.line.x2, other2.line.y2);
                        px = [x1, ixy1[0], x2, ixy2[0]];
                        py = [y1, ixy1[1], y2, ixy2[1]];
                    }
                }
            }
            this.vg.drawPoly(px, py, WebMolKit.MetaVector.NOCOLOUR, 0, col, true);
        }
        drawBondDeclined(b) {
            let x1 = b.line.x1, y1 = b.line.y1, x2 = b.line.x2, y2 = b.line.y2;
            let dx = x2 - x1, dy = y2 - y1;
            let col = b.col;
            let size = b.size, head = b.head;
            let ext = Math.sqrt(dx * dx + dy * dy);
            let nsteps = Math.ceil(ext * 2.5 * this.invScale);
            let norm = head / ext;
            let ox = norm * dy, oy = -norm * dx, invSteps = 1.0 / (nsteps + 1);
            let holdout = this.mol.atomAdjCount(b.bto) == 1 && this.layout.getPoint(b.bto - 1).text == null ? 1 : 1 - (0.15 * this.scale) / ext;
            for (let i = 0; i <= nsteps + 1; i++) {
                let cx = x1 + i * dx * invSteps * holdout, cy = y1 + i * dy * invSteps * holdout;
                let ix = ox * i * invSteps, iy = oy * i * invSteps;
                this.vg.drawLine(cx - ix, cy - iy, cx + ix, cy + iy, col, size);
            }
        }
        drawBondUnknown(b) {
            let x1 = b.line.x1, y1 = b.line.y1, x2 = b.line.x2, y2 = b.line.y2;
            let dx = x2 - x1, dy = y2 - y1;
            let col = b.col;
            let size = b.size, head = b.head;
            let ext = Math.sqrt(dx * dx + dy * dy);
            let nsteps = Math.ceil(ext * 3.5 * this.invScale);
            let norm = head / ext;
            let ox = norm * dy, oy = -norm * dx;
            let sz = 1 + 3 * (nsteps + 1);
            let x = WebMolKit.Vec.numberArray(0, sz), y = WebMolKit.Vec.numberArray(0, sz), ctrl = WebMolKit.Vec.booleanArray(false, sz);
            x[0] = x1;
            y[0] = y1;
            ctrl[0] = false;
            for (let i = 0, j = 1; i <= nsteps; i++, j += 3) {
                let ax = x1 + i * dx / (nsteps + 1), ay = y1 + i * dy / (nsteps + 1);
                let cx = x1 + (i + 1) * dx / (nsteps + 1), cy = y1 + (i + 1) * dy / (nsteps + 1);
                let bx = (ax + cx) / 2, by = (ay + cy) / 2;
                let sign = i % 2 == 0 ? 1 : -1;
                x[j] = ax;
                x[j + 1] = bx + sign * ox;
                x[j + 2] = cx;
                y[j] = ay;
                y[j + 1] = by + sign * oy;
                y[j + 2] = cy;
                ctrl[j] = true;
                ctrl[j + 1] = true;
                ctrl[j + 2] = false;
            }
            this.vg.drawPath(x, y, ctrl, false, col, size, WebMolKit.MetaVector.NOCOLOUR, false);
        }
        drawBondDotted(b) {
            let x1 = b.line.x1, y1 = b.line.y1, x2 = b.line.x2, y2 = b.line.y2;
            let dx = x2 - x1, dy = y2 - y1;
            let col = b.col;
            let size = b.size;
            let radius = size, dist = WebMolKit.norm_xy(dx, dy);
            if (dist < 0.01)
                return;
            let nudge = 0.5 * size / dist;
            x1 += nudge * dx;
            y1 += nudge * dy;
            x2 -= nudge * dx;
            y2 -= nudge * dy;
            dx = x2 - x1;
            dy = y2 - y1;
            let nsteps = Math.ceil(0.2 * dist / radius);
            let invSteps = 1.0 / (nsteps + 1);
            for (let i = 0; i <= nsteps + 1; i++) {
                let r = radius;
                if (b.type == WebMolKit.BLineType.DotDir)
                    r *= 1 + (i * (1.0 / (nsteps + 2)) - 0.5);
                let cx = x1 + i * dx * invSteps, cy = y1 + i * dy * invSteps;
                this.vg.drawOval(cx, cy, r, r, WebMolKit.MetaVector.NOCOLOUR, 0, col);
            }
        }
        drawBondIncMulti(b) {
            let x1 = b.line.x1, y1 = b.line.y1, x2 = b.line.x2, y2 = b.line.y2;
            let dx = x2 - x1, dy = y2 - y1;
            let col = b.col;
            let size = b.size, head = b.head;
            let norm = head / Math.sqrt(dx * dx + dy * dy);
            let ox = norm * dy, oy = -norm * dx;
            this.vg.drawPoly([x1, x2 - ox, x2 + ox], [y1, y2 - oy, y2 + oy], col, this.scale * 0.05, WebMolKit.MetaVector.NOCOLOUR, true);
            if (b.type == WebMolKit.BLineType.IncDouble) {
                this.vg.drawLine(x1, y1, x2, y2, col, this.scale * 0.03);
            }
            else {
                this.vg.drawLine(x1, y1, x2 + 0.33 * ox, y2 + 0.33 * oy, col, this.scale * 0.03);
                this.vg.drawLine(x1, y1, x2 - 0.33 * ox, y2 - 0.33 * oy, col, this.scale * 0.03);
            }
        }
    }
    WebMolKit.DrawMolecule = DrawMolecule;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class FontData {
        constructor() {
            this.UNITS_PER_EM = 2048;
            this.INV_UNITS_PER_EM = 1.0 / this.UNITS_PER_EM;
            this.PANOSE_1 = '2 11 6 4 3 5 4 4 2 4';
            this.ASCENT = 1638;
            this.DESCENT = -410;
            this.MISSING_HORZ = 2048;
            this.MISSING_DATA = 'M256 0v1536h1536v-1536h-1536zM384 128h1280v1280h-1280v-1280z';
            this.ASCENT_FUDGE = 0.9;
            this.UNICODE = [
                ' ', '!', '"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<',
                '=', '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
                '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',
                'x', 'y', 'z', '{', '|', '}', '~', '\u00A0', '\u00A1', '\u00A2', '\u00A3', '\u00A4', '\u00A5', '\u00A6', '\u00A7', '\u00A8', '\u00A9', '\u00AA',
                '\u00AB', '\u00AC', '\u00AD', '\u00AE', '\u00AF', '\u00B0', '\u00B1', '\u00B2', '\u00B3', '\u00B4', '\u00B5', '\u00B6', '\u00B7', '\u00B8', '\u00B9',
                '\u00BA', '\u00BB', '\u00BC', '\u00BD', '\u00BE', '\u00BF', '\u00C0', '\u00C1', '\u00C2', '\u00C3', '\u00C4', '\u00C5', '\u00C6', '\u00C7', '\u00C8',
                '\u00C9', '\u00CA', '\u00CB', '\u00CC', '\u00CD', '\u00CE', '\u00CF', '\u00D0', '\u00D1', '\u00D2', '\u00D3', '\u00D4', '\u00D5', '\u00D6', '\u00D7',
                '\u00D8', '\u00D9', '\u00DA', '\u00DB', '\u00DC', '\u00DD', '\u00DE', '\u00DF', '\u00E0', '\u00E1', '\u00E2', '\u00E3', '\u00E4', '\u00E5', '\u00E6',
                '\u00E7', '\u00E8', '\u00E9', '\u00EA', '\u00EB', '\u00EC', '\u00ED', '\u00EE', '\u00EF', '\u00F0', '\u00F1', '\u00F2', '\u00F3', '\u00F4', '\u00F5',
                '\u00F6', '\u00F7', '\u00F8', '\u00F9', '\u00FA', '\u00FB', '\u00FC', '\u00FD', '\u00FE', '\u037E', '\u0384', '\u0385', '\u0386', '\u0387', '\u0388',
                '\u0389', '\u038A', '\u038C', '\u038E', '\u038F', '\u0390', '\u0391', '\u0392', '\u0393', '\u0394', '\u0395', '\u0396', '\u0397', '\u0398', '\u0399',
                '\u039A', '\u039B', '\u039C', '\u039D', '\u039E', '\u039F', '\u03A0', '\u03A1', '\u03A3', '\u03A4', '\u03A5', '\u03A6', '\u03A7', '\u03A8', '\u03A9',
                '\u03AA', '\u03AB', '\u03AC', '\u03AD', '\u03AE', '\u03AF', '\u03B0', '\u03B1', '\u03B2', '\u03B3', '\u03B4', '\u03B5', '\u03B6', '\u03B7', '\u03B8',
                '\u03B9', '\u03BA', '\u03BB', '\u03BC', '\u03BD', '\u03BE', '\u03BF', '\u03C0', '\u03C1', '\u03C2', '\u03C3', '\u03C4', '\u03C5', '\u03C6', '\u03C7',
                '\u03C8', '\u03C9', '\u03CA', '\u03CB', '\u03CC', '\u03CD', '\u03CE', '\u2202', '\u2206', '\u220F', '\u2211', '\u2212', '\u2215', '\u2219', '\u221A',
                '\u221E', '\u222B', '\u2248', '\u2260', '\u2264', '\u2265'
            ];
            this.HORIZ_ADV_X = [
                720, 806, 940, 1676, 1302, 2204, 1488, 550, 930, 930, 1302, 1676, 745, 930, 745, 930, 1302, 1302, 1302, 1302, 1302, 1302, 1302, 1302, 1302, 1302,
                930, 930, 1676, 1676, 1676, 1117, 2048, 1400, 1404, 1430, 1578, 1295, 1177, 1588, 1539, 862, 931, 1419, 1140, 1726, 1532, 1612, 1235, 1612, 1424,
                1400, 1262, 1499, 1400, 2025, 1403, 1260, 1403, 930, 930, 930, 1676, 1302, 1302, 1230, 1276, 1067, 1276, 1220, 720, 1276, 1296, 562, 705, 1212, 562,
                1992, 1296, 1243, 1276, 1276, 874, 1067, 807, 1296, 1212, 1676, 1212, 1212, 1076, 1300, 930, 1300, 1676, 720, 806, 1302, 1302, 1302, 1302, 930, 1302,
                1302, 2048, 1117, 1320, 1676, 930, 2048, 1302, 1110, 1676, 1110, 1110, 1302, 1314, 1302, 745, 1302, 1110, 1117, 1320, 2048, 2048, 2048, 1117, 1400,
                1400, 1400, 1400, 1400, 1400, 2016, 1430, 1295, 1295, 1295, 1295, 862, 862, 862, 862, 1588, 1532, 1612, 1612, 1612, 1612, 1612, 1676, 1612, 1499,
                1499, 1499, 1499, 1260, 1240, 1270, 1230, 1230, 1230, 1230, 1230, 1230, 1956, 1067, 1220, 1220, 1220, 1220, 562, 562, 562, 562, 1253, 1296, 1243,
                1243, 1243, 1243, 1243, 1676, 1243, 1296, 1296, 1296, 1296, 1212, 1276, 930, 1302, 1302, 1400, 930, 1538, 1782, 1105, 1804, 1543, 1859, 562, 1400,
                1404, 1160, 1440, 1295, 1403, 1539, 1612, 862, 1419, 1404, 1726, 1532, 1329, 1612, 1539, 1235, 1377, 1262, 1260, 1677, 1403, 1783, 1676, 862, 1260,
                1276, 1050, 1296, 562, 1293, 1276, 1270, 1212, 1245, 1050, 937, 1296, 1278, 562, 1212, 1212, 1310, 1212, 1030, 1243, 1305, 1280, 1040, 1291, 1016,
                1293, 1618, 1208, 1683, 1666, 562, 1293, 1243, 1293, 1666, 1302, 1489, 1676, 1489, 1676, 740, 745, 1676, 2048, 1302, 1676, 1676, 1676, 1676
            ];
            this.GLYPH_DATA = [
                '',
                'M515 1489l-26 -1079h-170l-28 1079h224zM505 0h-204v211h204v-211z',
                'M772 1556l-43 -579h-132l-43 579h218zM386 1556l-43 -579h-132l-43 579h218z',
                'M1481 932h-333l-92 -376h308v-135h-343l-104 -421h-129l104 421h-270l-104 -421h-129l104 421h-298v135h333l92 376h-308v135h343l105 422h129l-105 -422h270l105 422h129l-105 -422h298v-135zM1022 934h-274l-94 -380h274z',
                'M1160 380q0 -155 -121 -257.5t-317 -121.5v-362h-118v357q-132 1 -248 25.5t-201 63.5v198h16q19 -14 68 -40.5t95 -43.5q52 -19 121.5 -35.5t148.5 -19.5v433q-40 8 -74 15.5t-63 15.5q-163 41 -234 123.5t-71 203.5q0 148 116.5 250t325.5 119v272h118v-270 q101 -2 207 -24t178 -51v-196h-14q-75 46 -156.5 81.5t-214.5 44.5v-431q30 -5 65 -13.5t61 -13.5q149 -32 230.5 -110t81.5 -213zM604 747v413q-107 -8 -180 -58.5t-73 -140.5q0 -91 54 -137t199 -77zM971 354q0 94 -58.5 137.5t-190.5 68.5v-414q120 12 184.5 61t64.5 147 z',
                'M884 1076q0 -224 -94.5 -333t-272.5 -109q-182 0 -275 109t-93 332q0 224 95 333t273 109q181 0 274 -110t93 -331zM1575 1489l-780 -1489h-165l780 1489h165zM2055 413q0 -224 -95 -333t-273 -109q-181 0 -274 110t-93 331q0 224 94.5 333t272.5 109q182 0 275 -109 t93 -332zM706 1076q0 172 -44.5 240t-144.5 68q-102 0 -146 -68t-44 -241t44 -240.5t146 -67.5q100 0 144.5 67.5t44.5 241.5zM1877 413q0 172 -44.5 240t-144.5 68q-102 0 -146 -68t-44 -241t44 -240.5t146 -67.5q100 0 144.5 67.5t44.5 241.5z',
                'M792 1191q0 95 -56.5 149.5t-144.5 54.5q-92 0 -150 -61.5t-58 -150.5q0 -75 39.5 -133t170.5 -137q98 35 148.5 102.5t50.5 175.5zM986 315l-478 466q-31 -15 -62 -39.5t-62 -66.5q-28 -39 -46 -94t-18 -124q0 -146 85.5 -235.5t242.5 -89.5q93 0 184.5 45.5 t153.5 137.5zM1287 909v-96q0 -96 -25 -216t-85 -229l378 -368h-246l-229 224q-115 -142 -235 -198.5t-247 -56.5q-208 0 -345.5 121.5t-137.5 318.5q0 92 26 159t61 116q35 47 87 88.5t105 72.5q-110 72 -158.5 145t-48.5 184q0 67 26.5 127.5t79.5 110.5q50 48 130.5 78 t177.5 30q173 0 280 -87.5t107 -221.5q0 -44 -12 -99.5t-41 -99.5q-32 -49 -91 -94t-153 -77l371 -362q14 40 21 88t8 100q2 56 1.5 125t-0.5 117h195z',
                'M386 1556l-43 -579h-136l-43 579h222z',
                'M783 -412h-229q-177 203 -275 443t-98 541t98 541t275 443h229v-10q-81 -73 -154.5 -168.5t-136.5 -222.5q-60 -123 -97.5 -271t-37.5 -312q0 -171 36.5 -313t98.5 -270q60 -123 137 -222.5t154 -168.5v-10z',
                'M749 572q0 -301 -98 -541t-275 -443h-229v10q77 69 154.5 168.5t136.5 222.5q62 128 98.5 270t36.5 313q0 164 -37 312t-98 271q-63 127 -136.5 222.5t-154.5 168.5v10h229q177 -203 275 -443t98 -541z',
                'M1137 887l-64 -110l-362 213l6 -360h-129l5 360l-361 -214l-65 110l381 207l-381 207l65 110l362 -213l-6 359h129l-7 -359l363 212l64 -110l-380 -205z',
                'M1466 572h-545v-545h-166v545h-545v160h545v545h166v-545h545v-160z',
                'M575 285l-282 -655h-146l174 655h254z',
                'M777 561h-624v181h624v-181z',
                'M492 0h-239v285h239v-285z',
                'M860 1556l-717 -1860h-173l714 1860h176z',
                'M1167 745q0 -401 -125.5 -588.5t-389.5 -187.5q-268 0 -391.5 190t-123.5 584q0 397 125 586.5t390 189.5q268 0 391.5 -192.5t123.5 -581.5zM904 291q35 81 47.5 190.5t12.5 263.5q0 152 -12.5 264t-48.5 190q-35 77 -95.5 116t-155.5 39q-94 0 -155.5 -39t-97.5 -118 q-34 -74 -46.5 -193t-12.5 -261q0 -156 11 -261t47 -188q33 -78 93.5 -119t160.5 -41q94 0 156 39t96 118z',
                'M1084 0h-806v152h310v998h-310v136q63 0 135 10.5t109 30.5q46 25 72.5 63.5t30.5 103.5h155v-1342h304v-152z',
                'M1169 0h-1008v209q105 90 210.5 180t196.5 179q192 186 263 295.5t71 236.5q0 116 -76.5 181.5t-213.5 65.5q-91 0 -197 -32t-207 -98h-10v210q71 35 189.5 64t229.5 29q229 0 359 -110.5t130 -299.5q0 -85 -21.5 -158.5t-63.5 -139.5q-39 -62 -91.5 -122t-127.5 -133 q-107 -105 -221 -203.5t-213 -182.5h801v-171z',
                'M1038 717q48 -43 79 -108t31 -168q0 -102 -37 -187t-104 -148q-75 -70 -176.5 -103.5t-222.5 -33.5q-124 0 -244 29.5t-197 64.5v209h15q85 -56 200 -93t222 -37q63 0 134 21t115 62q46 44 68.5 97t22.5 134q0 80 -25.5 132.5t-70.5 82.5q-45 31 -109 42.5t-138 11.5h-90 v166h70q152 0 242.5 63.5t90.5 185.5q0 54 -23 94.5t-64 66.5q-43 26 -92 36t-111 10q-95 0 -202 -34t-202 -96h-10v209q71 35 189.5 64.5t229.5 29.5q109 0 192 -20t150 -64q72 -48 109 -116t37 -159q0 -124 -87.5 -216.5t-206.5 -116.5v-14q48 -8 110 -33.5t105 -63.5z ',
                'M1203 419h-221v-419h-192v419h-713v230l721 840h184v-910h221v-160zM790 579v672l-577 -672h577z',
                'M1157 473q0 -104 -38 -199t-104 -160q-72 -70 -171.5 -107.5t-230.5 -37.5q-122 0 -235 25.5t-191 61.5v211h14q82 -52 192 -88.5t216 -36.5q71 0 137.5 20t118.5 70q44 43 66.5 103t22.5 139q0 77 -26.5 130t-73.5 85q-52 38 -126.5 53.5t-166.5 15.5q-88 0 -169.5 -12 t-140.5 -24v767h896v-175h-703v-396q43 4 88 6t78 2q121 0 212 -20.5t167 -72.5q80 -55 124 -142t44 -218z',
                'M1191 483q0 -227 -149.5 -370.5t-366.5 -143.5q-110 0 -200 34t-159 101q-86 83 -132.5 220t-46.5 330q0 198 42.5 351t135.5 272q88 113 227 176.5t324 63.5q59 0 99 -5t81 -18v-191h-10q-28 15 -84.5 28.5t-115.5 13.5q-215 0 -343 -134.5t-149 -363.5 q84 51 165.5 77.5t188.5 26.5q95 0 167.5 -17.5t148.5 -70.5q88 -61 132.5 -154t44.5 -226zM988 475q0 93 -27.5 154t-90.5 106q-46 32 -102 42t-117 10q-85 0 -158 -20t-150 -62q-2 -22 -3 -42.5t-1 -51.5q0 -158 32.5 -249.5t89.5 -144.5q46 -44 99.5 -64.5t116.5 -20.5 q145 0 228 88.5t83 254.5z',
                'M1173 1266l-674 -1266h-214l717 1314h-848v175h1019v-223z',
                'M1180 415q0 -193 -150.5 -321t-378.5 -128q-242 0 -385.5 125t-143.5 320q0 124 72 224.5t203 159.5v6q-120 64 -177.5 140t-57.5 190q0 168 138 280t351 112q223 0 356 -107t133 -272q0 -101 -63 -198.5t-185 -152.5v-6q140 -60 214 -148t74 -224zM943 1142 q0 107 -82.5 170.5t-210.5 63.5q-126 0 -206.5 -60t-80.5 -162q0 -72 40.5 -124.5t122.5 -93.5q37 -18 106.5 -47t135.5 -48q99 66 137 137t38 164zM974 396q0 92 -40.5 147.5t-158.5 111.5q-47 22 -103 41t-149 53q-90 -49 -144.5 -133t-54.5 -190q0 -135 93 -223t236 -88 q146 0 233.5 75t87.5 206z',
                'M1167 834q0 -195 -44.5 -354t-134.5 -271q-91 -114 -228 -176t-322 -62q-52 0 -98 5.5t-82 17.5v191h10q29 -15 82 -28.5t118 -13.5q221 0 346.5 132.5t145.5 365.5q-93 -56 -175 -80t-179 -24q-92 0 -166.5 18t-149.5 70q-88 61 -132.5 155t-44.5 225q0 228 150 371 t366 143q108 0 200 -33.5t161 -100.5q85 -83 131 -213.5t46 -337.5zM965 877q0 155 -32 249t-88 146q-47 45 -101 64.5t-117 19.5q-144 0 -227.5 -90t-83.5 -253q0 -95 27 -155t91 -105q45 -31 99 -41.5t120 -10.5q78 0 158 21t150 61q1 21 2.5 41.5t1.5 52.5z',
                'M585 832h-239v285h239v-285zM585 0h-239v285h239v-285z',
                'M585 832h-239v285h239v-285zM658 285l-282 -655h-146l174 655h254z',
                'M1408 77l-1154 513v124l1154 513v-180l-910 -395l910 -395v-180z',
                'M1431 782h-1186v160h1186v-160zM1431 362h-1186v160h1186v-160z',
                'M1422 590l-1154 -513v180l910 395l-910 395v180l1154 -513v-124z',
                'M1005 1139q0 -98 -35 -174.5t-92 -135.5q-56 -57 -129 -107t-155 -97v-225h-179v305q65 37 140.5 81t123.5 89q58 52 90 107.5t32 141.5q0 113 -76.5 168.5t-197.5 55.5q-108 0 -204.5 -34t-152.5 -69h-10v204q70 27 177.5 48.5t203.5 21.5q215 0 339.5 -104.5 t124.5 -275.5zM610 0h-204v211h204v-211z',
                'M1870 663q0 -139 -40.5 -269t-115.5 -237h-440l-27 116q-74 -60 -142 -92t-156 -32q-168 0 -268.5 127t-100.5 355q0 227 123 362t294 135q73 0 129 -16.5t121 -49.5v48h159v-842h243q42 75 63.5 187.5t21.5 201.5q0 164 -45.5 298t-133.5 230t-218 147.5t-295 51.5 q-160 0 -292.5 -58t-227.5 -156q-96 -98 -150.5 -234.5t-54.5 -290.5q0 -165 52 -301.5t147 -233.5q99 -101 232 -152.5t290 -51.5q86 0 177.5 11t175.5 35v-142q-97 -21 -181 -28.5t-173 -7.5q-186 0 -345 63.5t-273 177.5q-115 115 -179 276t-64 356q0 185 67 344.5 t183 276.5t275 184t340 67q196 0 350 -62t260 -174t162.5 -269.5t56.5 -350.5zM1245 408v518q-63 29 -113 41.5t-107 12.5q-129 0 -202 -90t-73 -256q0 -163 58 -246.5t181 -83.5q67 0 134 31t122 73z',
                'M1374 0h-211l-146 415h-644l-146 -415h-201l542 1489h264zM956 585l-261 731l-262 -731h523z',
                'M1323 458q0 -111 -42 -196t-113 -140q-84 -66 -184.5 -94t-255.5 -28h-528v1489h441q163 0 244 -12t155 -50q82 -43 119 -110.5t37 -161.5q0 -106 -54 -180.5t-144 -119.5v-8q151 -31 238 -132.5t87 -256.5zM990 1129q0 54 -18 91t-58 60q-47 27 -114 33.5t-166 6.5h-236 v-430h256q93 0 148 9.5t102 39.5t66.5 77.5t19.5 112.5zM1117 450q0 90 -27 143t-98 90q-48 25 -116.5 32.5t-166.5 7.5h-311v-554h262q130 0 213 13.5t136 49.5q56 39 82 89t26 129z',
                'M1350 108q-55 -24 -99.5 -45t-116.5 -44q-61 -19 -132.5 -32.5t-157.5 -13.5q-162 0 -294.5 45.5t-230.5 142.5q-96 95 -150 241.5t-54 340.5q0 184 52 329t150 245q95 97 229.5 148t298.5 51q120 0 239.5 -29t265.5 -102v-235h-15q-123 103 -244 150t-259 47 q-113 0 -203.5 -36.5t-161.5 -113.5q-69 -75 -107.5 -189.5t-38.5 -264.5q0 -157 42.5 -270t109.5 -184q70 -74 163.5 -109.5t197.5 -35.5q143 0 268 49t234 147h14v-232z',
                'M1458 743q0 -203 -88.5 -368t-235.5 -256q-102 -63 -227.5 -91t-330.5 -28h-376v1489h372q218 0 346.5 -31.5t217.5 -86.5q152 -95 237 -253t85 -375zM1251 746q0 175 -61 295t-182 189q-88 50 -187 69.5t-237 19.5h-186v-1149h186q143 0 249.5 21t195.5 78 q111 71 166.5 187t55.5 290z',
                'M1181 0h-981v1489h981v-176h-783v-408h783v-176h-783v-553h783v-176z',
                'M1151 1313h-753v-420h647v-176h-647v-717h-198v1489h951v-176z',
                'M1442 110q-122 -56 -266.5 -97.5t-279.5 -41.5q-174 0 -319 48t-247 144q-103 97 -159 242.5t-56 340.5q0 357 208.5 563.5t572.5 206.5q127 0 259.5 -30.5t285.5 -103.5v-235h-18q-31 24 -90 63t-116 65q-69 31 -156.5 51.5t-198.5 20.5q-250 0 -395.5 -160.5 t-145.5 -434.5q0 -289 152 -449.5t414 -160.5q96 0 191.5 19t167.5 49v365h-399v174h595v-639z',
                'M1339 0h-198v729h-743v-729h-198v1489h198v-584h743v584h198v-1489z',
                'M725 0h-588v152h195v1185h-195v152h588v-152h-195v-1185h195v-152z',
                'M746 387q0 -196 -119.5 -302t-320.5 -106q-48 0 -128 8.5t-134 20.5v185h11q41 -14 101 -29t123 -15q92 0 146.5 21t80.5 60q27 40 34.5 98t7.5 134v869h-315v158h513v-1102z',
                'M1397 0h-257l-589 663l-148 -158v-505h-198v1489h198v-777l723 777h240l-665 -700z',
                'M1142 0h-942v1489h198v-1313h744v-176z',
                'M1526 0h-198v1283l-414 -873h-118l-411 873v-1283h-185v1489h270l397 -829l384 829h275v-1489z',
                'M1336 0h-245l-706 1332v-1332h-185v1489h307l644 -1216v1216h185v-1489z',
                'M1310 1318q91 -100 139.5 -245t48.5 -329t-49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5zM1292 744 q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5z',
                'M1174 1039q0 -99 -34.5 -183.5t-96.5 -146.5q-77 -77 -182 -115.5t-265 -38.5h-198v-555h-198v1489h404q134 0 227 -22.5t165 -70.5q85 -57 131.5 -142t46.5 -215zM968 1034q0 77 -27 134t-82 93q-48 31 -109.5 44.5t-155.5 13.5h-196v-595h167q120 0 195 21.5t122 68.5 q47 48 66.5 101t19.5 119z',
                'M1528 -365q-60 -15 -118.5 -21.5t-119.5 -6.5q-174 0 -279.5 95.5t-114.5 273.5q-24 -4 -46.5 -5.5t-43.5 -1.5q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5 q91 -100 139.5 -245t48.5 -329q0 -273 -111.5 -460t-299.5 -262q4 -114 54 -177t182 -63q41 0 97.5 12.5t80.5 22.5h27v-182zM1292 744q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5z',
                'M1432 0h-257l-498 592h-279v-592h-198v1489h417q135 0 225 -17.5t162 -62.5q81 -51 126.5 -128.5t45.5 -196.5q0 -161 -81 -269.5t-223 -163.5zM969 1070q0 64 -22.5 113.5t-74.5 83.5q-43 29 -102 40.5t-139 11.5h-233v-562h200q94 0 164 16.5t119 61.5q45 42 66.5 96.5 t21.5 138.5z',
                'M1282 425q0 -87 -40.5 -172t-113.5 -144q-80 -64 -186.5 -100t-256.5 -36q-161 0 -289.5 30t-261.5 89v248h14q113 -94 261 -145t278 -51q184 0 286.5 69t102.5 184q0 99 -48.5 146t-147.5 73q-75 20 -162.5 33t-185.5 33q-198 42 -293.5 143.5t-95.5 264.5 q0 187 158 306.5t401 119.5q157 0 288 -30t232 -74v-234h-14q-85 72 -223.5 119.5t-283.5 47.5q-159 0 -255.5 -66t-96.5 -170q0 -93 48 -146t169 -81q64 -14 182 -34t200 -41q166 -44 250 -133t84 -249z',
                'M1262 1313h-532v-1313h-198v1313h-532v176h1262v-176z',
                'M1321 598q0 -162 -35.5 -282.5t-116.5 -200.5q-77 -76 -180 -111t-240 -35q-140 0 -244 37t-175 109q-81 82 -116.5 198t-35.5 285v891h198v-901q0 -121 16.5 -191t55.5 -127q44 -65 119.5 -98t181.5 -33q107 0 182 32.5t120 98.5q39 57 55.5 130.5t16.5 182.5v906h198 v-891z',
                'M1374 1489l-542 -1489h-264l-542 1489h212l467 -1310l467 1310h202z',
                'M1933 1489l-387 -1489h-223l-313 1236l-306 -1236h-218l-394 1489h203l313 -1238l308 1238h201l311 -1250l311 1250h194z',
                'M1336 1489l-514 -736l513 -753h-229l-406 613l-416 -613h-216l519 744l-507 745h228l401 -605l410 605h217z',
                'M1254 1489l-524 -836v-653h-198v632l-526 857h219l407 -666l411 666h211z',
                'M1288 0h-1162v184l913 1129h-879v176h1106v-179l-922 -1134h944v-176z',
                'M759 -392h-520v1948h520v-143h-346v-1662h346v-143z',
                'M960 -304h-173l-717 1860h176z',
                'M691 -392h-520v143h346v1662h-346v143h520v-1948z',
                'M1490 684h-198l-455 627l-454 -629h-197l589 807h126z',
                'M1306 -300h-1310v120h1310v-120z',
                'M762 1302h-149l-273 374h243z',
                'M1053 0h-187v119q-25 -17 -67.5 -47.5t-82.5 -48.5q-47 -23 -108 -38.5t-143 -15.5q-151 0 -256 100t-105 255q0 127 54.5 205.5t155.5 123.5q102 45 245 61t307 24v29q0 64 -22.5 106t-64.5 66q-40 23 -96 31t-117 8q-74 0 -165 -19.5t-188 -56.5h-10v191q55 15 159 33 t205 18q118 0 205.5 -19.5t151.5 -66.5q63 -46 96 -119t33 -181v-758zM866 275v311q-86 -5 -202.5 -15t-184.5 -29q-81 -23 -131 -71.5t-50 -133.5q0 -96 58 -144.5t177 -48.5q99 0 181 38.5t152 92.5z',
                'M1168 567q0 -140 -39.5 -252t-106.5 -188q-71 -79 -156 -118.5t-187 -39.5q-95 0 -166 22.5t-140 60.5l-12 -52h-176v1556h188v-556q79 65 168 106.5t200 41.5q198 0 312.5 -152t114.5 -429zM974 562q0 200 -66 303.5t-213 103.5q-82 0 -166 -35.5t-156 -91.5v-640 q80 -36 137.5 -50t130.5 -14q156 0 244.5 102.5t88.5 321.5z',
                'M1011 70q-94 -45 -178.5 -70t-179.5 -25q-121 0 -222 35.5t-173 107.5q-73 72 -113 182t-40 257q0 274 150.5 430t397.5 156q96 0 188.5 -27t169.5 -66v-209h-10q-86 67 -177.5 103t-178.5 36q-160 0 -252.5 -107.5t-92.5 -315.5q0 -202 90.5 -310.5t254.5 -108.5 q57 0 116 15t106 39q41 21 77 44.5t57 40.5h10v-207z',
                'M1091 0h-188v117q-81 -70 -169 -109t-191 -39q-200 0 -317.5 154t-117.5 427q0 142 40.5 253t109.5 189q68 76 158.5 116t187.5 40q88 0 156 -18.5t143 -57.5v484h188v-1556zM903 275v641q-76 34 -136 47t-131 13q-158 0 -246 -110t-88 -312q0 -199 68 -302.5t218 -103.5 q80 0 162 35.5t153 91.5z',
                'M1120 539h-823q0 -103 31 -179.5t85 -125.5q52 -48 123.5 -72t157.5 -24q114 0 229.5 45.5t164.5 89.5h10v-205q-95 -40 -194 -67t-208 -27q-278 0 -434 150.5t-156 427.5q0 274 149.5 435t393.5 161q226 0 348.5 -132t122.5 -375v-102zM937 683q-1 148 -74.5 229 t-223.5 81q-151 0 -240.5 -89t-101.5 -221h640z',
                'M786 1374h-10q-31 9 -81 18.5t-88 9.5q-121 0 -175.5 -53.5t-54.5 -193.5v-38h339v-158h-333v-959h-188v959h-127v158h127v37q0 199 99 305.5t286 106.5q63 0 113.5 -6t92.5 -14v-172z',
                'M1091 127q0 -284 -129 -417t-397 -133q-89 0 -173.5 12.5t-166.5 35.5v192h10q46 -18 146 -44.5t200 -26.5q96 0 159 23t98 64q35 39 50 94t15 123v102q-85 -68 -162.5 -101.5t-197.5 -33.5q-200 0 -317.5 144.5t-117.5 407.5q0 144 40.5 248.5t110.5 180.5 q65 71 158 110.5t185 39.5q97 0 162.5 -19.5t138.5 -59.5l12 48h176v-990zM903 307v609q-75 34 -139.5 48.5t-128.5 14.5q-155 0 -244 -104t-89 -302q0 -188 66 -285t219 -97q82 0 164.5 31.5t151.5 84.5z',
                'M1119 0h-188v636q0 77 -9 144.5t-33 105.5q-25 42 -72 62.5t-122 20.5q-77 0 -161 -38t-161 -97v-834h-188v1556h188v-563q88 73 182 114t193 41q181 0 276 -109t95 -314v-725z',
                'M387 1304h-212v195h212v-195zM375 0h-188v1117h188v-1117z',
                'M533 1304h-212v195h212v-195zM521 -27q0 -196 -100 -296t-268 -100q-40 0 -105.5 8t-109.5 20v179h10q28 -11 75.5 -25t92.5 -14q72 0 116 20t66 60t28.5 96.5t6.5 137.5v900h-233v158h421v-1144z',
                'M1199 0h-248l-448 489l-122 -116v-373h-188v1556h188v-998l543 559h237l-519 -516z',
                'M375 0h-188v1556h188v-1556z',
                'M1815 0h-188v636q0 72 -6.5 139t-27.5 107q-23 43 -66 65t-124 22q-79 0 -158 -39.5t-158 -100.5q3 -23 5 -53.5t2 -60.5v-715h-188v636q0 74 -6.5 140.5t-27.5 106.5q-23 43 -66 64.5t-124 21.5q-77 0 -154.5 -38t-154.5 -97v-834h-188v1117h188v-124q88 73 175.5 114 t186.5 41q114 0 193.5 -48t118.5 -133q114 96 208 138.5t201 42.5q184 0 271.5 -111.5t87.5 -311.5v-725z',
                'M1119 0h-188v636q0 77 -9 144.5t-33 105.5q-25 42 -72 62.5t-122 20.5q-77 0 -161 -38t-161 -97v-834h-188v1117h188v-124q88 73 182 114t193 41q181 0 276 -109t95 -314v-725z',
                'M1137 558q0 -273 -140 -431t-375 -158q-237 0 -376.5 158t-139.5 431t139.5 431.5t376.5 158.5q235 0 375 -158.5t140 -431.5zM943 558q0 217 -85 322.5t-236 105.5q-153 0 -237.5 -105.5t-84.5 -322.5q0 -210 85 -318.5t237 -108.5q150 0 235.5 107.5t85.5 319.5z',
                'M1168 572q0 -136 -39 -248.5t-110 -190.5q-66 -74 -155.5 -114.5t-189.5 -40.5q-87 0 -157.5 19t-143.5 59v-468h-188v1529h188v-117q75 63 168.5 105.5t199.5 42.5q202 0 314.5 -152.5t112.5 -423.5zM974 567q0 202 -69 302t-212 100q-81 0 -163 -35t-157 -92v-633 q80 -36 137.5 -49t130.5 -13q157 0 245 106t88 314z',
                'M1091 -412h-188v538q-87 -75 -173 -111.5t-186 -36.5q-199 0 -317.5 153.5t-118.5 423.5q0 144 41.5 254.5t109.5 185.5q66 73 155 113t188 40q90 0 159.5 -20t141.5 -59l12 48h176v-1529zM903 284v632q-78 35 -138 49t-130 14q-163 0 -248 -110.5t-85 -304.5 q0 -196 68.5 -301.5t215.5 -105.5q82 0 164 35.5t153 91.5z',
                'M882 912h-10q-42 10 -81.5 14.5t-93.5 4.5q-87 0 -168 -38.5t-156 -99.5v-793h-188v1117h188v-165q112 90 197.5 127.5t174.5 37.5q49 0 71 -2.5t66 -9.5v-193z',
                'M983 322q0 -153 -126.5 -251t-345.5 -98q-124 0 -227.5 29.5t-173.5 64.5v211h10q89 -67 198 -106.5t209 -39.5q124 0 194 40t70 126q0 66 -38 100t-146 58q-40 9 -104.5 21t-117.5 26q-147 39 -208.5 114.5t-61.5 185.5q0 69 28.5 130t86.5 109q56 47 142.5 74.5 t193.5 27.5q100 0 202.5 -24.5t170.5 -59.5v-201h-10q-72 53 -175 89.5t-202 36.5q-103 0 -174 -39.5t-71 -117.5q0 -69 43 -104q42 -35 136 -57q52 -12 116.5 -24t107.5 -22q131 -30 202 -103q71 -74 71 -196z',
                'M765 10q-53 -14 -115.5 -23t-111.5 -9q-171 0 -260 92t-89 295v594h-127v158h127v321h188v-321h388v-158h-388v-509q0 -88 4 -137.5t28 -92.5q22 -40 60.5 -58.5t117.5 -18.5q46 0 96 13.5t72 22.5h10v-169z',
                'M1111 0h-188v124q-95 -75 -182 -115t-192 -40q-176 0 -274 107.5t-98 315.5v725h188v-636q0 -85 8 -145.5t34 -103.5q27 -44 70 -64t125 -20q73 0 159.5 38t161.5 97v834h188v-1117z',
                'M1151 1117l-452 -1117h-189l-449 1117h204l346 -889l343 889h197z',
                'M1590 1117l-291 -1117h-174l-287 861l-285 -861h-173l-294 1117h196l205 -865l279 865h155l286 -865l194 865h189z',
                'M1152 0h-237l-317 429l-319 -429h-219l436 557l-432 560h237l315 -422l316 422h220l-439 -550z',
                'M1151 1117l-652 -1529h-201l208 466l-445 1063h204l343 -828l346 828h197z',
                'M995 0h-902v139l651 821h-637v157h871v-134l-654 -824h671v-159z',
                'M1113 -392h-150q-179 0 -290.5 99.5t-111.5 287.5v149q0 169 -83 264.5t-254 95.5h-51v156h51q171 0 254 95.5t83 264.5v149q0 188 111.5 287.5t290.5 99.5h150v-138h-114q-136 0 -197.5 -63t-61.5 -203v-175q0 -139 -77 -233.5t-214 -149.5v-24q137 -55 214 -149.5 t77 -233.5v-175q0 -140 61.5 -203t197.5 -63h114v-138z',
                'M552 -392h-174v1948h174v-1948z',
                'M1127 504h-51q-171 0 -254 -95.5t-83 -264.5v-149q0 -188 -111.5 -287.5t-290.5 -99.5h-150v138h114q136 0 197.5 63t61.5 203v175q0 139 77 233.5t214 149.5v24q-137 55 -214 149.5t-77 233.5v175q0 140 -61.5 203t-197.5 63h-114v138h150q179 0 290.5 -99.5 t111.5 -287.5v-149q0 -169 83 -264.5t254 -95.5h51v-156z',
                'M1489 927q-2 -99 -22.5 -195t-65.5 -171q-46 -77 -111 -121t-165 -44q-94 0 -167 39.5t-157 141.5q-102 125 -148 157t-96 32q-94 0 -144 -87.5t-59 -283.5h-167q2 100 22.5 194.5t64.5 171.5q43 74 112 119.5t165 45.5q93 0 166.5 -38.5t158.5 -142.5q80 -98 131 -143.5 t112 -45.5q103 0 151.5 101t51.5 270h167z',
                '',
                'M505 1278h-204v211h204v-211zM515 0h-224l26 1079h170z',
                'M1120 74q-71 -30 -161 -53.5t-194 -26.5v-355h-118v359q-227 21 -357.5 165t-130.5 394q0 242 133.5 391.5t354.5 171.5v355h118v-351q104 -3 197 -25t158 -53v-203h-11q-55 44 -142 85t-202 50v-839q120 10 206.5 52.5t137.5 83.5h11v-201zM647 142v834 q-135 -20 -216 -125t-81 -294q0 -181 76 -286t221 -129z',
                'M1163 0h-1026v207q118 32 169.5 126.5t51.5 279.5h-176v138h176v310q0 200 126.5 328.5t331.5 128.5q105 0 181 -17t140 -34v-206h-10q-62 42 -138 66t-162 24q-140 0 -209.5 -82.5t-69.5 -226.5v-291h415v-138h-415v-61q0 -126 -62 -219.5t-160 -150.5v-11h837v-171z ',
                'M1168 257l-110 -110l-236 234q-44 -26 -81 -37t-89 -11q-46 0 -89.5 12.5t-79.5 35.5l-236 -236l-109 113l233 234q-23 37 -35 81.5t-12 87.5q0 52 11 88.5t37 79.5l-234 237l111 110l235 -235q36 23 79.5 35.5t88.5 12.5q44 0 88 -12t81 -35l234 234l113 -109l-235 -237 q24 -38 36 -79.5t12 -89.5q0 -45 -12.5 -89t-35.5 -80zM832 661q0 73 -52.5 129t-127.5 56q-73 0 -126.5 -55t-53.5 -130q0 -74 52.5 -129.5t127.5 -55.5q73 0 126.5 54.5t53.5 130.5z',
                'M1191 1489l-448 -831v-94h372v-138h-370v-426h-188v426h-370v138h372v73l-451 852h212l332 -659l336 659h203z',
                'M552 758h-174v798h174v-798zM552 -392h-174v798h174v-798z',
                'M1128 601q0 -106 -59 -187t-158 -136v-7q97 -46 141 -118.5t44 -162.5q0 -77 -33 -146t-98 -119q-72 -56 -169 -83t-221 -27q-87 0 -170.5 13.5t-175.5 44.5v194h10q79 -37 169 -62t198 -25q134 0 215 48.5t81 135.5q0 56 -19.5 88.5t-64.5 57.5q-41 23 -113 41.5 t-154 38.5q-214 52 -296 133q-83 81 -83 210q0 98 57 182.5t159 141.5v7q-101 48 -143 121t-42 162q0 81 32 146.5t99 117.5q64 50 163.5 79t227.5 29q87 0 171 -14t175 -43v-194h-10q-58 27 -152.5 57t-215.5 30q-127 0 -211.5 -46t-84.5 -133q0 -57 21.5 -92.5t64.5 -58.5 t109 -41.5t157 -39.5q200 -46 290 -125q89 -79 89 -218zM881 399q28 33 43 65.5t15 90.5q0 51 -16.5 86t-45.5 58q-28 24 -67 39.5t-83 27.5q-39 11 -85.5 21.5t-116.5 30.5q-18 -9 -49 -31.5t-53 -46.5q-24 -26 -43 -69t-19 -92q0 -50 15.5 -85t44.5 -59q27 -23 67.5 -39 t84.5 -27q38 -10 86 -22t115 -31q20 11 53 34.5t54 48.5z',
                'M958 1304h-199v195h199v-195zM545 1304h-199v195h199v-195z',
                'M1889 655q0 -358 -253.5 -611.5t-611.5 -253.5t-611.5 253.5t-253.5 611.5t253.5 611.5t611.5 253.5t611.5 -253.5t253.5 -611.5zM1773 655q0 310 -219.5 532t-529.5 222t-529.5 -222t-219.5 -532t219.5 -532t529.5 -222t529.5 222t219.5 532zM1375 258 q-86 -39 -165.5 -58.5t-157.5 -19.5q-227 0 -359 123t-132 357q0 225 134.5 354t356.5 129q89 0 175 -24t148 -52v-181h-16q-54 40 -138.5 75t-173.5 35q-142 0 -221.5 -85.5t-79.5 -250.5q0 -159 76.5 -246t224.5 -87q83 0 161.5 29t150.5 81h16v-179z',
                'M944 554h-170v94q-28 -20 -52.5 -38.5t-68.5 -37.5q-45 -20 -85.5 -30.5t-113.5 -10.5q-128 0 -215.5 85t-87.5 217q0 106 46.5 173.5t123.5 103.5q78 36 197.5 51.5t255.5 21.5v18q0 53 -18 85t-51 51q-34 18 -77.5 23t-91.5 5q-84 0 -168 -24t-123 -38h-14v172 q45 13 137 29t169 16q217 0 312 -84.5t95 -243.5v-638zM774 796v245q-69 -4 -160.5 -12t-145.5 -23q-64 -18 -103 -56.5t-39 -106.5q0 -76 45.5 -114t139.5 -38q82 0 147.5 33.5t115.5 71.5z',
                'M1146 191l-528 419v85l528 418v-188l-357 -273l357 -273v-188zM716 162l-550 446v89l550 445v-196l-371 -294l371 -294v-196z',
                'M1456 57h-171v545h-1075v160h1246v-705z',
                'M777 561h-624v181h624v-181z',
                'M1889 655q0 -358 -253.5 -611.5t-611.5 -253.5t-611.5 253.5t-253.5 611.5t253.5 611.5t611.5 253.5t611.5 -253.5t253.5 -611.5zM1773 655q0 310 -219.5 532t-529.5 222t-529.5 -222t-219.5 -532t219.5 -532t529.5 -222t529.5 222t219.5 532zM1581 215h-223l-331 355 h-162v-355h-165v915h312q94 0 155 -8t120 -39q63 -34 92.5 -82.5t29.5 -121.5q0 -97 -56.5 -161.5t-155.5 -102.5zM1229 868q0 36 -14 64t-47 46q-31 17 -66 22t-88 5h-149v-309h127q62 0 107 9.5t74 32.5q31 25 43.5 55t12.5 75z',
                'M1306 1668h-1305l-5 120h1310v-120z',
                'M956 1116q0 -168 -116 -284t-285 -116t-285 115.5t-116 284.5q0 168 116 284t285 116q170 0 285.5 -116t115.5 -284zM791 1116q0 102 -67 171.5t-169 69.5t-169 -69.5t-67 -171.5q0 -104 68.5 -172.5t167.5 -68.5q102 0 169 70t67 171z',
                'M1461 179h-1246v158h540v422h-540v158h540v545h166v-545h540v-158h-540v-422h540v-158z',
                'M967 566h-760v156q100 62 183.5 117t134.5 96q131 103 168 154.5t37 135.5q0 69 -53.5 107t-143.5 38q-89 0 -175 -30.5t-134 -61.5h-13v180q71 26 158.5 43.5t174.5 17.5q180 0 273.5 -78.5t93.5 -203.5q0 -99 -48.5 -174.5t-163.5 -165.5q-55 -43 -132.5 -94 t-143.5 -92h544v-145z',
                'M956 817q0 -75 -33 -131.5t-89 -90.5q-57 -35 -131 -51.5t-163 -16.5q-94 0 -176.5 15t-156.5 43v179h14q41 -36 138.5 -65.5t190.5 -29.5q100 0 166.5 35.5t66.5 110.5q0 85 -59 115t-171 30h-143v141h128q112 0 165.5 38.5t53.5 106.5q0 61 -49.5 96.5t-153.5 35.5 q-77 0 -174.5 -31t-141.5 -67h-14v178q74 27 160.5 44.5t176.5 17.5q175 0 271.5 -68t96.5 -174q0 -89 -55 -146t-144 -83v-8q95 -17 160.5 -72.5t65.5 -151.5z',
                'M963 1676l-273 -374h-149l179 374h243z',
                'M1124 0h-178l-10 118q-59 -65 -123.5 -102t-155.5 -37q-86 0 -149.5 35t-129.5 99v-525h-188v1529h188v-838q32 -39 109.5 -80t168.5 -41q93 0 159.5 33.5t120.5 93.5v832h188v-1117z',
                'M1106 -363h-148v1722h-214v-1722h-149v956q-206 5 -332 129t-126 328q0 207 130 323t373 116h466v-1852z',
                'M492 511h-239v283h239v-283z',
                'M880 -89q0 -162 -91.5 -248t-237.5 -86q-37 0 -95 7t-103 19v160h9q26 -10 70 -23t94 -13q104 0 153 39t49 127q0 29 -3 65.5t-6 61.5h153q2 -19 5 -45t3 -64z',
                'M914 566h-615v122h234v568h-242v112q45 0 99 6.5t84 18.5q37 16 59 38t25 62h135v-805h221v-122z',
                'M996 1025q0 -235 -122 -364.5t-315 -129.5q-201 0 -319.5 132.5t-118.5 361.5t118.5 362t319.5 133q193 0 315 -130t122 -365zM814 1025q0 172 -67.5 258t-187.5 86q-122 0 -189 -87t-67 -257t67 -256.5t189 -86.5q120 0 187.5 85.5t67.5 257.5z',
                'M1154 608l-550 -446v196l371 294l-371 294v196l550 -445v-89zM702 610l-528 -419v188l357 273l-357 273v188l528 -418v-85z',
                'M545 565h-165v681h-209v117q102 0 165 22t72 108h137v-928zM1410 1489l-780 -1489h-165l780 1489h165zM1857 220h-163v-220h-150v220h-465v185l466 539h149v-591h163v-133zM1548 353v400l-353 -400h353z',
                'M545 565h-165v681h-209v117q102 0 165 22t72 108h137v-928zM1410 1489l-780 -1489h-165l780 1489h165zM1955 0h-688v148q91 69 158 121t106 89q109 103 141 157.5t32 136.5q0 70 -44 107t-120 37q-70 0 -141.5 -30t-112.5 -62h-15v179q65 27 140.5 44t152.5 17 q157 0 241.5 -79t84.5 -201q0 -93 -41 -167t-147 -168q-49 -43 -119.5 -96t-125.5 -94h498v-139z',
                'M793 826q0 -71 -30 -127t-78 -90q-53 -37 -114.5 -53t-140.5 -16q-82 0 -153.5 15t-136.5 43v175h17q37 -35 114 -64.5t156 -29.5q84 0 139 36.5t55 108.5q0 83 -50 112.5t-141 29.5h-140v139h125q87 0 134.5 38t47.5 104q0 60 -41 95.5t-128 35.5q-66 0 -142.5 -31 t-113.5 -66h-17v175q64 27 139 44t154 17q152 0 237 -70t85 -168q0 -87 -48.5 -143.5t-125.5 -82.5v-8q80 -16 138.5 -70.5t58.5 -148.5zM1500 1489l-780 -1489h-165l780 1489h165zM1913 220h-163v-220h-150v220h-465v185l466 539h149v-591h163v-133zM1604 353v400 l-353 -400h353z',
                'M712 1278h-204v211h204v-211zM958 40q-83 -30 -176 -50t-205 -20q-215 0 -339.5 104.5t-124.5 275.5q0 98 34.5 173t93.5 137q58 62 136.5 112.5t146.5 91.5v225h179v-305q-60 -33 -139 -81.5t-125 -88.5q-54 -47 -88 -109t-34 -140q0 -113 76.5 -168.5t197.5 -55.5 q103 0 201.5 33t155.5 70h10v-204z',
                'M1374 0h-211l-146 415h-644l-146 -415h-201l542 1489h264zM956 585l-261 731l-262 -731h523zM862 1675h-149l-273 374h243z',
                'M1374 0h-211l-146 415h-644l-146 -415h-201l542 1489h264zM956 585l-261 731l-262 -731h523zM955 2049l-273 -374h-149l179 374h243z',
                'M1374 0h-211l-146 415h-644l-146 -415h-201l542 1489h264zM956 585l-261 731l-262 -731h523zM1033 1670h-159l-185 256l-184 -256h-155l228 379h227z',
                'M1374 0h-211l-146 415h-644l-146 -415h-201l542 1489h264zM956 585l-261 731l-262 -731h523zM1119 1992q-11 -152 -77 -229t-177 -77q-54 0 -100 19.5t-87 56.5q-47 43 -79.5 64.5t-71.5 21.5q-52 0 -78 -45t-30 -121h-131q8 151 79 228t174 77q50 0 96.5 -19.5 t88.5 -55.5q47 -41 83.5 -61.5t69.5 -20.5q51 0 79.5 46t31.5 116h129z',
                'M1374 0h-211l-146 415h-644l-146 -415h-201l542 1489h264zM956 585l-261 731l-262 -731h523zM1005 1677h-199v195h199v-195zM592 1677h-199v195h199v-195z',
                'M1374 0h-211l-148 415h-640l-148 -415h-201l519 1407q-89 44 -142.5 123.5t-53.5 181.5q0 143 102 240t248 97q147 0 248.5 -97t101.5 -240q0 -100 -52.5 -181.5t-141.5 -123.5zM899 1710q0 86 -57 143.5t-143 57.5t-143 -58t-57 -143q0 -86 57.5 -143.5t142.5 -57.5 q86 0 143 57.5t57 143.5zM953 585l-258 715l-259 -715h517z',
                'M1901 0h-944v556h-524l-212 -556h-207l594 1489h1293v-176h-749v-408h749v-176h-749v-553h749v-176zM957 723v601h-219l-239 -601h458z',
                'M1350 108q-55 -24 -99.5 -45t-116.5 -44q-11 -3 -24 -7.5t-31 -7.5q2 -19 3.5 -44.5t1.5 -48.5q0 -162 -93.5 -248t-240.5 -86q-38 0 -97.5 7t-104.5 19v162h9q26 -10 71.5 -24t95.5 -14q106 0 155 40t49 126q0 19 -1 41.5t-3 42.5q-19 -2 -40.5 -3t-39.5 -1 q-162 0 -294.5 45.5t-230.5 142.5q-96 95 -150 241.5t-54 340.5q0 184 52 329t150 245q95 97 229.5 148t298.5 51q120 0 239.5 -29t265.5 -102v-235h-15q-123 103 -244 150t-259 47q-113 0 -203.5 -36.5t-161.5 -113.5q-69 -75 -107.5 -189.5t-38.5 -264.5q0 -157 42.5 -270 t109.5 -184q70 -74 163.5 -109.5t197.5 -35.5q143 0 268 49t234 147h14v-232z',
                'M1181 0h-981v1489h981v-176h-783v-408h783v-176h-783v-553h783v-176zM822 1675h-149l-273 374h243z',
                'M1181 0h-981v1489h981v-176h-783v-408h783v-176h-783v-553h783v-176zM993 2049l-273 -374h-149l179 374h243z',
                'M1181 0h-981v1489h981v-176h-783v-408h783v-176h-783v-553h783v-176zM1031 1670h-159l-185 256l-184 -256h-155l228 379h227z',
                'M1181 0h-981v1489h981v-176h-783v-408h783v-176h-783v-553h783v-176zM1038 1677h-199v195h199v-195zM625 1677h-199v195h199v-195z',
                'M725 0h-588v152h195v1185h-195v152h588v-152h-195v-1185h195v-152zM568 1675h-149l-273 374h243z',
                'M725 0h-588v152h195v1185h-195v152h588v-152h-195v-1185h195v-152zM725 2049l-273 -374h-149l179 374h243z',
                'M725 0h-588v152h195v1185h-195v152h588v-152h-195v-1185h195v-152zM776 1670h-159l-185 256l-184 -256h-155l228 379h227z',
                'M725 0h-588v152h195v1185h-195v152h588v-152h-195v-1185h195v-152zM738 1677h-199v195h199v-195zM325 1677h-199v195h199v-195z',
                'M1468 743q0 -203 -88.5 -368t-235.5 -256q-102 -63 -227.5 -91t-330.5 -28h-376v740h-196v143h196v606h372q218 0 347 -31.5t217 -86.5q152 -95 237 -253t85 -375zM1261 746q0 175 -61 295t-182 189q-88 50 -187 69.5t-237 19.5h-188v-436h361v-143h-361v-570h188 q143 0 249.5 21t195.5 78q111 71 166.5 187t55.5 290z',
                'M1336 0h-245l-706 1332v-1332h-185v1489h307l644 -1216v1216h185v-1489zM1208 1992q-11 -152 -77 -229t-177 -77q-54 0 -100 19.5t-87 56.5q-47 43 -79.5 64.5t-71.5 21.5q-52 0 -78 -45t-30 -121h-131q8 151 79 228t174 77q50 0 96.5 -19.5t88.5 -55.5 q47 -41 83.5 -61.5t69.5 -20.5q51 0 79.5 46t31.5 116h129z',
                'M1310 1318q91 -100 139.5 -245t48.5 -329t-49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5zM1292 744 q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5zM932 1675h-149l-273 374h243z',
                'M1310 1318q91 -100 139.5 -245t48.5 -329t-49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5zM1292 744 q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5zM1083 2049l-273 -374h-149l179 374h243z',
                'M1310 1318q91 -100 139.5 -245t48.5 -329t-49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5zM1292 744 q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5zM1136 1670h-159l-185 256l-184 -256h-155l228 379h227z',
                'M1310 1318q91 -100 139.5 -245t48.5 -329t-49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5zM1292 744 q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5zM1207 1992q-11 -152 -77 -229t-177 -77q-54 0 -100 19.5t-87 56.5q-47 43 -79.5 64.5t-71.5 21.5q-52 0 -78 -45t-30 -121h-131q8 151 79 228 t174 77q50 0 96.5 -19.5t88.5 -55.5q47 -41 83.5 -61.5t69.5 -20.5q51 0 79.5 46t31.5 116h129z',
                'M1307 1318q91 -100 139.5 -245t48.5 -329t-49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5zM1289 744 q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5zM1108 1677h-199v195h199v-195zM695 1677h-199v195h199v-195z',
                'M1385 216l-111 -111l-436 440l-436 -440l-111 111l440 436l-440 436l111 111l436 -440l436 440l111 -111l-440 -436z',
                'M1498 744q0 -184 -49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-115 0 -215.5 29t-179.5 84l-159 -228h-132l205 294q-101 100 -155.5 250t-54.5 346q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q118 0 215 -27.5t179 -82.5l142 201h132 l-188 -268q101 -100 156.5 -248.5t55.5 -350.5zM1097 1260q-57 46 -129 68.5t-161 22.5q-110 0 -200 -38.5t-156 -116.5q-64 -76 -98.5 -190.5t-34.5 -261.5q0 -140 29.5 -252t87.5 -188zM1295 744q0 139 -30 253t-88 189l-664 -957q60 -45 132.5 -68t161.5 -23 q110 0 201.5 40t153.5 116q67 82 100 194.5t33 255.5z',
                'M1321 598q0 -162 -35.5 -282.5t-116.5 -200.5q-77 -76 -180 -111t-240 -35q-140 0 -244 37t-175 109q-81 82 -116.5 198t-35.5 285v891h198v-901q0 -121 16.5 -191t55.5 -127q44 -65 119.5 -98t181.5 -33q107 0 182 32.5t120 98.5q39 57 55.5 130.5t16.5 182.5v906h198 v-891zM932 1675h-149l-273 374h243z',
                'M1321 598q0 -162 -35.5 -282.5t-116.5 -200.5q-77 -76 -180 -111t-240 -35q-140 0 -244 37t-175 109q-81 82 -116.5 198t-35.5 285v891h198v-901q0 -121 16.5 -191t55.5 -127q44 -65 119.5 -98t181.5 -33q107 0 182 32.5t120 98.5q39 57 55.5 130.5t16.5 182.5v906h198 v-891zM1073 2049l-273 -374h-149l179 374h243z',
                'M1321 598q0 -162 -35.5 -282.5t-116.5 -200.5q-77 -76 -180 -111t-240 -35q-140 0 -244 37t-175 109q-81 82 -116.5 198t-35.5 285v891h198v-901q0 -121 16.5 -191t55.5 -127q44 -65 119.5 -98t181.5 -33q107 0 182 32.5t120 98.5q39 57 55.5 130.5t16.5 182.5v906h198 v-891zM1084 1670h-159l-185 256l-184 -256h-155l228 379h227z',
                'M1321 598q0 -162 -35.5 -282.5t-116.5 -200.5q-77 -76 -180 -111t-240 -35q-140 0 -244 37t-175 109q-81 82 -116.5 198t-35.5 285v891h198v-901q0 -121 16.5 -191t55.5 -127q44 -65 119.5 -98t181.5 -33q107 0 182 32.5t120 98.5q39 57 55.5 130.5t16.5 182.5v906h198 v-891zM1056 1677h-199v195h199v-195zM643 1677h-199v195h199v-195z',
                'M1254 1489l-524 -836v-653h-198v632l-526 857h219l407 -666l411 666h211zM935 2049l-273 -374h-149l179 374h243z',
                'M1174 787q0 -92 -35 -176.5t-95 -141.5q-78 -75 -187.5 -111t-260.5 -36h-198v-322h-198v1489h198v-270h205q133 0 230 -22.5t164 -66.5q83 -53 130 -138t47 -205zM968 782q0 72 -26 125.5t-82 88.5q-48 30 -112 42.5t-154 12.5h-196v-563h167q119 0 195 20.5t123 65.5 q44 41 64.5 92t20.5 116z',
                'M1165 481q0 -214 -135.5 -359.5t-354.5 -145.5q-44 0 -101.5 7.5t-93.5 20.5v165h10q42 -24 91.5 -33t105.5 -9q74 0 129 29t88 78q35 52 50.5 115.5t15.5 139.5q0 166 -105.5 250.5t-303.5 84.5v150q157 0 234 59.5t77 188.5q0 35 -11 68t-41 64q-27 29 -71 46.5 t-105 17.5q-57 0 -103 -14.5t-86 -53.5q-37 -36 -59.5 -102t-22.5 -161v-1087h-188v1080q0 124 36 215.5t100 153.5q60 58 149.5 87.5t183.5 29.5q183 0 297.5 -87t114.5 -238q0 -112 -71 -201t-184 -121v-9q164 -37 259 -148.5t95 -280.5z',
                'M1053 0h-187v119q-25 -17 -67.5 -47.5t-82.5 -48.5q-47 -23 -108 -38.5t-143 -15.5q-151 0 -256 100t-105 255q0 127 54.5 205.5t155.5 123.5q102 45 245 61t307 24v29q0 64 -22.5 106t-64.5 66q-40 23 -96 31t-117 8q-74 0 -165 -19.5t-188 -56.5h-10v191q55 15 159 33 t205 18q118 0 205.5 -19.5t151.5 -66.5q63 -46 96 -119t33 -181v-758zM866 275v311q-86 -5 -202.5 -15t-184.5 -29q-81 -23 -131 -71.5t-50 -133.5q0 -96 58 -144.5t177 -48.5q99 0 181 38.5t152 92.5zM738 1302h-149l-273 374h243z',
                'M1053 0h-187v119q-25 -17 -67.5 -47.5t-82.5 -48.5q-47 -23 -108 -38.5t-143 -15.5q-151 0 -256 100t-105 255q0 127 54.5 205.5t155.5 123.5q102 45 245 61t307 24v29q0 64 -22.5 106t-64.5 66q-40 23 -96 31t-117 8q-74 0 -165 -19.5t-188 -56.5h-10v191q55 15 159 33 t205 18q118 0 205.5 -19.5t151.5 -66.5q63 -46 96 -119t33 -181v-758zM866 275v311q-86 -5 -202.5 -15t-184.5 -29q-81 -23 -131 -71.5t-50 -133.5q0 -96 58 -144.5t177 -48.5q99 0 181 38.5t152 92.5zM934 1676l-273 -374h-149l179 374h243z',
                'M1053 0h-187v119q-25 -17 -67.5 -47.5t-82.5 -48.5q-47 -23 -108 -38.5t-143 -15.5q-151 0 -256 100t-105 255q0 127 54.5 205.5t155.5 123.5q102 45 245 61t307 24v29q0 64 -22.5 106t-64.5 66q-40 23 -96 31t-117 8q-74 0 -165 -19.5t-188 -56.5h-10v191q55 15 159 33 t205 18q118 0 205.5 -19.5t151.5 -66.5q63 -46 96 -119t33 -181v-758zM866 275v311q-86 -5 -202.5 -15t-184.5 -29q-81 -23 -131 -71.5t-50 -133.5q0 -96 58 -144.5t177 -48.5q99 0 181 38.5t152 92.5zM961 1297h-159l-185 256l-184 -256h-155l228 379h227z',
                'M1053 0h-187v119q-25 -17 -67.5 -47.5t-82.5 -48.5q-47 -23 -108 -38.5t-143 -15.5q-151 0 -256 100t-105 255q0 127 54.5 205.5t155.5 123.5q102 45 245 61t307 24v29q0 64 -22.5 106t-64.5 66q-40 23 -96 31t-117 8q-74 0 -165 -19.5t-188 -56.5h-10v191q55 15 159 33 t205 18q118 0 205.5 -19.5t151.5 -66.5q63 -46 96 -119t33 -181v-758zM866 275v311q-86 -5 -202.5 -15t-184.5 -29q-81 -23 -131 -71.5t-50 -133.5q0 -96 58 -144.5t177 -48.5q99 0 181 38.5t152 92.5zM1038 1619q-11 -152 -77 -229t-177 -77q-54 0 -100 19.5t-87 56.5 q-47 43 -79.5 64.5t-71.5 21.5q-52 0 -78 -45t-30 -121h-131q8 151 79 228t174 77q50 0 96.5 -19.5t88.5 -55.5q47 -41 83.5 -61.5t69.5 -20.5q51 0 79.5 46t31.5 116h129z',
                'M1053 0h-187v119q-25 -17 -67.5 -47.5t-82.5 -48.5q-47 -23 -108 -38.5t-143 -15.5q-151 0 -256 100t-105 255q0 127 54.5 205.5t155.5 123.5q102 45 245 61t307 24v29q0 64 -22.5 106t-64.5 66q-40 23 -96 31t-117 8q-74 0 -165 -19.5t-188 -56.5h-10v191q55 15 159 33 t205 18q118 0 205.5 -19.5t151.5 -66.5q63 -46 96 -119t33 -181v-758zM866 275v311q-86 -5 -202.5 -15t-184.5 -29q-81 -23 -131 -71.5t-50 -133.5q0 -96 58 -144.5t177 -48.5q99 0 181 38.5t152 92.5zM926 1304h-199v195h199v-195zM513 1304h-199v195h199v-195z',
                'M1053 0h-187v119q-25 -17 -67.5 -47.5t-82.5 -48.5q-47 -23 -108 -38.5t-143 -15.5q-151 0 -256 100t-105 255q0 127 54.5 205.5t155.5 123.5q102 45 245 61t307 24v29q0 64 -22.5 106t-64.5 66q-40 23 -96 31t-117 8q-74 0 -165 -19.5t-188 -56.5h-10v191q55 15 159 33 t205 18q118 0 205.5 -19.5t151.5 -66.5q63 -46 96 -119t33 -181v-758zM866 275v311q-86 -5 -202.5 -15t-184.5 -29q-81 -23 -131 -71.5t-50 -133.5q0 -96 58 -144.5t177 -48.5q99 0 181 38.5t152 92.5zM956 1630q0 -143 -102 -242t-248 -99q-144 0 -247 98.5t-103 242.5 q0 143 102 241t248 98q147 0 248.5 -98t101.5 -241zM811 1630q0 86 -58.5 145.5t-146.5 59.5t-146.5 -59t-58.5 -146t59 -146t146 -59q88 0 146.5 59t58.5 146z',
                'M1855 559h-819q0 -114 30 -195t85 -133q52 -48 123 -70.5t157 -22.5q111 0 217.5 41.5t172.5 93.5h12v-205q-78 -35 -184.5 -64.5t-215.5 -29.5q-166 0 -284.5 52t-194.5 155q-21 -19 -67 -59t-96 -68q-63 -36 -137 -59.5t-189 -23.5q-150 0 -255.5 97t-105.5 249 q0 124 54 200.5t155 118.5q95 39 241 53t308 17v61q0 65 -23 107.5t-64 65.5q-40 23 -96 31.5t-116 8.5q-79 0 -168.5 -21t-179.5 -57h-13v191q55 15 158 34t204 19q159 0 264.5 -46.5t162.5 -137.5q69 82 170 134t226 52q217 0 342.5 -128t125.5 -379v-82zM1673 703 q-5 68 -23.5 119t-50.5 88q-34 39 -88.5 61t-133.5 22q-133 0 -223 -75t-115 -215h634zM894 298q-20 53 -30.5 119t-10.5 141q-105 -3 -201 -7.5t-178 -25.5q-79 -20 -127.5 -65.5t-48.5 -128.5q0 -95 58 -141t176 -46q99 0 195.5 43t166.5 111z',
                'M1011 70q-33 -15 -71.5 -30.5t-67.5 -24.5q3 -19 5.5 -47.5t2.5 -56.5q0 -162 -91.5 -248t-237.5 -86q-37 0 -95 7t-103 19v160h9q26 -10 70 -23t94 -13q104 0 153 39t49 127q0 22 -1.5 45t-3.5 43q-16 -2 -30.5 -4t-39.5 -2q-121 0 -222 35.5t-173 107.5 q-73 72 -113 182t-40 257q0 274 150.5 430t397.5 156q96 0 188.5 -27t169.5 -66v-209h-10q-86 67 -177.5 103t-178.5 36q-160 0 -252.5 -107.5t-92.5 -315.5q0 -202 90.5 -310.5t254.5 -108.5q57 0 116 15t106 39q41 21 77 44.5t57 40.5h10v-207z',
                'M1120 539h-823q0 -103 31 -179.5t85 -125.5q52 -48 123.5 -72t157.5 -24q114 0 229.5 45.5t164.5 89.5h10v-205q-95 -40 -194 -67t-208 -27q-278 0 -434 150.5t-156 427.5q0 274 149.5 435t393.5 161q226 0 348.5 -132t122.5 -375v-102zM937 683q-1 148 -74.5 229 t-223.5 81q-151 0 -240.5 -89t-101.5 -221h640zM759 1302h-149l-273 374h243z',
                'M1120 539h-823q0 -103 31 -179.5t85 -125.5q52 -48 123.5 -72t157.5 -24q114 0 229.5 45.5t164.5 89.5h10v-205q-95 -40 -194 -67t-208 -27q-278 0 -434 150.5t-156 427.5q0 274 149.5 435t393.5 161q226 0 348.5 -132t122.5 -375v-102zM937 683q-1 148 -74.5 229 t-223.5 81q-151 0 -240.5 -89t-101.5 -221h640zM960 1676l-273 -374h-149l179 374h243z',
                'M1120 539h-823q0 -103 31 -179.5t85 -125.5q52 -48 123.5 -72t157.5 -24q114 0 229.5 45.5t164.5 89.5h10v-205q-95 -40 -194 -67t-208 -27q-278 0 -434 150.5t-156 427.5q0 274 149.5 435t393.5 161q226 0 348.5 -132t122.5 -375v-102zM937 683q-1 148 -74.5 229 t-223.5 81q-151 0 -240.5 -89t-101.5 -221h640zM986 1297h-159l-185 256l-184 -256h-155l228 379h227z',
                'M1120 539h-823q0 -103 31 -179.5t85 -125.5q52 -48 123.5 -72t157.5 -24q114 0 229.5 45.5t164.5 89.5h10v-205q-95 -40 -194 -67t-208 -27q-278 0 -434 150.5t-156 427.5q0 274 149.5 435t393.5 161q226 0 348.5 -132t122.5 -375v-102zM937 683q-1 148 -74.5 229 t-223.5 81q-151 0 -240.5 -89t-101.5 -221h640zM951 1304h-199v195h199v-195zM538 1304h-199v195h199v-195z',
                'M375 0h-188v1117h188v-1117zM401 1302h-149l-273 374h243z',
                'M375 0h-188v1117h188v-1117zM582 1676l-273 -374h-149l179 374h243z',
                'M572 1297h-151l-143 267l-142 -267h-147l178 379h227zM375 0h-188v1117h188v-1117z',
                'M557 1304h-189v195h189v-195zM194 1304h-189v195h189v-195zM375 0h-188v1117h188v-1117z',
                'M1137 637q0 -324 -142 -496t-383 -172q-229 0 -367.5 135t-138.5 380q0 226 137 358t339 132q108 0 185.5 -26.5t163.5 -79.5q-32 112 -99.5 219t-154.5 181l-264 -162l-66 97l237 142q-84 67 -156 107.5t-165 87.5v16h295q35 -25 84 -58.5t86 -59.5l210 128l66 -97 l-186 -109q153 -147 236 -325.5t83 -397.5zM847 226q49 59 75 143.5t26 234.5q0 32 -1.5 59.5t-3.5 57.5q-75 45 -157.5 66.5t-168.5 21.5q-147 0 -231.5 -87.5t-84.5 -239.5q0 -180 84.5 -267t227.5 -87q66 0 127.5 22t106.5 76z',
                'M1119 0h-188v636q0 77 -9 144.5t-33 105.5q-25 42 -72 62.5t-122 20.5q-77 0 -161 -38t-161 -97v-834h-188v1117h188v-124q88 73 182 114t193 41q181 0 276 -109t95 -314v-725zM1075 1619q-11 -152 -77 -229t-177 -77q-54 0 -100 19.5t-87 56.5q-47 43 -79.5 64.5 t-71.5 21.5q-52 0 -78 -45t-30 -121h-131q8 151 79 228t174 77q50 0 96.5 -19.5t88.5 -55.5q47 -41 83.5 -61.5t69.5 -20.5q51 0 79.5 46t31.5 116h129z',
                'M1137 558q0 -273 -140 -431t-375 -158q-237 0 -376.5 158t-139.5 431t139.5 431.5t376.5 158.5q235 0 375 -158.5t140 -431.5zM943 558q0 217 -85 322.5t-236 105.5q-153 0 -237.5 -105.5t-84.5 -322.5q0 -210 85 -318.5t237 -108.5q150 0 235.5 107.5t85.5 319.5z M732 1302h-149l-273 374h243z',
                'M1137 558q0 -273 -140 -431t-375 -158q-237 0 -376.5 158t-139.5 431t139.5 431.5t376.5 158.5q235 0 375 -158.5t140 -431.5zM943 558q0 217 -85 322.5t-236 105.5q-153 0 -237.5 -105.5t-84.5 -322.5q0 -210 85 -318.5t237 -108.5q150 0 235.5 107.5t85.5 319.5z M933 1676l-273 -374h-149l179 374h243z',
                'M1137 558q0 -273 -140 -431t-375 -158q-237 0 -376.5 158t-139.5 431t139.5 431.5t376.5 158.5q235 0 375 -158.5t140 -431.5zM943 558q0 217 -85 322.5t-236 105.5q-153 0 -237.5 -105.5t-84.5 -322.5q0 -210 85 -318.5t237 -108.5q150 0 235.5 107.5t85.5 319.5z M963 1297h-159l-185 256l-184 -256h-155l228 379h227z',
                'M1137 558q0 -273 -140 -431t-375 -158q-237 0 -376.5 158t-139.5 431t139.5 431.5t376.5 158.5q235 0 375 -158.5t140 -431.5zM943 558q0 217 -85 322.5t-236 105.5q-153 0 -237.5 -105.5t-84.5 -322.5q0 -210 85 -318.5t237 -108.5q150 0 235.5 107.5t85.5 319.5z M1038 1619q-11 -152 -77 -229t-177 -77q-54 0 -100 19.5t-87 56.5q-47 43 -79.5 64.5t-71.5 21.5q-52 0 -78 -45t-30 -121h-131q8 151 79 228t174 77q50 0 96.5 -19.5t88.5 -55.5q47 -41 83.5 -61.5t69.5 -20.5q51 0 79.5 46t31.5 116h129z',
                'M1137 558q0 -273 -140 -431t-375 -158q-237 0 -376.5 158t-139.5 431t139.5 431.5t376.5 158.5q235 0 375 -158.5t140 -431.5zM943 558q0 217 -85 322.5t-236 105.5q-153 0 -237.5 -105.5t-84.5 -322.5q0 -210 85 -318.5t237 -108.5q150 0 235.5 107.5t85.5 319.5z M928 1304h-199v195h199v-195zM515 1304h-199v195h199v-195z',
                'M957 1022h-238v275h238v-275zM1466 572h-1256v160h1256v-160zM957 7h-238v275h238v-275z',
                'M1137 558q0 -273 -140 -431t-375 -158q-84 0 -155.5 21t-130.5 60l-133 -198h-110l171 256q-75 77 -116.5 190t-41.5 260q0 273 139.5 431.5t376.5 158.5q87 0 158 -22t125 -57l116 172h111l-155 -231q76 -76 118 -188t42 -264zM813 930q-37 29 -86.5 43.5t-104.5 14.5 q-155 0 -240 -110t-85 -320q0 -97 17 -171t52 -128zM946 558q0 97 -17.5 173t-51.5 130l-448 -671q39 -31 86.5 -46t106.5 -15q150 0 237 108.5t87 320.5z',
                'M1111 0h-188v124q-95 -75 -182 -115t-192 -40q-176 0 -274 107.5t-98 315.5v725h188v-636q0 -85 8 -145.5t34 -103.5q27 -44 70 -64t125 -20q73 0 159.5 38t161.5 97v834h188v-1117zM764 1302h-149l-273 374h243z',
                'M1111 0h-188v124q-95 -75 -182 -115t-192 -40q-176 0 -274 107.5t-98 315.5v725h188v-636q0 -85 8 -145.5t34 -103.5q27 -44 70 -64t125 -20q73 0 159.5 38t161.5 97v834h188v-1117zM945 1676l-273 -374h-149l179 374h243z',
                'M1111 0h-188v124q-95 -75 -182 -115t-192 -40q-176 0 -274 107.5t-98 315.5v725h188v-636q0 -85 8 -145.5t34 -103.5q27 -44 70 -64t125 -20q73 0 159.5 38t161.5 97v834h188v-1117zM985 1297h-159l-185 256l-184 -256h-155l228 379h227z',
                'M1111 0h-188v124q-95 -75 -182 -115t-192 -40q-176 0 -274 107.5t-98 315.5v725h188v-636q0 -85 8 -145.5t34 -103.5q27 -44 70 -64t125 -20q73 0 159.5 38t161.5 97v834h188v-1117zM955 1304h-199v195h199v-195zM542 1304h-199v195h199v-195z',
                'M1151 1117l-652 -1529h-201l208 466l-445 1063h204l343 -828l346 828h197zM928 1676l-273 -374h-149l179 374h243z',
                'M1168 572q0 -136 -39 -248.5t-110 -190.5q-66 -74 -155.5 -114.5t-189.5 -40.5q-87 0 -157.5 19t-143.5 59v-468h-188v1968h188v-556q75 63 168.5 105.5t199.5 42.5q202 0 314.5 -152.5t112.5 -423.5zM974 567q0 202 -69 302t-212 100q-81 0 -163 -35t-157 -92v-633 q80 -36 137.5 -49t130.5 -13q157 0 245 106t88 314z',
                'M585 832h-239v285h239v-285zM658 285l-282 -655h-146l174 655h254z',
                'M773 1676l-49 -384h-145l-49 384h243z',
                'M765 1676l-49 -384h-128l-49 384h226zM1048 1304h-191v195h191v-195zM447 1304h-191v195h191v-195z',
                'M1374 0h-211l-146 415h-644l-146 -415h-201l542 1489h264zM956 585l-261 731l-262 -731h523zM250 1489l-49 -384h-145l-49 384h243z',
                'M585 832h-239v285h239v-285z',
                'M1424 0h-981v1489h981v-176h-783v-408h783v-176h-783v-553h783v-176zM243 1489l-49 -384h-145l-49 384h243z',
                'M1582 0h-198v729h-743v-729h-198v1489h198v-584h743v584h198v-1489zM243 1489l-49 -384h-145l-49 384h243z',
                'M968 0h-588v152h195v1185h-195v152h588v-152h-195v-1185h195v-152zM243 1489l-49 -384h-145l-49 384h243z',
                'M1501 1318q91 -100 139.5 -245t48.5 -329t-49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5zM1483 744 q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5zM243 1489l-49 -384h-145l-49 384h243z',
                'M1537 1489l-524 -836v-653h-198v632l-526 857h219l407 -666l411 666h211zM243 1489l-49 -384h-145l-49 384h243z',
                'M1751 0h-576v387q60 38 119.5 82t103.5 101q45 59 71 138.5t26 185.5q0 206 -127 330.5t-347 124.5t-347 -124.5t-127 -330.5q0 -106 26 -185.5t71 -138.5q45 -57 104 -101t119 -82v-387h-576v174h410v124q-157 90 -258.5 246t-101.5 350q0 276 187.5 451t492.5 175 t492.5 -175t187.5 -451q0 -194 -101.5 -350t-258.5 -246v-124h410v-174zM243 1489l-49 -384h-145l-49 384h243z',
                'M375 0h-188v1117h188v-1117zM379 1676l-56 -384h-84l-56 384h196zM615 1304h-171v195h171v-195zM118 1304h-171v195h171v-195z',
                'M1374 0h-211l-146 415h-644l-146 -415h-201l542 1489h264zM956 585l-261 731l-262 -731h523z',
                'M1323 458q0 -111 -42 -196t-113 -140q-84 -66 -184.5 -94t-255.5 -28h-528v1489h441q163 0 244 -12t155 -50q82 -43 119 -110.5t37 -161.5q0 -106 -54 -180.5t-144 -119.5v-8q151 -31 238 -132.5t87 -256.5zM990 1129q0 54 -18 91t-58 60q-47 27 -114 33.5t-166 6.5h-236 v-430h256q93 0 148 9.5t102 39.5t66.5 77.5t19.5 112.5zM1117 450q0 90 -27 143t-98 90q-48 25 -116.5 32.5t-166.5 7.5h-311v-554h262q130 0 213 13.5t136 49.5q56 39 82 89t26 129z',
                'M1162 1313h-764v-1313h-198v1489h962v-176z',
                'M1414 0h-1388l562 1489h264zM1147 168l-432 1147l-431 -1147h863z',
                'M1181 0h-981v1489h981v-176h-783v-408h783v-176h-783v-553h783v-176z',
                'M1288 0h-1162v184l913 1129h-879v176h1106v-179l-922 -1134h944v-176z',
                'M1339 0h-198v729h-743v-729h-198v1489h198v-584h743v584h198v-1489z',
                'M1310 1318q91 -100 139.5 -245t48.5 -329t-49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5zM1292 744 q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5zM1120 713h-627v179h627v-179z',
                'M725 0h-588v152h195v1185h-195v152h588v-152h-195v-1185h195v-152z',
                'M1397 0h-257l-589 663l-148 -158v-505h-198v1489h198v-777l723 777h240l-665 -700z',
                'M1378 0h-213l-468 1285l-468 -1285h-203l556 1489h240z',
                'M1526 0h-198v1283l-414 -873h-118l-411 873v-1283h-185v1489h270l397 -829l384 829h275v-1489z',
                'M1336 0h-245l-706 1332v-1332h-185v1489h307l644 -1216v1216h185v-1489z',
                'M1215 1313h-1101v176h1101v-176zM1163 729h-997v176h997v-176zM1215 0h-1101v176h1101v-176z',
                'M1310 1318q91 -100 139.5 -245t48.5 -329t-49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5zM1292 744 q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5z',
                'M1339 0h-198v1313h-743v-1313h-198v1489h1139v-1489z',
                'M1174 1039q0 -99 -34.5 -183.5t-96.5 -146.5q-77 -77 -182 -115.5t-265 -38.5h-198v-555h-198v1489h404q134 0 227 -22.5t165 -70.5q85 -57 131.5 -142t46.5 -215zM968 1034q0 77 -27 134t-82 93q-48 31 -109.5 44.5t-155.5 13.5h-196v-595h167q120 0 195 21.5t122 68.5 q47 48 66.5 101t19.5 119z',
                'M1280 0h-1162v184l620 600l-600 526v179h1096v-176h-832l586 -506v-26l-630 -605h922v-176z',
                'M1262 1313h-532v-1313h-198v1313h-532v176h1262v-176z',
                'M1254 1489l-524 -836v-653h-198v632l-526 857h219l407 -666l411 666h211z',
                'M1572 755q0 -140 -44.5 -248.5t-123.5 -181.5q-85 -79 -207 -125.5t-260 -49.5v-166h-197v166q-134 3 -257 48t-210 127q-79 74 -123.5 182t-44.5 248q0 136 43 238t119 178q81 81 202.5 128t270.5 51v155h197v-155q148 -3 271 -52t202 -127q75 -73 118.5 -177t43.5 -239 zM1366 763q0 99 -32 182t-91 140q-58 56 -129 82t-177 28v-890q94 2 171 30.5t127 75.5q65 60 98 147t33 205zM740 305v890q-106 -1 -177 -28t-129 -82t-90.5 -140t-32.5 -182q0 -112 33.5 -203t97.5 -149q49 -45 126.5 -75t171.5 -31z',
                'M1336 1489l-514 -736l513 -753h-229l-406 613l-416 -613h-216l519 744l-507 745h228l401 -605l410 605h217z',
                'M1604 910q0 -157 -40.5 -264.5t-117.5 -174.5q-80 -69 -192.5 -104t-263.5 -45v-322h-197v322q-154 11 -267 47t-188 102q-78 69 -118.5 176t-40.5 263v579h198v-602q0 -109 29.5 -180t81.5 -115q53 -45 130 -68.5t175 -30.5v996h197v-996q97 8 175 30.5t131 68.5 q56 49 83 115.5t27 179.5v602h198v-579z',
                'M1568 0h-576v387q60 38 119.5 82t103.5 101q45 59 71 138.5t26 185.5q0 206 -127 330.5t-347 124.5t-347 -124.5t-127 -330.5q0 -106 26 -185.5t71 -138.5q45 -57 104 -101t119 -82v-387h-576v174h410v124q-157 90 -258.5 246t-101.5 350q0 276 187.5 451t492.5 175 t492.5 -175t187.5 -451q0 -194 -101.5 -350t-258.5 -246v-124h410v-174z',
                'M725 0h-588v152h195v1185h-195v152h588v-152h-195v-1185h195v-152zM738 1677h-199v195h199v-195zM325 1677h-199v195h199v-195z',
                'M1254 1489l-524 -836v-653h-198v632l-526 857h219l407 -666l411 666h211zM939 1677h-199v195h199v-195zM526 1677h-199v195h199v-195z',
                'M1091 0h-188v117q-81 -70 -169 -109t-191 -39q-200 0 -317.5 154t-117.5 427q0 142 40.5 253t109.5 189q68 76 158.5 116t187.5 40q88 0 156 -22t143 -61v52h188v-1117zM903 275v636q-76 34 -136 49.5t-131 15.5q-158 0 -246 -110t-88 -312q0 -199 68 -302.5t218 -103.5 q80 0 162 35.5t153 91.5zM743 1676l-49 -384h-145l-49 384h243z',
                'M1006 64q-107 -48 -210 -69t-218 -21q-79 0 -161 16t-152 56q-69 39 -112.5 102.5t-43.5 157.5q0 96 56.5 168t177.5 110v7q-91 24 -145 90t-54 158q0 89 47.5 147.5t112.5 92.5q64 33 145 49t160 16q98 0 180 -16.5t172 -44.5v-207h-13q-66 51 -163.5 79t-197.5 28 q-45 0 -84 -5.5t-81 -25.5q-35 -15 -60.5 -48.5t-25.5 -77.5q0 -61 28 -95t76 -49q45 -14 97 -15.5t105 -1.5h111v-166h-158q-62 0 -112 -4.5t-92 -21.5q-41 -17 -65.5 -54t-24.5 -96q0 -53 26 -90t67 -58q37 -19 87.5 -29t106.5 -10q102 0 218 36t187 98h13v-206zM721 1676 l-49 -384h-145l-49 384h243z',
                'M1119 -412h-188v1048q0 77 -9 144.5t-33 105.5q-25 42 -72 62.5t-122 20.5q-77 0 -161 -38t-161 -97v-834h-188v1117h188v-124q88 73 182 114t193 41q181 0 276 -109t95 -314v-1137zM802 1676l-49 -384h-145l-49 384h243z',
                'M375 0h-188v1117h188v-1117zM403 1676l-49 -384h-145l-49 384h243z',
                'M1116 407q0 -218 -122 -327.5t-348 -109.5q-223 0 -346 107.5t-123 329.5v710h188v-641q0 -93 10 -153t42 -106q31 -43 84.5 -64.5t145.5 -21.5q86 0 143.5 22t87.5 66q29 44 39.5 105.5t10.5 151.5v641h188v-710zM760 1676l-49 -384h-128l-49 384h226zM1043 1304h-191 v195h191v-195zM442 1304h-191v195h191v-195z',
                'M1091 0h-188v117q-81 -70 -169 -109t-191 -39q-200 0 -317.5 154t-117.5 427q0 142 40.5 253t109.5 189q68 76 158.5 116t187.5 40q88 0 156 -22t143 -61v52h188v-1117zM903 275v636q-76 34 -136 49.5t-131 15.5q-158 0 -246 -110t-88 -312q0 -199 68 -302.5t218 -103.5 q80 0 162 35.5t153 91.5z',
                'M1165 444q0 -202 -134.5 -334t-339.5 -132q-79 0 -167 22t-151 64v-476h-188v1490q0 224 126.5 351t349.5 127q90 0 164.5 -21.5t133.5 -67.5q57 -43 91 -112t34 -160q0 -127 -69.5 -221.5t-196.5 -131.5v-17q159 -26 253 -125.5t94 -255.5zM971 449q0 89 -34.5 144.5 t-92.5 86.5q-59 32 -132 43t-146 11h-36v160h36q66 0 131 14.5t104 44.5q46 34 68.5 83t22.5 134q0 112 -69 170t-178 58q-73 0 -125 -26.5t-85 -70.5q-32 -44 -47 -102.5t-15 -120.5v-862q66 -38 141 -53.5t147 -15.5q149 0 229.5 78.5t80.5 223.5z',
                'M1151 1117l-457 -1061v-468h-188v468l-445 1061h204l343 -828l346 828h197z',
                'M1139 551q0 -272 -138.5 -427t-376.5 -155q-241 0 -379.5 151.5t-138.5 413.5q0 141 43 239.5t107 162.5q69 72 159 113t182 58q-76 63 -166 130.5t-192 139.5v179h810v-158h-561v-10q68 -46 179 -124t204 -162q150 -136 209 -261.5t59 -289.5zM945 551q0 135 -55 249 t-165 200q-66 -8 -138.5 -32t-138.5 -77q-63 -50 -105.5 -137t-42.5 -214q0 -201 85 -305t241 -104q153 0 236 105.5t83 314.5z',
                'M1006 64q-107 -48 -210 -69t-218 -21q-79 0 -161 16t-152 56q-69 39 -112.5 102.5t-43.5 157.5q0 96 56.5 168t177.5 110v7q-91 24 -145 90t-54 158q0 89 47.5 147.5t112.5 92.5q64 33 145 49t160 16q98 0 180 -16.5t172 -44.5v-207h-13q-66 51 -163.5 79t-197.5 28 q-45 0 -84 -5.5t-81 -25.5q-35 -15 -60.5 -48.5t-25.5 -77.5q0 -61 28 -95t76 -49q45 -14 97 -15.5t105 -1.5h111v-166h-158q-62 0 -112 -4.5t-92 -21.5q-41 -17 -65.5 -54t-24.5 -96q0 -53 26 -90t67 -58q37 -19 87.5 -29t106.5 -10q102 0 218 36t187 98h13v-206z',
                'M922 75q32 -40 46 -85.5t14 -85.5q0 -84 -45 -168.5t-112 -147.5h-179v14q90 79 128 138.5t38 128.5q0 57 -30.5 95t-77.5 38h-145q-229 0 -340 116t-111 345q0 140 46 268t124 247q75 112 173.5 214.5t206.5 196.5v9h-460v158h744v-135q-117 -78 -231.5 -181 t-204.5 -223q-89 -117 -146 -257t-57 -283q0 -34 3 -70t15 -76q10 -38 34.5 -75.5t63.5 -61.5q36 -22 96.5 -24.5t116.5 -2.5h86q71 0 122 -26t82 -66z',
                'M1119 -412h-188v1048q0 77 -9 144.5t-33 105.5q-25 42 -72 62.5t-122 20.5q-77 0 -161 -38t-161 -97v-834h-188v1117h188v-124q88 73 182 114t193 41q181 0 276 -109t95 -314v-1137z',
                'M1141 768q0 -190 -23 -316.5t-59 -210.5q-58 -135 -163 -203.5t-257 -68.5t-257 68.5t-163 203.5q-37 84 -59.5 210.5t-22.5 316.5q0 174 22.5 305.5t60.5 214.5q57 130 162.5 199t256.5 69t256.5 -69t162.5 -199q37 -84 60 -215t23 -305zM952 858q-4 143 -28.5 250 t-56.5 161q-41 70 -95 98.5t-133 28.5t-133 -28.5t-95 -98.5q-34 -55 -57.5 -161.5t-27.5 -249.5h626zM952 697h-626q0 -142 23 -258.5t59 -178.5q40 -69 96 -100t135 -31t135 31t96 100q36 62 59 178.5t23 258.5z',
                'M375 0h-188v1117h188v-1117z',
                'M1192 0h-248l-451 489l-112 -109v-380h-188v1117h188v-550l384 417q72 79 135.5 107t126.5 28q28 0 58 -1t37 -1v-166h-11q-16 2 -39.5 3t-36.5 1q-47 0 -85.5 -23.5t-67.5 -56.5l-251 -271z',
                'M1151 0h-205l-328 829l-361 -829h-196l465 1056l-215 500h211z',
                'M1125 0h-186v118q-74 -78 -141.5 -108.5t-145.5 -30.5q-75 0 -135 27t-144 107v-525h-188v1529h188v-838q32 -39 111 -80t170 -41q93 0 161 33.5t122 93.5v832h188v-1117z',
                'M1151 1117l-452 -1117h-189l-449 1117h204l346 -889l343 889h197z',
                'M1041 -96q0 -85 -45.5 -169t-111.5 -147h-180v14q92 79 129.5 139t37.5 128q0 55 -29 94t-75 39h-140q-140 0 -232.5 27t-155.5 84q-66 60 -100.5 135.5t-34.5 163.5q0 78 25 144t73 119q44 49 112.5 83.5t144.5 53.5v11q-125 28 -200 110.5t-75 186.5q0 83 43.5 150.5 t133.5 125.5v6h-228v154h824v-158h-256q-68 0 -122.5 -14.5t-102.5 -48.5q-45 -32 -72 -83t-27 -118q0 -79 32.5 -128t83.5 -75q45 -23 104 -34t139 -11h170v-165h-295q-66 0 -118.5 -20t-99.5 -59q-43 -37 -68.5 -90t-25.5 -112q0 -102 37.5 -159t101.5 -82 q63 -25 139.5 -28.5t166.5 -3.5h28q68 0 119.5 -23.5t84.5 -60.5q31 -35 48 -82.5t17 -96.5z',
                'M1137 558q0 -273 -140 -431t-375 -158q-237 0 -376.5 158t-139.5 431t139.5 431.5t376.5 158.5q235 0 375 -158.5t140 -431.5zM943 558q0 217 -85 322.5t-236 105.5q-153 0 -237.5 -105.5t-84.5 -322.5q0 -210 85 -318.5t237 -108.5q150 0 235.5 107.5t85.5 319.5z',
                'M1120 0h-188v955h-559v-955h-188v1117h935v-1117z',
                'M1172 577q0 -258 -138.5 -428.5t-360.5 -170.5q-65 0 -146.5 18t-153.5 61v-469h-188v1058q0 123 35.5 215.5t101.5 158.5q62 62 155.5 95t195.5 33q243 0 371 -147t128 -424zM978 565q0 218 -80 320t-226 102q-158 0 -228.5 -96t-70.5 -278v-403q73 -34 132.5 -48.5 t134.5 -14.5q162 0 250 111t88 307z',
                'M1018 -96q0 -87 -47 -172t-109 -144h-177v14q86 75 124.5 135.5t38.5 131.5q0 54 -30 93.5t-75 39.5h-92q-117 0 -216 30t-174 97q-73 66 -114.5 170t-41.5 250q0 270 155.5 432t414.5 162q84 0 164 -18.5t147 -45.5v-211h-12q-94 62 -172.5 87t-146.5 25 q-166 0 -260.5 -119t-94.5 -312q0 -112 28.5 -183t78.5 -116q50 -44 114.5 -63.5t139.5 -19.5h100q115 0 186 -76.5t71 -186.5z',
                'M1137 558q0 -281 -140.5 -435t-373.5 -154q-241 0 -379 158t-138 431q0 275 141 432.5t378 157.5q55 0 108 -11t82 -20h480v-165h-288q62 -73 96 -170t34 -224zM943 558q0 215 -82 322t-236 107q-161 0 -243 -112t-82 -317q0 -209 83.5 -318t239.5 -109q152 0 236 107.5 t84 319.5z',
                'M1006 952h-404v-952h-188v952h-404v165h996v-165z',
                'M1116 407q0 -218 -122 -327.5t-348 -109.5q-223 0 -346 107.5t-123 329.5v710h188v-641q0 -93 10 -153t42 -106q31 -43 84.5 -64.5t145.5 -21.5q86 0 143.5 22t87.5 66q29 44 39.5 105.5t10.5 151.5v641h188v-710z',
                'M1514 576q0 -259 -171.5 -417t-440.5 -173v-398h-187v398q-130 6 -240.5 46.5t-191.5 109.5q-85 74 -132 172t-47 232q0 159 59 296t192 275h229v-17q-136 -99 -210 -232t-74 -300q0 -189 112.5 -304t301.5 -121v1000q33 2 70.5 2.5t76.5 0.5q304 0 478.5 -149.5 t174.5 -420.5zM1319 586q0 184 -112 293.5t-305 109.5v-846q206 10 311.5 126t105.5 317z',
                'M1160 -412h-213l-346 619l-350 -619h-203l444 770l-433 759h213l335 -600l339 600h203l-433 -751z',
                'M1507 446q0 -114 -48 -198t-127 -137q-82 -55 -182 -82.5t-215 -32.5v-408h-187v408q-115 6 -214.5 32t-182.5 83q-80 54 -127.5 137.5t-47.5 197.5v671h188v-612q0 -113 37.5 -180.5t89.5 -102.5q56 -38 123 -53t134 -19v967h187v-967q67 5 134 19t123 53 q59 40 93 101.5t34 181.5v612h188v-671z',
                'M1553 503q0 -96 -23.5 -192.5t-74.5 -171.5q-55 -80 -133.5 -124.5t-193.5 -44.5q-96 0 -177 49.5t-118 116.5h-6q-39 -68 -113 -117t-176 -49q-113 0 -194.5 46.5t-132.5 122.5t-74.5 171.5t-23.5 192.5q0 170 57 308.5t201 305.5h228v-17q-135 -108 -214.5 -262 t-79.5 -337q0 -66 8 -122.5t38 -119.5q26 -55 72.5 -91.5t117.5 -36.5q51 0 86.5 12.5t55.5 29.5q22 18 36.5 40t20.5 37v584h186v-584q9 -17 23 -39t35 -39q24 -19 52.5 -30t86.5 -11q70 0 117 35.5t74 92.5q25 55 36 116t11 126q0 182 -78.5 336t-215.5 263v17h228 q144 -167 201 -305.5t57 -308.5z',
                'M557 1304h-189v195h189v-195zM194 1304h-189v195h189v-195zM375 0h-188v1117h188v-1117z',
                'M1116 407q0 -218 -122 -327.5t-348 -109.5q-223 0 -346 107.5t-123 329.5v710h188v-641q0 -93 10 -153t42 -106q31 -43 84.5 -64.5t145.5 -21.5q86 0 143.5 22t87.5 66q29 44 39.5 105.5t10.5 151.5v641h188v-710zM953 1304h-199v195h199v-195zM540 1304h-199v195h199 v-195z',
                'M1137 558q0 -273 -140 -431t-375 -158q-237 0 -376.5 158t-139.5 431t139.5 431.5t376.5 158.5q235 0 375 -158.5t140 -431.5zM943 558q0 217 -85 322.5t-236 105.5q-153 0 -237.5 -105.5t-84.5 -322.5q0 -210 85 -318.5t237 -108.5q150 0 235.5 107.5t85.5 319.5z M743 1676l-49 -384h-145l-49 384h243z',
                'M1116 407q0 -218 -122 -327.5t-348 -109.5q-223 0 -346 107.5t-123 329.5v710h188v-641q0 -93 10 -153t42 -106q31 -43 84.5 -64.5t145.5 -21.5q86 0 143.5 22t87.5 66q29 44 39.5 105.5t10.5 151.5v641h188v-710zM768 1676l-49 -384h-145l-49 384h243z',
                'M1553 503q0 -96 -23.5 -192.5t-74.5 -171.5q-55 -80 -133.5 -124.5t-193.5 -44.5q-96 0 -177 49.5t-118 116.5h-6q-39 -68 -113 -117t-176 -49q-113 0 -194.5 46.5t-132.5 122.5t-74.5 171.5t-23.5 192.5q0 170 57 308.5t201 305.5h228v-17q-135 -108 -214.5 -262 t-79.5 -337q0 -66 8 -122.5t38 -119.5q26 -55 72.5 -91.5t117.5 -36.5q51 0 86.5 12.5t55.5 29.5q22 18 36.5 40t20.5 37v584h186v-584q9 -17 23 -39t35 -39q24 -19 52.5 -30t86.5 -11q70 0 117 35.5t74 92.5q25 55 36 116t11 126q0 182 -78.5 336t-215.5 263v17h228 q144 -167 201 -305.5t57 -308.5zM955 1676l-49 -384h-145l-49 384h243z',
                'M1145 837q0 -164 -39 -344t-121 -303q-85 -124 -186.5 -173t-214.5 -49q-192 0 -313.5 126.5t-121.5 329.5q0 228 134.5 372.5t336.5 144.5q90 0 169.5 -26t158.5 -91q2 26 3 55.5t1 55.5q0 217 -79 318t-231 101q-78 0 -169.5 -31.5t-169.5 -86.5h-11v194 q81 44 181.5 66.5t196.5 22.5q137 0 239.5 -54.5t164.5 -178.5q42 -86 56.5 -189t14.5 -260zM942 678q-60 47 -136 74t-148 27q-141 0 -225 -91t-84 -261q0 -145 67.5 -221.5t179.5 -76.5q128 0 209.5 97t115.5 287q6 33 11.5 73t9.5 92z',
                'M1438 0h-1388l562 1489h264zM1171 168l-432 1147l-431 -1147h863z',
                'M1532 1315h-200v-1508h-198v1508h-592v-1508h-198v1508h-200v174h1388v-174z',
                'M1369 -189h-1182v191l673 668l-663 631v188h1133v-176h-891l648 -601v-72l-666 -653h948v-176z',
                'M1456 572h-1236v160h1236v-160z',
                'M843 1489l-780 -1489h-165l780 1489h165z',
                'M492 511h-239v283h239v-283z',
                'M1737 1788l-880 -1939h-102l-384 993h-237v139h393l313 -821l730 1628h167z',
                'M1887 663q0 -239 -122.5 -372.5t-329.5 -133.5q-133 0 -244 76.5t-180 222.5q-79 -151 -184.5 -225t-248.5 -74q-191 0 -304 135.5t-113 349.5q0 238 125 372t327 134q134 0 245 -77t179 -222q79 150 185.5 224.5t247.5 74.5q191 0 304 -135.5t113 -349.5zM967 729 q-63 117 -155 175.5t-188 58.5q-138 0 -216 -83.5t-78 -237.5q0 -133 63.5 -216t182.5 -83q110 0 172 48.5t119 142.5q34 57 52.5 92.5t47.5 102.5zM1718 663q0 134 -64 216.5t-182 82.5q-88 0 -152.5 -35.5t-138.5 -155.5q-30 -48 -55.5 -99.5t-44.5 -95.5 q60 -115 153.5 -174.5t189.5 -59.5q138 0 216 83t78 238z',
                'M1168 1367h-10q-32 8 -89.5 18.5t-89.5 10.5q-129 0 -181 -61q-53 -61 -53 -210v-1123q0 -206 -104 -315q-105 -110 -293 -110q-52 0 -106.5 5.5t-103.5 15.5v178h10q33 -8 87 -18.5t88 -10.5q129 0 182 61q52 61 52 210v1123q0 204 104 315q104 110 293 110 q58 0 109 -5.5t105 -15.5v-178z',
                'M1431 1104q-20 -194 -111 -293t-249 -99q-77 0 -147 37.5t-126 82.5q-65 52 -117 79.5t-96 27.5q-75 0 -117 -48t-70 -172h-155q23 182 112.5 280t248.5 98q72 0 143 -37t130 -83q61 -48 114.5 -77.5t98.5 -29.5q76 0 120.5 54.5t63.5 179.5h157zM1432 588 q-25 -184 -112 -281.5t-250 -97.5q-72 0 -144 37.5t-129 82.5q-39 31 -103 69t-110 38q-78 0 -121 -55t-63 -179h-157q19 192 110.5 292t249.5 100q77 0 146 -37t127 -83q35 -28 97 -67.5t116 -39.5q75 0 117 49.5t69 171.5h157z',
                'M1431 362h-608l-104 -335h-153l104 335h-425v156h474l84 268h-558v156h606l105 335h153l-105 -335h427v-156h-476l-83 -268h559v-156z',
                'M1408 303l-1154 483v124l1154 483v-183l-889 -362l889 -362v-183zM1408 0h-1154v160h1154v-160z',
                'M1422 786l-1154 -483v183l889 362l-889 362v183l1154 -483v-124zM1422 0h-1154v160h1154v-160z'
            ];
            this.OUTLINE_X = [
                [], [291, 301, 505, 515], [168, 211, 729, 772, 554], [195, 389, 917, 1364, 1481, 1481, 1288, 760, 312, 195],
                [155, 604, 722, 1129.8, 1160, 1107, 722, 604, 278.5, 191.1, 162, 155], [149, 172.3, 242, 630, 1687, 1844.3, 1960, 2031.3, 2055, 2031.8, 1962, 1575, 517, 359.8, 244, 172.8],
                [115, 149.4, 252.5, 407.6, 598, 1555, 1287, 961.3, 881, 757.5, 601, 423.5, 293, 213.5, 187], [164, 207, 343, 386], [181, 205.5, 279, 554, 783, 783, 554, 279, 205.5],
                [147, 376, 651, 724.5, 749, 724.5, 651, 376, 147], [167, 232, 588, 717, 1073, 1137, 1137, 1073, 717, 588, 232, 167], [210, 755, 921, 1466, 1466, 921, 755, 210],
                [147, 293, 575, 321], [153, 777, 777, 153], [253, 492, 492, 253], [-30, 143, 860, 684],
                [137, 167.9, 260.5, 420.1, 652, 881.4, 1041.5, 1135.6, 1167, 1136.1, 1043.5, 883.9, 652, 422, 262, 168.3], [278, 1084, 1084, 780, 625, 278],
                [161, 1169, 1169, 1106, 1073.5, 976, 821.3, 617, 387.5, 198, 161], [167, 364, 608, 830.5, 1007, 1111, 1148, 1117, 1080, 971, 821, 629, 399.5, 210, 167],
                [77, 790, 982, 1203, 1203, 982, 798, 77], [187, 378, 613, 843.5, 1015, 1119, 1157, 1147, 251, 187],
                [137, 183.5, 316, 475, 675, 875.1, 1041.5, 1153.6, 1191, 1046, 965, 866, 542, 315, 179.5], [154, 285, 499, 1173, 1173, 154],
                [122, 157.9, 265.5, 433.6, 651, 859.6, 1029.5, 1142.4, 1180, 1140, 1106.8, 1007, 851.5, 651, 456.8, 300, 196.5, 162],
                [113, 258, 340, 438, 760, 988, 1122.5, 1167, 1121, 990, 829, 629, 429.5, 263, 150.5], [346, 585, 585, 346], [230, 376, 658, 585, 346], [254, 1408, 1408, 254],
                [245, 1431, 1431, 245], [268, 1422, 1422, 268], [160, 406, 610, 970, 1005, 973.9, 880.5, 733.4, 541, 337.5, 160],
                [176, 240, 419, 692, 1037, 1210, 1391, 1714, 1829.5, 1870, 1813.5, 1651, 1391, 1041, 701, 426, 243], [26, 1374, 832, 568],
                [200, 728, 983.5, 1168, 1281, 1323, 1196, 1159, 1040, 885, 641, 200], [115, 169, 319, 549.5, 844, 1001.5, 1134, 1250.5, 1350, 1350, 1084.5, 845, 546.5, 317, 167],
                [200, 576, 906.5, 1134, 1369.5, 1458, 1373, 1136, 918.5, 572, 200], [200, 1181, 1181, 200], [200, 398, 1045, 1151, 1151, 200],
                [115, 171, 330, 577, 896, 1175.5, 1442, 1442, 1441, 1155.5, 896, 570.9, 323.5, 167.1], [200, 1339, 1339, 200], [137, 725, 725, 137],
                [44, 178, 306, 486.6, 626.5, 716.1, 746, 746, 233, 44], [205, 1397, 1366, 205], [200, 1142, 1142, 398, 200], [200, 1526, 1526, 200], [200, 1336, 1336, 200],
                [115, 163.5, 302, 520.5, 806, 1092.5, 1310, 1448.5, 1498, 1449.5, 1310, 1093.5, 806, 521.5, 303, 163], [200, 398, 1043, 1139.5, 1174, 1127.5, 996, 831, 604, 200],
                [115, 163.5, 302, 520.5, 1010.5, 1133.1, 1290, 1409.5, 1528, 1528, 1498, 1449.5, 1310, 1093.5, 806, 521.5, 303, 163], [200, 1432, 1130.5, 1004, 842, 617, 200],
                [134, 395.5, 685, 941.5, 1128, 1241.5, 1282, 1222, 990, 702, 480.3, 301, 182.5, 143, 134], [0, 532, 730, 1262, 1262, 0],
                [178, 213.5, 330, 505, 749, 989, 1169, 1285.5, 1321, 1321, 178], [26, 568, 832, 1374, 238], [92, 486, 1546, 1933, 295], [68, 1335, 1336, 80], [6, 532, 730, 1254, 225],
                [126, 1288, 1288, 1266, 160, 126], [239, 759, 759, 239], [70, 787, 960, 246], [171, 691, 691, 171], [186, 383, 1490, 901, 775], [-4, 1306, 1306, -4], [340, 613, 762, 583],
                [104, 130.3, 209, 325.5, 465, 1053, 1053, 1020, 924, 772.5, 567, 362, 203], [185, 679, 866, 1022, 1128.5, 1168, 1139.4, 1053.5, 918.1, 373, 185],
                [105, 145, 258, 431, 653, 832.5, 1011, 1011, 841.5, 653, 430.1, 255.5, 142.6], [108, 137.4, 225.5, 363.6, 543, 1091, 1091, 903, 258, 148.5],
                [106, 145, 262, 448.5, 696, 904, 1098, 1120, 1120, 1089.4, 997.5, 849.1, 649, 428.6, 255.5, 143.4], [68, 195, 383, 716, 786, 786, 693.5, 580, 415, 294, 68],
                [108, 225, 391.5, 565, 798.3, 962, 1058.8, 1091, 1091, 602, 417, 259, 148.5], [185, 1119, 1119, 1095.3, 1024, 373, 185], [175, 187, 375, 387, 387, 175],
                [-62, 47.5, 153, 304, 421, 496, 521, 533, 533, 321, 100, -62], [193, 1199, 1161, 381, 193], [187, 375, 375, 187], [185, 1815, 1815, 1793.1, 1727.5, 1615.9, 1456, 735, 185],
                [185, 1119, 1119, 1095.3, 1024, 907.5, 748, 185], [106, 140.9, 245.5, 409.4, 622, 833.3, 997, 1102, 1137, 1102, 997, 833.3, 622, 409.4, 245.5, 140.9],
                [185, 373, 1019, 1129, 1168, 1139.9, 1055.5, 920.6, 741, 185], [108, 137.6, 226.5, 365.1, 903, 1091, 1091, 602, 414, 259, 149.5], [185, 373, 882, 882, 816, 745, 185],
                [110, 283.5, 511, 706.9, 856.5, 951.4, 983, 939, 768.5, 566, 372.5, 230, 143.5, 115, 110], [62, 211.3, 278, 387.5, 538, 649.5, 765, 765, 377, 189, 62],
                [177, 201.5, 275, 392.5, 549, 1111, 1111, 177], [61, 510, 699, 1151, 265], [86, 380, 1299, 1590, 766], [60, 1152, 1152, 64], [61, 298, 499, 1151, 265],
                [93, 995, 995, 978, 107, 93], [173, 588.9, 672.5, 800.9, 963, 1113, 1113, 963, 800.9, 672.5, 588.9, 173], [378, 552, 552, 378],
                [187, 337, 499.1, 627.5, 711.1, 1127, 1127, 711.1, 627.5, 499.1, 337, 187], [187, 354, 1125, 1290, 1401, 1466.5, 1489, 1322, 551, 386, 274, 209.5], [], [291, 515, 505, 301],
                [159, 191.6, 289.5, 647, 765, 1120, 1120, 765, 647, 292.5, 192.4], [137, 1163, 1163, 1137, 997, 816, 630.6, 484.5, 389.6, 182, 137],
                [138, 247, 1058, 1168, 1168, 1055, 249, 138], [108, 187, 557, 745, 1115, 1191, 320], [378, 552, 552, 378],
                [172, 229, 404.5, 575, 796, 965, 1063, 1096, 1128, 1071, 896, 725, 497.5, 334, 235, 203], [346, 958, 958, 346],
                [159, 222.4, 412.5, 692.1, 1024, 1355.9, 1635.5, 1825.6, 1889, 1825.6, 1635.5, 1355.9, 1024, 692.1, 412.5, 222.4],
                [151, 238.5, 454, 944, 944, 920.3, 849, 723.5, 537, 368, 231], [166, 716, 1146, 1146, 716, 166], [210, 1285, 1456, 1456, 210], [153, 777, 777, 153],
                [159, 222.4, 412.5, 692.1, 1024, 1355.9, 1635.5, 1825.6, 1889, 1825.6, 1635.5, 1355.9, 1024, 692.1, 412.5, 222.4], [-4, 1, 1306, 1306],
                [154, 183, 270, 399.3, 555, 710.8, 840, 927, 956, 927.1, 840.5, 711.4, 555, 399.3, 270, 183], [215, 1461, 1461, 921, 755, 215],
                [207, 967, 967, 911, 887.6, 817.5, 544, 369.5, 211, 207], [207, 363.5, 540, 703, 834, 923, 956, 929, 904.9, 832.5, 561, 384.5, 224, 207], [541, 690, 963, 720],
                [190, 378, 1124, 1124, 190], [137, 168.5, 595, 1106, 1106, 640, 425.3, 267, 169.5], [253, 492, 492, 253], [353, 456, 551, 788.5, 857.1, 880, 877, 872, 719, 353],
                [291, 299, 914, 914, 693, 558, 291], [121, 150.6, 239.5, 378.6, 559, 734.3, 874, 965.5, 996, 965.5, 874, 734.3, 559, 378.6, 239.5, 150.6], [174, 604, 1154, 1154, 604, 174],
                [171, 465, 1694, 1857, 1857, 1694, 1410, 545, 408, 171], [171, 465, 1955, 1955, 1890, 1805.5, 1410, 545, 408, 171], [140, 555, 1750, 1913, 1913, 1750, 1500, 448, 294, 155, 140],
                [113, 144.1, 237.5, 384.6, 577, 782, 958, 958, 712, 508, 147.5], [26, 1374, 862, 683, 440], [26, 1374, 955, 712, 533], [26, 1374, 1033, 805, 578, 350],
                [26, 1374, 1119, 990, 541, 367, 288], [26, 1374, 1005, 806, 393], [26, 1374, 1049, 1023.6, 947.5, 834.6, 699, 564, 451, 374.5, 349], [14, 1901, 1901, 608],
                [115, 169, 548, 652.5, 750, 990.5, 1350, 1350, 1084.5, 845, 546.5, 317, 167], [200, 1181, 1181, 643, 400, 200], [200, 1181, 1181, 993, 750, 200],
                [200, 1181, 1181, 803, 576, 200], [200, 1181, 1181, 1038, 426, 200], [137, 725, 725, 389, 146, 137], [137, 725, 725, 482, 137], [93, 137, 725, 776, 548, 321],
                [126, 137, 725, 738, 738, 126], [14, 210, 586, 916.5, 1144, 1379.5, 1468, 1383, 1146, 929, 582, 210, 14], [200, 1336, 1336, 1208, 1079, 630, 456, 200],
                [115, 163.5, 302, 520.5, 806, 1092.5, 1310, 1448.5, 1498, 1449.5, 1310, 753, 510, 163], [115, 163.5, 302, 520.5, 806, 1092.5, 1310, 1448.5, 1498, 1449.5, 1083, 840, 303, 163],
                [115, 163.5, 302, 520.5, 806, 1092.5, 1310, 1448.5, 1498, 1449.5, 1136, 908, 681, 453, 163],
                [115, 163.5, 302, 520.5, 806, 1092.5, 1310, 1448.5, 1498, 1449.5, 1207, 1078, 629, 455, 163],
                [112, 160.5, 299, 517.5, 803, 1089.5, 1307, 1445.5, 1495, 1446.5, 1108, 909, 496, 160], [291, 402, 1274, 1385, 1385, 1274, 402, 291],
                [115, 120, 252, 1092.5, 1310, 1448.5, 1498, 1474, 1342, 806, 521.5, 303, 163], [178, 213.5, 330, 505, 749, 989, 1169, 1285.5, 1321, 1321, 753, 510, 178],
                [178, 213.5, 330, 505, 749, 989, 1169, 1285.5, 1321, 1321, 1073, 830, 178], [178, 213.5, 330, 505, 749, 989, 1169, 1285.5, 1321, 1321, 856, 629, 178],
                [178, 213.5, 330, 505, 749, 989, 1169, 1285.5, 1321, 1321, 1056, 444, 178], [6, 532, 730, 1254, 935, 692], [200, 398, 1044, 1139, 1174, 1127, 997, 398, 200],
                [185, 675, 873.1, 1029.5, 1131.1, 1165, 1066, 1037.4, 951.5, 819.9, 654, 470.5, 321, 221, 185], [104, 130.3, 209, 325.5, 465, 1053, 1053, 1020, 559, 316, 203],
                [104, 130.3, 209, 325.5, 465, 1053, 1053, 934, 691, 203], [104, 130.3, 209, 325.5, 465, 1053, 1053, 961, 733, 506, 278, 203],
                [104, 130.3, 209, 325.5, 465, 1053, 1053, 1038, 909, 460, 286, 207], [104, 130.3, 209, 325.5, 465, 1053, 1053, 926, 314, 203],
                [104, 130.3, 209, 325.5, 465, 1053, 1053, 956, 930.6, 854.5, 741.6, 606, 471, 358, 281.5, 256],
                [104, 130.4, 209.5, 326.1, 465, 1433, 1648.5, 1833, 1855, 1855, 1823.6, 1729.5, 1581.1, 1387, 564, 360, 202],
                [105, 145, 353, 456, 551, 788.5, 857.1, 1011, 1011, 841.5, 653, 430.1, 255.5, 142.6], [106, 145, 262, 448.5, 696, 904, 1098, 1120, 1120, 1089.4, 997.5, 580, 337, 143.4],
                [106, 145, 262, 448.5, 696, 904, 1098, 1120, 1120, 1089.4, 960, 717, 255.5, 143.4], [106, 145, 262, 448.5, 696, 904, 1098, 1120, 1120, 1089.4, 986, 758, 531, 303, 143.4],
                [106, 145, 262, 448.5, 696, 904, 1098, 1120, 1120, 1089.4, 951, 339, 143.4], [-21, 187, 375, 401, 222], [160, 187, 375, 582, 339], [-11, 187, 375, 572, 394, 167],
                [5, 187, 375, 557, 557, 5], [106, 140.6, 244.5, 405.6, 612, 828.3, 995, 1101.5, 1137, 1004, 938, 263], [185, 1119, 1119, 1075, 946, 497, 323, 244, 185],
                [106, 140.9, 245.5, 409.4, 622, 833.3, 997, 1102, 1137, 1102, 997, 553, 310, 140.9], [106, 140.9, 245.5, 409.4, 622, 833.3, 997, 1102, 1137, 1102, 933, 690, 245.5, 140.9],
                [106, 140.9, 245.5, 409.4, 622, 833.3, 997, 1102, 1137, 1102, 963, 735, 508, 280, 140.9], [106, 140.9, 245.5, 409.4, 622, 833.3, 997, 1102, 1137, 1038, 909, 460, 286, 207],
                [106, 140.9, 245.5, 409.4, 622, 833.3, 997, 1102, 1137, 1102, 928, 729, 316, 140.9], [210, 719, 957, 1466, 1466, 957, 719, 210],
                [93, 203, 833.3, 997, 1102, 1137, 1132, 1021, 409.4, 245.5, 140.9, 106], [177, 201.5, 275, 392.5, 549, 1111, 1111, 585, 342, 177],
                [177, 201.5, 275, 392.5, 549, 1111, 1111, 945, 702, 177], [177, 201.5, 275, 392.5, 549, 1111, 1111, 757, 530, 177], [177, 201.5, 275, 392.5, 549, 1111, 1111, 955, 343, 177],
                [61, 298, 499, 1151, 928, 685], [185, 373, 1019, 1129, 1168, 1139.9, 1055.5, 920.6, 373, 185], [230, 376, 658, 585, 346], [530, 579, 724, 773],
                [256, 588, 716, 1048, 1048, 765, 539, 256], [7, 26, 1374, 832], [346, 585, 585, 346], [0, 49, 443, 1424, 1424, 443], [0, 49, 443, 1582, 1582, 443], [0, 49, 380, 968, 968, 380],
                [0, 49, 354.5, 493, 711.5, 997, 1283.5, 1501, 1639.5, 1689, 1640.5, 1501, 1284.5, 997], [0, 49, 815, 1013, 1537, 289],
                [0, 49, 291, 1751, 1751, 1701, 1654.1, 1513.5, 1296.6, 1021], [-53, 187, 375, 615, 615, 379, 183, -53], [26, 1374, 832, 568],
                [200, 728, 983.5, 1168, 1281, 1323, 1196, 1159, 1040, 885, 641, 200], [200, 398, 1162, 1162, 200], [26, 1414, 852, 588], [200, 1181, 1181, 200],
                [126, 1288, 1288, 1266, 160, 126], [200, 1339, 1339, 200], [115, 163.5, 302, 520.5, 806, 1092.5, 1310, 1448.5, 1498, 1449.5, 1310, 1093.5, 806, 521.5, 303, 163],
                [137, 725, 725, 137], [205, 1397, 1366, 205], [26, 1378, 822, 582], [200, 1526, 1526, 200], [200, 1336, 1336, 200], [114, 1215, 1215, 114],
                [115, 163.5, 302, 520.5, 806, 1092.5, 1310, 1448.5, 1498, 1449.5, 1310, 1093.5, 806, 521.5, 303, 163], [200, 1339, 1339, 200],
                [200, 398, 1043, 1139.5, 1174, 1127.5, 996, 831, 604, 200], [118, 1280, 1280, 1234, 138, 118], [0, 532, 730, 1262, 1262, 0], [6, 532, 730, 1254, 225],
                [105, 149.5, 273, 740, 937, 1404, 1527.5, 1572, 1528.5, 1410, 937, 740, 267, 148], [68, 1335, 1336, 80], [179, 219.5, 338, 793, 990, 1446, 1563.5, 1604, 1604, 179],
                [108, 1568, 1568, 1518, 1471.1, 1330.5, 1113.6, 838, 562.4, 345.5, 204.9, 158, 108], [126, 137, 725, 738, 738, 126], [6, 532, 730, 1254, 939, 740, 327],
                [108, 137.4, 225.5, 363.6, 543, 1091, 1091, 743, 500, 148.5], [109, 152.5, 265, 417, 578, 796, 1006, 1006, 961, 721, 478, 191.5, 144],
                [185, 931, 1119, 1119, 1095.3, 802, 559, 185], [160, 187, 375, 403], [177, 207.8, 300, 448, 646, 846, 994, 1085.5, 1116, 1116, 1043, 760, 534, 251, 177],
                [108, 137.4, 225.5, 363.6, 543, 1091, 1091, 604, 416.5, 258, 148.5], [185, 373, 1030.5, 1131.4, 1165, 1084, 1050, 959, 825.5, 661, 462.1, 311.5, 216.6, 185],
                [61, 506, 694, 1151, 265], [106, 140.6, 244.5, 408.6, 624, 837.1, 1000.5, 1104.4, 1139, 1049, 239],
                [109, 152.5, 265, 417, 578, 796, 1006, 1006, 961, 789, 609, 449, 304, 191.5, 144], [108, 135.8, 219, 646, 825, 937, 982, 942, 198],
                [185, 931, 1119, 1119, 1095.3, 1024, 907.5, 748, 185], [137, 159.5, 219, 382, 639, 896, 1059, 1118, 1141, 1118, 1058, 895.5, 639, 382.5, 220, 159.5], [187, 375, 375, 187],
                [193, 1192, 1122, 1085, 1027, 193], [61, 1151, 522, 311], [185, 373, 1125, 1125, 185], [61, 510, 699, 1151, 265], [104, 138.5, 239, 704, 884, 995.5, 1041, 957, 133],
                [106, 140.9, 245.5, 409.4, 622, 833.3, 997, 1102, 1137, 1102, 997, 833.3, 622, 409.4, 245.5, 140.9], [185, 1120, 1120, 185],
                [185, 373, 1033.5, 1137.4, 1172, 1140, 1044, 887.3, 673, 477.5, 322, 220.5, 185], [105, 146.5, 261, 685, 862, 971, 1018, 986, 839, 675, 441.9, 260.5, 143.9],
                [106, 140.5, 244, 407.8, 623, 832.9, 996.5, 1101.9, 1295, 1295, 625, 412, 247, 141.3], [10, 414, 602, 1006, 1006, 10],
                [177, 207.8, 300, 448, 646, 846, 994, 1085.5, 1116, 1116, 177], [104, 151, 283, 715, 902, 1342.5, 1471.1, 1514, 1470.4, 1339.5, 1132.6, 861, 784.5, 714, 355, 163],
                [48, 1160, 1149, 59], [176, 223.5, 748, 935, 1459, 1507, 1507, 176], [113, 136.5, 211, 343.5, 538, 1128, 1321.5, 1455, 1529.5, 1553, 1496, 1295, 371, 170],
                [5, 187, 375, 557, 557, 5], [177, 207.8, 300, 448, 646, 846, 994, 1085.5, 1116, 1116, 953, 341, 177],
                [106, 140.9, 245.5, 409.4, 622, 833.3, 997, 1102, 1137, 1102, 743, 500, 140.9], [177, 207.8, 300, 448, 646, 846, 994, 1085.5, 1116, 1116, 768, 525, 177],
                [113, 136.5, 211, 343.5, 538, 1128, 1321.5, 1455, 1529.5, 1553, 1496, 955, 712, 170],
                [149, 179.4, 270.5, 409.6, 584, 798.5, 985, 1106, 1145, 1130.5, 1074, 909.5, 670, 473.5, 292], [50, 1438, 876, 612], [144, 344, 1332, 1532, 1532, 144],
                [187, 1369, 1369, 1330, 197, 187], [220, 1456, 1456, 220], [-102, 63, 843, 678], [253, 492, 492, 253], [134, 755, 857, 1737, 1570, 134],
                [161, 189.3, 274, 406.5, 578, 1435, 1620.9, 1764.5, 1856.4, 1887, 1858.8, 1774, 1641.5, 1470, 613, 430.3, 286, 192.3],
                [138, 241.5, 348, 515.3, 641, 719, 1168, 1168, 1063, 954, 786.3, 661, 583, 138], [243, 400, 1070, 1214, 1320, 1432, 1431, 1274, 604, 462.4, 355.5, 243],
                [245, 566, 719, 1431, 1431, 1109, 956, 245], [254, 1408, 1408, 254], [268, 1422, 1422, 268]
            ];
            this.OUTLINE_Y = [
                [], [1489, 0, 0, 1489], [1556, 977, 977, 1556, 1556], [421, 0, 0, 421, 932, 1067, 1489, 1489, 1067, 556],
                [85, -361, -361, 238.1, 380, 1231, 1576, 1576, 1185, 1071.5, 935, 283], [1075, 880.5, 743, 0, -29, -1.8, 80, 217.8, 413, 607.5, 745, 1489, 1517, 1489.8, 1408, 1270.3],
                [409, 230.9, 90.5, -0.6, -31, 0, 909, 1333.4, 1432.5, 1498.1, 1520, 1490, 1412, 1301.5, 1174], [1556, 977, 977, 1556], [572, 286.3, 31, -412, -412, 1556, 1556, 1113, 857.8],
                [-412, -412, 31, 286.3, 572, 857.8, 1113, 1556, 1556], [886, 776, 630, 630, 777, 887, 1299, 1409, 1556, 1556, 1410, 1300], [572, 27, 27, 572, 732, 1277, 1277, 732],
                [-370, -370, 285, 285], [561, 561, 742, 742], [0, 0, 285, 285], [-304, -304, 1556, 1556],
                [743, 400, 159, 16.5, -31, 15.9, 156.5, 397.4, 745, 1084.9, 1326.5, 1470.9, 1519, 1471.6, 1329.5, 1088.1], [0, 0, 152, 1494, 1494, 1286],
                [0, 0, 171, 1110, 1279.4, 1409.5, 1492.4, 1520, 1491, 1427, 209], [63, -1.5, -31, 2.5, 106, 254, 441, 1161, 1320, 1436, 1500, 1520, 1490.5, 1426, 272],
                [419, 0, 0, 419, 579, 1489, 1489, 649], [56, -5.5, -31, 6.5, 114, 274, 473, 1489, 1489, 267],
                [654, 324, 104, 3, -31, 4.9, 112.5, 276.9, 483, 1494, 1512, 1517, 1453.5, 1277, 1005], [1314, 0, 0, 1266, 1489, 1489],
                [411, 233.5, 91, -2.8, -34, -2, 94, 238.3, 415, 1144, 1294.5, 1416, 1496.3, 1523, 1495, 1411, 1285, 1131],
                [1005, -6, -23.5, -29, 33, 209, 480, 834, 1171.5, 1385, 1485.5, 1519, 1483.3, 1376, 1211.8], [0, 0, 1117, 1117], [-370, -370, 285, 1117, 1117], [590, 77, 1227, 714],
                [362, 362, 942, 942], [77, 590, 714, 1227], [1245, 0, 0, 964.5, 1139, 1293.4, 1414.5, 1492.9, 1519, 1497.5, 1449],
                [647, 291, 15, -162.5, -226, -218.5, -190, 157, 394, 663, 1013.5, 1283, 1457, 1519, 1452, 1268, 991.5], [0, 0, 1489, 1489],
                [0, 0, 28, 122, 262, 458, 1155, 1316.5, 1427, 1477, 1489, 1489], [743, 402.5, 161, 18.5, -27, -13.5, 19, 63, 108, 1385, 1487, 1516, 1465, 1317, 1072],
                [0, 0, 28, 119, 375, 743, 1118, 1371, 1457.5, 1489, 1489], [0, 0, 1489, 1489], [0, 0, 717, 1313, 1489, 1489],
                [746, 405.5, 163, 19, -29, 12.5, 110, 749, 1382, 1485.5, 1516, 1464.4, 1309.5, 1065.4], [0, 0, 1489, 1489], [0, 0, 1489, 1489],
                [8, -12.5, -21, 5.5, 85, 213.5, 387, 1489, 1489, 193], [0, 0, 1489, 1489], [0, 0, 176, 1489, 1489], [0, 0, 1489, 1489], [0, 0, 1489, 1489],
                [744, 415, 172, 21, -31, 20, 172, 414.5, 744, 1073, 1318, 1467.5, 1520, 1468, 1318, 1070.5], [0, 0, 709, 855.5, 1039, 1254, 1396, 1466.5, 1489, 1489],
                [744, 415, 172, 21, -297.5, -369.1, -393, -386.5, -365, -183, 744, 1073, 1318, 1467.5, 1520, 1468, 1318, 1070.5], [0, 0, 1280.5, 1409, 1471.5, 1489, 1489],
                [92, 3, -27, 9, 109, 253, 425, 1412, 1486, 1516, 1486.1, 1396.5, 1260.1, 1090, 340], [1313, 0, 0, 1313, 1489, 1489], [598, 313, 115, 6, -31, 4, 115, 315.5, 598, 1489, 1489],
                [1489, 0, 0, 1489, 1489], [1489, 0, 0, 1489, 1489], [0, 0, 1489, 1489], [1489, 0, 0, 1489, 1489], [0, 0, 176, 1489, 1489, 184], [-392, -392, 1556, 1556],
                [1556, -304, -304, 1556], [-392, -392, 1556, 1556], [682, 682, 684, 1489, 1489], [-300, -300, -180, -180], [1676, 1302, 1302, 1676],
                [324, 182.8, 69, -6, -31, 0, 758, 939, 1058, 1124.5, 1144, 1126, 1093], [0, -31, 8.5, 127, 315, 567, 812.8, 996, 1110, 1556, 1556],
                [557, 300, 118, 10.5, -25, 0, 70, 1050, 1116, 1143, 1104, 987, 801.5], [550, 306.8, 123, 7.5, -31, 0, 1556, 1556, 992, 803],
                [552, 306.6, 124.5, 11.6, -26, 1, 68, 539, 641, 856.3, 1016, 1115, 1148, 1107.8, 987, 797.8], [959, 0, 0, 959, 1374, 1546, 1560, 1566, 1539.4, 1459.5, 1117],
                [569, -375, -410.5, -423, -389.8, -290, -119.3, 127, 1117, 1148, 1108.5, 998, 817.5], [0, 0, 725, 906, 1039, 1556, 1556], [1304, 0, 0, 1304, 1499, 1499],
                [-395, -415, -423, -398, -323, -199, -27, 1304, 1499, 1499, 1117, -216], [0, 0, 1117, 1556, 1556], [0, 0, 1556, 1556], [0, 0, 725, 902.9, 1036.5, 1120.1, 1148, 1148, 1117],
                [0, 0, 725, 906, 1039, 1120.8, 1148, 1117], [558, 313.8, 127, 8.5, -31, 8.5, 127, 313.8, 558, 802.4, 989.5, 1108.4, 1148, 1108.4, 989.5, 802.4],
                [-412, -412, 133, 323.5, 572, 813.4, 995.5, 1109.9, 1148, 1117], [555, 314.1, 131.5, 16.4, -412, -412, 1117, 1148, 1108, 995, 809.5], [0, 0, 912, 1105, 1114.5, 1117, 1117],
                [67, 2.5, -27, -2.5, 71, 182.8, 322, 1060, 1119.5, 1144, 1116.5, 1042, 933, 803, 278], [959, 189.8, 70, 1, -22, -13, 10, 1117, 1438, 1438, 1117],
                [392, 209.1, 76.5, -4.1, -31, 0, 1117, 1117], [1117, 0, 0, 1117, 1117], [1117, 0, 0, 1117, 1117], [0, 0, 1117, 1117], [1117, -412, -412, 1117, 1117],
                [0, 0, 159, 1117, 1117, 139], [504, -170.9, -292.5, -367.1, -392, -392, 1556, 1556, 1531.1, 1456.5, 1334.9, 660], [-392, -392, 1556, 1556],
                [-392, -392, -367.1, -292.5, -170.9, 504, 660, 1334.9, 1456.5, 1531.1, 1556, 1556], [395, 395, 396, 440, 561, 732, 927, 927, 926, 880.5, 761, 589.5], [], [0, 0, 1489, 1489],
                [557, 333.5, 163, -361, -361, 74, 1046, 1475, 1475, 948.5, 775.9], [0, 0, 171, 1467, 1501, 1518, 1485.9, 1389.5, 1243.1, 751, 207],
                [258, 145, 147, 257, 1067, 1176, 1176, 1066], [1489, 426, 0, 0, 426, 1489, 1489], [-392, -392, 1556, 1556],
                [533, -327, -371.5, -385, -358, -275, -156, -10, 601, 1462, 1505, 1519, 1490, 1411, 1293.5, 1147], [1304, 1304, 1499, 1499],
                [655, 323.1, 43.5, -146.6, -210, -146.6, 43.5, 323.1, 655, 986.9, 1266.5, 1456.6, 1520, 1456.6, 1266.5, 986.9],
                [833, 616, 531, 554, 1192, 1332.4, 1435.5, 1498.9, 1520, 1504, 1475], [608, 162, 191, 1113, 1142, 697], [602, 57, 57, 762, 762], [561, 561, 742, 742],
                [655, 323.1, 43.5, -146.6, -210, -146.6, 43.5, 323.1, 655, 986.9, 1266.5, 1456.6, 1520, 1456.6, 1266.5, 986.9], [1788, 1668, 1668, 1788],
                [1116, 960.4, 831.5, 744.9, 716, 745, 832, 961, 1116, 1271, 1400, 1487, 1516, 1487, 1400, 1271], [179, 179, 917, 1462, 1462, 917],
                [566, 566, 711, 1237, 1350.4, 1440.5, 1519, 1501.5, 1458, 722], [585, 542, 527, 543.5, 595, 685.5, 817, 1278, 1374.5, 1452, 1520, 1502.5, 1458, 764],
                [1302, 1302, 1676, 1676], [-412, -412, 0, 1117, 1117], [1050, 866, -363, -363, 1489, 1489, 1460, 1373, 1234.3], [511, 511, 794, 794],
                [-397, -416, -423, -337, -232, -89, -25, 20, 20, -237], [1256, 566, 566, 688, 1493, 1493, 1368],
                [1025, 820.1, 663.5, 564.1, 531, 563.4, 660.5, 816.4, 1025, 1233.8, 1390, 1487.5, 1520, 1486.8, 1387, 1230], [191, 162, 608, 697, 1142, 1113],
                [1246, 0, 0, 220, 353, 944, 1489, 1493, 1493, 1363], [1246, 0, 0, 139, 664, 865, 1489, 1493, 1493, 1363], [598, 0, 0, 220, 353, 944, 1489, 1517, 1500, 1456, 773],
                [350, 195.6, 74.5, -3.9, -30, -10, 40, 244, 1489, 1489, 523], [0, 0, 1675, 2049, 2049], [0, 0, 2049, 2049, 1675], [0, 0, 1670, 2049, 2049, 1670],
                [0, 0, 1992, 1992, 1987, 1910, 1682], [0, 0, 1872, 1872, 1872], [0, 0, 1712, 1843.5, 1952, 2024.8, 2049, 2024.8, 1952, 1843.5, 1712], [0, 0, 1489, 1489],
                [743, 402.5, -397, -416, -423, -337, 108, 1385, 1487, 1516, 1465, 1317, 1072], [0, 0, 1489, 2049, 2049, 1489], [0, 0, 1489, 2049, 2049, 1489], [0, 0, 1489, 2049, 2049, 1489],
                [0, 0, 1489, 1872, 1872, 1489], [0, 0, 1489, 2049, 2049, 1489], [0, 0, 2049, 2049, 1489], [1670, 0, 0, 1670, 2049, 2049], [1677, 0, 0, 1677, 1872, 1872],
                [740, 0, 0, 28, 119, 375, 743, 1118, 1371, 1457.5, 1489, 1489, 883], [0, 0, 1489, 1992, 1992, 1987, 1910, 1489],
                [744, 415, 172, 21, -31, 20, 172, 414.5, 744, 1073, 1318, 2049, 2049, 1070.5], [744, 415, 172, 21, -31, 20, 172, 414.5, 744, 1073, 2049, 2049, 1318, 1070.5],
                [744, 415, 172, 21, -31, 20, 172, 414.5, 744, 1073, 1670, 2049, 2049, 1670, 1070.5], [744, 415, 172, 21, -31, 20, 172, 414.5, 744, 1073, 1992, 1992, 1987, 1910, 1070.5],
                [744, 415, 172, 21, -31, 20, 172, 414.5, 744, 1073, 1872, 1872, 1872, 1070.5], [216, 105, 105, 216, 1088, 1199, 1199, 1088],
                [744, -146, -146, 20, 172, 414.5, 744, 1611, 1611, 1520, 1468, 1318, 1070.5], [598, 313, 115, 6, -31, 4, 115, 315.5, 598, 1489, 2049, 2049, 1489],
                [598, 313, 115, 6, -31, 4, 115, 315.5, 598, 1489, 2049, 2049, 1489], [598, 313, 115, 6, -31, 4, 115, 315.5, 598, 1489, 2049, 2049, 1489],
                [598, 313, 115, 6, -31, 4, 115, 315.5, 598, 1489, 1872, 1872, 1489], [1489, 0, 0, 1489, 2049, 2049], [0, 0, 469, 610.5, 787, 992, 1130, 1489, 1489],
                [0, -24, 12.4, 121.5, 284.1, 481, 1241, 1376, 1479, 1544.3, 1566, 1536.5, 1449, 1295.5, 1080], [324, 182.8, 69, -6, -31, 0, 758, 939, 1676, 1676, 1093],
                [324, 182.8, 69, -6, -31, 0, 758, 1676, 1676, 1093], [324, 182.8, 69, -6, -31, 0, 758, 1297, 1676, 1676, 1297, 1093],
                [324, 182.8, 69, -6, -31, 0, 758, 1619, 1619, 1614, 1537, 1309], [324, 182.8, 69, -6, -31, 0, 758, 1499, 1499, 1093],
                [324, 182.8, 69, -6, -31, 0, 758, 1630, 1761.8, 1871, 1944.5, 1969, 1944.5, 1871, 1761.8, 1630],
                [317, 178.8, 68, -4.8, -29, -26, 3.5, 68, 559, 641, 861.3, 1020, 1116, 1148, 1146, 1127, 1093], [557, 300, -397, -416, -423, -337, -232, 70, 1050, 1116, 1143, 1104, 987, 801.5],
                [552, 306.6, 124.5, 11.6, -26, 1, 68, 539, 641, 856.3, 1016, 1676, 1676, 797.8], [552, 306.6, 124.5, 11.6, -26, 1, 68, 539, 641, 856.3, 1676, 1676, 987, 797.8],
                [552, 306.6, 124.5, 11.6, -26, 1, 68, 539, 641, 856.3, 1297, 1676, 1676, 1297, 797.8], [552, 306.6, 124.5, 11.6, -26, 1, 68, 539, 641, 856.3, 1499, 1499, 797.8],
                [1676, 0, 0, 1302, 1676], [1302, 0, 0, 1676, 1676], [1297, 0, 0, 1297, 1676, 1676], [1304, 0, 0, 1304, 1499, 1499],
                [484, 266.5, 104, 2.8, -31, 12, 141, 351, 637, 1469, 1566, 1556], [0, 0, 725, 1619, 1619, 1614, 1537, 1309, 1117],
                [558, 313.8, 127, 8.5, -31, 8.5, 127, 313.8, 558, 802.4, 989.5, 1676, 1676, 802.4], [558, 313.8, 127, 8.5, -31, 8.5, 127, 313.8, 558, 802.4, 1676, 1676, 989.5, 802.4],
                [558, 313.8, 127, 8.5, -31, 8.5, 127, 313.8, 558, 802.4, 1297, 1676, 1676, 1297, 802.4], [558, 313.8, 127, 8.5, -31, 8.5, 127, 313.8, 558, 1619, 1619, 1614, 1537, 1309],
                [558, 313.8, 127, 8.5, -31, 8.5, 127, 313.8, 558, 802.4, 1499, 1499, 1499, 802.4], [572, 7, 7, 572, 732, 1297, 1297, 732],
                [-148, -148, 8.5, 127, 313.8, 558, 1241, 1241, 1108.4, 989.5, 802.4, 558], [392, 209.1, 76.5, -4.1, -31, 0, 1117, 1676, 1676, 1117],
                [392, 209.1, 76.5, -4.1, -31, 0, 1117, 1676, 1676, 1117], [392, 209.1, 76.5, -4.1, -31, 0, 1117, 1676, 1676, 1117], [392, 209.1, 76.5, -4.1, -31, 0, 1117, 1499, 1499, 1117],
                [1117, -412, -412, 1117, 1676, 1676], [-412, -412, 133, 323.5, 572, 813.4, 995.5, 1109.9, 1556, 1556], [-370, -370, 285, 1117, 1117], [1676, 1292, 1292, 1676],
                [1304, 1292, 1292, 1304, 1499, 1676, 1676, 1499], [1489, 0, 0, 1489], [832, 832, 1117, 1117], [1489, 1105, 0, 0, 1489, 1489], [1489, 1105, 0, 0, 1489, 1489],
                [1489, 1105, 0, 0, 1489, 1489], [1489, 1105, 415, 172, 21, -31, 20, 172, 414.5, 744, 1073, 1318, 1467.5, 1520], [1489, 1105, 0, 0, 1489, 1489],
                [1489, 1105, 0, 0, 174, 894, 1144.8, 1345, 1476.3, 1520], [1304, 0, 0, 1304, 1499, 1676, 1676, 1499], [0, 0, 1489, 1489],
                [0, 0, 28, 122, 262, 458, 1155, 1316.5, 1427, 1477, 1489, 1489], [0, 0, 1313, 1489, 1489], [0, 0, 1489, 1489], [0, 0, 1489, 1489], [0, 0, 176, 1489, 1489, 184],
                [0, 0, 1489, 1489], [744, 415, 172, 21, -31, 20, 172, 414.5, 744, 1073, 1318, 1467.5, 1520, 1468, 1318, 1070.5], [0, 0, 1489, 1489], [0, 0, 1489, 1489], [0, 0, 1489, 1489],
                [0, 0, 1489, 1489], [0, 0, 1489, 1489], [0, 0, 1489, 1489], [744, 415, 172, 21, -31, 20, 172, 414.5, 744, 1073, 1318, 1467.5, 1520, 1468, 1318, 1070.5], [0, 0, 1489, 1489],
                [0, 0, 709, 855.5, 1039, 1254, 1396, 1466.5, 1489, 1489], [0, 0, 176, 1489, 1489, 184], [1313, 0, 0, 1313, 1489, 1489], [1489, 0, 0, 1489, 1489],
                [755, 507, 325, -16, -16, 325, 506.5, 755, 994, 1171, 1505, 1505, 1171, 993], [0, 0, 1489, 1489], [910, 647, 471, 0, 0, 471, 645.5, 910, 1489, 1489],
                [0, 0, 174, 894, 1144.8, 1345, 1476.3, 1520, 1476.3, 1345, 1144.8, 894, 174], [1677, 0, 0, 1677, 1872, 1872], [1489, 0, 0, 1489, 1872, 1872, 1872],
                [550, 306.8, 123, 7.5, -31, 0, 1117, 1676, 1676, 803], [306, 148.5, 46, -10, -26, -5, 64, 270, 1083, 1676, 1676, 986.5, 839], [0, -412, -412, 725, 906, 1676, 1676, 1117],
                [1676, 0, 0, 1676], [407, 213.6, 77.5, -3.1, -30, -2.6, 79.5, 216.1, 407, 1117, 1499, 1676, 1676, 1499, 1117], [550, 306.8, 123, 7.5, -31, 0, 1117, 1148, 1108, 992, 803],
                [-412, -412, 110, 259.5, 444, 1195, 1355, 1467, 1534.5, 1556, 1524.3, 1429, 1277.8, 1078], [1117, -412, -412, 1117, 1117],
                [534, 299.6, 120.5, 6.9, -31, 7.8, 124, 308.3, 551, 1556, 1556], [306, 148.5, 46, -10, -26, -5, 64, 270, 1083, 1127.5, 1144, 1128, 1079, 986.5, 839],
                [463, 262.3, 118, -412, -412, -264.5, -96, 1556, 1556], [0, -412, -412, 725, 906, 1039, 1120.8, 1148, 1117],
                [768, 451.5, 241, 37.5, -31, 37.5, 241, 451.5, 768, 1073, 1288, 1487, 1556, 1487, 1288, 1073.5], [0, 0, 1117, 1117], [0, 0, 1117, 1118, 1119, 1117], [0, 0, 1556, 1556],
                [-412, -412, 0, 1117, 1117], [1117, 0, 0, 1117, 1117], [412, 248.5, 113, -412, -412, -265, -96, 1556, 1556],
                [558, 313.8, 127, 8.5, -31, 8.5, 127, 313.8, 558, 802.4, 989.5, 1108.4, 1148, 1108.4, 989.5, 802.4], [0, 0, 1117, 1117],
                [-412, -412, 148.5, 340.9, 577, 821.5, 1001, 1111.3, 1148, 1115, 1020, 861.5, 646], [549, 299, 129, -412, -412, -268, -96, 1079, 1124.5, 1143, 1102.5, 981, 792],
                [558, 313.8, 127, 8.5, -31, 7.5, 123, 308.8, 952, 1117, 1148, 1108.6, 990.5, 803.6], [952, 0, 0, 952, 1117, 1117],
                [407, 213.6, 77.5, -3.1, -30, -2.6, 79.5, 216.1, 407, 1117, 1117], [546, 314, 142, -412, -412, 159, 342.3, 576, 816.6, 996.5, 1108.6, 1146, 1145.5, 1143, 1117, 842],
                [-412, -412, 1117, 1117], [446, 248.5, -412, -412, 248, 446, 1117, 1117], [503, 310.5, 139, 16.5, -30, -30, 14.5, 139, 310.5, 503, 811.5, 1117, 1117, 811.5],
                [1304, 0, 0, 1304, 1499, 1499], [407, 213.6, 77.5, -3.1, -30, -2.6, 79.5, 216.1, 407, 1117, 1499, 1499, 1117],
                [558, 313.8, 127, 8.5, -31, 8.5, 127, 313.8, 558, 802.4, 1676, 1676, 802.4], [407, 213.6, 77.5, -3.1, -30, -2.6, 79.5, 216.1, 407, 1117, 1676, 1676, 1117],
                [503, 310.5, 139, 16.5, -30, -30, 14.5, 139, 310.5, 503, 811.5, 1676, 1676, 811.5], [424, 240.1, 94.5, -0.4, -32, 17, 190, 493, 837, 1097, 1286, 1464.5, 1519, 1496.5, 1430],
                [0, 0, 1489, 1489], [1315, -193, -193, 1315, 1489, 1489], [-189, -189, -13, 1489, 1489, 2], [572, 572, 732, 732], [0, 0, 1489, 1489], [511, 511, 794, 794],
                [842, -151, -151, 1788, 1788, 981], [642, 447.6, 292.5, 190.9, 157, 157, 190.4, 290.5, 450.4, 663, 857.4, 1012.5, 1114.1, 1148, 1148, 1114.5, 1014, 854],
                [-402, -417.5, -423, -395.5, -313, -179.8, 1367, 1545, 1560.5, 1566, 1538.5, 1456, 1321.8, -224], [202, 202, 209, 233.4, 306.5, 588, 1104, 1104, 1097, 1072.5, 999, 719],
                [362, 27, 27, 362, 942, 1277, 1277, 942], [0, 0, 1393, 910], [0, 0, 910, 1393]
            ];
            this.KERN_C1 = [
                '\'', '\'', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '.', '.', 'A', 'A', 'A', 'A', 'A', 'A', 'A',
                'A', 'A', 'A', 'A', 'A', 'B', 'B', 'B', 'B', 'C', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F',
                'I', 'J', 'J', 'J', 'J', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',
                'L', 'O', 'O', 'O', 'O', 'O', 'O', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'Q', 'Q', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'S',
                'S', 'S', 'S', 'S', 'S', 'S', 'S', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T',
                'T', 'T', 'T', 'T', 'T', 'T', 'U', 'U', 'U', 'U', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'W', 'W', 'W', 'W', 'W', 'W',
                'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y',
                'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z',
                'a', 'a', 'a', 'b', 'b', 'b', 'c', 'c', 'e', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'h', 'h', 'h', 'k', 'k', 'k', 'k', 'm', 'm',
                'm', 'n', 'n', 'n', 'o', 'o', 'o', 'o', 'o', 'p', 'p', 'p', 'r', 'r', 'r', 'r', 'r', 't', 't', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'w', 'w', 'w',
                'w', 'w', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'y', 'y', 'y', 'y', 'y', 'y', 'y', 'y', 'y', 'y', 'y', 'y', 'y', 'z', 'z', 'z', 'z', 'z', 'z', 'z',
                'z', 'z', '\u00C7', '\u00E7', '\u00D8', '\u00D8', '\u00D8', '\u00D8', '\u00D8', '\u00D8', '\u00F8', '\u00F8', '\u00F8', '\u00F8', '\u00F8'
            ];
            this.KERN_C2 = [
                '\u00C6', 'A', '\u00E6', '\u00C6', 'z', 'y', 'x', 'w', 'v', 'a', 'Z', 'Y', 'X', 'W', 'V', 'T', 'S', 'J', 'I', 'A', '-', ',', 'y', 'w', 'v', 'u', 't',
                'Y', 'W', 'V', 'U', 'T', 'S', '-', 'T', '.', '-', ',', '-', 'Z', 'Y', 'X', 'W', 'T', '.', ',', '\u00F8', '\u00E6', '\u00C6', 'o', 'e', 'a', 'T', 'A',
                '?', ';', ':', '.', ',', '-', '\u00C6', 'A', '.', ',', '\u00F8', '\u00E6', '\u00D8', 'y', 'w', 'v', 'u', 'o', 'e', 'a', 'O', '-', '\u00D8', '\u00C7',
                'y', 'v', 'Y', 'W', 'V', 'T', 'O', 'J', 'G', 'C', '-', '\'', 'Z', 'Y', 'X', 'T', '.', ',', '\u00F8', '\u00E6', '\u00C6', 'o', 'e', 'a', 'Y', 'A',
                '.', ',', '.', ',', '\u00F8', '\u00E6', 'y', 'u', 'o', 'e', 'a', 'Y', 'T', '-', '\u00C6', 'y', 'w', 'v', 'S', 'A', '.', ',', '\u00F8', '\u00E6',
                '\u00D8', '\u00C6', '\u00C7', 'z', 'y', 'w', 'v', 'u', 's', 'r', 'o', 'g', 'e', 'c', 'a', 'T', 'S', 'O', 'G', 'C', 'A', '?', ';', ':', '.', '-', ',',
                '\u00C6', 'A', '.', ',', '\u00F8', '\u00E6', '\u00C6', 'y', 'u', 'o', 'e', 'a', 'A', ';', ':', '.', '-', ',', '\u00F8', '\u00E6', '\u00C6', 'y', 'u',
                'r', 'o', 'e', 'a', 'A', ';', ':', '.', '-', ',', '\u00F8', '\u00E6', '\u00D8', '\u00C7', 'y', 'u', 'o', 'e', 'a', 'O', 'G', 'C', '-', '\u00F8',
                '\u00E6', '\u00D8', '\u00C6', 'v', 'u', 's', 'r', 'q', 'p', 'o', 'n', 'm', 'g', 'e', 'd', 'a', 'O', 'A', ';', ':', '.', '-', ',', '\u00F8', '\u00E6',
                '\u00D8', '\u00C7', 'y', 'w', 'o', 'e', 'a', 'Z', 'O', 'G', 'C', '-', 'y', 'w', 'v', 'y', '.', ',', 'T', '-', 'T', '}', 'y', ']', '\\', '?', '.',
                '-', ',', '*', ')', '\'', '"', 'y', 'w', 'v', '\u00F8', 'o', 'e', '-', 'y', 'w', 'v', 'y', 'w', 'v', 'y', 'x', 'v', '.', ',', 'y', '.', ',',
                '\u00E6', 'a', '.', '-', ',', 'y', '-', '\u00F8', '\u00E6', 'o', 'e', 'a', '.', '-', ',', '\u00E6', 'a', '.', '-', ',', '\u00F8', '\u00E7', 'o', 'g',
                'e', 'd', 'c', '-', '\u00F8', '\u00E6', '\u00E7', 'q', 'o', 'g', 'e', 'd', 'c', 'a', '.', '-', ',', '\u00F8', '\u00E7', 'q', 'o', 'g', 'e', 'd', 'c',
                '-', '-', '-', 'Z', 'Y', 'X', 'T', '.', ',', 'y', 'x', 'v', '.', ','
            ];
            this.KERN_K = [
                100, 100, 20, 50, 40, 40, 50, 20, 40, 20, 30, 140, 80, 50, 50, 150, 20, 100, 30, 50, 160, 130, 50, 30, 50, 10, 20, 80, 50, 60, 10, 120, 10, 50, 60,
                20, -10, 20, 50, 20, 20, 10, 20, 50, 50, 50, 50, 100, 110, 50, 50, 100, -30, 100, -60, 60, 60, 300, 300, 30, 10, 10, 20, 20, 70, 60, 20, 80, 70, 80,
                50, 70, 70, 60, 20, 110, 20, 20, 110, 110, 160, 100, 110, 170, 20, -100, 20, 20, 160, 120, 20, 20, 10, 50, 30, 30, 50, 50, 70, 50, 50, 50, -20, 50,
                300, 300, 30, 30, 50, 50, 55, 20, 50, 50, 40, 20, 60, 100, 20, 30, 20, 30, 22, 20, 20, 20, 220, 240, 50, 130, 40, 170, 200, 200, 200, 200, 180, 200,
                220, 210, 220, 220, 240, 70, 12, 50, 40, 40, 120, -60, 200, 200, 290, 150, 290, 20, 10, 20, 20, 100, 100, 70, 65, 60, 100, 100, 100, 60, 80, 80, 290,
                50, 290, 100, 100, 60, 65, 60, 60, 100, 100, 100, 50, 80, 80, 220, 50, 290, 60, 50, 10, 10, 80, 30, 60, 60, 50, 10, 10, 10, 80, 130, 140, 20, 80,
                100, 110, 110, 100, 130, 100, 130, 100, 100, 130, 130, 120, 140, 20, 80, 200, 200, 290, 140, 290, 60, 50, 20, 20, 65, 40, 60, 60, 50, 10, 20, 20, 20,
                60, 16, 10, 16, 5, 20, 30, 60, 20, 140, -100, 10, -100, -100, -110, 120, 50, 130, -50, -100, -60, -60, 20, 10, 20, 20, 20, 20, 100, 20, 10, 20, 20,
                10, 20, 15, 20, 15, 20, 30, 5, 20, 30, 40, 36, 290, 20, 290, 10, 40, 18, 40, 18, 18, 40, 180, 40, 180, 20, 20, 70, 20, 70, 24, 20, 24, 10, 24, 10,
                20, 50, 18, 40, 18, 10, 18, 10, 18, 10, 18, 40, 190, 40, 190, 12, 10, 10, 12, 10, 12, 10, 10, 20, 50, 20, 20, 20, 10, 50, 30, 30, 15, 20, 15, 20, 30
            ];
            this.pathCache = [];
            this.pathMissing = null;
            this.ctxReference = null;
            for (let n = this.GLYPH_DATA.length - 1; n >= 0; n--)
                this.pathCache[n] = null;
        }
        getKerning(ch1, ch2) {
            const sz = this.KERN_K.length;
            for (let n = 0; n < sz; n++)
                if (this.KERN_C1[n] == ch1 && this.KERN_C2[n] == ch2)
                    return -this.KERN_K[n];
            return 0;
        }
        static measureText(txt, size) { return this.main.measureText(txt, size); }
        measureText(txt, size) {
            let font = FontData.main;
            let scale = size / font.UNITS_PER_EM;
            let dx = 0;
            for (let n = 0; n < txt.length; n++) {
                let ch = txt.charAt(n);
                let i = this.getIndex(ch);
                if (i < 0) {
                    dx += font.MISSING_HORZ;
                    continue;
                }
                dx += font.HORIZ_ADV_X[i];
                if (n < txt.length - 1)
                    dx += font.getKerning(ch, txt.charAt(n + 1));
            }
            return [dx * scale, font.ASCENT * scale * font.ASCENT_FUDGE, -font.DESCENT * scale];
        }
        static measureWidths(txt, size) { return this.main.measureWidths(txt, size); }
        measureWidths(txt, size) {
            let font = FontData.main;
            let scale = size / font.UNITS_PER_EM;
            let xpos = [0];
            let dx = 0;
            for (let n = 0; n < txt.length; n++) {
                let ch = txt.charAt(n);
                let i = this.getIndex(ch);
                if (i < 0) {
                    dx += font.MISSING_HORZ;
                    xpos.push(dx * scale);
                    continue;
                }
                dx += font.HORIZ_ADV_X[i];
                if (n < txt.length - 1)
                    dx += font.getKerning(ch, txt.charAt(n + 1));
                xpos.push(dx * scale);
            }
            return xpos;
        }
        getIndex(ch) {
            return this.UNICODE.indexOf(ch);
        }
        getRawGlyph(idx) {
            return this.GLYPH_DATA[idx];
        }
        getGlyphPath(idx) {
            let path = this.pathCache[idx];
            if (path != null)
                return path;
            path = new Path2D(this.GLYPH_DATA[idx]);
            this.pathCache[idx] = path;
            return path;
        }
        getMissingPath() {
            if (!this.pathMissing)
                this.pathMissing = new Path2D(this.MISSING_DATA);
            return this.pathMissing;
        }
        getOutlineX(idx) { return this.OUTLINE_X[idx].slice(0); }
        getOutlineY(idx) { return this.OUTLINE_Y[idx].slice(0); }
        initNativeFont(ctx) {
            if (ctx == null && this.ctxReference)
                return;
            if (ctx == null) {
                let canvas = WebMolKit.dom('<canvas/>').appendTo(document.body);
                this.ctxReference = canvas.el.getContext('2d');
                canvas.remove();
            }
            else
                this.ctxReference = ctx;
        }
        static measureTextNative(txt, family, size, opt = {}) {
            return this.main.measureTextNative(txt, family, size, opt);
        }
        measureTextNative(txt, family, size, opt = {}) {
            if (!this.ctxReference)
                throw 'Calling measureTextNative without having called initNativeFont first';
            this.ctxReference.save();
            let pfx = '';
            if (opt.bold)
                pfx += 'bold ';
            if (opt.italic)
                pfx += 'italic ';
            this.ctxReference.font = pfx + size + 'px ' + family;
            let metrics = this.ctxReference.measureText(txt);
            this.ctxReference.restore();
            const FUDGE = this.ASCENT_FUDGE * this.ASCENT / this.UNITS_PER_EM;
            return [metrics.width, size * FUDGE, size * (-this.DESCENT / this.ASCENT) * FUDGE];
        }
    }
    FontData.main = new FontData();
    WebMolKit.FontData = FontData;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let TextAlign;
    (function (TextAlign) {
        TextAlign[TextAlign["Centre"] = 0] = "Centre";
        TextAlign[TextAlign["Left"] = 1] = "Left";
        TextAlign[TextAlign["Right"] = 2] = "Right";
        TextAlign[TextAlign["Baseline"] = 0] = "Baseline";
        TextAlign[TextAlign["Middle"] = 4] = "Middle";
        TextAlign[TextAlign["Top"] = 8] = "Top";
        TextAlign[TextAlign["Bottom"] = 16] = "Bottom";
    })(TextAlign = WebMolKit.TextAlign || (WebMolKit.TextAlign = {}));
    const PRIM_LINE = 1;
    const PRIM_RECT = 2;
    const PRIM_OVAL = 3;
    const PRIM_PATH = 4;
    const PRIM_TEXT = 5;
    const PRIM_TEXTNATIVE = 6;
    class MetaVector {
        constructor(vec) {
            this.types = [];
            this.prims = [];
            this.width = 0;
            this.height = 0;
            this.offsetX = 0;
            this.offsetY = 0;
            this.scale = 1;
            this.density = 1;
            this.charMissing = false;
            this.lowX = null;
            this.lowY = null;
            this.highX = null;
            this.highY = null;
            const font = WebMolKit.FontData.main;
            this.charMask = WebMolKit.Vec.booleanArray(false, font.UNICODE.length);
            if (vec != null) {
                if (vec.size != null) {
                    this.width = vec.size[0];
                    this.height = vec.size[1];
                }
                if (vec.types != null)
                    this.types = vec.types;
                if (vec.prims != null)
                    this.prims = vec.prims;
                for (let p of this.prims)
                    if (p[0] == PRIM_TEXT) {
                        let txt = p[4];
                        for (let n = 0; n < txt.length; n++) {
                            let i = font.getIndex(txt.charAt(n));
                            if (i >= 0)
                                this.charMask[i] = true;
                            else
                                this.charMissing = true;
                        }
                    }
            }
        }
        drawLine(x1, y1, x2, y2, colour, thickness) {
            if (thickness == null)
                thickness = 1;
            let typeidx = this.findOrCreateType([PRIM_LINE, thickness, colour]);
            const bump = 0.5 * thickness;
            this.updateBounds(Math.min(x1, x2) - bump, Math.min(y1, y2) - bump);
            this.updateBounds(Math.max(x1, x2) + bump, Math.max(y1, y2) + bump);
            this.prims.push([PRIM_LINE, typeidx, x1, y1, x2, y2]);
        }
        drawRect(x, y, w, h, edgeCol, thickness, fillCol) {
            if (edgeCol == null)
                edgeCol = MetaVector.NOCOLOUR;
            if (fillCol == null)
                fillCol = MetaVector.NOCOLOUR;
            if (thickness == null)
                thickness = 1;
            let typeidx = this.findOrCreateType([PRIM_RECT, edgeCol, fillCol, thickness]);
            const bump = 0.5 * thickness;
            this.updateBounds(x - bump, y - bump);
            this.updateBounds(x + w + bump, y + h + bump);
            this.prims.push([PRIM_RECT, typeidx, x, y, w, h]);
        }
        drawOval(cx, cy, rw, rh, edgeCol, thickness, fillCol) {
            if (edgeCol == null)
                edgeCol = MetaVector.NOCOLOUR;
            if (fillCol == null)
                fillCol = MetaVector.NOCOLOUR;
            if (thickness == null)
                thickness = 1;
            const bump = 0.5 * thickness;
            this.updateBounds(cx - rw - bump, cy - rh - bump);
            this.updateBounds(cx + rw + bump, cy + rh + bump);
            let typeidx = this.findOrCreateType([PRIM_OVAL, edgeCol, fillCol, thickness]);
            this.prims.push([PRIM_OVAL, typeidx, cx, cy, rw, rh]);
        }
        drawPath(xpoints, ypoints, ctrlFlags, isClosed, edgeCol, thickness, fillCol, hardEdge) {
            if (edgeCol == null)
                edgeCol = MetaVector.NOCOLOUR;
            if (fillCol == null)
                fillCol = MetaVector.NOCOLOUR;
            if (thickness == null)
                thickness = 1;
            if (hardEdge == null)
                hardEdge = false;
            const bump = 0.5 * thickness;
            for (let n = 0; n < xpoints.length; n++) {
                this.updateBounds(xpoints[n] - bump, ypoints[n] - bump);
                if (bump != 0)
                    this.updateBounds(xpoints[n] + bump, ypoints[n] + bump);
            }
            let typeidx = this.findOrCreateType([PRIM_PATH, edgeCol, fillCol, thickness, hardEdge]);
            this.prims.push([PRIM_PATH, typeidx, xpoints.length, WebMolKit.clone(xpoints), WebMolKit.clone(ypoints), WebMolKit.clone(ctrlFlags), isClosed]);
        }
        drawPoly(xpoints, ypoints, edgeCol, thickness, fillCol, hardEdge) {
            this.drawPath(xpoints, ypoints, null, true, edgeCol, thickness, fillCol, hardEdge);
        }
        drawText(x, y, txt, size, colour, align, direction) {
            if (align == null)
                align = TextAlign.Left | TextAlign.Baseline;
            if (direction == null)
                direction = 0;
            let cosTheta = 1, sinTheta = 0;
            if (direction != 0)
                [cosTheta, sinTheta] = [Math.cos(direction * WebMolKit.DEGRAD), Math.sin(direction * WebMolKit.DEGRAD)];
            const font = WebMolKit.FontData.main;
            for (let n = 0; n < txt.length; n++) {
                let i = font.getIndex(txt.charAt(n));
                if (i >= 0)
                    this.charMask[i] = true;
                else
                    this.charMissing = true;
            }
            let metrics = font.measureText(txt, size);
            let bx = 0, by = 0;
            let dx = 0;
            if ((align & TextAlign.Left) != 0) { }
            else if ((align & TextAlign.Right) != 0)
                dx = -metrics[0];
            else
                dx = -0.5 * metrics[0];
            if (dx != 0) {
                bx += dx * cosTheta;
                by += dx * sinTheta;
            }
            let dy = 0;
            if ((align & TextAlign.Middle) != 0)
                dy = 0.5 * metrics[1];
            else if ((align & TextAlign.Top) != 0)
                dy = metrics[1];
            else if ((align & TextAlign.Bottom) != 0)
                dy = -metrics[2];
            if (dy != 0) {
                bx -= dy * sinTheta;
                by += dy * cosTheta;
            }
            let x1 = 0, y1 = 0, x2 = 0, y2 = 0;
            let tx = 0;
            for (let n = 0; n < txt.length; n++) {
                let ch = txt.charAt(n);
                let i = font.getIndex(ch);
                if (i >= 0) {
                    let outlineX = font.getOutlineX(i), outlineY = font.getOutlineY(i);
                    x1 = Math.min(x1, tx + WebMolKit.Vec.min(outlineX));
                    x2 = Math.max(x2, tx + WebMolKit.Vec.max(outlineX));
                    y1 = Math.min(y1, -WebMolKit.Vec.max(outlineY));
                    y2 = Math.max(y2, -WebMolKit.Vec.min(outlineY));
                    tx += font.HORIZ_ADV_X[i];
                    if (n < txt.length - 1)
                        tx += font.getKerning(ch, txt.charAt(n + 1));
                }
                else
                    tx += font.MISSING_HORZ;
            }
            const mscale = size * font.INV_UNITS_PER_EM;
            if (direction == 0) {
                this.updateBounds(x + bx + x1 * mscale, y + by + y1 * mscale);
                this.updateBounds(x + bx + x2 * mscale, y + by + y2 * mscale);
            }
            else {
                let rx1 = x1 * mscale, ry1 = y1 * mscale;
                let rx2 = x2 * mscale, ry2 = y2 * mscale;
                this.updateBounds(x + bx + rx1 * cosTheta - ry1 * sinTheta, y + by + rx1 * sinTheta + ry1 * cosTheta);
                this.updateBounds(x + bx + rx2 * cosTheta - ry1 * sinTheta, y + by + rx2 * sinTheta + ry1 * cosTheta);
                this.updateBounds(x + bx + rx2 * cosTheta - ry2 * sinTheta, y + by + rx2 * sinTheta + ry2 * cosTheta);
                this.updateBounds(x + bx + rx1 * cosTheta - ry2 * sinTheta, y + by + rx1 * sinTheta + ry2 * cosTheta);
            }
            let typeidx = this.findOrCreateType([PRIM_TEXT, size, colour]);
            this.prims.push([PRIM_TEXT, typeidx, x + bx, y + by, txt, direction]);
        }
        drawTextNative(x, y, txt, fontFamily, fontSize, colour, align, opt) {
            if (!opt)
                opt = {};
            if (align == null)
                align = TextAlign.Left | TextAlign.Baseline;
            const font = WebMolKit.FontData.main;
            for (let n = 0; n < txt.length; n++) {
                let i = font.getIndex(txt.charAt(n));
                if (i >= 0)
                    this.charMask[i] = true;
                else
                    this.charMissing = true;
            }
            let metrics = font.measureTextNative(txt, fontFamily, fontSize, opt);
            let bx = 0, by = 0;
            if ((align & TextAlign.Left) != 0) { }
            else if ((align & TextAlign.Right) != 0)
                bx = -metrics[0];
            else
                bx = -0.5 * metrics[0];
            if ((align & TextAlign.Middle) != 0)
                by += 0.5 * metrics[1];
            else if ((align & TextAlign.Top) != 0)
                by += metrics[1];
            else if ((align & TextAlign.Bottom) != 0)
                by -= metrics[2];
            this.updateBounds(x, y - metrics[1]);
            this.updateBounds(x + metrics[0], y + metrics[2]);
            let typeidx = this.findOrCreateType([PRIM_TEXTNATIVE, fontFamily, fontSize, colour, opt]);
            this.prims.push([PRIM_TEXTNATIVE, typeidx, x + bx, y + by, txt]);
        }
        boundLowX() { return this.lowX; }
        boundLowY() { return this.lowY; }
        boundHighX() { return this.highX; }
        boundHighY() { return this.highY; }
        getBounds() { return new WebMolKit.Box(this.lowX, this.lowY, this.highX - this.lowX, this.highY - this.lowY); }
        measure() {
            this.width = Math.ceil(this.highX - this.lowX);
            this.height = Math.ceil(this.highY - this.lowY);
        }
        normalise() {
            if (this.lowX != 0 || this.lowY != 0)
                this.transformPrimitives(-this.lowX, -this.lowY, 1, 1);
            this.width = Math.ceil(this.highX - this.lowX);
            this.height = Math.ceil(this.highY - this.lowY);
        }
        setSize(width, height) { this.width = width; this.height = height; }
        transformIntoBox(box) {
            this.transformPrimitives(-this.lowX, -this.lowY, 1, 1);
            let nw = Math.ceil(this.highX - this.lowX), nh = Math.ceil(this.highY - this.lowY);
            let scale = 1;
            if (nw > box.w) {
                let mod = box.w / nw;
                nw = box.w;
                nh *= mod;
                scale *= mod;
            }
            if (nh > box.h) {
                let mod = box.h / nh;
                nh = box.h;
                nw *= mod;
                scale *= mod;
            }
            let ox = 0.5 * (box.w - nw), oy = 0.5 * (box.h - nh);
            this.transformPrimitives(box.x + ox, box.y + oy, scale, scale);
        }
        scaleExtent(maxWidth, maxHeight) {
            let w = this.highX - this.lowX, h = this.highY - this.lowY;
            if (w <= maxWidth && h <= maxHeight)
                return;
            let scale = Math.min(maxWidth / w, maxHeight / h);
            this.transformPrimitives(0, 0, scale, scale);
        }
        transformPrimitives(ox, oy, sw, sh) {
            if (ox == 0 && oy == 0 && sw == 1 && sh == 1)
                return;
            for (let a of this.prims) {
                const type = a[0];
                if (type == PRIM_LINE) {
                    a[2] = ox + a[2] * sw;
                    a[3] = oy + a[3] * sh;
                    a[4] = ox + a[4] * sw;
                    a[5] = oy + a[5] * sh;
                }
                else if (type == PRIM_RECT) {
                    a[2] = ox + a[2] * sw;
                    a[3] = oy + a[3] * sh;
                    a[4] = a[4] * sw;
                    a[5] = a[5] * sh;
                }
                else if (type == PRIM_OVAL) {
                    a[2] = ox + a[2] * sw;
                    a[3] = oy + a[3] * sh;
                    a[4] *= sw;
                    a[5] *= sh;
                }
                else if (type == PRIM_PATH) {
                    let sz = a[2], px = a[3], py = a[4];
                    for (let n = 0; n < sz; n++) {
                        px[n] = ox + px[n] * sw;
                        py[n] = oy + py[n] * sh;
                    }
                }
                else if (type == PRIM_TEXT || type == PRIM_TEXTNATIVE) {
                    a[2] = ox + a[2] * sw;
                    a[3] = oy + a[3] * sh;
                }
            }
            let swsh = 0.5 * (sw + sh);
            if (swsh != 1)
                for (let t of this.types) {
                    const type = t[0];
                    if (type == PRIM_LINE)
                        t[1] *= swsh;
                    else if (type == PRIM_RECT)
                        t[3] *= swsh;
                    else if (type == PRIM_OVAL)
                        t[3] *= swsh;
                    else if (type == PRIM_PATH)
                        t[3] *= swsh;
                    else if (type == PRIM_TEXT)
                        t[1] *= swsh;
                    else if (type == PRIM_TEXTNATIVE)
                        t[2] *= swsh;
                }
            this.lowX = ox + this.lowX * sw;
            this.lowY = oy + this.lowY * sh;
            this.highX = ox + this.highX * sw;
            this.highY = oy + this.highY * sh;
        }
        renderInto(parent) {
            let canvas = WebMolKit.newElement(parent, 'canvas', { 'width': this.width, 'height': this.height });
            this.renderCanvas(canvas);
            return canvas;
        }
        renderCanvas(canvas, clearFirst) {
            let ctx = canvas.getContext('2d');
            if (clearFirst)
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            let w = this.width, h = this.height;
            this.density = WebMolKit.pixelDensity();
            canvas.style.width = w + 'px';
            canvas.style.height = h + 'px';
            canvas.width = w * this.density;
            canvas.height = h * this.density;
            this.renderContext(ctx);
        }
        renderContext(ctx) {
            ctx.save();
            ctx.scale(this.density, this.density);
            this.typeObj = [];
            for (let n = 0; n < this.types.length; n++) {
                let t = this.types[n];
                if (t[0] == PRIM_LINE)
                    this.typeObj[n] = this.setupTypeLine(t);
                else if (t[0] == PRIM_RECT)
                    this.typeObj[n] = this.setupTypeRect(t);
                else if (t[0] == PRIM_OVAL)
                    this.typeObj[n] = this.setupTypeOval(t);
                else if (t[0] == PRIM_PATH)
                    this.typeObj[n] = this.setupTypePath(t);
                else if (t[0] == PRIM_TEXT)
                    this.typeObj[n] = this.setupTypeText(t);
                else if (t[0] == PRIM_TEXTNATIVE)
                    this.typeObj[n] = this.setupTypeTextNative(t);
            }
            for (let n = 0; n < this.prims.length; n++) {
                let p = this.prims[n];
                if (p[0] == PRIM_LINE)
                    this.renderLine(ctx, p);
                else if (p[0] == PRIM_RECT)
                    this.renderRect(ctx, p);
                else if (p[0] == PRIM_OVAL)
                    this.renderOval(ctx, p);
                else if (p[0] == PRIM_PATH)
                    this.renderPath(ctx, p);
                else if (p[0] == PRIM_TEXT)
                    this.renderText(ctx, p);
                else if (p[0] == PRIM_TEXTNATIVE)
                    this.renderTextNative(ctx, p);
            }
            ctx.restore();
        }
        createSVG(prettyPrint = false) {
            let xml = WebMolKit.XML.parseXML('<svg/>');
            let svg = xml.documentElement;
            svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            svg.setAttribute('width', this.width.toString());
            svg.setAttribute('height', this.height.toString());
            svg.setAttribute('viewBox', `0 0 ${this.width} ${this.height}`);
            this.renderSVG(svg);
            return prettyPrint ? WebMolKit.XML.toPrettyString(xml) : WebMolKit.XML.toString(xml);
        }
        renderSVG(svg) {
            this.typeObj = [];
            const font = WebMolKit.FontData.main;
            let defs = WebMolKit.XML.appendElement(svg, 'defs');
            if (this.charMissing) {
                let path = WebMolKit.XML.appendElement(defs, 'path');
                path.setAttribute('id', 'missing');
                path.setAttribute('d', font.MISSING_DATA);
                path.setAttribute('edge', 'none');
            }
            for (let n = 0; n < font.UNICODE.length; n++)
                if (this.charMask[n]) {
                    let path = WebMolKit.XML.appendElement(defs, 'path');
                    path.setAttribute('id', 'char' + n);
                    path.setAttribute('d', font.GLYPH_DATA[n]);
                    path.setAttribute('edge', 'none');
                }
            for (let n = 0; n < this.types.length; n++) {
                let t = this.types[n];
                if (t[0] == PRIM_LINE)
                    this.typeObj[n] = this.setupTypeLine(t);
                else if (t[0] == PRIM_RECT)
                    this.typeObj[n] = this.setupTypeRect(t);
                else if (t[0] == PRIM_OVAL)
                    this.typeObj[n] = this.setupTypeOval(t);
                else if (t[0] == PRIM_PATH)
                    this.typeObj[n] = this.setupTypePath(t);
                else if (t[0] == PRIM_TEXT)
                    this.typeObj[n] = this.setupTypeText(t);
                else if (t[0] == PRIM_TEXTNATIVE)
                    this.typeObj[n] = this.setupTypeTextNative(t);
            }
            for (let n = 0; n < this.prims.length;) {
                let p = this.prims[n], num = 1;
                if (p[0] != PRIM_PATH && p[0] != PRIM_TEXT && p[0] != PRIM_TEXTNATIVE) {
                    for (; n + num < this.prims.length; num++)
                        if (this.prims[n + num][0] != p[0] || this.prims[n + num][1] != p[1])
                            break;
                }
                if (p[0] == PRIM_LINE) {
                    if (num == 1)
                        this.svgLine1(svg, p);
                    else
                        this.svgLineN(svg, p, n, num);
                }
                else if (p[0] == PRIM_RECT) {
                    if (num == 1)
                        this.svgRect1(svg, p);
                    else
                        this.svgRectN(svg, p, n, num);
                }
                else if (p[0] == PRIM_OVAL) {
                    if (num == 1)
                        this.svgOval1(svg, p);
                    else
                        this.svgOvalN(svg, p, n, num);
                }
                else if (p[0] == PRIM_PATH)
                    this.svgPath(svg, p);
                else if (p[0] == PRIM_TEXT)
                    this.svgText(svg, p);
                else if (p[0] == PRIM_TEXTNATIVE)
                    this.svgTextNative(svg, p);
                n += num;
            }
        }
        spool(into) {
            for (let p of this.prims) {
                if (p[0] == PRIM_LINE) {
                    let [_, typeidx, x1, y1, x2, y2] = p;
                    let [, thickness, colour] = this.types[typeidx];
                    into.drawLine(x1, y1, x2, y2, colour, thickness);
                }
                else if (p[0] == PRIM_RECT) {
                    let [_, typeidx, x, y, w, h] = p;
                    let [, edgeCol, fillCol, thickness] = this.types[typeidx];
                    into.drawRect(x, y, w, h, edgeCol, thickness, fillCol);
                }
                else if (p[0] == PRIM_OVAL) {
                    let [_, typeidx, x, y, w, h] = p;
                    let [, edgeCol, fillCol, thickness] = this.types[typeidx];
                    into.drawOval(x, y, w, h, edgeCol, thickness, fillCol);
                }
                else if (p[0] == PRIM_PATH) {
                    let [_, typeidx, numPoints, xpoints, ypoints, ctrlFlags, isClosed] = p;
                    let [, edgeCol, fillCol, thickness, hardEdge] = this.types[typeidx];
                    into.drawPath(xpoints, ypoints, ctrlFlags, isClosed, edgeCol, thickness, fillCol, hardEdge);
                }
                else if (p[0] == PRIM_TEXT) {
                    let [_, typeidx, x, y, txt, direction] = p;
                    let [, size, colour] = this.types[typeidx];
                    into.drawText(x, y, txt, size, colour, null, direction);
                }
                else if (p[0] == PRIM_TEXTNATIVE) {
                    let [_, typeidx, x, y, txt] = p;
                    let [, fontFamily, fontSize, colour] = this.types[typeidx];
                    into.drawTextNative(x, y, txt, fontFamily, fontSize, colour);
                }
            }
        }
        setupTypeLine(t) {
            let thickness = t[1] * this.scale;
            let colour = t[2];
            return { 'thickness': thickness, 'colour': colour };
        }
        setupTypeRect(t) {
            let edgeCol = t[1];
            let fillCol = t[2];
            let thickness = t[3] * this.scale;
            return { 'edgeCol': edgeCol, 'fillCol': fillCol, 'thickness': thickness };
        }
        setupTypeOval(t) {
            let edgeCol = t[1];
            let fillCol = t[2];
            let thickness = t[3] * this.scale;
            return { 'edgeCol': edgeCol, 'fillCol': fillCol, 'thickness': thickness };
        }
        setupTypePath(t) {
            let edgeCol = t[1];
            let fillCol = t[2];
            let thickness = t[3] * this.scale;
            let hardEdge = t[4];
            return { 'edgeCol': edgeCol, 'fillCol': fillCol, 'thickness': thickness, 'hardEdge': hardEdge };
        }
        setupTypeText(t) {
            let sz = t[1] * this.scale;
            let colour = t[2];
            return { 'colour': colour, 'size': sz };
        }
        setupTypeTextNative(t) {
            let family = t[1];
            let sz = t[2] * this.scale;
            let colour = t[3];
            let opt = t[4];
            return { 'colour': colour, 'family': family, 'size': sz, 'opt': opt };
        }
        renderLine(ctx, p) {
            let type = this.typeObj[p[1]];
            let x1 = p[2], y1 = p[3];
            let x2 = p[4], y2 = p[5];
            let colour = type.colour;
            x1 = this.offsetX + this.scale * x1;
            y1 = this.offsetY + this.scale * y1;
            x2 = this.offsetX + this.scale * x2;
            y2 = this.offsetY + this.scale * y2;
            if (colour != null) {
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.strokeStyle = WebMolKit.colourCanvas(colour);
                ctx.lineWidth = type.thickness;
                ctx.lineCap = 'round';
                ctx.stroke();
            }
        }
        renderRect(ctx, p) {
            let type = this.typeObj[p[1]];
            let x = p[2], y = p[3];
            let w = p[4], h = p[5];
            let edgeCol = type.edgeCol, fillCol = type.fillCol;
            x = this.offsetX + this.scale * x;
            y = this.offsetY + this.scale * y;
            w *= this.scale;
            h *= this.scale;
            if (fillCol != MetaVector.NOCOLOUR) {
                ctx.fillStyle = WebMolKit.colourCanvas(fillCol);
                ctx.fillRect(x, y, w, h);
            }
            if (edgeCol != MetaVector.NOCOLOUR) {
                ctx.strokeStyle = WebMolKit.colourCanvas(edgeCol);
                ctx.lineWidth = type.thickness;
                ctx.lineCap = 'square';
                ctx.strokeRect(x, y, w, h);
            }
        }
        renderOval(ctx, p) {
            let type = this.typeObj[p[1]];
            let cx = p[2], cy = p[3];
            let rw = p[4], rh = p[5];
            let edgeCol = type.edgeCol, fillCol = type.fillCol;
            cx = this.offsetX + this.scale * cx;
            cy = this.offsetY + this.scale * cy;
            rw *= this.scale;
            rh *= this.scale;
            if (fillCol != MetaVector.NOCOLOUR) {
                ctx.fillStyle = WebMolKit.colourCanvas(fillCol);
                ctx.beginPath();
                ctx.ellipse(cx, cy, rw, rh, 0, 0, 2 * Math.PI, true);
                ctx.fill();
            }
            if (edgeCol != MetaVector.NOCOLOUR) {
                ctx.strokeStyle = WebMolKit.colourCanvas(edgeCol);
                ctx.lineWidth = type.thickness;
                ctx.beginPath();
                ctx.ellipse(cx, cy, rw, rh, 0, 0, 2 * Math.PI, true);
                ctx.stroke();
            }
        }
        renderPath(ctx, p) {
            let type = this.typeObj[p[1]];
            let npts = p[2];
            if (npts == 0)
                return;
            let x = WebMolKit.Vec.duplicate(p[3]), y = WebMolKit.Vec.duplicate(p[4]);
            let ctrl = p[5];
            let isClosed = p[6];
            let edgeCol = type.edgeCol, fillCol = type.fillCol;
            for (let n = 0; n < npts; n++) {
                x[n] = this.offsetX + this.scale * x[n];
                y[n] = this.offsetY + this.scale * y[n];
            }
            for (let layer = 1; layer <= 2; layer++) {
                if (layer == 1 && fillCol == MetaVector.NOCOLOUR)
                    continue;
                if (layer == 2 && edgeCol == MetaVector.NOCOLOUR)
                    continue;
                ctx.beginPath();
                ctx.moveTo(x[0], y[0]);
                for (let i = 1; i < npts; i++) {
                    if (!ctrl || !ctrl[i]) {
                        ctx.lineTo(x[i], y[i]);
                    }
                    else if (i < npts - 1 && !ctrl[i + 1]) {
                        ctx.quadraticCurveTo(x[i], y[i], x[i + 1], y[i + 1]);
                        i++;
                    }
                    else if (i < npts - 1 && !ctrl[i + 2]) {
                        ctx.bezierCurveTo(x[i], y[i], x[i + 1], y[i + 1], x[i + 2], y[i + 2]);
                        i += 2;
                    }
                }
                if (isClosed)
                    ctx.closePath();
                if (layer == 1) {
                    ctx.fillStyle = WebMolKit.colourCanvas(type.fillCol);
                    ctx.fill();
                }
                else {
                    ctx.strokeStyle = WebMolKit.colourCanvas(type.edgeCol);
                    ctx.lineWidth = type.thickness;
                    ctx.lineCap = type.hardEdge ? 'square' : 'round';
                    ctx.lineJoin = type.hardEdge ? 'miter' : 'round';
                    ctx.stroke();
                }
            }
        }
        renderText(ctx, p) {
            let type = this.typeObj[p[1]];
            let x = p[2], y = p[3];
            let txt = p[4];
            let sz = type.size;
            let fill = WebMolKit.colourCanvas(type.colour);
            x = this.offsetX + this.scale * x;
            y = this.offsetY + this.scale * y;
            let font = WebMolKit.FontData.main;
            let scale = sz / font.UNITS_PER_EM;
            let dx = 0;
            for (let n = 0; n < txt.length; n++) {
                let ch = txt.charAt(n);
                let i = font.getIndex(ch);
                let path = null;
                if (i < 0) {
                    dx += font.MISSING_HORZ;
                    path = font.getMissingPath();
                }
                else
                    path = font.getGlyphPath(i);
                if (path) {
                    ctx.save();
                    ctx.translate(x + dx * scale, y);
                    ctx.scale(scale, -scale);
                    ctx.fillStyle = fill;
                    ctx.fill(path);
                    ctx.restore();
                }
                dx += font.HORIZ_ADV_X[i];
                if (n < txt.length - 1)
                    dx += font.getKerning(ch, txt.charAt(n + 1));
            }
        }
        renderTextNative(ctx, p) {
            let type = this.typeObj[p[1]];
            let x = p[2], y = p[3];
            let txt = p[4];
            let family = type.family, sz = type.size, opt = type.opt;
            let fill = WebMolKit.colourCanvas(type.colour);
            x = this.offsetX + this.scale * x;
            y = this.offsetY + this.scale * y;
            ctx.save();
            let pfx = '';
            if (opt.bold)
                pfx += 'bold ';
            if (opt.italic)
                pfx += 'italic ';
            ctx.font = pfx + sz + 'px ' + family;
            ctx.fillStyle = fill;
            ctx.fillText(txt, x, y);
            ctx.restore();
        }
        svgLine1(svg, p) {
            let type = this.typeObj[p[1]];
            let x1 = p[2], y1 = p[3];
            let x2 = p[4], y2 = p[5];
            x1 = this.offsetX + this.scale * x1;
            y1 = this.offsetY + this.scale * y1;
            x2 = this.offsetX + this.scale * x2;
            y2 = this.offsetY + this.scale * y2;
            if (type.colour != MetaVector.NOCOLOUR) {
                let line = WebMolKit.XML.appendElement(svg, 'line');
                line.setAttribute('x1', x1.toString());
                line.setAttribute('y1', y1.toString());
                line.setAttribute('x2', x2.toString());
                line.setAttribute('y2', y2.toString());
                this.defineSVGStroke(line, type.colour);
                line.setAttribute('stroke-width', type.thickness.toString());
                line.setAttribute('stroke-linecap', 'round');
            }
        }
        svgLineN(svg, p, pos, sz) {
            let type = this.typeObj[p[1]];
            if (type.colour == MetaVector.NOCOLOUR)
                return;
            let g = WebMolKit.XML.appendElement(svg, 'g');
            this.defineSVGStroke(g, type.colour);
            g.setAttribute('stroke-width', type.thickness.toString());
            g.setAttribute('stroke-linecap', 'round');
            for (let n = 0; n < sz; n++) {
                let p = this.prims[pos + n];
                let x1 = p[2], y1 = p[3];
                let x2 = p[4], y2 = p[5];
                x1 = this.offsetX + this.scale * x1;
                y1 = this.offsetY + this.scale * y1;
                x2 = this.offsetX + this.scale * x2;
                y2 = this.offsetY + this.scale * y2;
                let line = WebMolKit.XML.appendElement(g, 'line');
                line.setAttribute('x1', x1.toString());
                line.setAttribute('y1', y1.toString());
                line.setAttribute('x2', x2.toString());
                line.setAttribute('y2', y2.toString());
            }
        }
        svgRect1(svg, p) {
            let type = this.typeObj[p[1]];
            let x = p[2], y = p[3];
            let w = p[4], h = p[5];
            x = this.offsetX + this.scale * x;
            y = this.offsetY + this.scale * y;
            w *= this.scale;
            h *= this.scale;
            let rect = WebMolKit.XML.appendElement(svg, 'rect');
            rect.setAttribute('x', x.toString());
            rect.setAttribute('y', y.toString());
            rect.setAttribute('width', w.toString());
            rect.setAttribute('height', h.toString());
            this.defineSVGStroke(rect, type.edgeCol);
            if (type.edgeCol != MetaVector.NOCOLOUR) {
                rect.setAttribute('stroke-width', type.thickness.toString());
                rect.setAttribute('stroke-linecap', 'square');
            }
            this.defineSVGFill(rect, type.fillCol);
        }
        svgRectN(svg, p, pos, sz) {
            let type = this.typeObj[p[1]];
            let g = WebMolKit.XML.appendElement(svg, 'g');
            this.defineSVGStroke(g, type.edgeCol);
            if (type.edgeCol != MetaVector.NOCOLOUR) {
                g.setAttribute('stroke-width', type.thickness.toString());
                g.setAttribute('stroke-linecap', 'square');
            }
            this.defineSVGFill(g, type.fillCol);
            for (let n = 0; n < sz; n++) {
                let p = this.prims[pos + n];
                let x = p[2], y = p[3];
                let w = p[4], h = p[5];
                x = this.offsetX + this.scale * x;
                y = this.offsetY + this.scale * y;
                w *= this.scale;
                h *= this.scale;
                let rect = WebMolKit.XML.appendElement(g, 'rect');
                rect.setAttribute('x', x.toString());
                rect.setAttribute('y', y.toString());
                rect.setAttribute('width', w.toString());
                rect.setAttribute('height', h.toString());
            }
        }
        svgOval1(svg, p) {
            let type = this.typeObj[p[1]];
            let cx = p[2], cy = p[3];
            let rw = p[4], rh = p[5];
            cx = this.offsetX + this.scale * cx;
            cy = this.offsetY + this.scale * cy;
            rw *= this.scale;
            rh *= this.scale;
            let oval = WebMolKit.XML.appendElement(svg, 'ellipse');
            oval.setAttribute('cx', cx.toString());
            oval.setAttribute('cy', cy.toString());
            oval.setAttribute('rx', rw.toString());
            oval.setAttribute('ry', rh.toString());
            this.defineSVGStroke(oval, type.edgeCol);
            if (type.edgeCol != MetaVector.NOCOLOUR) {
                oval.setAttribute('stroke-width', type.thickness.toString());
            }
            this.defineSVGFill(oval, type.fillCol);
        }
        svgOvalN(svg, p, pos, sz) {
            let type = this.typeObj[p[1]];
            let g = WebMolKit.XML.appendElement(svg, 'g');
            this.defineSVGStroke(g, type.edgeCol);
            if (type.edgeCol != MetaVector.NOCOLOUR) {
                g.setAttribute('stroke-width', type.thickness.toString());
            }
            this.defineSVGFill(g, type.fillCol);
            for (let n = 0; n < sz; n++) {
                let p = this.prims[pos + n];
                let cx = p[2], cy = p[3];
                let rw = p[4], rh = p[5];
                cx = this.offsetX + this.scale * cx;
                cy = this.offsetY + this.scale * cy;
                rw *= this.scale;
                rh *= this.scale;
                let oval = WebMolKit.XML.appendElement(g, 'ellipse');
                oval.setAttribute('cx', cx.toString());
                oval.setAttribute('cy', cy.toString());
                oval.setAttribute('rx', rw.toString());
                oval.setAttribute('ry', rh.toString());
            }
        }
        svgPath(svg, p) {
            let type = this.typeObj[p[1]];
            let npts = p[2];
            if (npts == 0)
                return;
            let x = p[3].slice(0), y = p[4].slice(0);
            let ctrl = p[5];
            let isClosed = p[6];
            for (let n = 0; n < npts; n++) {
                x[n] = this.offsetX + this.scale * x[n];
                y[n] = this.offsetY + this.scale * y[n];
            }
            let shape = 'M ' + x[0] + ' ' + y[0];
            let n = 1;
            while (n < npts) {
                if (!ctrl || !ctrl[n]) {
                    shape += ' L ' + x[n] + ' ' + y[n];
                    n++;
                }
                else if (ctrl[n] && n < npts - 1 && !ctrl[n + 1]) {
                    shape += ' Q ' + x[n] + ' ' + y[n] + ' ' + x[n + 1] + ' ' + y[n + 1];
                    n += 2;
                }
                else if (ctrl[n] && n < npts - 2 && ctrl[n + 1] && !ctrl[n + 2]) {
                    shape += ' C ' + x[n] + ' ' + y[n] + ' ' + x[n + 1] + ' ' + y[n + 1] + ' ' + x[n + 2] + ' ' + y[n + 2];
                    n += 3;
                }
                else
                    n++;
            }
            if (isClosed)
                shape += ' Z';
            let path = WebMolKit.XML.appendElement(svg, 'path');
            path.setAttribute('d', shape);
            this.defineSVGStroke(path, type.edgeCol);
            if (type.edgeCol != MetaVector.NOCOLOUR) {
                path.setAttribute('stroke-width', type.thickness.toString());
                path.setAttribute('stroke-linejoin', type.hardEdge ? 'miter' : 'round');
                path.setAttribute('stroke-linecap', type.hardEdge ? 'square' : 'round');
            }
            this.defineSVGFill(path, type.fillCol);
        }
        svgText(svg, p) {
            let type = this.typeObj[p[1]];
            let x = p[2], y = p[3];
            let txt = p[4];
            let direction = p[5];
            let sz = type.size;
            x = this.offsetX + this.scale * x;
            y = this.offsetY + this.scale * y;
            let font = WebMolKit.FontData.main;
            let scale = sz / font.UNITS_PER_EM;
            let parent = svg;
            if (direction != 0) {
                parent = WebMolKit.XML.appendElement(parent, 'g');
                parent.setAttribute('transform', `rotate(${direction},${x},${y})`);
            }
            let gdelta = WebMolKit.XML.appendElement(parent, 'g');
            gdelta.setAttribute('transform', 'translate(' + x + ',' + y + ')');
            this.defineSVGFill(gdelta, type.colour);
            let gscale = WebMolKit.XML.appendElement(gdelta, 'g');
            gscale.setAttribute('transform', 'scale(' + scale + ',' + (-scale) + ')');
            let dx = 0;
            for (let n = 0; n < txt.length; n++) {
                let ch = txt.charAt(n);
                let i = font.getIndex(ch);
                let use = WebMolKit.XML.appendElement(gscale, 'use');
                let ref = i < 0 ? '#missing' : '#char' + i;
                use.setAttribute('href', ref);
                use.setAttribute('x', dx.toString());
                if (i >= 0) {
                    dx += font.HORIZ_ADV_X[i];
                    if (n < txt.length - 1)
                        dx += font.getKerning(ch, txt.charAt(n + 1));
                }
                else
                    dx += font.MISSING_HORZ;
            }
        }
        svgTextNative(svg, p) {
            let type = this.typeObj[p[1]];
            let x = p[2], y = p[3];
            let txt = p[4];
            let family = type.family, sz = type.size, opt = type.opt;
            x = this.offsetX + this.scale * x;
            y = this.offsetY + this.scale * y;
            let colour = WebMolKit.colourCanvas(type.colour);
            let style = `fill: ${colour}; font-family: ${family}; font-size: ${sz};`;
            if (opt.bold)
                style += ' font-weight: bold;';
            if (opt.italic)
                style += ' font-style: italic;';
            let node = WebMolKit.XML.appendElement(svg, 'text');
            node.setAttribute('xml:space', 'preserve');
            node.setAttribute('x', x.toString());
            node.setAttribute('y', y.toString());
            node.setAttribute('style', style);
            WebMolKit.XML.setText(node, txt);
        }
        defineSVGStroke(obj, col) {
            if (col == MetaVector.NOCOLOUR) {
                obj.setAttribute('stroke-opacity', '0');
                return;
            }
            obj.setAttribute('stroke', WebMolKit.colourCode(col));
            let alpha = WebMolKit.colourAlpha(col);
            if (alpha != 1)
                obj.setAttribute('stroke-opacity', alpha.toString());
        }
        defineSVGFill(obj, col) {
            if (col == MetaVector.NOCOLOUR) {
                obj.setAttribute('fill-opacity', '0');
                return;
            }
            obj.setAttribute('fill', WebMolKit.colourCode(col));
            let alpha = WebMolKit.colourAlpha(col);
            if (alpha != 1)
                obj.setAttribute('fill-opacity', alpha.toString());
        }
        findOrCreateType(typeDef) {
            for (let i = 0; i < this.types.length; i++) {
                if (this.types[i].length != typeDef.length)
                    continue;
                let match = true;
                for (let j = 0; j < typeDef.length; j++)
                    if (typeDef[j] != this.types[i][j]) {
                        match = false;
                        break;
                    }
                if (match)
                    return i;
            }
            this.types.push(typeDef);
            return this.types.length - 1;
        }
        updateBounds(x, y) {
            if (this.lowX == null) {
                this.lowX = x;
                this.lowY = y;
                this.highX = x;
                this.highY = y;
                return;
            }
            this.lowX = Math.min(this.lowX, x);
            this.lowY = Math.min(this.lowY, y);
            this.highX = Math.max(this.highX, x);
            this.highY = Math.max(this.highY, y);
        }
    }
    MetaVector.NOCOLOUR = -1;
    WebMolKit.MetaVector = MetaVector;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class RenderPolicy {
        constructor(data) {
            if (!data) {
                data =
                    {
                        'name': 'default',
                        'pointScale': 20,
                        'resolutionDPI': 100,
                        'fontSize': 0.65,
                        'lineSize': 0.075,
                        'bondSep': 0.2,
                        'defaultPadding': 0.2,
                        'foreground': 0x000000,
                        'background': 0xFFFFFF,
                        'atomCols': new Array(112)
                    };
                for (let n = 0; n <= 111; n++)
                    data.atomCols[n] = 0x000000;
                this.data = data;
            }
            else {
                this.data = WebMolKit.clone(data);
            }
        }
        static defaultBlackOnWhite(pixPerAng) {
            let policy = new RenderPolicy();
            if (pixPerAng)
                policy.data.pointScale = pixPerAng;
            return policy;
        }
        static defaultWhiteOnBlack(pixPerAng) {
            let policy = new RenderPolicy();
            if (pixPerAng)
                policy.data.pointScale = pixPerAng;
            policy.data.foreground = 0xFFFFFF;
            policy.data.background = 0x000000;
            for (let n = 0; n <= 111; n++)
                policy.data.atomCols[n] = 0xFFFFFF;
            return policy;
        }
        static defaultColourOnWhite(pixPerAng) {
            let policy = RenderPolicy.defaultBlackOnWhite(pixPerAng);
            policy.data.atomCols[0] = 0x404040;
            policy.data.atomCols[1] = 0x808080;
            policy.data.atomCols[6] = 0x000000;
            policy.data.atomCols[7] = 0x0000FF;
            policy.data.atomCols[8] = 0xFF0000;
            policy.data.atomCols[9] = 0xFF8080;
            policy.data.atomCols[15] = 0xFF8000;
            policy.data.atomCols[16] = 0x808000;
            policy.data.atomCols[17] = 0x00C000;
            policy.data.atomCols[35] = 0xC04000;
            return policy;
        }
        static defaultColourOnBlack(pixPerAng) {
            let policy = RenderPolicy.defaultWhiteOnBlack(pixPerAng);
            policy.data.atomCols[0] = 0xA0A0A0;
            policy.data.atomCols[1] = 0x808080;
            policy.data.atomCols[6] = 0xFFFFFF;
            policy.data.atomCols[7] = 0x4040FF;
            policy.data.atomCols[8] = 0xFF4040;
            policy.data.atomCols[9] = 0xFF8080;
            policy.data.atomCols[15] = 0xFF8000;
            policy.data.atomCols[16] = 0xFFFF00;
            policy.data.atomCols[17] = 0x40FF40;
            policy.data.atomCols[35] = 0xFF8040;
            return policy;
        }
        static defaultPrintedPublication() {
            let policy = RenderPolicy.defaultBlackOnWhite(9.6);
            policy.data.resolutionDPI = 600;
            policy.data.fontSize = 0.80;
            policy.data.bondSep = 0.27;
            policy.data.lineSize = 0.0625;
            return policy;
        }
    }
    WebMolKit.RenderPolicy = RenderPolicy;
    class RenderEffects {
        constructor() {
            this.colAtom = {};
            this.colBond = {};
            this.dottedRectOutline = {};
            this.dottedBondCross = {};
            this.hideAtoms = new Set();
            this.hideBonds = new Set();
            this.atomFrameDotSz = [];
            this.atomFrameCol = [];
            this.atomCircleSz = [];
            this.atomCircleCol = [];
            this.atomDecoText = [];
            this.atomDecoCol = [];
            this.atomDecoSize = [];
            this.bondDecoText = [];
            this.bondDecoCol = [];
            this.bondDecoSize = [];
            this.overlapAtoms = [];
        }
    }
    WebMolKit.RenderEffects = RenderEffects;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class ButtonBank {
        constructor() {
            this.isSubLevel = false;
            this.buttons = [];
        }
        init() { }
        claimKey(event) { return false; }
        bankClosed() { }
        static matchKey(event, mnemonic, key) {
            if (mnemonic == null || mnemonic == '')
                return false;
            let mshift = false, mctrl = false, malt = false, mmeta = false, mkey = mnemonic;
            while (true) {
                if (mkey.startsWith('Shift+')) {
                    mshift = true;
                    mkey = mkey.substring(6);
                }
                else if (mkey.startsWith('Ctrl+')) {
                    mctrl = true;
                    mkey = mkey.substring(5);
                }
                else if (mkey.startsWith('Alt+')) {
                    malt = true;
                    mkey = mkey.substring(4);
                }
                else if (mkey.startsWith('Cmd+')) {
                    mmeta = true;
                    mkey = mkey.substring(4);
                }
                else
                    break;
            }
            if (mshift != event.shiftKey)
                return false;
            if (mctrl != event.ctrlKey)
                return false;
            if (malt != event.altKey)
                return false;
            if (mmeta != event.metaKey)
                return false;
            if (key)
                mkey = key;
            return mkey.toLowerCase() == event.key.toLowerCase();
        }
    }
    WebMolKit.ButtonBank = ButtonBank;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    const ELEMENTS_NOBLE = [
        'He', 'Ar', 'Kr', 'Xe', 'Rn'
    ];
    const ELEMENTS_S_BLOCK = [
        'Li', 'Na', 'K', 'Rb', 'Cs', 'Fr', 'Sc',
        'Be', 'Mg', 'Ca', 'Sr', 'Ba', 'Ra', 'Y'
    ];
    const ELEMENTS_P_BLOCK = [
        'B', 'Al', 'Si', 'Ga', 'Ge', 'As', 'Se',
        'In', 'Sn', 'Sb', 'Te', 'Tl', 'Pb', 'Bi', 'Po', 'At'
    ];
    const ELEMENTS_D_BLOCK = [
        'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn',
        'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd',
        'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg'
    ];
    const ELEMENTS_F_BLOCK = [
        'La', 'Ce', 'Pr', 'Nd', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy',
        'Ho', 'Er', 'Tm', 'Yb', 'Lu', 'Ac', 'Th', 'Pa', 'U'
    ];
    const ELEMENTS_ABBREV = [
        '*', 'A', 'X', 'Y', 'Z', 'Q', 'M', 'T', 'E', 'L', 'R',
        'R0', 'R1', 'R2', 'R3', 'R4', 'R5', 'R6', 'R7', 'R8'
    ];
    let CommandType;
    (function (CommandType) {
        CommandType[CommandType["Main"] = 0] = "Main";
        CommandType[CommandType["Atom"] = 1] = "Atom";
        CommandType[CommandType["Bond"] = 2] = "Bond";
        CommandType[CommandType["Select"] = 3] = "Select";
        CommandType[CommandType["Move"] = 4] = "Move";
        CommandType[CommandType["Abbrev"] = 5] = "Abbrev";
        CommandType[CommandType["SBlock"] = 6] = "SBlock";
        CommandType[CommandType["PBlock"] = 7] = "PBlock";
        CommandType[CommandType["DBlock"] = 8] = "DBlock";
        CommandType[CommandType["FBlock"] = 9] = "FBlock";
        CommandType[CommandType["Noble"] = 10] = "Noble";
    })(CommandType || (CommandType = {}));
    const COMMANDS_MAIN = [
        { 'id': 'undo', 'imageFN': 'MainUndo', 'helpText': 'Undo last change.', 'mnemonic': 'CmdOrCtrl+Z' },
        { 'id': 'redo', 'imageFN': 'MainRedo', 'helpText': 'Cancel last undo.', 'mnemonic': 'CmdOrCtrl+Shift+Z' },
        { 'id': 'zoomin', 'imageFN': 'MainZoomIn', 'helpText': 'Zoom in.', 'mnemonic': '=' },
        { 'id': 'zoomout', 'imageFN': 'MainZoomOut', 'helpText': 'Zoom out.', 'mnemonic': '-' },
        { 'id': 'zoomfit', 'imageFN': 'MainZoomFit', 'helpText': 'Show whole diagram onscreen.', 'mnemonic': '' },
        { 'id': 'selside', 'imageFN': 'MainSelSide', 'helpText': 'Select alternate side of current atom or bond.', 'mnemonic': 'E' },
        { 'id': 'selall', 'imageFN': 'MainSelAll', 'helpText': 'Select all atoms.', 'mnemonic': 'Shift+A' },
        { 'id': 'selnone', 'imageFN': 'MainSelNone', 'helpText': 'Clear selection.', 'mnemonic': 'Shift+Q' },
        { 'id': 'delete', 'imageFN': 'MainDelete', 'helpText': 'Delete selected atoms and bonds.', 'mnemonic': 'D' },
        { 'id': 'cut', 'imageFN': 'MainCut', 'helpText': 'Copy selection to clipboard, and remove.', 'mnemonic': 'CmdOrCtrl+X' },
        { 'id': 'copy', 'imageFN': 'MainCopy', 'helpText': 'Copy selection to clipboard.', 'mnemonic': 'CmdOrCtrl+C' },
        { 'id': 'paste', 'imageFN': 'MainPaste', 'helpText': 'Paste clipboard contents.' },
        { 'id': 'atom', 'imageFN': 'MainAtom', 'helpText': 'Open the Atom submenu.', 'isSubMenu': true, 'mnemonic': 'A' },
        { 'id': 'bond', 'imageFN': 'MainBond', 'helpText': 'Open the Bond submenu.', 'isSubMenu': true, 'mnemonic': 'B' },
        { 'id': 'select', 'imageFN': 'MainSelect', 'helpText': 'Open the Selection submenu.', 'isSubMenu': true, 'mnemonic': 'S' },
        { 'id': 'move', 'imageFN': 'MainMove', 'helpText': 'Open the Move submenu.', 'isSubMenu': true, 'mnemonic': 'M' },
    ];
    const COMMANDS_ATOM = [
        { 'id': 'element:C', 'text': 'C', 'helpText': 'Change elements to Carbon.', 'mnemonic': 'Shift+C' },
        { 'id': 'element:N', 'text': 'N', 'helpText': 'Change elements to Nitrogen.', 'mnemonic': 'Shift+N' },
        { 'id': 'element:O', 'text': 'O', 'helpText': 'Change elements to Oxygen.', 'mnemonic': 'Shift+O' },
        { 'id': 'element:S', 'text': 'S', 'helpText': 'Change elements to Sulfur.', 'mnemonic': 'Shift+S' },
        { 'id': 'element:P', 'text': 'P', 'helpText': 'Change elements to Phosphorus.', 'mnemonic': 'Shift+P' },
        { 'id': 'element:H', 'text': 'H', 'helpText': 'Change elements to Hydrogen.', 'mnemonic': 'Shift+H' },
        { 'id': 'element:F', 'text': 'F', 'helpText': 'Change elements to Fluorine.', 'mnemonic': 'Shift+F' },
        { 'id': 'element:Cl', 'text': 'Cl', 'helpText': 'Change elements to Chlorine.', 'mnemonic': 'Shift+L' },
        { 'id': 'element:Br', 'text': 'Br', 'helpText': 'Change elements to Bromine.', 'mnemonic': 'Shift+B' },
        { 'id': 'element:I', 'text': 'I', 'helpText': 'Change elements to Iodine.', 'mnemonic': 'Shift+I' },
        { 'id': 'plus', 'imageFN': 'AtomPlus', 'helpText': 'Increase the atom charge.', 'mnemonic': 'Shift+=', 'key': '+' },
        { 'id': 'minus', 'imageFN': 'AtomMinus', 'helpText': 'Decrease the atom charge.', 'mnemonic': 'Shift+-', 'key': '_' },
        { 'id': 'abbrev', 'imageFN': 'AtomAbbrev', 'helpText': 'Open list of common labels.', 'isSubMenu': true, 'mnemonic': '' },
        { 'id': 'sblock', 'imageFN': 'AtomSBlock', 'helpText': 'Open list of s-block elements.', 'isSubMenu': true, 'mnemonic': '' },
        { 'id': 'pblock', 'imageFN': 'AtomPBlock', 'helpText': 'Open list of p-block elements.', 'isSubMenu': true, 'mnemonic': '' },
        { 'id': 'dblock', 'imageFN': 'AtomDBlock', 'helpText': 'Open list of d-block elements.', 'isSubMenu': true, 'mnemonic': '' },
        { 'id': 'fblock', 'imageFN': 'AtomFBlock', 'helpText': 'Open list of f-block elements.', 'isSubMenu': true, 'mnemonic': '' },
        { 'id': 'noble', 'imageFN': 'AtomNoble', 'helpText': 'Open list of noble elements.', 'isSubMenu': true, 'mnemonic': '' },
    ];
    const COMMANDS_BOND = [
        { 'id': 'one', 'imageFN': 'BondOne', 'helpText': 'Create or set bonds to single.', 'mnemonic': '1' },
        { 'id': 'two', 'imageFN': 'BondTwo', 'helpText': 'Create or set bonds to double.', 'mnemonic': '2' },
        { 'id': 'three', 'imageFN': 'BondThree', 'helpText': 'Create or set bonds to triple.', 'mnemonic': '3' },
        { 'id': 'four', 'imageFN': 'BondFour', 'helpText': 'Create or set bonds to quadruple.', 'mnemonic': '' },
        { 'id': 'zero', 'imageFN': 'BondZero', 'helpText': 'Create or set bonds to zero-order.', 'mnemonic': '0' },
        { 'id': 'inclined', 'imageFN': 'BondUp', 'helpText': 'Create or set bonds to inclined.', 'mnemonic': '5' },
        { 'id': 'declined', 'imageFN': 'BondDown', 'helpText': 'Create or set bonds to declined.', 'mnemonic': '6' },
        { 'id': 'squig', 'imageFN': 'BondSquig', 'helpText': 'Create or set bonds to unknown stereochemistry.', 'mnemonic': '4' },
        { 'id': 'bondQAny', 'imageFN': 'BondQAny', 'helpText': 'Query bond that matches anything.' },
        { 'id': 'addtwo', 'imageFN': 'BondAddTwo', 'helpText': 'Add two new bonds to the subject atom.', 'mnemonic': 'Shift+D' },
        { 'id': 'insert', 'imageFN': 'BondInsert', 'helpText': 'Insert a methylene into the subject bond.', 'mnemonic': '' },
        { 'id': 'switch', 'imageFN': 'BondSwitch', 'helpText': 'Cycle through likely bond geometries.', 'mnemonic': '' },
        { 'id': 'rotate', 'imageFN': 'BondRotate', 'helpText': 'Rotate bond to invert substituent orientation.', 'mnemonic': '' },
        { 'id': 'linear', 'imageFN': 'BondLinear', 'helpText': 'Apply linear geometry.', 'mnemonic': 'Shift+V' },
        { 'id': 'trigonal', 'imageFN': 'BondTrigonal', 'helpText': 'Apply trigonal geometry.', 'mnemonic': 'Shift+W' },
        { 'id': 'tetra1', 'imageFN': 'BondTetra1', 'helpText': 'Apply tetrahedral geometry #1.', 'mnemonic': 'Shift+E' },
        { 'id': 'tetra2', 'imageFN': 'BondTetra2', 'helpText': 'Apply tetrahedral geometry #2.', 'mnemonic': 'Shift+R' },
        { 'id': 'sqplan', 'imageFN': 'BondSqPlan', 'helpText': 'Apply square planar geometry.', 'mnemonic': 'Shift+T' },
        { 'id': 'octa1', 'imageFN': 'BondOcta1', 'helpText': 'Apply octahedral geometry #1.', 'mnemonic': 'Shift+Y' },
        { 'id': 'octa2', 'imageFN': 'BondOcta2', 'helpText': 'Apply octahedral geometry #2.', 'mnemonic': 'Shift+U' },
        { 'id': 'metalligate', 'imageFN': 'BondMetalLigate', 'helpText': 'Arrange ligands around metal centre.', 'mnemonic': '' },
        { 'id': 'artifactpath', 'imageFN': 'BondArtifactPath', 'helpText': 'Add a path bond artifact.', 'mnemonic': '' },
        { 'id': 'artifactring', 'imageFN': 'BondArtifactRing', 'helpText': 'Add a ring bond artifact.', 'mnemonic': '' },
        { 'id': 'artifactarene', 'imageFN': 'BondArtifactArene', 'helpText': 'Add an arene bond artifact.', 'mnemonic': '' },
        { 'id': 'artifactclear', 'imageFN': 'BondArtifactClear', 'helpText': 'Remove a bond artifact.', 'mnemonic': '' },
        { 'id': 'polymer', 'imageFN': 'BondPolymer', 'helpText': 'Create a polymer block.', 'mnemonic': '' },
    ];
    const COMMANDS_SELECT = [
        { 'id': 'selgrow', 'imageFN': 'SelectionGrow', 'helpText': 'Add adjacent atoms to selection.', 'mnemonic': '' },
        { 'id': 'selshrink', 'imageFN': 'SelectionShrink', 'helpText': 'Unselect exterior atoms.', 'mnemonic': '' },
        { 'id': 'selchain', 'imageFN': 'SelectionChain', 'helpText': 'Extend selection to non-ring atoms.', 'mnemonic': '' },
        { 'id': 'smallring', 'imageFN': 'SelectionSmRing', 'helpText': 'Extend selection to small rings.', 'mnemonic': '' },
        { 'id': 'ringblock', 'imageFN': 'SelectionRingBlk', 'helpText': 'Extend selection to ring blocks.', 'mnemonic': '' },
        { 'id': 'curelement', 'imageFN': 'SelectionCurElement', 'helpText': 'Select all atoms of current element type.', 'mnemonic': '' },
        { 'id': 'selprev', 'imageFN': 'MainSelPrev', 'helpText': 'Select previous connected component.', 'mnemonic': '[' },
        { 'id': 'selnext', 'imageFN': 'MainSelNext', 'helpText': 'Select next connected component.', 'mnemonic': ']' },
        { 'id': 'toggle', 'imageFN': 'SelectionToggle', 'helpText': 'Toggle selection of current.', 'mnemonic': ',' },
        { 'id': 'uncurrent', 'imageFN': 'SelectionUncurrent', 'helpText': 'Undefine current object.', 'mnemonic': '.' },
        { 'id': 'join', 'imageFN': 'MoveJoin', 'helpText': 'Overlapping atoms will be joined as one.', 'mnemonic': '' },
        { 'id': 'new', 'imageFN': 'MainNew', 'helpText': 'Clear the molecular structure.', 'mnemonic': '' },
        { 'id': 'inline', 'imageFN': 'AtomInline', 'helpText': 'Make selected atoms into an inline abbreviation.', 'mnemonic': '/' },
        { 'id': 'formula', 'imageFN': 'AtomFormula', 'helpText': 'Make selected atoms into their molecule formula.', 'mnemonic': '\\' },
        { 'id': 'expandabbrev', 'imageFN': 'AtomExpandAbbrev', 'helpText': 'Expand out the inline abbreviation.', 'mnemonic': 'Shift+/', 'key': '/' },
        { 'id': 'clearabbrev', 'imageFN': 'AtomClearAbbrev', 'helpText': 'Remove inline abbreviation.', 'mnemonic': 'Shift+\\', 'key': '\\' },
    ];
    const COMMANDS_MOVE = [
        { 'id': 'up', 'imageFN': 'MoveUp', 'helpText': 'Move subject atoms up slightly.', 'mnemonic': 'Shift+Up', 'key': "ArrowUp" },
        { 'id': 'down', 'imageFN': 'MoveDown', 'helpText': 'Move subject atoms down slightly.', 'mnemonic': 'Shift+Down', 'key': "ArrowDown" },
        { 'id': 'left', 'imageFN': 'MoveLeft', 'helpText': 'Move subject atoms slightly to the left.', 'mnemonic': 'Shift+Left', 'key': "ArrowLeft" },
        { 'id': 'right', 'imageFN': 'MoveRight', 'helpText': 'Move subject atoms slightly to the right.', 'mnemonic': 'Shift+Right', 'key': "ArrowRight" },
        { 'id': 'uplots', 'imageFN': 'MoveUpLots', 'helpText': 'Move subject atoms up somewhat.', 'mnemonic': '' },
        { 'id': 'downlots', 'imageFN': 'MoveDownLots', 'helpText': 'Move subject atoms down somewhat.', 'mnemonic': '' },
        { 'id': 'leftlots', 'imageFN': 'MoveLeftLots', 'helpText': 'Move subject atoms somewhat to the left.', 'mnemonic': '' },
        { 'id': 'rightlots', 'imageFN': 'MoveRightLots', 'helpText': 'Move subject atoms somewhat to the right.', 'mnemonic': '' },
        { 'id': 'upfar', 'imageFN': 'MoveUpFar', 'helpText': 'Move subject atoms far up.', 'mnemonic': '' },
        { 'id': 'downfar', 'imageFN': 'MoveDownFar', 'helpText': 'Move subject atoms far down.', 'mnemonic': '' },
        { 'id': 'leftfar', 'imageFN': 'MoveLeftFar', 'helpText': 'Move subject atoms far to the left.', 'mnemonic': '' },
        { 'id': 'rightfar', 'imageFN': 'MoveRightFar', 'helpText': 'Move subject atoms far to the right.', 'mnemonic': '' },
        { 'id': 'rotp01', 'imageFN': 'MoveRotP01', 'helpText': 'Rotate 1\u00B0 counter-clockwise.', 'mnemonic': '' },
        { 'id': 'rotm01', 'imageFN': 'MoveRotM01', 'helpText': 'Rotate 1\u00B0 clockwise.', 'mnemonic': '' },
        { 'id': 'rotp05', 'imageFN': 'MoveRotP05', 'helpText': 'Rotate 5\u00B0 counter-clockwise.', 'mnemonic': '' },
        { 'id': 'rotm05', 'imageFN': 'MoveRotM05', 'helpText': 'Rotate 5\u00B0 clockwise.', 'mnemonic': '' },
        { 'id': 'rotp15', 'imageFN': 'MoveRotP15', 'helpText': 'Rotate 15\u00B0 counter-clockwise.', 'mnemonic': '' },
        { 'id': 'rotm15', 'imageFN': 'MoveRotM15', 'helpText': 'Rotate 15\u00B0 clockwise.', 'mnemonic': '' },
        { 'id': 'rotp30', 'imageFN': 'MoveRotP30', 'helpText': 'Rotate 30\u00B0 counter-clockwise.', 'mnemonic': 'Shift+[', 'key': '{' },
        { 'id': 'rotm30', 'imageFN': 'MoveRotM30', 'helpText': 'Rotate 30\u00B0 clockwise.', 'mnemonic': 'Shift+]', 'key': '}' },
        { 'id': 'hflip', 'imageFN': 'MoveHFlip', 'helpText': 'Flip subject atoms horizontally.', 'mnemonic': 'Shift+,', 'key': ',' },
        { 'id': 'vflip', 'imageFN': 'MoveVFlip', 'helpText': 'Flip subject atoms vertically.', 'mnemonic': 'Shift+.', 'key': '.' },
        { 'id': 'shrink', 'imageFN': 'MoveShrink', 'helpText': 'Decrease subject bond distances.', 'mnemonic': 'Shift+Z' },
        { 'id': 'grow', 'imageFN': 'MoveGrow', 'helpText': 'Increase subject bond distances.', 'mnemonic': 'Shift+X' },
    ];
    class CommandBank extends WebMolKit.ButtonBank {
        constructor(owner, cmdType = CommandType.Main) {
            super();
            this.owner = owner;
            this.cmdType = cmdType;
        }
        update() {
            if (this.cmdType == CommandType.Main)
                for (let btn of COMMANDS_MAIN)
                    this.buttons.push(btn);
            else if (this.cmdType == CommandType.Atom)
                for (let btn of COMMANDS_ATOM)
                    this.buttons.push(btn);
            else if (this.cmdType == CommandType.Bond)
                for (let btn of COMMANDS_BOND)
                    this.buttons.push(btn);
            else if (this.cmdType == CommandType.Select)
                for (let btn of COMMANDS_SELECT)
                    this.buttons.push(btn);
            else if (this.cmdType == CommandType.Move)
                for (let btn of COMMANDS_MOVE)
                    this.buttons.push(btn);
            else if (this.cmdType == CommandType.Abbrev)
                this.populateElements(ELEMENTS_ABBREV);
            else if (this.cmdType == CommandType.SBlock)
                this.populateElements(ELEMENTS_S_BLOCK);
            else if (this.cmdType == CommandType.PBlock)
                this.populateElements(ELEMENTS_P_BLOCK);
            else if (this.cmdType == CommandType.DBlock)
                this.populateElements(ELEMENTS_D_BLOCK);
            else if (this.cmdType == CommandType.FBlock)
                this.populateElements(ELEMENTS_F_BLOCK);
            else if (this.cmdType == CommandType.Noble)
                this.populateElements(ELEMENTS_NOBLE);
        }
        populateElements(elements) {
            for (let el of elements) {
                this.buttons.push({ 'id': `element:${el}`, 'text': el, 'helpText': `Change elements to ${el}.` });
            }
        }
        hitButton(id) {
            let actv = 0, param = null;
            if (id.startsWith('element:')) {
                let el = id.substring(8);
                actv = WebMolKit.ActivityType.Element;
                param = { 'element': el };
            }
            else if (id == 'delete')
                actv = WebMolKit.ActivityType.Delete;
            else if (id == 'undo') {
                if (this.owner.canUndo())
                    this.owner.performUndo();
                else
                    this.owner.showMessage('Nothing to undo.');
            }
            else if (id == 'redo') {
                if (this.owner.canRedo())
                    this.owner.performRedo();
                else
                    this.owner.showMessage('Nothing to redo.');
            }
            else if (id == 'cut')
                actv = WebMolKit.ActivityType.Cut;
            else if (id == 'copy')
                actv = WebMolKit.ActivityType.Copy;
            else if (id == 'paste')
                this.owner.performPaste();
            else if (id == 'new')
                actv = WebMolKit.ActivityType.Clear;
            else if (id == 'zoomfit')
                this.owner.autoScale();
            else if (id == 'zoomout')
                this.owner.zoom(0.8);
            else if (id == 'zoomin')
                this.owner.zoom(1.25);
            else if (id == 'selall')
                actv = WebMolKit.ActivityType.SelectAll;
            else if (id == 'selnone')
                actv = WebMolKit.ActivityType.SelectNone;
            else if (id == 'selprev')
                actv = WebMolKit.ActivityType.SelectPrevComp;
            else if (id == 'selnext')
                actv = WebMolKit.ActivityType.SelectNextComp;
            else if (id == 'selside')
                actv = WebMolKit.ActivityType.SelectSide;
            else if (id == 'plus') {
                actv = WebMolKit.ActivityType.Charge;
                param = { 'delta': 1 };
            }
            else if (id == 'minus') {
                actv = WebMolKit.ActivityType.Charge;
                param = { 'delta': -1 };
            }
            else if (id == 'one') {
                actv = WebMolKit.ActivityType.BondOrder;
                param = { 'order': 1 };
            }
            else if (id == 'two') {
                actv = WebMolKit.ActivityType.BondOrder;
                param = { 'order': 2 };
            }
            else if (id == 'three') {
                actv = WebMolKit.ActivityType.BondOrder;
                param = { 'order': 3 };
            }
            else if (id == 'four') {
                actv = WebMolKit.ActivityType.BondOrder;
                param = { 'order': 4 };
            }
            else if (id == 'zero') {
                actv = WebMolKit.ActivityType.BondOrder;
                param = { 'order': 0 };
            }
            else if (id == 'inclined') {
                actv = WebMolKit.ActivityType.BondType;
                param = { 'type': WebMolKit.Molecule.BONDTYPE_INCLINED };
            }
            else if (id == 'declined') {
                actv = WebMolKit.ActivityType.BondType;
                param = { 'type': WebMolKit.Molecule.BONDTYPE_DECLINED };
            }
            else if (id == 'squig') {
                actv = WebMolKit.ActivityType.BondType;
                param = { 'type': WebMolKit.Molecule.BONDTYPE_UNKNOWN };
            }
            else if (id == 'linear') {
                actv = WebMolKit.ActivityType.BondGeom;
                param = { 'geom': WebMolKit.Geometry.Linear };
            }
            else if (id == 'trigonal') {
                actv = WebMolKit.ActivityType.BondGeom;
                param = { 'geom': WebMolKit.Geometry.Trigonal };
            }
            else if (id == 'tetra1') {
                actv = WebMolKit.ActivityType.BondGeom;
                param = { 'geom': WebMolKit.Geometry.Tetra1 };
            }
            else if (id == 'tetra2') {
                actv = WebMolKit.ActivityType.BondGeom;
                param = { 'geom': WebMolKit.Geometry.Tetra2 };
            }
            else if (id == 'sqplan') {
                actv = WebMolKit.ActivityType.BondGeom;
                param = { 'geom': WebMolKit.Geometry.SqPlan };
            }
            else if (id == 'octa1') {
                actv = WebMolKit.ActivityType.BondGeom;
                param = { 'geom': WebMolKit.Geometry.Octa1 };
            }
            else if (id == 'octa2') {
                actv = WebMolKit.ActivityType.BondGeom;
                param = { 'geom': WebMolKit.Geometry.Octa2 };
            }
            else if (id == 'switch')
                actv = WebMolKit.ActivityType.BondSwitch;
            else if (id == 'rotate')
                actv = WebMolKit.ActivityType.BondRotate;
            else if (id == 'connect')
                actv = WebMolKit.ActivityType.Connect;
            else if (id == 'disconnect')
                actv = WebMolKit.ActivityType.Disconnect;
            else if (id == 'metalligate')
                actv = WebMolKit.ActivityType.MetalLigate;
            else if (id == 'artifactpath')
                actv = WebMolKit.ActivityType.BondArtifactPath;
            else if (id == 'artifactring')
                actv = WebMolKit.ActivityType.BondArtifactRing;
            else if (id == 'artifactarene')
                actv = WebMolKit.ActivityType.BondArtifactArene;
            else if (id == 'artifactclear')
                actv = WebMolKit.ActivityType.BondArtifactClear;
            else if (id == 'polymer')
                actv = WebMolKit.ActivityType.PolymerBlock;
            else if (id == 'addtwo')
                actv = WebMolKit.ActivityType.BondAddTwo;
            else if (id == 'insert')
                actv = WebMolKit.ActivityType.BondInsert;
            else if (id == 'curelement')
                actv = WebMolKit.ActivityType.SelectCurElement;
            else if (id == 'selgrow')
                actv = WebMolKit.ActivityType.SelectGrow;
            else if (id == 'selshrink')
                actv = WebMolKit.ActivityType.SelectShrink;
            else if (id == 'selprev')
                actv = WebMolKit.ActivityType.SelectPrevComp;
            else if (id == 'selnext')
                actv = WebMolKit.ActivityType.SelectNextComp;
            else if (id == 'selchain')
                actv = WebMolKit.ActivityType.SelectChain;
            else if (id == 'smallring')
                actv = WebMolKit.ActivityType.SelectSmRing;
            else if (id == 'ringblock')
                actv = WebMolKit.ActivityType.SelectRingBlk;
            else if (id == 'toggle')
                actv = WebMolKit.ActivityType.SelectToggle;
            else if (id == 'uncurrent')
                actv = WebMolKit.ActivityType.SelectUnCurrent;
            else if (id == 'join')
                actv = WebMolKit.ActivityType.Join;
            else if (id == 'inline')
                actv = WebMolKit.ActivityType.AbbrevGroup;
            else if (id == 'formula')
                actv = WebMolKit.ActivityType.AbbrevFormula;
            else if (id == 'clearabbrev')
                actv = WebMolKit.ActivityType.AbbrevClear;
            else if (id == 'expandabbrev')
                actv = WebMolKit.ActivityType.AbbrevExpand;
            else if (id == 'up') {
                actv = WebMolKit.ActivityType.Nudge;
                param = { 'dir': 'up' };
            }
            else if (id == 'down') {
                actv = WebMolKit.ActivityType.Nudge;
                param = { 'dir': 'down' };
            }
            else if (id == 'left') {
                actv = WebMolKit.ActivityType.Nudge;
                param = { 'dir': 'left' };
            }
            else if (id == 'right') {
                actv = WebMolKit.ActivityType.Nudge;
                param = { 'dir': 'right' };
            }
            else if (id == 'uplots') {
                actv = WebMolKit.ActivityType.NudgeLots;
                param = { 'dir': 'up' };
            }
            else if (id == 'downlots') {
                actv = WebMolKit.ActivityType.NudgeLots;
                param = { 'dir': 'down' };
            }
            else if (id == 'leftlots') {
                actv = WebMolKit.ActivityType.NudgeLots;
                param = { 'dir': 'left' };
            }
            else if (id == 'rightlots') {
                actv = WebMolKit.ActivityType.NudgeLots;
                param = { 'dir': 'right' };
            }
            else if (id == 'upfar') {
                actv = WebMolKit.ActivityType.NudgeFar;
                param = { 'dir': 'up' };
            }
            else if (id == 'downfar') {
                actv = WebMolKit.ActivityType.NudgeFar;
                param = { 'dir': 'down' };
            }
            else if (id == 'leftfar') {
                actv = WebMolKit.ActivityType.NudgeFar;
                param = { 'dir': 'left' };
            }
            else if (id == 'rightfar') {
                actv = WebMolKit.ActivityType.NudgeFar;
                param = { 'dir': 'right' };
            }
            else if (id == 'rotp01') {
                actv = WebMolKit.ActivityType.Rotate;
                param = { 'theta': 1 };
            }
            else if (id == 'rotm01') {
                actv = WebMolKit.ActivityType.Rotate;
                param = { 'theta': -1 };
            }
            else if (id == 'rotp05') {
                actv = WebMolKit.ActivityType.Rotate;
                param = { 'theta': 5 };
            }
            else if (id == 'rotm05') {
                actv = WebMolKit.ActivityType.Rotate;
                param = { 'theta': -5 };
            }
            else if (id == 'rotp15') {
                actv = WebMolKit.ActivityType.Rotate;
                param = { 'theta': 15 };
            }
            else if (id == 'rotm15') {
                actv = WebMolKit.ActivityType.Rotate;
                param = { 'theta': -15 };
            }
            else if (id == 'rotp30') {
                actv = WebMolKit.ActivityType.Rotate;
                param = { 'theta': 30 };
            }
            else if (id == 'rotm30') {
                actv = WebMolKit.ActivityType.Rotate;
                param = { 'theta': -30 };
            }
            else if (id == 'hflip') {
                actv = WebMolKit.ActivityType.Flip;
                param = { 'axis': 'hor' };
            }
            else if (id == 'vflip') {
                actv = WebMolKit.ActivityType.Flip;
                param = { 'axis': 'ver' };
            }
            else if (id == 'shrink') {
                actv = WebMolKit.ActivityType.Scale;
                param = { 'mag': 1 / 1.1 };
            }
            else if (id == 'grow') {
                actv = WebMolKit.ActivityType.Scale;
                param = { 'mag': 1.1 };
            }
            else if (id == 'bondQAny')
                actv = WebMolKit.ActivityType.QueryBondAny;
            else if (id == 'atom')
                this.buttonView.pushBank(new CommandBank(this.owner, CommandType.Atom));
            else if (id == 'bond')
                this.buttonView.pushBank(new CommandBank(this.owner, CommandType.Bond));
            else if (id == 'select')
                this.buttonView.pushBank(new CommandBank(this.owner, CommandType.Select));
            else if (id == 'move')
                this.buttonView.pushBank(new CommandBank(this.owner, CommandType.Move));
            else if (id == 'abbrev')
                this.buttonView.pushBank(new CommandBank(this.owner, CommandType.Abbrev));
            else if (id == 'sblock')
                this.buttonView.pushBank(new CommandBank(this.owner, CommandType.SBlock));
            else if (id == 'pblock')
                this.buttonView.pushBank(new CommandBank(this.owner, CommandType.PBlock));
            else if (id == 'dblock')
                this.buttonView.pushBank(new CommandBank(this.owner, CommandType.DBlock));
            else if (id == 'fblock')
                this.buttonView.pushBank(new CommandBank(this.owner, CommandType.FBlock));
            else if (id == 'noble')
                this.buttonView.pushBank(new CommandBank(this.owner, CommandType.Noble));
            else
                alert('Unhandled command: "' + id + '"');
            if (actv > 0) {
                new WebMolKit.MoleculeActivity(this.owner.getState(), actv, param, this.owner).execute();
            }
        }
        claimKey(event) {
            for (let listItems of [COMMANDS_MAIN, COMMANDS_ATOM, COMMANDS_BOND, COMMANDS_SELECT, COMMANDS_MOVE])
                for (let item of listItems) {
                    if (WebMolKit.ButtonBank.matchKey(event, item.mnemonic, item.key)) {
                        this.hitButton(item.id);
                        return true;
                    }
                }
            return false;
        }
    }
    WebMolKit.CommandBank = CommandBank;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class ContextSketch {
        constructor(state, sketcher, proxyClip) {
            this.state = state;
            this.sketcher = sketcher;
            this.proxyClip = proxyClip;
        }
        populate() {
            const { state, sketcher } = this;
            let menu = [];
            if (sketcher.canUndo() || sketcher.canRedo()) {
                if (sketcher.canUndo())
                    menu.push({ 'label': 'Undo', 'accelerator': 'CmdOrCtrl+Z', 'click': () => sketcher.performUndo() });
                if (sketcher.canRedo())
                    menu.push({ 'label': 'Redo', 'accelerator': 'CmdOrCtrl+Shift+Z', 'click': () => sketcher.performRedo() });
                menu.push(null);
            }
            if (state.currentAtom > 0 || state.currentBond > 0)
                menu.push({ 'label': 'Edit', 'accelerator': 'Enter', 'click': () => sketcher.editCurrent() });
            this.maybeAppend(menu, 'Delete', 'D', WebMolKit.ActivityType.Delete);
            this.maybeAppend(menu, 'Cut', 'CmdOrCtrl+X', WebMolKit.ActivityType.Cut);
            this.maybeAppend(menu, 'Copy', 'CmdOrCtrl+C', WebMolKit.ActivityType.Copy);
            if (this.proxyClip.canAlwaysGet())
                menu.push({ 'label': 'Paste', 'accelerator': 'CmdOrCtrl+V', 'click': () => sketcher.performPaste() });
            this.maybeAppend(menu, 'Charge +', 'Shift+=', WebMolKit.ActivityType.Charge, { 'delta': 1 });
            this.maybeAppend(menu, 'Charge -', 'Shift+-', WebMolKit.ActivityType.Charge, { 'delta': -1 });
            this.maybeAppend(menu, 'Bond Order 0', '0', WebMolKit.ActivityType.BondOrder, { 'order': 0 });
            this.maybeAppend(menu, 'Bond Order 1', '1', WebMolKit.ActivityType.BondOrder, { 'order': 1 });
            this.maybeAppend(menu, 'Bond Order 2', '2', WebMolKit.ActivityType.BondOrder, { 'order': 2 });
            this.maybeAppend(menu, 'Bond Order 3', '3', WebMolKit.ActivityType.BondOrder, { 'order': 3 });
            this.maybeAppend(menu, 'Bond Order 4', null, WebMolKit.ActivityType.BondOrder, { 'order': 4 });
            this.maybeAppend(menu, 'Unknown Stereochemistry', '4', WebMolKit.ActivityType.BondType, { 'type': WebMolKit.Molecule.BONDTYPE_UNKNOWN });
            this.maybeAppend(menu, 'Bond Wedge Up', '5', WebMolKit.ActivityType.BondType, { 'type': WebMolKit.Molecule.BONDTYPE_INCLINED });
            this.maybeAppend(menu, 'Bond Wedge Down', '6', WebMolKit.ActivityType.BondType, { 'type': WebMolKit.Molecule.BONDTYPE_DECLINED });
            this.maybeAppend(menu, 'Switch Geometry', null, WebMolKit.ActivityType.BondSwitch);
            this.maybeAppend(menu, 'Add Two Bonds', 'Shift+D', WebMolKit.ActivityType.BondAddTwo);
            this.maybeAppend(menu, 'Insert Atom', null, WebMolKit.ActivityType.BondInsert);
            this.maybeAppend(menu, 'Join Atoms', null, WebMolKit.ActivityType.Join);
            this.maybeAppend(menu, 'Abbreviate Group', '/', WebMolKit.ActivityType.AbbrevGroup);
            this.maybeAppend(menu, 'Abbreviate Formula', '\\', WebMolKit.ActivityType.AbbrevFormula);
            this.maybeAppend(menu, 'Clear Abbreviation', 'Shift+\\', WebMolKit.ActivityType.AbbrevClear);
            this.maybeAppend(menu, 'Expand Abbreviation', 'Shift+/', WebMolKit.ActivityType.AbbrevExpand);
            let rotateSub = this.rotateSubMenu();
            if (WebMolKit.Vec.notBlank(rotateSub))
                menu.push({ 'label': 'Rotate', 'subMenu': rotateSub });
            let querySub = this.querySubMenu();
            if (WebMolKit.Vec.notBlank(querySub))
                menu.push({ 'label': 'Query', 'subMenu': querySub });
            let poly = new WebMolKit.PolymerBlock(state.mol);
            for (let units of poly.getUnits()) {
                let a1 = state.currentAtom, a2 = 0;
                if (state.currentBond > 0)
                    [a1, a2] = state.mol.bondFromTo(state.currentBond);
                if (units.atoms.includes(a1) || units.atoms.includes(a2)) {
                    let label = 'Polymer Block (' + units.atoms.length + ' atom' + (units.atoms.length == 1 ? '' : 's') + ')';
                    menu.push({ 'label': label, 'click': () => sketcher.performPolymerBlock(units.atoms) });
                }
            }
            if (menu.length > 0)
                menu.push(null);
            menu.push({ 'label': 'Scale to Fit', 'click': () => sketcher.autoScale() });
            menu.push({ 'label': 'Zoom In', 'accelerator': '=', 'click': () => sketcher.zoom(1.25) });
            menu.push({ 'label': 'Zoom Out', 'accelerator': '-', 'click': () => sketcher.zoom(0.8) });
            return menu;
        }
        maybeAppend(menu, title, accelerator, activ, param = null) {
            let molact = new WebMolKit.MoleculeActivity(this.state, activ, param);
            molact.execute();
            if (!molact.output.mol && !molact.toClipboard)
                return;
            menu.push({ 'label': title, 'accelerator': accelerator, 'click': () => {
                    this.sketcher.setState(molact.output, true);
                    if (molact.toClipboard)
                        this.proxyClip.setString(molact.toClipboard);
                } });
        }
        rotateSubMenu() {
            let menu = [];
            this.maybeAppend(menu, 'Bond', null, WebMolKit.ActivityType.BondRotate);
            this.maybeAppend(menu, '+1 \u{00B0}', null, WebMolKit.ActivityType.Rotate, { 'theta': 1 });
            this.maybeAppend(menu, '-1 \u{00B0}', null, WebMolKit.ActivityType.Rotate, { 'theta': -1 });
            this.maybeAppend(menu, '+5 \u{00B0}', null, WebMolKit.ActivityType.Rotate, { 'theta': 5 });
            this.maybeAppend(menu, '-5 \u{00B0}', null, WebMolKit.ActivityType.Rotate, { 'theta': -5 });
            this.maybeAppend(menu, '+15 \u{00B0}', null, WebMolKit.ActivityType.Rotate, { 'theta': 15 });
            this.maybeAppend(menu, '-15 \u{00B0}', null, WebMolKit.ActivityType.Rotate, { 'theta': -15 });
            this.maybeAppend(menu, '+30 \u{00B0}', 'Shift+[', WebMolKit.ActivityType.Rotate, { 'theta': 30 });
            this.maybeAppend(menu, '-30 \u{00B0}', 'Shift+]', WebMolKit.ActivityType.Rotate, { 'theta': -30 });
            this.maybeAppend(menu, 'H-Flip', 'Shift+,', WebMolKit.ActivityType.Flip, { 'axis': 'hor' });
            this.maybeAppend(menu, 'V-Flip', 'Shift+.', WebMolKit.ActivityType.Flip, { 'axis': 'ver' });
            return menu;
        }
        querySubMenu() {
            let menu = [];
            this.maybeAppend(menu, 'Clear', null, WebMolKit.ActivityType.QueryClear);
            this.maybeAppend(menu, 'Copy', null, WebMolKit.ActivityType.QueryCopy);
            return menu;
        }
    }
    WebMolKit.ContextSketch = ContextSketch;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class Widget {
        constructor() {
            this.tagType = 'div';
            this.domContent = null;
        }
        get content() { return $(this.domContent.el); }
        get contentDOM() { return this.domContent; }
        render(parent) {
            if (parent.jquery)
                parent = parent[0];
            let tag = this.tagType;
            this.domContent = WebMolKit.dom(`<${tag}/>`).appendTo(parent);
        }
        remove() {
            if (this.domContent)
                this.domContent.remove();
            this.domContent = null;
        }
        addTooltip(bodyHTML, titleHTML) {
            WebMolKit.addTooltip(this.content, bodyHTML, titleHTML);
        }
    }
    WebMolKit.Widget = Widget;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let DraggingTool;
    (function (DraggingTool) {
        DraggingTool[DraggingTool["None"] = 0] = "None";
        DraggingTool[DraggingTool["Press"] = 1] = "Press";
        DraggingTool[DraggingTool["Lasso"] = 2] = "Lasso";
        DraggingTool[DraggingTool["Pan"] = 3] = "Pan";
        DraggingTool[DraggingTool["Zoom"] = 4] = "Zoom";
        DraggingTool[DraggingTool["Rotate"] = 5] = "Rotate";
        DraggingTool[DraggingTool["Move"] = 6] = "Move";
        DraggingTool[DraggingTool["Erasor"] = 7] = "Erasor";
        DraggingTool[DraggingTool["Atom"] = 8] = "Atom";
        DraggingTool[DraggingTool["Bond"] = 9] = "Bond";
        DraggingTool[DraggingTool["Charge"] = 10] = "Charge";
        DraggingTool[DraggingTool["Ring"] = 11] = "Ring";
    })(DraggingTool = WebMolKit.DraggingTool || (WebMolKit.DraggingTool = {}));
    let DrawCanvasDecoration;
    (function (DrawCanvasDecoration) {
        DrawCanvasDecoration[DrawCanvasDecoration["None"] = 0] = "None";
        DrawCanvasDecoration[DrawCanvasDecoration["Stereochemistry"] = 1] = "Stereochemistry";
        DrawCanvasDecoration[DrawCanvasDecoration["MappingNumber"] = 2] = "MappingNumber";
        DrawCanvasDecoration[DrawCanvasDecoration["AtomIndex"] = 3] = "AtomIndex";
    })(DrawCanvasDecoration = WebMolKit.DrawCanvasDecoration || (WebMolKit.DrawCanvasDecoration = {}));
    class DrawCanvas extends WebMolKit.Widget {
        constructor() {
            super();
            this.mol = null;
            this.policy = null;
            this.offsetX = 0;
            this.offsetY = 0;
            this.pointScale = 1;
            this.viewOpt = {
                'decoration': DrawCanvasDecoration.Stereochemistry,
                'showOxState': true,
                'showQuery': true,
                'showArtifacts': true,
            };
            this.width = 0;
            this.height = 0;
            this.border = 0x808080;
            this.borderRadius = 4;
            this.background = 0xF8F8F8;
            this.canvasUnder = null;
            this.canvasMolecule = null;
            this.canvasOver = null;
            this.divMessage = null;
            this.layout = null;
            this.metavec = null;
            this.stereo = null;
            this.guidelines = null;
            this.filthy = false;
            this.dragType = DraggingTool.None;
            this.currentAtom = 0;
            this.currentBond = 0;
            this.hoverAtom = 0;
            this.hoverBond = 0;
            this.selectedMask = null;
            this.opAtom = 0;
            this.opBond = 0;
            this.opBudged = false;
            this.opShift = false;
            this.opCtrl = false;
            this.opAlt = false;
            this.lassoX = null;
            this.lassoY = null;
            this.lassoMask = null;
            this.clickX = 0;
            this.clickY = 0;
            this.mouseX = 0;
            this.mouseY = 0;
            this.dragGuides = null;
            this.templatePerms = null;
            this.currentPerm = 0;
            this.fusionBank = null;
            this.cursorWatermark = 0;
            this.cursorDX = 0;
            this.cursorDY = 0;
            this.toolAtomSymbol = '';
            this.toolBondOrder = 0;
            this.toolBondType = 0;
            this.toolChargeDelta = 0;
            this.toolRingArom = false;
            this.toolRingFreeform = false;
            this.toolRotateIncr = 0;
            this.redrawCacheKey = '';
            this.abbrevPolicy = WebMolKit.RenderPolicy.defaultBlackOnWhite();
            this.abbrevPolicy.data.foreground = 0xD0D0D0;
            this.abbrevPolicy.data.atomCols = WebMolKit.Vec.numberArray(0xD0D0D0, this.abbrevPolicy.data.atomCols.length);
        }
        render(parent) {
            if (!this.width || !this.height)
                throw 'Sketcher.render called without width and height';
            super.render(parent);
            this.container = WebMolKit.dom('<div/>').appendTo(this.contentDOM);
            this.container.css({ 'position': 'relative', 'width': this.width + 'px', 'height': this.height + 'px' });
            this.container.css({ 'background-color': WebMolKit.colourCanvas(this.background) });
            if (this.border != WebMolKit.MetaVector.NOCOLOUR) {
                this.container.css({ 'border': '1px solid ' + WebMolKit.colourCanvas(this.border) });
                this.container.css({ 'border-radius': this.borderRadius + 'px' });
            }
            this.container.css({ 'outline': 'none' });
            this.container.attr({ 'tabindex': '0' });
            let canvasStyle = { 'position': 'absolute', 'left': '0', 'top': '0', 'width': `${this.width}px`, 'height': `${this.height}`, 'pointer-events': 'none' };
            this.divInfo = WebMolKit.dom('<div/>').appendTo(this.container).css({ 'position': 'absolute', 'left': '0', 'top': '0', 'pointer-events': 'none' });
            this.canvasUnder = WebMolKit.dom('<canvas/>').appendTo(this.container).css(canvasStyle);
            this.canvasMolecule = WebMolKit.dom('<canvas/>').appendTo(this.container).css(canvasStyle);
            this.canvasOver = WebMolKit.dom('<canvas/>').appendTo(this.container).css(canvasStyle);
            this.divMessage = WebMolKit.dom('<div/>').appendTo(this.container).css(canvasStyle);
            this.divMessage.css({ 'text-align': 'center', 'vertical-align': 'middle', 'font-weight': 'bold', 'font-size': '120%' });
        }
        getState() {
            let state = {
                'mol': this.mol.clone(),
                'currentAtom': this.currentAtom,
                'currentBond': this.currentBond,
                'selectedMask': this.selectedMask == null ? null : this.selectedMask.slice(0)
            };
            return state;
        }
        getSelected(atom) {
            if (this.selectedMask == null || atom > this.selectedMask.length)
                return false;
            return this.selectedMask[atom - 1];
        }
        getLassoed(atom) {
            if (this.lassoMask == null || atom > this.lassoMask.length)
                return false;
            return this.lassoMask[atom - 1];
        }
        scale() { return this.pointScale; }
        angToX(ax) {
            return ax * this.pointScale + this.offsetX;
        }
        angToY(ay) {
            return ay * -this.pointScale + this.offsetY;
        }
        xToAng(px) {
            return (px - this.offsetX) / this.pointScale;
        }
        yToAng(py) {
            return (py - this.offsetY) / -this.pointScale;
        }
        scaleToAng(scale) { return scale / this.pointScale; }
        angToScale(ang) { return ang * this.pointScale; }
        yIsUp() { return false; }
        measureText(str, fontSize) { return WebMolKit.FontData.main.measureText(str, fontSize); }
        delayedRedraw() {
            if (this.canvasMolecule == null)
                return;
            this.filthy = true;
            window.setTimeout(() => { if (this.filthy)
                this.redraw(); }, 10);
        }
        layoutMolecule() {
            let mol = this.mol;
            if (this.hoverAtom > 0 && WebMolKit.MolUtil.hasAbbrev(mol, this.hoverAtom)) {
                mol = mol.clone();
                mol.setAtomElement(this.hoverAtom, '');
                mol.setAtomCharge(this.hoverAtom, 0);
                mol.setAtomUnpaired(this.hoverAtom, 0);
                WebMolKit.MolUtil.clearAbbrev(mol, this.hoverAtom);
            }
            let effects = this.sketchEffects(mol);
            this.layout = new WebMolKit.ArrangeMolecule(mol, this, this.policy, effects);
            this.layout.setWantArtifacts(this.viewOpt.showArtifacts);
            this.layout.arrange();
        }
        redrawMetaVector() {
            this.metavec = new WebMolKit.MetaVector();
            new WebMolKit.DrawMolecule(this.layout, this.metavec).draw();
            if (this.hoverAtom > 0 && WebMolKit.MolUtil.hasAbbrev(this.mol, this.hoverAtom)) {
                let abbrevMol = WebMolKit.MolUtil.getAbbrev(this.mol, this.hoverAtom);
                this.orientAbbreviation(this.hoverAtom, abbrevMol);
                this.abbrevPolicy.data.pointScale = this.policy.data.pointScale;
                let layout = new WebMolKit.ArrangeMolecule(abbrevMol, this, this.abbrevPolicy, new WebMolKit.RenderEffects());
                layout.arrange();
                new WebMolKit.DrawMolecule(layout, this.metavec).draw();
            }
        }
        redraw() {
            this.filthy = false;
            this.redrawInfo();
            this.redrawUnder();
            this.redrawMolecule();
            this.redrawOver();
        }
        redrawInfo() {
            let cacheKey = JSON.stringify([this.width, this.height, this.mol.toString()]);
            if (cacheKey == this.redrawCacheKey)
                return;
            this.redrawCacheKey = cacheKey;
            this.divInfo.empty();
            this.divInfo.css({ 'visibility': 'hidden', 'left': '0', 'top': '0' });
            if (this.mol.numAtoms == 0)
                return;
            let divText = WebMolKit.dom('<div/>').appendTo(this.divInfo);
            divText.css({ 'display': 'inline-block', 'text-align': 'right', 'font-family': 'sans-serif', 'font-size': '80%', 'color': '#C0C0C0' });
            let html = WebMolKit.MolUtil.molecularFormula(this.mol, ['<sub>', '</sub>', '<sup>', '</sup>']);
            let chg = 0;
            for (let n = 1; n <= this.mol.numAtoms; n++)
                chg += this.mol.atomCharge(n);
            if (chg == -1)
                html += '<sup>-</sup>';
            else if (chg < -1)
                html += `<sup>${chg}</sup>`;
            else if (chg == 1)
                html += '<sup>+</sup>';
            else if (chg > 1)
                html += `<sup>+${chg}</sup>`;
            html += '<br>' + WebMolKit.MolUtil.molecularWeight(this.mol).toFixed(2);
            divText.setHTML(html);
            setTimeout(() => {
                let w = divText.width(), h = divText.height();
                WebMolKit.setBoundaryPixels(this.divInfo, this.width - w - 1, 1, w, h);
                this.divInfo.css({ 'visibility': 'visible' });
            }, 1);
        }
        redrawUnder() {
            let HOVER_COL = 0xE0E0E0;
            let CURRENT_COL = 0xA0A0A0, CURRENT_BORD = 0x808080;
            let SELECT_COL = 0xC0C0C0;
            let LASSO_COL = 0xD0D0D0;
            let density = WebMolKit.pixelDensity();
            this.canvasUnder.elCanvas.width = this.width * density;
            this.canvasUnder.elCanvas.height = this.height * density;
            this.canvasUnder.css({ 'width': `${this.width}px`, 'height': `${this.height}px` });
            let ctx = this.canvasUnder.elCanvas.getContext('2d');
            ctx.save();
            ctx.scale(density, density);
            ctx.clearRect(0, 0, this.width, this.height);
            if (this.hoverAtom > 0) {
                let units = new WebMolKit.PolymerBlock(this.mol).getUnits();
                for (let unit of units)
                    if (unit.atoms.includes(this.hoverAtom))
                        this.drawPolymerUnit(ctx, unit, units);
                let sz = 0;
                if (this.hoverAtom == this.currentAtom)
                    sz += 0.1;
                if (this.getSelected(this.hoverAtom))
                    sz += 0.1;
                if (this.currentBond > 0 && (this.mol.bondFrom(this.currentBond) == this.hoverAtom || this.mol.bondTo(this.currentBond) == this.hoverAtom))
                    sz += 0.1;
                this.drawAtomShade(ctx, this.hoverAtom, HOVER_COL, -1, sz);
            }
            if (this.hoverBond > 0) {
                let bfr = this.mol.bondFrom(this.hoverBond), bto = this.mol.bondTo(this.hoverBond);
                let units = new WebMolKit.PolymerBlock(this.mol).getUnits();
                for (let unit of units)
                    if (unit.atoms.includes(bfr) && unit.atoms.includes(bto))
                        this.drawPolymerUnit(ctx, unit, units);
                let sz = 0;
                if (this.hoverBond == this.currentBond)
                    sz += 0.1;
                if (this.getSelected(bfr) && this.getSelected(bto))
                    sz += 0.1;
                this.drawBondShade(ctx, this.hoverBond, HOVER_COL, -1, sz);
            }
            for (let n = 1; n <= this.mol.numBonds; n++) {
                let sz = n == this.currentBond ? 0.1 : 0;
                let bfr = this.mol.bondFrom(n), bto = this.mol.bondTo(n);
                let sfr = this.getSelected(bfr), sto = this.getSelected(bto), lfr = this.getLassoed(bfr), lto = this.getLassoed(bto);
                if (sfr && sto)
                    this.drawBondShade(ctx, n, SELECT_COL, -1, sz);
                else if ((sfr || lfr) && (sto || lto))
                    this.drawBondShade(ctx, n, LASSO_COL, -1, sz);
            }
            for (let n = 1; n <= this.mol.numAtoms; n++) {
                let sz = this.currentAtom == n ? 0.1 : 0;
                if (this.getSelected(n))
                    this.drawAtomShade(ctx, n, SELECT_COL, -1, sz);
                else if (this.getLassoed(n))
                    this.drawAtomShade(ctx, n, LASSO_COL, -1, sz);
            }
            if (this.currentAtom > 0) {
                this.drawAtomShade(ctx, this.currentAtom, CURRENT_COL, CURRENT_BORD, 0);
            }
            if (this.currentBond > 0) {
                let bfr = this.mol.bondFrom(this.currentBond), bto = this.mol.bondTo(this.currentBond);
                this.drawBondShade(ctx, this.currentBond, CURRENT_COL, CURRENT_BORD, 0);
            }
            if (this.dragType == DraggingTool.Move || (this.dragType == DraggingTool.Atom && this.opAtom > 0) || this.dragType == DraggingTool.Bond) {
                if (this.dragGuides != null && this.dragGuides.length > 0) {
                    for (let g of this.dragGuides)
                        for (let n = 0; n < g.x.length; n++) {
                            let lw = this.policy.data.lineSize * this.pointScale;
                            ctx.strokeStyle = '#C0C0C0';
                            ctx.lineWidth = lw;
                            WebMolKit.drawLine(ctx, g.sourceX, g.sourceY, g.destX[n], g.destY[n]);
                            ctx.beginPath();
                            ctx.ellipse(g.destX[n], g.destY[n], 2 * lw, 2 * lw, 0, 0, WebMolKit.TWOPI, false);
                            ctx.fillStyle = '#C0C0C0';
                            ctx.fill();
                        }
                }
            }
            if (this.dragType == DraggingTool.Ring) {
                let [ringX, ringY] = this.determineFauxRing();
                let rsz = ringX == null ? 0 : ringX.length;
                if (rsz > 0) {
                    let scale = this.pointScale;
                    let lw = this.policy.data.lineSize * scale;
                    ctx.strokeStyle = '#C0C0C0';
                    ctx.lineWidth = lw;
                    for (let n = 0; n < rsz; n++) {
                        let nn = n < rsz - 1 ? n + 1 : 0;
                        let x1 = this.angToX(ringX[n]), y1 = this.angToY(ringY[n]);
                        let x2 = this.angToX(ringX[nn]), y2 = this.angToY(ringY[nn]);
                        WebMolKit.drawLine(ctx, x1, y1, x2, y2);
                    }
                    if (this.toolRingArom) {
                        let cx = 0, cy = 0;
                        for (let n = 0; n < rsz; n++) {
                            cx += ringX[n];
                            cy += ringY[n];
                        }
                        cx /= rsz;
                        cy /= rsz;
                        let rad = 0;
                        for (let n = 0; n < rsz; n++)
                            rad += WebMolKit.norm_xy(ringX[n] - cx, ringY[n] - cy);
                        rad = this.angToScale(rad * 0.5 / rsz);
                        ctx.beginPath();
                        ctx.ellipse(this.angToX(cx), this.angToY(cy), rad, rad, 0, 0, WebMolKit.TWOPI, false);
                        ctx.stroke();
                    }
                }
            }
            ctx.restore();
        }
        redrawMolecule() {
            let density = WebMolKit.pixelDensity();
            this.canvasMolecule.elCanvas.width = this.width * density;
            this.canvasMolecule.elCanvas.height = this.height * density;
            this.canvasMolecule.css({ 'width': `${this.width}px`, 'height': `${this.height}px` });
            let ctx = this.canvasMolecule.elCanvas.getContext('2d');
            ctx.save();
            ctx.scale(density, density);
            ctx.clearRect(0, 0, this.width, this.height);
            if (this.metavec != null)
                this.metavec.renderContext(ctx);
            if (this.templatePerms != null) {
                let perm = this.templatePerms[this.currentPerm];
                if (perm.metavec != null)
                    perm.metavec.renderContext(ctx);
            }
            ctx.restore();
        }
        redrawOver() {
            let density = WebMolKit.pixelDensity();
            this.canvasOver.elCanvas.width = this.width * density;
            this.canvasOver.elCanvas.height = this.height * density;
            this.canvasOver.css({ 'width': `${this.width}px`, 'height': `${this.height}px` });
            let ctx = this.canvasOver.elCanvas.getContext('2d');
            ctx.save();
            ctx.scale(density, density);
            ctx.clearRect(0, 0, this.width, this.height);
            if ((this.dragType == DraggingTool.Lasso || this.dragType == DraggingTool.Erasor) && this.lassoX.length > 1) {
                let erasing = this.dragType == DraggingTool.Erasor;
                let path = new Path2D();
                path.moveTo(this.lassoX[0], this.lassoY[0]);
                for (let n = 1; n < this.lassoX.length; n++)
                    path.lineTo(this.lassoX[n], this.lassoY[n]);
                path.closePath();
                ctx.fillStyle = WebMolKit.colourCanvas(erasing ? 0xD0FF0000 : 0xF0000000);
                ctx.fill(path);
                ctx.strokeStyle = erasing ? '#804040' : '#808080';
                ctx.lineWidth = 0.5;
                ctx.stroke(path);
            }
            if (this.dragType == DraggingTool.Rotate) {
                let [x0, y0, theta, magnitude] = this.determineDragTheta();
                let scale = this.pointScale;
                let lw = this.policy.data.lineSize * scale;
                ctx.strokeStyle = '#E0E0E0';
                ctx.lineWidth = 0.5 * lw;
                WebMolKit.drawLine(ctx, x0, y0, x0 + magnitude, y0);
                ctx.strokeStyle = '#808080';
                ctx.lineWidth = lw;
                WebMolKit.drawLine(ctx, x0, y0, x0 + magnitude * Math.cos(theta), y0 + magnitude * Math.sin(theta));
                ctx.beginPath();
                ctx.ellipse(x0, y0, 2 * lw, 2 * lw, 0, 0, WebMolKit.TWOPI, false);
                ctx.fillStyle = '#808080';
                ctx.fill();
                for (let atom of this.subjectAtoms(true, false)) {
                    let ax = this.angToX(this.mol.atomX(atom)), ay = this.angToY(this.mol.atomY(atom));
                    let ang = Math.atan2(ay - y0, ax - x0), dist = WebMolKit.norm_xy(ax - x0, ay - y0);
                    let nx = x0 + dist * Math.cos(ang + theta), ny = y0 + dist * Math.sin(ang + theta);
                    ctx.beginPath();
                    ctx.ellipse(nx, ny, 2 * lw, 2 * lw, 0, 0, WebMolKit.TWOPI, false);
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }
            }
            if (this.dragType == DraggingTool.Move) {
                let [dx, dy] = this.determineMoveDelta();
                let scale = this.pointScale;
                let lw = this.policy.data.lineSize * scale;
                for (let atom of this.subjectAtoms(false, true)) {
                    let ax = this.angToX(this.mol.atomX(atom)), ay = this.angToY(this.mol.atomY(atom));
                    ctx.beginPath();
                    ctx.ellipse(ax + dx, ay + dy, 2 * lw, 2 * lw, 0, 0, WebMolKit.TWOPI, false);
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }
            }
            if ((this.dragType == DraggingTool.Atom && this.opAtom > 0) || this.dragType == DraggingTool.Bond) {
                let element = this.dragType == DraggingTool.Atom ? this.toolAtomSymbol : 'C';
                let order = this.dragType == DraggingTool.Bond ? this.toolBondOrder : 1;
                let type = this.dragType == DraggingTool.Bond ? this.toolBondType : WebMolKit.Molecule.BONDTYPE_NORMAL;
                this.drawOriginatingBond(ctx, element, order, type);
            }
            if (this.viewOpt.showQuery)
                this.drawQueryFeatures(ctx);
            ctx.restore();
        }
        subjectAtoms(allIfNone = false, useOpAtom = false) {
            let atoms = [];
            if (this.selectedMask != null) {
                for (let n = 0; n < this.selectedMask.length; n++)
                    if (this.selectedMask[n])
                        atoms.push(n + 1);
                if (atoms.length > 0)
                    return atoms;
            }
            if (this.currentAtom > 0)
                atoms.push(this.currentAtom);
            else if (this.currentBond > 0) {
                atoms.push(this.mol.bondFrom(this.currentBond));
                atoms.push(this.mol.bondTo(this.currentBond));
            }
            if (useOpAtom && atoms.length == 0 && this.opAtom > 0)
                atoms.push(this.opAtom);
            if (allIfNone && atoms.length == 0) {
                for (let n = 1; n <= this.mol.numAtoms; n++)
                    atoms.push(n);
            }
            return atoms;
        }
        updateLasso(x, y) {
            if (this.dragType != DraggingTool.Lasso && this.dragType != DraggingTool.Erasor)
                return;
            if (x < 0 || y < 0 || x > this.width || y > this.height) {
                this.dragType = DraggingTool.None;
                this.lassoX = null;
                this.lassoY = null;
                this.lassoMask = null;
                this.delayedRedraw();
            }
            let len = WebMolKit.Vec.len(this.lassoX);
            if (len > 0 && this.lassoX[len - 1] == x && this.lassoY[len - 1] == y)
                return;
            this.lassoX.push(x);
            this.lassoY.push(y);
            this.calculateLassoMask();
            this.delayedRedraw();
        }
        calculateLassoMask() {
            this.lassoMask = new Array(this.mol.numAtoms);
            for (let n = 0; n < this.mol.numAtoms; n++)
                this.lassoMask[n] = false;
            for (let n = 0; n < this.layout.numPoints(); n++) {
                let p = this.layout.getPoint(n);
                if (p.anum == 0)
                    continue;
                this.lassoMask[p.anum - 1] = WebMolKit.GeomUtil.pointInPolygon(p.oval.cx, p.oval.cy, this.lassoX, this.lassoY);
            }
        }
        drawAtomShade(ctx, atom, fillCol, borderCol, anghalo) {
            if (this.layout == null)
                return;
            let p = null;
            for (let n = 0; n < this.layout.numPoints(); n++)
                if (this.layout.getPoint(n).anum == atom) {
                    p = this.layout.getPoint(n);
                    break;
                }
            if (p == null)
                return;
            let minRad = 0.2 * this.pointScale, minRadSq = WebMolKit.sqr(minRad);
            let cx = p.oval.cx, cy = p.oval.cy;
            let rad = Math.max(minRad, Math.max(p.oval.rw, p.oval.rh)) + (0.1 + anghalo) * this.pointScale;
            if (fillCol != -1) {
                ctx.beginPath();
                ctx.ellipse(cx, cy, rad, rad, 0, 0, WebMolKit.TWOPI, true);
                ctx.fillStyle = WebMolKit.colourCanvas(fillCol);
                ctx.fill();
            }
            if (borderCol != -1) {
                ctx.beginPath();
                ctx.ellipse(cx, cy, rad, rad, 0, 0, WebMolKit.TWOPI, true);
                ctx.strokeStyle = WebMolKit.colourCanvas(borderCol);
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }
        drawBondShade(ctx, bond, fillCol, borderCol, anghalo) {
            if (this.layout == null)
                return;
            let x1 = 0, y1 = 0, x2 = 0, y2 = 0, nb = 0, sz = 0;
            for (let n = 0; n < this.layout.numLines(); n++) {
                let l = this.layout.getLine(n);
                if (l.bnum != bond)
                    continue;
                x1 += l.line.x1;
                y1 += l.line.y1;
                x2 += l.line.x2;
                y2 += l.line.y2;
                nb++;
                sz += l.size + (0.2 + anghalo) * this.pointScale;
            }
            if (nb == 0)
                return;
            let invNB = 1 / nb;
            sz *= invNB;
            x1 *= invNB;
            y1 *= invNB;
            x2 *= invNB;
            y2 *= invNB;
            let dx = x2 - x1, dy = y2 - y1, invDist = 1 / WebMolKit.norm_xy(dx, dy);
            dx *= invDist;
            dy *= invDist;
            let ox = dy, oy = -dx;
            let path = new Path2D(), mx, my, CIRC = 0.8;
            path.moveTo(x1 + ox * sz, y1 + oy * sz);
            mx = x1 + (ox * sz - dx * sz) * CIRC;
            my = y1 + (oy * sz - dy * sz) * CIRC;
            path.quadraticCurveTo(mx, my, x1 - dx * sz, y1 - dy * sz);
            mx = x1 + (-ox * sz - dx * sz) * CIRC;
            my = y1 + (-oy * sz - dy * sz) * CIRC;
            path.quadraticCurveTo(mx, my, x1 - ox * sz, y1 - oy * sz);
            path.lineTo(x2 - ox * sz, y2 - oy * sz);
            mx = x2 + (-ox * sz + dx * sz) * CIRC;
            my = y2 + (-oy * sz + dy * sz) * CIRC;
            path.quadraticCurveTo(mx, my, x2 + dx * sz, y2 + dy * sz);
            mx = x2 + (ox * sz + dx * sz) * CIRC;
            my = y2 + (oy * sz + dy * sz) * CIRC;
            path.quadraticCurveTo(mx, my, x2 + ox * sz, y2 + oy * sz);
            path.closePath();
            if (fillCol != -1) {
                ctx.beginPath();
                ctx.fillStyle = WebMolKit.colourCanvas(fillCol);
                ctx.fill(path);
            }
            if (borderCol != -1) {
                ctx.beginPath();
                ctx.strokeStyle = WebMolKit.colourCanvas(borderCol);
                ctx.lineWidth = 1;
                ctx.stroke(path);
            }
        }
        drawOriginatingBond(ctx, element, order, type) {
            let x1 = this.clickX, y1 = this.clickY;
            if (this.opAtom > 0) {
                x1 = this.angToX(this.mol.atomX(this.opAtom));
                y1 = this.angToY(this.mol.atomY(this.opAtom));
            }
            else if (this.opBond > 0) {
                let [bfr, bto] = this.mol.bondFromTo(this.opBond);
                x1 = this.angToX(0.5 * (this.mol.atomX(bfr) + this.mol.atomX(bto)));
                y1 = this.angToY(0.5 * (this.mol.atomY(bfr) + this.mol.atomY(bto)));
            }
            let x2 = this.mouseX, y2 = this.mouseY;
            let snapTo = this.snapToGuide(x2, y2);
            if (snapTo != null) {
                x2 = snapTo[0];
                y2 = snapTo[1];
            }
            let scale = this.pointScale;
            ctx.strokeStyle = '#808080';
            ctx.lineWidth = this.policy.data.lineSize * scale;
            WebMolKit.drawLine(ctx, x1, y1, x2, y2);
            if (element != 'C') {
                let fh = this.policy.data.fontSize * scale;
                ctx.font = WebMolKit.fontSansSerif(fh);
                let metrics = ctx.measureText(element);
                ctx.fillStyle = '#808080';
                ctx.fillText(element, x2 - 0.5 * metrics.width, y2 + 0.5 * fh);
            }
        }
        drawQueryFeatures(ctx) {
            const { layout, mol } = this;
            let annots = [];
            for (let n = 1; n <= mol.numAtoms; n++)
                if (WebMolKit.QueryUtil.hasAnyQueryAtom(mol, n)) {
                    let bits = [];
                    for (let xtra of mol.atomExtra(n))
                        if (xtra.startsWith('q'))
                            bits.push(xtra);
                    let ap = layout.getPoint(n - 1);
                    annots.push({ 'txt': bits.join(','), 'x': ap.oval.cx + ap.oval.rw, 'y': ap.oval.cy });
                }
            for (let n = 1; n <= mol.numBonds; n++)
                if (WebMolKit.QueryUtil.hasAnyQueryBond(mol, n)) {
                    let bits = [];
                    for (let xtra of mol.bondExtra(n))
                        if (xtra.startsWith('q'))
                            bits.push(xtra);
                    let num = 0, cx = 0, cy = 0;
                    for (let bl of layout.getLines())
                        if (bl.bnum == n) {
                            num += 2;
                            cx += bl.line.x1 + bl.line.x2;
                            cy += bl.line.y1 + bl.line.y2;
                        }
                    annots.push({ 'txt': bits.join(','), 'x': cx / num, 'y': cy / num });
                }
            let fh = 0.7 * this.policy.data.fontSize * this.pointScale;
            for (let annot of annots) {
                ctx.font = WebMolKit.fontSansSerif(fh);
                ctx.fillStyle = '#FF40C0';
                ctx.fillText(annot.txt, annot.x, annot.y);
            }
        }
        drawPolymerUnit(ctx, unit, allUnits) {
            const { mol, layout } = this;
            let x = [], y = [];
            let scale = this.pointScale;
            for (let a of unit.atoms) {
                let pt = layout.getPoint(a - 1);
                let rad = Math.max(0.5 * scale, Math.max(pt.oval.rw, pt.oval.rh));
                const NPT = 36, THPT = WebMolKit.TWOPI / NPT;
                for (let n = 0; n < NPT; n++) {
                    let th = n * THPT;
                    x.push(pt.oval.cx + rad * Math.cos(th));
                    y.push(pt.oval.cy + rad * Math.sin(th));
                }
            }
            let extBonds = [], inAtoms = [], outAtoms = [];
            for (let n = 1; n <= mol.numBonds; n++) {
                let bfr = mol.bondFrom(n), bto = mol.bondTo(n);
                let flag1 = unit.atoms.includes(bfr), flag2 = unit.atoms.includes(bto);
                if (!flag1 && !flag2)
                    continue;
                if (!flag2) {
                    extBonds.push(n);
                    inAtoms.push(bfr);
                    outAtoms.push(bto);
                }
                else if (!flag1) {
                    extBonds.push(n);
                    inAtoms.push(bto);
                    outAtoms.push(bfr);
                }
                let pt1 = layout.getPoint(bfr - 1), pt2 = layout.getPoint(bto - 1);
                let x1 = pt1.oval.cx, y1 = pt1.oval.cy, x2 = pt2.oval.cx, y2 = pt2.oval.cy;
                if (!flag1)
                    [x1, y1] = [0.5 * (x1 + x2), 0.5 * (y1 + y2)];
                else if (!flag2)
                    [x2, y2] = [0.5 * (x1 + x2), 0.5 * (y1 + y2)];
                let dx = x2 - x1, dy = y2 - y1, d = WebMolKit.norm_xy(dx, dy), invD = WebMolKit.invZ(d);
                let ox = dy * invD * 0.3 * scale, oy = -dx * invD * 0.3 * scale;
                let npWidth = Math.ceil(2 * d / scale) + 1, npHeight = Math.ceil(2 * WebMolKit.norm_xy(ox, oy) / scale) + 1;
                for (let n = 0; n <= npWidth; n++) {
                    x.push(x1 - ox + dx * n / npWidth);
                    y.push(y1 - oy + dy * n / npWidth);
                    x.push(x1 + ox + dx * n / npWidth);
                    y.push(y1 + oy + dy * n / npWidth);
                }
                for (let n = 1; n < npHeight; n++) {
                    x.push(x1 - ox + 2 * ox * n / npHeight);
                    y.push(y1 - oy + 2 * oy * n / npHeight);
                    x.push(x2 - ox + 2 * ox * n / npHeight);
                    y.push(y2 - oy + 2 * oy * n / npHeight);
                }
            }
            let [px, py] = WebMolKit.GeomUtil.outlinePolygon(x, y, 0.5 * scale);
            let path = new Path2D();
            path.moveTo(px[0], py[0]);
            for (let n = 1; n < px.length; n++)
                path.lineTo(px[n], py[n]);
            path.closePath();
            ctx.save();
            ctx.fillStyle = '#F9EFFF';
            ctx.fill(path);
            ctx.strokeStyle = '#C0C0C0';
            ctx.lineWidth = 1;
            ctx.stroke(path);
            ctx.restore();
            let selfLinks = [];
            let innerLinks = [];
            let outerLinks = [];
            if (WebMolKit.Vec.len(unit.bondConn) == 4) {
                innerLinks.push([inAtoms[extBonds.indexOf(unit.bondConn[0])], inAtoms[extBonds.indexOf(unit.bondConn[2])]]);
                innerLinks.push([inAtoms[extBonds.indexOf(unit.bondConn[1])], inAtoms[extBonds.indexOf(unit.bondConn[3])]]);
            }
            else if (WebMolKit.Vec.len(extBonds) == 2 && unit.connect != null) {
                if (unit.connect == WebMolKit.PolymerBlockConnectivity.HeadToTail || unit.connect == WebMolKit.PolymerBlockConnectivity.Random) {
                    innerLinks.push([inAtoms[0], inAtoms[1]]);
                }
                if (unit.connect == WebMolKit.PolymerBlockConnectivity.HeadToHead || unit.connect == WebMolKit.PolymerBlockConnectivity.Random) {
                    selfLinks.push(inAtoms[0]);
                    selfLinks.push(inAtoms[1]);
                }
            }
            else {
                for (let b of extBonds) {
                    let a1 = mol.bondFrom(b), a2 = mol.bondTo(b);
                    if (unit.atoms.includes(a2))
                        [a1, a2] = [a2, a1];
                    let incl = unit.bondIncl.get(b), excl = unit.bondExcl.get(b);
                    let isCapped = mol.atomElement(a2) != WebMolKit.POLYMERBLOCK_SPECIAL_UNCAPPED;
                    for (let look of (isCapped ? [unit] : allUnits))
                        for (let a of look.atoms) {
                            let isExt = false;
                            for (let adj of mol.atomAdjList(a))
                                if (!look.atoms.includes(adj)) {
                                    isExt = true;
                                    break;
                                }
                            if (!isExt)
                                continue;
                            if (WebMolKit.Vec.notBlank(incl)) {
                                let anames = look.atomName.get(a), any = false;
                                if (anames)
                                    for (let an of anames)
                                        any = any || incl.includes(an);
                                if (!any)
                                    continue;
                            }
                            if (WebMolKit.Vec.notBlank(excl)) {
                                let anames = look.atomName.get(a), any = false;
                                if (anames)
                                    for (let an of anames)
                                        any = any || excl.includes(an);
                                if (any)
                                    continue;
                            }
                            if (a == a1)
                                selfLinks.push(a1);
                            else if (unit === look)
                                innerLinks.push([a1, a]);
                            else
                                outerLinks.push([a1, a]);
                        }
                }
            }
            selfLinks = WebMolKit.Vec.uniqueStable(selfLinks);
            innerLinks = WebMolKit.Vec.maskGet(innerLinks, WebMolKit.Vec.maskUnique(innerLinks.map((pair) => WebMolKit.Vec.min(pair) * mol.numAtoms + WebMolKit.Vec.max(pair))));
            outerLinks = WebMolKit.Vec.maskGet(outerLinks, WebMolKit.Vec.maskUnique(outerLinks.map((pair) => WebMolKit.Vec.min(pair) * mol.numAtoms + WebMolKit.Vec.max(pair))));
            ctx.save();
            ctx.strokeStyle = '#6329C1';
            ctx.lineWidth = 2;
            ctx.setLineDash([1, 1]);
            ctx.beginPath();
            for (let a of selfLinks) {
                let p1 = layout.getPoint(a - 1), x1 = p1.oval.cx, y1 = p1.oval.cy;
                let x2 = 0, y2 = 0, num = 0;
                for (let n = 0; n < extBonds.length; n++)
                    if (inAtoms[n] == a) {
                        let p2 = layout.getPoint(outAtoms[n] - 1);
                        x2 += p2.oval.cx;
                        y2 += p2.oval.cy;
                        num++;
                    }
                if (num > 1) {
                    x2 /= num;
                    y2 /= num;
                }
                x2 = x1 + 0.5 * (x2 - x1);
                y2 = y1 + 0.5 * (y2 - y1);
                let dx = x2 - x1, dy = y2 - y1, invD = WebMolKit.invZ(WebMolKit.norm_xy(dx, dy)), ox = dy * invD, oy = -dx * invD;
                let cx = 0.5 * (x1 + x2), cy = 0.5 * (y1 + y2);
                const EXT = 2 * scale;
                ctx.moveTo(x1, y1);
                ctx.quadraticCurveTo(cx + ox * EXT, cy + oy * EXT, x2, y2);
                ctx.quadraticCurveTo(cx - ox * EXT, cy - oy * EXT, x1, y1);
            }
            for (let [a1, a2] of innerLinks) {
                let x1 = mol.atomX(a1), y1 = mol.atomY(a1), x2 = mol.atomX(a2), y2 = mol.atomY(a2);
                let dx = x2 - x1, dy = y2 - y1, invD = WebMolKit.invZ(WebMolKit.norm_xy(dx, dy)), ox = dy * invD, oy = -dx * invD;
                let cx = 0.5 * (x1 + x2), cy = 0.5 * (y1 + y2);
                const EXT = 5;
                let px1 = cx + ox * EXT, py1 = cy + oy * EXT, px2 = cx - ox * EXT, py2 = cy - oy * EXT;
                let [px, py] = WebMolKit.CoordUtil.congestionPoint(mol, px1, py1) < WebMolKit.CoordUtil.congestionPoint(mol, px2, py2) ? [px1, py1] : [px2, py2];
                ctx.moveTo(this.angToX(x1), this.angToY(y1));
                ctx.quadraticCurveTo(this.angToX(px), this.angToY(py), this.angToX(x2), this.angToY(y2));
            }
            for (let [a1, a2] of outerLinks) {
                let p1 = layout.getPoint(a1 - 1), p2 = layout.getPoint(a2 - 1);
                ctx.moveTo(p1.oval.cx, p1.oval.cy);
                ctx.lineTo(p2.oval.cx, p2.oval.cy);
            }
            ctx.stroke();
            ctx.restore();
        }
        determineFauxRing() {
            let atom = this.opAtom, bond = this.opBond, mol = this.mol;
            let x1 = atom > 0 ? mol.atomX(atom) : bond > 0 ? 0.5 * (mol.atomX(mol.bondFrom(bond)) + mol.atomX(mol.bondTo(bond))) : this.xToAng(this.clickX);
            let y1 = atom > 0 ? mol.atomY(atom) : bond > 0 ? 0.5 * (mol.atomY(mol.bondFrom(bond)) + mol.atomY(mol.bondTo(bond))) : this.yToAng(this.clickY);
            let x2 = this.xToAng(this.mouseX), y2 = this.yToAng(this.mouseY), dx = x2 - x1, dy = y2 - y1;
            let rsz = Math.min(9, Math.round(WebMolKit.norm_xy(dx, dy) * 2 / WebMolKit.Molecule.IDEALBOND) + 2);
            if (rsz < 3) { }
            else if (bond > 0)
                return WebMolKit.SketchUtil.proposeBondRing(mol, rsz, bond, dx, dy);
            else if (atom > 0 && mol.atomAdjCount(atom) > 0 && !this.toolRingFreeform)
                return WebMolKit.SketchUtil.proposeAtomRing(mol, rsz, atom, dx, dy);
            else
                return WebMolKit.SketchUtil.proposeNewRing(mol, rsz, x1, y1, dx, dy, !this.toolRingFreeform);
            return [null, null];
        }
        determineDragTheta() {
            let x0 = this.clickX, y0 = this.clickY;
            let snap = this.snapToGuide(x0, y0);
            if (snap != null) {
                x0 = snap[0];
                y0 = snap[1];
            }
            let theta = Math.atan2(this.mouseY - y0, this.mouseX - x0), magnitude = WebMolKit.norm_xy(this.mouseX - x0, this.mouseY - y0);
            if (this.toolRotateIncr > 0)
                theta = Math.round(theta / this.toolRotateIncr) * this.toolRotateIncr;
            return [x0, y0, theta, magnitude];
        }
        determineMoveDelta() {
            let x1 = this.clickX, y1 = this.clickY, x2 = this.mouseX, y2 = this.mouseY;
            if (this.opAtom > 0) {
                x1 = this.angToX(this.mol.atomX(this.opAtom));
                y1 = this.angToY(this.mol.atomY(this.opAtom));
                let snap = this.snapToGuide(x2, y2);
                if (snap != null) {
                    x2 = snap[0];
                    y2 = snap[1];
                }
            }
            return [x2 - x1, y2 - y1];
        }
        snapToGuide(x, y) {
            if (this.opBond > 0) {
                let obj = this.pickObject(x, y);
                if (obj < 0) {
                    let [bfr, bto] = this.mol.bondFromTo(-obj);
                    let px = this.angToX(0.5 * (this.mol.atomX(bfr) + this.mol.atomX(bto)));
                    let py = this.angToY(0.5 * (this.mol.atomY(bfr) + this.mol.atomY(bto)));
                    return [px, py];
                }
                return null;
            }
            let bestDSQ = Number.POSITIVE_INFINITY, bestX = 0, bestY = 0;
            const APPROACH = WebMolKit.sqr(0.5 * this.pointScale);
            if (this.dragGuides != null)
                for (let i = 0; i < this.dragGuides.length; i++)
                    for (let j = 0; j < this.dragGuides[i].x.length; j++) {
                        let px = this.dragGuides[i].destX[j], py = this.dragGuides[i].destY[j];
                        let dsq = WebMolKit.norm2_xy(px - x, py - y);
                        if (dsq < APPROACH && dsq < bestDSQ) {
                            bestDSQ = dsq;
                            bestX = px;
                            bestY = py;
                        }
                    }
            for (let n = 1; n <= this.mol.numAtoms; n++) {
                let px = this.angToX(this.mol.atomX(n)), py = this.angToY(this.mol.atomY(n));
                let dsq = WebMolKit.norm2_xy(px - x, py - y);
                if (dsq < APPROACH && dsq < bestDSQ) {
                    bestDSQ = dsq;
                    bestX = px;
                    bestY = py;
                }
            }
            if (isFinite(bestDSQ))
                return [bestX, bestY];
            return null;
        }
        pickObjectCanvas(x, y, opt = {}) {
            let limitDist = 0.5 * this.pointScale;
            let bestItem = 0, bestScore = Number.POSITIVE_INFINITY;
            if (!opt.noAtoms)
                for (let n = 0; n < this.layout.numPoints(); n++) {
                    let p = this.layout.getPoint(n);
                    if (p.anum == 0)
                        continue;
                    let dx = Math.abs(x - p.oval.cx), dy = Math.abs(y - p.oval.cy);
                    let dsq = WebMolKit.norm2_xy(dx, dy);
                    let limitDSQ = WebMolKit.sqr(Math.max(limitDist, Math.max(p.oval.rw, p.oval.rh)));
                    if (dsq > limitDSQ)
                        continue;
                    if (dsq < bestScore) {
                        bestItem = p.anum;
                        bestScore = dsq;
                    }
                }
            if (bestItem != 0)
                return bestItem;
            if (!opt.noBonds)
                for (let n = 0; n < this.layout.numLines(); n++) {
                    let l = this.layout.getLine(n);
                    if (l.bnum == 0)
                        continue;
                    let x1 = l.line.x1, y1 = l.line.y1;
                    let x2 = l.line.x2, y2 = l.line.y2;
                    if (x < Math.min(x1, x2) - limitDist || y < Math.min(y1, y2) - limitDist ||
                        x > Math.max(x1, x2) + limitDist || y > Math.max(y1, y2) + limitDist)
                        continue;
                    let dist = WebMolKit.GeomUtil.pointLineSegDistance(x, y, x1, y1, x2, y2);
                    if (dist > limitDist)
                        continue;
                    if (dist < bestScore) {
                        bestItem = -l.bnum;
                        bestScore = dist;
                    }
                }
            return bestItem;
        }
        pickObject(x, y, opt = {}) {
            return this.pickObjectCanvas(x, y, opt) || 0;
        }
        sketchEffects(mol) {
            let effects = new WebMolKit.RenderEffects();
            for (let n = 1; n <= mol.numAtoms; n++)
                if (WebMolKit.MolUtil.hasAbbrev(mol, n) && n != this.hoverAtom)
                    effects.dottedRectOutline[n] = 0x808080;
            effects.overlapAtoms = WebMolKit.CoordUtil.overlappingAtomList(mol, 0.2);
            effects.atomDecoText = WebMolKit.Vec.stringArray('', mol.numAtoms);
            effects.atomDecoCol = WebMolKit.Vec.numberArray(WebMolKit.Theme.foreground, mol.numAtoms);
            effects.atomDecoSize = WebMolKit.Vec.numberArray(0.3, mol.numAtoms);
            effects.bondDecoText = WebMolKit.Vec.stringArray('', mol.numBonds);
            effects.bondDecoCol = WebMolKit.Vec.numberArray(WebMolKit.Theme.foreground, mol.numBonds);
            effects.bondDecoSize = WebMolKit.Vec.numberArray(0.3, mol.numBonds);
            if (this.viewOpt.showOxState) {
                for (let n = 1; n <= mol.numAtoms; n++) {
                    let ox = WebMolKit.MolUtil.atomOxidationState(mol, n);
                    if (ox != null) {
                        effects.atomDecoText[n - 1] = WebMolKit.MolUtil.oxidationStateText(ox);
                        effects.atomDecoCol[n - 1] = 0xFF8080;
                    }
                }
            }
            if (this.viewOpt.decoration == DrawCanvasDecoration.Stereochemistry) {
                if (!this.stereo)
                    this.stereo = WebMolKit.Stereochemistry.create(WebMolKit.MetaMolecule.createStrict(mol));
                skip: for (let n = 1; n <= mol.numAtoms; n++) {
                    let chi = this.stereo.atomTetraChirality(n);
                    if (chi == WebMolKit.Stereochemistry.STEREO_NONE)
                        continue;
                    for (let adjb of mol.atomAdjBonds(n))
                        if (mol.bondOrder(adjb) != 1)
                            continue skip;
                    if (chi == WebMolKit.Stereochemistry.STEREO_UNKNOWN) {
                        for (let adj of mol.atomAdjList(n))
                            if (WebMolKit.Chemistry.ELEMENT_BLOCKS[mol.atomicNumber(adj)] >= 3)
                                continue skip;
                    }
                    effects.atomDecoText[n - 1] = chi == WebMolKit.Stereochemistry.STEREO_POS ? 'R' :
                        chi == WebMolKit.Stereochemistry.STEREO_NEG ? 'S' :
                            chi == WebMolKit.Stereochemistry.STEREO_UNKNOWN ? 'R/S' : '?';
                    effects.atomDecoCol[n - 1] = 0x00A000;
                }
                for (let n = 1; n <= mol.numBonds; n++) {
                    let side = this.stereo.bondSideStereo(n);
                    if (side == WebMolKit.Stereochemistry.STEREO_NONE)
                        continue;
                    effects.bondDecoText[n - 1] = side == WebMolKit.Stereochemistry.STEREO_POS ? 'Z' :
                        side == WebMolKit.Stereochemistry.STEREO_NEG ? 'E' :
                            side == WebMolKit.Stereochemistry.STEREO_UNKNOWN ? 'Z/E' : '?';
                    effects.bondDecoCol[n - 1] = 0x00A000;
                }
            }
            else if (this.viewOpt.decoration == DrawCanvasDecoration.MappingNumber) {
                effects.atomDecoText = WebMolKit.Vec.stringArray('', mol.numAtoms);
                effects.atomDecoCol = WebMolKit.Vec.numberArray(0x8000FF, mol.numAtoms);
                effects.atomDecoSize = WebMolKit.Vec.numberArray(0.3, mol.numAtoms);
                for (let n = 1; n <= mol.numAtoms; n++)
                    if (mol.atomMapNum(n) > 0)
                        effects.atomDecoText[n - 1] = mol.atomMapNum(n).toString();
            }
            else if (this.viewOpt.decoration == DrawCanvasDecoration.AtomIndex) {
                effects.atomDecoText = WebMolKit.Vec.stringArray('', mol.numAtoms);
                effects.atomDecoCol = WebMolKit.Vec.numberArray(0x8000FF, mol.numAtoms);
                effects.atomDecoSize = WebMolKit.Vec.numberArray(0.3, mol.numAtoms);
                for (let n = 1; n <= mol.numAtoms; n++)
                    effects.atomDecoText[n - 1] = n.toString();
            }
            return effects;
        }
        orientAbbreviation(abbrevAtom, abbrevMol) {
            const { mol } = this;
            if (WebMolKit.MolUtil.isBlank(abbrevMol))
                return;
            if (this.mol.atomAdjCount(abbrevAtom) != 1)
                return;
            let nbr = mol.atomAdjList(abbrevAtom)[0];
            let vx1 = mol.atomX(abbrevAtom) - mol.atomX(nbr), vy1 = mol.atomY(abbrevAtom) - mol.atomY(nbr);
            let adj = abbrevMol.atomAdjList(1);
            let vx2 = 0, vy2 = 0, inv = WebMolKit.invZ(adj.length);
            for (let a of adj) {
                vx2 += abbrevMol.atomX(a) - abbrevMol.atomX(1);
                vy2 += abbrevMol.atomY(a) - abbrevMol.atomY(1);
            }
            vx2 *= inv;
            vy2 *= inv;
            let th1 = Math.atan2(vy1, vx1), th2 = Math.atan2(vy2, vx2);
            WebMolKit.CoordUtil.rotateMolecule(abbrevMol, th1 - th2);
            if (adj.length == 1) {
                WebMolKit.CoordUtil.translateMolecule(abbrevMol, mol.atomX(abbrevAtom) - abbrevMol.atomX(adj[0]), mol.atomY(abbrevAtom) - abbrevMol.atomY(adj[0]));
                abbrevMol.setAtomPos(1, mol.atomX(nbr), mol.atomY(nbr));
            }
            else {
                WebMolKit.CoordUtil.translateMolecule(abbrevMol, mol.atomX(nbr) - abbrevMol.atomX(1), mol.atomY(nbr) - abbrevMol.atomY(1));
            }
            for (let b of abbrevMol.atomAdjBonds(1)) {
                let a = abbrevMol.bondOther(b, 1);
                if (abbrevMol.atomHExplicit(a) != WebMolKit.Molecule.HEXPLICIT_UNKNOWN)
                    continue;
                abbrevMol.setAtomHExplicit(a, Math.max(0, abbrevMol.atomHydrogens(a)));
            }
            abbrevMol.deleteAtomAndBonds(1);
        }
    }
    WebMolKit.DrawCanvas = DrawCanvas;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class EditAtom extends WebMolKit.Dialog {
        constructor(mol, atom, proxyClip, callbackApply) {
            super();
            this.atom = atom;
            this.proxyClip = proxyClip;
            this.callbackApply = callbackApply;
            this.newX = 0;
            this.newY = 0;
            this.tabs = null;
            this.abbrevList = null;
            this.svgAbbrev = null;
            this.abbrevIndices = [];
            this.currentAbbrev = -1;
            this.initMol = mol;
            this.mol = mol.clone();
            this.title = 'Edit Atom';
            this.minPortionWidth = 20;
            this.maxPortionWidth = 95;
        }
        populate() {
            this.proxyClip.pushHandler(new WebMolKit.ClipboardProxyHandler());
            let buttons = this.buttonsDOM(), body = this.bodyDOM();
            this.btnApply = WebMolKit.dom('<button class="wmk-button wmk-button-primary">Apply</button>').appendTo(buttons).css({ 'margin-left': '0.5em' });
            this.btnApply.onClick(() => this.applyChanges());
            if (this.atom > 0) {
                this.tabs = new WebMolKit.TabBar(['Atom', 'Abbreviation', 'Geometry', 'Query', 'Extra']);
                this.tabs.render(body);
                this.tabs.onSelect((idx) => this.selectedTab(idx));
                this.populateAtom(this.tabs.getPanelDOM('Atom'));
                this.populateAbbreviation(this.tabs.getPanelDOM('Abbreviation'));
                if (this.atom > 0)
                    this.populateGeometry(this.tabs.getPanelDOM('Geometry'));
                this.populateQuery(this.tabs.getPanelDOM('Query'));
                this.populateExtra(this.tabs.getPanelDOM('Extra'));
            }
            else {
                this.populateAtom(body);
            }
            let focusable = body.findAll('input,textarea');
            if (focusable.length > 0)
                focusable[0].grabFocus(true);
            for (let dom of focusable) {
                dom.css({ 'font': 'inherit' });
                dom.onKeyDown((event) => {
                    if (event.key == "Enter")
                        this.applyChanges();
                    else if (event.key == "Escape")
                        this.close();
                    else if (event.key == "PageUp") {
                        this.tabs.rotateSelected(-1);
                        this.selectedTab(this.tabs.getSelectedIndex());
                        event.preventDefault();
                    }
                    else if (event.key == "PageDown") {
                        this.tabs.rotateSelected(1);
                        this.selectedTab(this.tabs.getSelectedIndex());
                        event.preventDefault();
                    }
                    event.stopPropagation();
                });
            }
        }
        close() {
            this.proxyClip.popHandler();
            super.close();
        }
        applyChanges() {
            this.mol.keepTransient = true;
            this.updateMolecule();
            let selTab = this.tabs ? this.tabs.getSelectedValue() : null;
            if (selTab == 'Abbreviation')
                this.updateAbbrev();
            if (selTab == 'Geometry')
                this.updateGeometry();
            if (selTab == 'Query')
                this.updateQuery();
            if (selTab == 'Extra')
                this.updateExtra();
            this.mol.keepTransient = false;
            if (this.callbackApply)
                this.callbackApply(this);
        }
        populateAtom(panel) {
            let grid = WebMolKit.dom('<div/>').appendTo(panel);
            grid.css({ 'display': 'grid', 'align-items': 'center', 'justify-content': 'start' });
            grid.css({ 'grid-row-gap': '0.5em', 'grid-column-gap': '0.5em' });
            grid.css({ 'grid-template-columns': '[start col0] auto [col1] auto [col2] auto [col3] auto [col4 end]' });
            grid.appendHTML('<div style="grid-area: 1 / col0;">Symbol</div>');
            this.inputSymbol = WebMolKit.dom('<input size="20"/>').appendTo(grid);
            this.inputSymbol.css({ 'grid-area': '1 / col1 / auto / col4}' });
            this.inputSymbol.onInput(() => this.periodicWidget.changeElement(this.inputSymbol.getValue()));
            grid.appendHTML('<div style="grid-area: 2 / col0;">Charge</div>');
            this.inputCharge = WebMolKit.dom('<input type="number" size="6"/>').appendTo(grid);
            this.inputCharge.css({ 'grid-area': '2 / col1' });
            grid.appendHTML('<div style="grid-area: 2 / col2;">Unpaired</div>');
            this.inputUnpaired = WebMolKit.dom('<input type="number" size="6"/>').appendTo(grid);
            this.inputUnpaired.css({ 'grid-area': '2 / col3' });
            grid.appendHTML('<div style="grid-area: 3 / col0;">Hydrogens</div>');
            this.optionHydrogen = new WebMolKit.OptionList(['Auto', 'None', '1', '2', '3', '4', 'Other']);
            this.optionHydrogen.render(WebMolKit.dom('<div style="grid-area: 3 / col1 / auto / col3"/>').appendTo(grid));
            this.optionHydrogen.onSelect((idx) => this.inputHydrogen.elInput.disabled = idx != 6);
            this.inputHydrogen = WebMolKit.dom('<input type="number" size="4"/>').appendTo(grid);
            this.inputHydrogen.css({ 'grid-area': '3 / col3' });
            this.inputHydrogen.elInput.disabled = true;
            grid.appendHTML('<div style="grid-area: 4 / col0;">Isotope</div>');
            this.optionIsotope = new WebMolKit.OptionList(['Natural', 'Enriched']);
            this.optionIsotope.render(WebMolKit.dom('<div style="grid-area: 4 / col1 / auto / col3"/>').appendTo(grid));
            this.optionIsotope.onSelect((idx) => this.inputIsotope.elInput.disabled = idx == 0);
            this.inputIsotope = WebMolKit.dom('<input type="number" size="6"/>').appendTo(grid);
            this.inputIsotope.css({ 'grid-area': '4 / col3' });
            this.inputIsotope.elInput.disabled = true;
            grid.appendHTML('<div style="grid-area: 5 / col0;">Mapping</div>');
            this.inputMapping = WebMolKit.dom('<input type="number" size="6"/>').appendTo(grid);
            this.inputMapping.css({ 'grid-area': '5 / col1' });
            grid.appendHTML('<div style="grid-area: 5 / col2;">Index</div>');
            this.inputIndex = WebMolKit.dom('<input type="number" size="6" readonly="readonly"/>').appendTo(grid);
            this.inputIndex.css({ 'grid-area': '5 / col3' });
            let divPeriodic = WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': '6 / start / 6 / end' });
            this.periodicWidget = new WebMolKit.PeriodicTableWidget();
            this.periodicWidget.onSelect((element) => this.inputSymbol.setValue(element));
            this.periodicWidget.onDoubleClick(() => this.applyChanges());
            this.periodicWidget.render(divPeriodic);
            const mol = this.mol, atom = this.atom;
            if (atom > 0) {
                this.inputSymbol.setValue(mol.atomElement(atom));
                this.inputCharge.setValue(mol.atomCharge(atom).toString());
                this.inputUnpaired.setValue(mol.atomUnpaired(atom).toString());
                let hc = mol.atomHExplicit(atom);
                if (hc == WebMolKit.Molecule.HEXPLICIT_UNKNOWN) {
                    this.optionHydrogen.setSelectedIndex(0);
                    this.inputHydrogen.setValue(mol.atomHydrogens(atom).toString());
                    this.inputHydrogen.elInput.disabled = true;
                }
                else if (hc <= 4) {
                    this.optionHydrogen.setSelectedIndex(hc + 1);
                    this.inputHydrogen.setValue(hc.toString());
                    this.inputHydrogen.elInput.disabled = true;
                }
                else {
                    this.optionHydrogen.setSelectedIndex(6);
                    this.inputHydrogen.setValue(hc.toString());
                    this.inputHydrogen.elInput.disabled = false;
                }
                this.optionIsotope.setSelectedIndex(mol.atomIsotope(atom) == WebMolKit.Molecule.ISOTOPE_NATURAL ? 0 : 1);
                if (mol.atomIsotope(atom) != WebMolKit.Molecule.ISOTOPE_NATURAL)
                    this.inputIsotope.setValue(mol.atomIsotope(atom).toString());
                this.inputIsotope.elInput.disabled = mol.atomIsotope(atom) == WebMolKit.Molecule.ISOTOPE_NATURAL;
                this.inputMapping.setValue(mol.atomMapNum(atom).toString());
                this.inputIndex.setValue(atom.toString());
                this.periodicWidget.changeElement(mol.atomElement(atom));
            }
        }
        populateAbbreviation(panel) {
            let divFlex = WebMolKit.dom('<div/>').appendTo(panel).css({ 'display': 'flex', 'align-items': 'flex-start' });
            divFlex.css({ 'max-width': '60vw', 'max-height': '50vh', 'overflow-y': 'scroll' });
            let spanSearch = WebMolKit.dom('<div/>').appendTo(divFlex).css({ 'margin-right': '0.5em', 'flex': '0 0' });
            let spanList = WebMolKit.dom('<div/>').appendTo(divFlex).css({ 'flex': '1 1 100%' });
            this.inputAbbrevSearch = WebMolKit.dom('<input size="10"/>').appendTo(spanSearch);
            this.inputAbbrevSearch.setAttr('placeholder', 'Search');
            let lastSearch = '';
            this.inputAbbrevSearch.onKeyDown((event) => {
                if (event.key == "ArrowUp")
                    this.cycleAbbreviation(-1);
                else if (event.key == "ArrowDown")
                    this.cycleAbbreviation(1);
            });
            this.inputAbbrevSearch.onInput(() => {
                let search = this.inputAbbrevSearch.getValue();
                if (search == lastSearch)
                    return;
                lastSearch = search;
                this.fillAbbreviations();
            });
            let divButtons = WebMolKit.dom('<div/>').appendTo(spanSearch).css({ 'margin-top': '0.5em' });
            let btnClear = WebMolKit.dom('<button class="wmk-button wmk-button-default">Clear</button>').appendTo(divButtons);
            btnClear.onClick(() => {
                this.selectAbbreviation(-1);
                if (this.atom > 0 && WebMolKit.MolUtil.hasAbbrev(this.mol, this.atom))
                    this.applyChanges();
            });
            this.tableAbbrev = WebMolKit.dom('<table/>').appendTo(spanList).css({ 'border-collapse': 'collapse', 'width': '100%' });
            this.fillAbbreviations();
        }
        populateGeometry(panel) {
            const { mol, atom } = this;
            let divContainer1 = WebMolKit.dom('<div/>').appendTo(panel).css({ 'text-align': 'center' });
            let divContainer2 = WebMolKit.dom('<div/>').appendTo(divContainer1).css({ 'display': 'inline-block' });
            let grid = WebMolKit.dom('<div/>').appendTo(divContainer2);
            grid.css({ 'display': 'grid', 'align-items': 'center', 'justify-content': 'start' });
            grid.css({ 'grid-row-gap': '0.5em', 'grid-column-gap': '0.5em' });
            grid.css({ 'grid-template-columns': '[start col0] auto [col1] auto [col2] auto [col3] auto [col4 end]' });
            this.geomWidget = new WebMolKit.GeomWidget(WebMolKit.GeomWidgetType.Atom, mol, atom);
            this.geomWidget.render(WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': '1 / col0 / auto / col4', 'text-align': 'center' }));
            let label1 = WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': '2 / col0' });
            this.inputGeom1 = WebMolKit.dom('<input type="number" size="8"/>').appendTo(grid).css({ 'grid-area': '2 / col1' });
            let label2 = WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': '2 / col2' });
            this.inputGeom2 = WebMolKit.dom('<input type="number" size="8"/>').appendTo(grid).css({ 'grid-area': '2 / col3' });
            this.geomWidget.callbackSelect = (sel) => {
                let atoms = this.geomWidget.selectionAtoms(sel);
                if (sel.type == WebMolKit.GeomWidgetSelType.Position) {
                    label1.setText('Position X');
                    label2.setText('Y');
                    this.inputGeom1.setValue(this.refGeom1 = mol.atomX(atoms[0]).toFixed(3));
                    this.inputGeom2.setValue(this.refGeom2 = mol.atomY(atoms[0]).toFixed(3));
                }
                else if (sel.type == WebMolKit.GeomWidgetSelType.Link) {
                    let dx = mol.atomX(atoms[1]) - mol.atomX(atoms[0]), dy = mol.atomY(atoms[1]) - mol.atomY(atoms[0]);
                    label1.setText('Distance');
                    label2.setText('Angle');
                    this.inputGeom1.setValue(this.refGeom1 = WebMolKit.norm_xy(dx, dy).toFixed(3));
                    this.inputGeom2.setValue(this.refGeom2 = (Math.atan2(dy, dx) * WebMolKit.RADDEG).toFixed(1));
                }
                else if (sel.type == WebMolKit.GeomWidgetSelType.Torsion) {
                    let cx = mol.atomX(atoms[0]), cy = mol.atomY(atoms[0]);
                    let th2 = Math.atan2(mol.atomY(atoms[1]) - cy, mol.atomX(atoms[1]) - cx);
                    let th1 = Math.atan2(mol.atomY(atoms[2]) - cy, mol.atomX(atoms[2]) - cx);
                    label1.setText('Angle');
                    label2.setText('');
                    this.inputGeom1.setValue(this.refGeom1 = (WebMolKit.angleDiffPos(th2, th1) * WebMolKit.RADDEG).toFixed(1));
                    this.inputGeom2.setValue(this.refGeom2 = '');
                }
                label2.setCSS('display', sel.type == WebMolKit.GeomWidgetSelType.Torsion ? 'none' : 'block');
                this.inputGeom2.setCSS('display', sel.type == WebMolKit.GeomWidgetSelType.Torsion ? 'none' : 'block');
            };
            this.geomWidget.callbackSelect(this.geomWidget.selected);
        }
        populateQuery(panel) {
            this.queryWidget = new WebMolKit.QueryFieldsWidget(this.mol, this.atom, 0);
            this.queryWidget.render(panel);
        }
        populateExtra(panel) {
            let fields = [...this.mol.atomExtra(this.atom), ...this.mol.atomTransient(this.atom)];
            this.fieldsWidget = new WebMolKit.ExtraFieldsWidget(fields);
            this.fieldsWidget.render(panel);
        }
        updateMolecule() {
            let { mol, atom } = this;
            if (atom == 0)
                atom = this.atom = mol.addAtom('C', this.newX, this.newY);
            let sym = this.inputSymbol.getValue();
            if (sym != '')
                mol.setAtomElement(atom, sym);
            let chg = parseInt(this.inputCharge.getValue());
            if (chg > -20 && chg < 20)
                mol.setAtomCharge(atom, chg);
            let unp = parseInt(this.inputUnpaired.getValue());
            if (unp >= 0 && unp < 20)
                mol.setAtomUnpaired(atom, unp);
            let hcidx = this.optionHydrogen.getSelectedIndex();
            if (hcidx == 0)
                mol.setAtomHExplicit(atom, WebMolKit.Molecule.HEXPLICIT_UNKNOWN);
            else if (hcidx <= 5)
                mol.setAtomHExplicit(atom, hcidx - 1);
            else {
                let hyd = parseInt(this.inputHydrogen.getValue());
                if (hyd >= 0 && hyd < 20)
                    mol.setAtomHExplicit(atom, hyd);
            }
            if (this.optionIsotope.getSelectedIndex() == 1) {
                let iso = parseInt(this.inputIsotope.getValue());
                if (iso >= 0 && iso < 300)
                    mol.setAtomIsotope(atom, iso);
            }
            else
                mol.setAtomIsotope(atom, WebMolKit.Molecule.ISOTOPE_NATURAL);
            let map = parseInt(this.inputMapping.getValue());
            if (!isNaN(map))
                mol.setAtomMapNum(atom, map);
        }
        updateAbbrev() {
            const { mol, atom } = this;
            if (this.currentAbbrev < 0) {
                let el = mol.atomElement(atom);
                WebMolKit.MolUtil.clearAbbrev(mol, atom);
                mol.setAtomElement(atom, el);
            }
            else {
                let abbrev = this.abbrevList[this.currentAbbrev];
                mol.setAtomElement(atom, abbrev.name);
                WebMolKit.MolUtil.setAbbrev(mol, atom, abbrev.frag);
            }
        }
        updateGeometry() {
            let strval1 = this.inputGeom1.getValue(), strval2 = this.inputGeom2.getValue();
            if (this.refGeom1 == strval1 && this.refGeom2 == strval2)
                return;
            const { mol } = this;
            let sel = this.geomWidget.selected, atoms = this.geomWidget.selectionAtoms(sel);
            if (sel.type == WebMolKit.GeomWidgetSelType.Position) {
                let x = parseFloat(strval1), y = parseFloat(strval2);
                if (isNaN(x) || isNaN(y) || Math.abs(x) > 1E6 || Math.abs(y) > 1E6)
                    return;
                mol.setAtomPos(atoms[0], x, y);
            }
            else if (sel.type == WebMolKit.GeomWidgetSelType.Link) {
                if (this.refGeom1 != strval1) {
                    let dist = parseFloat(strval1);
                    if (isNaN(dist) || Math.abs(dist) > 100)
                        return;
                    let mask = WebMolKit.Vec.booleanArray(false, mol.numAtoms);
                    mask[atoms[1] - 1] = true;
                    let instate = { 'mol': mol, 'currentAtom': 0, 'currentBond': mol.findBond(atoms[0], atoms[1]), 'selectedMask': mask };
                    let molact = new WebMolKit.MoleculeActivity(instate, WebMolKit.ActivityType.BondDist, { 'dist': dist });
                    molact.execute();
                    if (molact.output.mol)
                        this.mol = molact.output.mol;
                    return;
                }
                else if (this.refGeom2 != strval2) {
                    let angle = parseFloat(strval2);
                    if (isNaN(angle))
                        return;
                    let mask = WebMolKit.Vec.booleanArray(false, mol.numAtoms);
                    mask[atoms[1] - 1] = true;
                    let instate = { 'mol': mol, 'currentAtom': 0, 'currentBond': mol.findBond(atoms[0], atoms[1]), 'selectedMask': mask };
                    let molact = new WebMolKit.MoleculeActivity(instate, WebMolKit.ActivityType.AlignAngle, { 'angle': angle * WebMolKit.DEGRAD });
                    molact.execute();
                    if (molact.output.mol)
                        this.mol = molact.output.mol;
                    return;
                }
            }
            else if (sel.type == WebMolKit.GeomWidgetSelType.Torsion) {
                let angle = parseFloat(strval1);
                if (isNaN(angle))
                    return;
                let mask = WebMolKit.Vec.booleanArray(false, mol.numAtoms);
                for (let a of atoms)
                    mask[a - 1] = true;
                let instate = { 'mol': mol, 'currentAtom': atoms[2], 'currentBond': 0, 'selectedMask': mask };
                let molact = new WebMolKit.MoleculeActivity(instate, WebMolKit.ActivityType.AdjustTorsion, { 'angle': angle * WebMolKit.DEGRAD });
                molact.execute();
                if (molact.output.mol)
                    this.mol = molact.output.mol;
                return;
            }
        }
        updateQuery() {
            this.queryWidget.updateAtom();
        }
        updateExtra() {
            this.mol.setAtomExtra(this.atom, this.fieldsWidget.getExtraFields());
            this.mol.setAtomTransient(this.atom, this.fieldsWidget.getTransientFields());
        }
        fillAbbreviations() {
            if (WebMolKit.AbbrevContainer.needsSetup()) {
                setTimeout(() => WebMolKit.AbbrevContainer.setupData().then(() => this.fillAbbreviations()), 1);
                return;
            }
            this.tableAbbrev.empty();
            WebMolKit.AbbrevContainer.main.submitMolecule(this.mol, true);
            this.abbrevList = WebMolKit.AbbrevContainer.main.getAbbrevs();
            if (!this.svgAbbrev) {
                this.svgAbbrev = [];
                let policy = WebMolKit.RenderPolicy.defaultColourOnWhite(10);
                let measure = new WebMolKit.OutlineMeasurement(0, 0, policy.data.pointScale);
                for (let abbrev of this.abbrevList) {
                    let effects = new WebMolKit.RenderEffects();
                    let mol = abbrev.frag.clone();
                    effects.atomCircleSz = WebMolKit.Vec.numberArray(0, mol.numAtoms);
                    effects.atomCircleCol = WebMolKit.Vec.numberArray(0, mol.numAtoms);
                    for (let n = 1; n <= mol.numAtoms; n++)
                        if (mol.atomElement(n) == WebMolKit.MolUtil.ABBREV_ATTACHMENT) {
                            mol.setAtomElement(n, 'C');
                            effects.atomCircleSz[n - 1] = 0.2;
                            effects.atomCircleCol[n - 1] = 0x00C000;
                        }
                    let layout = new WebMolKit.ArrangeMolecule(mol, measure, policy, effects);
                    layout.arrange();
                    let gfx = new WebMolKit.MetaVector();
                    new WebMolKit.DrawMolecule(layout, gfx).draw();
                    gfx.normalise();
                    this.svgAbbrev.push(gfx.createSVG());
                }
                const { mol, atom } = this;
                if (atom > 0 && WebMolKit.MolUtil.hasAbbrev(mol, atom)) {
                    let name = mol.atomElement(atom), mf = WebMolKit.MolUtil.molecularFormula(WebMolKit.MolUtil.getAbbrev(mol, atom));
                    for (let n = 0; n < this.abbrevList.length; n++)
                        if (name == this.abbrevList[n].name) {
                            if (mf == WebMolKit.MolUtil.molecularFormula(this.abbrevList[n].frag))
                                this.currentAbbrev = n;
                            break;
                        }
                }
            }
            let tr = WebMolKit.dom('<tr/>').appendTo(this.tableAbbrev);
            tr.appendHTML('<td><u>Label</u></td>');
            tr.appendHTML('<td><u>Structure</u></td>');
            this.abbrevEntries = [];
            this.abbrevIndices = [];
            let search = this.inputAbbrevSearch.getValue().toLowerCase();
            for (let n = 0; n < this.abbrevList.length; n++) {
                if (this.currentAbbrev != n && !this.abbrevList[n].nameSearch.includes(search))
                    continue;
                let entry = {
                    'tr': WebMolKit.dom('<tr/>').appendTo(this.tableAbbrev),
                    'idx': n,
                    'bgcol': this.abbrevEntries.length % 2 == 0 ? '#FFFFFF' : '#F8F8F8'
                };
                entry.tr.setCSS('background-color', this.currentAbbrev == entry.idx ? WebMolKit.colourCode(WebMolKit.Theme.lowlight) : entry.bgcol);
                let tdLabel = WebMolKit.dom('<td/>').appendTo(entry.tr), tdStruct = WebMolKit.dom('<td/>').appendTo(entry.tr);
                tdLabel.setHTML(this.abbrevList[n].nameHTML);
                WebMolKit.dom(this.svgAbbrev[n]).appendTo(tdStruct).css({ 'display': 'block', 'pointer-events': 'none' });
                entry.tr.css({ 'cursor': 'pointer' });
                entry.tr.onClick(() => this.selectAbbreviation(n));
                entry.tr.onDblClick((event) => this.applyChanges());
                this.abbrevEntries.push(entry);
                this.abbrevIndices.push(n);
            }
        }
        selectAbbreviation(idx) {
            if (this.currentAbbrev == idx)
                return;
            this.currentAbbrev = idx;
            for (let entry of this.abbrevEntries) {
                entry.tr.setCSS('background-color', this.currentAbbrev == entry.idx ? WebMolKit.colourCode(WebMolKit.Theme.lowlight) : entry.bgcol);
                if (this.currentAbbrev == entry.idx)
                    entry.tr.el.scrollIntoView({ 'block': 'nearest' });
            }
        }
        cycleAbbreviation(dir) {
            let sz = this.abbrevIndices.length;
            if (sz == 0)
                return;
            let idx = this.abbrevIndices.indexOf(this.currentAbbrev);
            if (idx < 0) {
                if (dir < 0)
                    idx = sz - 1;
                else
                    idx = 0;
            }
            else
                idx = (idx + sz + dir) % sz;
            this.selectAbbreviation(this.abbrevIndices[idx]);
        }
        selectedTab(idx) {
            if (idx == 0)
                this.inputSymbol.grabFocus();
            else if (idx == 1)
                this.inputAbbrevSearch.grabFocus();
            else if (idx == 2)
                this.inputGeom1.grabFocus();
        }
    }
    WebMolKit.EditAtom = EditAtom;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class EditBond extends WebMolKit.Dialog {
        constructor(mol, bond, proxyClip, callbackApply) {
            super();
            this.bond = bond;
            this.proxyClip = proxyClip;
            this.callbackApply = callbackApply;
            this.initMol = mol;
            this.mol = mol.clone();
            this.title = 'Edit Bond';
            this.minPortionWidth = 20;
            this.maxPortionWidth = 95;
        }
        populate() {
            this.proxyClip.pushHandler(new WebMolKit.ClipboardProxyHandler());
            let buttons = this.buttonsDOM(), body = this.bodyDOM();
            this.btnApply = WebMolKit.dom('<button class="wmk-button wmk-button-primary">Apply</button>').appendTo(buttons).css({ 'margin-left': '0.5em' });
            this.btnApply.onClick(() => this.applyChanges());
            this.tabs = new WebMolKit.TabBar(['Bond', 'Geometry', 'Query', 'Extra']);
            this.tabs.render(body);
            this.tabs.onSelect((idx) => this.selectedTab(idx));
            this.populateBond(this.tabs.getPanelDOM('Bond'));
            this.populateGeometry(this.tabs.getPanelDOM('Geometry'));
            this.populateQuery(this.tabs.getPanelDOM('Query'));
            this.populateExtra(this.tabs.getPanelDOM('Extra'));
            let focusable = body.findAll('input,textarea');
            if (focusable.length > 0)
                focusable[0].grabFocus(true);
            for (let dom of focusable) {
                dom.css({ 'font': 'inherit' });
                dom.onKeyDown((event) => {
                    if (event.key == "Enter")
                        this.applyChanges();
                    else if (event.key == "Escape")
                        this.close();
                    else if (event.key == "PageUp") {
                        this.tabs.rotateSelected(-1);
                        this.selectedTab(this.tabs.getSelectedIndex());
                        event.preventDefault();
                    }
                    else if (event.key == "PageDown") {
                        this.tabs.rotateSelected(1);
                        this.selectedTab(this.tabs.getSelectedIndex());
                        event.preventDefault();
                    }
                    event.stopPropagation();
                });
            }
        }
        close() {
            this.proxyClip.popHandler();
            super.close();
        }
        applyChanges() {
            this.mol.keepTransient = true;
            this.updateMolecule();
            if (this.tabs.getSelectedValue() == 'Geometry')
                this.updateGeometry();
            if (this.tabs.getSelectedValue() == 'Query')
                this.updateQuery();
            if (this.tabs.getSelectedValue() == 'Extra')
                this.updateExtra();
            this.mol.keepTransient = false;
            if (this.callbackApply)
                this.callbackApply(this);
        }
        populateBond(panel) {
            const { mol, bond } = this;
            let grid = WebMolKit.dom('<div/>').appendTo(panel);
            grid.css({ 'display': 'grid', 'align-items': 'center', 'justify-content': 'start' });
            grid.css({ 'grid-row-gap': '0.5em', 'grid-column-gap': '0.5em' });
            grid.css({ 'grid-template-columns': '[start col0] auto [col1] auto [col2] auto [col3] auto [col4 end]' });
            WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': '1 / col0' }).setText('Order');
            let ordersHTML = [];
            for (let o = 0; o <= 4; o++)
                ordersHTML.push(`&nbsp;&nbsp;${o}&nbsp;&nbsp;`);
            this.optionOrder = new WebMolKit.OptionList(ordersHTML);
            this.optionOrder.htmlLabels = true;
            this.optionOrder.setSelectedIndex(mol.bondOrder(bond));
            this.optionOrder.render(WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-column': 'col1 / col4', 'grid-row': '1' }));
            WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': '2 / col0' }).setText('Stereo');
            this.optionStereo = new WebMolKit.OptionList(['None', 'Up', 'Down', 'Unknown']);
            this.optionStereo.setSelectedIndex(mol.bondType(bond));
            this.optionStereo.render(WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-column': 'col1 / col4', 'grid-row': '2' }));
            WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': '3 / col0' }).setText('From');
            this.inputFrom = WebMolKit.dom('<input size="6"/>').appendTo(grid).css({ 'grid-area': '3 / col1', 'font': 'inherit' });
            this.inputFrom.elInput.readOnly = true;
            this.inputFrom.setValue(mol.bondFrom(bond).toString());
            WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': '3 / col2' }).setText('To');
            this.inputTo = WebMolKit.dom('<input size="6"/>').appendTo(grid).css({ 'grid-area': '3 / col3', 'font': 'inherit' });
            this.inputTo.elInput.readOnly = true;
            this.inputTo.setValue(mol.bondTo(bond).toString());
            WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': '4 / col2' }).setText('Index');
            this.inputIndex = WebMolKit.dom('<input size="6"/>').appendTo(grid).css({ 'grid-area': '4 / col3', 'font': 'inherit' });
            this.inputIndex.elInput.readOnly = true;
            this.inputIndex.setValue(bond.toString());
        }
        populateGeometry(panel) {
            const { mol, bond } = this;
            let divContainer1 = WebMolKit.dom('<div/>').appendTo(panel).css({ 'text-align': 'center' });
            let divContainer2 = WebMolKit.dom('<div/>').appendTo(divContainer1).css({ 'display': 'inline-block' });
            let grid = WebMolKit.dom('<div/>').appendTo(divContainer2);
            grid.css({ 'display': 'grid', 'align-items': 'center', 'justify-content': 'start' });
            grid.css({ 'grid-row-gap': '0.5em', 'grid-column-gap': '0.5em' });
            grid.css({ 'grid-template-columns': '[start col0] auto [col1] auto [col2]' });
            this.geomWidget = new WebMolKit.GeomWidget(WebMolKit.GeomWidgetType.Bond, mol, bond);
            this.geomWidget.render(WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': '1 / col0 / auto / col2', 'text-align': 'center' }));
            let label1 = WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': '2 / col0' });
            this.inputGeom1 = WebMolKit.dom('<input type="number" size="8"/>').appendTo(grid).css({ 'grid-area': '2 / col1' });
            this.geomWidget.callbackSelect = (sel) => {
                if (sel.type == WebMolKit.GeomWidgetSelType.Link) {
                    let a1 = mol.bondFrom(bond), a2 = mol.bondTo(bond);
                    let dx = mol.atomX(a2) - mol.atomX(a1), dy = mol.atomY(a2) - mol.atomY(a1);
                    label1.setText('Distance');
                    this.inputGeom1.setValue(this.refGeom1 = WebMolKit.norm_xy(dx, dy).toFixed(3));
                }
            };
            this.geomWidget.callbackSelect(this.geomWidget.selected);
        }
        populateQuery(panel) {
            this.queryWidget = new WebMolKit.QueryFieldsWidget(this.mol, 0, this.bond);
            this.queryWidget.render(panel);
        }
        populateExtra(panel) {
            let fields = [...this.mol.bondExtra(this.bond), ...this.mol.bondTransient(this.bond)];
            this.fieldsWidget = new WebMolKit.ExtraFieldsWidget(fields);
            this.fieldsWidget.render(panel);
        }
        updateMolecule() {
            let { mol, bond } = this;
            mol.setBondOrder(bond, this.optionOrder.getSelectedIndex());
            mol.setBondType(bond, this.optionStereo.getSelectedIndex());
        }
        updateGeometry() {
            let strval1 = this.inputGeom1.getValue();
            if (this.refGeom1 == strval1)
                return;
            const { mol } = this;
            let sel = this.geomWidget.selected, atoms = this.geomWidget.selectionAtoms(sel);
            if (sel.type == WebMolKit.GeomWidgetSelType.Link) {
                if (this.refGeom1 != strval1) {
                    let dist = parseFloat(strval1);
                    if (isNaN(dist) || Math.abs(dist) > 100)
                        return;
                    let instate = { 'mol': mol, 'currentAtom': 0, 'currentBond': mol.findBond(atoms[0], atoms[1]), 'selectedMask': null };
                    let molact = new WebMolKit.MoleculeActivity(instate, WebMolKit.ActivityType.BondDist, { 'dist': dist });
                    molact.execute();
                    this.mol = molact.output.mol;
                    return;
                }
            }
        }
        updateQuery() {
            this.queryWidget.updateBond();
        }
        updateExtra() {
            this.mol.setBondExtra(this.bond, this.fieldsWidget.getExtraFields());
            this.mol.setBondTransient(this.bond, this.fieldsWidget.getTransientFields());
        }
        selectedTab(idx) {
            if (idx == 0)
                this.inputFrom.grabFocus();
            else if (idx == 1)
                this.inputGeom1.grabFocus();
        }
    }
    WebMolKit.EditBond = EditBond;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    const CHAR_LOW_A = 'a'.charCodeAt(0), CHAR_UP_A = 'A'.charCodeAt(0);
    function indexToAtomLabel(idx) { return String.fromCharCode(CHAR_UP_A + Math.min(26, Math.max(0, idx)) - 1); }
    function indexToBondLabel(idx) { return String.fromCharCode(CHAR_LOW_A + Math.min(26, Math.max(0, idx)) - 1); }
    class EditPolymer extends WebMolKit.Dialog {
        constructor(mol, atoms, proxyClip, callbackApply) {
            super();
            this.atoms = atoms;
            this.proxyClip = proxyClip;
            this.callbackApply = callbackApply;
            this.optionConnect = null;
            this.optionBondConn = null;
            this.currentID = 0;
            this.unit = null;
            this.borderAtoms = [];
            this.outBonds = [];
            this.outAtoms = [];
            this.initMol = mol;
            this.mol = mol.clone();
            this.title = 'Polymer Block';
            this.minPortionWidth = 20;
            this.maxPortionWidth = 95;
            this.polymer = new WebMolKit.PolymerBlock(this.mol);
            atoms = WebMolKit.Vec.sorted(atoms);
            for (let id of this.polymer.getIDList()) {
                let look = this.polymer.getUnit(id);
                if (WebMolKit.Vec.equals(atoms, look.atoms)) {
                    this.currentID = id;
                    this.unit = look;
                    break;
                }
            }
            if (!this.unit)
                this.unit = new WebMolKit.PolymerBlockUnit(atoms);
            let umol = this.umol = this.mol.clone();
            let mask = WebMolKit.Vec.booleanArray(false, this.umol.numAtoms);
            for (let n = 1; n <= this.mol.numBonds; n++) {
                let bfr = this.mol.bondFrom(n), bto = this.mol.bondTo(n);
                let in1 = this.atoms.includes(bfr), in2 = this.atoms.includes(bto);
                if (in1 || in2)
                    mask[bfr - 1] = mask[bto - 1] = true;
                if (in1 && !in2) {
                    this.borderAtoms.push(bfr);
                    this.outBonds.push(n);
                    this.outAtoms.push(bto);
                }
                if (in2 && !in1) {
                    this.borderAtoms.push(bto);
                    this.outBonds.push(n);
                    this.outAtoms.push(bfr);
                }
            }
            this.borderAtoms = WebMolKit.Vec.sortedUnique(this.borderAtoms);
            this.umap = WebMolKit.Vec.maskMap(mask);
            this.umol = WebMolKit.MolUtil.subgraphMask(this.umol, mask);
            new WebMolKit.PolymerBlock(this.umol).removeAll();
        }
        populate() {
            this.proxyClip.pushHandler(new WebMolKit.ClipboardProxyHandler());
            let buttons = this.buttonsDOM(), body = this.bodyDOM();
            this.btnApply = WebMolKit.dom('<button class="wmk-button wmk-button-primary">Apply</button>').appendTo(buttons).css({ 'margin-left': '0.5em' });
            if (this.currentID == 0)
                this.btnApply.setText('Create');
            this.btnApply.onClick(() => this.applyChanges());
            if (this.currentID > 0) {
                this.btnRemove = WebMolKit.dom('<button class="wmk-button wmk-button-default">Remove</button>').appendTo(buttons).css({ 'margin-left': '0.5em' });
                this.btnRemove.onClick(() => this.applyRemove());
            }
            let grid = WebMolKit.dom('<div/>').appendTo(body);
            grid.css({ 'display': 'grid', 'align-items': 'center', 'justify-content': 'start' });
            grid.css({ 'grid-row-gap': '0.5em', 'grid-column-gap': '0.5em' });
            grid.css({ 'grid-template-columns': '[start col0] auto [col1] auto [col2] auto [col3] auto [col4] auto [end]' });
            WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': '1 / col0' }).setText('# Atoms');
            let inputNAtoms = WebMolKit.dom('<input size="5"/>').appendTo(WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': '1 / col1' }));
            inputNAtoms.elInput.readOnly = true;
            inputNAtoms.setValue(this.unit.atoms.length.toString());
            WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': '1 / col2' }).setText('Out-bonds');
            let inputNBond = WebMolKit.dom('<input size="5"/>').appendTo(WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': '1 / col3' }));
            inputNBond.elInput.readOnly = true;
            inputNBond.setValue(this.outBonds.length.toString());
            let row = 1;
            if (this.outBonds.length == 2) {
                row++;
                WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': `${row} / col0` }).setText('Connectivity');
                this.optionConnect = new WebMolKit.OptionList(['Unknown', 'Head-to-Tail', 'Head-to-Head', 'Random']);
                this.optionConnect.render(WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': `${row} / col1 / auto / col4` }));
                if (this.unit.connect == WebMolKit.PolymerBlockConnectivity.HeadToTail)
                    this.optionConnect.setSelectedIndex(1);
                else if (this.unit.connect == WebMolKit.PolymerBlockConnectivity.HeadToHead)
                    this.optionConnect.setSelectedIndex(2);
                else if (this.unit.connect == WebMolKit.PolymerBlockConnectivity.Random)
                    this.optionConnect.setSelectedIndex(3);
            }
            if (this.outBonds.length == 4 && WebMolKit.Vec.uniqueUnstable(this.outAtoms).length == 4) {
                row++;
                WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': `${row} / col0` }).setText('2x2 Connectivity');
                this.populate2x2Conn(WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': `${row} / col1 / auto / end` }));
            }
            let getList = (str) => {
                if (!str)
                    return null;
                let list = [];
                for (let bit of str.split(',')) {
                    let v = parseInt(bit);
                    if (v > 0)
                        list.push(v);
                    else
                        return undefined;
                }
                return list;
            };
            for (let n = 0; n < this.borderAtoms.length; n++) {
                row++;
                let domLabel = WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': `${row} / col0`, 'text-align': 'right', 'padding-right': '0.5em' });
                if (n == 0)
                    domLabel.setText('Name ');
                WebMolKit.dom('<span/>').appendTo(domLabel).css({ 'color': '#008000' }).setText(indexToAtomLabel(n + 1));
                let input = WebMolKit.dom('<input size="20"/>').appendTo(WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': `${row} / col1 / auto / end`, 'width': '100%' }));
                let atom = this.borderAtoms[n];
                let nvals = this.unit.atomName.get(atom);
                if (nvals)
                    input.setValue(nvals.join(','));
                input.onInput(() => {
                    let list = getList(input.getValue());
                    if (list !== undefined)
                        this.unit.atomName.set(atom, list);
                });
            }
            for (let n = 0; n < this.outAtoms.length; n++) {
                row++;
                let domLabel = WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': `${row} / col0`, 'text-align': 'right', 'padding-right': '0.5em' });
                if (n == 0)
                    domLabel.setText('Link ');
                WebMolKit.dom('<span/>').appendTo(domLabel).css({ 'color': '#800080' }).setText(indexToBondLabel(n + 1));
                WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': `${row} / col1` }).setText('Include');
                let inputIncl = WebMolKit.dom('<input size="10"/>').appendTo(WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': `${row} / col2`, 'width': '100%' }));
                WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': `${row} / col3` }).setText('Exclude');
                let inputExcl = WebMolKit.dom('<input size="10"/>').appendTo(WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': `${row} / col4`, 'width': '100%' }));
                let bond = this.outBonds[n];
                let ivals = this.unit.bondIncl.get(bond), evals = this.unit.bondExcl.get(bond);
                if (ivals)
                    inputIncl.setValue(ivals.join(','));
                if (evals)
                    inputExcl.setValue(evals.join(','));
                inputIncl.onInput(() => {
                    let list = getList(inputIncl.getValue());
                    if (list !== undefined)
                        this.unit.bondIncl.set(bond, list);
                });
                inputExcl.onInput(() => {
                    let list = getList(inputExcl.getValue());
                    if (list !== undefined)
                        this.unit.bondExcl.set(bond, list);
                });
            }
            row++;
            this.populateUncap(WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': `${row} / col0 / auto / col4`, 'text-align': 'center' }));
            row++;
            this.divPreview = WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': `${row} / col0 / auto / col4`, 'text-align': 'center' });
            this.renderUnit();
            let focusable = body.findAll('input,textarea');
            if (focusable.length > 0)
                focusable[0].grabFocus(true);
            for (let dom of focusable) {
                dom.css({ 'font': 'inherit' });
                dom.onKeyDown((event) => {
                    let keyCode = event.keyCode || event.which;
                    if (keyCode == 13)
                        this.applyChanges();
                    if (keyCode == 27)
                        this.close();
                });
            }
        }
        close() {
            this.proxyClip.popHandler();
            super.close();
        }
        populate2x2Conn(div) {
            const perms = [[0, 1, 2, 3], [0, 1, 3, 2], [0, 2, 1, 3], [0, 2, 3, 1], [0, 3, 1, 2], [0, 3, 2, 1]];
            let bondConnOptions = [null];
            let optionList = ['None'];
            let selidx = 0;
            for (let perm of perms) {
                let bonds = WebMolKit.Vec.idxGet(this.outBonds, perm);
                if (WebMolKit.Vec.equals(bonds, this.unit.bondConn))
                    selidx = optionList.length;
                bondConnOptions.push(bonds);
                optionList.push(`${perm[0] + 1},${perm[1] + 1}:${perm[2] + 1},${perm[3] + 1}`);
            }
            this.optionBondConn = new WebMolKit.OptionList(optionList);
            this.optionBondConn.setSelectedIndex(selidx);
            this.optionBondConn.render(div);
            this.optionBondConn.onSelect((idx) => {
                this.unit.bondConn = bondConnOptions[idx];
                this.renderUnit();
            });
        }
        populateUncap(div) {
            let uncapAtoms = [];
            skip: for (let a of this.outAtoms)
                if (this.mol.atomAdjCount(a) == 1 && this.mol.atomElement(a) != '*') {
                    for (let unit of this.polymer.getUnits())
                        if (unit.atoms.includes(a))
                            continue skip;
                    uncapAtoms.push(a);
                }
            if (uncapAtoms.length == 0)
                return;
            let btnUncap = WebMolKit.dom('<button class="wmk-button wmk-button-default">Uncap Exterior</button>').appendTo(div);
            btnUncap.onClick(() => {
                btnUncap.elInput.disabled = true;
                for (let a of uncapAtoms)
                    this.mol.setAtomElement(a, '*');
            });
        }
        applyChanges() {
            if (this.optionConnect) {
                let sel = this.optionConnect.getSelectedIndex();
                if (sel == 0)
                    this.unit.connect = null;
                else if (sel == 1)
                    this.unit.connect = WebMolKit.PolymerBlockConnectivity.HeadToTail;
                else if (sel == 2)
                    this.unit.connect = WebMolKit.PolymerBlockConnectivity.HeadToHead;
                else if (sel == 3)
                    this.unit.connect = WebMolKit.PolymerBlockConnectivity.Random;
            }
            if (this.currentID)
                this.polymer.removeUnit(this.currentID);
            this.currentID = this.polymer.createUnit(this.unit.clone());
            this.polymer.rewriteMolecule();
            this.callbackApply(this);
        }
        applyRemove() {
            if (this.currentID)
                this.polymer.removeUnit(this.currentID);
            this.callbackApply(this);
        }
        renderUnit() {
            let umol = this.umol.clone();
            let policy = WebMolKit.RenderPolicy.defaultColourOnWhite(20);
            let measure = new WebMolKit.OutlineMeasurement(0, 0, policy.data.pointScale);
            let effects = new WebMolKit.RenderEffects();
            effects.atomCircleSz = WebMolKit.Vec.numberArray(0, umol.numAtoms);
            effects.atomCircleCol = WebMolKit.Vec.numberArray(0, umol.numAtoms);
            effects.atomDecoText = WebMolKit.Vec.stringArray(null, umol.numAtoms);
            effects.atomDecoCol = WebMolKit.Vec.numberArray(null, umol.numAtoms);
            effects.atomDecoSize = WebMolKit.Vec.numberArray(null, umol.numAtoms);
            let borderAtoms = this.borderAtoms.map((atom) => this.umap[atom - 1] + 1);
            let outAtoms = this.outAtoms.map((atom) => this.umap[atom - 1] + 1);
            for (let n = 1; n <= umol.numAtoms; n++) {
                let bidx = borderAtoms.indexOf(n), oidx = outAtoms.indexOf(n);
                if (bidx >= 0) {
                    effects.atomDecoText[n - 1] = indexToAtomLabel(bidx + 1);
                    effects.atomDecoCol[n - 1] = 0x008000;
                    effects.atomDecoSize[n - 1] = 0.5;
                }
                if (oidx >= 0) {
                    umol.setAtomCharge(n, 0);
                    umol.setAtomUnpaired(n, 0);
                    umol.setAtomIsotope(n, 0);
                    effects.atomCircleSz[n - 1] = 0.1;
                    effects.atomCircleCol[n - 1] = 0xFF00FF;
                    effects.atomDecoText[n - 1] = indexToBondLabel(oidx + 1);
                    effects.atomDecoCol[n - 1] = 0x800080;
                    effects.atomDecoSize[n - 1] = 0.5;
                    umol.setAtomElement(n, 'C');
                }
            }
            let layout = new WebMolKit.ArrangeMolecule(umol, measure, policy, effects);
            layout.arrange();
            layout.squeezeInto(0, 0, 300, 300);
            let gfx = new WebMolKit.MetaVector();
            if (this.unit.bondConn) {
                const LINES = [
                    [0, 1, 0xC86D08, 2, false], [2, 3, 0xC86D08, 2, false],
                    [0, 2, 0xC0C86D08, 1, true], [1, 3, 0xC0C86D08, 1, true]
                ];
                for (let [i1, i2, col, sz, circle] of LINES) {
                    let a1 = this.outAtoms[this.outBonds.indexOf(this.unit.bondConn[i1])];
                    let a2 = this.outAtoms[this.outBonds.indexOf(this.unit.bondConn[i2])];
                    let p1 = layout.getPoint(a1 - 1), p2 = layout.getPoint(a2 - 1);
                    gfx.drawLine(p1.oval.cx, p1.oval.cy, p2.oval.cx, p2.oval.cy, col, sz);
                    if (circle) {
                        for (let f of [0.2, 0.4, 0.6, 0.8]) {
                            let mx = p1.oval.cx + f * (p2.oval.cx - p1.oval.cx), my = p1.oval.cy + f * (p2.oval.cy - p1.oval.cy);
                            gfx.drawOval(mx, my, 2, 2, col, sz, null);
                        }
                    }
                }
            }
            new WebMolKit.DrawMolecule(layout, gfx).draw();
            gfx.normalise();
            this.divPreview.empty();
            WebMolKit.dom(gfx.createSVG()).appendTo(this.divPreview).css({ 'pointer-events': 'none' });
        }
    }
    WebMolKit.EditPolymer = EditPolymer;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class ExtraFieldsWidget extends WebMolKit.Widget {
        constructor(fields) {
            super();
            this.fields = fields;
        }
        render(parent) {
            super.render(parent);
            this.divFields = WebMolKit.dom('<div/>').appendTo(this.contentDOM);
            this.fillTable();
            let divButtons = WebMolKit.dom('<div/>').appendTo(this.contentDOM).css({ 'text-align': 'center' });
            let btnExtra = WebMolKit.dom('<button class="wmk-button wmk-button-default">Extra</button>').appendTo(divButtons);
            btnExtra.onClick(() => {
                this.fields.push(WebMolKit.Molecule.PREFIX_EXTRA);
                this.fillTable();
            });
            let btnTransient = WebMolKit.dom('<button class="wmk-button wmk-button-default">Transient</button>').appendTo(divButtons).css({ 'margin-left': '0.5em' });
            btnTransient.onClick(() => {
                this.fields.push(WebMolKit.Molecule.PREFIX_TRANSIENT);
                this.fillTable();
            });
        }
        getExtraFields() {
            let extra = [];
            for (let field of this.fields)
                if (!field.startsWith(WebMolKit.Molecule.PREFIX_TRANSIENT) && field.length > 1)
                    extra.push(field);
            return extra;
        }
        getTransientFields() {
            let transient = [];
            for (let field of this.fields)
                if (field.startsWith(WebMolKit.Molecule.PREFIX_TRANSIENT) && field.length > 1)
                    transient.push(field);
            return transient;
        }
        fillTable() {
            this.divFields.empty();
            if (this.fields.length == 0)
                return;
            let table = WebMolKit.dom('<table/>').appendTo(this.divFields).css({ 'width': '100%' });
            let tr = WebMolKit.dom('<tr/>').appendTo(table);
            WebMolKit.dom('<td/>').appendTo(tr).css({ 'text-align': 'right', 'font-weight': 'bold', 'text-decoration': 'underline' }).setText('Type');
            WebMolKit.dom('<td/>').appendTo(tr).css({ 'font-weight': 'bold', 'text-decoration': 'underline' }).setText('Value');
            for (let n = 0; n < this.fields.length; n++) {
                let strType = '?', strValue = '';
                if (this.fields[n].length > 0) {
                    strType = this.fields[n].charAt(0);
                    strValue = this.fields[n].substring(1);
                }
                tr = WebMolKit.dom('<tr/>').appendTo(table);
                let tdType = WebMolKit.dom('<td/>').appendTo(tr).css({ 'text-align': 'right' }), tdValue = WebMolKit.dom('<td/>').appendTo(tr), tdButton = WebMolKit.dom('<td/>').appendTo(tr);
                WebMolKit.dom('<span/>').appendTo(tdType).css({ 'padding': '0.2em', 'border': '1px solid black', 'background-color': '#C0C0C0' }).setText(strType);
                let input = WebMolKit.dom('<input size="20"/>').appendTo(tdValue).css({ 'width': '100%', 'font': 'inherit' });
                input.setValue(strValue);
                input.onInput(() => { this.fields[n] = strType + input.getValue(); });
                let btnDelete = WebMolKit.dom('<button class="wmk-button wmk-button-small wmk-button-default">\u{2716}</button>').appendTo(tdButton).css({ 'margin-left': '0.5em' });
                btnDelete.onClick(() => {
                    this.fields.splice(n, 1);
                    this.fillTable();
                });
            }
        }
    }
    WebMolKit.ExtraFieldsWidget = ExtraFieldsWidget;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let GeomWidgetType;
    (function (GeomWidgetType) {
        GeomWidgetType[GeomWidgetType["Atom"] = 0] = "Atom";
        GeomWidgetType[GeomWidgetType["Bond"] = 1] = "Bond";
    })(GeomWidgetType = WebMolKit.GeomWidgetType || (WebMolKit.GeomWidgetType = {}));
    let GeomWidgetSelType;
    (function (GeomWidgetSelType) {
        GeomWidgetSelType[GeomWidgetSelType["Position"] = 0] = "Position";
        GeomWidgetSelType[GeomWidgetSelType["Link"] = 1] = "Link";
        GeomWidgetSelType[GeomWidgetSelType["Torsion"] = 2] = "Torsion";
    })(GeomWidgetSelType = WebMolKit.GeomWidgetSelType || (WebMolKit.GeomWidgetSelType = {}));
    class GeomWidget extends WebMolKit.Widget {
        constructor(type, mol, idx) {
            super();
            this.type = type;
            this.mol = mol;
            this.idx = idx;
            this.posX = [];
            this.posY = [];
            this.linkA = [];
            this.linkB = [];
            this.torsA = [];
            this.torsB = [];
            this.hovered = null;
            if (type == GeomWidgetType.Atom) {
                const atom = idx;
                let adj = mol.atomAdjList(atom);
                this.atomSubset = [atom, ...adj];
                for (let b of mol.atomAdjBonds(atom)) {
                    this.linkA.push(0);
                    this.linkB.push(this.atomSubset.indexOf(mol.bondOther(b, atom)));
                }
                let theta = [];
                for (let a of adj)
                    theta.push(Math.atan2(-(mol.atomY(a) - mol.atomY(atom)), mol.atomX(a) - mol.atomX(atom)));
                let order = WebMolKit.Vec.idxSort(theta);
                for (let n = 0; n < order.length; n++) {
                    this.torsA.push(order[n] + 1);
                    this.torsB.push(order[n < order.length - 1 ? n + 1 : 0] + 1);
                }
                this.selected = { 'type': GeomWidgetSelType.Position, 'idx': 0 };
            }
            else {
                const bond = idx;
                let a1 = mol.bondFrom(bond), a2 = mol.bondTo(bond);
                this.atomSubset = [...mol.atomAdjList(a1), ...mol.atomAdjList(a2)];
                let link = (a1, a2) => {
                    this.linkA.push(this.atomSubset.indexOf(a1));
                    this.linkB.push(this.atomSubset.indexOf(a2));
                };
                link(a1, a2);
                for (let a of mol.atomAdjList(a1))
                    if (a != a2)
                        link(a1, a);
                for (let a of mol.atomAdjList(a2))
                    if (a != a1)
                        link(a2, a);
                this.selected = { 'type': GeomWidgetSelType.Link, 'idx': 0 };
            }
        }
        render(parent) {
            super.render(parent);
            let divOuter = WebMolKit.dom('<div/>').appendTo(this.contentDOM).css({ 'text-align': 'center' });
            this.divDiagram = WebMolKit.dom('<div/>').appendTo(divOuter).css({ 'display': 'inline-block' });
            this.contentDOM.onClick((event) => this.mouseClick(WebMolKit.eventCoords(event, this.divDiagram)));
            this.contentDOM.onMouseMove((event) => this.mouseMove(WebMolKit.eventCoords(event, this.divDiagram)));
            this.redraw();
        }
        selectionAtoms(sel) {
            const atoms = this.atomSubset;
            if (sel.type == GeomWidgetSelType.Position)
                return [atoms[sel.idx]];
            if (sel.type == GeomWidgetSelType.Link)
                return [atoms[this.linkA[sel.idx]], atoms[this.linkB[sel.idx]]];
            if (sel.type == GeomWidgetSelType.Torsion)
                return [atoms[0], atoms[this.torsA[sel.idx]], atoms[this.torsB[sel.idx]]];
            return null;
        }
        redraw() {
            this.divDiagram.empty();
            let w = 250, h = 250;
            this.posX = [];
            this.posY = [];
            const ANG_RAD = 0.25;
            for (let a of this.atomSubset) {
                this.posX.push(this.mol.atomX(a));
                this.posY.push(this.mol.atomY(a));
            }
            let loX = WebMolKit.Vec.min(this.posX) - ANG_RAD, hiX = WebMolKit.Vec.max(this.posX) + ANG_RAD;
            let loY = WebMolKit.Vec.min(this.posY) - ANG_RAD, hiY = WebMolKit.Vec.max(this.posY) + ANG_RAD;
            this.scale = Math.min(40, Math.min((w - 4) / (hiX - loX), (h - 4) / (hiY - loY)));
            let dx = 0.5 * (w - (hiX - loX) * this.scale), dy = 0.5 * (h - (hiY - loY) * this.scale);
            for (let n = 0; n < this.atomSubset.length; n++) {
                this.posX[n] = dx + (this.posX[n] - loX) * this.scale;
                this.posY[n] = h - (dy + (this.posY[n] - loY) * this.scale);
            }
            this.posRad = ANG_RAD * this.scale;
            let gfx = new WebMolKit.MetaVector();
            gfx.setSize(w, h);
            let fg = WebMolKit.Theme.foreground, bg = WebMolKit.Theme.background, outerSel = 0x008FD1, innerSel = 0x47D5D2;
            for (let n = 0; n < this.atomSubset.length; n++) {
                if (this.hovered && this.hovered.type == GeomWidgetSelType.Position && this.hovered.idx == n)
                    gfx.drawOval(this.posX[n], this.posY[n], this.posRad, this.posRad, fg, 1, bg);
                else if (this.selected && this.selected.type == GeomWidgetSelType.Position && this.selected.idx == n)
                    gfx.drawOval(this.posX[n], this.posY[n], this.posRad, this.posRad, outerSel, 1, innerSel);
                else
                    gfx.drawOval(this.posX[n], this.posY[n], this.posRad, this.posRad, WebMolKit.MetaVector.NOCOLOUR, 0, fg);
            }
            for (let showsel of [1, 2, 3])
                for (let n = 0; n < this.linkA.length; n++) {
                    let x1 = this.posX[this.linkA[n]], y1 = this.posY[this.linkA[n]];
                    let x2 = this.posX[this.linkB[n]], y2 = this.posY[this.linkB[n]];
                    if (this.hovered && this.hovered.type == GeomWidgetSelType.Link && this.hovered.idx == n) {
                        if (showsel == 3) {
                            gfx.drawLine(x1, y1, x2, y2, fg, this.scale * 0.1 + 2);
                            gfx.drawLine(x1, y1, x2, y2, bg, this.scale * 0.1);
                        }
                    }
                    else if (this.selected && this.selected.type == GeomWidgetSelType.Link && this.selected.idx == n) {
                        if (showsel == 2) {
                            gfx.drawLine(x1, y1, x2, y2, outerSel, this.scale * 0.1 + 2);
                            gfx.drawLine(x1, y1, x2, y2, innerSel, this.scale * 0.1);
                        }
                    }
                    else {
                        if (showsel == 1)
                            gfx.drawLine(x1, y1, x2, y2, fg, this.scale * 0.1);
                    }
                }
            for (let n = 0; n < this.torsA.length; n++) {
                let cx = this.posX[0], cy = this.posY[0];
                let dx1 = 0.5 * (this.posX[this.torsA[n]] - cx), dy1 = 0.5 * (this.posY[this.torsA[n]] - cy);
                let dx2 = 0.5 * (this.posX[this.torsB[n]] - cx), dy2 = 0.5 * (this.posY[this.torsB[n]] - cy);
                let rad = 0.5 * (WebMolKit.norm_xy(dx1, dy1) + WebMolKit.norm_xy(dx2, dy2));
                let theta1 = Math.atan2(dy1, dx1) + 10 * WebMolKit.DEGRAD, theta2 = Math.atan2(dy2, dx2) - 10 * WebMolKit.DEGRAD, dtheta = WebMolKit.angleDiff(theta2, theta1);
                let ox1 = rad * Math.cos(theta1), oy1 = rad * Math.sin(theta1), ox2 = rad * Math.cos(theta2), oy2 = rad * Math.sin(theta2);
                let px, py, pf;
                if (dtheta > 0) {
                    let [ax1, ay1, ax2, ay2] = WebMolKit.GeomUtil.arcControlPoints(rad, ox1, oy1, ox2, oy2);
                    px = WebMolKit.Vec.add([ox1, ax1, ax2, ox2], cx);
                    py = WebMolKit.Vec.add([oy1, ay1, ay2, oy2], cy);
                    pf = [false, true, true, false];
                }
                else {
                    let thetaM = theta1 + 0.5 * (dtheta + WebMolKit.TWOPI);
                    let oxM = rad * Math.cos(thetaM), oyM = rad * Math.sin(thetaM);
                    let [ax1, ay1, ax2, ay2] = WebMolKit.GeomUtil.arcControlPoints(rad, ox1, oy1, oxM, oyM);
                    let [ax3, ay3, ax4, ay4] = WebMolKit.GeomUtil.arcControlPoints(rad, oxM, oyM, ox2, oy2);
                    px = WebMolKit.Vec.add([ox1, ax1, ax2, oxM, ax3, ax4, ox2], cx);
                    py = WebMolKit.Vec.add([oy1, ay1, ay2, oyM, ay3, ay4, oy2], cy);
                    pf = [false, true, true, false, true, true, false];
                }
                if (this.hovered && this.hovered.type == GeomWidgetSelType.Torsion && this.hovered.idx == n) {
                    gfx.drawPath(px, py, pf, false, fg, this.scale * 0.1 + 2, WebMolKit.MetaVector.NOCOLOUR, false);
                    gfx.drawPath(px, py, pf, false, bg, this.scale * 0.1, WebMolKit.MetaVector.NOCOLOUR, false);
                }
                else if (this.selected && this.selected.type == GeomWidgetSelType.Torsion && this.selected.idx == n) {
                    gfx.drawPath(px, py, pf, false, outerSel, this.scale * 0.1 + 2, WebMolKit.MetaVector.NOCOLOUR, false);
                    gfx.drawPath(px, py, pf, false, innerSel, this.scale * 0.1, WebMolKit.MetaVector.NOCOLOUR, false);
                }
                else
                    gfx.drawPath(px, py, pf, false, fg, this.scale * 0.1, WebMolKit.MetaVector.NOCOLOUR, false);
            }
            this.divDiagram.empty();
            let svg = WebMolKit.dom(gfx.createSVG()).appendTo(this.divDiagram).css({ 'pointer-events': 'none' });
        }
        mouseClick(xy) {
            event.stopPropagation();
            if (this.type == GeomWidgetType.Bond)
                return;
            let which = this.whichSelection(xy[0], xy[1]);
            if (!which)
                return;
            if (!this.sameSelection(this.selected, which)) {
                this.selected = which;
                this.hovered = null;
                this.redraw();
                this.callbackSelect(which);
            }
        }
        mouseMove(xy) {
            if (this.type == GeomWidgetType.Bond)
                return;
            let which = this.whichSelection(xy[0], xy[1]);
            if (which && this.sameSelection(which, this.selected))
                which = null;
            if (!this.sameSelection(this.hovered, which)) {
                this.hovered = which;
                this.redraw();
            }
        }
        whichSelection(x, y) {
            let cx = this.posX[0], cy = this.posY[0];
            if (WebMolKit.norm_xy(x - cx, y - cy) <= this.posRad)
                return { 'type': GeomWidgetSelType.Position, 'idx': 0 };
            let maxRad = 0;
            for (let n = 1; n < this.atomSubset.length; n++)
                maxRad = Math.max(maxRad, WebMolKit.norm_xy(this.posX[n] - cx, this.posY[n] - cy) + this.posRad);
            if (WebMolKit.norm_xy(x - cx, y - cy) > maxRad)
                return null;
            let theta = Math.atan2(y - cy, x - cx);
            let closeSel = null, closeDelta = Number.POSITIVE_INFINITY;
            for (let n = 0; n < this.linkB.length; n++) {
                let delta = Math.abs(WebMolKit.angleDiff(Math.atan2(this.posY[this.linkB[n]] - cy, this.posX[this.linkB[n]] - cx), theta));
                if (delta < 10 * WebMolKit.DEGRAD && delta < closeDelta) {
                    closeSel = { 'type': GeomWidgetSelType.Link, 'idx': n };
                    closeDelta = delta;
                }
            }
            for (let n = 0; n < this.torsA.length; n++) {
                let theta1 = Math.atan2(this.posY[this.torsA[n]] - cy, this.posX[this.torsA[n]] - cx);
                let theta2 = Math.atan2(this.posY[this.torsB[n]] - cy, this.posX[this.torsB[n]] - cx);
                let midtheta = theta1 + 0.5 * (WebMolKit.angleDiff(theta2, theta1));
                let delta = Math.abs(WebMolKit.angleDiff(midtheta, theta));
                if (delta < closeDelta) {
                    closeSel = { 'type': GeomWidgetSelType.Torsion, 'idx': n };
                    closeDelta = delta;
                }
            }
            return closeSel;
        }
        sameSelection(sel1, sel2) {
            if (sel1 == null && sel2 == null)
                return true;
            if (sel1 == null || sel2 == null)
                return false;
            return sel1.type == sel2.type && sel1.idx == sel2.idx;
        }
    }
    WebMolKit.GeomWidget = GeomWidget;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class MetalLigate {
        constructor(mol, metalAtom, ligandAttach) {
            this.metalAtom = metalAtom;
            this.ligandAttach = ligandAttach;
            this.ligands = [];
            this.mol = mol.clone();
        }
        generate() {
            const { mol, metalAtom, ligandAttach, ligands } = this;
            let g = WebMolKit.Graph.fromMolecule(mol);
            g.isolateNode(metalAtom - 1);
            for (let cc of g.calculateComponentGroups()) {
                WebMolKit.Vec.addTo(cc, 1);
                let anything = false;
                for (let a of ligandAttach)
                    if (cc.indexOf(a) >= 0) {
                        anything = true;
                        break;
                    }
                if (!anything)
                    continue;
                let lig = { 'atoms': cc, 'attach': [] };
                lig.atoms = cc;
                let anyAttached = false;
                for (let a of lig.atoms)
                    if (mol.findBond(a, metalAtom) > 0) {
                        anyAttached = true;
                        break;
                    }
                for (let a of lig.atoms) {
                    let bonded = mol.findBond(a, metalAtom) > 0;
                    if (bonded || (!anyAttached && ligandAttach.includes(a)))
                        lig.attach.push(a);
                }
                ligands.push(lig);
                for (let a of lig.attach)
                    if (mol.findBond(a, metalAtom) == 0)
                        this.makeLigandBond(a);
            }
            if (ligands.length == 0)
                throw new Error('No ligand atoms');
            let otherLigands = mol.atomAdjList(metalAtom);
            for (let lig of ligands)
                otherLigands = WebMolKit.Vec.exclude(otherLigands, lig.attach);
            let mx = mol.atomX(metalAtom), my = mol.atomY(metalAtom);
            let otherTheta = new Array(otherLigands.length);
            for (let n = 0; n < otherLigands.length; n++)
                otherTheta[n] = Math.atan2(mol.atomY(otherLigands[n]) - my, mol.atomX(otherLigands[n]) - mx);
            for (let lig of ligands) {
                if (lig.attach.length == 1) {
                    let a = lig.attach[0];
                    lig.avgTheta = Math.atan2(mol.atomY(a) - my, mol.atomX(a) - mx);
                    this.orientLigand(lig);
                }
                else {
                    let theta = new Array(lig.attach.length);
                    for (let n = 0; n < lig.attach.length; n++) {
                        let a = lig.attach[n];
                        theta[n] = Math.atan2(mol.atomY(a) - my, mol.atomX(a) - mx);
                    }
                    theta = WebMolKit.GeomUtil.sortAngles(theta);
                    let base = theta[0];
                    for (let n = 0; n < theta.length; n++)
                        theta[n] = WebMolKit.angleDiffPos(theta[n], base);
                    lig.avgTheta = base + WebMolKit.Vec.sum(theta) / theta.length;
                    this.orientLigand(lig);
                }
            }
            if (otherLigands.length == 0) {
                ligands.sort((l1, l2) => WebMolKit.signum(l1.avgTheta - l2.avgTheta));
                this.arrangeLigandsFree(ligands);
            }
            else if (otherLigands.length == 1) {
                ligands.sort((l1, l2) => {
                    let diff1 = WebMolKit.angleDiffPos(l1.avgTheta, otherTheta[0]);
                    let diff2 = WebMolKit.angleDiffPos(l2.avgTheta, otherTheta[0]);
                    return WebMolKit.signum(diff1 - diff2);
                });
                this.arrangeLigandsRange(ligands, otherTheta[0], WebMolKit.TWOPI, true);
            }
            else {
                let otherOrder = WebMolKit.Vec.idxSort(otherTheta);
                for (let n = 0; n < otherOrder.length; n++) {
                    let nn = (n + 1) % otherOrder.length;
                    let theta = otherTheta[otherOrder[n]];
                    let extent = WebMolKit.angleDiffPos(otherTheta[otherOrder[nn]], theta);
                    let batch = [];
                    for (let lig of ligands) {
                        let diff = WebMolKit.angleDiffPos(lig.avgTheta, theta);
                        if (diff < extent)
                            batch.push(lig);
                    }
                    if (batch.length == 0)
                        continue;
                    batch.sort((l1, l2) => {
                        let diff1 = WebMolKit.angleDiffPos(l1.avgTheta, theta);
                        let diff2 = WebMolKit.angleDiffPos(l2.avgTheta, theta);
                        return WebMolKit.signum(diff1 - diff2);
                    });
                    this.arrangeLigandsRange(batch, theta, extent, true);
                }
            }
            this.resolveClashes();
            return mol;
        }
        makeLigandBond(ligAtom) {
            const { mol, metalAtom } = this;
            let mchg = mol.atomCharge(metalAtom), lchg = mol.atomCharge(ligAtom);
            if (mchg > 0 && lchg < 0) {
                mol.setAtomCharge(metalAtom, mchg - 1);
                mol.setAtomCharge(ligAtom, lchg + 1);
                mol.addBond(metalAtom, ligAtom, 1);
                return;
            }
            if (mchg < 0 && lchg > 0) {
                mol.setAtomCharge(metalAtom, mchg + 1);
                mol.setAtomCharge(ligAtom, lchg - 1);
                mol.addBond(metalAtom, ligAtom, 1);
                return;
            }
            let order = 0;
            if (mol.atomHExplicit(ligAtom) == WebMolKit.Molecule.HEXPLICIT_UNKNOWN && mol.atomHydrogens(ligAtom) > 0)
                order = 1;
            mol.addBond(metalAtom, ligAtom, order);
        }
        orientLigand(lig) {
            const { mol, metalAtom } = this;
            let mx = mol.atomX(metalAtom), my = mol.atomY(metalAtom);
            let lsz = lig.atoms.length, asz = lig.attach.length;
            let idxAttach = new Array(asz);
            for (let n = 0; n < asz; n++)
                idxAttach[n] = lig.atoms.indexOf(lig.attach[n]);
            let lx = new Array(lsz), ly = new Array(lsz);
            let ax = WebMolKit.MolUtil.arrayAtomX(mol), ay = WebMolKit.MolUtil.arrayAtomY(mol);
            let molExtent = WebMolKit.Vec.max(ax) - WebMolKit.Vec.min(ax) + WebMolKit.Vec.max(ay) - WebMolKit.Vec.min(ay);
            let dx = molExtent * Math.cos(lig.avgTheta), dy = molExtent * Math.sin(lig.avgTheta);
            for (let n = 0; n < lsz; n++) {
                lx[n] = mol.atomX(lig.atoms[n]) + dx;
                ly[n] = mol.atomY(lig.atoms[n]) + dy;
            }
            let cx = WebMolKit.Vec.sum(lx) / lsz, cy = WebMolKit.Vec.sum(ly) / lsz;
            let weight = [];
            for (let n = 0; n < lsz; n++) {
                let closest = Number.POSITIVE_INFINITY;
                for (let idx of idxAttach)
                    closest = Math.min(closest, WebMolKit.norm2_xy(lx[n] - lx[idx], ly[n] - ly[idx]));
                weight.push(1.0 / (1 + Math.sqrt(closest)));
            }
            let bestScore = Number.POSITIVE_INFINITY;
            let bestLX = null, bestLY = null;
            for (let theta = 0; theta < 360; theta += 15) {
                let cosTheta = Math.cos(theta * WebMolKit.DEGRAD), sinTheta = Math.sin(theta * WebMolKit.DEGRAD);
                let rx = new Array(lsz), ry = new Array(lsz);
                let score = 0;
                for (let n = 0; n < lsz; n++) {
                    let x = lx[n] - cx, y = ly[n] - cy;
                    rx[n] = cx + x * cosTheta - y * sinTheta;
                    ry[n] = cy + x * sinTheta + y * cosTheta;
                    let dist = WebMolKit.norm_xy(rx[n] - mx, ry[n] - my);
                    if (lig.attach.indexOf(lig.atoms[n]) >= 0)
                        score += dist;
                    else
                        score -= dist * weight[n];
                }
                if (score < bestScore) {
                    bestScore = score;
                    bestLX = rx;
                    bestLY = ry;
                }
            }
            lx = bestLX;
            ly = bestLY;
            if (asz == 1) {
                dx = WebMolKit.Molecule.IDEALBOND * Math.cos(lig.avgTheta);
                dy = WebMolKit.Molecule.IDEALBOND * Math.sin(lig.avgTheta);
                WebMolKit.Vec.addTo(lx, mx + dx - lx[idxAttach[0]]);
                WebMolKit.Vec.addTo(ly, my + dy - ly[idxAttach[0]]);
            }
            else {
                let attTheta = new Array(asz), attDist = WebMolKit.Vec.numberArray(0, asz), attDX = WebMolKit.Vec.numberArray(0, asz), attDY = WebMolKit.Vec.numberArray(0, asz);
                for (let n = 0; n < asz; n++) {
                    let ox = lx[idxAttach[n]] - mx, oy = ly[idxAttach[n]] - my;
                    attTheta[n] = Math.atan2(oy, ox);
                    if (asz > 2) {
                        attDist[n] = WebMolKit.norm_xy(ox, oy);
                        attDX[n] = ox / attDist[n];
                        attDY[n] = oy / attDist[n];
                    }
                }
                WebMolKit.Vec.addTo(attDist, -WebMolKit.Vec.min(attDist));
                let orderAttach = WebMolKit.GeomUtil.idxSortAngles(attTheta);
                let srcX = new Array(asz), srcY = new Array(asz);
                let dstX = new Array(asz), dstY = new Array(asz);
                let dtheta = 45 * WebMolKit.DEGRAD / (asz - 1), theta = lig.avgTheta - 0.5 * dtheta;
                for (let n = 0; n < asz; n++) {
                    srcX[n] = lx[idxAttach[orderAttach[n]]];
                    srcY[n] = ly[idxAttach[orderAttach[n]]];
                    dstX[n] = mx + WebMolKit.Molecule.IDEALBOND * Math.cos(theta) + attDist[n] * attDX[n];
                    dstY[n] = my + WebMolKit.Molecule.IDEALBOND * Math.sin(theta) + attDist[n] * attDY[n];
                    theta += dtheta / (asz - 1);
                }
                let tfm = WebMolKit.GeomUtil.superimpose(srcX, srcY, dstX, dstY);
                for (let n = 0; n < lsz; n++) {
                    let [x, y] = WebMolKit.GeomUtil.applyAffine(lx[n], ly[n], tfm);
                    lx[n] = x;
                    ly[n] = y;
                }
            }
            for (let n = 0; n < lsz; n++)
                mol.setAtomPos(lig.atoms[n], lx[n], ly[n]);
        }
        arrangeLigandsFree(batch) {
            if (batch.length == 1)
                return;
            let refTheta = WebMolKit.Vec.last(batch).avgTheta;
            refTheta += 0.5 * WebMolKit.angleDiffPos(WebMolKit.Vec.first(batch).avgTheta, refTheta);
            this.arrangeLigandsRange(batch, refTheta, WebMolKit.TWOPI, false);
        }
        arrangeLigandsRange(batch, refTheta, refSpan, bounded) {
            const { mol, metalAtom } = this;
            let mx = mol.atomX(metalAtom), my = mol.atomY(metalAtom);
            let bsz = batch.length;
            let thetaMin = new Array(bsz), thetaSpan = new Array(bsz);
            let ligandSpan = 0;
            for (let n = 0; n < bsz; n++) {
                let [theta1, theta2] = this.determineThetaBounds(batch[n]);
                thetaMin[n] = theta1;
                thetaSpan[n] = WebMolKit.angleDiffPos(theta2, theta1);
                ligandSpan += thetaSpan[n];
            }
            let residual = (refSpan - ligandSpan) / (bsz + (bounded ? 1 : 0));
            let theta = refTheta + (bounded ? residual : 0.5 * residual);
            for (let n = 0; n < bsz; n++) {
                let rotTheta = theta - thetaMin[n];
                let cosTheta = Math.cos(rotTheta), sinTheta = Math.sin(rotTheta);
                for (let a of batch[n].atoms) {
                    let x = mol.atomX(a) - mx, y = mol.atomY(a) - my;
                    mol.setAtomPos(a, mx + x * cosTheta - y * sinTheta, my + x * sinTheta + y * cosTheta);
                }
                theta += thetaSpan[n] + residual;
            }
        }
        determineThetaBounds(lig) {
            const { mol, metalAtom } = this;
            let theta = [];
            let mx = mol.atomX(metalAtom), my = mol.atomY(metalAtom);
            for (let n = 0; n < lig.attach.length; n++) {
                let x = mol.atomX(lig.attach[n]) - mx;
                let y = mol.atomY(lig.attach[n]) - my;
                theta.push(Math.atan2(y, x));
            }
            WebMolKit.Vec.sort(theta);
            let bestScore = Number.POSITIVE_INFINITY, bestMin = 0, bestMax = 0;
            for (let n = 0; n < theta.length; n++) {
                let score = 0;
                for (let i = 0; i < theta.length - 1; i++)
                    score += WebMolKit.angleDiffPos(theta[i + 1], theta[i]);
                if (score < bestScore) {
                    bestScore = score;
                    bestMin = WebMolKit.Vec.first(theta);
                    bestMax = WebMolKit.Vec.last(theta);
                }
                theta.push(theta.shift());
            }
            return [bestMin, bestMax];
        }
        resolveClashes() {
            const { mol, metalAtom, ligands } = this;
            const na = mol.numAtoms, nb = mol.numBonds, lsz = this.ligands.length;
            let ablk = WebMolKit.Vec.numberArray(-1, na), bblk = WebMolKit.Vec.numberArray(-1, nb);
            for (let n = 1; n <= na; n++)
                if (mol.atomConnComp(n) == mol.atomConnComp(metalAtom))
                    ablk[n - 1] = 0;
            for (let n = 0; n < lsz; n++)
                for (let a of ligands[n].atoms)
                    ablk[a - 1] = n + 1;
            for (let n = 1; n <= nb; n++) {
                let blk1 = ablk[mol.bondFrom(n) - 1], blk2 = ablk[mol.bondTo(n) - 1];
                if (blk1 < 0 || blk2 < 0) { }
                else if (blk1 == blk2)
                    bblk[n - 1] = blk1;
            }
            let bumpDX = new Array(lsz), bumpDY = new Array(lsz);
            let mx = mol.atomX(metalAtom), my = mol.atomY(metalAtom);
            for (let n = 0; n < lsz; n++) {
                let lig = ligands[n];
                let dx = 0, dy = 0;
                for (let a of lig.attach) {
                    dx += mol.atomX(a) - mx;
                    dy += mol.atomY(a) - my;
                }
                dx /= lig.attach.length;
                dy /= lig.attach.length;
                let invDist = 1.0 / WebMolKit.norm_xy(dx, dy);
                bumpDX[n] = dx * 0.5 * invDist;
                bumpDY[n] = dy * 0.5 * invDist;
            }
            const CLOSE_SQ = WebMolKit.sqr(0.5);
            for (let count = 0; count < 12; count++) {
                let tainted = WebMolKit.Vec.booleanArray(false, lsz);
                outer: for (let i = 0; i < na - 1; i++) {
                    if (ablk[i] < 0)
                        continue;
                    for (let j = i + 1; j < na; j++)
                        if (ablk[j] >= 0 && ablk[j] != ablk[i]) {
                            if (WebMolKit.norm2_xy(mol.atomX(i + 1) - mol.atomX(j + 1), mol.atomY(i + 1) - mol.atomY(j + 1)) < CLOSE_SQ) {
                                if (ablk[i] > 0)
                                    tainted[ablk[i] - 1] = true;
                                if (ablk[j] > 0)
                                    tainted[ablk[j] - 1] = true;
                            }
                            if (WebMolKit.Vec.allTrue(tainted))
                                break outer;
                        }
                }
                if (WebMolKit.Vec.anyFalse(tainted))
                    outer: for (let i = 0; i < nb - 1; i++) {
                        if (bblk[i] < 0)
                            continue;
                        let x1 = mol.atomX(mol.bondFrom(i + 1)), y1 = mol.atomY(mol.bondFrom(i + 1));
                        let x2 = mol.atomX(mol.bondTo(i + 1)), y2 = mol.atomY(mol.bondTo(i + 1));
                        for (let j = i + 1; j < nb; j++)
                            if (bblk[j] >= 0 && bblk[j] != bblk[i]) {
                                let x3 = mol.atomX(mol.bondFrom(j + 1)), y3 = mol.atomY(mol.bondFrom(j + 1));
                                let x4 = mol.atomX(mol.bondTo(j + 1)), y4 = mol.atomY(mol.bondTo(j + 1));
                                if (WebMolKit.GeomUtil.doLineSegsIntersect(x1, y1, x2, y2, x3, y3, x4, y4)) {
                                    if (bblk[i] > 0)
                                        tainted[bblk[i] - 1] = true;
                                    if (bblk[j] > 0)
                                        tainted[bblk[j] - 1] = true;
                                }
                                if (WebMolKit.Vec.allTrue(tainted))
                                    break outer;
                            }
                    }
                if (WebMolKit.Vec.allFalse(tainted))
                    break;
                for (let n = 0; n < lsz; n++)
                    if (tainted[n]) {
                        for (let a of ligands[n].atoms) {
                            mol.setAtomPos(a, mol.atomX(a) + bumpDX[n], mol.atomY(a) + bumpDY[n]);
                        }
                    }
            }
        }
    }
    WebMolKit.MetalLigate = MetalLigate;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let ActivityType;
    (function (ActivityType) {
        ActivityType[ActivityType["Delete"] = 1] = "Delete";
        ActivityType[ActivityType["Clear"] = 2] = "Clear";
        ActivityType[ActivityType["Copy"] = 3] = "Copy";
        ActivityType[ActivityType["Cut"] = 4] = "Cut";
        ActivityType[ActivityType["SelectAll"] = 5] = "SelectAll";
        ActivityType[ActivityType["SelectNone"] = 6] = "SelectNone";
        ActivityType[ActivityType["SelectPrevComp"] = 7] = "SelectPrevComp";
        ActivityType[ActivityType["SelectNextComp"] = 8] = "SelectNextComp";
        ActivityType[ActivityType["SelectSide"] = 9] = "SelectSide";
        ActivityType[ActivityType["SelectGrow"] = 10] = "SelectGrow";
        ActivityType[ActivityType["SelectShrink"] = 11] = "SelectShrink";
        ActivityType[ActivityType["SelectChain"] = 12] = "SelectChain";
        ActivityType[ActivityType["SelectSmRing"] = 13] = "SelectSmRing";
        ActivityType[ActivityType["SelectRingBlk"] = 14] = "SelectRingBlk";
        ActivityType[ActivityType["SelectCurElement"] = 15] = "SelectCurElement";
        ActivityType[ActivityType["SelectToggle"] = 16] = "SelectToggle";
        ActivityType[ActivityType["SelectUnCurrent"] = 17] = "SelectUnCurrent";
        ActivityType[ActivityType["Element"] = 18] = "Element";
        ActivityType[ActivityType["AtomPos"] = 19] = "AtomPos";
        ActivityType[ActivityType["Charge"] = 20] = "Charge";
        ActivityType[ActivityType["Connect"] = 21] = "Connect";
        ActivityType[ActivityType["Disconnect"] = 22] = "Disconnect";
        ActivityType[ActivityType["MetalLigate"] = 23] = "MetalLigate";
        ActivityType[ActivityType["BondOrder"] = 24] = "BondOrder";
        ActivityType[ActivityType["BondType"] = 25] = "BondType";
        ActivityType[ActivityType["BondGeom"] = 26] = "BondGeom";
        ActivityType[ActivityType["BondAtom"] = 27] = "BondAtom";
        ActivityType[ActivityType["BondSwitch"] = 28] = "BondSwitch";
        ActivityType[ActivityType["BondRotate"] = 29] = "BondRotate";
        ActivityType[ActivityType["BondAddTwo"] = 30] = "BondAddTwo";
        ActivityType[ActivityType["BondInsert"] = 31] = "BondInsert";
        ActivityType[ActivityType["Join"] = 32] = "Join";
        ActivityType[ActivityType["Nudge"] = 33] = "Nudge";
        ActivityType[ActivityType["NudgeLots"] = 34] = "NudgeLots";
        ActivityType[ActivityType["NudgeFar"] = 35] = "NudgeFar";
        ActivityType[ActivityType["Flip"] = 36] = "Flip";
        ActivityType[ActivityType["Scale"] = 37] = "Scale";
        ActivityType[ActivityType["Rotate"] = 38] = "Rotate";
        ActivityType[ActivityType["BondDist"] = 39] = "BondDist";
        ActivityType[ActivityType["AlignAngle"] = 40] = "AlignAngle";
        ActivityType[ActivityType["AdjustTorsion"] = 41] = "AdjustTorsion";
        ActivityType[ActivityType["Move"] = 42] = "Move";
        ActivityType[ActivityType["Ring"] = 43] = "Ring";
        ActivityType[ActivityType["TemplateFusion"] = 44] = "TemplateFusion";
        ActivityType[ActivityType["AbbrevTempl"] = 45] = "AbbrevTempl";
        ActivityType[ActivityType["AbbrevGroup"] = 46] = "AbbrevGroup";
        ActivityType[ActivityType["AbbrevFormula"] = 47] = "AbbrevFormula";
        ActivityType[ActivityType["AbbrevClear"] = 48] = "AbbrevClear";
        ActivityType[ActivityType["AbbrevExpand"] = 49] = "AbbrevExpand";
        ActivityType[ActivityType["BondArtifactPath"] = 50] = "BondArtifactPath";
        ActivityType[ActivityType["BondArtifactRing"] = 51] = "BondArtifactRing";
        ActivityType[ActivityType["BondArtifactArene"] = 52] = "BondArtifactArene";
        ActivityType[ActivityType["BondArtifactClear"] = 53] = "BondArtifactClear";
        ActivityType[ActivityType["PolymerBlock"] = 54] = "PolymerBlock";
        ActivityType[ActivityType["AddHydrogens"] = 55] = "AddHydrogens";
        ActivityType[ActivityType["RemoveHydrogens"] = 56] = "RemoveHydrogens";
        ActivityType[ActivityType["QueryClear"] = 57] = "QueryClear";
        ActivityType[ActivityType["QueryCopy"] = 58] = "QueryCopy";
        ActivityType[ActivityType["QueryPaste"] = 59] = "QueryPaste";
        ActivityType[ActivityType["QuerySetAtom"] = 60] = "QuerySetAtom";
        ActivityType[ActivityType["QuerySetBond"] = 61] = "QuerySetBond";
        ActivityType[ActivityType["QueryBondAny"] = 62] = "QueryBondAny";
    })(ActivityType = WebMolKit.ActivityType || (WebMolKit.ActivityType = {}));
    class MoleculeActivity {
        constructor(input, activity, param, owner) {
            this.input = input;
            this.activity = activity;
            this.param = param;
            this.owner = owner;
            this.toClipboard = null;
            this.output =
                {
                    'mol': null,
                    'currentAtom': -1,
                    'currentBond': -1,
                    'selectedMask': null
                };
            let na = this.input.mol.numAtoms;
            if (this.input.selectedMask == null)
                this.input.selectedMask = WebMolKit.Vec.booleanArray(false, na);
            while (this.input.selectedMask.length < na)
                this.input.selectedMask.push(false);
            this.subjectMask = this.input.selectedMask.slice(0);
            this.subjectLength = WebMolKit.Vec.maskCount(this.subjectMask);
            this.subjectIndex = [];
            this.hasSelected = this.subjectLength > 0;
            if (this.subjectLength == 0) {
                if (this.input.currentAtom > 0) {
                    this.subjectLength = 1;
                    this.subjectMask[this.input.currentAtom - 1] = true;
                    this.subjectIndex = [this.input.currentAtom];
                }
                else if (this.input.currentBond > 0) {
                    let bfr = this.input.mol.bondFrom(this.input.currentBond), bto = this.input.mol.bondTo(this.input.currentBond);
                    let b1 = Math.min(bfr, bto), b2 = Math.max(bfr, bto);
                    this.subjectLength = 2;
                    this.subjectMask[b1 - 1] = true;
                    this.subjectMask[b2 - 1] = true;
                    this.subjectIndex = [b1, b2];
                }
            }
            else {
                this.subjectIndex = WebMolKit.Vec.maskIdx(this.subjectMask);
                WebMolKit.Vec.addTo(this.subjectIndex, 1);
            }
        }
        setOwner(owner) {
            this.owner = owner;
        }
        evaluate() {
            return true;
        }
        execute() {
            let param = this.param;
            if (this.activity == ActivityType.Delete)
                this.execDelete();
            else if (this.activity == ActivityType.Clear)
                this.execClear();
            else if (this.activity == ActivityType.Copy)
                this.execCopy(false);
            else if (this.activity == ActivityType.Cut)
                this.execCopy(true);
            else if (this.activity == ActivityType.SelectAll)
                this.execSelectAll(true);
            else if (this.activity == ActivityType.SelectNone)
                this.execSelectAll(false);
            else if (this.activity == ActivityType.SelectPrevComp)
                this.execSelectComp(-1);
            else if (this.activity == ActivityType.SelectNextComp)
                this.execSelectComp(1);
            else if (this.activity == ActivityType.SelectSide)
                this.execSelectSide();
            else if (this.activity == ActivityType.SelectGrow)
                this.execSelectGrow();
            else if (this.activity == ActivityType.SelectShrink)
                this.execSelectShrink();
            else if (this.activity == ActivityType.SelectChain)
                this.execSelectChain();
            else if (this.activity == ActivityType.SelectSmRing)
                this.execSelectSmRing();
            else if (this.activity == ActivityType.SelectRingBlk)
                this.execSelectRingBlk();
            else if (this.activity == ActivityType.SelectCurElement)
                this.execSelectCurElement();
            else if (this.activity == ActivityType.SelectToggle)
                this.execSelectToggle();
            else if (this.activity == ActivityType.SelectUnCurrent)
                this.execSelectUnCurrent();
            else if (this.activity == ActivityType.Element)
                this.execElement(param.element, param.positionX, param.positionY, param.keepAbbrev);
            else if (this.activity == ActivityType.Charge)
                this.execCharge(param.delta);
            else if (this.activity == ActivityType.Connect)
                this.execConnect(1, WebMolKit.Molecule.BONDTYPE_NORMAL);
            else if (this.activity == ActivityType.Disconnect)
                this.execDisconnect();
            else if (this.activity == ActivityType.MetalLigate)
                this.execMetalLigate();
            else if (this.activity == ActivityType.BondOrder)
                this.execBond(param.order, WebMolKit.Molecule.BONDTYPE_NORMAL);
            else if (this.activity == ActivityType.BondType)
                this.execBond(1, param.type);
            else if (this.activity == ActivityType.BondGeom)
                this.execBondGeom(param.geom);
            else if (this.activity == ActivityType.BondAtom)
                this.execBondAtom(param.order, param.type, param.element, param.x1, param.y1, param.x2, param.y2);
            else if (this.activity == ActivityType.BondSwitch)
                this.execBondSwitch();
            else if (this.activity == ActivityType.BondRotate)
                this.execBondRotate();
            else if (this.activity == ActivityType.BondAddTwo)
                this.execBondAddTwo();
            else if (this.activity == ActivityType.BondInsert)
                this.execBondInsert();
            else if (this.activity == ActivityType.Join)
                this.execJoin();
            else if (this.activity == ActivityType.Nudge)
                this.execNudge(param.dir, 0.1);
            else if (this.activity == ActivityType.NudgeLots)
                this.execNudge(param.dir, 1);
            else if (this.activity == ActivityType.NudgeFar)
                this.execNudgeFar(param.dir);
            else if (this.activity == ActivityType.Flip)
                this.execFlip(param.axis);
            else if (this.activity == ActivityType.Scale)
                this.execScale(param.mag);
            else if (this.activity == ActivityType.Rotate)
                this.execRotate(param.theta, param.centreX, param.centreY);
            else if (this.activity == ActivityType.BondDist)
                this.execBondDist(param.dist);
            else if (this.activity == ActivityType.AlignAngle)
                this.execAlignAngle(param.angle);
            else if (this.activity == ActivityType.AdjustTorsion)
                this.execAdjustTorsion(param.angle);
            else if (this.activity == ActivityType.Move)
                this.execMove(param.refAtom, param.deltaX, param.deltaY);
            else if (this.activity == ActivityType.Ring)
                this.execRing(param.ringX, param.ringY, param.aromatic);
            else if (this.activity == ActivityType.TemplateFusion) {
                this.execTemplateFusion(WebMolKit.Molecule.fromString(param.fragNative));
                if (this.owner)
                    this.owner.setPermutations(this.output.permutations);
                return;
            }
            else if (this.activity == ActivityType.AbbrevTempl)
                this.execAbbrevTempl();
            else if (this.activity == ActivityType.AbbrevGroup)
                this.execAbbrevGroup();
            else if (this.activity == ActivityType.AbbrevFormula)
                this.execAbbrevFormula();
            else if (this.activity == ActivityType.AbbrevClear)
                this.execAbbrevClear();
            else if (this.activity == ActivityType.AbbrevExpand)
                this.execAbbrevExpand();
            else if (this.activity == ActivityType.BondArtifactPath || this.activity == ActivityType.BondArtifactRing ||
                this.activity == ActivityType.BondArtifactArene || this.activity == ActivityType.BondArtifactClear)
                this.execBondArtifact(this.activity);
            else if (this.activity == ActivityType.PolymerBlock)
                this.execPolymerBlock();
            else if (this.activity == ActivityType.AddHydrogens)
                this.execAddHydrogens();
            else if (this.activity == ActivityType.RemoveHydrogens)
                this.execRemoveHydrogens();
            else if (this.activity == ActivityType.QueryClear)
                this.execQueryClear();
            else if (this.activity == ActivityType.QueryCopy)
                this.execQueryCopy();
            else if (this.activity == ActivityType.QueryPaste)
                this.execQueryPaste();
            else if (this.activity == ActivityType.QuerySetAtom)
                this.execQuerySetAtom();
            else if (this.activity == ActivityType.QuerySetBond)
                this.execQuerySetBond();
            else if (this.activity == ActivityType.QueryBondAny)
                this.execQueryBondAny();
            this.finish();
        }
        finish() {
            if (!this.owner)
                return;
            if (this.output.mol != null || this.output.currentAtom >= 0 || this.output.currentBond >= 0 || this.output.selectedMask != null) {
                this.owner.setState(this.output, true);
                if (this.errmsg != null)
                    this.owner.showMessage(this.errmsg, false);
            }
            else {
                if (this.errmsg != null)
                    this.owner.showMessage(this.errmsg, true);
            }
        }
        execDelete() {
            if (!this.requireSubject())
                return;
            let mol = this.input.mol;
            this.output.mol = mol.clone();
            this.zapSubject();
            if (this.input.currentBond > 0 && !this.hasSelected) {
                this.output.mol.deleteBond(this.input.currentBond);
                this.output.currentBond = 0;
                return;
            }
            if (this.subjectLength == 1 && this.subjectIndex[0] == this.input.currentAtom) {
                let adj = mol.atomAdjList(this.input.currentAtom);
                if (adj.length == 1) {
                    this.output.currentAtom = adj[0];
                    if (this.output.currentAtom > this.input.currentAtom)
                        this.output.currentAtom--;
                }
            }
            for (let n = this.subjectLength - 1; n >= 0; n--)
                this.output.mol.deleteAtomAndBonds(this.subjectIndex[n]);
        }
        execCopy(withCut) {
            let mol = this.input.mol;
            if (this.subjectLength > 0)
                mol = WebMolKit.MolUtil.subgraphWithAttachments(mol, this.subjectMask);
            if (this.owner)
                this.owner.performCopy(mol);
            else
                this.toClipboard = mol.toString();
            if (withCut) {
                this.zapSubject();
                this.output.mol = WebMolKit.MolUtil.subgraphMask(this.input.mol, WebMolKit.Vec.notMask(this.subjectMask));
            }
        }
        execClear() {
            this.output.mol = new WebMolKit.Molecule();
            this.zapSubject();
        }
        execSelectAll(all) {
            let same = true;
            for (let n = 0; n < this.input.mol.numAtoms; n++)
                if (this.subjectMask[n] != all) {
                    same = false;
                    break;
                }
            if (same) {
                this.errmsg = all ? 'All atoms already selected.' : 'All atoms already deselected.';
                return;
            }
            this.output.selectedMask = WebMolKit.Vec.booleanArray(all, this.input.mol.numAtoms);
        }
        execSelectComp(dir) {
            let cclist = WebMolKit.MolUtil.componentList(this.input.mol);
            if (cclist.length == 1 && this.hasSelected && this.subjectLength == this.input.mol.numAtoms) {
                this.errmsg = 'All atoms already selected.';
                return;
            }
            let sel = this.pickSelectedGroup(cclist, dir);
            this.output.selectedMask = WebMolKit.Vec.booleanArray(false, this.input.mol.numAtoms);
            for (let n = 0; n < cclist[sel].length; n++)
                this.output.selectedMask[cclist[sel][n] - 1] = true;
        }
        execSelectSide() {
            if (!this.requireCurrent())
                return;
            let mol = this.input.mol, currentAtom = this.input.currentAtom, currentBond = this.input.currentBond;
            if (currentAtom > 0 && mol.atomAdjCount(currentAtom) == 0) {
                this.errmsg = 'Current atom has no neighbours.';
                return;
            }
            if (currentBond > 0 && mol.atomAdjCount(mol.bondFrom(currentBond)) == 1 && mol.atomAdjCount(mol.bondTo(currentBond)) == 1) {
                this.errmsg = 'Current bond has no neighbours.';
                return;
            }
            let sides = currentAtom > 0 ? WebMolKit.MolUtil.getAtomSides(mol, currentAtom) : WebMolKit.MolUtil.getBondSides(mol, currentBond);
            let sel = this.pickSelectedGroup(sides, 1);
            this.output.selectedMask = WebMolKit.Vec.booleanArray(false, mol.numAtoms);
            for (let n = 0; n < sides[sel].length; n++)
                this.output.selectedMask[sides[sel][n] - 1] = true;
        }
        execSelectGrow() {
            if (!this.requireSubject())
                return;
            let mol = this.input.mol, currentAtom = this.input.currentAtom, currentBond = this.input.currentBond;
            this.output.selectedMask = this.input.selectedMask.slice(0);
            if (!this.hasSelected) {
                if (currentAtom > 0) {
                    this.output.selectedMask[currentAtom - 1] = true;
                }
                else {
                    this.output.selectedMask[mol.bondFrom(currentBond) - 1] = true;
                    this.output.selectedMask[mol.bondTo(currentBond) - 1] = true;
                }
            }
            else {
                for (let n = 1; n <= mol.numBonds; n++) {
                    let bfr = mol.bondFrom(n) - 1, bto = mol.bondTo(n) - 1;
                    if (this.input.selectedMask[bfr] && !this.input.selectedMask[bto])
                        this.output.selectedMask[bto] = true;
                    else if (this.input.selectedMask && !this.input.selectedMask[bfr])
                        this.output.selectedMask[bfr] = true;
                }
            }
        }
        execSelectShrink() {
            if (!this.requireSelected())
                return;
            let mol = this.input.mol;
            let count = WebMolKit.Vec.numberArray(0, mol.numAtoms);
            for (let n = 1; n <= mol.numBonds; n++) {
                let bfr = mol.bondFrom(n) - 1, bto = mol.bondTo(n) - 1;
                if (!this.input.selectedMask[bfr] || !this.input.selectedMask[bto])
                    continue;
                count[bfr]++;
                count[bto]++;
            }
            this.output.selectedMask = this.input.selectedMask.slice(0);
            for (let n = 0; n < mol.numAtoms; n++)
                this.output.selectedMask[n] = this.input.selectedMask[n] && count[n] >= 2;
        }
        execSelectChain() {
            if (!this.requireSubject())
                return;
            let mol = this.input.mol;
            this.output.selectedMask = this.input.selectedMask.slice(0);
            for (let n = 1; n <= mol.numBonds; n++) {
                let bfr = mol.bondFrom(n) - 1, bto = mol.bondTo(n) - 1;
                if (this.input.selectedMask[bfr] && !this.input.selectedMask[bto] && mol.atomRingBlock(bto + 1) == 0)
                    this.output.selectedMask[bto] = true;
                else if (this.input.selectedMask[bto] && !this.input.selectedMask[bfr] && mol.atomRingBlock(bfr + 1) == 0)
                    this.output.selectedMask[bfr] = true;
            }
        }
        execSelectSmRing() {
            if (!this.requireSubject())
                return;
            this.output.selectedMask = this.input.selectedMask.slice(0);
            for (let r = 3; r <= 8; r++) {
                let rings = this.input.mol.findRingsOfSize(r);
                for (let i = 0; i < rings.length; i++) {
                    let any = false;
                    for (let j = 0; j < rings[i].length; j++)
                        if (this.subjectMask[rings[i][j] - 1]) {
                            any = true;
                            break;
                        }
                    if (any)
                        for (let j = 0; j < rings[i].length; j++)
                            this.output.selectedMask[rings[i][j] - 1] = true;
                }
            }
        }
        execSelectRingBlk() {
            if (!this.requireSubject())
                return;
            let mol = this.input.mol;
            this.output.selectedMask = this.input.selectedMask.slice(0);
            let maxRB = 0;
            for (let n = 1; n <= mol.numAtoms; n++)
                maxRB = Math.max(maxRB, mol.atomRingBlock(n));
            if (maxRB == 0)
                return;
            let gotRB = WebMolKit.Vec.booleanArray(false, maxRB);
            for (let n = 1; n <= mol.numAtoms; n++) {
                let rb = mol.atomRingBlock(n);
                if (rb > 0 && this.subjectMask[n - 1])
                    gotRB[rb - 1] = true;
            }
            for (let n = 1; n <= mol.numAtoms; n++) {
                let rb = mol.atomRingBlock(n);
                if (rb > 0 && gotRB[rb - 1])
                    this.output.selectedMask[n - 1] = true;
            }
        }
        execSelectCurElement() {
            if (!this.requireCurrent())
                return;
            let mol = this.input.mol;
            this.output.selectedMask = this.input.selectedMask.slice(0);
            let el1 = '', el2 = '';
            if (this.input.currentAtom > 0) {
                el1 = mol.atomElement(this.input.currentAtom);
            }
            else {
                el1 = mol.atomElement(mol.bondFrom(this.input.currentBond));
                el2 = mol.atomElement(mol.bondTo(this.input.currentBond));
            }
            for (let n = 1; n <= mol.numAtoms; n++)
                if (mol.atomElement(n) == el1 || mol.atomElement(n) == el2)
                    this.output.selectedMask[n - 1] = true;
        }
        execSelectToggle() {
            if (!this.requireCurrent())
                return;
            this.output.selectedMask = this.input.selectedMask.slice(0);
            if (this.input.currentAtom > 0) {
                this.output.selectedMask[this.input.currentAtom - 1] = !this.output.selectedMask[this.input.currentAtom - 1];
            }
            else {
                let bfr = this.input.mol.bondFrom(this.input.currentBond), bto = this.input.mol.bondTo(this.input.currentBond);
                let sel = !this.input.selectedMask[bfr - 1] || !this.input.selectedMask[bto - 1];
                this.output.selectedMask[bfr - 1] = sel;
                this.output.selectedMask[bto - 1] = sel;
            }
        }
        execSelectUnCurrent() {
            if (!this.requireCurrent())
                return;
            this.output.selectedMask = this.input.selectedMask.slice(0);
            if (this.input.currentAtom > 0) {
                this.output.selectedMask[this.input.currentAtom - 1] = false;
            }
            else {
                this.output.selectedMask[this.input.mol.bondFrom(this.input.currentBond) - 1] = false;
                this.output.selectedMask[this.input.mol.bondTo(this.input.currentBond) - 1] = false;
            }
        }
        execElement(element, positionX, positionY, keepAbbrev) {
            const QUERY_ELEMENTS = ['A', 'X', 'Y', 'Z', 'Q', 'M', 'T', 'E', 'R'];
            if (this.subjectLength > 0 && !QUERY_ELEMENTS.includes(element)) {
                let anyChange = false;
                for (let n = 0; n < this.subjectLength; n++)
                    if (this.input.mol.atomElement(this.subjectIndex[n]) != element) {
                        anyChange = true;
                        break;
                    }
                if (!anyChange) {
                    this.errmsg = 'Elements not changed.';
                    return;
                }
            }
            let mol = this.output.mol = this.input.mol.clone();
            let applyQuery = (atom) => {
                if (element == 'A') {
                    WebMolKit.QueryUtil.setQueryAtomElementsNot(mol, atom, ['H']);
                    WebMolKit.QueryUtil.deleteQueryAtom(mol, atom, WebMolKit.QueryTypeAtom.Elements);
                }
                else if (element == 'X') {
                    WebMolKit.QueryUtil.setQueryAtomElements(mol, atom, ['F', 'Cl', 'Br', 'I']);
                    WebMolKit.QueryUtil.deleteQueryAtom(mol, atom, WebMolKit.QueryTypeAtom.ElementsNot);
                }
                else if (element == 'Y') {
                    WebMolKit.QueryUtil.setQueryAtomElements(mol, atom, ['O', 'S', 'Se', 'Te']);
                    WebMolKit.QueryUtil.deleteQueryAtom(mol, atom, WebMolKit.QueryTypeAtom.ElementsNot);
                }
                else if (element == 'Z') {
                    WebMolKit.QueryUtil.setQueryAtomElements(mol, atom, ['F', 'Cl', 'Br', 'O', 'S']);
                    WebMolKit.QueryUtil.deleteQueryAtom(mol, atom, WebMolKit.QueryTypeAtom.ElementsNot);
                }
                else if (element == 'Q') {
                    WebMolKit.QueryUtil.setQueryAtomElementsNot(mol, atom, ['H', 'C']);
                    WebMolKit.QueryUtil.deleteQueryAtom(mol, atom, WebMolKit.QueryTypeAtom.Elements);
                }
                else if (element == 'M') {
                    const NON_METALS = ['H', 'B', 'C', 'N', 'O', 'F', 'Si', 'P', 'S', 'Cl', 'As', 'Se', 'Br', 'Te', 'I'];
                    WebMolKit.QueryUtil.setQueryAtomElementsNot(mol, atom, NON_METALS);
                    WebMolKit.QueryUtil.deleteQueryAtom(mol, atom, WebMolKit.QueryTypeAtom.Elements);
                }
                else if (element == 'T') {
                    const TRANSITION_METALS = [
                        'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn',
                        'Y', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd',
                        'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg',
                        'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu',
                        'Ac', 'Th', 'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', 'Md', 'No', 'Lr'
                    ];
                    WebMolKit.QueryUtil.setQueryAtomElements(mol, atom, TRANSITION_METALS);
                    WebMolKit.QueryUtil.deleteQueryAtom(mol, atom, WebMolKit.QueryTypeAtom.ElementsNot);
                }
                else if (element == 'E') {
                    const MAIN_GROUPS = [
                        'B', 'N', 'O', 'F',
                        'Al', 'Si', 'P', 'S', 'Cl',
                        'Zn', 'Ga', 'Se', 'As', 'Se', 'Br',
                        'Cd', 'In', 'Sn', 'Sb', 'Te', 'I',
                        'Hg', 'Tl', 'Pb', 'Bi', 'Pb', 'At'
                    ];
                    WebMolKit.QueryUtil.setQueryAtomElements(mol, atom, MAIN_GROUPS);
                    WebMolKit.QueryUtil.deleteQueryAtom(mol, atom, WebMolKit.QueryTypeAtom.ElementsNot);
                }
                else if (element == 'R') {
                    WebMolKit.QueryUtil.setQueryAtomElements(mol, atom, ['C', 'N', 'O', 'S', 'P', 'H']);
                    WebMolKit.QueryUtil.deleteQueryAtom(mol, atom, WebMolKit.QueryTypeAtom.ElementsNot);
                }
            };
            if (mol.numAtoms == 0) {
                mol.addAtom(element, 0, 0);
                applyQuery(mol.numAtoms);
            }
            else if (this.subjectLength == 0) {
                if (positionX != null && positionY != null)
                    mol.addAtom(element, positionX, positionY);
                else
                    WebMolKit.SketchUtil.placeNewAtom(mol, element);
                applyQuery(mol.numAtoms);
            }
            else {
                for (let n = 0; n < this.subjectLength; n++) {
                    if (keepAbbrev)
                        mol.setAtomElement(this.subjectIndex[n], element);
                    else
                        WebMolKit.MolUtil.setAtomElement(mol, this.subjectIndex[n], element);
                    applyQuery(this.subjectIndex[n]);
                }
            }
        }
        execCharge(delta) {
            if (!this.requireSubject())
                return;
            this.output.mol = this.input.mol.clone();
            for (let n = 0; n < this.subjectLength; n++) {
                let chg = Math.max(-20, Math.min(20, this.input.mol.atomCharge(this.subjectIndex[n]) + delta));
                this.output.mol.setAtomCharge(this.subjectIndex[n], chg);
            }
        }
        execConnect(order, type) {
            if (!this.requireSubject())
                return;
            let conn = WebMolKit.SketchUtil.pickAtomsToConnect(this.input.mol, this.subjectIndex);
            if (conn == null) {
                this.errmsg = 'Subject atoms contain no bonds suitable for connection.';
                return;
            }
            this.output.mol = this.input.mol.clone();
            for (let n = 0; n < conn.length; n += 2)
                WebMolKit.MolUtil.addBond(this.output.mol, conn[n], conn[n + 1], order, type);
        }
        execDisconnect() {
            let zap = [];
            let mol = this.input.mol;
            if (this.hasSelected) {
                for (let n = 1; n <= mol.numBonds; n++)
                    if (this.subjectMask[mol.bondFrom(n) - 1] && this.subjectMask[mol.bondTo(n) - 1])
                        zap.push(n);
            }
            else if (this.input.currentAtom > 0) {
                for (let a of mol.atomAdjBonds(this.input.currentAtom))
                    zap.push(a);
            }
            else if (this.input.currentBond > 0) {
                zap.push(this.input.currentBond);
            }
            if (zap.length == 0) {
                this.errmsg = 'Subject atoms contain no bonds suitable for disconnection.';
                return;
            }
            let killmask = WebMolKit.Vec.booleanArray(false, mol.numBonds);
            for (let b of zap)
                killmask[b - 1] = true;
            this.output.mol = this.input.mol.clone();
            for (let n = mol.numBonds; n >= 1; n--)
                if (killmask[n - 1])
                    this.output.mol.deleteBond(n);
        }
        execMetalLigate() {
            if (!this.requireSubject())
                return;
            let mol = this.input.mol;
            let ligAtoms = this.subjectIndex.slice(0);
            let metalAtom = this.input.currentAtom;
            if (metalAtom == 0) {
                for (let a of this.subjectIndex) {
                    let atno = mol.atomicNumber(a);
                    if (WebMolKit.Chemistry.ELEMENT_BLOCKS[atno] >= 3) {
                        metalAtom = a;
                        break;
                    }
                }
            }
            if (metalAtom == 0) {
                for (let a of this.subjectIndex) {
                    let atno = mol.atomicNumber(a);
                    if (WebMolKit.Chemistry.ELEMENT_ROWS[atno] >= 3) {
                        metalAtom = a;
                        break;
                    }
                }
            }
            if (metalAtom == 0) {
                this.errmsg = 'Unsure which is the metal atom: try indicating as current.';
                return;
            }
            let i = ligAtoms.indexOf(metalAtom);
            if (i >= 0)
                ligAtoms.splice(i, 1);
            if (ligAtoms.length == 0)
                ligAtoms = mol.atomAdjList(metalAtom);
            if (ligAtoms.length == 0) {
                this.errmsg = 'Metal centre has no attachments: try selecting atom join-points.';
                return;
            }
            mol = new WebMolKit.MetalLigate(mol, metalAtom, ligAtoms).generate();
            this.output.mol = mol;
            this.output.currentAtom = metalAtom;
            this.output.currentBond = -1;
            this.output.selectedMask = WebMolKit.Vec.booleanArray(false, mol.numAtoms);
            for (let a of ligAtoms)
                this.output.selectedMask[a - 1] = true;
        }
        execBond(order, type) {
            if (!this.requireSubject())
                return;
            if (this.subjectLength == 1) {
                this.performBondNew(this.subjectIndex[0], order, type);
                return;
            }
            let ccmol = WebMolKit.MolUtil.subgraphMask(this.input.mol, this.subjectMask);
            let oneComp = true;
            for (let n = ccmol.numAtoms; n >= 1; n--)
                if (ccmol.atomConnComp(n) != 1) {
                    oneComp = false;
                    break;
                }
            if (oneComp)
                this.performBondChange(order, type);
            else
                this.execConnect(order, type);
        }
        execBondGeom(geom) {
            let bond = this.subjectLength == 2 ? this.input.mol.findBond(this.subjectIndex[0], this.subjectIndex[1]) : 0;
            if (this.subjectLength == 0 || this.subjectLength > 2 || (this.subjectLength == 2 && bond == 0)) {
                this.errmsg = 'The subject must be a single atom or bond.';
                return;
            }
            if (this.subjectLength == 1)
                this.performBondGeomAtom(geom, this.subjectIndex[0]);
            else
                this.performBondGeomBond(geom, bond);
        }
        execBondAtom(order, type, element, x1, y1, x2, y2) {
            let mol = this.input.mol;
            let a1 = WebMolKit.CoordUtil.atomAtPoint(mol, x1, y1, 0.01), a2 = WebMolKit.CoordUtil.atomAtPoint(mol, x2, y2, 0.01);
            if (a1 > 0 && a2 > 0 && mol.findBond(a1, a2) > 0)
                return;
            this.output.mol = mol.clone();
            if (a1 == 0)
                a1 = this.output.mol.addAtom('C', x1, y1);
            if (a2 == 0)
                a2 = this.output.mol.addAtom(element, x2, y2);
            this.output.mol.addBond(a1, a2, order, type);
        }
        execBondSwitch() {
            if (!this.requireSubject())
                return;
            let mol = this.input.mol;
            let src = 0, dst = [];
            if (this.subjectLength == 1) {
                src = this.subjectIndex[0];
                let adj = mol.atomAdjList(src);
                for (let n = 0; n < adj.length; n++)
                    if (mol.atomAdjCount(adj[n]) == 1)
                        dst.push(adj[n]);
            }
            else if (this.subjectLength == 2 && mol.findBond(this.subjectIndex[0], this.subjectIndex[1]) > 0) {
                let ac1 = mol.atomAdjCount(this.subjectIndex[0]), ac2 = mol.atomAdjCount(this.subjectIndex[1]);
                if (ac1 > 1 && ac2 == 1) {
                    src = this.subjectIndex[0];
                    dst.push(this.subjectIndex[1]);
                }
                else if (ac1 == 1 && ac2 > 1) {
                    src = this.subjectIndex[1];
                    dst.push(this.subjectIndex[0]);
                }
            }
            if (src == 0 || dst.length == 0) {
                this.errmsg = 'Subject must include a terminal bond.';
                return;
            }
            let geoms = WebMolKit.SketchUtil.guessAtomGeometry(mol, src, 1);
            if (geoms.length == 0) {
                this.errmsg = 'No alternative geometries identified.';
                return;
            }
            this.output.mol = WebMolKit.SketchUtil.switchAtomGeometry(mol, src, dst, geoms);
            if (this.output.mol == null) {
                this.errmsg = 'No alternative geometries identified.';
            }
        }
        execBondRotate() {
            let bond = this.input.currentBond;
            if (bond == 0) {
                this.errmsg = 'There must be a current bond.';
                return;
            }
            let mol = this.input.mol;
            if (mol.bondInRing(bond)) {
                this.errmsg = 'Cannot rotate a ring-bond.';
                return;
            }
            if (mol.atomAdjCount(mol.bondFrom(bond)) == 1 || mol.atomAdjCount(mol.bondTo(bond)) == 1) {
                this.errmsg = 'Terminal bonds do not rotate.';
                return;
            }
            mol = mol.clone();
            let [atom1, atom2, side] = this.mobileSide(bond);
            let cx = mol.atomX(atom1), cy = mol.atomY(atom1);
            let theta = Math.atan2(mol.atomY(atom1) - mol.atomY(atom2), mol.atomX(atom1) - mol.atomX(atom2));
            for (let a of side)
                if (a != atom1) {
                    let dx = mol.atomX(a) - cx, dy = mol.atomY(a) - cy, dist = WebMolKit.norm_xy(dx, dy);
                    let dtheta = Math.atan2(dy, dx);
                    dtheta = theta - WebMolKit.angleDiff(dtheta, theta);
                    mol.setAtomPos(a, cx + dist * Math.cos(dtheta), cy + dist * Math.sin(dtheta));
                }
            let mask = WebMolKit.Vec.idxMask(WebMolKit.Vec.add(side, -1), mol.numAtoms);
            for (let b = 1; b <= mol.numBonds; b++)
                if (mask[mol.bondFrom(b) - 1] && mask[mol.bondTo(b) - 1]) {
                    let bt = mol.bondType(b);
                    if (bt == WebMolKit.Molecule.BONDTYPE_INCLINED)
                        mol.setBondType(b, WebMolKit.Molecule.BONDTYPE_DECLINED);
                    else if (bt == WebMolKit.Molecule.BONDTYPE_DECLINED)
                        mol.setBondType(b, WebMolKit.Molecule.BONDTYPE_INCLINED);
                }
            if (WebMolKit.CoordUtil.sketchEquivalent(this.input.mol, mol)) {
                this.errmsg = 'Rotation has no effect.';
                return;
            }
            this.output.mol = mol;
        }
        execBondAddTwo() {
            if (this.subjectLength != 1) {
                this.errmsg = 'Subject must be a single atom.';
                return;
            }
            let atom = this.subjectIndex[0];
            if (this.input.mol.atomAdjCount(atom) < 2) {
                this.errmsg = 'Subject atom must already have at least 2 bonds.';
                return;
            }
            let ang = WebMolKit.SketchUtil.calculateNewBondAngles(this.input.mol, atom, 1);
            if (ang.length == 0)
                ang = WebMolKit.SketchUtil.exitVectors(this.input.mol, atom);
            if (ang.length == 0) {
                this.errmsg = 'Could not find a suitable geometry for new substituents.';
                return;
            }
            let baseAng = ang[0];
            let cx = this.input.mol.atomX(atom), cy = this.input.mol.atomY(atom);
            if (ang.length > 1) {
                let best = 0;
                for (let n = 0; n < ang.length; n++) {
                    let x = cx + WebMolKit.Molecule.IDEALBOND * Math.cos(ang[n]);
                    let y = cy + WebMolKit.Molecule.IDEALBOND * Math.sin(ang[n]);
                    let score = WebMolKit.CoordUtil.congestionPoint(this.input.mol, x, y);
                    if (n == 0 || score < best) {
                        best = score;
                        baseAng = ang[n];
                    }
                }
            }
            let ang1 = baseAng - 30.0 * WebMolKit.DEGRAD, ang2 = baseAng + 30.0 * WebMolKit.DEGRAD;
            let mol = this.input.mol.clone();
            let a1 = mol.addAtom('C', cx + WebMolKit.Molecule.IDEALBOND * Math.cos(ang1), cy + WebMolKit.Molecule.IDEALBOND * Math.sin(ang1));
            let a2 = mol.addAtom('C', cx + WebMolKit.Molecule.IDEALBOND * Math.cos(ang2), cy + WebMolKit.Molecule.IDEALBOND * Math.sin(ang2));
            mol.addBond(atom, a1, 1);
            mol.addBond(atom, a2, 1);
            this.output.mol = mol;
        }
        execBondInsert() {
            let mol = this.input.mol, bond = this.input.currentBond;
            if (bond == 0) {
                this.errmsg = 'There must be a current bond.';
                return;
            }
            if (mol.bondInRing(bond)) {
                this.errmsg = 'Cannot insert into a ring-bond.';
                return;
            }
            let [alink, _, side] = this.mobileSide(bond);
            mol = mol.clone();
            mol.setBondOrder(bond, 1);
            let fragmask = WebMolKit.Vec.booleanArray(false, mol.numAtoms);
            for (let a of side)
                fragmask[a - 1] = true;
            let frag = WebMolKit.MolUtil.subgraphWithAttachments(mol, fragmask);
            for (let n = mol.numAtoms; n >= 1; n--)
                if (fragmask[n - 1] && n != alink) {
                    mol.deleteAtomAndBonds(n);
                    if (n < alink)
                        alink -= 1;
                }
            mol.setAtomElement(alink, 'C');
            mol.setAtomCharge(alink, 0);
            mol.setAtomUnpaired(alink, 0);
            mol.setAtomHExplicit(alink, WebMolKit.Molecule.HEXPLICIT_UNKNOWN);
            mol.setAtomIsotope(alink, WebMolKit.Molecule.ISOTOPE_NATURAL);
            mol.setAtomMapNum(alink, 0);
            mol.setAtomExtra(alink, []);
            mol.setAtomTransient(alink, []);
            let fusion = new WebMolKit.TemplateFusion(mol, frag, '');
            fusion.withGuideOnly = true;
            fusion.permuteAtom(alink);
            if (fusion.perms.length == 0) {
                this.errmsg = 'Unable to insert.';
                return;
            }
            this.output.mol = fusion.perms[0].mol;
            this.zapSubject();
            this.output.currentAtom = alink;
        }
        execJoin() {
            if (!this.requireSubject())
                return;
            this.output.mol = WebMolKit.SketchUtil.joinOverlappingAtoms(this.input.mol, this.subjectMask);
            if (this.output.mol == null) {
                this.errmsg = 'Subject contains no overlapping atoms.';
            }
            else {
                this.zapSubject();
            }
        }
        execNudge(dir, extent) {
            if (!this.requireSubject())
                return;
            let dx = extent * (dir == 'left' ? -1 : dir == 'right' ? 1 : 0);
            let dy = extent * (dir == 'down' ? -1 : dir == 'up' ? 1 : 0);
            this.output.mol = this.input.mol.clone();
            for (let n = 0; n < this.subjectLength; n++) {
                let x = this.output.mol.atomX(this.subjectIndex[n]), y = this.output.mol.atomY(this.subjectIndex[n]);
                this.output.mol.setAtomPos(this.subjectIndex[n], x + dx, y + dy);
            }
        }
        execNudgeFar(dir) {
            if (!this.requireSubject())
                return;
            if (this.subjectLength == this.input.mol.numAtoms) {
                this.errmsg = 'Cannot apply to entire molecule.';
                return;
            }
            let dx = dir == 'left' ? -1 : dir == 'right' ? 1 : 0;
            let dy = dir == 'down' ? -1 : dir == 'up' ? 1 : 0;
            this.output.mol = WebMolKit.SketchUtil.moveToEdge(this.input.mol, this.subjectMask, dx, dy);
            if (this.output.mol == null) {
                this.execNudge(dir, 1);
            }
        }
        execFlip(axis) {
            if (this.input.mol.numAtoms < 2) {
                this.errmsg = 'At least 2 atoms are required.';
                return;
            }
            let isVertical = axis == 'ver';
            let cx = 0, cy = 0;
            let mask = this.subjectMask, mol = this.input.mol;
            if (this.input.currentAtom > 0) {
                cx = mol.atomX(this.input.currentAtom);
                cy = mol.atomY(this.input.currentAtom);
                if (!this.hasSelected) {
                    mask = WebMolKit.Vec.booleanArray(false, mol.numAtoms);
                    let cc = mol.atomConnComp(this.input.currentAtom);
                    for (let n = 1; n <= mol.numAtoms; n++)
                        mask[n - 1] = mol.atomConnComp(n) == cc;
                }
            }
            else if (this.input.currentBond > 0) {
                let bfr = mol.bondFrom(this.input.currentBond), bto = mol.bondTo(this.input.currentBond);
                cx = 0.5 * (mol.atomX(bfr) + mol.atomX(bto));
                cy = 0.5 * (mol.atomY(bfr) + mol.atomY(bto));
                if (!this.hasSelected) {
                    mask = WebMolKit.Vec.booleanArray(false, mol.numAtoms);
                    let cc = mol.atomConnComp(bfr);
                    for (let n = 1; n <= mol.numAtoms; n++)
                        mask[n - 1] = mol.atomConnComp(n) == cc;
                }
            }
            else if (this.subjectLength == 0) {
                let box = mol.boundary();
                cx = 0.5 * (box.minX() + box.maxX());
                cy = 0.5 * (box.minY() + box.maxY());
                mask = WebMolKit.Vec.booleanArray(true, mol.numAtoms);
            }
            else {
                for (let n = 0; n < this.subjectLength; n++) {
                    cx += mol.atomX(this.subjectIndex[n]);
                    cy += mol.atomY(this.subjectIndex[n]);
                }
                let invSz = 1.0 / this.subjectLength;
                cx *= invSz;
                cy *= invSz;
            }
            this.output.mol = mol.clone();
            for (let n = 1; n <= mol.numAtoms; n++)
                if (mask[n - 1]) {
                    if (!isVertical)
                        this.output.mol.setAtomX(n, 2 * cx - this.output.mol.atomX(n));
                    else
                        this.output.mol.setAtomY(n, 2 * cy - this.output.mol.atomY(n));
                }
        }
        execScale(mag) {
            if (this.input.mol.numAtoms < 2) {
                this.errmsg = 'At least 2 atoms are required.';
                return;
            }
            let mol = this.input.mol;
            let b;
            if (this.subjectLength == 2 && (b = mol.findBond(this.subjectIndex[0], this.subjectIndex[1])) > 0 && !mol.bondInRing(b)) {
                let a1 = this.subjectIndex[0], a2 = this.subjectIndex[1];
                let ccmol = mol.clone();
                ccmol.deleteBond(b);
                let idx1 = [], idx2 = [];
                for (let n = 1; n <= ccmol.numAtoms; n++) {
                    if (ccmol.atomConnComp(n) == ccmol.atomConnComp(a1))
                        idx1.push(n);
                    else if (ccmol.atomConnComp(n) == ccmol.atomConnComp(a2))
                        idx2.push(n);
                }
                let dx = (mol.atomX(a2) - mol.atomX(a1)) * (mag - 1);
                let dy = (mol.atomY(a2) - mol.atomY(a1)) * (mag - 1);
                if (idx1.length == idx2.length) {
                    dx *= 0.5;
                    dy *= 0.5;
                }
                this.output.mol = mol.clone();
                if (idx1.length <= idx2.length)
                    for (let n = 0; n < idx1.length; n++) {
                        let a = idx1[n];
                        this.output.mol.setAtomPos(a, this.output.mol.atomX(a) - dx, this.output.mol.atomY(a) - dy);
                    }
                if (idx2.length <= idx1.length)
                    for (let n = 0; n < idx2.length; n++) {
                        let a = idx2[n];
                        this.output.mol.setAtomPos(a, this.output.mol.atomX(a) + dx, this.output.mol.atomY(a) + dy);
                    }
                return;
            }
            let cx = 0, cy = 0;
            if (this.input.currentAtom > 0) {
                cx = mol.atomX(this.input.currentAtom);
                cy = mol.atomY(this.input.currentAtom);
            }
            else if (this.input.currentBond > 0) {
                let bfr = mol.bondFrom(this.input.currentBond), bto = mol.bondTo(this.input.currentBond);
                cx = 0.5 * (mol.atomX(bfr) + mol.atomX(bto));
                cy = 0.5 * (mol.atomY(bfr) + mol.atomY(bto));
            }
            else {
                for (let n = 0; n < this.subjectLength; n++) {
                    cx += mol.atomX(this.subjectIndex[n]);
                    cy += mol.atomY(this.subjectIndex[n]);
                }
                let invSz = 1.0 / this.subjectLength;
                cx *= invSz;
                cy *= invSz;
            }
            this.output.mol = mol.clone();
            for (let n = 0; n < this.subjectLength; n++) {
                let x = this.output.mol.atomX(this.subjectIndex[n]);
                let y = this.output.mol.atomY(this.subjectIndex[n]);
                this.output.mol.setAtomPos(this.subjectIndex[n], (x - cx) * mag + cx, (y - cy) * mag + cy);
            }
        }
        execRotate(theta, centreX, centreY) {
            theta *= WebMolKit.DEGRAD;
            let mol = this.input.mol;
            if (centreX != null && centreY != null) {
                this.output.mol = mol.clone();
                let mask = this.subjectLength == 0 ? WebMolKit.Vec.booleanArray(true, mol.numAtoms) : this.subjectMask;
                WebMolKit.CoordUtil.rotateAtoms(this.output.mol, mask, centreX, centreY, theta);
                return;
            }
            if (mol.numAtoms < 2) {
                this.errmsg = 'At least 2 atoms are required.';
                return;
            }
            let cx = 0, cy = 0;
            let mask = this.subjectMask;
            if (this.input.currentAtom > 0) {
                cx = mol.atomX(this.input.currentAtom);
                cy = mol.atomY(this.input.currentAtom);
                if (!this.hasSelected) {
                    mask = WebMolKit.Vec.booleanArray(false, mol.numAtoms);
                    let cc = mol.atomConnComp(this.input.currentAtom);
                    for (let n = 1; n <= mol.numAtoms; n++)
                        mask[n - 1] = mol.atomConnComp(n) == cc;
                }
                if (WebMolKit.Vec.maskCount(mask) == 1 && mask[this.input.currentAtom - 1]) {
                    this.errmsg = 'Component is isolated.';
                    return;
                }
            }
            else if (this.input.currentBond > 0) {
                let bfr = mol.bondFrom(this.input.currentBond), bto = mol.bondTo(this.input.currentBond);
                cx = 0.5 * (mol.atomX(bfr) + mol.atomX(bto));
                cy = 0.5 * (mol.atomY(bfr) + mol.atomY(bto));
                if (!this.hasSelected) {
                    mask = WebMolKit.Vec.booleanArray(false, mol.numAtoms);
                    let cc = mol.atomConnComp(bfr);
                    for (let n = 1; n <= mol.numAtoms; n++)
                        mask[n - 1] = mol.atomConnComp(n) == cc;
                }
            }
            else if (this.subjectLength == 0) {
                let box = mol.boundary();
                cx = 0.5 * (box.minX() + box.maxX());
                cy = 0.5 * (box.minY() + box.maxY());
                mask = WebMolKit.Vec.booleanArray(true, mol.numAtoms);
            }
            else {
                if (this.subjectLength == 1) {
                    this.errmsg = 'Component is isolated.';
                    return;
                }
                for (let n = 0; n < this.subjectLength; n++) {
                    cx += mol.atomX(this.subjectIndex[n]);
                    cy += mol.atomY(this.subjectIndex[n]);
                }
                let invSz = 1.0 / this.subjectLength;
                cx *= invSz;
                cy *= invSz;
            }
            this.output.mol = mol.clone();
            WebMolKit.CoordUtil.rotateAtoms(this.output.mol, mask, cx, cy, theta);
        }
        execBondDist(dist) {
            let bond = this.input.currentBond;
            if (bond == 0) {
                this.errmsg = 'There must be a current bond.';
                return;
            }
            let mol = this.input.mol.clone();
            if (mol.bondInRing(bond)) {
                let atom1 = mol.bondFrom(bond), atom2 = mol.bondTo(bond);
                let dx = mol.atomX(atom2) - mol.atomX(atom1), dy = mol.atomY(atom2) - mol.atomY(atom1), curDist = WebMolKit.norm_xy(dx, dy), inv = 1.0 / curDist;
                let sel1 = this.isSelected(atom1), sel2 = this.isSelected(atom2);
                let ox = dx * (dist - curDist) * inv, oy = dy * (dist - curDist) * inv;
                if (sel1 && !sel2) {
                    mol.setAtomPos(atom1, mol.atomX(atom1) - ox, mol.atomY(atom1) - oy);
                }
                else if (sel2 && !sel1) {
                    mol.setAtomPos(atom2, mol.atomX(atom2) + ox, mol.atomY(atom2) + oy);
                }
                else {
                    mol.setAtomPos(atom1, mol.atomX(atom1) - 0.5 * ox, mol.atomY(atom1) - 0.5 * oy);
                    mol.setAtomPos(atom2, mol.atomX(atom2) + 0.5 * ox, mol.atomY(atom2) + 0.5 * oy);
                }
            }
            else {
                let [atom1, atom2, side] = this.mobileSide(bond);
                let dx = mol.atomX(atom2) - mol.atomX(atom1), dy = mol.atomY(atom2) - mol.atomY(atom1);
                let curDist = WebMolKit.norm_xy(dx, dy), inv = 1.0 / curDist;
                let ox = dx * (dist - curDist) * inv, oy = dy * (dist - curDist) * inv;
                for (let a of side)
                    mol.setAtomPos(a, mol.atomX(a) - ox, mol.atomY(a) - oy);
            }
            this.output.mol = mol;
        }
        execAlignAngle(angle) {
            let bond = this.input.currentBond;
            if (bond == 0) {
                this.errmsg = 'There must be a current bond.';
                return;
            }
            let mol = this.input.mol.clone();
            if (mol.bondInRing(bond)) {
                this.errmsg = 'Cannot align a ring-bond.';
                return;
            }
            let [atom1, atom2, side] = this.mobileSide(bond);
            let cx = mol.atomX(atom2), cy = mol.atomY(atom2);
            let delta = angle - Math.atan2(mol.atomY(atom1) - cy, mol.atomX(atom1) - cx);
            let cosTheta = Math.cos(delta), sinTheta = Math.sin(delta);
            for (let a of side) {
                let x = mol.atomX(a) - cx, y = mol.atomY(a) - cy;
                mol.setAtomPos(a, cx + x * cosTheta - y * sinTheta, cy + x * sinTheta + y * cosTheta);
            }
            this.output.mol = mol;
        }
        execAdjustTorsion(angle) {
            if (this.input.currentAtom == 0 || WebMolKit.Vec.maskCount(this.input.selectedMask) != 3) {
                this.errmsg = 'Must be 3 selected atoms and a current atom.';
                return;
            }
            let mol = this.input.mol.clone();
            let a1 = this.input.currentAtom;
            let atoms = [];
            for (let n = 1; n <= mol.numAtoms; n++)
                if (n != a1 && this.input.selectedMask[n - 1])
                    atoms.push(n);
            let a2 = mol.findBond(a1, atoms[0]) > 0 ? atoms.shift() :
                mol.findBond(a1, atoms[1]) > 0 ? atoms.pop() : 0;
            if (a2 == 0 || mol.findBond(a2, atoms[0]) == 0) {
                this.errmsg = 'Selected atoms must be consecutive.';
                return;
            }
            let a3 = atoms[0];
            let cx = mol.atomX(a2), cy = mol.atomY(a2);
            let theta1 = Math.atan2(mol.atomY(a1) - cy, mol.atomX(a1) - cx);
            let theta3 = Math.atan2(mol.atomY(a3) - cy, mol.atomX(a3) - cx);
            let delta = angle - WebMolKit.angleDiff(theta3, theta1);
            let group1 = [], group3 = [];
            if (mol.atomRingBlock(a1) == 0 || mol.atomRingBlock(a1) != mol.atomRingBlock(a3)) {
                let g = WebMolKit.Graph.fromMolecule(mol);
                g.removeEdge(a2 - 1, a1 - 1);
                g.removeEdge(a2 - 1, a3 - 1);
                let cc = g.calculateComponents();
                for (let n = 0; n < g.numNodes; n++) {
                    if (cc[n] == cc[a1 - 1])
                        group1.push(n + 1);
                    else if (cc[n] == cc[a3 - 1])
                        group3.push(n + 1);
                }
            }
            if (mol.atomRingBlock(a1) > 0 && mol.atomRingBlock(a1) == mol.atomRingBlock(a2))
                group1 = [a1];
            if (mol.atomRingBlock(a3) > 0 && mol.atomRingBlock(a3) == mol.atomRingBlock(a2))
                group3 = [a3];
            WebMolKit.CoordUtil.rotateAtoms(mol, WebMolKit.Vec.idxMask(WebMolKit.Vec.add(group1, -1), mol.numAtoms), cx, cy, -0.5 * delta);
            WebMolKit.CoordUtil.rotateAtoms(mol, WebMolKit.Vec.idxMask(WebMolKit.Vec.add(group3, -1), mol.numAtoms), cx, cy, 0.5 * delta);
            this.output.mol = mol;
        }
        execMove(refAtom, deltaX, deltaY) {
            let subj = this.subjectIndex;
            if (WebMolKit.Vec.len(subj) == 0) {
                if (refAtom == 0)
                    return;
                subj = [refAtom];
            }
            this.output.mol = this.input.mol.clone();
            for (let a of subj)
                this.output.mol.setAtomPos(a, this.output.mol.atomX(a) + deltaX, this.output.mol.atomY(a) + deltaY);
        }
        execRing(ringX, ringY, aromatic) {
            let rsz = ringX.length;
            let atoms = WebMolKit.Vec.numberArray(0, rsz), bonds = WebMolKit.Vec.numberArray(0, rsz);
            let outmol = this.input.mol.clone();
            for (let n = 0; n < rsz; n++) {
                atoms[n] = WebMolKit.CoordUtil.atomAtPoint(outmol, ringX[n], ringY[n]);
                if (atoms[n] == 0)
                    atoms[n] = outmol.addAtom('C', ringX[n], ringY[n]);
            }
            for (let n = 0; n < rsz; n++) {
                let nn = n < rsz - 1 ? n + 1 : 0;
                bonds[n] = outmol.findBond(atoms[n], atoms[nn]);
                if (bonds[n] == 0)
                    bonds[n] = outmol.addBond(atoms[n], atoms[nn], 1);
            }
            if (aromatic) {
                let valence = WebMolKit.Vec.numberArray(0, rsz);
                let pi = WebMolKit.Vec.booleanArray(false, rsz);
                for (let n = 0; n < rsz; n++) {
                    valence[n] = WebMolKit.Chemistry.ELEMENT_BONDING[outmol.atomicNumber(atoms[n])] + outmol.atomCharge(atoms[n]);
                    if (outmol.atomHExplicit(atoms[n]) != WebMolKit.Molecule.HEXPLICIT_UNKNOWN)
                        valence[n] -= outmol.atomHExplicit(atoms[n]);
                    for (let b of outmol.atomAdjBonds(atoms[n]))
                        valence[n] -= outmol.bondOrder(b);
                    if (outmol.bondOrder(bonds[n]) >= 2) {
                        pi[n] = true;
                        if (n < rsz - 1) {
                            pi[n] = true;
                            n++;
                        }
                        else
                            pi[0] = true;
                    }
                }
                for (let n = 0; n < rsz; n++) {
                    let nn = n < rsz - 1 ? n + 1 : 0;
                    if (pi[n] || pi[nn])
                        continue;
                    if (valence[n] > 0 && valence[nn] > 0) {
                        outmol.setBondOrder(bonds[n], 2);
                        pi[n] = true;
                        pi[nn] = true;
                        valence[n]--;
                        valence[nn]--;
                    }
                }
            }
            this.output.mol = outmol;
        }
        execTemplateFusion(frag) {
            let mol = this.input.mol;
            let fusion = new WebMolKit.TemplateFusion(mol, frag, '');
            if (this.subjectLength == 0)
                fusion.permuteNone();
            else if (this.subjectLength == 1)
                fusion.permuteAtom(this.subjectIndex[0]);
            else if (this.subjectLength == 2 && mol.findBond(this.subjectIndex[0], this.subjectIndex[1]) > 0)
                fusion.permuteBond(this.subjectIndex[0], this.subjectIndex[1]);
            else
                fusion.permuteMulti(this.subjectIndex);
            let permutations = [];
            for (let perm of fusion.perms) {
                let obj = {};
                obj['mol'] = perm.mol.toString();
                obj['display'] = perm.display.toString();
                obj['molidx'] = perm.molidx;
                obj['temidx'] = perm.temidx;
                obj['srcidx'] = perm.srcidx;
                permutations.push(obj);
            }
            this.output.permutations = permutations;
        }
        execAbbrevTempl() {
        }
        execAbbrevGroup() {
            if (!this.requireSubject())
                return;
            if (!this.checkAbbreviationReady())
                return;
            let mol = WebMolKit.MolUtil.convertToAbbrev(this.input.mol, WebMolKit.Vec.notMask(this.subjectMask), '?');
            if (mol == null) {
                this.errmsg = 'Inline abbreviations must be terminal with exactly one attachment point.';
                return;
            }
            this.output.mol = mol;
            this.zapSubject();
            this.output.currentAtom = mol.numAtoms;
        }
        execAbbrevFormula() {
            if (!this.requireSubject())
                return;
            if (!this.checkAbbreviationReady())
                return;
            let fixed = this.input.mol.clone();
            for (let n = 1; n <= fixed.numAtoms; n++)
                fixed.setAtomHExplicit(n, fixed.atomHydrogens(n));
            let abv = WebMolKit.MolUtil.subgraphMask(fixed, this.subjectMask);
            let formula = WebMolKit.MolUtil.molecularFormula(abv, true);
            let mol = WebMolKit.MolUtil.convertToAbbrev(this.input.mol, WebMolKit.Vec.notMask(this.subjectMask), formula);
            if (mol == null) {
                this.errmsg = 'Inline abbreviations must be terminal with exactly one attachment point.';
                return;
            }
            this.output.mol = mol;
            this.zapSubject();
            this.output.currentAtom = mol.numAtoms;
        }
        execAbbrevClear() {
            let idx = [];
            for (let n of this.subjectIndex)
                if (WebMolKit.MolUtil.hasAbbrev(this.input.mol, n))
                    idx.push(n);
            if (idx.length == 0) {
                this.errmsg = 'No abbreviations to clear.';
                return;
            }
            let mol = this.input.mol.clone();
            for (let n of idx)
                WebMolKit.MolUtil.clearAbbrev(mol, n);
            this.output.mol = mol;
        }
        execAbbrevExpand() {
            let idx = [];
            for (let n of this.subjectIndex)
                if (WebMolKit.MolUtil.hasAbbrev(this.input.mol, n))
                    idx.push(n);
            if (idx.length == 0) {
                this.errmsg = 'No abbreviations to expand.';
                return;
            }
            let mol = this.input.mol.clone();
            for (let n of idx)
                WebMolKit.MolUtil.expandOneAbbrev(mol, n, true);
            this.output.mol = mol;
            this.zapSubject();
        }
        execBondArtifact(activity) {
            if (!this.requireAtoms() || !this.requireSubject())
                return;
            let artif = new WebMolKit.BondArtifact(this.input.mol.clone());
            let subject = this.subjectIndex.slice(0), curAtom = this.input.currentAtom;
            if (curAtom > 0 && subject.indexOf(curAtom) < 0)
                subject.push(curAtom);
            if (activity == ActivityType.BondArtifactPath) {
                if (!artif.createPath(subject)) {
                    this.errmsg = 'Path artifact not suitable.';
                    return;
                }
            }
            else if (activity == ActivityType.BondArtifactRing) {
                if (!artif.createRing(subject)) {
                    this.errmsg = 'Ring artifact not suitable.';
                    return;
                }
            }
            else if (activity == ActivityType.BondArtifactArene) {
                if (!artif.createArene(subject)) {
                    this.errmsg = 'Arene artifact not suitable.';
                    return;
                }
            }
            else if (activity == ActivityType.BondArtifactClear) {
                if (!artif.removeArtifact(subject)) {
                    if (this.removePolymerBlock(subject))
                        return;
                    this.errmsg = 'No artifact removed.';
                    return;
                }
            }
            artif.rewriteMolecule();
            this.output.mol = artif.mol;
        }
        execPolymerBlock() {
            if (!this.requireAtoms() || !this.requireSubject())
                return;
            if (this.owner)
                this.owner.performPolymerBlock(this.subjectIndex);
        }
        execAddHydrogens() {
            let mol = this.input.mol.clone();
            if (!this.requireAtoms())
                return;
            let atoms = this.subjectIndex;
            if (atoms.length == 0)
                atoms = WebMolKit.Vec.identity1(mol.numAtoms);
            for (let a of atoms) {
                let hc = mol.atomHydrogens(a);
                if (hc > 0)
                    WebMolKit.SketchUtil.placeAdditionalHydrogens(mol, a, hc);
            }
            if (mol.numAtoms == this.input.mol.numAtoms) {
                this.errmsg = 'Nothing needs to be added.';
                return;
            }
            this.output.mol = mol;
        }
        execRemoveHydrogens() {
            if (!this.requireAtoms())
                return;
            let mol = this.input.mol;
            let selmask = this.subjectMask;
            if (WebMolKit.Vec.allFalse(selmask))
                selmask = WebMolKit.Vec.booleanArray(true, mol.numAtoms);
            let keepmask = WebMolKit.Vec.booleanArray(true, mol.numAtoms);
            for (let n = 1; n <= mol.numAtoms; n++)
                if (WebMolKit.MolUtil.boringHydrogen(mol, n)) {
                    let nbr = mol.atomAdjList(n)[0];
                    if (selmask[n - 1] || selmask[nbr - 1])
                        keepmask[n - 1] = false;
                }
            if (WebMolKit.Vec.allTrue(keepmask)) {
                this.errmsg = 'Nothing to be deleted.';
                return;
            }
            this.output.mol = WebMolKit.MolUtil.subgraphMask(mol, keepmask);
        }
        execQueryClear() {
            if (!this.requireSubject())
                return;
            let mol = this.input.mol.clone();
            const { currentBond } = this.input;
            if (currentBond > 0 && WebMolKit.QueryUtil.hasAnyQueryBond(mol, currentBond)) {
                WebMolKit.QueryUtil.deleteQueryBondAll(mol, currentBond);
                this.output.mol = mol;
                return;
            }
            let anything = false;
            for (let a of this.subjectIndex)
                if (WebMolKit.QueryUtil.hasAnyQueryAtom(mol, a)) {
                    WebMolKit.QueryUtil.deleteQueryAtomAll(mol, a);
                    anything = true;
                }
            for (let b = 1; b <= mol.numBonds; b++)
                if (this.subjectMask[mol.bondFrom(b) - 1] && this.subjectMask[mol.bondTo(b) - 1] && WebMolKit.QueryUtil.hasAnyQueryBond(mol, b)) {
                    WebMolKit.QueryUtil.deleteQueryBondAll(mol, b);
                    anything = true;
                }
            if (anything)
                this.output.mol = mol;
            else
                this.errmsg = 'No query terms to clear.';
        }
        execQueryCopy() {
            if (!this.requireSubject())
                return;
            const { mol, currentBond } = this.input;
            if (currentBond > 0) {
                if (!WebMolKit.QueryUtil.hasAnyQueryBond(mol, currentBond)) {
                    this.errmsg = 'Bond has no query terms.';
                    return;
                }
                let qmol = new WebMolKit.Molecule();
                qmol.addAtom('*', 0, 0);
                qmol.addAtom('*', WebMolKit.Molecule.IDEALBOND, 0);
                qmol.addBond(1, 2, 1);
                qmol.setBondExtra(1, mol.bondExtra(currentBond).filter((xtra) => xtra.startsWith('q')));
                this.toClipboard = qmol.toString();
            }
            else if (this.subjectLength == 1) {
                let atom = this.subjectIndex[0];
                if (!WebMolKit.QueryUtil.hasAnyQueryAtom(mol, atom)) {
                    this.errmsg = 'Atom has no query terms.';
                    return;
                }
                let qmol = new WebMolKit.Molecule();
                qmol.addAtom('*', 0, 0);
                qmol.setAtomExtra(1, mol.atomExtra(atom).filter((xtra) => xtra.startsWith('q')));
                this.toClipboard = qmol.toString();
            }
            else
                this.errmsg = 'Subject has to be a single atom or bond.';
        }
        execQueryPaste() {
            if (!this.requireSubject())
                return;
            let qmol = this.param.qmol;
            if (!qmol) { }
            else if (qmol.numAtoms == 1 && qmol.atomElement(1) == '*' && WebMolKit.QueryUtil.hasAnyQueryAtom(qmol, 1)) {
                let mol = this.output.mol = this.input.mol.clone();
                let qterms = qmol.atomExtra(1).filter((xtra) => xtra.startsWith('q'));
                for (let a of this.subjectIndex) {
                    let aterms = mol.atomExtra(a).filter((xtra) => xtra.startsWith('q'));
                    mol.setAtomExtra(a, [...aterms, ...qterms]);
                }
                return;
            }
            else if (qmol.numAtoms == 2 && qmol.atomElement(1) == '*' && qmol.atomElement(2) == '*' &&
                qmol.numBonds == 1 && WebMolKit.QueryUtil.hasAnyQueryBond(qmol, 1)) {
                let mol = this.output.mol = this.input.mol.clone();
                let qterms = qmol.bondExtra(1).filter((xtra) => xtra.startsWith('q'));
                for (let b = 1; b <= mol.numBonds; b++)
                    if (this.subjectMask[mol.bondFrom(b) - 1] && this.subjectMask[mol.bondTo(b) - 1]) {
                        let bterms = mol.bondExtra(b).filter((xtra) => xtra.startsWith('q'));
                        mol.setBondExtra(b, [...bterms, ...qterms]);
                    }
                return;
            }
            this.errmsg = 'Unable to paste query terms.';
        }
        execQuerySetAtom() {
        }
        execQuerySetBond() {
        }
        execQueryBondAny() {
            if (!this.requireSubject())
                return;
            const { mol, currentBond } = this.input;
            let bonds = [];
            for (let n = 1; n <= mol.numBonds; n++)
                if (this.subjectMask[mol.bondFrom(n) - 1] && this.subjectMask[mol.bondTo(n) - 1])
                    bonds.push(n);
            if (bonds.length == 0) {
                this.errmsg = 'Must select at least one bond.';
                return;
            }
            this.output.mol = this.input.mol.clone();
            for (let b of bonds) {
                this.output.mol.setBondOrder(b, 0);
                WebMolKit.QueryUtil.setQueryBondOrders(this.output.mol, b, [-1, 0, 1, 2, 3, 4]);
            }
        }
        requireSubject() {
            if (this.subjectLength == 0)
                this.errmsg = 'Subject required: current atom/bond or selected atoms.';
            return this.subjectLength > 0;
        }
        requireAtoms() {
            if (this.input.mol.numAtoms == 0)
                this.errmsg = 'There are no atoms.';
            return this.input.mol.numAtoms > 0;
        }
        requireCurrent() {
            if (this.input.currentAtom == 0 && this.input.currentBond == 0) {
                this.errmsg = 'There must be a current atom or bond.';
                return false;
            }
            return true;
        }
        requireSelected() {
            if (!this.hasSelected)
                this.errmsg = 'No atoms are selected.';
            return this.hasSelected;
        }
        pickSelectedGroup(groups, dir) {
            if (this.subjectLength == 0)
                return 0;
            for (let i = 0; i < groups.length; i++) {
                let g = groups[i];
                let all = true;
                for (let j = 0; j < g.length; j++)
                    if (!this.subjectMask[g[j] - 1]) {
                        all = false;
                        break;
                    }
                if (all) {
                    i += dir;
                    return i < 0 ? i + groups.length : i >= groups.length ? i - groups.length : i;
                }
            }
            for (let i = 0; i < groups.length; i++) {
                let g = groups[i];
                for (let j = 0; j < g.length; j++)
                    if (this.subjectMask[g[j] - 1])
                        return i;
            }
            return 0;
        }
        zapSubject() {
            this.output.currentAtom = 0;
            this.output.currentBond = 0;
            this.output.selectedMask = WebMolKit.Vec.booleanArray(false, this.input.mol.numAtoms);
        }
        performBondNew(atom, order, type) {
            let mol = this.input.mol;
            let ang = WebMolKit.SketchUtil.calculateNewBondAngles(mol, atom, order);
            if (ang.length == 0)
                ang = WebMolKit.SketchUtil.exitVectors(mol, atom);
            if (ang.length == 0) {
                this.errmsg = 'Could not find a suitable geometry for a new substituent.';
                return;
            }
            let bx = 0, by = 0, best = 0;
            for (let n = 0; n < ang.length; n++) {
                let x = mol.atomX(atom) + WebMolKit.Molecule.IDEALBOND * Math.cos(ang[n]);
                let y = mol.atomY(atom) + WebMolKit.Molecule.IDEALBOND * Math.sin(ang[n]);
                let score = WebMolKit.CoordUtil.congestionPoint(mol, x, y);
                if (WebMolKit.Chemistry.ELEMENT_BLOCKS[mol.atomicNumber(atom)] <= 2)
                    score += Math.abs(WebMolKit.angleNorm(ang[n])) * 1E-8;
                else
                    score += Math.abs(WebMolKit.angleDiff(0.5 * Math.PI, ang[n])) * 1E-8;
                if (n == 0 || score < best) {
                    best = score;
                    bx = x;
                    by = y;
                }
            }
            this.output.mol = mol.clone();
            let anum = WebMolKit.CoordUtil.atomAtPoint(this.output.mol, bx, by);
            if (anum == 0)
                anum = this.output.mol.addAtom('C', bx, by);
            WebMolKit.MolUtil.addBond(this.output.mol, atom, anum, order, type);
        }
        performBondChange(order, type) {
            let mol = this.input.mol;
            let bonds = [];
            for (let n = 1; n <= mol.numBonds; n++)
                if (this.subjectMask[mol.bondFrom(n) - 1] && this.subjectMask[mol.bondTo(n) - 1])
                    bonds.push(n);
            let switchType = type == WebMolKit.Molecule.BONDTYPE_DECLINED || type == WebMolKit.Molecule.BONDTYPE_INCLINED;
            let stereoType = switchType || type == WebMolKit.Molecule.BONDTYPE_UNKNOWN;
            let anyChange = switchType;
            for (let n = 0; n < bonds.length && !anyChange; n++) {
                let b = bonds[n];
                if (mol.bondOrder(b) != order && type == WebMolKit.Molecule.BONDTYPE_NORMAL)
                    anyChange = true;
                else if (mol.bondType(b) != type)
                    anyChange = true;
            }
            if (!anyChange) {
                this.errmsg = 'No bond changes made.';
                return;
            }
            this.output.mol = mol.clone();
            for (let n = 0; n < bonds.length; n++) {
                let b = bonds[n], bfr = this.output.mol.bondFrom(b), bto = this.output.mol.bondTo(b);
                if (switchType && this.output.mol.bondType(b) == type) {
                    this.output.mol.setBondFromTo(b, bto, bfr);
                }
                else if (this.output.mol.bondOrder(b) != order || this.output.mol.bondType(b) != type) {
                    if (!stereoType && order != this.output.mol.bondOrder(b))
                        this.output.mol.setBondOrder(b, order);
                    else
                        this.output.mol.setBondType(b, type);
                }
                else if (switchType) {
                    this.output.mol.setBondFromTo(b, bto, bfr);
                }
            }
        }
        performBondGeomAtom(geom, atom) {
            let mol = this.input.mol;
            let adj = mol.atomAdjList(atom);
            let asz = adj.length, gsz = WebMolKit.SketchUtil.GEOM_ANGLES[geom].length;
            if (asz > gsz) {
                this.errmsg = 'The current atom has more bonds than does the selected geometry.';
                return;
            }
            if (asz == 0) {
                this.performBondNew(atom, 1, WebMolKit.Molecule.BONDTYPE_NORMAL);
                return;
            }
            if (asz == gsz) {
                this.output.mol = WebMolKit.SketchUtil.refitAtomGeometry(mol, atom, geom);
                if (this.output.mol == null)
                    this.errmsg = 'Could not re-fit the atom geometry.';
                return;
            }
            let ang = WebMolKit.CoordUtil.atomBondAngles(mol, atom);
            let newang = WebMolKit.SketchUtil.mapAngleSubstituent(geom, ang);
            if (newang == null) {
                this.output.mol = WebMolKit.SketchUtil.refitAtomGeometry(mol, atom, geom);
                if (this.output.mol == null)
                    this.errmsg = 'Could not re-fit the atom geometry.';
                return;
            }
            this.output.mol = mol.clone();
            let theta = WebMolKit.SketchUtil.pickNewAtomDirection(mol, atom, newang);
            let x = this.output.mol.atomX(atom) + WebMolKit.Molecule.IDEALBOND * Math.cos(theta);
            let y = this.output.mol.atomY(atom) + WebMolKit.Molecule.IDEALBOND * Math.sin(theta);
            let anum = WebMolKit.CoordUtil.atomAtPoint(this.output.mol, x, y);
            if (anum == 0)
                anum = this.output.mol.addAtom('C', x, y);
            WebMolKit.MolUtil.addBond(this.output.mol, atom, anum, 1);
        }
        performBondGeomBond(geom, bond) {
            let mol = this.input.mol;
            let bfr = mol.bondFrom(bond), bto = mol.bondTo(bond);
            let ac1 = mol.atomAdjCount(bfr), ac2 = mol.atomAdjCount(bto);
            if (ac1 > 1 && ac2 == 1) { }
            else if (ac1 == 1 && ac2 > 1) {
                let t = ac1;
                ac1 = ac2;
                ac2 = t;
            }
            else {
                this.errmsg = 'One end of the bond must be terminal.';
                return;
            }
            let adj = mol.atomAdjList(bfr);
            let x1 = mol.atomX(bfr), y1 = mol.atomY(bfr);
            let x2 = mol.atomX(bto), y2 = mol.atomY(bto);
            let ang = [];
            for (let n = 0, p = 0; n < adj.length; n++)
                if (adj[n] != bto) {
                    ang.push(Math.atan2(mol.atomY(adj[n]) - y1, mol.atomX(adj[n]) - x1));
                }
            let newang = WebMolKit.SketchUtil.mapAngleSubstituent(geom, ang);
            if (newang == null) {
                this.errmsg = 'No alternative geometries identified.';
                return;
            }
            let bestAng = WebMolKit.TWOPI + 1, bestX = 0, bestY = 0;
            let curth = Math.atan2(y2 - y1, x2 - x1), r = WebMolKit.norm_xy(x2 - x1, y2 - y1);
            for (let n = 0; n < newang.length; n++) {
                let th = WebMolKit.angleDiff(newang[n], curth);
                if (th < 0)
                    th += WebMolKit.TWOPI;
                if (n > 0 && th > bestAng)
                    continue;
                let x = x1 + r * Math.cos(th + curth);
                let y = y1 + r * Math.sin(th + curth);
                if (WebMolKit.CoordUtil.atomAtPoint(mol, x, y) > 0)
                    continue;
                bestAng = th;
                bestX = x;
                bestY = y;
            }
            if (bestAng > WebMolKit.TWOPI) {
                this.errmsg = 'No alternative geometries identified.';
                return;
            }
            this.output.mol = mol.clone();
            this.output.mol.setAtomPos(bto, bestX, bestY);
        }
        checkAbbreviationReady() {
            let junction = 0;
            let mol = this.input.mol, subjmask = this.subjectMask;
            for (let n = 1; n <= mol.numBonds; n++) {
                let b1 = mol.bondFrom(n), b2 = mol.bondTo(n);
                let atom = 0;
                if ((subjmask[b1 - 1] && !subjmask[b2 - 1] && WebMolKit.MolUtil.hasAbbrev(mol, b1)) ||
                    (subjmask[b2 - 1] && !subjmask[b1 - 1] && WebMolKit.MolUtil.hasAbbrev(mol, b2))) {
                    this.errmsg = 'Already an abbreviation.';
                    return false;
                }
                if (subjmask[b1 - 1] && !subjmask[b2 - 1])
                    atom = b1;
                else if (subjmask[b2 - 1] && !subjmask[b1 - 1])
                    atom = b2;
                if (atom == 0 || atom == junction) { }
                else if (junction == 0)
                    junction = atom;
                else {
                    this.errmsg = 'The selected group must be terminal.';
                    return false;
                }
            }
            return true;
        }
        mobileSide(bond) {
            let { mol } = this.input;
            let atom1 = mol.bondFrom(bond), atom2 = mol.bondTo(bond);
            let g = WebMolKit.Graph.fromMolecule(mol);
            g.removeEdge(atom1 - 1, atom2 - 1);
            let side1 = [], side2 = [];
            for (let grp of g.calculateComponentGroups()) {
                if (grp.includes(atom1 - 1))
                    side1 = WebMolKit.Vec.add(grp, 1);
                if (grp.includes(atom2 - 1))
                    side2 = WebMolKit.Vec.add(grp, 1);
            }
            let weight1 = side1.length * (mol.atomRingBlock(atom1) > 0 ? 2 : 1);
            let weight2 = side2.length * (mol.atomRingBlock(atom2) > 0 ? 2 : 1);
            let sel1 = false, sel2 = false;
            for (let a of side1)
                if (this.isSelected(a)) {
                    sel1 = true;
                    break;
                }
            for (let a of side2)
                if (this.isSelected(a)) {
                    sel2 = true;
                    break;
                }
            if (sel1 && !sel2) { }
            else if ((sel2 && !sel1) || weight2 < weight1)
                return [atom2, atom1, side2];
            return [atom1, atom2, side1];
        }
        isSelected(atom) {
            let mask = this.input.selectedMask;
            return mask ? mask[atom - 1] : false;
        }
        removePolymerBlock(atoms) {
            let polymer = new WebMolKit.PolymerBlock(this.input.mol.clone());
            for (let id of polymer.getIDList()) {
                let unit = polymer.getUnit(id);
                for (let atom of atoms)
                    if (unit.atoms.includes(atom)) {
                        polymer.removeUnit(id);
                        polymer.rewriteMolecule();
                        this.output.mol = polymer.mol;
                        return true;
                    }
            }
            return false;
        }
    }
    WebMolKit.MoleculeActivity = MoleculeActivity;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    const POSITION_TABLE_Y = [
        1, 1,
        2, 2, 2, 2, 2, 2, 2, 2,
        3, 3, 3, 3, 3, 3, 3, 3,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        6, 6,
        8.5, 8.5, 8.5, 8.5, 8.5, 8.5, 8.5, 8.5, 8.5, 8.5, 8.5, 8.5, 8.5, 8.5,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        7, 7,
        9.5, 9.5, 9.5, 9.5, 9.5, 9.5, 9.5, 9.5, 9.5, 9.5, 9.5, 9.5, 9.5, 9.5,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7
    ];
    const POSITION_TABLE_X = [
        1, 18,
        1, 2, 13, 14, 15, 16, 17, 18,
        1, 2, 13, 14, 15, 16, 17, 18,
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
        1, 2,
        3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.5, 11.5, 12.5, 13.5, 14.5, 15.5, 16.5,
        3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
        1, 2,
        3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.5, 11.5, 12.5, 13.5, 14.5, 15.5, 16.5,
        3, 4, 5, 6, 7, 8, 9, 10, 11, 12
    ];
    const CSS_PERIODICTABLE = `
	*.wmk-periodictable-element
	{
		border: 1px solid black;
		border-radius: 2px;
		margin: 0;
		min-width: 2em;
		padding: 0.4em 0 0.3em 0;
		text-align: center;
		color: #FFFFFF;
		cursor: pointer;
	}
	*.wmk-periodictable-block1
	{
		background-color: #313062;
	}
	*.wmk-periodictable-block2
	{
		background-color: #205224;
	}
	*.wmk-periodictable-block3
	{
		background-color: #522818;
	}
	*.wmk-periodictable-block4
	{
		background-color: #575212;
	}
	*.wmk-periodictable-selected
	{
		background-color: #FFFFFF;
		color: #000000;
		cursor: default;
	}
`;
    class PeriodicTableWidget extends WebMolKit.Widget {
        constructor() {
            super();
            this.divList = [];
            this.selectedAtno = 0;
            WebMolKit.installInlineCSS('periodictable', CSS_PERIODICTABLE);
        }
        render(parent) {
            super.render(parent);
            let grid = WebMolKit.dom('<div/>').appendTo(this.contentDOM).css({ 'display': 'grid' });
            grid.css({ 'align-items': 'center', 'justify-content': 'start', 'gap': '1px' });
            let row = POSITION_TABLE_Y.map((y) => Math.round(2 * y) + 1);
            let col = POSITION_TABLE_X.map((x) => Math.round(2 * x) + 1);
            let num = row.length;
            for (let n = 0; n < num; n++) {
                let div = WebMolKit.dom('<div/>').appendTo(grid);
                div.css({ 'grid-row': `${row[n]} / span 2`, 'grid-column': `${col[n]} / span 2` });
                div.addClass('wmk-periodictable-element');
                let blk = WebMolKit.Chemistry.ELEMENT_BLOCKS[n + 1];
                if (blk == 1)
                    div.addClass('wmk-periodictable-block1');
                else if (blk == 2)
                    div.addClass('wmk-periodictable-block2');
                else if (blk == 3)
                    div.addClass('wmk-periodictable-block3');
                else if (blk == 4)
                    div.addClass('wmk-periodictable-block4');
                let el = WebMolKit.Chemistry.ELEMENTS[n + 1];
                div.setText(el);
                this.divList.push(div);
                div.onClick(() => {
                    this.changeElement(el);
                    this.callbackSelect(el);
                });
                div.onDblClick((event) => {
                    this.callbackDoubleClick();
                    event.preventDefault();
                    event.stopPropagation();
                });
            }
        }
        onSelect(callback) {
            this.callbackSelect = callback;
        }
        onDoubleClick(callback) {
            this.callbackDoubleClick = callback;
        }
        changeElement(element) {
            let atno = WebMolKit.Chemistry.ELEMENTS.indexOf(element);
            if (atno == this.selectedAtno)
                return;
            if (this.selectedAtno > 0)
                this.divList[this.selectedAtno - 1].removeClass('wmk-periodictable-selected');
            this.selectedAtno = atno;
            if (this.selectedAtno > 0)
                this.divList[this.selectedAtno - 1].addClass('wmk-periodictable-selected');
        }
    }
    WebMolKit.PeriodicTableWidget = PeriodicTableWidget;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class QueryFieldsWidget extends WebMolKit.Widget {
        constructor(mol, atom, bond) {
            super();
            this.mol = mol;
            this.atom = atom;
            this.bond = bond;
        }
        render(parent) {
            super.render(parent);
            let grid = WebMolKit.dom('<div/>').appendTo(this.contentDOM);
            grid.css({ 'display': 'grid', 'align-items': 'center', 'justify-content': 'start' });
            grid.css({ 'grid-row-gap': '0.5em', 'grid-column-gap': '0.5em' });
            grid.css({ 'grid-template-columns': '[title] auto [value] auto [end]' });
            let row = 0;
            let makeInput = () => {
                let input = WebMolKit.dom('<input size="20"/>').appendTo(grid).css({ 'grid-area': `${row} / value` });
                return input;
            };
            let makeToggleInput = () => {
                let div = WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': `${row} / value`, 'dispkay': 'flex' });
                let lbl = WebMolKit.dom('<label/>').appendTo(div).css({ 'margin-right': '0.5em' });
                let chk = WebMolKit.dom('<input type="checkbox"/>').appendTo(lbl);
                lbl.appendText('Not');
                let input = WebMolKit.dom('<input size="20"/>').appendTo(div).css({ 'flex-grow': '1' });
                return [chk, input];
            };
            if (this.atom > 0) {
                WebMolKit.dom('<div>Charges</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });
                this.inputCharges = makeInput();
                WebMolKit.dom('<div>Aromatic</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });
                this.optAromatic = new WebMolKit.OptionList(['Maybe', 'Yes', 'No']);
                this.optAromatic.render(WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': `${row} / value` }));
                WebMolKit.dom('<div>Elements</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });
                [this.chkNotElements, this.inputElements] = makeToggleInput();
                WebMolKit.dom('<div>Ring Sizes</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });
                [this.chkNotRingSizes, this.inputRingSizes] = makeToggleInput();
                WebMolKit.dom('<div>Ring Block</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });
                this.optRingBlock = new WebMolKit.OptionList(['Maybe', 'Yes', 'No']);
                this.optRingBlock.render(WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': `${row} / value` }));
                WebMolKit.dom('<div># Small Rings</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });
                this.inputNumRings = makeInput();
                WebMolKit.dom('<div>Adjacency</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });
                this.inputAdjacency = makeInput();
                WebMolKit.dom('<div>Bond Sums</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });
                this.inputBondSums = makeInput();
                WebMolKit.dom('<div>Valences</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });
                this.inputValences = makeInput();
                WebMolKit.dom('<div>Hydrogens</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });
                this.inputHydrogens = makeInput();
                WebMolKit.dom('<div>Isotopes</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });
                this.inputIsotopes = makeInput();
                this.setupAtom();
            }
            else {
                WebMolKit.dom('<div>Ring Sizes</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });
                [this.chkNotRingSizes, this.inputRingSizes] = makeToggleInput();
                WebMolKit.dom('<div>Ring Block</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });
                this.optRingBlock = new WebMolKit.OptionList(['Maybe', 'Yes', 'No']);
                this.optRingBlock.render(WebMolKit.dom('<div/>').appendTo(grid).css({ 'grid-area': `${row} / value` }));
                WebMolKit.dom('<div># Small Rings</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });
                this.inputNumRings = makeInput();
                WebMolKit.dom('<div>Num Rings</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });
                this.inputNumRings = makeInput();
                WebMolKit.dom('<div>Bond Orders</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });
                this.inputOrders = makeInput();
                this.setupBond();
            }
        }
        updateAtom() {
            const { mol, atom } = this;
            WebMolKit.QueryUtil.deleteQueryAtomAll(mol, atom);
            let chg = this.splitNumbers(this.inputCharges.getValue());
            if (chg)
                WebMolKit.QueryUtil.setQueryAtomCharges(mol, atom, chg);
            let arom = this.optAromatic.getSelectedIndex();
            if (arom > 0)
                WebMolKit.QueryUtil.setQueryAtomAromatic(mol, atom, arom == 1);
            let elem = this.splitStrings(this.inputElements.getValue());
            if (elem) {
                if (!this.chkNotElements.elInput.checked)
                    WebMolKit.QueryUtil.setQueryAtomElements(mol, atom, elem);
                else
                    WebMolKit.QueryUtil.setQueryAtomElementsNot(mol, atom, elem);
            }
            let ringsz = this.splitNumbers(this.inputRingSizes.getValue());
            if (ringsz) {
                if (!this.chkNotRingSizes.elInput.checked)
                    WebMolKit.QueryUtil.setQueryAtomRingSizes(mol, atom, ringsz);
                else
                    WebMolKit.QueryUtil.setQueryAtomRingSizesNot(mol, atom, ringsz);
            }
            let ringblk = this.optRingBlock.getSelectedIndex();
            if (ringblk > 0)
                WebMolKit.QueryUtil.setQueryAtomRingBlock(mol, atom, ringblk == 1);
            let nring = this.splitNumbers(this.inputNumRings.getValue());
            if (nring)
                WebMolKit.QueryUtil.setQueryAtomNumRings(mol, atom, nring);
            let adj = this.splitNumbers(this.inputAdjacency.getValue());
            if (adj)
                WebMolKit.QueryUtil.setQueryAtomAdjacency(mol, atom, adj);
            let bond = this.splitNumbers(this.inputBondSums.getValue());
            if (bond)
                WebMolKit.QueryUtil.setQueryAtomBondSums(mol, atom, bond);
            let val = this.splitNumbers(this.inputValences.getValue());
            if (val)
                WebMolKit.QueryUtil.setQueryAtomValences(mol, atom, val);
            let hyd = this.splitNumbers(this.inputHydrogens.getValue());
            if (hyd)
                WebMolKit.QueryUtil.setQueryAtomHydrogens(mol, atom, hyd);
            let iso = this.splitNumbers(this.inputIsotopes.getValue());
            if (iso)
                WebMolKit.QueryUtil.setQueryAtomIsotope(mol, atom, iso);
        }
        updateBond() {
            const { mol, bond } = this;
            WebMolKit.QueryUtil.deleteQueryBondAll(mol, bond);
            let ringsz = this.splitNumbers(this.inputRingSizes.getValue());
            if (ringsz) {
                if (!this.chkNotRingSizes.elInput.checked)
                    WebMolKit.QueryUtil.setQueryBondRingSizes(mol, bond, ringsz);
                else
                    WebMolKit.QueryUtil.setQueryBondRingSizesNot(mol, bond, ringsz);
            }
            let ringblk = this.optRingBlock.getSelectedIndex();
            if (ringblk > 0)
                WebMolKit.QueryUtil.setQueryBondRingBlock(mol, bond, ringblk == 1);
            let nring = this.splitNumbers(this.inputNumRings.getValue());
            if (nring)
                WebMolKit.QueryUtil.setQueryBondNumRings(mol, bond, nring);
            let order = this.splitNumbers(this.inputOrders.getValue());
            if (order)
                WebMolKit.QueryUtil.setQueryBondOrders(mol, bond, order);
        }
        setupAtom() {
            const { mol, atom } = this;
            let chg = WebMolKit.QueryUtil.queryAtomCharges(mol, atom);
            let arom = WebMolKit.QueryUtil.queryAtomAromatic(mol, atom);
            let elem = WebMolKit.QueryUtil.queryAtomElements(mol, atom);
            let elemNot = WebMolKit.QueryUtil.queryAtomElementsNot(mol, atom);
            let ringsz = WebMolKit.QueryUtil.queryAtomRingSizes(mol, atom);
            let ringszNot = WebMolKit.QueryUtil.queryAtomRingSizesNot(mol, atom);
            let ringblk = WebMolKit.QueryUtil.queryAtomRingBlock(mol, atom);
            let nring = WebMolKit.QueryUtil.queryAtomNumRings(mol, atom);
            let adj = WebMolKit.QueryUtil.queryAtomAdjacency(mol, atom);
            let bond = WebMolKit.QueryUtil.queryAtomBondSums(mol, atom);
            let val = WebMolKit.QueryUtil.queryAtomValences(mol, atom);
            let hyd = WebMolKit.QueryUtil.queryAtomHydrogens(mol, atom);
            let iso = WebMolKit.QueryUtil.queryAtomIsotope(mol, atom);
            let frag = WebMolKit.QueryUtil.queryAtomSubFrags(mol, atom);
            let fragNot = WebMolKit.QueryUtil.queryAtomSubFragsNot(mol, atom);
            this.inputCharges.setValue(WebMolKit.Vec.notBlank(chg) ? chg.join(',') : '');
            this.optAromatic.setSelectedIndex(arom == null ? 0 : arom ? 1 : 2);
            this.chkNotElements.elInput.checked = WebMolKit.Vec.isBlank(elem) && WebMolKit.Vec.notBlank(elemNot);
            this.inputElements.setValue(WebMolKit.Vec.notBlank(elem) ? elem.join(',') : WebMolKit.Vec.notBlank(elemNot) ? elemNot.join(',') : '');
            this.chkNotRingSizes.elInput.checked = WebMolKit.Vec.isBlank(ringsz) && WebMolKit.Vec.notBlank(ringszNot);
            this.inputRingSizes.setValue(WebMolKit.Vec.notBlank(ringsz) ? ringsz.join(',') : WebMolKit.Vec.notBlank(ringszNot) ? ringszNot.join(',') : '');
            this.optRingBlock.setSelectedIndex(ringblk == null ? 0 : ringblk ? 1 : 2);
            this.inputNumRings.setValue(WebMolKit.Vec.notBlank(nring) ? nring.join(',') : '');
            this.inputAdjacency.setValue(WebMolKit.Vec.notBlank(adj) ? adj.join(',') : '');
            this.inputBondSums.setValue(WebMolKit.Vec.notBlank(bond) ? bond.join(',') : '');
            this.inputValences.setValue(WebMolKit.Vec.notBlank(val) ? val.join(',') : '');
            this.inputHydrogens.setValue(WebMolKit.Vec.notBlank(hyd) ? hyd.join(',') : '');
            this.inputIsotopes.setValue(WebMolKit.Vec.notBlank(iso) ? iso.join(',') : '');
        }
        setupBond() {
            const { mol, bond } = this;
            let ringsz = WebMolKit.QueryUtil.queryBondRingSizes(mol, bond);
            let ringszNot = WebMolKit.QueryUtil.queryBondRingSizesNot(mol, bond);
            let ringblk = WebMolKit.QueryUtil.queryBondRingBlock(mol, bond);
            let nring = WebMolKit.QueryUtil.queryBondNumRings(mol, bond);
            let order = WebMolKit.QueryUtil.queryBondOrders(mol, bond);
            this.chkNotRingSizes.elInput.checked = WebMolKit.Vec.isBlank(ringsz) && WebMolKit.Vec.notBlank(ringszNot);
            this.inputRingSizes.setValue(WebMolKit.Vec.notBlank(ringsz) ? ringsz.join(',') : WebMolKit.Vec.notBlank(ringszNot) ? ringszNot.join(',') : '');
            this.optRingBlock.setSelectedIndex(ringblk == null ? 0 : ringblk ? 1 : 2);
            this.inputNumRings.setValue(WebMolKit.Vec.notBlank(nring) ? nring.join(',') : '');
            this.inputOrders.setValue(WebMolKit.Vec.notBlank(order) ? order.join(',') : '');
        }
        splitStrings(str) {
            let list = [];
            if (str)
                for (let bit of str.split(/[\s\,\;]+/))
                    if (bit)
                        list.push(bit);
            return list.length ? list : null;
        }
        splitNumbers(str) {
            let list = [];
            if (str)
                for (let bit of str.split(/[\s\,\;]+/)) {
                    if (bit.startsWith('+'))
                        bit = bit.substring(1);
                    let num = parseInt(bit);
                    if (!isNaN(num))
                        list.push(num);
                }
            return list.length ? list : null;
        }
    }
    WebMolKit.QueryFieldsWidget = QueryFieldsWidget;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class Sketcher extends WebMolKit.DrawCanvas {
        constructor() {
            super();
            this.inDialog = false;
            this.initialFocus = true;
            this.useToolBank = true;
            this.lowerToolBank = false;
            this.useCommandBank = true;
            this.lowerCommandBank = false;
            this.useTemplateBank = true;
            this.lowerTemplateBank = false;
            this.debugOutput = undefined;
            this.beenSetup = false;
            this.undoStack = [];
            this.redoStack = [];
            this.fadeWatermark = 0;
            this.toolView = null;
            this.commandView = null;
            this.templateView = null;
            this.proxyClip = null;
            this.proxyMenu = null;
        }
        setSize(width, height) {
            this.width = width;
            this.height = height;
        }
        defineMolecule(mol, withAutoScale = true, withStashUndo = false, keepSelect = false) {
            if (mol.compareTo(this.mol) == 0)
                return;
            if (withStashUndo)
                this.stashUndo();
            this.stopTemplateFusion();
            this.mol = mol.clone();
            if (this.onChangeMolecule)
                this.onChangeMolecule(this.mol);
            this.guidelines = [];
            for (let n = 1; n <= this.mol.numAtoms; n++) {
                for (let sprout of WebMolKit.SketchUtil.guidelineSprouts(this.mol, n))
                    this.guidelines.push(sprout);
            }
            if (!this.beenSetup)
                return;
            if (!keepSelect) {
                this.currentAtom = this.currentBond = 0;
                this.selectedMask = null;
            }
            this.stereo = null;
            this.hoverAtom = 0;
            this.hoverBond = 0;
            if (!withAutoScale)
                this.renderMolecule();
            else
                this.autoScale();
        }
        defineClipboard(proxy) {
            this.proxyClip = proxy;
        }
        defineContext(proxy) {
            this.proxyMenu = proxy;
        }
        defineMoleculeString(molsk, withAutoScale, withStashUndo) {
            this.defineMolecule(WebMolKit.Molecule.fromString(molsk), withAutoScale, withStashUndo);
        }
        defineRenderPolicy(policy) {
            this.policy = policy;
            this.pointScale = policy.data.pointScale;
        }
        defineBackground(borderCol, borderRad, bgCol) {
            if (borderCol != null)
                this.border = borderCol;
            if (borderRad != null)
                this.borderRadius = borderRad;
            if (bgCol != null)
                this.background = bgCol;
        }
        clearMolecule() { this.defineMolecule(new WebMolKit.Molecule(), true, true); }
        getMolecule() { return this.mol.clone(); }
        setup(callback) {
            this.beenSetup = true;
            if (this.mol == null)
                this.mol = new WebMolKit.Molecule();
            if (this.policy == null) {
                this.policy = WebMolKit.RenderPolicy.defaultColourOnWhite();
                this.pointScale = this.policy.data.pointScale;
            }
            this.layoutMolecule();
            this.centreAndShrink();
            this.redrawMetaVector();
            if (callback)
                callback();
        }
        setupAsync() {
            return __awaiter(this, void 0, void 0, function* () {
                return new Promise((resolve) => this.setup(() => resolve()));
            });
        }
        render(parent) {
            super.render(parent);
            this.centreAndShrink();
            this.redraw();
            let reserveHeight = 0;
            if (this.useCommandBank) {
                this.commandView = new WebMolKit.ButtonView(WebMolKit.ButtonViewPosition.Bottom, 0, 0, this.width, this.height);
                if (this.lowerCommandBank)
                    this.commandView.lowerBank();
                this.commandView.setHasBigButtons(false);
                this.commandView.pushBank(new WebMolKit.CommandBank(this));
                this.commandView.render(this.container);
                reserveHeight = this.commandView.height;
            }
            if (this.useToolBank) {
                this.toolView = new WebMolKit.ButtonView(WebMolKit.ButtonViewPosition.Left, 0, 0, this.width, this.height - reserveHeight);
                if (this.lowerToolBank)
                    this.toolView.lowerBank();
                this.toolView.setHasBigButtons(false);
                this.toolView.pushBank(new WebMolKit.ToolBank(this));
                this.toolView.render(this.container);
            }
            if (this.useTemplateBank) {
                this.templateView = new WebMolKit.ButtonView(WebMolKit.ButtonViewPosition.Right, 0, 0, this.width, this.height - reserveHeight);
                if (this.lowerTemplateBank)
                    this.templateView.lowerBank();
                this.templateView.setHasBigButtons(true);
                this.templateView.pushBank(new WebMolKit.TemplateBank(this, null));
                this.templateView.render(this.container);
            }
            this.container.onClick((event) => this.mouseClick(event));
            this.container.onDblClick((event) => this.mouseDoubleClick(event));
            this.container.onMouseDown((event) => this.mouseDown(event));
            this.container.onMouseUp((event) => this.mouseUp(event));
            this.container.onMouseOver((event) => this.mouseOver(event));
            this.container.onMouseLeave((event) => this.mouseOut(event));
            this.container.onMouseMove((event) => this.mouseMove(event));
            this.container.onKeyPress((event) => this.keyPressed(event));
            this.container.onKeyDown((event) => this.keyDown(event));
            this.container.onKeyUp((event) => this.keyUp(event));
            this.container.onTouchStart((event) => this.touchStart(event));
            this.container.onTouchMove((event) => this.touchMove(event));
            this.container.onTouchCancel((event) => this.touchCancel(event));
            this.container.onTouchEnd((event) => this.touchEnd(event));
            this.contentDOM.onContextMenu((event) => this.contextMenu(event));
            this.container.el.addEventListener('dragover', (event) => {
                event.stopPropagation();
                event.preventDefault();
                event.dataTransfer.dropEffect = 'copy';
            });
            this.container.el.addEventListener('drop', (event) => {
                event.stopPropagation();
                event.preventDefault();
                this.dropInto(event.dataTransfer);
            });
            if (this.initialFocus)
                this.grabFocus();
        }
        get decoration() { return this.viewOpt.decoration; }
        set decoration(decoration) { if (this.viewOpt.decoration != decoration) {
            this.viewOpt.decoration = decoration;
            this.renderMolecule();
        } }
        get showOxState() { return this.viewOpt.showOxState; }
        set showOxState(showOxState) { if (this.viewOpt.showOxState != showOxState) {
            this.viewOpt.showOxState = showOxState;
            this.renderMolecule();
        } }
        get showQuery() { return this.viewOpt.showQuery; }
        set showQuery(showQuery) { if (this.viewOpt.showQuery != showQuery) {
            this.viewOpt.showQuery = showQuery;
            this.renderMolecule();
        } }
        get showArtifacts() { return this.viewOpt.showArtifacts; }
        set showArtifacts(showArtifacts) { if (this.viewOpt.showArtifacts != showArtifacts) {
            this.viewOpt.showArtifacts = showArtifacts;
            this.renderMolecule();
        } }
        changeSize(width, height) {
            if (width == this.width && height == this.height)
                return;
            this.width = width;
            this.height = height;
            for (let widget of [this.container, this.canvasUnder, this.canvasMolecule, this.canvasOver]) {
                widget.css({ 'width': `${width}px`, 'height': `${height}px` });
            }
            for (let btnv of [this.commandView, this.toolView, this.templateView])
                if (btnv) {
                    btnv.setParentSize(width, height);
                    btnv.refreshBank();
                }
            this.autoScale();
        }
        showMessage(msg, isError = false) {
            let watermark = ++this.fadeWatermark;
            this.divMessage.css({ 'color': isError ? '#FF0000' : '#008000' });
            this.divMessage.setText(msg);
            let szLeft = (this.toolView == null ? 0 : this.toolView.width) + 2;
            let szRight = (this.templateView == null ? 0 : this.templateView.width) + 2;
            let szBottom = (this.commandView == null ? 0 : this.commandView.height) + 2;
            this.divMessage.css({ 'left': szLeft + 'px' });
            this.divMessage.css({ 'width': (this.width - szLeft - szRight) + 'px' });
            this.divMessage.css({ 'height': (this.height - szBottom) + 'px' });
            window.setTimeout(() => {
                if (watermark == this.fadeWatermark)
                    this.divMessage.setText('');
            }, 5000);
        }
        clearMessage() {
            if (this.divMessage.getText() == '')
                return;
            this.fadeWatermark++;
            this.divMessage.setText('');
        }
        autoScale() {
            this.pointScale = this.policy.data.pointScale;
            this.layoutMolecule();
            this.centreAndShrink();
            this.redrawMetaVector();
            this.layoutTemplatePerm();
            this.delayedRedraw();
        }
        anySelected() {
            if (this.selectedMask == null)
                return false;
            for (let n = 0; n < this.selectedMask.length; n++)
                if (this.selectedMask[n])
                    return true;
            return false;
        }
        setSelected(atom, sel) {
            if (this.selectedMask == null) {
                this.selectedMask = new Array(this.mol.numAtoms);
                for (let n = this.selectedMask.length - 1; n >= 0; n--)
                    this.selectedMask[n] = false;
            }
            while (this.selectedMask.length < this.mol.numAtoms) {
                this.selectedMask.push(false);
            }
            this.selectedMask[atom - 1] = sel;
            this.delayedRedraw();
        }
        changeCurrentAtom(atom) {
            if (this.currentAtom == atom)
                return;
            this.currentAtom = atom;
            this.currentBond = 0;
            this.delayedRedraw();
        }
        changeCurrentBond(bond) {
            if (this.currentBond == bond)
                return;
            this.currentBond = bond;
            this.currentAtom = 0;
            this.delayedRedraw();
        }
        clearSubject() {
            if (this.currentAtom == 0 && this.currentBond == 0 && WebMolKit.Vec.allFalse(this.selectedMask))
                return;
            this.currentAtom = 0;
            this.currentBond = 0;
            this.selectedMask = WebMolKit.Vec.booleanArray(false, this.mol.numAtoms);
            this.delayedRedraw();
        }
        setState(state, withStashUndo = true) {
            this.stopTemplateFusion();
            if (state.mol != null)
                this.defineMolecule(state.mol.clone(), false, withStashUndo, true);
            if (state.currentAtom >= 0)
                this.currentAtom = state.currentAtom;
            if (state.currentBond >= 0)
                this.currentBond = state.currentBond;
            if (state.selectedMask != null)
                this.selectedMask = state.selectedMask == null ? null : state.selectedMask.slice(0);
            this.delayedRedraw();
        }
        stashUndo() {
            if (this.undoStack.length == 0 && this.mol.numAtoms == 0)
                return;
            let state = this.getState();
            this.undoStack.push(state);
            while (this.undoStack.length > Sketcher.UNDO_SIZE) {
                this.undoStack.splice(0, 1);
            }
            this.redoStack = [];
        }
        setPermutations(perms) {
            this.templatePerms = perms;
            this.pickTemplatePermutation(0);
            this.fusionBank = new WebMolKit.FusionBank(this);
            this.templateView.pushBank(this.fusionBank);
            if (this.mol.numAtoms == 0)
                this.centreAndShrink();
        }
        stopTemplateFusion() {
            if (this.fusionBank != null)
                this.templateView.popBank();
        }
        clearPermutations() {
            if (this.templatePerms == null)
                return;
            this.templatePerms = null;
            this.delayedRedraw();
            this.fusionBank = null;
        }
        templateAccept() {
            let mol = WebMolKit.Molecule.fromString(this.templatePerms[this.currentPerm].mol);
            this.templateView.popBank();
            this.defineMolecule(mol, false, true, false);
        }
        templateRotate(dir) {
            let idx = (this.currentPerm + dir) % this.templatePerms.length;
            if (idx < 0)
                idx += this.templatePerms.length;
            this.pickTemplatePermutation(idx);
        }
        canUndo() { return this.undoStack.length > 0; }
        canRedo() { return this.redoStack.length > 0; }
        performUndo() {
            if (this.undoStack.length == 0)
                return;
            let state = this.getState();
            this.redoStack.push(state);
            this.setState(this.undoStack.pop(), false);
        }
        performRedo() {
            if (this.redoStack.length == 0)
                return;
            let state = this.getState();
            this.undoStack.push(state);
            this.setState(this.redoStack.pop(), false);
        }
        performCopy(mol) {
            if (!mol)
                mol = this.getMolecule();
            if (this.proxyClip)
                this.proxyClip.setString(mol.toString());
        }
        performCopySelection(andCut) {
            new WebMolKit.MoleculeActivity(this.getState(), andCut ? WebMolKit.ActivityType.Cut : WebMolKit.ActivityType.Copy, {}, this).execute();
        }
        performPaste() {
            if (this.proxyClip && this.proxyClip.canAlwaysGet()) {
                let txt = this.proxyClip.getString();
                this.pasteText(txt);
            }
        }
        performActivity(activity, param = {}) {
            new WebMolKit.MoleculeActivity(this.getState(), activity, param, this).execute();
        }
        zoom(mag) {
            let cx = 0.5 * this.width, cy = 0.5 * this.height;
            let newScale = Math.min(10 * this.policy.data.pointScale, Math.max(0.1 * this.policy.data.pointScale, this.pointScale * mag));
            if (newScale == this.pointScale)
                return;
            this.offsetX = cx - (newScale / this.pointScale) * (cx - this.offsetX);
            this.offsetY = cy - (newScale / this.pointScale) * (cy - this.offsetY);
            this.pointScale = newScale;
            this.layoutMolecule();
            this.redrawMetaVector();
            this.layoutTemplatePerm();
            this.delayedRedraw();
        }
        editCurrent() {
            if (this.currentAtom > 0)
                this.editAtom(this.currentAtom);
            else if (this.currentBond > 0)
                this.editBond(this.currentBond);
        }
        pasteText(str) {
            let mol = WebMolKit.MoleculeStream.readUnknown(str);
            if (!mol) {
                let ds = WebMolKit.DataSheetStream.readXML(str);
                if (ds) {
                    outer: for (let r = 0; r < ds.numRows; r++)
                        for (let c = 0; c < ds.numCols; c++)
                            if (ds.colType(c) == "molecule" && ds.notNull(r, c)) {
                                mol = ds.getMolecule(r, c);
                                break outer;
                            }
                }
            }
            if (mol != null)
                this.pasteMolecule(mol);
            else
                alert('Text from clipboard is not a valid molecule.');
        }
        pasteMolecule(mol) {
            if (this.mol.numAtoms == 0) {
                this.defineMolecule(mol, true, true, true);
                return;
            }
            let molact = new WebMolKit.MoleculeActivity(this.getState(), WebMolKit.ActivityType.QueryPaste, { 'qmol': mol });
            molact.execute();
            if (molact.output.mol) {
                this.defineMolecule(molact.output.mol, false, true, true);
                return;
            }
            let param = { 'fragNative': mol.toString() };
            new WebMolKit.MoleculeActivity(this.getState(), WebMolKit.ActivityType.TemplateFusion, param, this).execute();
        }
        pickTemplatePermutation(idx) {
            let perm = this.templatePerms[idx];
            this.currentPerm = idx;
            this.layoutTemplatePerm();
            this.delayedRedraw();
        }
        performPolymerBlock(atoms) {
            let dlg = new WebMolKit.EditPolymer(this.mol, atoms, this.proxyClip, () => {
                if (this.mol.compareTo(dlg.mol) != 0)
                    this.defineMolecule(dlg.mol, false, true, true);
                dlg.close();
            });
            dlg.callbackClose = () => {
                this.inDialog = false;
                this.grabFocus();
            };
            this.inDialog = true;
            dlg.open();
        }
        grabFocus() {
            this.container.grabFocus();
        }
        hasFocus() {
            return this.container.hasFocus();
        }
        centreAndShrink() {
            if (this.mol.numAtoms == 0 || this.layout == null) {
                this.offsetX = 0.5 * this.width;
                this.offsetY = 0.5 * this.height;
                this.pointScale = this.policy.data.pointScale;
                return;
            }
            let bounds = this.layout.determineBoundary(0);
            let limW = this.width - 6, limH = this.height - 6;
            let natW = bounds[2] - bounds[0], natH = bounds[3] - bounds[1];
            let scale = 1;
            if (natW > limW) {
                let down = limW / natW;
                scale *= down;
                natW *= down;
                natH *= down;
            }
            if (natH > limH) {
                let down = limH / natH;
                scale *= down;
                natW *= down;
                natH *= down;
            }
            if (scale < 1) {
                this.pointScale *= scale;
                this.layout.offsetEverything(this.offsetX * scale, this.offsetY * scale);
                this.layout.scaleEverything(scale);
                bounds = this.layout.determineBoundary(0);
            }
            let dx = 0.5 * (limW - natW) - bounds[0], dy = 0.5 * (limH - natH) - bounds[1];
            this.offsetX += dx;
            this.offsetY += dy;
            this.layout.offsetEverything(dx, dy);
        }
        layoutTemplatePerm() {
            if (this.currentPerm < 0 || this.templatePerms == null)
                return;
            let perm = this.templatePerms[this.currentPerm];
            let tpolicy = new WebMolKit.RenderPolicy(this.policy.data);
            tpolicy.data.foreground = 0x808080;
            tpolicy.data.atomCols = tpolicy.data.atomCols.slice(0);
            for (let n in tpolicy.data.atomCols)
                tpolicy.data.atomCols[n] = 0x808080;
            let effects = new WebMolKit.RenderEffects();
            let layout = new WebMolKit.ArrangeMolecule(WebMolKit.Molecule.fromString(perm.display), this, tpolicy, effects);
            layout.arrange();
            perm.metavec = new WebMolKit.MetaVector();
            new WebMolKit.DrawMolecule(layout, perm.metavec).draw();
        }
        renderMolecule() {
            this.layoutMolecule();
            this.redrawMetaVector();
            this.delayedRedraw();
        }
        pickObjectCanvas(x, y) {
            if (this.layout == null)
                return 0;
            if (this.toolView != null) {
                let pos1 = this.container.offset(), pos2 = this.toolView.contentDOM.offset();
                if (this.toolView.withinOutline(x + pos1.x - pos2.x, y + pos1.y - pos2.y))
                    return null;
            }
            if (this.commandView != null) {
                let pos1 = this.container.offset(), pos2 = this.commandView.contentDOM.offset();
                if (this.commandView.withinOutline(x + pos1.x - pos2.x, y + pos1.y - pos2.y))
                    return null;
            }
            if (this.templateView != null) {
                let pos1 = this.container.offset(), pos2 = this.templateView.contentDOM.offset();
                if (this.templateView.withinOutline(x + pos1.x - pos2.x, y + pos1.y - pos2.y))
                    return null;
            }
            return super.pickObjectCanvas(x, y);
        }
        updateHoverCursor(x, y) {
            let tool = this.toolView ? this.toolView.selectedButton : '';
            let toolApplies = tool && tool != WebMolKit.ToolBankItem.Pan && tool != WebMolKit.ToolBankItem.Rotate;
            let mouseObj = 0;
            if (this.dragType == WebMolKit.DraggingTool.None && toolApplies) {
                mouseObj = this.pickObject(x, y);
            }
            let mouseAtom = mouseObj > 0 ? mouseObj : 0, mouseBond = mouseObj < 0 ? -mouseObj : 0;
            let abbrevThen = this.hoverAtom > 0 && WebMolKit.MolUtil.hasAbbrev(this.mol, this.hoverAtom) ? this.hoverAtom : 0;
            let abbrevNow = mouseAtom > 0 && WebMolKit.MolUtil.hasAbbrev(this.mol, mouseAtom) ? mouseAtom : 0;
            if (mouseAtom != this.hoverAtom || mouseBond != this.hoverBond) {
                this.hoverAtom = mouseAtom;
                this.hoverBond = mouseBond;
                if (abbrevThen != abbrevNow) {
                    this.layoutMolecule();
                    this.redrawMetaVector();
                }
                this.delayedRedraw();
            }
        }
        determineDragGuide(order) {
            if (this.opAtom == 0 || this.mol.atomAdjCount(this.opAtom) == 0) {
                let g = {
                    'atom': this.opAtom,
                    'orders': [order],
                    'x': [],
                    'y': [],
                    'sourceX': this.opAtom == 0 ? this.clickX : this.angToX(this.mol.atomX(this.opAtom)),
                    'sourceY': this.opAtom == 0 ? this.clickY : this.angToY(this.mol.atomY(this.opAtom)),
                    'destX': [],
                    'destY': []
                };
                let mx = this.opAtom == 0 ? this.xToAng(this.clickX) : this.mol.atomX(this.opAtom);
                let my = this.opAtom == 0 ? this.yToAng(this.clickY) : this.mol.atomY(this.opAtom);
                for (let n = 0; n < 12; n++) {
                    let theta = WebMolKit.TWOPI * n / 12;
                    let dx = WebMolKit.Molecule.IDEALBOND * Math.cos(theta), dy = WebMolKit.Molecule.IDEALBOND * Math.sin(theta);
                    g.x.push(mx + dx);
                    g.y.push(my + dy);
                    g.destX.push(g.sourceX + dx * this.pointScale);
                    g.destY.push(g.sourceY - dy * this.pointScale);
                }
                return [g];
            }
            if (this.guidelines == null)
                return null;
            let best = null, single = null;
            for (let n = 0; n < this.guidelines.length; n++) {
                let g = this.guidelines[n];
                if (g.atom != this.opAtom)
                    continue;
                if (g.orders.indexOf(order) >= 0) {
                    best = g;
                    break;
                }
                if (g.orders.indexOf(1) >= 0)
                    single = g;
            }
            if (best == null)
                best = single;
            if (best == null)
                return [];
            let g = WebMolKit.clone(best);
            g.sourceX = this.angToX(this.mol.atomX(g.atom));
            g.sourceY = this.angToY(this.mol.atomY(g.atom));
            g.destX = [];
            g.destY = [];
            for (let n = 0; n < g.x.length; n++) {
                g.destX.push(this.angToX(g.x[n]));
                g.destY.push(this.angToY(g.y[n]));
            }
            return [g];
        }
        determineMoveGuide() {
            let subj = this.subjectAtoms(false, true);
            if (subj.length == 0 || subj.length == this.mol.numAtoms)
                return null;
            let guides = [];
            for (let n = 0; n < this.guidelines.length; n++) {
                let g = this.guidelines[n];
                if (g.orders.indexOf(1) < 0 || subj.indexOf(g.atom) >= 0)
                    continue;
                g = WebMolKit.clone(g);
                g.sourceX = this.angToX(this.mol.atomX(g.atom));
                g.sourceY = this.angToY(this.mol.atomY(g.atom));
                g.destX = [];
                g.destY = [];
                for (let i = 0; i < g.x.length; i++) {
                    g.destX.push(this.angToX(g.x[i]));
                    g.destY.push(this.angToY(g.y[i]));
                }
                guides.push(g);
            }
            return guides;
        }
        editAtom(atom) {
            if (atom == 0)
                return;
            let dlg = new WebMolKit.EditAtom(this.mol, atom, this.proxyClip, () => {
                if (this.mol.compareTo(dlg.mol) != 0)
                    this.defineMolecule(dlg.mol, false, true, true);
                dlg.close();
            });
            dlg.callbackClose = () => {
                this.inDialog = false;
                this.grabFocus();
            };
            this.inDialog = true;
            dlg.open();
        }
        editBond(bond) {
            if (bond == 0)
                return;
            let dlg = new WebMolKit.EditBond(this.mol, bond, this.proxyClip, () => {
                if (this.mol.compareTo(dlg.mol) != 0)
                    this.defineMolecule(dlg.mol, false, true, true);
                dlg.close();
            });
            dlg.callbackClose = () => {
                this.inDialog = false;
                this.grabFocus();
            };
            this.inDialog = true;
            dlg.open();
        }
        hitArrowKey(dx, dy) {
            let watermark = ++this.cursorWatermark;
            this.cursorDX += dx;
            this.cursorDY += dy;
            setTimeout(() => {
                if (watermark == this.cursorWatermark)
                    this.cursorJumpDirection();
            }, 100);
        }
        cursorJumpDirection() {
            let theta = Math.atan2(this.cursorDY, this.cursorDX);
            if (this.currentAtom > 0)
                this.jumpFromCurrentAtom(theta);
            else if (this.currentBond > 0)
                this.jumpFromCurrentBond(theta);
            else
                this.jumpFromNowhere(theta);
            this.cursorDX = 0;
            this.cursorDY = 0;
            this.cursorWatermark = 0;
        }
        jumpFromCurrentAtom(theta) {
            let adj = this.mol.atomAdjList(this.currentAtom);
            let closest = 0, closestDelta = Number.MAX_VALUE;
            for (let a of adj) {
                let dx = this.mol.atomX(a) - this.mol.atomX(this.currentAtom), dy = this.mol.atomY(a) - this.mol.atomY(this.currentAtom);
                let adjTheta = Math.atan2(dy, dx), delta = Math.abs(WebMolKit.angleDiff(adjTheta, theta));
                if (delta < 35.0 * WebMolKit.DEGRAD && delta < closestDelta)
                    [closest, closestDelta] = [a, delta];
            }
            if (closest > 0) {
                this.changeCurrentBond(this.mol.findBond(this.currentAtom, closest));
                return;
            }
            let best = 0, bestScore = Number.MIN_VALUE;
            for (let n = 1; n <= this.mol.numAtoms; n++)
                if (n != this.currentAtom && adj.indexOf(n) < 0) {
                    let dx = this.mol.atomX(n) - this.mol.atomX(this.currentAtom), dy = this.mol.atomY(n) - this.mol.atomY(this.currentAtom);
                    let adjTheta = Math.atan2(dy, dx), delta = Math.abs(WebMolKit.angleDiff(adjTheta, theta));
                    if (delta > 45.0 * WebMolKit.DEGRAD)
                        continue;
                    let cosdelta = Math.cos(delta);
                    let score = Math.pow(cosdelta, 2) / (WebMolKit.norm2_xy(dx, dy) + 0.001);
                    if (score > bestScore)
                        [best, bestScore] = [n, score];
                }
            if (best > 0)
                this.changeCurrentAtom(best);
        }
        jumpFromCurrentBond(theta) {
            let [bfr, bto] = this.mol.bondFromTo(this.currentBond);
            let bondTheta = Math.atan2(this.mol.atomY(bto) - this.mol.atomY(bfr), this.mol.atomX(bto) - this.mol.atomX(bfr));
            if (Math.abs(WebMolKit.angleDiff(theta, bondTheta)) < 50.0 * WebMolKit.DEGRAD)
                this.changeCurrentAtom(bto);
            if (Math.abs(WebMolKit.angleDiff(theta, bondTheta + Math.PI)) < 50.0 * WebMolKit.DEGRAD)
                this.changeCurrentAtom(bfr);
        }
        jumpFromNowhere(theta) {
            if (this.mol.numAtoms == 0)
                return;
            if (this.mol.numAtoms == 1) {
                this.changeCurrentAtom(1);
                return;
            }
            let cx = 0, cy = 0;
            for (let n = 1; n <= this.mol.numAtoms; n++) {
                cx += this.mol.atomX(n);
                cy += this.mol.atomY(n);
            }
            let inv = 1.0 / this.mol.numAtoms;
            cx *= inv;
            cy *= inv;
            let best = 0, bestScore = Number.MIN_VALUE;
            for (let n = 1; n <= this.mol.numAtoms; n++) {
                let dx = this.mol.atomX(n) - cx, dy = this.mol.atomY(n) - cy, atheta = Math.atan2(dy, dx);
                let cosdelta = Math.cos(Math.abs(WebMolKit.angleDiff(theta + Math.PI, atheta)));
                let score = cosdelta * WebMolKit.norm_xy(dx, dy);
                if (score > bestScore)
                    [best, bestScore] = [n, score];
            }
            if (best > 0)
                this.changeCurrentAtom(best);
        }
        createRing(rsz, aromatic) {
            const { mol } = this;
            let rx = null, ry = null;
            if (this.currentAtom > 0) {
                let dx = 0, dy = 0, adj = mol.atomAdjList(this.currentAtom);
                let x0 = mol.atomX(this.currentAtom), y0 = mol.atomY(this.currentAtom);
                for (let a of adj) {
                    dx -= mol.atomX(a) - x0;
                    dy -= mol.atomY(a) - y0;
                }
                if (Math.abs(dx) < 0.001 && Math.abs(dy) < 0.001) {
                    if (adj.length >= 2) {
                        let theta = adj.map((a) => Math.atan2(mol.atomY(a) - x0, mol.atomX(a) - y0));
                        WebMolKit.Vec.sort(theta);
                        let best = Number.POSITIVE_INFINITY;
                        for (let n = 0; n < theta.length; n++) {
                            let th = WebMolKit.angleDiff(theta[(n + 1) % theta.length], theta[n]);
                            let lx = Math.cos(th), ly = Math.sin(th), score = WebMolKit.CoordUtil.congestionPoint(mol, x0 + lx, y0 + ly);
                            if (score < best)
                                [best, dx, dy] = [score, lx, ly];
                        }
                    }
                    else
                        [dx, dy] = [1, 0];
                }
                [rx, ry] = WebMolKit.SketchUtil.proposeAtomRing(this.mol, rsz, this.currentAtom, dx, dy);
            }
            else if (this.currentBond > 0) {
                let a1 = mol.bondFrom(this.currentBond), a2 = mol.bondTo(this.currentBond);
                let x1 = mol.atomX(a1), y1 = mol.atomY(a1), x2 = mol.atomX(a2), y2 = mol.atomY(a2);
                let cx = 0.5 * (x1 + x2), cy = 0.5 * (y1 + y2), ox = y1 - y2, oy = x2 - x1;
                let [dx, dy] = WebMolKit.CoordUtil.congestionPoint(mol, cx - ox, cy - oy) < WebMolKit.CoordUtil.congestionPoint(mol, cx + ox, cy + oy) ? [-ox, -oy] : [ox, oy];
                [rx, ry] = WebMolKit.SketchUtil.proposeBondRing(this.mol, rsz, this.currentBond, dx, dy);
            }
            else {
                let x = 0, y = 0;
                if (mol.numAtoms > 0) {
                    let bound = mol.boundary();
                    [x, y] = [bound.maxX() + WebMolKit.Molecule.IDEALBOND, bound.midY()];
                }
                [rx, ry] = WebMolKit.SketchUtil.proposeNewRing(this.mol, rsz, x, y, 1, 0, false);
            }
            if (!rx)
                return;
            let param = {
                'ringX': rx,
                'ringY': ry,
                'aromatic': aromatic
            };
            let molact = new WebMolKit.MoleculeActivity(this.getState(), WebMolKit.ActivityType.Ring, param, this);
            molact.execute();
        }
        mouseClick(event) {
            event.stopPropagation();
            this.grabFocus();
            return false;
        }
        mouseDoubleClick(event) {
            event.stopPropagation();
            event.preventDefault();
            if (this.toolView.selectedButton != WebMolKit.ToolBankItem.Arrow)
                return;
            let xy = WebMolKit.eventCoords(event, this.container);
            let clickObj = this.pickObject(xy[0], xy[1]);
            if (clickObj > 0) {
                let atom = clickObj;
                this.editAtom(atom);
            }
            else {
                let bond = -clickObj;
                this.editBond(bond);
            }
            return false;
        }
        mouseDown(event) {
            event.stopPropagation();
            event.preventDefault();
            this.clearMessage();
            if (event.ctrlKey && !event.shiftKey && !event.altKey) {
                this.contextMenu(event);
                return;
            }
            let [x, y] = WebMolKit.eventCoords(event, this.container);
            this.interactStart(x, y, event.shiftKey, event.ctrlKey, event.altKey);
            return false;
        }
        mouseUp(event) {
            event.stopPropagation();
            let [x, y] = WebMolKit.eventCoords(event, this.container);
            this.interactEnd(x, y);
            return false;
        }
        mouseOver(event) {
            event.stopPropagation();
            let [x, y] = WebMolKit.eventCoords(event, this.container);
            this.updateHoverCursor(x, y);
            this.updateLasso(x, y);
            return false;
        }
        mouseOut(event) {
            event.stopPropagation();
            let [x, y] = WebMolKit.eventCoords(event, this.container);
            this.updateHoverCursor(x, y);
            this.updateLasso(x, y);
            return false;
        }
        mouseMove(event) {
            event.stopPropagation();
            let [x, y] = WebMolKit.eventCoords(event, this.container);
            this.updateHoverCursor(x, y);
            if (this.dragType == WebMolKit.DraggingTool.None)
                return;
            this.interactDrag(x, y);
            return false;
        }
        keyPressed(event) {
        }
        keyDown(event) {
            let key = event.key;
            if (key == "Escape") {
                for (let view of [this.templateView, this.commandView, this.toolView])
                    if (view != null && view.stackSize > 1) {
                        view.popBank();
                        event.preventDefault();
                        event.stopPropagation();
                        return;
                    }
            }
            let mod = (event.shiftKey ? 'S' : '') + (event.ctrlKey || event.metaKey ? 'C' : '') + (event.altKey ? 'A' : '');
            let nomod = !event.shiftKey && !event.ctrlKey && !event.altKey && !event.metaKey;
            if (key == "Enter")
                this.editCurrent();
            else if (key == "ArrowLeft" && nomod)
                this.hitArrowKey(-1, 0);
            else if (key == "ArrowRight" && nomod)
                this.hitArrowKey(1, 0);
            else if (key == "ArrowUp" && nomod)
                this.hitArrowKey(0, 1);
            else if (key == "ArrowDown" && nomod)
                this.hitArrowKey(0, -1);
            else if (key == 'z' && mod == 'C')
                this.performUndo();
            else if (key == 'Z' && mod == 'SC')
                this.performRedo();
            else if (key == 'z' && nomod)
                this.toolView.cycleSelected(-1);
            else if (key == 'x' && nomod)
                this.toolView.cycleSelected(1);
            else if (this.toolView != null && this.toolView.topBank.claimKey(event)) { }
            else if (this.commandView != null && this.commandView.topBank.claimKey(event)) { }
            else if (this.templateView != null && this.templateView.topBank.claimKey(event)) { }
            else if (key == '#' && mod == 'SC')
                this.createRing(3, false);
            else if (key == '$' && mod == 'SC')
                this.createRing(4, false);
            else if (key == '%' && mod == 'SC')
                this.createRing(5, false);
            else if (key == '^' && mod == 'SC')
                this.createRing(6, false);
            else if (key == '&' && mod == 'SC')
                this.createRing(7, false);
            else if (key == '3' && mod == 'CA')
                this.createRing(3, true);
            else if (key == '4' && mod == 'CA')
                this.createRing(4, true);
            else if (key == '5' && mod == 'CA')
                this.createRing(5, true);
            else if (key == '6' && mod == 'CA')
                this.createRing(6, true);
            else if (key == '7' && mod == 'CA')
                this.createRing(7, true);
            else if (key == 'c' && mod == 'C' && this.proxyClip)
                this.proxyClip.triggerCopy(false);
            else if (key == 'x' && mod == 'C' && this.proxyClip)
                this.proxyClip.triggerCopy(true);
            else if (key == 'v' && mod == 'C' && this.proxyClip && this.proxyClip.canAlwaysGet())
                this.proxyClip.triggerPaste();
            else
                return;
            event.preventDefault();
            event.stopPropagation();
        }
        keyUp(event) {
        }
        touchStart(event) {
            let [x, y] = WebMolKit.eventCoords(event.touches[0], this.container);
            if (this.pickObjectCanvas(x, y) == null)
                return;
            this.interactStart(x, y, event.shiftKey, event.ctrlKey, event.altKey);
            event.preventDefault();
        }
        touchMove(event) {
            if (this.dragType != WebMolKit.DraggingTool.None) {
                let [x, y] = WebMolKit.eventCoords(event.touches[0], this.container);
                this.interactDrag(x, y);
            }
            event.preventDefault();
        }
        touchCancel(event) {
        }
        touchEnd(event) {
            if (this.dragType != WebMolKit.DraggingTool.None) {
                let [x, y] = [this.mouseX, this.mouseY];
                this.interactEnd(x, y);
                event.preventDefault();
            }
        }
        mouseWheel(event) {
        }
        contextMenu(event) {
            event.preventDefault();
            event.stopPropagation();
            this.dragType = WebMolKit.DraggingTool.None;
            if (!this.proxyMenu)
                return;
            let [x, y] = WebMolKit.eventCoords(event, this.container);
            let clickObj = this.pickObject(x, y);
            if (clickObj > 0)
                this.changeCurrentAtom(clickObj);
            else if (clickObj < 0)
                this.changeCurrentBond(-clickObj);
            let state = this.getState();
            let ctx = new WebMolKit.ContextSketch(state, this, this.proxyClip);
            let menu = ctx.populate();
            this.proxyMenu.openContextMenu(menu, event);
        }
        interactStart(x, y, shiftKey, ctrlKey, altKey) {
            this.dragType = WebMolKit.DraggingTool.Press;
            this.opBudged = false;
            this.dragGuides = null;
            this.mouseX = x;
            this.mouseY = y;
            this.clickX = x;
            this.clickY = y;
            let clickObj = this.pickObject(x, y);
            this.opAtom = clickObj > 0 ? clickObj : 0;
            this.opBond = clickObj < 0 ? -clickObj : 0;
            this.opShift = shiftKey;
            this.opCtrl = ctrlKey;
            this.opAlt = altKey;
            let tool = '';
            if (this.toolView != null)
                tool = this.toolView.selectedButton;
            if (tool == WebMolKit.ToolBankItem.Arrow) {
                if (!this.opShift && !this.opCtrl && !this.opAlt) {
                    this.dragType = WebMolKit.DraggingTool.Press;
                }
                else if (!this.opShift && !this.opCtrl && this.opAlt) {
                    this.dragType = WebMolKit.DraggingTool.Pan;
                }
                else if (!this.opShift && this.opCtrl && this.opAlt) {
                    this.dragType = WebMolKit.DraggingTool.Zoom;
                }
            }
            else if (tool == WebMolKit.ToolBankItem.Rotate) {
                this.dragType = WebMolKit.DraggingTool.Rotate;
                this.toolRotateIncr = this.opShift ? 0 : 15 * WebMolKit.DEGRAD;
            }
            else if (tool == WebMolKit.ToolBankItem.Pan) {
                this.dragType = WebMolKit.DraggingTool.Pan;
            }
            else if (tool == WebMolKit.ToolBankItem.Drag) {
                this.dragType = WebMolKit.DraggingTool.Move;
                if (this.opAtom > 0)
                    this.dragGuides = this.determineMoveGuide();
                this.delayedRedraw();
            }
            else if (tool == WebMolKit.ToolBankItem.Erasor) {
                this.dragType = WebMolKit.DraggingTool.Erasor;
                this.lassoX = [x];
                this.lassoY = [y];
                this.lassoMask = [];
            }
            else if (tool == WebMolKit.ToolBankItem.RingAliph) {
                this.dragType = WebMolKit.DraggingTool.Ring;
                this.toolRingArom = false;
                this.toolRingFreeform = this.opShift;
            }
            else if (tool == WebMolKit.ToolBankItem.RingArom) {
                this.dragType = WebMolKit.DraggingTool.Ring;
                this.toolRingArom = true;
                this.toolRingFreeform = this.opShift;
            }
            else if (tool == WebMolKit.ToolBankItem.AtomPlus) {
                this.dragType = WebMolKit.DraggingTool.Charge;
                this.toolChargeDelta = 1;
            }
            else if (tool == WebMolKit.ToolBankItem.AtomMinus) {
                this.dragType = WebMolKit.DraggingTool.Charge;
                this.toolChargeDelta = -1;
            }
            else if (tool.startsWith(WebMolKit.ToolBankItem.BondPfx)) {
                this.dragType = WebMolKit.DraggingTool.Bond;
                this.toolBondOrder = 1;
                this.toolBondType = WebMolKit.Molecule.BONDTYPE_NORMAL;
                if (tool == WebMolKit.ToolBankItem.BondOrder0)
                    this.toolBondOrder = 0;
                else if (tool == WebMolKit.ToolBankItem.BondOrder2)
                    this.toolBondOrder = 2;
                else if (tool == WebMolKit.ToolBankItem.BondOrder3)
                    this.toolBondOrder = 3;
                else if (tool == WebMolKit.ToolBankItem.BondUnknown)
                    this.toolBondType = WebMolKit.Molecule.BONDTYPE_UNKNOWN;
                else if (tool == WebMolKit.ToolBankItem.BondInclined)
                    this.toolBondType = WebMolKit.Molecule.BONDTYPE_INCLINED;
                else if (tool == WebMolKit.ToolBankItem.BondDeclined)
                    this.toolBondType = WebMolKit.Molecule.BONDTYPE_DECLINED;
                if (this.opBond > 0) {
                    let [bfr, bto] = this.mol.bondFromTo(this.opBond), inPoly = false;
                    for (let poly of new WebMolKit.PolymerBlock(this.mol).getUnits()) {
                        let in1 = poly.atoms.includes(bfr), in2 = poly.atoms.includes(bto);
                        if ((in1 && !in2) || (in2 && !in1)) {
                            inPoly = true;
                            break;
                        }
                    }
                    if (inPoly) {
                        this.toolBondOrder = 0;
                        this.toolBondType = WebMolKit.Molecule.BONDTYPE_NORMAL;
                    }
                }
                if (this.opBond == 0)
                    this.dragGuides = this.determineDragGuide(this.toolBondOrder);
            }
            else if (tool.startsWith(WebMolKit.ToolBankItem.ElementPfx)) {
                this.dragType = WebMolKit.DraggingTool.Atom;
                this.toolAtomSymbol = tool.substring(WebMolKit.ToolBankItem.ElementPfx.length);
                this.dragGuides = this.determineDragGuide(1);
            }
        }
        interactDrag(x, y) {
            if (!this.opBudged) {
                let dx = x - this.clickX, dy = y - this.clickY;
                if (dx * dx + dy * dy > 2 * 2)
                    this.opBudged = true;
            }
            if (this.dragType == WebMolKit.DraggingTool.Press && this.opAtom == 0 && this.opBond == 0 && this.opBudged) {
                this.dragType = WebMolKit.DraggingTool.Lasso;
                this.lassoX = [x];
                this.lassoY = [y];
                this.lassoMask = [];
            }
            if (this.dragType == WebMolKit.DraggingTool.Lasso || this.dragType == WebMolKit.DraggingTool.Erasor) {
                this.updateLasso(x, y);
            }
            else if (this.dragType == WebMolKit.DraggingTool.Pan) {
                let dx = x - this.mouseX, dy = y - this.mouseY;
                if (dx != 0 || dy != 0) {
                    this.offsetX += dx;
                    this.offsetY += dy;
                    this.layout.offsetEverything(dx, dy);
                    this.metavec.transformPrimitives(dx, dy, 1, 1);
                    if (this.currentPerm >= 0 && this.templatePerms != null) {
                        let perm = this.templatePerms[this.currentPerm];
                        perm.metavec.transformPrimitives(dx, dy, 1, 1);
                    }
                    this.delayedRedraw();
                }
                this.mouseX = x;
                this.mouseY = y;
            }
            else if (this.dragType == WebMolKit.DraggingTool.Zoom) {
                let dy = y - this.mouseY;
                if (dy != 0) {
                    dy = Math.min(50, Math.max(-50, dy));
                    let newScale = this.pointScale * (1 - dy * 0.01);
                    newScale = Math.min(10, Math.max(0.1, newScale));
                    let newOX = this.clickX - (newScale / this.pointScale) * (this.clickX - this.offsetX);
                    let newOY = this.clickY - (newScale / this.pointScale) * (this.clickY - this.offsetY);
                    this.pointScale = newScale;
                    this.offsetX = newOX;
                    this.offsetY = newOY;
                    this.delayedRedraw();
                }
                this.mouseX = x;
                this.mouseY = y;
            }
            else if (this.dragType == WebMolKit.DraggingTool.Rotate ||
                this.dragType == WebMolKit.DraggingTool.Move ||
                this.dragType == WebMolKit.DraggingTool.Atom ||
                this.dragType == WebMolKit.DraggingTool.Bond ||
                this.dragType == WebMolKit.DraggingTool.Ring) {
                this.mouseX = x;
                this.mouseY = y;
                this.delayedRedraw();
            }
        }
        interactEnd(x, y) {
            if (this.opBudged)
                this.interactEndDrag(x, y);
            else
                this.interactEndClick(x, y);
            this.dragType = WebMolKit.DraggingTool.None;
            this.lassoX = null;
            this.lassoY = null;
            this.lassoMask = null;
            this.dragGuides = null;
            this.delayedRedraw();
        }
        interactEndClick(x, y) {
            let clickObj = this.pickObject(x, y);
            let clickAtom = clickObj > 0 ? clickObj : 0, clickBond = clickObj < 0 ? -clickObj : 0;
            if (this.dragType == WebMolKit.DraggingTool.Press) {
                if (!this.opShift && !this.opCtrl && !this.opAlt) {
                    if (clickAtom == 0 && clickBond == 0) {
                        if (WebMolKit.Vec.anyTrue(this.selectedMask))
                            this.selectedMask = null;
                        else if (this.currentAtom > 0)
                            this.currentAtom = 0;
                        else if (this.currentBond > 0)
                            this.currentBond = 0;
                    }
                    else if (clickAtom != this.currentAtom || clickBond != this.currentBond) {
                        this.currentAtom = clickAtom;
                        this.currentBond = clickBond;
                    }
                    else if (clickAtom == 0 && clickBond == 0 && this.anySelected()) {
                        this.selectedMask = null;
                    }
                }
                else if (this.opShift && !this.opCtrl && !this.opAlt) {
                    if (clickAtom > 0)
                        this.setSelected(clickAtom, !this.getSelected(clickAtom));
                }
            }
            else if (this.dragType == WebMolKit.DraggingTool.Move) {
                if (clickObj == 0) {
                    if (WebMolKit.Vec.anyTrue(this.selectedMask))
                        this.selectedMask = null;
                    else if (this.currentAtom > 0)
                        this.currentAtom = 0;
                    else if (this.currentBond > 0)
                        this.currentBond = 0;
                }
            }
            else if (this.dragType == WebMolKit.DraggingTool.Erasor) {
                if (this.opAtom > 0 || this.opBond > 0) {
                    let state = Object.assign(Object.assign({}, this.getState()), { 'currentAtom': this.opAtom, 'currentBond': this.opBond, 'selectedMask': [] });
                    let molact = new WebMolKit.MoleculeActivity(state, WebMolKit.ActivityType.Delete, {}, this);
                    molact.execute();
                }
            }
            else if (this.dragType == WebMolKit.DraggingTool.Atom) {
                let element = this.toolAtomSymbol;
                if (element == 'A') {
                    let dlg = new WebMolKit.EditAtom(this.mol, this.opAtom, this.proxyClip, () => {
                        let autoscale = this.mol.numAtoms == 0;
                        if (this.mol.compareTo(dlg.mol) != 0)
                            this.defineMolecule(dlg.mol, autoscale, true);
                        dlg.close();
                    });
                    if (this.opAtom == 0) {
                        dlg.newX = this.xToAng(this.clickX);
                        dlg.newY = this.yToAng(this.clickY);
                    }
                    dlg.callbackClose = () => {
                        this.inDialog = false;
                        this.grabFocus();
                    };
                    this.inDialog = true;
                    dlg.open();
                }
                else if (element) {
                    let param = { 'element': element, 'keepAbbrev': true };
                    if (this.opAtom == 0) {
                        let x = this.xToAng(this.clickX), y = this.yToAng(this.clickY);
                        if (this.mol.numAtoms == 0) {
                            this.offsetX = this.clickX;
                            this.offsetY = this.clickY;
                            x = 0;
                            y = 0;
                        }
                        param.positionX = x;
                        param.positionY = y;
                    }
                    let state = Object.assign(Object.assign({}, this.getState()), { 'currentAtom': this.opAtom, 'currentBond': 0, 'selectedMask': null });
                    let molact = new WebMolKit.MoleculeActivity(state, WebMolKit.ActivityType.Element, param, this);
                    molact.execute();
                }
            }
            else if (this.dragType == WebMolKit.DraggingTool.Charge) {
                if (this.opAtom > 0 || this.opBond > 0) {
                    let state = Object.assign(Object.assign({}, this.getState()), { 'currentAtom': this.opAtom, 'currentBond': this.opBond, 'selectedMask': null });
                    let molact = new WebMolKit.MoleculeActivity(state, WebMolKit.ActivityType.Charge, { 'delta': this.toolChargeDelta }, this);
                    molact.execute();
                }
            }
            else if (this.dragType == WebMolKit.DraggingTool.Bond) {
                let state = Object.assign(Object.assign({}, this.getState()), { 'currentAtom': this.opAtom, 'currentBond': this.opBond, 'selectedMask': null });
                let molact;
                if (this.toolBondType == WebMolKit.Molecule.BONDTYPE_NORMAL)
                    molact = new WebMolKit.MoleculeActivity(state, WebMolKit.ActivityType.BondOrder, { 'order': this.toolBondOrder }, this);
                else
                    molact = new WebMolKit.MoleculeActivity(state, WebMolKit.ActivityType.BondType, { 'type': this.toolBondType }, this);
                molact.execute();
            }
        }
        interactEndDrag(x, y) {
            if (this.dragType == WebMolKit.DraggingTool.Lasso) {
                if (this.lassoX.length >= 2) {
                    this.calculateLassoMask();
                    for (let n = 1; n <= this.mol.numAtoms; n++)
                        if (this.getLassoed(n) && !this.getSelected(n))
                            this.setSelected(n, true);
                }
                this.lassoX = null;
                this.lassoY = null;
                this.lassoMask = null;
                this.delayedRedraw();
            }
            else if (this.dragType == WebMolKit.DraggingTool.Erasor) {
                let any = false;
                for (let n = 0; n < this.lassoMask.length; n++)
                    if (this.lassoMask[n]) {
                        any = true;
                        break;
                    }
                if (any) {
                    let state = Object.assign(Object.assign({}, this.getState()), { 'currentAtom': 0, 'currentBond': 0, 'selectedMask': this.lassoMask });
                    let molact = new WebMolKit.MoleculeActivity(state, WebMolKit.ActivityType.Delete, {}, this);
                    molact.execute();
                }
            }
            else if (this.dragType == WebMolKit.DraggingTool.Rotate) {
                let [x0, y0, theta, magnitude] = this.determineDragTheta();
                let degrees = -theta * WebMolKit.RADDEG;
                let mx = this.xToAng(x0), my = this.yToAng(y0);
                let molact = new WebMolKit.MoleculeActivity(this.getState(), WebMolKit.ActivityType.Rotate, { 'theta': degrees, 'centreX': mx, 'centreY': my }, this);
                molact.execute();
            }
            else if (this.dragType == WebMolKit.DraggingTool.Move) {
                let [dx, dy] = this.determineMoveDelta();
                let scale = this.pointScale;
                let molact = new WebMolKit.MoleculeActivity(this.getState(), WebMolKit.ActivityType.Move, { 'refAtom': this.opAtom, 'deltaX': dx / scale, 'deltaY': -dy / scale }, this);
                molact.execute();
            }
            else if (this.dragType == WebMolKit.DraggingTool.Ring) {
                let [ringX, ringY] = this.determineFauxRing();
                if (ringX != null) {
                    let param = {
                        'ringX': ringX,
                        'ringY': ringY,
                        'aromatic': this.toolRingArom
                    };
                    let molact = new WebMolKit.MoleculeActivity(this.getState(), WebMolKit.ActivityType.Ring, param, this);
                    molact.execute();
                }
            }
            else if (this.dragType == WebMolKit.DraggingTool.Atom && this.opAtom > 0) {
                let x2 = this.mouseX, y2 = this.mouseY;
                let snapTo = this.snapToGuide(x2, y2);
                if (snapTo != null)
                    [x2, y2] = snapTo;
                let param = {
                    'order': 1,
                    'type': WebMolKit.Molecule.BONDTYPE_NORMAL,
                    'element': this.toolAtomSymbol,
                    'x1': this.mol.atomX(this.opAtom),
                    'y1': this.mol.atomY(this.opAtom),
                    'x2': this.xToAng(x2),
                    'y2': this.yToAng(y2)
                };
                if (this.toolAtomSymbol == 'A')
                    param.element = window.prompt('Enter element symbol:', '');
                if (param.element != '') {
                    let molact = new WebMolKit.MoleculeActivity(this.getState(), WebMolKit.ActivityType.BondAtom, param, this);
                    molact.execute();
                }
            }
            else if (this.dragType == WebMolKit.DraggingTool.Bond) {
                let x2 = this.mouseX, y2 = this.mouseY;
                let snapTo = this.snapToGuide(x2, y2);
                if (snapTo != null) {
                    [x2, y2] = snapTo;
                    if (this.opBond > 0) {
                        let toObj = this.pickObject(x2, y2, { 'noAtoms': true });
                        if (toObj < 0) {
                            this.connectPolymerBlock(this.opBond, -toObj);
                            return;
                        }
                    }
                }
                let param = {
                    'order': this.toolBondOrder,
                    'type': this.toolBondType,
                    'element': 'C',
                    'x1': this.opAtom == 0 ? this.xToAng(this.clickX) : this.mol.atomX(this.opAtom),
                    'y1': this.opAtom == 0 ? this.yToAng(this.clickY) : this.mol.atomY(this.opAtom),
                    'x2': this.xToAng(x2),
                    'y2': this.yToAng(y2)
                };
                let molact = new WebMolKit.MoleculeActivity(this.getState(), WebMolKit.ActivityType.BondAtom, param, this);
                molact.execute();
            }
        }
        dropInto(transfer) {
            let items = transfer.items, files = transfer.files;
            const SUFFIXES = ['.el', '.mol'];
            const MIMES = ['text/plain', 'chemical/x-sketchel', 'x-mdl-molfile'];
            for (let n = 0; n < items.length; n++) {
                if (items[n].kind == 'string' && MIMES.indexOf(items[n].type) >= 0) {
                    items[n].getAsString((str) => {
                        let mol = WebMolKit.Molecule.fromString(str);
                        if (mol != null) {
                            this.defineMolecule(mol, true, true, true);
                        }
                        else
                            console.log('Dragged data is not a SketchEl molecule: ' + str);
                    });
                    return;
                }
            }
            for (let n = 0; n < files.length; n++) {
                for (let sfx of SUFFIXES)
                    if (files[n].name.endsWith(sfx)) {
                        let reader = new FileReader();
                        reader.onload = (event) => {
                            let str = reader.result;
                            let mol = WebMolKit.MoleculeStream.readUnknown(str.toString());
                            if (mol != null) {
                                this.defineMolecule(mol, true, true);
                            }
                            else
                                console.log('Dragged file is not a recognised molecule: ' + str);
                        };
                        reader.readAsText(files[n]);
                        return;
                    }
            }
        }
        connectPolymerBlock(bond1, bond2) {
            let [atomIn1, atomOut1] = this.mol.bondFromTo(bond1), [atomIn2, atomOut2] = this.mol.bondFromTo(bond2);
            let state = this.getState();
            let polymer = new WebMolKit.PolymerBlock(state.mol);
            let poly1 = null, poly2 = null;
            let highName = 0;
            for (let poly of polymer.getUnits()) {
                if (!poly1 || poly.atoms.length < poly1.atoms.length) {
                    let ina = poly.atoms.includes(atomIn1), inb = poly.atoms.includes(atomOut1);
                    if (ina && !inb)
                        poly1 = poly;
                    else if (inb && !ina)
                        [poly1, atomIn1, atomOut1] = [poly, atomOut1, atomIn1];
                }
                if (!poly2 || poly.atoms.length < poly2.atoms.length) {
                    let ina = poly.atoms.includes(atomIn2), inb = poly.atoms.includes(atomOut2);
                    if (ina && !inb)
                        poly2 = poly;
                    else if (inb && !ina)
                        [poly2, atomIn2, atomOut2] = [poly, atomOut2, atomIn2];
                }
                for (let nameList of poly.atomName.values())
                    highName = Math.max(highName, WebMolKit.Vec.max(nameList));
            }
            if (!poly1 || !poly2)
                return false;
            let name1 = WebMolKit.Vec.first(poly1.atomName.get(atomIn1));
            if (!name1) {
                name1 = ++highName;
                poly1.atomName.set(atomIn1, [name1]);
            }
            let name2 = WebMolKit.Vec.first(poly2.atomName.get(atomIn2));
            if (!name2) {
                name2 = ++highName;
                poly2.atomName.set(atomIn2, [name2]);
            }
            poly1.bondIncl.set(bond1, WebMolKit.Vec.append(poly1.bondIncl.get(bond1), name2));
            poly2.bondIncl.set(bond2, WebMolKit.Vec.append(poly2.bondIncl.get(bond2), name1));
            polymer.rewriteMolecule();
            this.setState(state);
        }
    }
    Sketcher.UNDO_SIZE = 20;
    WebMolKit.Sketcher = Sketcher;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class TemplateBank extends WebMolKit.ButtonBank {
        constructor(owner, group) {
            super();
            this.owner = owner;
            this.group = group;
            this.subgroups = null;
            this.templates = null;
        }
        init() {
            let policy = WebMolKit.RenderPolicy.defaultBlackOnWhite();
            policy.data.pointScale = 10;
            policy.data.lineSize *= 1.5;
            policy.data.bondSep *= 1.5;
            (() => __awaiter(this, void 0, void 0, function* () {
                if (TemplateBank.resourceData.length == 0)
                    yield this.loadResourceData();
                if (this.group == null)
                    this.prepareSubGroups();
                else
                    this.prepareTemplates();
            }))();
        }
        update() {
            if (this.subgroups == null && this.templates == null)
                return;
            this.buttons = [];
            if (this.group == null)
                this.populateGroups();
            else
                this.populateTemplates();
        }
        populateGroups() {
            let groups = this.subgroups.groups, titles = this.subgroups.titles, preview = this.subgroups.preview;
            for (let n = 0; n < groups.length; n++) {
                this.buttons.push({ 'id': groups[n], 'metavec': preview[n], 'helpText': titles[n] });
            }
        }
        populateTemplates() {
            let names = this.templates.names, abbrev = this.templates.abbrev, mnemonic = this.templates.mnemonic, preview = this.templates.preview;
            for (let n = 0; n < names.length; n++) {
                this.buttons.push({ 'id': n.toString(), 'metavec': preview[n], 'helpText': names[n] });
            }
        }
        hitButton(id) {
            if (this.group == null) {
                this.buttonView.pushBank(new TemplateBank(this.owner, id));
            }
            else {
                let idx = parseInt(id);
                let param = { 'fragNative': this.templates.molecules[idx] };
                new WebMolKit.MoleculeActivity(this.owner.getState(), WebMolKit.ActivityType.TemplateFusion, param, this.owner).execute();
            }
        }
        loadResourceData() {
            return __awaiter(this, void 0, void 0, function* () {
                for (let fn of WebMolKit.TEMPLATE_FILES) {
                    let url = WebMolKit.Theme.RESOURCE_URL + '/data/templates/' + fn + '.ds';
                    let dsstr = yield WebMolKit.readTextURL(url);
                    TemplateBank.resourceList.push(fn);
                    TemplateBank.resourceData.push(WebMolKit.DataSheetStream.readXML(dsstr));
                }
            });
        }
        prepareSubGroups() {
            this.subgroups = { 'groups': TemplateBank.resourceList, 'titles': [], 'preview': [] };
            let sz = this.buttonView.idealSize, msz = 0.5 * (sz - 2);
            let policy = WebMolKit.RenderPolicy.defaultBlackOnWhite();
            policy.data.pointScale = 10;
            let effects = new WebMolKit.RenderEffects();
            let measure = new WebMolKit.OutlineMeasurement(0, 0, policy.data.pointScale);
            for (let ds of TemplateBank.resourceData) {
                this.subgroups.titles.push(ds.title);
                let colMol = ds.firstColOfType("molecule");
                let metavec = new WebMolKit.MetaVector();
                for (let n = 0, idx = 0; idx < 4 && n < ds.numRows; n++) {
                    let mol = ds.getMolecule(n, colMol);
                    if (WebMolKit.MolUtil.isBlank(mol))
                        continue;
                    let layout = new WebMolKit.ArrangeMolecule(mol, measure, policy, effects);
                    layout.arrange();
                    let col = (idx % 2), row = Math.floor(idx / 2);
                    layout.squeezeInto(1 + col * msz, 1 + row * msz, msz, msz, 1);
                    new WebMolKit.DrawMolecule(layout, metavec).draw();
                    idx++;
                }
                metavec.width = sz;
                metavec.height = sz;
                this.subgroups.preview.push(metavec);
            }
            this.buttonView.refreshBank();
        }
        prepareTemplates() {
            let idx = TemplateBank.resourceList.indexOf(this.group);
            let ds = TemplateBank.resourceData[idx];
            this.templates = { 'molecules': [], 'names': [], 'abbrev': [], 'mnemonic': [], 'preview': [] };
            let sz = this.buttonView.idealSize;
            let policy = WebMolKit.RenderPolicy.defaultBlackOnWhite();
            policy.data.pointScale = 12;
            let effects = new WebMolKit.RenderEffects();
            let measure = new WebMolKit.OutlineMeasurement(0, 0, policy.data.pointScale);
            let colMol = ds.findColByName('Molecule');
            let colName = ds.findColByName('Name');
            let colAbbrev = ds.findColByName('Abbrev');
            let colMnemonic = ds.findColByName('Mnemonic');
            for (let n = 0; n < ds.numRows; n++) {
                let mol = ds.getMolecule(n, colMol);
                this.templates.molecules.push(mol.toString());
                this.templates.names.push(ds.getString(n, colName));
                this.templates.abbrev.push(ds.getString(n, colAbbrev));
                this.templates.mnemonic.push(ds.getString(n, colMnemonic));
                let layout = new WebMolKit.ArrangeMolecule(mol, measure, policy, effects);
                layout.arrange();
                layout.squeezeInto(0, 0, sz, sz, 2);
                let metavec = new WebMolKit.MetaVector();
                new WebMolKit.DrawMolecule(layout, metavec).draw();
                metavec.width = sz;
                metavec.height = sz;
                this.templates.preview.push(metavec);
            }
            this.buttonView.refreshBank();
        }
    }
    TemplateBank.resourceList = [];
    TemplateBank.resourceData = [];
    WebMolKit.TemplateBank = TemplateBank;
    class FusionBank extends WebMolKit.ButtonBank {
        constructor(owner) {
            super();
            this.owner = owner;
        }
        update() {
            this.buttons = [];
            this.buttons.push({ 'id': 'accept', 'imageFN': 'GenericAccept', 'helpText': 'Apply this template.' });
            this.buttons.push({ 'id': 'prev', 'imageFN': 'TemplatePrev', 'helpText': 'Show previous fusion option.' });
            this.buttons.push({ 'id': 'next', 'imageFN': 'TemplateNext', 'helpText': 'Show next fusion option.' });
        }
        hitButton(id) {
            if (id == 'accept')
                this.owner.templateAccept();
            else if (id == 'prev')
                this.owner.templateRotate(-1);
            else if (id == 'next')
                this.owner.templateRotate(1);
        }
        bankClosed() {
            this.owner.clearPermutations();
        }
    }
    WebMolKit.FusionBank = FusionBank;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class FusionPermutation {
        constructor() {
            this.attdist = 0;
            this.guided = false;
            this.bridged = false;
            this.scoreModifier = 0;
            this.chainSelect = 0;
        }
    }
    WebMolKit.FusionPermutation = FusionPermutation;
    class TemplateFusion {
        constructor(mol, templ, abbrev) {
            this.mol = mol;
            this.templ = templ;
            this.abbrev = abbrev;
            this.perms = [];
            this.numAttach = 0;
            this.withGuideOnly = false;
            this.guidetempl = null;
            this.guideidx = [];
            this.guideadj = [];
            this.timeLimit = 5.0;
            let artif1 = new WebMolKit.BondArtifact(mol), artif2 = new WebMolKit.BondArtifact(templ);
            artif2.harmoniseNumbering(artif1);
            artif2.rewriteMolecule();
            let poly1 = new WebMolKit.PolymerBlock(mol), poly2 = new WebMolKit.PolymerBlock(templ);
            poly2.harmoniseNumbering(poly1);
            poly2.rewriteMolecule();
            this.huntForGuides();
        }
        permuteNone() {
            let numAttach = 0;
            let oldmol = this.mol.clone(), newmol = this.templ.clone();
            if (oldmol.numAtoms > 0) {
                let oldbox = oldmol.boundary(), newbox = newmol.boundary();
                let dx = oldbox.maxX() + 1 - newbox.minX();
                let dy = 0.5 * (oldbox.minY() + oldbox.maxY()) - 0.5 * (newbox.minY() + newbox.maxY());
                WebMolKit.CoordUtil.translateMolecule(newmol, dx, dy);
            }
            else {
                let newbox = newmol.boundary();
                WebMolKit.CoordUtil.translateMolecule(newmol, -newbox.midX(), -newbox.midY());
            }
            let oldbox = oldmol.boundary(), newbox = newmol.boundary();
            let cx = newbox.midX(), cy = newbox.midY();
            let ROTN = [0, 30, 45, 60, 90, 120, 135, 150, 180, 210, 225, 240, 270, 300, 315, 330];
            duplicate: for (let n = 0; n < ROTN.length; n++) {
                let rotmol = newmol.clone();
                WebMolKit.CoordUtil.rotateMolecule(rotmol, -ROTN[n] * WebMolKit.DEGRAD, cx, cy);
                for (let i = 0; i < this.perms.length; i++)
                    if (WebMolKit.CoordUtil.sketchEquivalent(rotmol, this.perms[i].display))
                        continue duplicate;
                let p = new FusionPermutation();
                p.mol = oldmol.clone();
                p.mol.append(rotmol);
                p.display = rotmol;
                p.srcidx = this.sourceIndex(p.mol, oldmol);
                p.attdist = 0;
                p.guided = false;
                this.perms.push(p);
            }
        }
        permuteAtom(atom) {
            this.numAttach = 1;
            let timeStart = new Date().getTime();
            let oldmol = this.mol.clone(), newmol = this.templ.clone();
            let newperms = [];
            if (this.guidetempl != null) {
                let fliptempl = WebMolKit.CoordUtil.mirrorImage(this.guidetempl.clone());
                for (let n = 0; n < this.guideidx.length; n++) {
                    if (new Date().getTime() - timeStart > this.timeLimit * 1000)
                        break;
                    this.composeGuidedOne(newperms, oldmol, this.guidetempl, atom, this.guideidx[n]);
                    this.composeGuidedOne(newperms, oldmol, fliptempl, atom, this.guideidx[n]);
                }
            }
            if (!this.withGuideOnly) {
                let flipmol = newmol.clone();
                WebMolKit.CoordUtil.mirrorImage(flipmol);
                for (let n = 1; n <= newmol.numAtoms; n++) {
                    if (new Date().getTime() - timeStart > this.timeLimit * 1000)
                        break;
                    this.composeDirectOne(newperms, oldmol, newmol, atom, n);
                    this.composeDirectOne(newperms, oldmol, flipmol, atom, n);
                    this.composeBridge(newperms, oldmol, newmol, atom, n);
                    this.composeBridge(newperms, oldmol, flipmol, atom, n);
                }
            }
            this.affixRawPermutations(newperms);
        }
        permuteBond(a1, a2) {
            this.numAttach = 2;
            let timeStart = new Date().getTime();
            let oldmol = this.mol.clone(), newmol = this.templ.clone();
            let newperms = [];
            if (this.guidetempl != null) {
                let fliptempl = WebMolKit.CoordUtil.mirrorImage(this.guidetempl.clone());
                for (let i = 0; i < this.guideidx.length; i++) {
                    if (new Date().getTime() - timeStart > this.timeLimit * 1000)
                        break;
                    let g1 = this.guideidx[i];
                    let adj = this.guidetempl.atomAdjList(g1);
                    for (let j = 0; j < adj.length; j++) {
                        let g2 = adj[j];
                        this.composeGuidedTwo(newperms, oldmol, this.guidetempl, a1, a2, g1, g2, true);
                        this.composeGuidedTwo(newperms, oldmol, this.guidetempl, a2, a1, g1, g2, true);
                        this.composeGuidedTwo(newperms, oldmol, fliptempl, a1, a2, g1, g2, true);
                        this.composeGuidedTwo(newperms, oldmol, fliptempl, a2, a1, g1, g2, true);
                        this.composeGuidedTwo(newperms, oldmol, this.guidetempl, a1, a2, g1, g2, false);
                        this.composeGuidedTwo(newperms, oldmol, this.guidetempl, a2, a1, g1, g2, false);
                        this.composeGuidedTwo(newperms, oldmol, fliptempl, a1, a2, g1, g2, false);
                        this.composeGuidedTwo(newperms, oldmol, fliptempl, a2, a1, g1, g2, false);
                    }
                }
            }
            if (!this.withGuideOnly) {
                let flipmol = newmol.clone();
                WebMolKit.CoordUtil.mirrorImage(flipmol);
                for (let n = 1; n <= newmol.numBonds; n++) {
                    if (new Date().getTime() - timeStart > this.timeLimit * 1000)
                        break;
                    let nfr = newmol.bondFrom(n), nto = newmol.bondTo(n);
                    this.composeDirectTwo(newperms, oldmol, newmol, a1, a2, nfr, nto);
                    this.composeDirectTwo(newperms, oldmol, flipmol, a1, a2, nfr, nto);
                    this.composeDirectTwo(newperms, oldmol, newmol, a1, a2, nto, nfr);
                    this.composeDirectTwo(newperms, oldmol, flipmol, a1, a2, nto, nfr);
                }
            }
            this.affixRawPermutations(newperms);
        }
        permuteMulti(atoms) {
            this.numAttach = atoms.length;
            let timeStart = new Date().getTime();
            let oldmol = this.mol.clone(), newmol = this.templ.clone();
            let newperms = [];
            if (this.guidetempl != null) {
                let fliptempl = WebMolKit.CoordUtil.mirrorImage(this.guidetempl.clone());
                if (this.guideidx.length == atoms.length) {
                    this.composeGuidedMulti(newperms, oldmol, this.guidetempl, atoms, this.guideidx, true);
                    this.composeGuidedMulti(newperms, oldmol, fliptempl, atoms, this.guideidx, true);
                }
                if (this.guideadj.length == atoms.length) {
                    this.composeGuidedMulti(newperms, oldmol, this.guidetempl, atoms, this.guideadj, false);
                    this.composeGuidedMulti(newperms, oldmol, fliptempl, atoms, this.guideadj, false);
                }
            }
            if (!this.withGuideOnly) {
                let flipmol = newmol.clone();
                WebMolKit.CoordUtil.mirrorImage(flipmol);
                for (let n = 1; n <= newmol.numAtoms; n++) {
                    if (new Date().getTime() - timeStart > this.timeLimit * 1000)
                        break;
                    this.composeDirectMulti(newperms, oldmol, newmol, atoms, n);
                    this.composeDirectMulti(newperms, oldmol, flipmol, atoms, n);
                }
            }
            this.affixRawPermutations(newperms);
        }
        huntForGuides() {
            this.guideidx = [];
            this.guideadj = [];
            for (let n = 1; n <= this.templ.numAtoms; n++)
                if (this.templ.atomElement(n) == 'X' && this.templ.atomAdjCount(n) > 0) {
                    this.guideidx.push(n);
                    let adj = this.templ.atomAdjList(n);
                    for (let i = 0; i < adj.length; i++)
                        if (this.guideadj.indexOf(adj[i]) < 0)
                            this.guideadj.push(adj[i]);
                }
            if (this.guideidx.length > 0) {
                this.guidetempl = this.templ.clone();
                for (let n = this.guideidx.length - 1; n >= 0; n--)
                    this.templ.deleteAtomAndBonds(this.guideidx[n]);
            }
        }
        composeDirectOne(list, oldmol, newmol, o1, n1) {
            let otheta = WebMolKit.SketchUtil.primeDirections(oldmol, o1);
            let ntheta = WebMolKit.SketchUtil.primeDirections(newmol, n1);
            let ocurrent = WebMolKit.CoordUtil.atomBondAngles(oldmol, o1);
            let ncurrent = WebMolKit.CoordUtil.atomBondAngles(newmol, n1);
            let theta1 = [], theta2 = [], scoreMod = [];
            for (let i = 0; i < ocurrent.length; i++)
                for (let j = 0; j < ntheta.length; j++) {
                    theta1.push(ocurrent[i]);
                    theta2.push(ntheta[j]);
                    scoreMod.push(-51);
                }
            for (let i = 0; i < otheta.length; i++)
                for (let j = 0; j < ncurrent.length; j++) {
                    theta1.push(otheta[i]);
                    theta2.push(ncurrent[j]);
                    scoreMod.push(0);
                }
            for (let i = 0; i < otheta.length; i++)
                for (let j = 0; j < ntheta.length; j++) {
                    theta1.push(otheta[i]);
                    theta2.push(ntheta[j]);
                    scoreMod.push(0);
                }
            let bfs = WebMolKit.Graph.fromMolecule(newmol).calculateBFS(0);
            let ox = oldmol.atomX(o1), oy = oldmol.atomY(o1), nx = newmol.atomX(n1), ny = newmol.atomY(n1);
            for (let n = 0; n < theta1.length; n++) {
                let dth = WebMolKit.angleDiff(theta1[n], theta2[n]);
                let frag = newmol.clone();
                WebMolKit.CoordUtil.translateMolecule(frag, ox - nx, oy - ny);
                WebMolKit.CoordUtil.rotateMolecule(frag, dth, ox, oy);
                let pmol = oldmol.clone();
                let osz = pmol.numAtoms;
                pmol.append(frag);
                let srcidx = this.sourceIndex(pmol, oldmol);
                WebMolKit.SketchUtil.mergeFragmentsMask(pmol, this.asMask(srcidx));
                if (pmol.numAtoms == osz)
                    continue;
                let p = new FusionPermutation();
                p.mol = pmol;
                p.display = frag;
                p.srcidx = srcidx;
                p.molidx = [o1];
                p.temidx = [n1];
                p.attdist = bfs[n1 - 1];
                p.guided = false;
                p.scoreModifier = scoreMod[n];
                this.removeExtraGuides(p, oldmol);
                list.push(p);
            }
        }
        composeDirectTwo(list, oldmol, newmol, o1, o2, n1, n2) {
            let oth = Math.atan2(oldmol.atomY(o2) - oldmol.atomY(o1), oldmol.atomX(o2) - oldmol.atomX(o1));
            let nth = Math.atan2(newmol.atomY(n2) - newmol.atomY(n1), newmol.atomX(n2) - newmol.atomX(n1));
            let cx = 0.5 * (oldmol.atomX(o1) + oldmol.atomX(o2)), cy = 0.5 * (oldmol.atomY(o1) + oldmol.atomY(o2));
            let frag = newmol.clone();
            WebMolKit.CoordUtil.translateMolecule(frag, cx - 0.5 * (newmol.atomX(n1) + newmol.atomX(n2)), cy - 0.5 * (newmol.atomY(n1) + newmol.atomY(n2)));
            WebMolKit.CoordUtil.rotateMolecule(frag, oth - nth, cx, cy);
            frag.setAtomPos(n1, oldmol.atomX(o1), oldmol.atomY(o1));
            frag.setAtomPos(n2, oldmol.atomX(o2), oldmol.atomY(o2));
            let pmol = oldmol.clone();
            let osz = pmol.numAtoms;
            pmol.append(frag);
            let srcidx = this.sourceIndex(pmol, oldmol);
            WebMolKit.SketchUtil.mergeFragmentsMask(pmol, this.asMask(srcidx));
            if (pmol.numAtoms == osz)
                return;
            let bfs = WebMolKit.Graph.fromMolecule(newmol).calculateBFS(0);
            let p = new FusionPermutation();
            p.mol = pmol;
            p.display = frag;
            p.srcidx = srcidx;
            p.molidx = [o1, o2];
            p.temidx = [n1, n2];
            p.attdist = Math.min(bfs[n1 - 1], bfs[n2 - 1]);
            p.guided = false;
            this.removeExtraGuides(p, oldmol);
            list.push(p);
        }
        composeDirectMulti(list, oldmol, newmol, oidx, n1) {
            let frag = newmol.clone();
            let x0 = oldmol.atomX(oidx[0]), y0 = oldmol.atomY(oidx[0]);
            WebMolKit.CoordUtil.translateMolecule(frag, x0 - frag.atomX(n1), y0 - frag.atomY(n1));
            let ox = oldmol.atomX(oidx[1]) - x0, oy = oldmol.atomY(oidx[1]) - y0;
            let otheta = Math.atan2(oy, ox), orad = WebMolKit.norm_xy(ox, oy);
            let bfs = WebMolKit.Graph.fromMolecule(newmol).calculateBFS(1);
            let nidx = [];
            for (let n2 = 1; n2 <= frag.numAtoms; n2++)
                if (n1 != n2) {
                    let nx = frag.atomX(n2) - frag.atomX(n1), ny = frag.atomY(n2) - frag.atomY(n1), nrad = WebMolKit.norm_xy(nx, ny);
                    if (Math.abs(nrad - orad) > 0.1)
                        continue;
                    let ntheta = Math.atan2(ny, nx);
                    WebMolKit.CoordUtil.rotateMolecule(frag, otheta - ntheta, x0, y0);
                    nidx = [n1, n2];
                    for (let i = 2; i < oidx.length; i++) {
                        let hit = false;
                        for (let j = 1; j <= frag.numAtoms; j++)
                            if (nidx.indexOf(j) < 0)
                                if (WebMolKit.norm_xy(oldmol.atomX(oidx[i]) - frag.atomX(j), oldmol.atomY(oidx[i]) - frag.atomY(j)) < 0.1 * 0.1) {
                                    hit = true;
                                    nidx.push(j);
                                    break;
                                }
                        if (!hit)
                            break;
                    }
                    if (nidx.length < oidx.length)
                        continue;
                    let lowbfs = bfs.length;
                    for (let n = 0; n < nidx.length; n++)
                        lowbfs = Math.min(lowbfs, bfs[nidx[n] - 1]);
                    let dx = 0, dy = 0;
                    for (let n = 0; n < oidx.length; n++) {
                        dx += oldmol.atomX(oidx[n]) - frag.atomX(nidx[n]);
                        dy += oldmol.atomY(oidx[n]) - frag.atomY(nidx[n]);
                    }
                    let invsz = 1.0 / oidx.length;
                    dx *= invsz;
                    dy *= invsz;
                    WebMolKit.CoordUtil.translateMolecule(frag, dx, dy);
                    let pmol = oldmol.clone();
                    let osz = pmol.numAtoms;
                    pmol.append(frag);
                    let srcidx = this.sourceIndex(pmol, oldmol);
                    for (let n = 0; n < nidx.length; n++) {
                        let x = pmol.atomX(oidx[n]), y = pmol.atomY(oidx[n]);
                        pmol.setAtomPos(osz + nidx[n], x, y);
                    }
                    WebMolKit.SketchUtil.mergeFragmentsMask(pmol, this.asMask(srcidx));
                    if (pmol.numAtoms == osz)
                        continue;
                    let p = new FusionPermutation();
                    p.mol = pmol;
                    p.display = frag.clone();
                    p.srcidx = srcidx;
                    p.molidx = oidx.slice(0);
                    p.temidx = nidx.slice(0);
                    p.attdist = Math.min(bfs[n1 - 1], bfs[n2 - 1]);
                    p.guided = false;
                    this.removeExtraGuides(p, oldmol);
                    list.push(p);
                }
        }
        composeBridge(list, oldmol, newmol, o1, n1) {
            let busy1 = oldmol.atomRingBlock(o1) != 0 || oldmol.atomAdjCount(o1) >= 3;
            let busy2 = newmol.atomRingBlock(n1) != 0 || newmol.atomAdjCount(n1) >= 3;
            if (!busy1 || !busy2)
                return;
            let otheta = WebMolKit.SketchUtil.primeDirections(oldmol, o1);
            let ntheta = WebMolKit.SketchUtil.primeDirections(newmol, n1);
            let bfs = WebMolKit.Graph.fromMolecule(newmol).calculateBFS(0);
            for (let i = 0; i < otheta.length; i++)
                for (let j = 0; j < ntheta.length; j++) {
                    let ox = oldmol.atomX(o1), oy = oldmol.atomY(o1), nx = newmol.atomX(n1), ny = newmol.atomY(n1);
                    let dx = WebMolKit.Molecule.IDEALBOND * Math.cos(otheta[i]), dy = WebMolKit.Molecule.IDEALBOND * Math.sin(otheta[i]);
                    let dth = WebMolKit.angleDiff(otheta[i], Math.PI + ntheta[j]);
                    let frag = newmol.clone();
                    WebMolKit.CoordUtil.translateMolecule(frag, ox - nx + dx, oy - ny + dy);
                    WebMolKit.CoordUtil.rotateMolecule(frag, dth, ox + dx, oy + dy);
                    let pmol = oldmol.clone();
                    let att = pmol.numAtoms + n1, osz = pmol.numAtoms;
                    pmol.append(frag);
                    let srcidx = this.sourceIndex(pmol, oldmol);
                    pmol.addBond(o1, att, 1);
                    att = frag.addAtom('C', ox, oy);
                    frag.addBond(n1, att, 1);
                    WebMolKit.SketchUtil.mergeFragmentsMask(pmol, this.asMask(srcidx));
                    if (pmol.numAtoms == osz)
                        continue;
                    let p = new FusionPermutation();
                    p.mol = pmol;
                    p.display = frag;
                    p.srcidx = srcidx;
                    p.molidx = [o1];
                    p.temidx = [att];
                    p.attdist = bfs[n1 - 1];
                    p.bridged = true;
                    p.guided = false;
                    this.removeExtraGuides(p, oldmol);
                    list.push(p);
                }
        }
        composeGuidedOne(list, oldmol, newmol, oidx, gidx) {
            if (newmol.atomAdjCount(gidx) == 0)
                return;
            let otheta = WebMolKit.SketchUtil.primeDirections(oldmol, oidx);
            if (newmol.atomAdjCount(gidx) > 1 && oldmol.atomAdjCount(oidx) > 0) {
                let ox = 0, oy = 0;
                let adj = oldmol.atomAdjList(oidx);
                for (let n = 0; n < adj.length; n++) {
                    ox += oldmol.atomX(adj[n]) - oldmol.atomX(oidx);
                    oy += oldmol.atomY(adj[n]) - oldmol.atomY(oidx);
                }
                let ang = Math.atan2(oy, ox);
                let unique = true;
                for (let n = 0; n < otheta.length; n++)
                    if (Math.abs(WebMolKit.angleDiff(ang, otheta[n])) < 3 * WebMolKit.RADDEG) {
                        unique = false;
                        break;
                    }
                if (unique)
                    otheta.push(ang);
            }
            let gx = newmol.atomX(gidx), gy = newmol.atomY(gidx);
            let dx = 0, dy = 0;
            let adj = newmol.atomAdjList(gidx);
            for (let n = 0; n < adj.length; n++) {
                dx += newmol.atomX(adj[n]) - gx;
                dy += newmol.atomY(adj[n]) - gy;
            }
            dx /= adj.length;
            dy /= adj.length;
            let ntheta = Math.atan2(dy, dx);
            let homoPenalty = 0;
            if (adj.length == 1) {
                let oel = oldmol.atomElement(oidx), nel = newmol.atomElement(adj[0]);
                if (oel != 'C' && oel == nel)
                    homoPenalty = 1;
            }
            for (let n = 0; n < otheta.length; n++) {
                let frag = newmol.clone();
                if (this.guideidx.length == 2) {
                    for (let i = 1; i <= frag.numAtoms; i++)
                        if (i != gidx && frag.atomElement(i) == 'X') {
                            frag.setAtomElement(i, TemplateFusion.RESERVED_GUIDESYMBOL);
                            break;
                        }
                }
                WebMolKit.CoordUtil.rotateMolecule(frag, otheta[n] - ntheta, gx, gy);
                WebMolKit.CoordUtil.translateMolecule(frag, oldmol.atomX(oidx) - gx, oldmol.atomY(oidx) - gy);
                let pmol = oldmol.clone();
                let osz = pmol.numAtoms;
                pmol.append(frag);
                let srcidx = this.sourceIndex(pmol, oldmol);
                WebMolKit.SketchUtil.mergeFragmentsMask(pmol, this.asMask(srcidx));
                if (pmol.numAtoms == osz)
                    continue;
                let sel = 0;
                for (let i = 1; i <= pmol.numAtoms; i++)
                    if (pmol.atomElement(i) == TemplateFusion.RESERVED_GUIDESYMBOL) {
                        let padj = pmol.atomAdjList(i);
                        if (padj.length == 1) {
                            sel = padj[0];
                            if (sel > i)
                                sel--;
                        }
                        pmol.deleteAtomAndBonds(i);
                        srcidx.splice(i - 1, 1);
                        break;
                    }
                let p = new FusionPermutation();
                p.mol = pmol;
                p.display = frag;
                p.srcidx = srcidx;
                p.molidx = [oidx];
                p.temidx = [gidx];
                p.attdist = 0;
                p.guided = true;
                p.scoreModifier = homoPenalty;
                p.chainSelect = sel;
                this.removeExtraGuides(p, oldmol);
                list.push(p);
            }
        }
        composeGuidedTwo(list, oldmol, newmol, o1, o2, gidx, nidx, snapToGuide) {
            let ox = oldmol.atomX(o1), oy = oldmol.atomY(o1);
            let gx = newmol.atomX(gidx), gy = newmol.atomY(gidx);
            let nx = newmol.atomX(nidx), ny = newmol.atomY(nidx);
            let otheta = Math.atan2(oldmol.atomY(o2) - oy, oldmol.atomX(o2) - ox);
            let gtheta = Math.atan2(ny - gy, nx - gx);
            let isGuideOnTerminal = oldmol.atomAdjCount(o1) == 1;
            let pmol = oldmol.clone(), frag = newmol.clone();
            WebMolKit.CoordUtil.rotateMolecule(frag, otheta - gtheta, gx, gy);
            if (snapToGuide) {
                WebMolKit.CoordUtil.translateMolecule(frag, ox - gx, oy - gy);
                pmol.setAtomPos(o2, frag.atomX(nidx), frag.atomY(nidx));
            }
            else {
                WebMolKit.CoordUtil.translateMolecule(frag, oldmol.atomX(o2) - frag.atomX(nidx), oldmol.atomY(o2) - frag.atomY(nidx));
                frag.setAtomPos(gidx, ox, oy);
            }
            let osz = pmol.numAtoms;
            pmol.append(frag);
            let srcidx = this.sourceIndex(pmol, oldmol);
            WebMolKit.SketchUtil.mergeFragmentsMask(pmol, this.asMask(srcidx));
            if (pmol.numAtoms == osz)
                return;
            let p = new FusionPermutation();
            p.mol = pmol;
            p.display = frag;
            p.srcidx = srcidx;
            p.molidx = [o1, o2];
            p.temidx = [gidx, nidx];
            p.attdist = isGuideOnTerminal ? 1 : 0;
            p.guided = true;
            this.removeExtraGuides(p, oldmol);
            list.push(p);
        }
        composeGuidedMulti(list, oldmol, newmol, oidx, gidx, nudgenew) {
            let cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0;
            for (let n = 0; n < oidx.length; n++) {
                cx1 += oldmol.atomX(oidx[n]);
                cy1 += oldmol.atomY(oidx[n]);
            }
            for (let n = 0; n < gidx.length; n++) {
                cx2 += newmol.atomX(gidx[n]);
                cy2 += newmol.atomY(gidx[n]);
            }
            cx1 /= oidx.length;
            cy1 /= oidx.length;
            cx2 /= gidx.length;
            cy2 /= gidx.length;
            let osz = oldmol.numAtoms;
            for (let i = 0; i < oidx.length; i++)
                for (let j = 0; j < gidx.length; j++) {
                    let pmol = oldmol.clone(), frag = newmol.clone();
                    let th1 = Math.atan2(pmol.atomY(oidx[i]) - cy1, pmol.atomX(oidx[i]) - cx1);
                    let th2 = Math.atan2(frag.atomY(gidx[j]) - cy2, frag.atomX(gidx[j]) - cx2);
                    WebMolKit.CoordUtil.rotateMolecule(frag, th1 - th2, cx2, cy2);
                    WebMolKit.CoordUtil.translateMolecule(frag, cx1 - cx2, cy1 - cy2);
                    pmol.append(frag);
                    let srcidx = this.sourceIndex(pmol, oldmol);
                    let midx = WebMolKit.Vec.numberArray(0, gidx.length), tidx = gidx.slice(0);
                    WebMolKit.Vec.sort(tidx);
                    let mask = WebMolKit.Vec.booleanArray(false, osz);
                    for (let g = tidx.length - 1; g >= 0; g--) {
                        let gatom = tidx[g] + osz;
                        let closest = 0, closeDSQ = 0;
                        for (let n = 0; n < oidx.length; n++)
                            if (!mask[oidx[n] - 1]) {
                                let dx = pmol.atomX(oidx[n]) - pmol.atomX(gatom), dy = pmol.atomY(oidx[n]) - pmol.atomY(gatom);
                                let dsq = WebMolKit.norm_xy(dx, dy);
                                if (closest == 0 || dsq < closeDSQ) {
                                    closest = oidx[n];
                                    closeDSQ = dsq;
                                }
                            }
                        if (!nudgenew) {
                            let dsq = WebMolKit.norm_xy(pmol.atomX(gatom) - pmol.atomX(closest), pmol.atomY(gatom) - pmol.atomY(closest));
                            if (dsq > 0.1 * 0.1) {
                                let num = frag.addAtom('C', pmol.atomX(closest), pmol.atomY(closest));
                                frag.addBond(num, tidx[g], 0);
                            }
                            pmol.setAtomPos(closest, pmol.atomX(gatom), pmol.atomY(gatom));
                        }
                        midx[g] = closest;
                        mask[closest - 1] = true;
                        let adj = pmol.atomAdjList(gatom);
                        for (let n = 0; n < adj.length; n++) {
                            let b = pmol.findBond(gatom, adj[n]);
                            pmol.addBond(closest, adj[n], pmol.bondOrder(b), pmol.bondType(b));
                        }
                        pmol.deleteAtomAndBonds(gatom);
                        srcidx.splice(gatom - 1, 1);
                        frag.setAtomPos(tidx[g], pmol.atomX(closest), pmol.atomY(closest));
                    }
                    for (let n = pmol.numAtoms; n > osz; n--)
                        if (pmol.atomElement(n) == 'X') {
                            pmol.deleteAtomAndBonds(n);
                            srcidx.splice(n - 1, 1);
                            for (let k = 0; k < tidx.length; k++)
                                if (n < tidx[k])
                                    tidx[k]--;
                        }
                    for (let n = frag.numAtoms; n >= 1; n--)
                        if (frag.atomElement(n) == 'X') {
                            frag.setAtomElement(n, 'C');
                        }
                    let p = new FusionPermutation();
                    p.mol = pmol;
                    p.display = frag;
                    p.srcidx = srcidx;
                    p.molidx = midx;
                    p.temidx = tidx;
                    p.attdist = 0;
                    p.guided = true;
                    this.removeExtraGuides(p, oldmol);
                    list.push(p);
                }
        }
        affixRawPermutations(list) {
            let npsz = list.length;
            if (npsz == 0)
                return;
            let umask = WebMolKit.Vec.booleanArray(true, npsz);
            for (let i = 0; i < npsz - 1; i++)
                if (umask[i]) {
                    let p1 = list[i];
                    for (let j = i + 1; j < npsz; j++)
                        if (umask[j]) {
                            let p2 = list[j];
                            if (WebMolKit.CoordUtil.sketchEquivalent(p1.mol, p2.mol)) {
                                if (p1.scoreModifier + p1.attdist > p2.scoreModifier + p2.attdist) {
                                    list[i] = p2;
                                    list[j] = p1;
                                }
                                umask[j] = false;
                            }
                        }
                }
            let score = WebMolKit.Vec.numberArray(0, npsz);
            let numKeep = 0;
            for (let n = 0; n < npsz; n++) {
                if (umask[n]) {
                    score[n] = this.scorePermutation(list[n]);
                    if (score[n] < 1000)
                        numKeep++;
                }
                else
                    score[n] = 0;
            }
            if (numKeep > 0)
                for (let n = 0; n < npsz; n++)
                    if (umask[n] && score[n] >= 1000)
                        umask[n] = false;
            let uscore = [], uidx = [];
            for (let n = 0; n < npsz; n++)
                if (umask[n]) {
                    uscore.push(score[n]);
                    uidx.push(n);
                }
            let sidx = WebMolKit.Vec.idxSort(uscore);
            for (let n = 0; n < sidx.length; n++) {
                let p = list[uidx[sidx[n]]];
                if (p.guided) {
                    this.perms.push(p);
                }
            }
            for (let n = 0; n < sidx.length; n++) {
                let p = list[uidx[sidx[n]]];
                if (!p.guided) {
                    this.perms.push(p);
                }
            }
        }
        removeExtraGuides(perm, oldmol) {
            WebMolKit.MolUtil.removeDuplicateBonds(perm.mol);
            for (let n = perm.temidx.length - 1; n >= 0; n--) {
                let el = perm.display.atomElement(perm.temidx[n]);
                if (el != 'X' && el != TemplateFusion.RESERVED_GUIDESYMBOL)
                    continue;
                perm.molidx.splice(n, 1);
                perm.temidx.splice(n, 1);
            }
            for (let n = perm.display.numAtoms; n >= 1; n--) {
                let el = perm.display.atomElement(n);
                if (el != 'X' && el != TemplateFusion.RESERVED_GUIDESYMBOL)
                    continue;
                let a = WebMolKit.CoordUtil.atomAtPoint(oldmol, perm.display.atomX(n), perm.display.atomY(n));
                if (a > 0)
                    perm.display.setAtomElement(n, 'C');
                else {
                    perm.display.deleteAtomAndBonds(n);
                    for (let i = 0; i < perm.temidx.length; i++)
                        if (perm.temidx[i] > n)
                            perm.temidx[i]--;
                }
            }
        }
        scorePermutation(perm) {
            let mol = this.mol, tmol = perm.display, tunion = perm.mol;
            let score = 0.2 * perm.attdist + perm.scoreModifier;
            score += WebMolKit.CoordUtil.congestionMolecule(tunion, 1e-3);
            score -= tunion.numAtoms;
            let sz1 = mol.numAtoms, sz2 = tmol.numAtoms;
            let mx1 = [], my1 = [], mx2 = [], my2 = [];
            for (let n = 0; n < sz1; n++) {
                mx1.push(mol.atomX(n + 1));
                my1.push(mol.atomY(n + 1));
            }
            for (let n = 0; n < sz2; n++) {
                mx2.push(tmol.atomX(n + 1));
                my2.push(tmol.atomY(n + 1));
            }
            for (let i = 0; i < sz1; i++)
                for (let j = 0; j < sz2; j++) {
                    if (WebMolKit.norm_xy(mx1[i] - mx2[j], my1[i] - my2[j]) > WebMolKit.CoordUtil.OVERLAP_THRESHOLD_SQ)
                        continue;
                    let contained = false;
                    for (let k = 0; k < perm.molidx.length; k++)
                        if (perm.molidx[k] == i + 1 && perm.temidx[k] == j + 1) {
                            contained = true;
                            break;
                        }
                    if (contained)
                        continue;
                    score += 100;
                }
            if (!perm.guided)
                for (let n = 0; n < perm.molidx.length; n++) {
                    let el = mol.atomElement(perm.molidx[n]);
                    if (el == 'C' || el == 'O' || el == 'S' || el == 'N' || el == 'P')
                        continue;
                    let adj1 = mol.atomAdjList(perm.molidx[n]), adj2 = tmol.atomAdjList(perm.temidx[n]);
                    if (adj1.length + adj2.length >= 4)
                        continue;
                    for (let i = 0; i < adj1.length; i++)
                        for (let j = 0; j < adj2.length; j++) {
                            let ai = adj1[i], aj = adj2[j];
                            let bo1 = mol.bondOrder(mol.findBond(perm.molidx[n], ai));
                            let bo2 = tmol.bondOrder(tmol.findBond(perm.temidx[n], aj));
                            let wantTheta = 0;
                            if ((bo1 == 1 && bo2 == 1) || (bo1 == 1 && bo2 == 2) || (bo1 == 2 && bo2 == 1))
                                wantTheta = 120;
                            else if ((bo1 == 2 && bo2 == 2) || (bo1 == 1 && bo2 == 3) || (bo1 == 3 && bo2 == 1))
                                wantTheta = 180;
                            else
                                continue;
                            let dx1 = mx1[ai - 1] - mx1[perm.molidx[n] - 1];
                            let dy1 = my1[ai - 1] - my1[perm.molidx[n] - 1];
                            let dx2 = mx2[aj - 1] - mx2[perm.temidx[n] - 1];
                            let dy2 = my2[aj - 1] - my2[perm.temidx[n] - 1];
                            let theta = Math.abs(WebMolKit.angleDiff(Math.atan2(dy1, dx1), Math.atan2(dy2, dx2))) * WebMolKit.RADDEG;
                            if (Math.abs(theta - wantTheta) > 5)
                                score += 50;
                        }
                }
            for (let n = 1; n <= tunion.numAtoms; n++)
                if (tunion.atomElement(n) == 'C' || tunion.atomElement(n) == 'N') {
                    let adjb = tunion.atomAdjBonds(n);
                    let totalBO = 0;
                    for (let i = 0; i < adjb.length; i++) {
                        let bo = tunion.bondOrder(adjb[i]);
                        totalBO += bo;
                        if (bo == 0) {
                            totalBO = 0;
                            break;
                        }
                    }
                    if (totalBO > 4)
                        score += 1000;
                }
            if (perm.molidx.length >= 2) {
                let mmask = WebMolKit.Vec.booleanArray(false, sz1);
                for (let n = 0; n < perm.molidx.length; n++)
                    mmask[perm.molidx[n] - 1] = true;
                for (let n = 1; n <= mol.numBonds; n++) {
                    let bfr = mol.bondFrom(n), bto = mol.bondTo(n);
                    if (!mmask[bfr - 1] || !mmask[bto - 1])
                        continue;
                    let tfr = perm.molidx.indexOf(bfr), tto = perm.molidx.indexOf(bto);
                    let tn = tmol.findBond(perm.temidx[tfr], perm.temidx[tto]);
                    if (tn == 0)
                        continue;
                    if (mol.bondOrder(n) != tmol.bondOrder(tn))
                        score += 1;
                }
            }
            return score;
        }
        sourceIndex(xmol, wmol) {
            let idx = WebMolKit.Vec.numberArray(0, xmol.numAtoms);
            for (let n = wmol.numAtoms; n >= 1; n--)
                idx[n - 1] = n;
            return idx;
        }
        asMask(imask) {
            let ret = WebMolKit.Vec.booleanArray(false, imask.length);
            for (let n = 0; n < imask.length; n++)
                ret[n] = imask[n] != 0;
            return ret;
        }
    }
    TemplateFusion.RESERVED_GUIDESYMBOL = 'XXX';
    WebMolKit.TemplateFusion = TemplateFusion;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let ToolBankItem;
    (function (ToolBankItem) {
        ToolBankItem["Arrow"] = "arrow";
        ToolBankItem["Rotate"] = "rotate";
        ToolBankItem["Pan"] = "pan";
        ToolBankItem["Drag"] = "drag";
        ToolBankItem["Erasor"] = "erasor";
        ToolBankItem["BondOrder0"] = "bond:Order0";
        ToolBankItem["BondOrder1"] = "bond:Order1";
        ToolBankItem["BondOrder2"] = "bond:Order2";
        ToolBankItem["BondOrder3"] = "bond:Order3";
        ToolBankItem["BondUnknown"] = "bond:Unknown";
        ToolBankItem["BondInclined"] = "bond:Inclined";
        ToolBankItem["BondDeclined"] = "bond:Declined";
        ToolBankItem["RingAliph"] = "ringAliph";
        ToolBankItem["RingArom"] = "ringArom";
        ToolBankItem["AtomPlus"] = "atomPlus";
        ToolBankItem["AtomMinus"] = "atomMinus";
        ToolBankItem["BondPfx"] = "bond:";
        ToolBankItem["ElementPfx"] = "element:";
    })(ToolBankItem = WebMolKit.ToolBankItem || (WebMolKit.ToolBankItem = {}));
    const TOOLS_MAIN = [
        { 'id': ToolBankItem.Arrow, 'imageFN': 'ToolSelect', 'helpText': 'Selection tool.', 'mnemonic': 'Escape' },
        { 'id': ToolBankItem.Rotate, 'imageFN': 'ToolRotate', 'helpText': 'Rotate subject atoms.', 'mnemonic': '' },
        { 'id': ToolBankItem.Pan, 'imageFN': 'ToolPan', 'helpText': 'Pan the viewport around the screen.', 'mnemonic': '' },
        { 'id': ToolBankItem.Drag, 'imageFN': 'ToolDrag', 'helpText': 'Drag selected atoms to new positions.', 'mnemonic': '' },
        { 'id': ToolBankItem.Erasor, 'imageFN': 'ToolErasor', 'helpText': 'Delete atoms or bonds by selecting.', 'mnemonic': 'Delete' },
        { 'id': ToolBankItem.BondOrder0, 'imageFN': 'BondZero', 'helpText': 'Create or change a bond to zero order.', 'mnemonic': 'Shift+0', 'key': ')' },
        { 'id': ToolBankItem.BondOrder1, 'imageFN': 'BondOne', 'helpText': 'Create or change a bond to single.', 'mnemonic': 'Shift+1', 'key': '!' },
        { 'id': ToolBankItem.BondOrder2, 'imageFN': 'BondTwo', 'helpText': 'Create or change a bond to double.', 'mnemonic': 'Shift+2', 'key': '@' },
        { 'id': ToolBankItem.BondOrder3, 'imageFN': 'BondThree', 'helpText': 'Create or change a bond to triple.', 'mnemonic': 'Shift+3', 'key': '#' },
        { 'id': ToolBankItem.BondUnknown, 'imageFN': 'BondSquig', 'helpText': 'Create or change a bond to unknown stereochemistry.', 'mnemonic': 'Shift+4', 'key': '$' },
        { 'id': ToolBankItem.BondInclined, 'imageFN': 'BondUp', 'helpText': 'Create or change a bond to up-wedge.', 'mnemonic': 'Shift+5', 'key': '%' },
        { 'id': ToolBankItem.BondDeclined, 'imageFN': 'BondDown', 'helpText': 'Create or change a bond to down-wedge.', 'mnemonic': 'Shift+6', 'key': '^' },
        { 'id': ToolBankItem.RingAliph, 'imageFN': 'ToolRing', 'helpText': 'Create plain ring.', 'mnemonic': 'Shift+7', 'key': '&' },
        { 'id': ToolBankItem.RingArom, 'imageFN': 'ToolArom', 'helpText': 'Create aromatic ring.', 'mnemonic': 'Shift+8', 'key': '*' },
        { 'id': ToolBankItem.AtomPlus, 'imageFN': 'AtomPlus', 'helpText': 'Increase charge on atom.', 'mnemonic': '' },
        { 'id': ToolBankItem.AtomMinus, 'imageFN': 'AtomMinus', 'helpText': 'Decrease charge on atom.', 'mnemonic': '' },
        { 'id': ToolBankItem.ElementPfx + 'C', 'text': 'C', 'helpText': 'Change elements to Carbon.', 'mnemonic': '' },
        { 'id': ToolBankItem.ElementPfx + 'N', 'text': 'N', 'helpText': 'Change elements to Nitrogen.', 'mnemonic': '' },
        { 'id': ToolBankItem.ElementPfx + 'O', 'text': 'O', 'helpText': 'Change elements to Oxygen.', 'mnemonic': '' },
        { 'id': ToolBankItem.ElementPfx + 'S', 'text': 'S', 'helpText': 'Change elements to Sulfur.', 'mnemonic': '' },
        { 'id': ToolBankItem.ElementPfx + 'P', 'text': 'P', 'helpText': 'Change elements to Phosphorus.', 'mnemonic': '' },
        { 'id': ToolBankItem.ElementPfx + 'H', 'text': 'H', 'helpText': 'Change elements to Hydrogen.', 'mnemonic': '' },
        { 'id': ToolBankItem.ElementPfx + 'F', 'text': 'F', 'helpText': 'Change elements to Fluorine.', 'mnemonic': '' },
        { 'id': ToolBankItem.ElementPfx + 'Cl', 'text': 'Cl', 'helpText': 'Change elements to Chlorine.', 'mnemonic': '' },
        { 'id': ToolBankItem.ElementPfx + 'Br', 'text': 'Br', 'helpText': 'Change elements to Bromine.', 'mnemonic': '' },
        { 'id': ToolBankItem.ElementPfx + 'A', 'text': 'A', 'helpText': 'Pick other element.', 'mnemonic': '' }
    ];
    class ToolBank extends WebMolKit.ButtonBank {
        constructor(owner) {
            super();
            this.owner = owner;
        }
        update() {
            for (let btn of TOOLS_MAIN)
                this.buttons.push(btn);
            this.buttonView.setSelectedButton('arrow');
        }
        hitButton(id) {
            this.buttonView.setSelectedButton(id);
        }
        claimKey(event) {
            for (let item of TOOLS_MAIN) {
                if (WebMolKit.ButtonBank.matchKey(event, item.mnemonic, item.key)) {
                    this.hitButton(item.id);
                    return true;
                }
            }
            return false;
        }
    }
    WebMolKit.ToolBank = ToolBank;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let ButtonViewPosition;
    (function (ButtonViewPosition) {
        ButtonViewPosition[ButtonViewPosition["Left"] = 0] = "Left";
        ButtonViewPosition[ButtonViewPosition["Right"] = 1] = "Right";
        ButtonViewPosition[ButtonViewPosition["Top"] = 2] = "Top";
        ButtonViewPosition[ButtonViewPosition["Bottom"] = 3] = "Bottom";
        ButtonViewPosition[ButtonViewPosition["Centre"] = 4] = "Centre";
    })(ButtonViewPosition = WebMolKit.ButtonViewPosition || (WebMolKit.ButtonViewPosition = {}));
    class ButtonView extends WebMolKit.Widget {
        constructor(position, parentX, parentY, parentWidth, parentHeight) {
            super();
            this.position = position;
            this.parentX = parentX;
            this.parentY = parentY;
            this.parentWidth = parentWidth;
            this.parentHeight = parentHeight;
            this.idealSize = 50;
            this.width = 0;
            this.height = 0;
            this.selectedButton = null;
            this.highlightButton = null;
            this.maxButtonColumns = 0;
            this.maxButtonRows = 0;
            this.border = 0x808080;
            this.background = 0xFFFFFF;
            this.buttonColNorm1 = 0x47D5D2;
            this.buttonColNorm2 = 0x008FD1;
            this.buttonColActv1 = 0x30FF69;
            this.buttonColActv2 = 0x008650;
            this.buttonColSel1 = 0xFFFFFF;
            this.buttonColSel2 = 0xE0E0E0;
            this.canvas = null;
            this.stack = [];
            this.display = [];
            this.hasBigButtons = true;
            this.prefabImgSize = 44;
            this.gripHeight = 30;
            this.gripWidth = 50;
            this.isRaised = true;
            this.outPadding = 2;
            this.inPadding = 2;
            this.x = 0;
            this.y = 0;
            this.isMacLike = false;
            this.isMacLike = !!navigator.platform.match(/(Mac|iPhone|iPod|iPad)/i);
        }
        setParentSize(width, height) {
            this.parentWidth = width;
            this.parentHeight = height;
        }
        get topBank() {
            return this.stack.length > 0 ? this.stack[this.stack.length - 1] : null;
        }
        get stackSize() { return this.stack.length; }
        render(parent) {
            super.render(parent);
            this.contentDOM.css({ 'position': 'absolute', 'width': `${this.width}px`, 'height': `${this.height}px` });
            this.contentDOM.addClass('no_selection');
            this.layoutButtons();
            let canvasStyle = 'position: absolute; left: 0; top: 0;';
            canvasStyle += 'pointer-events: none;';
            this.canvas = WebMolKit.newElement(this.contentDOM.el, 'canvas', { 'width': this.width, 'height': this.height, 'style': canvasStyle });
            this.canvas.style.width = this.width + 'px';
            this.canvas.style.height = this.height + 'px';
            this.applyOffset();
            this.redraw();
            this.contentDOM.onClick((event) => this.mouseClick(event));
            this.contentDOM.onDblClick((event) => this.mouseDoubleClick(event));
            this.contentDOM.onMouseDown((event) => { event.preventDefault(); this.mouseDown(event); });
            this.contentDOM.onMouseUp((event) => this.mouseUp(event));
            this.contentDOM.onMouseOver((event) => this.mouseOver(event));
            this.contentDOM.onMouseLeave((event) => this.mouseOut(event));
            this.contentDOM.onMouseMove((event) => this.mouseMove(event));
        }
        pushBank(bank) {
            bank.buttonView = this;
            bank.isSubLevel = this.stack.length > 0;
            bank.init();
            this.stack.push(bank);
            if (this.canvas != null) {
                this.layoutButtons();
                this.replaceCanvas();
                this.applyOffset();
                this.redraw();
            }
        }
        popBank() {
            if (this.stack.length == 0)
                return;
            WebMolKit.Vec.last(this.stack).bankClosed();
            this.stack.length--;
            if (this.canvas != null) {
                this.layoutButtons();
                this.replaceCanvas();
                this.applyOffset();
                this.redraw();
            }
        }
        refreshBank() {
            if (this.canvas != null) {
                this.layoutButtons();
                this.replaceCanvas();
                this.applyOffset();
                this.redraw();
            }
        }
        getSelectedButton() {
            return this.selectedButton;
        }
        setSelectedButton(id) {
            if (id != this.selectedButton) {
                this.selectedButton = id;
                this.redraw();
            }
        }
        cycleSelected(dir) {
            let sorted = this.display.filter((s) => s.id != '*');
            sorted.sort((d1, d2) => (d1.y * 10000 + d1.x) - (d2.y * 10000 + d2.x));
            let idx = 0, sz = sorted.length;
            for (let n = 0; n < sz; n++)
                if (sorted[n].id == this.selectedButton) {
                    idx = n;
                    break;
                }
            this.selectedButton = sorted[(idx + dir + sz) % sz].id;
            this.redraw();
        }
        raiseBank() {
            if (this.isRaised)
                return;
            this.isRaised = true;
            if (this.contentDOM) {
                this.layoutButtons();
                this.replaceCanvas();
                this.applyOffset();
                this.redraw();
            }
        }
        lowerBank() {
            if (!this.isRaised)
                return;
            this.isRaised = false;
            if (this.contentDOM) {
                this.layoutButtons();
                this.replaceCanvas();
                this.applyOffset();
                this.redraw();
            }
        }
        getHasBigButtons() {
            return this.hasBigButtons;
        }
        setHasBigButtons(flag) {
            this.hasBigButtons = flag;
            this.prefabImgSize = flag ? 44 : 36;
            this.idealSize = flag ? 50 : 40;
        }
        withinOutline(x, y) {
            let w = this.width, h = this.height;
            if (x < 0 || x > w || y < 0 || y > h)
                return false;
            if (this.position == ButtonViewPosition.Centre || this.stack.length == 0)
                return true;
            if (this.position == ButtonViewPosition.Left) {
                let my = 0.5 * h - 1, gw = this.gripHeight, hg = 0.5 * this.gripWidth;
                return x < w - gw || (y > my - hg && y < my + hg);
            }
            else if (this.position == ButtonViewPosition.Right) {
                let my = 0.5 * h - 1, gw = this.gripHeight, hg = 0.5 * this.gripWidth;
                return x > gw || (y > my - hg && y < my + hg);
            }
            else if (this.position == ButtonViewPosition.Top) {
                let mx = 0.5 * w - 1, gh = this.gripHeight, hg = 0.5 * this.gripWidth;
                return y < h - gh || (x > mx - hg && x < mx + hg);
            }
            else if (this.position == ButtonViewPosition.Bottom) {
                let mx = 0.5 * w - 1, gh = this.gripHeight, hg = 0.5 * this.gripWidth;
                return y > gh || (x > mx - hg && x < mx + hg);
            }
            return true;
        }
        gripSize() {
            return this.gripHeight;
        }
        sizeForButtons(nbtn) {
            return this.idealSize * nbtn + this.inPadding * (nbtn - 1) + 2 * this.outPadding;
        }
        layoutButtons() {
            if (this.contentDOM == null)
                return;
            let outPadding = this.outPadding, inPadding = this.inPadding;
            this.removeDisplayButtons();
            if (this.stack.length == 0) {
                this.width = 10;
                this.height = 10;
                if (this.position == ButtonViewPosition.Left || this.position == ButtonViewPosition.Right)
                    this.height = this.parentHeight;
                else if (this.position == ButtonViewPosition.Top || this.position == ButtonViewPosition.Bottom)
                    this.width = this.parentWidth;
                return;
            }
            if (!this.isRaised) {
                if (this.position == ButtonViewPosition.Left || this.position == ButtonViewPosition.Right) {
                    this.width = this.gripHeight;
                    this.height = this.gripWidth + 2 * outPadding;
                }
                else if (this.position == ButtonViewPosition.Top || this.position == ButtonViewPosition.Bottom) {
                    this.width = this.gripWidth + 2 * outPadding;
                    this.height = this.gripHeight;
                }
                this.addGripButton();
                return;
            }
            let bank = this.stack[this.stack.length - 1];
            bank.buttons = [];
            bank.update();
            let popWidth = 0, popHeight = 0;
            if (this.stack.length == 1) { }
            else if (this.position == ButtonViewPosition.Left || this.position == ButtonViewPosition.Right)
                popHeight = this.gripHeight + inPadding;
            else if (this.position == ButtonViewPosition.Top || this.position == ButtonViewPosition.Bottom)
                popWidth = this.gripHeight + inPadding;
            let bestLayout = null, bestScore = null;
            if (this.position == ButtonViewPosition.Left || this.position == ButtonViewPosition.Right) {
                let maxSlotHeight = Math.floor((this.parentHeight - 2 * outPadding - inPadding) / (this.idealSize + inPadding));
                let minSlotHeight = Math.ceil(0.5 * maxSlotHeight);
                for (let i = maxSlotHeight; i >= minSlotHeight; i--) {
                    let slotWidth = Math.ceil(bank.buttons.length / i);
                    for (let j = slotWidth; j <= slotWidth + 1; j++) {
                        let layout = this.layoutMaxHeight(bank, i, j);
                        let score = this.scoreLayout(layout) + 1 * layout[0].length;
                        if (bestLayout == null || score < bestScore) {
                            bestLayout = layout;
                            bestScore = score;
                        }
                    }
                }
            }
            else if (this.position == ButtonViewPosition.Top || this.position == ButtonViewPosition.Bottom) {
                let maxSlotWidth = Math.floor((this.parentWidth - 2 * outPadding - inPadding - popWidth) / (this.idealSize + inPadding));
                let minSlotWidth = Math.ceil(0.5 * maxSlotWidth);
                for (let n = maxSlotWidth; n >= minSlotWidth; n--) {
                    let layout = this.layoutMaxWidth(bank, n);
                    let score = this.scoreLayout(layout) + 1 * layout.length;
                    if (bestLayout == null || score < bestScore) {
                        bestLayout = layout;
                        bestScore = score;
                    }
                }
            }
            else {
            }
            let ncols = bestLayout[0].length, nrows = bestLayout.length;
            this.width = 2 * outPadding + inPadding + (this.idealSize + inPadding) * ncols + popWidth;
            this.height = 2 * outPadding + inPadding + (this.idealSize + inPadding) * nrows + popHeight;
            if (this.position == ButtonViewPosition.Left || this.position == ButtonViewPosition.Right)
                this.width += this.gripHeight;
            else if (this.position == ButtonViewPosition.Top || this.position == ButtonViewPosition.Bottom)
                this.height += this.gripHeight;
            this.addGripButton();
            if (popWidth > 0 || popHeight > 0) {
                let d = {
                    'id': '!',
                    'x': outPadding + inPadding,
                    'y': outPadding + inPadding,
                    'width': popWidth - inPadding,
                    'height': popHeight - inPadding
                };
                if (this.position == ButtonViewPosition.Right)
                    d.x += this.gripHeight;
                else if (this.position == ButtonViewPosition.Bottom)
                    d.y += this.gripHeight;
                if (popWidth == 0)
                    d.width = ncols * this.idealSize + inPadding * (ncols - 1);
                if (popHeight == 0)
                    d.height = nrows * this.idealSize + inPadding * (nrows - 1);
                this.display.push(d);
            }
            for (let y = 0; y < nrows; y++)
                for (let x = 0; x < ncols; x++) {
                    for (let n = 0; n < bank.buttons.length; n++)
                        if (bestLayout[y][x] == bank.buttons[n].id) {
                            let b = bank.buttons[n], d = { 'id': b.id };
                            d.x = outPadding + inPadding + popWidth + (this.idealSize + inPadding) * x;
                            d.y = outPadding + inPadding + popHeight + (this.idealSize + inPadding) * y;
                            if (this.position == ButtonViewPosition.Right)
                                d.x += this.gripHeight;
                            else if (this.position == ButtonViewPosition.Bottom)
                                d.y += this.gripHeight;
                            d.width = this.idealSize;
                            d.height = this.idealSize;
                            this.display.push(d);
                        }
                }
        }
        addGripButton() {
            if (this.position == ButtonViewPosition.Centre)
                return;
            let d = { 'id': '*' }, spc = 3;
            if (this.position == ButtonViewPosition.Left) {
                d.width = this.gripHeight - spc;
                d.height = this.gripWidth - 2 * spc;
                d.x = this.width - d.width - spc - 1;
                d.y = 0.5 * (this.height - d.height);
            }
            else if (this.position == ButtonViewPosition.Right) {
                d.width = this.gripHeight - spc;
                d.height = this.gripWidth - 2 * spc;
                d.x = spc + 1;
                d.y = 0.5 * (this.height - d.height);
            }
            else if (this.position == ButtonViewPosition.Top) {
                d.width = this.gripWidth - 2 * spc;
                d.height = this.gripHeight - spc;
                d.x = 0.5 * (this.width - d.width);
                d.y = this.height - d.height - spc - 1;
            }
            else if (this.position == ButtonViewPosition.Bottom) {
                d.width = this.gripWidth - 2 * spc;
                d.height = this.gripHeight - spc;
                d.x = 0.5 * (this.width - d.width);
                d.y = spc + 1;
            }
            this.display.push(d);
        }
        replaceCanvas() {
            this.contentDOM.empty();
            for (let n = 0; n < this.display.length; n++) {
                this.display[n].imgDOM = null;
                this.display[n].helpSpan = null;
            }
            let canvasStyle = 'position: absolute; left: 0; top: 0;';
            canvasStyle += 'pointer-events: none;';
            this.canvas = WebMolKit.newElement(this.contentDOM.el, 'canvas', { 'width': this.width, 'height': this.height, 'style': canvasStyle });
        }
        removeDisplayButtons() {
            this.contentDOM.empty();
            this.display = [];
        }
        applyOffset() {
            let x, y;
            if (this.position == ButtonViewPosition.Left) {
                x = 0;
                y = 0.5 * (this.parentHeight - this.height);
            }
            else if (this.position == ButtonViewPosition.Right) {
                x = this.parentWidth - this.width;
                y = 0.5 * (this.parentHeight - this.height);
            }
            else if (this.position == ButtonViewPosition.Top) {
                x = 0.5 * (this.parentWidth - this.width);
                y = 0;
            }
            else if (this.position == ButtonViewPosition.Bottom) {
                x = 0.5 * (this.parentWidth - this.width);
                y = this.parentHeight - this.height;
            }
            else {
                x = 0.5 * (this.parentWidth - this.width);
                y = 0.5 * (this.parentHeight - this.height);
            }
            this.x = this.parentX + x;
            this.y = this.parentY + y;
            this.contentDOM.css({ 'position': 'absolute' });
            WebMolKit.setBoundaryPixels(this.contentDOM, this.x, this.y, this.width, this.height);
        }
        redraw() {
            if (!this.contentDOM || !this.canvas)
                return;
            let density = WebMolKit.pixelDensity();
            this.canvas.width = this.width * density;
            this.canvas.height = this.height * density;
            this.canvas.style.width = this.width + 'px';
            this.canvas.style.height = this.height + 'px';
            let ctx = this.canvas.getContext('2d');
            ctx.save();
            ctx.scale(density, density);
            ctx.clearRect(0, 0, this.width, this.height);
            let path = this.traceOutline();
            ctx.fillStyle = WebMolKit.colourCanvas(this.background);
            ctx.fill(path);
            ctx.strokeStyle = WebMolKit.colourCanvas(this.border);
            ctx.lineWidth = 1;
            ctx.stroke(path);
            let bank = this.stack.length > 0 ? this.stack[this.stack.length - 1] : null;
            this.contentDOM.css({ 'width': this.width + 'px', 'height': this.height + 'px' });
            for (let n = 0; n < this.display.length; n++) {
                const d = this.display[n], b = this.buttonFromID(d.id);
                let col1, col2;
                if (this.highlightButton != null && d.id == this.highlightButton) {
                    col1 = this.buttonColActv1;
                    col2 = this.buttonColActv2;
                }
                else if (this.selectedButton != null && d.id == this.selectedButton) {
                    col1 = this.buttonColSel1;
                    col2 = this.buttonColSel2;
                }
                else {
                    col1 = this.buttonColNorm1;
                    col2 = this.buttonColNorm2;
                }
                ctx.save();
                path = WebMolKit.pathRoundedRect(d.x + 0.5, d.y + 0.5, d.x + d.width - 1, d.y + d.height - 1, 5);
                if (col2 != null) {
                    let grad = ctx.createLinearGradient(d.x, d.y, d.x + d.width, d.y + d.height);
                    grad.addColorStop(0, WebMolKit.colourCanvas(col1));
                    grad.addColorStop(1, WebMolKit.colourCanvas(col2));
                    ctx.fillStyle = grad;
                }
                else
                    ctx.fillStyle = WebMolKit.colourCanvas(col1);
                ctx.fill(path);
                ctx.strokeStyle = WebMolKit.colourCanvas(this.border);
                ctx.lineWidth = 0.5;
                ctx.stroke(path);
                ctx.restore();
                if (d.imgDOM != null) {
                    d.imgDOM.remove();
                    d.imgDOM = null;
                }
                if (b != null) {
                    if (d.helpSpan == null) {
                        d.helpSpan = WebMolKit.dom('<span style="position: absolute;"/>').appendTo(this.contentDOM);
                        let txt = b.helpText;
                        if (b.mnemonic) {
                            while (txt.endsWith('.'))
                                txt = txt.substring(0, txt.length - 1);
                            let keyText = b.mnemonic;
                            let match = keyText.match(/^(.*)CmdOrCtrl(.*)$/);
                            if (match)
                                keyText = match[1] + (this.isMacLike ? 'Cmd' : 'Ctrl') + match[2];
                            txt += ' [' + keyText + ']';
                        }
                        WebMolKit.addTooltip(d.helpSpan, txt);
                    }
                    WebMolKit.setBoundaryPixels(d.helpSpan, d.x, d.y, d.width, d.height);
                }
                if (b == null) { }
                else if (b.imageFN != null && d.imgDOM == null) {
                    d.imgDOM = WebMolKit.dom('<img/>').appendTo(this.contentDOM).css({ 'position': 'absolute', 'pointer-events': 'none' });
                    d.imgDOM.setAttr('src', WebMolKit.Theme.RESOURCE_URL + '/img/actions/' + b.imageFN + '.svg');
                    const sz = this.prefabImgSize;
                    const bx = d.x + Math.floor(0.5 * (d.width - sz));
                    const by = d.y + Math.floor(0.5 * (d.height - sz));
                    WebMolKit.setBoundaryPixels(d.imgDOM, bx, by, sz, sz);
                }
                else if (b.metavec != null) {
                    let draw = b.metavec instanceof WebMolKit.MetaVector ? b.metavec : new WebMolKit.MetaVector(b.metavec);
                    draw.offsetX = d.x + Math.floor(0.5 * (d.width - draw.width));
                    draw.offsetY = d.y + Math.floor(0.5 * (d.height - draw.height));
                    draw.renderContext(ctx);
                }
                else if (b.text != null) {
                    let sz = this.idealSize;
                    let draw = new WebMolKit.MetaVector({ 'size': [sz, sz] });
                    let fsz = sz * 0.6;
                    let wad = WebMolKit.FontData.main.measureText(b.text, fsz);
                    if (wad[1] + wad[2] > sz) {
                        fsz *= sz / (wad[1] + wad[2]);
                        wad = WebMolKit.FontData.main.measureText(b.text, fsz);
                    }
                    if (wad[0] > sz) {
                        fsz *= sz / wad[0];
                        wad = WebMolKit.FontData.main.measureText(b.text, fsz);
                    }
                    let x = 0.5 * (sz - wad[0]), y = 0.5 * (sz + wad[1]);
                    draw.drawText(x - 1, y, b.text, fsz, 0x000000);
                    draw.drawText(x + 1, y, b.text, fsz, 0x000000);
                    draw.drawText(x, y - 1, b.text, fsz, 0x000000);
                    draw.drawText(x, y + 1, b.text, fsz, 0x000000);
                    draw.drawText(x, y, b.text, fsz, 0xFFFFFF);
                    draw.offsetX = d.x + Math.floor(0.5 * (d.width - draw.width));
                    draw.offsetY = d.y + Math.floor(0.5 * (d.height - draw.height));
                    draw.renderContext(ctx);
                }
                if (b != null && b.isSubMenu) {
                    ctx.save();
                    let sx = d.x + d.width - 3, sy = d.y + d.height - 3;
                    ctx.beginPath();
                    ctx.moveTo(sx, sy);
                    ctx.lineTo(sx - 6, sy);
                    ctx.lineTo(sx, sy - 6);
                    ctx.closePath();
                    ctx.fillStyle = 'black';
                    ctx.fill();
                    ctx.restore();
                }
                if (d.id == '*') {
                    ctx.save();
                    path = new Path2D();
                    let px, py, flip = this.isRaised;
                    if (this.position == ButtonViewPosition.Left || this.position == ButtonViewPosition.Right) {
                        px = [0.2, 0.7, 0.7];
                        py = [0.5, 0.3, 0.7];
                        if (this.position == ButtonViewPosition.Left)
                            flip = !flip;
                    }
                    else if (this.position == ButtonViewPosition.Top || this.position == ButtonViewPosition.Bottom) {
                        px = [0.5, 0.3, 0.7];
                        py = [0.2, 0.7, 0.7];
                        if (this.position == ButtonViewPosition.Top)
                            flip = !flip;
                    }
                    if (flip) {
                        px = [1 - px[0], 1 - px[1], 1 - px[2]];
                        py = [1 - py[0], 1 - py[1], 1 - py[2]];
                    }
                    path.moveTo(d.x + d.width * px[0], d.y + d.height * py[0]);
                    path.lineTo(d.x + d.width * px[1], d.y + d.height * py[1]);
                    path.lineTo(d.x + d.width * px[2], d.y + d.height * py[2]);
                    path.closePath();
                    ctx.fillStyle = 'white';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 0;
                    ctx.fill(path);
                    ctx.stroke(path);
                    ctx.restore();
                }
                else if (d.id == '!') {
                    ctx.save();
                    let path1 = new Path2D(), path2 = new Path2D();
                    let inset = 5;
                    let w = d.width - inset * 2, h = d.height - inset * 2;
                    for (let z = 5; z < w + h - 1; z += 12) {
                        let x1 = 0, y1 = z, x2 = z, y2 = 0;
                        if (y1 > h) {
                            let delta = y1 - h;
                            x1 += delta;
                            y1 -= delta;
                        }
                        if (x2 > w) {
                            let delta = x2 - w;
                            x2 -= delta;
                            y2 += delta;
                        }
                        path1.moveTo(d.x + inset + x1, d.y + inset + y1);
                        path1.lineTo(d.x + inset + x2, d.y + inset + y2);
                        path2.moveTo(d.x + inset + x1 + 1, d.y + inset + y1);
                        path2.lineTo(d.x + inset + x2 + 1, d.y + inset + y2);
                    }
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = '#404040';
                    ctx.stroke(path1);
                    ctx.strokeStyle = 'white';
                    ctx.stroke(path2);
                    ctx.restore();
                }
            }
            ctx.restore();
        }
        delayedRedraw() {
            window.setTimeout(() => this.redraw(), 100);
        }
        buttonFromID(id) {
            let bank = this.stack[this.stack.length - 1];
            for (let n = 0; n < bank.buttons.length; n++)
                if (bank.buttons[n].id == id)
                    return bank.buttons[n];
            return null;
        }
        displayFromID(id) {
            for (let n = 0; n < this.display.length; n++)
                if (this.display[n].id == id)
                    return this.display[n];
            return null;
        }
        traceOutline() {
            let w = this.width, h = this.height, uw = w - 1, uh = h - 1, r = 8;
            if (this.position == ButtonViewPosition.Centre || this.stack.length == 0)
                return WebMolKit.pathRoundedRect(0.5, 0.5, w - 0.5, h - 0.5, r);
            let path = new Path2D();
            if (this.position == ButtonViewPosition.Left) {
                let my = 0.5 * h - 1, gw = this.gripHeight, hg = 0.5 * this.gripWidth;
                path.moveTo(0.5, 0.5);
                path.lineTo(0.5 + uw - gw - r, 0.5);
                path.bezierCurveTo(0.5 + uw - gw, 0.5, 0.5 + uw - gw, 0.5, 0.5 + uw - gw, 0.5 + r);
                path.lineTo(0.5 + uw - gw, 0.5 + my - hg);
                path.lineTo(0.5 + uw - r, 0.5 + my - hg);
                path.bezierCurveTo(0.5 + uw, 0.5 + my - hg, 0.5 + uw, 0.5 + my - hg, 0.5 + uw, 0.5 + my - hg + r);
                path.lineTo(0.5 + uw, 0.5 + my + hg - r);
                path.bezierCurveTo(0.5 + uw, 0.5 + my + hg, 0.5 + uw, 0.5 + my + hg, 0.5 + uw - r, 0.5 + my + hg);
                path.lineTo(0.5 + uw - gw, 0.5 + my + hg);
                path.lineTo(0.5 + uw - gw, 0.5 + uh - r);
                path.bezierCurveTo(0.5 + uw - gw, 0.5 + uh, 0.5 + uw - gw, 0.5 + uh, 0.5 + uw - gw - r, 0.5 + uh);
                path.lineTo(0.5, 0.5 + uh);
            }
            else if (this.position == ButtonViewPosition.Right) {
                let my = 0.5 * h - 1, gw = this.gripHeight, hg = 0.5 * this.gripWidth;
                path.moveTo(w - 0.5, 0.5);
                path.lineTo(w - (0.5 + uw - gw - r), 0.5);
                path.bezierCurveTo(w - (0.5 + uw - gw), 0.5, w - (0.5 + uw - gw), 0.5, w - (0.5 + uw - gw), 0.5 + r);
                path.lineTo(w - (0.5 + uw - gw), 0.5 + my - hg);
                path.lineTo(w - (0.5 + uw - r), 0.5 + my - hg);
                path.bezierCurveTo(w - (0.5 + uw), 0.5 + my - hg, w - (0.5 + uw), 0.5 + my - hg, w - (0.5 + uw), 0.5 + my - hg + r);
                path.lineTo(w - (0.5 + uw), 0.5 + my + hg - r);
                path.bezierCurveTo(w - (0.5 + uw), 0.5 + my + hg, w - (0.5 + uw), 0.5 + my + hg, w - (0.5 + uw - r), 0.5 + my + hg);
                path.lineTo(w - (0.5 + uw - gw), 0.5 + my + hg);
                path.lineTo(w - (0.5 + uw - gw), 0.5 + uh - r);
                path.bezierCurveTo(w - (0.5 + uw - gw), 0.5 + uh, w - (0.5 + uw - gw), 0.5 + uh, w - (0.5 + uw - gw - r), 0.5 + uh);
                path.lineTo(w - 0.5, 0.5 + uh);
            }
            else if (this.position == ButtonViewPosition.Top) {
                let mx = 0.5 * w - 1, gh = this.gripHeight, hg = 0.5 * this.gripWidth;
                path.moveTo(0.5, h - (0.5 + uh));
                path.lineTo(0.5, h - (0.5 + gh + r));
                path.bezierCurveTo(0.5, h - (0.5 + gh), 0.5, h - (0.5 + gh), 0.5 + r, h - (0.5 + gh));
                path.lineTo(0.5 + mx - hg, h - (0.5 + gh));
                path.lineTo(0.5 + mx - hg, h - (0.5 + r));
                path.bezierCurveTo(0.5 + mx - hg, h - 0.5, 0.5 + mx - hg, h - 0.5, 0.5 + mx - hg + r, h - 0.5);
                path.lineTo(0.5 + mx + hg - r, h - 0.5);
                path.bezierCurveTo(0.5 + mx + hg, h - 0.5, 0.5 + mx + hg, h - 0.5, 0.5 + mx + hg, h - (0.5 + r));
                path.lineTo(0.5 + mx + hg, h - (0.5 + gh));
                path.lineTo(0.5 + uw - r, h - (0.5 + gh));
                path.bezierCurveTo(0.5 + uw, h - (0.5 + gh), 0.5 + uw, h - (0.5 + gh), 0.5 + uw, h - (0.5 + gh + r));
                path.lineTo(0.5 + uw, h - (0.5 + uh));
            }
            else if (this.position == ButtonViewPosition.Bottom) {
                let mx = 0.5 * w - 1, gh = this.gripHeight, hg = 0.5 * this.gripWidth;
                path.moveTo(0.5, 0.5 + uh);
                path.lineTo(0.5, 0.5 + gh + r);
                path.bezierCurveTo(0.5, 0.5 + gh, 0.5, 0.5 + gh, 0.5 + r, 0.5 + gh);
                path.lineTo(0.5 + mx - hg, 0.5 + gh);
                path.lineTo(0.5 + mx - hg, 0.5 + r);
                path.bezierCurveTo(0.5 + mx - hg, 0.5, 0.5 + mx - hg, 0.5, 0.5 + mx - hg + r, 0.5);
                path.lineTo(0.5 + mx + hg - r, 0.5);
                path.bezierCurveTo(0.5 + mx + hg, 0.5, 0.5 + mx + hg, 0.5, 0.5 + mx + hg, 0.5 + r);
                path.lineTo(0.5 + mx + hg, 0.5 + gh);
                path.lineTo(0.5 + uw - r, 0.5 + gh);
                path.bezierCurveTo(0.5 + uw, 0.5 + gh, 0.5 + uw, 0.5 + gh, 0.5 + uw, 0.5 + gh + r);
                path.lineTo(0.5 + uw, 0.5 + uh);
            }
            return path;
        }
        layoutMaxWidth(bank, slotWidth) {
            if (bank.buttons.length == 0)
                return [[null]];
            let bx = new Array(bank.buttons.length), by = new Array(bank.buttons.length);
            let x = 0, y = 0, w = 0, h = 0;
            for (let n = 0; n < bank.buttons.length; n++) {
                w = Math.max(x + 1, w);
                h = Math.max(y + 1, h);
                bx[n] = x;
                by[n] = y;
                x++;
                if (x >= slotWidth) {
                    x = 0;
                    y++;
                }
            }
            let slot = new Array(h);
            for (let n = 0; n < h; n++)
                slot[n] = new Array(w);
            for (let n = 0; n < bank.buttons.length; n++) {
                slot[by[n]][bx[n]] = bank.buttons[n].id;
            }
            return slot;
        }
        layoutMaxHeight(bank, slotHeight, slotWidth) {
            if (bank.buttons.length == 0)
                return [[null]];
            let bx = new Array(bank.buttons.length), by = new Array(bank.buttons.length);
            let x = 0, y = 0, w = 0, h = 0;
            for (let n = 0; n < bank.buttons.length; n++) {
                w = Math.max(x + 1, w);
                h = Math.max(y + 1, h);
                bx[n] = x;
                by[n] = y;
                x++;
                if (x >= slotWidth) {
                    x = 0;
                    y++;
                }
            }
            let slot = new Array(h);
            for (let n = 0; n < h; n++)
                slot[n] = new Array(w);
            for (let n = 0; n < bank.buttons.length; n++) {
                slot[by[n]][bx[n]] = bank.buttons[n].id;
            }
            return slot;
        }
        scoreLayout(slots) {
            let score = 0;
            let nrows = slots.length, ncols = slots[0].length;
            for (let y = 0; y < nrows; y++)
                for (let x = 0; x < ncols; x++) {
                    if (slots[y][x] == null)
                        score++;
                }
            if (this.maxButtonRows > 0 && nrows > this.maxButtonRows)
                score += (nrows - this.maxButtonRows) * 100;
            if (this.maxButtonColumns > 0 && ncols > this.maxButtonColumns)
                score += (ncols - this.maxButtonColumns) * 100;
            return score;
        }
        pickButtonIndex(x, y) {
            for (let n = 0; n < this.display.length; n++) {
                let d = this.display[n];
                if (x >= d.x && y >= d.y && x < d.x + d.width && y < d.y + d.height)
                    return n;
            }
            return -1;
        }
        pickButtonID(x, y) {
            let idx = this.pickButtonIndex(x, y);
            if (idx < 0)
                return undefined;
            return this.display[idx].id;
        }
        triggerButton(id) {
            if (id == '*') {
                if (this.isRaised)
                    this.lowerBank();
                else
                    this.raiseBank();
                return;
            }
            else if (id == '!') {
                this.popBank();
                return;
            }
            let bank = this.stack[this.stack.length - 1];
            bank.hitButton(id);
        }
        mouseClick(event) {
        }
        mouseDoubleClick(event) {
            event.stopImmediatePropagation();
        }
        mouseDown(event) {
            this.contentDOM.parent().grabFocus();
            let xy = WebMolKit.eventCoords(event, this.contentDOM);
            if (!this.withinOutline(xy[0], xy[1]))
                return;
            let id = this.pickButtonID(xy[0], xy[1]);
            if (id != this.highlightButton) {
                this.highlightButton = id;
                this.redraw();
            }
            event.stopPropagation();
        }
        mouseUp(event) {
            let xy = WebMolKit.eventCoords(event, this.contentDOM);
            if (!this.withinOutline(xy[0], xy[1]))
                return;
            let id = this.pickButtonID(xy[0], xy[1]);
            if (id != null && this.highlightButton == id) {
                this.highlightButton = undefined;
                this.triggerButton(id);
                this.delayedRedraw();
            }
            else {
                this.highlightButton = undefined;
                this.delayedRedraw();
            }
            event.stopPropagation();
        }
        mouseOver(event) {
            let xy = WebMolKit.eventCoords(event, this.contentDOM);
            if (!this.withinOutline(xy[0], xy[1]))
                return;
            event.stopPropagation();
        }
        mouseOut(event) {
            let xy = WebMolKit.eventCoords(event, this.contentDOM);
            if (!this.withinOutline(xy[0], xy[1])) {
                if (this.highlightButton != null) {
                    this.highlightButton = null;
                    this.delayedRedraw();
                }
                return;
            }
            if (this.highlightButton != null) {
                let xy = WebMolKit.eventCoords(event, this.contentDOM);
                let id = this.pickButtonID(xy[0], xy[1]);
                if (id != this.highlightButton) {
                    this.highlightButton = null;
                    this.delayedRedraw();
                }
            }
            event.stopPropagation();
        }
        mouseMove(event) {
            let xy = WebMolKit.eventCoords(event, this.contentDOM);
            if (!this.withinOutline(xy[0], xy[1]))
                return;
        }
    }
    WebMolKit.ButtonView = ButtonView;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    const BUTTON_DIAMETER = 50;
    const BUTTON_HPADDING = 4;
    const BUTTON_VPADDING = 2;
    const STATE_NORMAL = 'normal';
    const STATE_SELECTED = 'selected';
    const STATE_DISABLED = 'disabled';
    class CircleButton extends WebMolKit.Widget {
        constructor(icon) {
            super();
            this.icon = icon;
            this.state = STATE_NORMAL;
            this.isHighlight = false;
            this.isPressed = false;
            this.progressFraction = null;
            this.callbackAction = null;
        }
        render(parent) {
            super.render(parent);
            this.content.addClass('no_selection');
            const diameter = BUTTON_DIAMETER;
            const width = diameter, height = diameter;
            let div = this.content;
            let density = WebMolKit.pixelDensity();
            div.css('width', width + 2 * BUTTON_HPADDING);
            div.css('height', height + 2 * BUTTON_VPADDING);
            div.css('position', 'relative');
            let canvasStyle = 'position: absolute; left: ' + BUTTON_HPADDING + 'px; top: ' + BUTTON_VPADDING + 'px;';
            canvasStyle += 'pointer-events: none;';
            function renderSolid(col1, col2) {
                let node = WebMolKit.newElement(div, 'canvas', { 'width': width * density, 'height': height * density, 'style': canvasStyle });
                node.style.width = width + 'px';
                node.style.height = height + 'px';
                let ctx = node.getContext('2d');
                ctx.save();
                ctx.scale(density, density);
                ctx.beginPath();
                ctx.arc(0.5 * width, 0.5 * height, 0.5 * diameter - 1, 0, 2 * Math.PI, true);
                ctx.clip();
                let grad = ctx.createLinearGradient(0, 0, width, height);
                grad.addColorStop(0, col1);
                grad.addColorStop(1, col2);
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, width, height);
                ctx.restore();
                return node;
            }
            function renderBorder(lw) {
                let node = WebMolKit.newElement(div, 'canvas', { 'width': width * density, 'height': height * density, 'style': canvasStyle });
                node.style.width = width + 'px';
                node.style.height = height + 'px';
                let ctx = node.getContext('2d');
                ctx.save();
                ctx.scale(density, density);
                ctx.beginPath();
                ctx.arc(0.5 * width, 0.5 * height, 0.5 * diameter - 0.5 * (1 + lw), 0, 2 * Math.PI, true);
                ctx.strokeStyle = 'black';
                ctx.lineWidth = lw;
                ctx.stroke();
                ctx.restore();
                return node;
            }
            this.normalBackgr = renderSolid('#FFFFFF', '#D0D0D0');
            this.selectedBackgr = renderSolid('#47D5D2', '#008FD1');
            this.pressedBackgr = renderSolid('#00CA59', '#008650');
            this.disabledBackgr = renderSolid('white', 'white');
            this.ringProgress = WebMolKit.newElement(div, 'canvas', { 'width': width * density, 'height': height * density, 'style': canvasStyle });
            this.ringProgress.style.width = width + 'px';
            this.ringProgress.style.height = height + 'px';
            this.ringProgress.getContext('2d').scale(density, density);
            this.ringProgress.hidden = true;
            this.thinBorder = renderBorder(1);
            this.thickBorder = renderBorder(2);
            let svgurl = WebMolKit.Theme.BASE_URL + '/img/icons/' + this.icon;
            this.svg = WebMolKit.newElement(div, 'object', { 'width': width, 'height': height, 'style': canvasStyle, 'data': svgurl, 'type': 'image/svg+xml' });
            this.updateLayers();
            div.mouseenter(() => this.mouseEnter());
            div.mouseleave(() => this.mouseLeave());
            div.mousedown(() => this.mouseDown());
            div.mouseup(() => this.mouseUp());
            div.click(() => this.mouseClicked());
        }
        setProgress(fraction) {
            if (this.progressFraction == fraction)
                return;
            this.progressFraction = fraction;
            this.ringProgress.hidden = false;
            let diameter = BUTTON_DIAMETER, mid = 0.5 * diameter, outer = mid - 1, inner = 0.8 * mid;
            let ctx = this.ringProgress.getContext('2d');
            ctx.clearRect(0, 0, diameter, diameter);
            ctx.strokeStyle = 'rgba(80,80,80,0.5)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.ellipse(mid, mid, inner + 0.5, inner + 0.5, 0, 0, WebMolKit.TWOPI, false);
            ctx.stroke();
            if (this.progressFraction == 0) {
                ctx.lineWidth = 1;
                ctx.strokeStyle = '#47D5D2';
                WebMolKit.drawLine(ctx, mid, mid - inner, mid, mid - outer);
                return;
            }
            let delta = WebMolKit.TWOPI * fraction;
            let theta1 = -0.5 * Math.PI, theta2 = theta1 + delta;
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(mid, mid - outer);
            ctx.arc(mid, mid, outer, theta1, theta2, false);
            ctx.lineTo(mid + inner * Math.cos(theta2), mid + inner * Math.sin(theta2));
            ctx.arc(mid, mid, inner, theta2, theta1, true);
            ctx.closePath();
            let grad = ctx.createRadialGradient(mid, mid, inner, mid, mid, outer);
            grad.addColorStop(0, '#47D5D2');
            grad.addColorStop(1, '#008FD2');
            ctx.fillStyle = grad;
            ctx.fill();
            ctx.restore();
        }
        clearProgress() {
            this.progressFraction = null;
            this.ringProgress.hidden = true;
        }
        updateLayers() {
            let setVisible = (canvas, visible) => canvas.style.display = visible ? 'block' : 'none';
            setVisible(this.pressedBackgr, this.isPressed);
            setVisible(this.normalBackgr, !this.isPressed && this.state == STATE_NORMAL);
            setVisible(this.selectedBackgr, !this.isPressed && this.state == STATE_SELECTED);
            setVisible(this.disabledBackgr, !this.isPressed && this.state == STATE_DISABLED);
            let highlight = this.isHighlight;
            if (this.state == STATE_DISABLED) {
                highlight = false;
                this.content.css('cursor', 'no-drop');
            }
            else
                this.content.css('cursor', 'pointer');
            setVisible(this.thinBorder, !highlight);
            setVisible(this.thickBorder, highlight);
        }
        mouseEnter() {
            this.isHighlight = true;
            this.updateLayers();
        }
        mouseLeave() {
            this.isHighlight = false;
            this.isPressed = false;
            this.updateLayers();
        }
        mouseDown() {
            this.isPressed = this.state != STATE_DISABLED;
            this.updateLayers();
        }
        mouseUp() {
            this.isPressed = false;
            this.updateLayers();
        }
        mouseClicked() {
            if (this.callbackAction)
                this.callbackAction(this);
        }
    }
    WebMolKit.CircleButton = CircleButton;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class ClipboardProxyHandler {
        copyEvent(andCut, proxy) { return false; }
        pasteEvent(proxy) { return false; }
    }
    WebMolKit.ClipboardProxyHandler = ClipboardProxyHandler;
    class ClipboardProxy {
        constructor() {
            this.handlers = [new ClipboardProxyHandler()];
        }
        pushHandler(handler) {
            this.handlers.push(handler);
        }
        popHandler() {
            this.handlers.pop();
        }
        currentHandler() {
            return WebMolKit.Vec.last(this.handlers);
        }
        triggerCopy(andCut) {
            if (this.currentHandler().copyEvent(andCut, this))
                return;
            document.execCommand(andCut ? 'cut' : 'copy');
        }
        triggerPaste() {
            if (this.currentHandler().pasteEvent(this))
                return;
            document.execCommand('paste');
        }
        getString() { return null; }
        setString(str) { }
        setImage(blob) { }
        canSetHTML() { return false; }
        setHTML(html) { }
        canAlwaysGet() { return false; }
        downloadString(str, fn) { }
    }
    WebMolKit.ClipboardProxy = ClipboardProxy;
    class ClipboardProxyWeb extends ClipboardProxy {
        constructor() {
            super();
            this.lastContent = null;
            this.fakeTextArea = null;
            this.busy = false;
            document.addEventListener('copy', (event) => {
                if (this.busy)
                    return null;
                if (this.currentHandler().copyEvent(false, this)) {
                    event.preventDefault();
                    return false;
                }
            });
            document.addEventListener('cut', (event) => {
                if (this.busy)
                    return null;
                if (this.currentHandler().copyEvent(true, this)) {
                    event.preventDefault();
                    return false;
                }
            });
            document.addEventListener('paste', (event) => {
                let wnd = window;
                this.lastContent = null;
                if (wnd.clipboardData && wnd.clipboardData.getData)
                    this.lastContent = wnd.clipboardData.getData('Text');
                else if (event.clipboardData && event.clipboardData.getData)
                    this.lastContent = event.clipboardData.getData('text/plain');
                let consumed = this.currentHandler().pasteEvent(this);
                this.lastContent = null;
                if (consumed) {
                    event.preventDefault();
                    return false;
                }
                return true;
            });
        }
        getString() {
            return this.lastContent;
        }
        setString(str) {
            let fallbackWorkaround = () => {
                if (this.fakeTextArea == null) {
                    this.fakeTextArea = document.createElement('textarea');
                    this.fakeTextArea.style.fontSize = '12pt';
                    this.fakeTextArea.style.border = '0';
                    this.fakeTextArea.style.padding = '0';
                    this.fakeTextArea.style.margin = '0';
                    this.fakeTextArea.style.position = 'fixed';
                    this.fakeTextArea.style['left'] = '-9999px';
                    this.fakeTextArea.style.top = (window.pageYOffset || document.documentElement.scrollTop) + 'px';
                    this.fakeTextArea.setAttribute('readonly', '');
                    document.body.appendChild(this.fakeTextArea);
                }
                this.fakeTextArea.value = str;
                this.fakeTextArea.select();
                this.busy = true;
                document.execCommand('copy');
                this.busy = false;
            };
            if (navigator.clipboard) {
                navigator.clipboard.writeText(str).then(() => { }, fallbackWorkaround);
            }
            else
                fallbackWorkaround();
        }
        setImage(blob) {
            this.busy = true;
            let rdr = new FileReader();
            rdr.onload = (event) => {
                let dataURL = event.target.result.toString();
                if (!dataURL)
                    return;
                let img = $('<img/>').attr('src', dataURL);
                img.on('load', () => {
                    let r = document.createRange();
                    r.setStartBefore(img[0]);
                    r.setEndAfter(img[0]);
                    r.selectNode(img[0]);
                    let sel = window.getSelection();
                    sel.addRange(r);
                    document.execCommand('copy');
                    img.remove();
                    this.busy = false;
                });
                img.appendTo(document.body);
            };
            rdr.readAsDataURL(blob);
        }
    }
    WebMolKit.ClipboardProxyWeb = ClipboardProxyWeb;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class EmbedChemistry extends WebMolKit.Widget {
        constructor() {
            super();
            this.padding = 4;
            this.borderCol = 0xD0D0D0;
            this.borderRadius = 8;
            this.backgroundCol1 = 0xFFFFFF;
            this.backgroundCol2 = 0xF0F0F0;
            this.policy = WebMolKit.RenderPolicy.defaultColourOnWhite();
        }
        clearBackground() { this.backgroundCol1 = null; this.backgroundCol2 = null; }
        setBackground(bg) { this.backgroundCol1 = bg; this.backgroundCol2 = null; }
        setBackgroundGradient(bg1, bg2) { this.backgroundCol1 = bg1; this.backgroundCol2 = bg2; }
        render(parent) {
            super.render(parent);
            let content = this.contentDOM;
            if (this.borderCol != null)
                content.setCSS('border', '1px solid ' + WebMolKit.colourCanvas(this.borderCol));
            if (this.borderRadius > 0)
                content.setCSS('border-radius', this.borderRadius + 'px');
            let bg1 = this.backgroundCol1, bg2 = this.backgroundCol2;
            if (bg1 != null && bg2 != null) {
                let cols = WebMolKit.colourCanvas(bg1) + ',' + WebMolKit.colourCanvas(bg2);
                content.setCSS('background-image', 'linear-gradient(to bottom right, ' + cols + ')');
            }
            else if (bg1 != null) {
                content.setCSS('background-color', WebMolKit.colourCanvas(bg1));
            }
            content.css({ 'padding': this.padding + 'px', 'margin': '0' });
        }
    }
    WebMolKit.EmbedChemistry = EmbedChemistry;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class EmbedCollection extends WebMolKit.EmbedChemistry {
        constructor(datastr, options) {
            super();
            this.datastr = datastr;
            this.ds = null;
            this.failmsg = '';
            this.tight = false;
            if (!options)
                options = {};
            if (options.encoding == 'base64')
                datastr = WebMolKit.fromUTF8(atob(datastr.trim()));
            let ds = null, name = options.name;
            if (options.format == 'datasheet' || options.format == 'chemical/x-datasheet') {
                ds = WebMolKit.DataSheetStream.readXML(datastr);
            }
            else if (options.format == 'sdfile' || options.format == 'chemical/x-mdl-sdfile') {
                try {
                    let mdl = new WebMolKit.MDLSDFReader(datastr);
                    ds = mdl.parse();
                }
                catch (ex) {
                    this.failmsg = ex;
                }
            }
            else {
                try {
                    ds = WebMolKit.DataSheetStream.readXML(datastr);
                }
                catch (ex) { }
                if (ds == null) {
                    try {
                        let mdl = new WebMolKit.MDLSDFReader(datastr);
                        ds = mdl.parse();
                    }
                    catch (ex) { }
                }
            }
            if (ds == null)
                return;
            if (options.padding)
                this.padding = options.padding;
            if (options.background == 'transparent')
                this.clearBackground();
            else if (options.background) {
                let bg = options.background, comma = bg.indexOf(',');
                if (comma < 0)
                    this.setBackground(WebMolKit.htmlToRGB(bg));
                else
                    this.setBackgroundGradient(WebMolKit.htmlToRGB(bg.substring(0, comma)), WebMolKit.htmlToRGB(bg.substring(comma + 1)));
            }
            if (options.border == 'transparent')
                this.borderCol = WebMolKit.MetaVector.NOCOLOUR;
            else if (options.border)
                this.borderCol = WebMolKit.htmlToRGB(options.border);
            if (options.radius != null)
                this.borderRadius = parseInt(options.radius);
            if (options.scheme == 'wob')
                this.policy = WebMolKit.RenderPolicy.defaultWhiteOnBlack();
            else if (options.scheme == 'cob')
                this.policy = WebMolKit.RenderPolicy.defaultColourOnBlack();
            else if (options.scheme == 'bow')
                this.policy = WebMolKit.RenderPolicy.defaultBlackOnWhite();
            else if (options.scheme == 'cow')
                this.policy = WebMolKit.RenderPolicy.defaultColourOnWhite();
            if (options.scale)
                this.policy.data.pointScale = options.scale;
            if (options.tight == true || options.tight == 'true')
                this.tight = true;
            this.ds = ds;
        }
        render(parent) {
            this.tagType = 'span';
            super.render(parent);
            let span = this.contentDOM, ds = this.ds, policy = this.policy;
            span.css({ 'display': 'inline-block', 'line-height': '0' });
            if (!this.tight)
                span.setCSS('margin-bottom', '1.5em');
            if (ds != null) {
                let aspects = new WebMolKit.AspectList(ds).enumerate();
                let columns = this.determineColumns(aspects);
                let table = WebMolKit.dom('<table/>').appendTo(span);
                table.css({ 'font-family': '"HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif' });
                table.css({ 'border-collapse': 'collapse', 'line-height': '1', 'margin': '2px', 'border': '0' });
                let tr = WebMolKit.dom('<tr/>').appendTo(table).css({ 'line-height': '1' });
                for (let n = 0; n < columns.length; n++) {
                    let th = WebMolKit.dom('<th/>').appendTo(tr);
                    th.css({ 'white-space': 'nowrap', 'font-weight': '600', 'text-decoration': 'underline', 'text-align': 'center' });
                    th.css({ 'padding': '0.2em 0.5em 0.2em 0.5em', 'color': 'black', 'border': '0' });
                    th.setText(columns[n].name);
                }
                for (let row = 0; row < ds.numRows;) {
                    let blksz = 1;
                    for (let aspect of aspects)
                        blksz = Math.max(blksz, aspect.rowBlockCount(row));
                    tr = WebMolKit.dom('<tr/>').appendTo(table).css({ 'line-height': '1' });
                    for (let col = 0; col < columns.length; col++) {
                        let td = WebMolKit.dom('<td/>').appendTo(tr);
                        td.css({ 'border': '1px solid #D0D0D0', 'padding': '0.2em', 'vertical-align': 'middle' });
                        let spec = columns[col];
                        if (spec.aspect == null) {
                            if (ds.isNull(row, spec.idx))
                                td.setText(' ');
                            else if (ds.colType(spec.idx) == "molecule")
                                this.renderMolecule(td, row, spec.idx);
                            else
                                this.renderPrimitive(td, row, spec.idx);
                        }
                        else if (spec.type == 'text')
                            this.renderTextAspect(td, row, spec.aspect, spec.idx);
                        else if (spec.type == 'graphic')
                            this.renderGraphicAspect(td, row, spec.aspect, spec.idx);
                    }
                    row += blksz;
                }
            }
            else {
                span.css({ 'color': 'red' });
                span.setText('Unable to parse datasheet: ' + this.failmsg);
                let pre = WebMolKit.dom('<pre/>').appendTo(span);
                pre.css({ 'line-height': '1.1' });
                pre.setText(this.datastr);
                console.log('Unparseable datasheet source string:\n[' + this.datastr + ']');
            }
        }
        determineColumns(aspects) {
            let ds = this.ds;
            let columns = [];
            let reserved = WebMolKit.Vec.booleanArray(false, ds.numCols);
            let names = [];
            for (let n = 0; n < ds.numCols; n++)
                names.push(ds.colName(n));
            for (let aspect of aspects) {
                if (ds.numRows > 0)
                    for (let n = 0, num = aspect.numTextRenderings(0); n < num; n++) {
                        let title = aspect.produceTextRendering(0, n).name;
                        columns.push({ 'name': title, 'aspect': aspect, 'type': 'text', 'idx': n });
                    }
                if (ds.numRows > 0)
                    for (let n = 0, num = aspect.numGraphicRenderings(0); n < num; n++) {
                        let title = aspect.produceGraphicRendering(0, n, this.policy).name;
                        columns.push({ 'name': title, 'aspect': aspect, 'type': 'graphic', 'idx': n });
                    }
                let claimed = aspect.areColumnsReserved(names);
                for (let n = 0; n < names.length; n++)
                    reserved[n] = reserved[n] || claimed[n];
            }
            for (let n = 0; n < ds.numCols; n++)
                if (!reserved[n] && ds.colType(n) != "extend") {
                    columns.push({ 'name': ds.colName(n), 'aspect': null, 'type': null, 'idx': n });
                }
            return columns;
        }
        renderPrimitive(td, row, col) {
            let txt = '', ct = this.ds.colType(col), align = 'center';
            if (ct == "string") {
                txt = this.ds.getString(row, col);
                align = 'left';
            }
            else if (ct == "integer")
                txt = this.ds.getInteger(row, col).toString();
            else if (ct == "real")
                txt = this.ds.getReal(row, col).toString();
            else if (ct == "boolean")
                txt = this.ds.getBoolean(row, col) ? 'true' : 'false';
            td.setText(txt);
            td.css({ 'text-align': align });
        }
        renderMolecule(td, row, col) {
            td.css({ 'text-align': 'center' });
            let effects = new WebMolKit.RenderEffects();
            let measure = new WebMolKit.OutlineMeasurement(0, 0, this.policy.data.pointScale);
            let layout = new WebMolKit.ArrangeMolecule(this.ds.getMolecule(row, col), measure, this.policy, effects);
            layout.arrange();
            let metavec = new WebMolKit.MetaVector();
            new WebMolKit.DrawMolecule(layout, metavec).draw();
            metavec.normalise();
            WebMolKit.dom(metavec.createSVG()).appendTo(td);
        }
        renderTextAspect(td, row, aspect, idx) {
            let rend = aspect.produceTextRendering(row, idx);
            if (!rend.text)
                td.setText(' ');
            else if (rend.type == WebMolKit.Aspect.TEXT_PLAIN)
                td.setText(rend.text);
            else if (rend.type == WebMolKit.Aspect.TEXT_LINK) {
                let ahref = WebMolKit.dom('<a target="_blank"/>').appendTo(td);
                ahref.setAttr('href', rend.text);
                ahref.setText(rend.text);
            }
            else if (rend.type == WebMolKit.Aspect.TEXT_HTML)
                td.setHTML(rend.text);
        }
        renderGraphicAspect(td, row, aspect, idx) {
            let metavec = aspect.produceGraphicRendering(row, idx, this.policy).metavec;
            if (metavec == null) {
                td.setText(' ');
                return;
            }
            td.css({ 'text-align': 'center' });
            metavec.normalise();
            WebMolKit.dom(metavec.createSVG()).appendTo(td);
        }
    }
    WebMolKit.EmbedCollection = EmbedCollection;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class EmbedMolecule extends WebMolKit.EmbedChemistry {
        constructor(molstr, options) {
            super();
            this.molstr = molstr;
            this.mol = null;
            this.name = '';
            this.failmsg = '';
            this.maxWidth = 0;
            this.maxHeight = 0;
            this.boxSize = null;
            this.tight = false;
            if (!options)
                options = {};
            let mol = null, name = options.name;
            if (options.format == 'sketchel' || options.format == 'chemical/x-sketchel') {
                mol = WebMolKit.Molecule.fromString(molstr);
            }
            else if (options.format == 'molfile' || options.format == 'chemical/x-mdl-molfile') {
                try {
                    let mdl = new WebMolKit.MDLMOLReader(molstr);
                    mol = mdl.parse();
                    if (mol != null && name == null)
                        name = mdl.molName;
                }
                catch (ex) {
                    this.failmsg = ex;
                }
            }
            else {
                mol = WebMolKit.Molecule.fromString(molstr);
                if (mol == null) {
                    try {
                        let mdl = new WebMolKit.MDLMOLReader(molstr);
                        mol = mdl.parse();
                        if (mol != null && name == null)
                            name = mdl.molName;
                    }
                    catch (ex) { }
                }
            }
            if (mol == null)
                return;
            if (options.invert)
                mol = WebMolKit.CoordUtil.mirrorImage(mol);
            if (options.rotate)
                WebMolKit.CoordUtil.rotateMolecule(mol, options.rotate * WebMolKit.DEGRAD);
            if (options.padding)
                this.padding = options.padding;
            if (options.background == 'transparent')
                this.clearBackground();
            else if (options.background) {
                let bg = options.background, comma = bg.indexOf(',');
                if (comma < 0)
                    this.setBackground(WebMolKit.htmlToRGB(bg));
                else
                    this.setBackgroundGradient(WebMolKit.htmlToRGB(bg.substring(0, comma)), WebMolKit.htmlToRGB(bg.substring(comma + 1)));
            }
            if (options.border == 'transparent')
                this.borderCol = WebMolKit.MetaVector.NOCOLOUR;
            else if (options.border)
                this.borderCol = WebMolKit.htmlToRGB(options.border);
            if (options.radius != null)
                this.borderRadius = parseInt(options.radius);
            if (options.width)
                this.maxWidth = options.width;
            if (options.height)
                this.maxHeight = options.height;
            if (options.box) {
                let box = options.box, comma = box.indexOf(',');
                this.boxSize = new WebMolKit.Size(parseInt(box.substring(0, comma)), parseInt(box.substring(comma + 1)));
            }
            if (options.scheme == 'wob')
                this.policy = WebMolKit.RenderPolicy.defaultWhiteOnBlack();
            else if (options.scheme == 'cob')
                this.policy = WebMolKit.RenderPolicy.defaultColourOnBlack();
            else if (options.scheme == 'bow')
                this.policy = WebMolKit.RenderPolicy.defaultBlackOnWhite();
            else if (options.scheme == 'cow')
                this.policy = WebMolKit.RenderPolicy.defaultColourOnWhite();
            if (options.scale)
                this.policy.data.pointScale = options.scale;
            if (options.tight == true || options.tight == 'true')
                this.tight = true;
            this.mol = mol;
            this.name = name;
        }
        render(parent) {
            this.tagType = 'span';
            super.render(parent);
            let span = this.contentDOM, mol = this.mol, policy = this.policy;
            span.css({ 'display': 'inline-block', 'line-height': '0' });
            if (!this.tight)
                span.setCSS('margin-bottom', '1.5em');
            if (mol != null && mol.numAtoms > 0) {
                span.setCSS('text-align', 'center');
                let effects = new WebMolKit.RenderEffects();
                let measure = new WebMolKit.OutlineMeasurement(0, 0, policy.data.pointScale);
                let layout = new WebMolKit.ArrangeMolecule(mol, measure, policy, effects);
                layout.arrange();
                if (this.boxSize)
                    layout.squeezeInto(0, 0, this.boxSize.w, this.boxSize.h);
                else if (this.maxWidth > 0 || this.maxHeight > 0) {
                    let bounds = layout.determineBoundary();
                    let w = bounds[2] - bounds[0], h = bounds[3] - bounds[1];
                    let limW = this.maxWidth == 0 ? w : Math.min(w, this.maxWidth);
                    let limH = this.maxHeight == 0 ? h : Math.min(h, this.maxHeight);
                    if (limW != w || limH != h)
                        layout.squeezeInto(0, 0, limW, limH);
                }
                let metavec = new WebMolKit.MetaVector();
                new WebMolKit.DrawMolecule(layout, metavec).draw();
                if (this.boxSize == null)
                    metavec.normalise();
                else
                    metavec.setSize(this.boxSize.w, this.boxSize.h);
                let svg = WebMolKit.dom(metavec.createSVG()).appendTo(span);
                if (this.name) {
                    let p = WebMolKit.dom('<p/>').appendTo(span);
                    p.css({ 'padding': '0.2em 0 0 0', 'margin': '0', 'width': '100%', 'color': '#606060', 'line-height': '1' });
                    p.css({ 'font-family': '"HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif' });
                    p.setText(this.name);
                }
            }
            else {
                span.css({ 'color': 'red' });
                span.setText('Unable to parse molecule: ' + this.failmsg);
                let pre = WebMolKit.dom('<pre/>').appendTo(span);
                pre.css({ 'line-height': '1.1' });
                pre.setText(this.molstr);
                console.log('Unparseable molecule source string:\n[' + this.molstr + ']');
            }
        }
    }
    WebMolKit.EmbedMolecule = EmbedMolecule;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let EmbedReactionFacet;
    (function (EmbedReactionFacet) {
        EmbedReactionFacet["HEADER"] = "header";
        EmbedReactionFacet["SCHEME"] = "scheme";
        EmbedReactionFacet["QUANTITY"] = "quantity";
        EmbedReactionFacet["METRICS"] = "metrics";
    })(EmbedReactionFacet = WebMolKit.EmbedReactionFacet || (WebMolKit.EmbedReactionFacet = {}));
    class EmbedReaction extends WebMolKit.EmbedChemistry {
        constructor(datastr, options) {
            super();
            this.datastr = datastr;
            this.row = 0;
            this.entry = null;
            this.failmsg = '';
            this.tight = false;
            this.facet = 'scheme';
            this.limitTotalW = 800;
            this.includeStoich = true;
            this.includeAnnot = false;
            if (!options)
                options = {};
            if (options.encoding == 'base64')
                datastr = WebMolKit.fromUTF8(atob(datastr.trim()));
            let xs = null;
            if (options.format == 'datasheet' || options.format == 'chemical/x-datasheet') {
                let ds = WebMolKit.DataSheetStream.readXML(datastr);
                if (ds == null) {
                    this.failmsg = 'Unable to parse raw XML datasheet.';
                    return;
                }
                if (WebMolKit.Experiment.isExperiment(ds))
                    xs = new WebMolKit.Experiment(ds);
            }
            else {
                let ds = WebMolKit.DataSheetStream.readXML(datastr);
                if (ds == null) {
                    this.failmsg = 'Unable to parse raw XML datasheet.';
                    return;
                }
                if (WebMolKit.Experiment.isExperiment(ds))
                    xs = new WebMolKit.Experiment(ds);
            }
            if (xs == null) {
                this.failmsg = 'Unable to instantiate Experiment aspect.';
                return;
            }
            if (xs.ds.numRows == 0) {
                this.failmsg = 'Experiment datasheet has no rows.';
                return;
            }
            if (options.row)
                this.row = options.row;
            if (this.row < 0 || this.row >= xs.ds.numRows) {
                this.failmsg = 'Requested row ' + this.row + ' out of bounds.';
                return;
            }
            this.entry = xs.getEntry(this.row);
            if (options.facet)
                this.facet = options.facet;
            if (options.padding)
                this.padding = options.padding;
            if (options.background == 'transparent')
                this.clearBackground();
            else if (options.background) {
                let bg = options.background, comma = bg.indexOf(',');
                if (comma < 0)
                    this.setBackground(WebMolKit.htmlToRGB(bg));
                else
                    this.setBackgroundGradient(WebMolKit.htmlToRGB(bg.substring(0, comma)), WebMolKit.htmlToRGB(bg.substring(comma + 1)));
            }
            if (options.border == 'transparent')
                this.borderCol = WebMolKit.MetaVector.NOCOLOUR;
            else if (options.border)
                this.borderCol = WebMolKit.htmlToRGB(options.border);
            if (options.radius != null)
                this.borderRadius = parseInt(options.radius);
            if (options.scheme == 'wob')
                this.policy = WebMolKit.RenderPolicy.defaultWhiteOnBlack();
            else if (options.scheme == 'cob')
                this.policy = WebMolKit.RenderPolicy.defaultColourOnBlack();
            else if (options.scheme == 'bow')
                this.policy = WebMolKit.RenderPolicy.defaultBlackOnWhite();
            else if (options.scheme == 'cow')
                this.policy = WebMolKit.RenderPolicy.defaultColourOnWhite();
            if (options.scale)
                this.policy.data.pointScale = options.scale;
            if (options.tight == true || options.tight == 'true')
                this.tight = true;
            if (options.maximumwidth > 0)
                this.limitTotalW = options.maximumwidth;
            if (options.stoichiometry == false || options.stoichiometry == 'false')
                this.includeStoich = true;
            if (options.annotations == true || options.annotations == 'true')
                this.includeAnnot = true;
        }
        render(parent) {
            this.tagType = 'span';
            super.render(parent);
            let span = this.contentDOM;
            span.css({ 'display': 'inline-block', 'line-height': '0' });
            if (!this.tight)
                span.setCSS('margin-bottom', '1.5em');
            if (this.entry != null) {
                if (this.facet == EmbedReactionFacet.HEADER)
                    this.renderHeader(span);
                else if (this.facet == EmbedReactionFacet.SCHEME)
                    this.renderScheme(span);
                else if (this.facet == EmbedReactionFacet.QUANTITY)
                    this.renderQuantity(span);
                else if (this.facet == EmbedReactionFacet.METRICS)
                    this.renderMetrics(span);
            }
            else {
                span.css({ 'color': 'red' });
                span.setText('Failure to acquire data: ' + this.failmsg);
                let pre = WebMolKit.dom('<pre/>').appendTo(span).css({ 'line-height': '1.1' });
                pre.setText(this.datastr);
                console.log('Unparseable datasheet source string:\n[' + this.datastr + ']');
            }
        }
        renderHeader(span) {
            let table = WebMolKit.dom('<table/>').appendTo(span);
            table.css({ 'font-family': '"HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif' });
            table.css({ 'border-collapse': 'collapse', 'line-height': '1', 'margin': '2px', 'border': '0' });
            let titles = ['Title', 'Created', 'Modified', 'DOI'];
            for (let n = 0; n < 4; n++) {
                if (n == 3 && !this.entry.doi)
                    continue;
                let tr = WebMolKit.dom('<tr/>').appendTo(table).css({ 'line-height': '1' });
                let th = WebMolKit.dom('<th/>').appendTo(tr);
                th.css({ 'white-space': 'nowrap', 'font-weight': '600', 'color': 'black', 'text-align': 'left', 'vertical-align': 'middle' });
                th.css({ 'padding': '0.2em 0.5em 0.2em 0.5em', 'border': '1px solid #D0D0D0' });
                th.setText(titles[n]);
                let td = WebMolKit.dom('<td/>').appendTo(tr);
                td.css({ 'border': '1px solid #D0D0D0', 'padding': '0.2em', 'vertical-align': 'middle' });
                if (n == 0) {
                    if (!this.entry.title)
                        td.setCSS('font-style', 'italic');
                    td.setText(this.entry.title ? this.entry.title : '(none)');
                }
                else if (n == 1 || n == 2) {
                    let date = n == 1 ? this.entry.createDate : this.entry.modifyDate;
                    if (date == null)
                        td.setCSS('font-style', 'italic');
                    td.setText(date == null ? '(none)' : date.toLocaleString());
                }
                else if (n == 3) {
                    let url = this.doiToLink(this.entry.doi);
                    if (url != null && (url.startsWith('http://') || url.startsWith('https://'))) {
                        let ahref = WebMolKit.dom('<a target="_blank"/>').appendTo(td);
                        ahref.setAttr('href', url);
                        ahref.setText(this.entry.doi);
                    }
                    else
                        td.setText(this.entry.doi);
                }
            }
        }
        renderScheme(span) {
            let measure = new WebMolKit.OutlineMeasurement(0, 0, this.policy.data.pointScale);
            let layout = new WebMolKit.ArrangeExperiment(this.entry, measure, this.policy);
            layout.limitTotalW = this.limitTotalW;
            layout.includeStoich = this.includeStoich;
            layout.includeAnnot = this.includeAnnot;
            layout.arrange();
            let metavec = new WebMolKit.MetaVector();
            new WebMolKit.DrawExperiment(layout, metavec).draw();
            metavec.normalise();
            let svg = WebMolKit.dom(metavec.createSVG()).appendTo(span);
        }
        renderQuantity(span) {
            let quant = new WebMolKit.QuantityCalc(this.entry);
            quant.calculate();
            let table = WebMolKit.dom('<table/>').appendTo(span);
            table.css({ 'font-family': '"HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif' });
            table.css({ 'border-collapse': 'collapse', 'line-height': '1', 'margin': '2px', 'border': '0' });
            let effects = new WebMolKit.RenderEffects();
            let measure = new WebMolKit.OutlineMeasurement(0, 0, this.policy.data.pointScale);
            for (let n = 0; n < quant.numQuantities; n++) {
                let qc = quant.getQuantity(n);
                let tr = WebMolKit.dom('<tr/>').appendTo(table).css({ 'line-height': '1' });
                let td = WebMolKit.dom('<td/>').appendTo(tr);
                td.css({ 'border': '1px solid #D0D0D0', 'padding': '0.2em', 'text-align': 'center', 'vertical-align': 'middle' });
                if (WebMolKit.MolUtil.notBlank(qc.comp.mol)) {
                    let layout = new WebMolKit.ArrangeMolecule(qc.comp.mol, measure, this.policy, effects);
                    layout.arrange();
                    let metavec = new WebMolKit.MetaVector();
                    new WebMolKit.DrawMolecule(layout, metavec).draw();
                    metavec.normalise();
                    let svg = WebMolKit.dom(metavec.createSVG()).appendTo(td);
                }
                td = WebMolKit.dom('<td/>').appendTo(tr);
                td.css({ 'border': '1px solid #D0D0D0', 'padding': '0.2em', 'text-align': 'left', 'vertical-align': 'top' });
                this.renderComponentText(td, qc);
            }
        }
        renderComponentText(parent, qc) {
            let title = [], content = [];
            if (qc.comp.name) {
                title.push('Name');
                content.push('<i>' + WebMolKit.escapeHTML(qc.comp.name) + '</i>');
            }
            if (WebMolKit.MolUtil.notBlank(qc.comp.mol)) {
                let mw = WebMolKit.MolUtil.molecularWeight(qc.comp.mol);
                title.push('Weight');
                content.push(mw.toFixed(4));
                let mf = WebMolKit.MolUtil.molecularFormula(qc.comp.mol, ['<sub>', '</sub>', '<sup>', '</sup>']);
                title.push('Formula');
                content.push(mf);
            }
            if (qc.valueEquiv > 0) {
                let text = qc.valueEquiv.toString(), stat = qc.statEquiv;
                if (stat == 2)
                    text = '<i>(' + text + ')</i>';
                else if (stat == 3)
                    text += ' (conflicting)';
                title.push('Stoichiometry');
                content.push(text);
            }
            if (qc.valueMass > 0) {
                let text = WebMolKit.QuantityCalc.formatMass(qc.valueMass), stat = qc.statMass;
                if (stat == 2)
                    text = '<i>(' + text + ')</i>';
                else if (stat == 3)
                    text += ' (conflicting)';
                title.push('Mass');
                content.push(text);
            }
            if (qc.valueVolume > 0) {
                let text = WebMolKit.QuantityCalc.formatVolume(qc.valueVolume), stat = qc.statVolume;
                if (stat == 2)
                    text = '<i>(' + text + ')</i>';
                else if (stat == 3)
                    text += ' (conflicting)';
                title.push('Volume');
                content.push(text);
            }
            if (qc.valueMoles > 0) {
                let text = WebMolKit.QuantityCalc.formatMoles(qc.valueMoles), stat = qc.statMoles;
                if (stat == 2)
                    text = '<i>(' + text + ')</i>';
                else if (stat == 3)
                    text += ' (conflicting)';
                title.push('Moles');
                content.push(text);
            }
            if (qc.valueDensity > 0) {
                let text = WebMolKit.QuantityCalc.formatDensity(qc.valueDensity), stat = qc.statDensity;
                if (stat == 2)
                    text = '<i>(' + text + ')</i>';
                else if (stat == 3)
                    text += ' (conflicting)';
                title.push('Density');
                content.push(text);
            }
            if (qc.valueConc > 0) {
                let text = WebMolKit.QuantityCalc.formatConc(qc.valueConc), stat = qc.statConc;
                if (stat == 2)
                    text = '<i>(' + text + ')</i>';
                else if (stat == 3)
                    text += ' (conflicting)';
                title.push('Concentration');
                content.push(text);
            }
            if (qc.valueYield > 0 && !qc.comp.waste) {
                let text = WebMolKit.QuantityCalc.formatPercent(qc.valueYield), stat = qc.statYield;
                if (stat == 2)
                    text = '<i>(' + text + ')</i>';
                else if (stat == 3)
                    text += ' (conflicting)';
                title.push('Yield');
                content.push(text);
            }
            for (let n = 0; n < title.length; n++) {
                let p = WebMolKit.dom('<p/>').appendTo(parent);
                p.setCSS('margin', '0.1em');
                p.append(WebMolKit.dom('<b>' + title[n] + '</b>'));
                p.appendText(': ');
                p.appendHTML(content[n]);
            }
        }
        renderMetrics(span) {
            let quant = new WebMolKit.QuantityCalc(this.entry);
            quant.calculate();
            let table = WebMolKit.dom('<table/>').appendTo(span);
            table.css({ 'font-family': '"HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif' });
            table.css({ 'border-collapse': 'collapse', 'line-height': '1', 'margin': '2px', 'border': '0' });
            let effects = new WebMolKit.RenderEffects();
            let measure = new WebMolKit.OutlineMeasurement(0, 0, this.policy.data.pointScale);
            if (quant.numGreenMetrics > 0)
                for (let n = 0; n < 3; n++) {
                    let tr = WebMolKit.dom('<tr/>').appendTo(table).css({ 'line-height': '1' });
                    let th = WebMolKit.dom('<th/>').appendTo(tr);
                    th.css({ 'border': '1px solid #D0D0D0', 'padding': '0.5em', 'font-weight': 'bold' });
                    th.css({ 'text-align': 'right', 'vertical-align': 'middle', 'white-space': 'nowrap' });
                    th.setText(n == 0 ? 'All Reactants' : n == 1 ? 'All Products' : 'All Waste');
                    let td = WebMolKit.dom('<td/>').appendTo(tr);
                    td.css({ 'border': '1px solid #D0D0D0', 'padding': '0.5em', 'white-space': 'nowrap' });
                    td.css({ 'text-align': 'left', 'vertical-align': 'middle' });
                    if (n == 0) {
                        td.setText(this.combineQuant(quant.getAllMassReact(), 'g') + ' = ' + this.sumQuant(quant.getAllMassReact(), 'g', true));
                    }
                    else if (n == 1) {
                        td.setText(this.combineQuant(quant.getAllMassProd(), 'g') + ' = ' + this.sumQuant(quant.getAllMassProd(), 'g', true));
                    }
                    else if (n == 2) {
                        if (quant.getAllMassWaste().length > 0)
                            td.setText(this.combineQuant(quant.getAllMassWaste(), 'g') + ' = ' + this.sumQuant(quant.getAllMassWaste(), 'g', false));
                        else
                            td.setText('none');
                    }
                }
            else {
                let tr = WebMolKit.dom('<tr/>').appendTo(table);
                let td = WebMolKit.dom('<td/>').appendTo(tr);
                td.setText('No metrics to show.');
            }
            for (let n = 0; n < quant.numGreenMetrics; n++) {
                let gm = quant.getGreenMetrics(n);
                let qc = quant.getQuantity(gm.idx);
                let tr = WebMolKit.dom('<tr/>').appendTo(table).css({ 'line-height': '1' });
                let td = WebMolKit.dom('<td/>').appendTo(tr);
                td.css({ 'border': '1px solid #D0D0D0', 'padding': '0.2em', 'text-align': 'center', 'vertical-align': 'middle' });
                if (WebMolKit.MolUtil.notBlank(qc.comp.mol)) {
                    let layout = new WebMolKit.ArrangeMolecule(qc.comp.mol, measure, this.policy, effects);
                    layout.arrange();
                    let metavec = new WebMolKit.MetaVector();
                    new WebMolKit.DrawMolecule(layout, metavec).draw();
                    metavec.normalise();
                    WebMolKit.dom(metavec.createSVG()).appendTo(td);
                }
                td = WebMolKit.dom('<td/>').appendTo(tr);
                td.css({ 'border': '1px solid #D0D0D0', 'padding': '0.5em', 'text-align': 'left', 'vertical-align': 'top' });
                let pmi1 = this.combineQuant(gm.massReact, 'g'), pmi2 = this.combineQuant(gm.massProd, 'g');
                let pmi3 = this.sumQuantExt(gm.massReact, gm.massProd, 1, Number.NaN, null);
                let vg = this.drawTotals('PMI', pmi1, pmi2, pmi3);
                vg.normalise();
                let para = WebMolKit.dom('<p/>').appendTo(td);
                WebMolKit.dom(vg.createSVG()).appendTo(para);
                let ef1 = this.combineQuant(gm.massWaste, 'g'), ef2 = this.combineQuant(gm.massProd, 'g');
                let ef3 = this.sumQuantExt(gm.massWaste, gm.massProd, 1, Number.NaN, null);
                vg = this.drawTotals('E-factor', ef1, ef2, ef3);
                vg.normalise();
                para = WebMolKit.dom('<p/>').appendTo(td);
                WebMolKit.dom(vg.createSVG()).appendTo(para);
                let ae1 = this.combineQuant(gm.molwProd, null), ae2 = this.combineQuant(gm.molwReact, null);
                let ae3 = this.sumQuantExt(gm.molwProd, gm.molwReact, 100, 100, '%');
                vg = this.drawTotals('Atom-E', ae1, ae2, ae3);
                vg.normalise();
                para = WebMolKit.dom('<p/>').appendTo(td);
                WebMolKit.dom(vg.createSVG()).appendTo(para);
            }
        }
        combineQuant(values, units) {
            if (values.length == 0)
                return '?';
            let str = '';
            for (let n = 0; n < values.length; n++) {
                if (n > 0)
                    str += ' + ';
                if (values[n] == WebMolKit.QuantityCalc.UNSPECIFIED) {
                    str += '?';
                }
                else {
                    str += WebMolKit.formatDouble(values[n], 4);
                    if (units)
                        str += ' ' + units;
                }
            }
            return str;
        }
        sumQuant(values, units, requireSomething) {
            if (values.length == 0)
                return requireSomething ? '?' : '0';
            let sum = 0;
            for (let n = 0; n < values.length; n++) {
                if (values[n] == WebMolKit.QuantityCalc.UNSPECIFIED)
                    return '?';
                sum += values[n];
            }
            let ret = WebMolKit.formatDouble(sum, 4);
            if (units)
                ret += ' ' + units;
            return ret;
        }
        sumQuantExt(numer, denom, mul, max, units) {
            if (numer.length == 0 || denom.length == 0)
                return '?';
            let sum1 = 0, sum2 = 0;
            for (let n = 0; n < numer.length; n++) {
                if (numer[n] == WebMolKit.QuantityCalc.UNSPECIFIED)
                    return '?';
                sum1 += numer[n];
            }
            for (let n = 0; n < denom.length; n++) {
                if (denom[n] == WebMolKit.QuantityCalc.UNSPECIFIED)
                    return '?';
                sum2 += denom[n];
            }
            if (sum2 <= 0)
                return '?';
            let val = mul * sum1 / sum2;
            if (!Number.isNaN(max))
                val = Math.min(val, max);
            let ret = WebMolKit.formatDouble(val, 4);
            if (units)
                ret += ' ' + units;
            return ret;
        }
        drawTotals(heading, over, under, answer) {
            let vg = new WebMolKit.MetaVector();
            let measure = new WebMolKit.OutlineMeasurement(0, 0, this.policy.data.pointScale);
            let sep = ' = ';
            let fsz = this.policy.data.pointScale * 0.8;
            let wadHeading = measure.measureText(heading, fsz);
            let wadOver = measure.measureText(over, fsz), wadUnder = measure.measureText(under, fsz);
            let wadAnswer = measure.measureText(answer, fsz);
            let wadSep = measure.measureText(sep, fsz);
            let x = 0;
            vg.drawText(x, 0, heading, fsz, 0x000000, WebMolKit.TextAlign.Left | WebMolKit.TextAlign.Middle);
            x += wadHeading[0];
            vg.drawText(x, 0, sep, fsz, 0x000000, WebMolKit.TextAlign.Left | WebMolKit.TextAlign.Middle);
            x += wadSep[0];
            vg.drawText(x, 0, answer, fsz, 0x000000, WebMolKit.TextAlign.Left | WebMolKit.TextAlign.Middle);
            x += wadAnswer[0];
            vg.drawText(x, 0, sep, fsz, 0x000000, WebMolKit.TextAlign.Left | WebMolKit.TextAlign.Middle);
            x += wadSep[0];
            let lw = Math.max(wadOver[0], wadUnder[0]);
            vg.drawLine(x, 0, x + lw, 0, 0x000000, 1);
            vg.drawText(x + 0.5 * lw, -2, over, fsz, 0x000000, WebMolKit.TextAlign.Centre | WebMolKit.TextAlign.Bottom);
            vg.drawText(x + 0.5 * lw, 2, under, fsz, 0x000000, WebMolKit.TextAlign.Centre | WebMolKit.TextAlign.Top);
            return vg;
        }
        doiToLink(doi) {
            if (doi.startsWith('http://') || doi.startsWith('https://'))
                return doi;
            let m = EmbedReaction.PTN_DOI1.exec(doi);
            if (m)
                return 'http://dx.doi.org/' + m[1];
            m = EmbedReaction.PTN_DOI2.exec(doi);
            if (m)
                return 'http://dx.doi.org/' + m[1];
            m = EmbedReaction.PTN_ISBN.exec(doi);
            if (m)
                return 'ISBN: ' + m[1];
            return null;
        }
    }
    EmbedReaction.PTN_DOI1 = /^doi:(\d+\.\d+\/.*)$/;
    EmbedReaction.PTN_DOI2 = /^(\d+\.\d+\/.*)$/;
    EmbedReaction.PTN_ISBN = /^(\d+-\d+-\d+-\d+-\d+)$/;
    WebMolKit.EmbedReaction = EmbedReaction;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class MenuProxy {
        hasContextMenu() { return false; }
        openContextMenu(menuItems, event) { }
    }
    WebMolKit.MenuProxy = MenuProxy;
    class MenuProxyWeb extends MenuProxy {
        hasContextMenu() { return true; }
        openContextMenu(menuItems, event) {
            let [x, y] = WebMolKit.eventCoords(event, document.body);
            let divCursor = WebMolKit.dom('<div/>').appendTo(document.body).css({ 'position': 'absolute', 'user-select': 'none' });
            WebMolKit.setBoundaryPixels(divCursor, x - 5, y - 5, 10, 10);
            let currentFocus = WebMolKit.dom(document.activeElement);
            let popup = new WebMolKit.Popup(divCursor);
            popup.callbackPopulate = () => {
                popup.bodyDOM().css({ 'user-select': 'none', 'font-size': '16px' });
                for (let menuItem of menuItems) {
                    let div = WebMolKit.dom('<div/>').appendTo(popup.bodyDOM());
                    if (menuItem == null) {
                        div.appendHTML('<hr/>');
                    }
                    else if (menuItem.subMenu) {
                        div.setText(menuItem.label + ' \u{25B8}');
                        div.css({ 'cursor': 'pointer' });
                        let fcn = (event) => {
                            event.preventDefault();
                            popup.close();
                            this.openContextMenu(menuItem.subMenu, event);
                        };
                        div.onClick(fcn);
                        div.onContextMenu(fcn);
                    }
                    else if (menuItem.click) {
                        div.setText(menuItem.label);
                        div.onMouseEnter(() => { div.css({ 'background-color': '#D0D0D0' }); });
                        div.onMouseLeave(() => { div.css({ 'background-color': 'transparent' }); });
                        div.css({ 'cursor': 'pointer' });
                        div.onClick(() => {
                            popup.close();
                            menuItem.click();
                        });
                    }
                    else {
                        div.css({ 'color': '#808080' });
                        div.setText(menuItem.label);
                    }
                }
            };
            popup.callbackClose = () => {
                divCursor.remove();
                currentFocus.grabFocus();
            };
            popup.open();
        }
    }
    WebMolKit.MenuProxyWeb = MenuProxyWeb;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class OptionList extends WebMolKit.Widget {
        constructor(options, isVertical = false) {
            super();
            this.options = options;
            this.isVertical = isVertical;
            this.padding = 6;
            this.htmlLabels = false;
            this.numCols = 0;
            this.selidx = 0;
            this.buttonDiv = [];
            this.auxCell = [];
            this.callbackSelect = null;
            if (options.length == 0)
                throw 'molsync.ui.OptionList: must provide a list of option labels.';
            if (!WebMolKit.hasInlineCSS('option'))
                WebMolKit.installInlineCSS('option', this.composeCSS());
        }
        getSelectedIndex() {
            return this.selidx;
        }
        getSelectedValue() {
            return this.options[this.selidx];
        }
        getAuxiliaryCell(idx) {
            return this.auxCell[idx].el;
        }
        onSelect(callback) {
            this.callbackSelect = callback;
        }
        render(parent) {
            super.render(parent);
            this.contentDOM.css({ 'display': 'inline-block', 'baseline-shift': '1.5em' });
            this.buttonDiv = [];
            this.auxCell = [];
            let table = WebMolKit.dom('<table class="wmk-option-table"/>').appendTo(this.contentDOM);
            let tr = this.isVertical ? null : WebMolKit.dom('<tr/>').appendTo(table);
            for (let n = 0; n < this.options.length; n++) {
                if (this.isVertical || (this.numCols > 0 && n > 0 && n % this.numCols == 0))
                    tr = WebMolKit.dom('<tr/>').appendTo(table);
                let td = WebMolKit.dom('<td class="wmk-option-cell"/>').appendTo(tr);
                let div = WebMolKit.dom('<div class="wmk-option"/>').appendTo(td);
                div.css({ 'padding': `${this.padding}px` });
                div.onClick(() => this.clickButton(n));
                this.buttonDiv.push(div);
                if (this.isVertical) {
                    td = WebMolKit.dom('<td style="vertical-align: middle;"/>').appendTo(tr);
                    this.auxCell.push(td);
                }
            }
            this.updateButtons();
        }
        clickButton(idx) {
            if (idx == this.selidx)
                return;
            this.setSelectedIndex(idx);
            if (this.callbackSelect)
                this.callbackSelect(idx, this);
        }
        setSelectedIndex(idx) {
            if (this.selidx == idx)
                return;
            this.selidx = idx;
            this.updateButtons();
        }
        setSelectedValue(val) {
            let idx = this.options.indexOf(val);
            if (idx >= 0)
                this.setSelectedIndex(idx);
        }
        updateButtons() {
            for (let n = 0; n < this.options.length && n < this.buttonDiv.length; n++) {
                let div = this.buttonDiv[n];
                let txt = this.options[n];
                if (txt.length == 0 && n == this.selidx)
                    div.setText('\u00A0\u2716\u00A0');
                else if (txt.length == 0)
                    div.setText('\u00A0\u00A0\u00A0');
                else if (this.htmlLabels)
                    div.setHTML(txt);
                else
                    div.setText(txt);
                div.removeClass('wmk-option-unselected wmk-option-selected');
                if (n != this.selidx)
                    div.addClass('wmk-option-unselected');
                else
                    div.addClass('wmk-option-selected');
            }
        }
        composeCSS() {
            let lowlight = WebMolKit.colourCode(WebMolKit.Theme.lowlight), lowlightEdge1 = WebMolKit.colourCode(WebMolKit.Theme.lowlightEdge1), lowlightEdge2 = WebMolKit.colourCode(WebMolKit.Theme.lowlightEdge2);
            let highlight = WebMolKit.colourCode(WebMolKit.Theme.highlight), highlightEdge1 = WebMolKit.colourCode(WebMolKit.Theme.highlightEdge1), highlightEdge2 = WebMolKit.colourCode(WebMolKit.Theme.highlightEdge2);
            return `
			.wmk-option
			{
				margin-bottom: 0;
				font-family: 'Open Sans', sans-serif;
				font-size: 14px;
				font-weight: normal;
				text-align: center;
				white-space: nowrap;
				line-height: 1.2em;
				cursor: pointer;
			}
			.wmk-option-selected
			{
				color: white;
				background-color: #008FD2;
				background-image: linear-gradient(to right bottom, ${lowlightEdge1}, ${lowlightEdge2});
			}
			.wmk-option-unselected
			{
				color: #333;
				background-color: white;
				background-image: linear-gradient(to right bottom, #FFFFFF, #E0E0E0);
			}
			.wmk-option-unselected:hover
			{
				background-color: #808080;
				background-image: linear-gradient(to right bottom, #F0F0F0, #D0D0D0);
			}
			.wmk-option-unselected:active
			{
				color: white;
				background-color: #00C000;
				background-image: linear-gradient(to right bottom, ${highlightEdge1}, ${highlightEdge2});
			}
			.wmk-option-table
			{
				margin: 1px;
				padding: 0;
				border-width: 0;
				border-collapse: collapse;
			}
			.wmk-option-cell
			{
				margin: 0;
				padding: 0;
				border-width: 0;
				border-width: 1px;
				border-style: solid;
				border-color: #808080;
			}
		`;
        }
    }
    WebMolKit.OptionList = OptionList;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    const CSS_POPUP = `
	*.wmk-popup
	{
		font-family: 'Open Sans', sans-serif;
	}
`;
    class Popup {
        constructor(parent) {
            this.popupBackground = 'white';
            this.callbackClose = null;
            this.callbackPopulate = null;
            this.parent = WebMolKit.domLegacy(parent);
            WebMolKit.installInlineCSS('popup', CSS_POPUP);
        }
        get obscureBackground() { return $(this.domObscureBackground.el); }
        get obscureForeground() { return $(this.domObscureForeground.el); }
        get panelBoundary() { return $(this.domPanelBoundary.el); }
        get bodyDiv() { return $(this.domBody.el); }
        onClose(callback) {
            this.callbackClose = callback;
        }
        open() {
            let body = WebMolKit.dom(document.documentElement);
            let zindex = 21000;
            let bg = this.domObscureBackground = WebMolKit.dom('<div/>').appendTo(body);
            bg.css({ 'position': 'fixed', 'z-index': zindex });
            bg.css({ 'left': '0', 'right': '0', 'top': '0', 'bottom': '0' });
            bg.css({ 'background-color': 'black', 'opacity': 0.2 });
            let fg = this.domObscureForeground = WebMolKit.dom('<div/>').appendTo(body);
            fg.css({ 'position': 'fixed', 'z-index': zindex + 1 });
            fg.css({ 'left': '0', 'right': '0', 'top': '0', 'bottom': '0' });
            fg.onClick(() => this.close());
            let pb = this.domPanelBoundary = WebMolKit.dom('<div class="wmk-popup"/>').appendTo(fg);
            pb.onClick((event) => event.stopPropagation());
            pb.css({ 'background-color': this.popupBackground, 'border': '1px solid black' });
            pb.css({ 'position': 'absolute', 'overflow': 'auto' });
            this.domBody = WebMolKit.dom('<div/>').appendTo(pb).css({ 'padding': '5px' });
            this.populate();
            this.positionAndShow();
        }
        close() {
            this.domPanelBoundary.remove();
            this.domObscureBackground.remove();
            this.domObscureForeground.remove();
            if (this.callbackClose)
                this.callbackClose(this);
            WebMolKit.clearTooltip();
        }
        bump() {
            this.positionAndShow();
        }
        body() { return this.bodyDiv; }
        bodyDOM() { return this.domBody; }
        populate() {
            if (this.callbackPopulate)
                this.callbackPopulate(this);
            else
                this.bodyDOM().setText('Empty popup.');
        }
        positionAndShow() {
            WebMolKit.clearTooltip();
            let winW = window.innerWidth, winH = window.innerHeight;
            const GAP = 2;
            let client = this.parent.el.getBoundingClientRect();
            let wx1 = client.left, wy1 = client.top, wx2 = client.right, wy2 = client.bottom;
            let pb = this.domPanelBoundary;
            let maxW = Math.max(wx1, winW - wx2) - 4;
            pb.css({ 'max-width': maxW + 'px' });
            let scrollSize = WebMolKit.empiricalScrollerSize();
            let setPosition = () => {
                let popW = pb.width(), popH = pb.height();
                let posX = 0, posY = 0;
                if (wy2 + GAP + popH < winH)
                    posY = wy2 + GAP;
                else if (wy1 - GAP - popH > 0)
                    posY = wy1 - GAP - popH;
                else if (winH - wy2 > wy1) {
                    posY = wy2 + GAP;
                    popH = winH - posY - GAP;
                }
                else {
                    posY = GAP;
                    popH = wy1 - posY - GAP;
                }
                if (pb.height() > popH)
                    popW += scrollSize.w + 10;
                if (wx1 + popW < winW)
                    posX = wx1;
                else if (popW < wx2)
                    posX = wx2 - popW;
                WebMolKit.setBoundaryPixels(pb, posX, posY, popW, popH);
            };
            setPosition();
            window.setTimeout(() => setPosition());
        }
    }
    WebMolKit.Popup = Popup;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class TabBar extends WebMolKit.Widget {
        constructor(options) {
            super();
            this.options = options;
            this.unionHeight = false;
            this.selidx = 0;
            this.buttonDiv = [];
            this.panelDiv = [];
            this.padding = 6;
            this.callbackSelect = null;
            if (!WebMolKit.hasInlineCSS('tabbar'))
                WebMolKit.installInlineCSS('tabbar', this.composeCSS());
        }
        onSelect(callback) {
            this.callbackSelect = callback;
        }
        getSelectedIndex() {
            return this.selidx;
        }
        getSelectedValue() {
            return this.options[this.selidx];
        }
        getPanel(idxOrName) {
            let dom = this.getPanelDOM(idxOrName);
            return dom ? $(dom.el) : null;
        }
        getPanelDOM(idxOrName) {
            let idx = typeof idxOrName == 'number' ? idxOrName : this.options.indexOf(idxOrName);
            if (idx < 0)
                return null;
            return this.panelDiv[idx];
        }
        render(parent) {
            super.render(parent);
            let grid = WebMolKit.dom('<div/>').appendTo(this.contentDOM).css({ 'display': 'grid' });
            grid.css({ 'align-items': 'center', 'justify-content': 'start', 'grid-row-gap': '0.5em' });
            let columns = '[start] 1fr ';
            for (let n = 0; n < this.options.length; n++)
                columns += '[btn' + n + '] auto ';
            columns += '[btnX] 1fr [end]';
            grid.css({ 'grid-template-columns': columns });
            let underline = WebMolKit.dom('<div/>').appendTo(grid);
            underline.css({ 'grid-column': 'start / end', 'grid-row': '1', 'height': '100%' });
            underline.css({ 'border-bottom': '1px solid #C0C0C0' });
            for (let n = 0; n < this.options.length; n++) {
                let outline = WebMolKit.dom('<div class="wmk-tabbar-cell"/>').appendTo(grid);
                outline.css({ 'grid-column': 'btn' + n, 'grid-row': '1' });
                let btn = WebMolKit.dom('<div class="wmk-tabbar"/>').appendTo(outline);
                btn.css({ 'padding': `${this.padding}px` });
                btn.onClick(() => this.clickButton(n));
                this.buttonDiv.push(btn);
                let panel = WebMolKit.dom('<div/>').appendTo(grid);
                panel.css({ 'grid-column': 'start / end', 'grid-row': '2' });
                panel.css({ 'align-self': 'start', 'justify-self': 'center', 'width': '100%' });
                this.panelDiv.push(panel);
            }
            this.updateButtons();
        }
        clickButton(idx) {
            if (idx == this.selidx)
                return;
            this.setSelectedIndex(idx);
            if (this.callbackSelect)
                this.callbackSelect(idx, this);
        }
        setSelectedIndex(idx) {
            if (this.selidx == idx)
                return;
            this.selidx = idx;
            let dom = this.contentDOM;
            dom.setCSS('min-width', `${dom.width()}px`);
            this.updateButtons();
        }
        setSelectedValue(val) {
            let idx = this.options.indexOf(val);
            if (idx >= 0)
                this.setSelectedIndex(idx);
        }
        rotateSelected(dir) {
            this.setSelectedIndex((this.selidx + dir + this.options.length) % this.options.length);
        }
        updateButtons() {
            for (let n = 0; n < this.options.length && n < this.buttonDiv.length; n++) {
                let div = this.buttonDiv[n];
                let txt = this.options[n];
                if (txt.length == 0 && n == this.selidx)
                    div.setText('\u00A0\u2716\u00A0');
                else if (txt.length == 0)
                    div.setText('\u00A0\u00A0\u00A0');
                else
                    div.setText(txt);
                div.removeClass('wmk-tabbar-unselected wmk-tabbar-selected');
                if (n != this.selidx)
                    div.addClass('wmk-tabbar-unselected');
                else
                    div.addClass('wmk-tabbar-selected');
                if (this.unionHeight)
                    this.panelDiv[n].setCSS('visibility', n == this.selidx ? 'visible' : 'hidden');
                else
                    this.panelDiv[n].setCSS('display', n == this.selidx ? 'block' : 'none');
            }
        }
        composeCSS() {
            let lowlight = WebMolKit.colourCode(WebMolKit.Theme.lowlight), lowlightEdge1 = WebMolKit.colourCode(WebMolKit.Theme.lowlightEdge1), lowlightEdge2 = WebMolKit.colourCode(WebMolKit.Theme.lowlightEdge2);
            let highlight = WebMolKit.colourCode(WebMolKit.Theme.highlight), highlightEdge1 = WebMolKit.colourCode(WebMolKit.Theme.highlightEdge1), highlightEdge2 = WebMolKit.colourCode(WebMolKit.Theme.highlightEdge2);
            return `
			.wmk-tabbar
			{
				margin-bottom: 0;
				font-family: 'Open Sans', sans-serif;
				font-size: 14px;
				font-weight: normal;
				text-align: center;
				white-space: nowrap;
				vertical-align: middle;
				cursor: pointer;
			}
			.wmk-tabbar-selected
			{
				color: white;
				background-color: #008FD2;
				background-image: linear-gradient(to right bottom, ${lowlightEdge1}, ${lowlightEdge2});
			}
			.wmk-tabbar-unselected
			{
				color: #333;
				background-color: white;
				background-image: linear-gradient(to right bottom, #FFFFFF, #E0E0E0);
			}
			.wmk-tabbar-unselected:hover
			{
				background-color: #808080;
				background-image: linear-gradient(to right bottom, #F0F0F0, #D0D0D0);
			}
			.wmk-tabbar-unselected:active
			{
				color: white;
				background-color: #00C000;
				background-image: linear-gradient(to right bottom, ${highlightEdge1}, ${highlightEdge2});
			}
			.wmk-tabbar-table
			{
				margin: 1px;
				padding: 0;
				border-width: 0;
				border-collapse: collapse;
			}
			.wmk-tabbar-cell
			{
				margin: 0 -1px -1px 0;
				padding: 0;
				border-width: 0;
				border-width: 1px;
				border-style: solid;
				border-color: #808080;
			}
		`;
        }
    }
    WebMolKit.TabBar = TabBar;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    let globalPopover = null;
    let globalTooltip = null;
    let globalPopWatermark = 0;
    function addTooltip(parent, bodyHTML, titleHTML, delay) {
        Tooltip.ensureGlobal();
        if (parent.jquery)
            parent = parent[0];
        let widget = WebMolKit.dom(parent);
        let tooltip = new Tooltip(widget, bodyHTML, titleHTML, delay == null ? 1000 : delay);
        widget.onMouseEnter(() => tooltip.start());
        widget.onMouseLeave(() => tooltip.stop());
    }
    WebMolKit.addTooltip = addTooltip;
    function raiseToolTip(parent, avoid, bodyHTML, titleHTML) {
        if (parent.jquery)
            parent = parent[0];
        clearTooltip();
        Tooltip.ensureGlobal();
        new Tooltip(WebMolKit.dom(parent), bodyHTML, titleHTML, 0).raise(avoid);
    }
    WebMolKit.raiseToolTip = raiseToolTip;
    function clearTooltip() {
        if (globalTooltip == null)
            return;
        globalPopWatermark++;
        globalTooltip.lower();
    }
    WebMolKit.clearTooltip = clearTooltip;
    class Tooltip {
        constructor(widget, bodyHTML, titleHTML, delay) {
            this.widget = widget;
            this.bodyHTML = bodyHTML;
            this.titleHTML = titleHTML;
            this.delay = delay;
        }
        static ensureGlobal() {
            if (globalPopover == null) {
                globalPopover = WebMolKit.dom('<div/>').css({ 'position': 'absolute', 'z-index': 22000, 'display': 'none' });
                globalPopover.css({ 'background-color': '#F0F0FF', 'background-image': 'linear-gradient(to right bottom, #FFFFFF, #D0D0FF)' });
                globalPopover.css({ 'color': 'black', 'border': '1px solid black', 'border-radius': '4px' });
                globalPopover.appendTo(document.body);
            }
        }
        start() {
            globalPopover.setCSS('display', 'none');
            this.watermark = ++globalPopWatermark;
            window.setTimeout(() => {
                if (this.watermark == globalPopWatermark)
                    this.raise();
            }, this.delay);
        }
        stop() {
            if (this.watermark == globalPopWatermark)
                this.lower();
            globalPopWatermark++;
        }
        raise(avoid) {
            if (!this.widget.exists())
                return;
            globalTooltip = this;
            let pop = globalPopover;
            pop.css({ 'max-width': '20em' });
            pop.empty();
            let div = WebMolKit.dom('<div/>').appendTo(pop).css({ 'padding': '0.3em' });
            let hasTitle = this.titleHTML != null && this.titleHTML.length > 0, hasBody = this.bodyHTML != null && this.bodyHTML.length > 0;
            if (hasTitle)
                WebMolKit.dom('<div/>').appendTo(div).setHTML('<b>' + this.titleHTML + '</b>');
            if (hasTitle && hasBody)
                div.appendHTML('<hr/>');
            if (hasBody)
                WebMolKit.dom('<div/>').appendTo(div).setHTML(this.bodyHTML);
            let winW = window.innerWidth, winH = window.innerHeight;
            const GAP = 2;
            let boundDiv = this.widget.el.getBoundingClientRect();
            let wx1 = boundDiv.left, wy1 = boundDiv.top;
            let wx2 = wx1 + boundDiv.width, wy2 = wy1 + boundDiv.height;
            if (avoid) {
                wx1 += avoid.x;
                wy1 += avoid.y;
                wx2 = wx1 + avoid.w;
                wy2 = wy1 + avoid.h;
            }
            let setPosition = () => {
                let popW = pop.width(), popH = pop.height();
                let posX = 0, posY = 0;
                if (wx1 + popW < winW)
                    posX = wx1;
                else if (popW < wx2)
                    posX = wx2 - popW;
                if (wy2 + GAP + popH < winH)
                    posY = wy2 + GAP;
                else if (wy1 - GAP - popH > 0)
                    posY = wy1 - GAP - popH;
                else
                    posY = wy2 + GAP;
                posX += window.pageXOffset;
                posY += window.pageYOffset;
                pop.css({ 'left': `${posX}px`, 'top': `${posY}px` });
            };
            setPosition();
            pop.setCSS('display', 'block');
            setTimeout(() => setPosition(), 1);
            let checkParent = () => {
                if (this.watermark != globalPopWatermark)
                    return;
                if (!this.widget.isVisible())
                    pop.setCSS('display', 'none');
                else
                    setTimeout(checkParent, 100);
            };
            setTimeout(checkParent, 100);
        }
        lower() {
            let pop = globalPopover;
            pop.setCSS('display', 'none');
        }
    }
    WebMolKit.Tooltip = Tooltip;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    const CSS_WEBMENU = `
	*.wmk-webmenubar
	{
		font-family: 'Open Sans', sans-serif;
		background-color: black;
		color: white;
		width: 100%;
	}
	*.wmk-webmenudrop
	{
		font-family: 'Open Sans', sans-serif;
		background-color: rgba(0,0,0,0.7);
		color: white;
	}
	*.wmk-webmenuitem
	{
		font-family: 'Open Sans', sans-serif;
		color: white;
		padding: 0 0.5em 0 0.5em;
	}
	*.wmk-webmenuitem:hover
	{
		background-color: #0000FF;
		cursor: pointer;
	}
`;
    class WebMenu extends WebMolKit.Widget {
        constructor(barItems) {
            super();
            this.barItems = barItems;
            this.topItems = [];
            if (!WebMolKit.hasInlineCSS('webmenu'))
                WebMolKit.installInlineCSS('webmenu', CSS_WEBMENU);
        }
        render(parent) {
            super.render(parent);
            this.content.addClass('wmk-webmenubar');
            for (let item of this.barItems) {
                let dom = $('<span></span>').appendTo(this.content);
                dom.addClass('wmk-webmenuitem');
                dom.text(item.label ? item.label : '?');
                dom.click((event) => { this.activateMenu(dom, item); event.preventDefault(); });
                dom.dblclick((event) => event.preventDefault());
            }
        }
        activateMenu(parent, item) {
            if (item.click) {
                item.click();
                return;
            }
            if (WebMolKit.Vec.len(item.submenu) == 0) {
                return;
            }
            let wx1 = parent.offset().left, wy1 = parent.offset().top;
            let wx2 = wx1 + parent.width(), wy2 = wy1 + parent.height();
            let menuX = 0, menuY = 0;
            if (this.obscureBackground) {
                menuX = wx2;
                menuY = wy1;
            }
            else {
                menuX = wx1;
                menuY = wy2;
                let bg = this.obscureBackground = $('<span></span>').appendTo($(document.documentElement));
                bg.css('width', '100%');
                bg.css('height', document.documentElement.clientHeight + 'px');
                bg.css('position', 'absolute');
                bg.css('left', 0);
                bg.css('top', 0);
                bg.css('z-index', 9999);
                bg.click(() => this.deactivateMenu());
                bg.show();
                this.obscureBackground = bg;
            }
            let container = $('<div></div>');
            container.addClass('wmk-webmenudrop');
            container.css('position', 'absolute');
            container.css('left', `${menuX}px`);
            container.css('top', `${menuY}px`);
            for (let subitem of item.submenu) {
                let dom = $('<div></div>').appendTo(container);
                dom.addClass('wmk-webmenuitem');
                dom.text(subitem.label ? subitem.label : '?');
                dom.click((event) => { this.activateMenu(dom, subitem); event.preventDefault(); });
                dom.dblclick((event) => event.preventDefault());
            }
            this.obscureBackground.append(container);
        }
        deactivateMenu() {
            this.obscureBackground.remove();
            this.obscureBackground = null;
        }
    }
    WebMolKit.WebMenu = WebMenu;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class GeomUtil {
        static pointInPolygon(x, y, px, py) {
            if (x < WebMolKit.minArray(px) || x > WebMolKit.maxArray(px) || y < WebMolKit.minArray(py) || y > WebMolKit.maxArray(py))
                return false;
            let sz = px.length;
            for (let n = 0; n < sz; n++)
                if (px[n] == x && py[n] == y)
                    return true;
            let phase = false;
            for (let n = 0; n < sz; n++) {
                let x1 = px[n], y1 = py[n], x2 = px[n + 1 < sz ? n + 1 : 0], y2 = py[n + 1 < sz ? n + 1 : 0];
                if (y > Math.min(y1, y2) && y <= Math.max(y1, y2) && x <= Math.max(x1, x2) && y1 != y2) {
                    let intr = (y - y1) * (x2 - x1) / (y2 - y1) + x1;
                    if (x1 == x2 || x <= intr)
                        phase = !phase;
                }
            }
            return phase;
        }
        static areLinesParallel(x1, y1, x2, y2, x3, y3, x4, y4) {
            let dxa = x2 - x1, dxb = x4 - x3, dya = y2 - y1, dyb = y4 - y3;
            return (WebMolKit.realEqual(dxa, dxb) && WebMolKit.realEqual(dya, dyb)) || (WebMolKit.realEqual(dxa, -dxb) && WebMolKit.realEqual(dya, -dyb));
        }
        static lineIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
            let u = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
            return [x1 + u * (x2 - x1), y1 + u * (y2 - y1)];
        }
        static isPointOnLineSeg(px, py, x1, y1, x2, y2) {
            if (px < Math.min(x1, x2) || px > Math.max(x1, x2) || py < Math.min(y1, y2) || py > Math.max(y1, y2))
                return false;
            if ((px == x1 && py == y1) || (px == x2 && py == y2))
                return true;
            let dx = x2 - x1, dy = y2 - y1;
            if (Math.abs(dx) > Math.abs(dy))
                return WebMolKit.realEqual(py, (dy / dx) * (px - x1) + y1);
            else
                return WebMolKit.realEqual(px, (dx / dy) * (py - y1) + x1);
        }
        static pointLineDistance(px, py, x1, y1, x2, y2) {
            let dx = x2 - x1, dy = y2 - y1;
            return Math.abs(dy * px - dx * py + x2 * y1 - y2 * x1) / WebMolKit.norm_xy(dx, dy);
        }
        static pointLineSegDistance(px, py, x1, y1, x2, y2) {
            let dx = x2 - x1, dy = y2 - y1;
            let t = ((px - x1) * dx + (py - y1) * dy) / WebMolKit.norm2_xy(dx, dy);
            t = Math.max(0, Math.min(1, t));
            let tx = x1 + t * dx, ty = y1 + t * dy;
            return WebMolKit.norm_xy(px - tx, py - ty);
        }
        static doLineSegsIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
            if (Math.max(x1, x2) < Math.min(x3, x4) || Math.max(y1, y2) < Math.min(y3, y4))
                return false;
            if (Math.min(x1, x2) > Math.max(x3, x4) || Math.min(y1, y2) > Math.max(y3, y4))
                return false;
            if ((x1 == x3 && y1 == y3) || (x1 == x4 && y1 == y4) || (x2 == x3 && y2 == y3) || (x2 == x4 && y2 == y4))
                return true;
            if ((x1 == x2 || x3 == x4) && (x1 == x3 || x1 == x4 || x2 == x3 || x2 == x4))
                return true;
            if ((y1 == y2 || y3 == y4) && (y1 == y3 || y1 == y4 || y2 == y3 || y2 == y4))
                return true;
            let x4_x3 = x4 - x3, y4_y3 = y4 - y3, x2_x1 = x2 - x1, y2_y1 = y2 - y1, x1_x3 = x1 - x3, y1_y3 = y1 - y3;
            let nx = x4_x3 * y1_y3 - y4_y3 * x1_x3;
            let ny = x2_x1 * y1_y3 - y2_y1 * x1_x3;
            let dn = y4_y3 * x2_x1 - x4_x3 * y2_y1;
            if (dn == 0)
                return false;
            if (dn < 0) {
                dn = -dn;
                nx = -nx;
                ny = -ny;
            }
            return nx >= 0 && nx <= dn && ny >= 0 && ny <= dn;
        }
        static rectsIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
            if (x1 <= x2 && x1 + w1 >= x2 + w2 && y1 <= y2 && y1 + h1 >= y2 + h2)
                return true;
            if (x2 <= x1 && x2 + w2 >= x1 + w1 && y2 <= y1 && y2 + h2 >= y1 + h1)
                return true;
            if (x1 + w1 < x2 || x2 + w2 < x1 || y1 + h1 < y2 || y2 + h2 < y1)
                return false;
            return true;
        }
        static sortAngles(theta) {
            if (theta == null || theta.length < 2)
                return theta;
            theta = theta.slice(0);
            for (let n = 0; n < theta.length; n++)
                theta[n] = WebMolKit.angleNorm(theta[n]);
            if (theta.length == 2) {
                if (WebMolKit.angleDiffPos(theta[1], theta[0]) > Math.PI)
                    return [theta[1], theta[0]];
                return theta;
            }
            WebMolKit.Vec.sort(theta);
            while (true) {
                let a = theta[theta.length - 1], b = theta[0], c = theta[1];
                if (WebMolKit.angleDiff(b, a) <= WebMolKit.angleDiff(c, b))
                    break;
                for (let n = theta.length - 1; n > 0; n--)
                    theta[n] = theta[n - 1];
                theta[0] = a;
            }
            return theta;
        }
        static idxSortAngles(theta) {
            const sz = WebMolKit.Vec.len(theta);
            if (theta == null || sz < 2)
                return WebMolKit.Vec.identity0(sz);
            if (sz == 2) {
                if (WebMolKit.angleDiffPos(theta[1], theta[0]) > Math.PI)
                    return [1, 0];
                else
                    return [0, 1];
            }
            theta = WebMolKit.Vec.duplicate(theta);
            for (let n = 0; n < sz; n++)
                theta[n] = WebMolKit.angleNorm(theta[n]);
            let idx = WebMolKit.Vec.idxSort(theta);
            while (true) {
                let a = theta[idx[sz - 1]], b = theta[idx[0]], c = theta[idx[1]];
                if (WebMolKit.angleDiff(b, a) <= WebMolKit.angleDiff(c, b))
                    break;
                let last = idx.pop();
                idx.unshift(last);
            }
            return idx;
        }
        static uniqueAngles(theta, threshold) {
            let ang = GeomUtil.sortAngles(theta), ret = [];
            ret.push(ang[0]);
            for (let n = 1; n < ang.length; n++) {
                if (Math.abs(WebMolKit.angleDiff(ang[n], ang[n - 1])) > threshold)
                    ret.push(ang[n]);
            }
            return ret;
        }
        static thetaObtuse(th1, th2) {
            let dth = th2 - th1;
            while (dth < -Math.PI)
                dth += 2 * Math.PI;
            while (dth > Math.PI)
                dth -= 2 * Math.PI;
            return dth > 0 ? th1 - 0.5 * (2 * Math.PI - dth) : th1 + 0.5 * (2 * Math.PI + dth);
        }
        static emergentAngle(theta) {
            let len = theta.length;
            if (len == 1)
                return theta[0];
            if (len == 2)
                return 0.5 * (theta[0] + theta[1]);
            WebMolKit.Vec.sort(theta);
            let bottom = 0;
            let behind = WebMolKit.angleDiffPos(theta[0], theta[len - 1]);
            for (let n = 1; n < len; n++) {
                let delta = WebMolKit.angleDiffPos(theta[n], theta[n - 1]);
                if (delta > behind) {
                    bottom = n;
                    behind = delta;
                }
            }
            let sum = 0;
            for (let n = 0; n < len; n++) {
                let delta = theta[n] - theta[bottom];
                if (delta < 0)
                    delta += WebMolKit.TWOPI;
                sum += delta;
            }
            return sum / len + theta[bottom];
        }
        static dotProduct(v1, v2) {
            return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
        }
        static crossProduct(v1, v2) {
            const x = v1[1] * v2[2] - v1[2] * v2[1];
            const y = v1[2] * v2[0] - v1[0] * v2[2];
            const z = v1[0] * v2[1] - v1[1] * v2[0];
            return [x, y, z];
        }
        static affineTranslate(dx, dy) {
            return [[1, 0, dx], [0, 1, dy], [0, 0, 1]];
        }
        static affineMirror(xaxis, yaxis) {
            return [[xaxis ? -1 : 1, 0, 0], [0, yaxis ? -1 : 1, 0], [0, 0, 1]];
        }
        static affineScale(sx, sy) {
            return [[sx, 0, 0], [0, sy, 0], [0, 0, 1]];
        }
        static affineRotate(theta) {
            let cos = Math.cos(theta), sin = Math.sin(theta);
            return [[cos, -sin, 0], [sin, cos, 0], [0, 0, 1]];
        }
        static affineCompose(A, B) {
            let tfm = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
            let Acol = [0, 0, 0];
            for (let j = 0; j < 3; j++) {
                for (let k = 0; k < 3; k++)
                    Acol[k] = A[k][j];
                for (let i = 0; i < 3; i++) {
                    let Brow = B[i];
                    let s = 0;
                    for (let k = 0; k < 3; k++)
                        s += Acol[k] * Brow[k];
                    tfm[i][j] = s;
                }
            }
            return tfm;
        }
        static applyAffine(x, y, tfm) {
            return [x * tfm[0][0] + y * tfm[0][1] + tfm[0][2], x * tfm[1][0] + y * tfm[1][1] + tfm[1][2]];
        }
        static isAffineMirror(tfm) {
            let a = tfm[0][0], b = tfm[0][1], c = tfm[0][2];
            let d = tfm[1][0], e = tfm[1][1], f = tfm[1][2];
            let g = tfm[2][0], h = tfm[2][1], i = tfm[2][2];
            return a * e * i + b * f * g + c * d * h - c * e * g - b * d * i - a * f * h < 0;
        }
        static magnitude2(v) {
            return v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
        }
        static magnitude(v) {
            return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
        }
        static dist2(v1, v2) {
            let dx = v1[0] - v2[0], dy = v1[1] - v2[1], dz = v1[2] - v2[2];
            return dx * dx + dy * dy + dz * dz;
        }
        static dist(v1, v2) {
            let dx = v1[0] - v2[0], dy = v1[1] - v2[1], dz = v1[2] - v2[2];
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }
        static normalise(v) {
            const dsq = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
            if (dsq == 0)
                return;
            const inv = 1.0 / Math.sqrt(dsq);
            v[0] *= inv;
            v[1] *= inv;
            v[2] *= inv;
        }
        static normalised(v) {
            let ret = v.slice(0);
            this.normalise(ret);
            return ret;
        }
        static acuteAngle(v1, v2) {
            let mag1 = this.magnitude(v1), mag2 = this.magnitude(v2);
            if (mag1 == 0 || mag2 == 0)
                return 0;
            let dot = this.dotProduct(v1, v2);
            let cosTheta = dot / (mag1 * mag2);
            cosTheta = Math.max(-1, Math.min(1, cosTheta));
            return Math.acos(cosTheta);
        }
        static arcControlPoints(rad, x1, y1, x2, y2) {
            let t1x = -y1, t1y = x1;
            let t2x = y2, t2y = -x2;
            let dx = 0.5 * (x1 + x2);
            let dy = 0.5 * (y1 + y2);
            let tx = 3 / 8 * (t1x + t2x);
            let ty = 3 / 8 * (t1y + t2y);
            let a = tx * tx + ty * ty;
            let b = dx * tx + dy * ty;
            let c = dx * dx + dy * dy - rad * rad;
            let D = b * b - a * c;
            let k = (Math.sqrt(D) - b) / a;
            return [x1 + k * t1x, y1 + k * t1y, x2 + k * t2x, y2 + k * t2y];
        }
        static fitCircle(x, y) {
            let dsq = Number.POSITIVE_INFINITY;
            for (let n = 0; n < x.length; n++)
                dsq = Math.min(dsq, WebMolKit.norm2_xy(x[n], y[n]));
            return Math.sqrt(dsq);
        }
        static fitEllipse(px, py, minX, minY, maxX, maxY) {
            let bestW = 0.5 * this.fitCircle(px, py), bestH = bestW, bestScore = bestW * bestH;
            let x = WebMolKit.Vec.concat(px, [minX, maxX, 0, 0]);
            let y = WebMolKit.Vec.concat(py, [0, 0, minY, maxY]);
            const sz = x.length;
            let shrinkToFit = (whs) => {
                let dmin = Number.POSITIVE_INFINITY;
                let invW2 = 1.0 / (whs[0] * whs[0]), invH2 = 1.0 / (whs[1] * whs[1]);
                for (let n = 0; n < sz; n++)
                    dmin = Math.min(dmin, Math.sqrt(x[n] * x[n] * invW2 + y[n] * y[n] * invH2));
                if (dmin < 1) {
                    whs[0] *= dmin;
                    whs[1] *= dmin;
                }
                whs[2] = whs[0] * whs[1];
            };
            let mul = 1;
            let whsX = [0, 0, 0], whsY = [0, 0, 0];
            while (mul > 0.001) {
                whsX[0] = bestW * (1 + mul);
                whsX[1] = bestH;
                shrinkToFit(whsX);
                whsY[0] = bestW;
                whsY[1] = bestH * (1 + mul);
                shrinkToFit(whsY);
                let anything = false;
                if (whsX[2] > bestScore) {
                    bestW = whsX[0];
                    bestH = whsX[1];
                    bestScore = whsX[2];
                    anything = true;
                }
                if (whsY[2] > bestScore) {
                    bestW = whsY[0];
                    bestH = whsY[1];
                    bestScore = whsY[2];
                    anything = true;
                }
                if (!anything)
                    mul *= 0.6;
            }
            return [bestW, bestH];
        }
        static superimpose(ax, ay, bx, by) {
            let sz = ax.length;
            if (sz == 1) {
                let dx = bx[0] - ax[0], dy = by[0] - ay[0];
                return [[1, 0, dx], [0, 1, dy], [0, 0, 1]];
            }
            if (sz == 2) {
                let thetaA = Math.atan2(ay[1] - ay[0], ax[1] - ax[0]), thetaB = Math.atan2(by[1] - by[0], bx[1] - bx[0]);
                let delta = WebMolKit.angleDiff(thetaB, thetaA), cos = Math.cos(delta), sin = Math.sin(delta);
                let rot00 = cos, rot01 = -sin;
                let rot10 = sin, rot11 = cos;
                let acx = 0.5 * (ax[0] + ax[1]), acy = 0.5 * (ay[0] + ay[1]);
                let bcx = 0.5 * (bx[0] + bx[1]), bcy = 0.5 * (by[0] + by[1]);
                let rax = rot00 * acx + rot01 * acy;
                let ray = rot10 * acx + rot11 * acy;
                return [[rot00, rot01, bcx - rax], [rot10, rot11, bcy - ray], [0, 0, 1]];
            }
            let invsz = 1.0 / sz;
            let acx = WebMolKit.Vec.sum(ax) * invsz, acy = WebMolKit.Vec.sum(ay) * invsz;
            let bcx = WebMolKit.Vec.sum(bx) * invsz, bcy = WebMolKit.Vec.sum(by) * invsz;
            let mtxA = new WebMolKit.Matrix(3, sz), mtxB = new WebMolKit.Matrix(3, sz);
            for (let n = 0; n < sz; n++) {
                mtxA.set(0, n, ax[n] - acx);
                mtxA.set(1, n, ay[n] - acy);
                mtxA.set(2, n, 0);
                mtxB.set(0, n, bx[n] - bcx);
                mtxB.set(1, n, by[n] - bcy);
                mtxB.set(2, n, 0);
            }
            let cov = mtxA.times(mtxB.transpose());
            let svd = new WebMolKit.SingularValueDecomposition(cov);
            let rotate = svd.getV().times(svd.getU().transpose());
            let rot00 = rotate.get(0, 0), rot01 = rotate.get(0, 1);
            let rot10 = rotate.get(1, 0), rot11 = rotate.get(1, 1);
            let rax = rot00 * acx + rot01 * acy;
            let ray = rot10 * acx + rot11 * acy;
            return [[rot00, rot01, bcx - rax], [rot10, rot11, bcy - ray], [0, 0, 1]];
        }
        static convexHull(x, y, flatness) {
            let algo = new QuickHull(x, y, WebMolKit.sqr(flatness * 0.1));
            return [algo.hullX, algo.hullY];
        }
        static outlinePolygon(x, y, diameter) {
            let del = new WebMolKit.Triangulation2D(x, y);
            let concave = del.trimConcave(diameter);
            let idx = del.traceOutline(concave);
            return [WebMolKit.Vec.idxGet(x, idx), WebMolKit.Vec.idxGet(y, idx)];
        }
    }
    WebMolKit.GeomUtil = GeomUtil;
    class QuickHull {
        constructor(x, y, threshSq) {
            this.x = x;
            this.y = y;
            this.threshSq = threshSq;
            this.hsz = 0;
            this.hullX = [];
            this.hullY = [];
            const sz = x.length;
            let l = 0, r = 0;
            for (let n = 0; n < sz; n++) {
                if (x[r] > x[n] || (x[r] == x[n] && y[r] > y[n]))
                    r = n;
                if (x[l] < x[n] || (x[l] == x[n] && y[l] < y[n]))
                    l = n;
            }
            let al1 = [], al2 = [];
            for (let n = 0; n < sz; n++) {
                if (n != l && n != r) {
                    if (this.right(r, l, n) > 0)
                        al1.push(n);
                    else
                        al2.push(n);
                }
            }
            this.hullX.push(x[r]);
            this.hullY.push(y[r]);
            this.quickHull(r, l, al1);
            this.hullX.push(x[l]);
            this.hullY.push(y[l]);
            this.quickHull(l, r, al2);
            for (let n = 0; n < this.hullX.length - 1;) {
                if (WebMolKit.norm2_xy(this.hullX[n] - this.hullY[n + 1], this.hullY[n] - this.hullY[n + 1]) < threshSq) {
                    this.hullX.splice(n + 1, 1);
                    this.hullY.splice(n + 1, 1);
                }
                else
                    n++;
            }
        }
        quickHull(a, b, al) {
            if (al.length == 0)
                return;
            let c = this.furthestPoint(a, b, al);
            let al1 = [], al2 = [];
            for (let n = 0; n < al.length; n++) {
                let p = al[n];
                if (p == a || p == b)
                    continue;
                if (this.right(a, c, p) > 0)
                    al1.push(p);
                else if (this.right(c, b, p) > 0)
                    al2.push(p);
            }
            this.quickHull(a, c, al1);
            this.hullX.push(this.x[c]);
            this.hullY.push(this.y[c]);
            this.quickHull(c, b, al2);
        }
        right(a, b, p) {
            const x = this.x, y = this.y;
            return (x[a] - x[b]) * (y[p] - y[b]) - (x[p] - x[b]) * (y[a] - y[b]);
        }
        distance(a, b, p) {
            const x = this.x, y = this.y;
            let u = ((x[p] - x[a]) * (x[b] - x[a]) + (y[p] - y[a]) * (y[b] - y[a])) / ((x[b] - x[a]) * (x[b] - x[a]) + (y[b] - y[a]) * (y[b] - y[a]));
            let ux = x[a] + u * (x[b] - x[a]);
            let uy = y[a] + u * (y[b] - y[a]);
            return ((ux - x[p]) * (ux - x[p]) + (uy - y[p]) * (uy - y[p]));
        }
        furthestPoint(a, b, al) {
            let maxDist = -1;
            let maxPos = -1;
            for (let n = 0; n < al.length; n++) {
                let p = al[n];
                if (p == a || p == b)
                    continue;
                let dist = this.distance(a, b, p);
                if (dist > maxDist) {
                    maxDist = dist;
                    maxPos = p;
                }
            }
            return maxPos;
        }
    }
    WebMolKit.QuickHull = QuickHull;
    class RollingBall {
        constructor(x, y, diameter) {
            this.x = x;
            this.y = y;
            this.sequence = [];
            const sz = x.length;
            const threshSq = diameter * diameter;
            let first = WebMolKit.Vec.idxMax(x), latest = first;
            let direction = 0.0;
            let visited = WebMolKit.Vec.booleanArray(false, sz);
            this.sequence.push(first);
            let roll = () => {
                let bestIdx = -1;
                let bestDelta = 0, bestTheta = 0;
                for (let n = 0; n < sz; n++)
                    if (n != latest && !visited[n]) {
                        let dx = x[n] - x[latest], dy = y[n] - y[latest];
                        let dsq = WebMolKit.norm2_xy(dx, dy);
                        if (dsq == 0 || dsq > threshSq)
                            continue;
                        let theta = Math.atan2(dy, dx), delta = WebMolKit.angleDiffPos(theta, direction);
                        if (bestIdx < 0 || delta < bestDelta) {
                            bestIdx = n;
                            bestDelta = delta;
                            bestTheta = theta;
                        }
                    }
                if (bestIdx < 0)
                    return -1;
                direction = WebMolKit.angleNorm(bestTheta - 0.5 * Math.PI);
                visited[bestIdx] = true;
                return bestIdx;
            };
            while (true) {
                let next = roll();
                if (next < 0) {
                    this.sequence = null;
                    return;
                }
                if (next == first)
                    break;
                this.sequence.push(next);
                latest = next;
            }
        }
        sequencePos() {
            if (!this.sequence)
                return null;
            let posList = [];
            for (let n of this.sequence)
                posList.push(new Pos(this.x[n], this.y[n]));
            return posList;
        }
        sequenceXY() {
            if (!this.sequence)
                return [null, null];
            let px = [], py = [];
            for (let n of this.sequence) {
                px.push(this.x[n]);
                py.push(this.y[n]);
            }
            return [px, py];
        }
    }
    WebMolKit.RollingBall = RollingBall;
    class Pos {
        constructor(x, y) {
            this.x = x == null ? 0 : x;
            this.y = y == null ? 0 : y;
        }
        static zero() { return new Pos(); }
        static fromArray(src) { return new Pos(src[0], src[1]); }
        clone() { return new Pos(this.x, this.y); }
        equals(other) { return this.x == other.x && this.y == other.y; }
        scaleBy(mag) {
            if (mag == 1)
                return;
            this.x *= mag;
            this.y *= mag;
        }
        offsetBy(dx, dy) {
            this.x += dx;
            this.y += dy;
        }
        withScaleBy(mag) {
            return new Pos(this.x * mag, this.y * mag);
        }
        withOffsetBy(dx, dy) {
            return new Pos(this.x + dx, this.y + dy);
        }
        toString() { return '[' + this.x + ',' + this.y + ']'; }
    }
    WebMolKit.Pos = Pos;
    class Size {
        constructor(w, h) {
            this.w = w == null ? 0 : w;
            this.h = h == null ? 0 : h;
        }
        static zero() { return new Size(); }
        static fromArray(src) { return new Size(src[0], src[1]); }
        clone() { return new Size(this.w, this.h); }
        equals(other) { return this.w == other.w && this.h == other.h; }
        isZero() { return this.w == 0 && this.h == 0; }
        scaleBy(mag) {
            if (mag == 1)
                return;
            this.w *= mag;
            this.h *= mag;
        }
        fitInto(maxW, maxH) {
            let scale = 1;
            if (this.w > maxW)
                scale = maxW / this.w;
            if (this.h > maxH)
                scale = Math.min(scale, maxH / this.h);
            if (scale < 1)
                this.scaleBy(scale);
        }
        withScaleBy(mag) {
            return new Size(this.w * mag, this.h * mag);
        }
        toString() { return '[' + this.w + ',' + this.h + ']'; }
    }
    WebMolKit.Size = Size;
    class Box {
        constructor(x, y, w, h) {
            this.x = x == null ? 0 : x;
            this.y = y == null ? 0 : y;
            this.w = w == null ? 0 : w;
            this.h = h == null ? 0 : h;
        }
        static zero() { return new Box(); }
        static fromSize(sz) { return new Box(0, 0, sz.w, sz.h); }
        static fromOval(oval) { return new Box(oval.cx - oval.rw, oval.cy - oval.rh, 2 * oval.rw, 2 * oval.rh); }
        static fromArray(src) { return new Box(src[0], src[1], src[2], src[3]); }
        clone() { return new Box(this.x, this.y, this.w, this.h); }
        equals(other) { return this.x == other.x && this.y == other.y && this.w == other.w && this.h == other.h; }
        getPos() { return new Pos(this.x, this.y); }
        setPos(pos) {
            this.x = pos.x;
            this.y = pos.y;
        }
        getSize() { return new Size(this.w, this.h); }
        setSize(sz) {
            this.w = sz.w;
            this.h = sz.h;
        }
        isZero() { return this.w == 0 && this.h == 0; }
        minX() { return this.x; }
        minY() { return this.y; }
        midX() { return this.x + 0.5 * this.w; }
        midY() { return this.y + 0.5 * this.h; }
        maxX() { return this.x + this.w; }
        maxY() { return this.y + this.h; }
        area() { return this.w * this.h; }
        scaleBy(mag) {
            if (mag == 1)
                return;
            this.x *= mag;
            this.y *= mag;
            this.w *= mag;
            this.h *= mag;
        }
        offsetBy(dx, dy) {
            this.x += dx;
            this.y += dy;
        }
        grow(bx, by) {
            this.x -= bx;
            this.y -= by;
            this.w += 2 * bx;
            this.h += 2 * by;
        }
        withScaleBy(mag) {
            return new Box(this.x * mag, this.y * mag, this.w * mag, this.h * mag);
        }
        withOffsetBy(dx, dy) {
            return new Box(this.x + dx, this.y + dy, this.w, this.h);
        }
        withGrow(bx, by) {
            return new Box(this.x - bx, this.y - by, this.w + 2 * bx, this.h + 2 * by);
        }
        intersects(other) {
            return GeomUtil.rectsIntersect(this.x, this.y, this.w, this.h, other.x, other.y, other.w, other.h);
        }
        intersection(other) {
            let x1 = this.x, x2 = x1 + this.w, y1 = this.y, y2 = y1 + this.h;
            let x3 = other.x, x4 = x3 + other.w, y3 = other.y, y4 = y3 + other.h;
            let x5 = Math.max(x1, x3), y5 = Math.max(y1, y3), x6 = Math.min(x2, x4), y6 = Math.min(y2, y4);
            return new Box(x5, y5, x6 - x5, y6 - y5);
        }
        contains(x, y) {
            return x >= this.x && x < this.x + this.w && y >= this.y && y < this.y + this.h;
        }
        union(other) {
            let x1 = Math.min(this.x, other.x), x2 = Math.max(this.x + this.w, other.x + other.w);
            let y1 = Math.min(this.y, other.y), y2 = Math.max(this.y + this.h, other.y + other.h);
            return new Box(x1, y1, x2 - x1, y2 - y1);
        }
        isEmpty() { return this.w == 0 && this.h == 0; }
        notEmpty() { return this.w > 0 || this.h > 0; }
        toString() { return '[' + this.x + ',' + this.y + ';' + this.w + ',' + this.h + ']'; }
    }
    WebMolKit.Box = Box;
    class Oval {
        constructor(cx, cy, rw, rh) {
            this.cx = cx == null ? 0 : cx;
            this.cy = cy == null ? 0 : cy;
            this.rw = rw == null ? 0 : rw;
            this.rh = rh == null ? 0 : rh;
        }
        static zero() { return new Oval(); }
        static fromBox(box) { return new Oval(box.x + 0.5 * box.w, box.y + 0.5 * box.h, 0.5 * box.w, 0.5 * box.h); }
        static fromArray(src) { return new Oval(src[0], src[1], src[2], src[3]); }
        clone() { return new Oval(this.cx, this.cy, this.rw, this.rh); }
        setCentre(pos) {
            this.cx = pos.x;
            this.cy = pos.y;
        }
        setRadius(sz) {
            this.rw = sz.w;
            this.rh = sz.h;
        }
        minX() { return this.cx - this.rw; }
        minY() { return this.cy - this.rh; }
        maxX() { return this.cx + this.rw; }
        maxY() { return this.cy + this.rh; }
        scaleBy(mag) {
            if (mag == 1)
                return;
            this.cx *= mag;
            this.cy *= mag;
            this.rw *= mag;
            this.rh *= mag;
        }
        offsetBy(dx, dy) {
            this.cx += dx;
            this.cy += dy;
        }
        withScaleBy(mag) {
            return new Oval(this.cx * mag, this.cy * mag, this.rw * mag, this.rh * mag);
        }
        withOffsetBy(dx, dy) {
            return new Oval(this.cx + dx, this.cy + dy, this.rw, this.rh);
        }
        toString() { return '[' + this.cx + ',' + this.cy + ';' + this.rw + ',' + this.rh + ']'; }
    }
    WebMolKit.Oval = Oval;
    class Line {
        constructor(x1, y1, x2, y2) {
            this.x1 = x1 == null ? 0 : x1;
            this.y1 = y1 == null ? 0 : y1;
            this.x2 = x2 == null ? 0 : x2;
            this.y2 = y2 == null ? 0 : y2;
        }
        static zero() { return new Line(); }
        clone() { return new Line(this.x1, this.y1, this.x2, this.y2); }
        setPos1(pos) {
            this.x1 = pos.x;
            this.y1 = pos.y;
        }
        setPos2(pos) {
            this.x2 = pos.x;
            this.y2 = pos.y;
        }
        minX() { return Math.min(this.x1, this.x2); }
        minY() { return Math.min(this.y1, this.y2); }
        maxX() { return Math.max(this.x1, this.x2); }
        maxY() { return Math.max(this.y1, this.y2); }
        scaleBy(mag) {
            if (mag == 1)
                return;
            this.x1 *= mag;
            this.y1 *= mag;
            this.x2 *= mag;
            this.y2 *= mag;
        }
        offsetBy(dx, dy) {
            this.x1 += dx;
            this.y1 += dy;
            this.x2 += dx;
            this.y2 += dy;
        }
        toString() { return '[' + this.x1 + ',' + this.y1 + ';' + this.x2 + ',' + this.y2 + ']'; }
    }
    WebMolKit.Line = Line;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class Matrix {
        constructor(m, n, s = 0) {
            this.m = m;
            this.n = n;
            if (m == 0)
                return;
            this.A = new Array(m);
            for (let i = 0; i < m; i++)
                this.A[i] = WebMolKit.Vec.numberArray(s, n);
        }
        static fromArray(A) {
            let mtx = new Matrix(0, 0);
            mtx.A = A;
            mtx.m = A.length;
            mtx.n = A[0].length;
            return mtx;
        }
        clone() {
            const { A, m, n } = this;
            let mtx = new Matrix(m, n);
            for (let i = 0; i < m; i++)
                for (let j = 0; j < n; j++)
                    mtx.A[i][j] = A[i][j];
            return mtx;
        }
        get numRows() { return this.m; }
        get numCols() { return this.n; }
        get(i, j) { return this.A[i][j]; }
        set(i, j, v) { this.A[i][j] = v; }
        transpose() {
            const { A, m, n } = this;
            let X = new Matrix(n, m);
            const C = X.A;
            for (let i = 0; i < m; i++)
                for (let j = 0; j < n; j++)
                    C[j][i] = A[i][j];
            return X;
        }
        norm1() {
            const { A, m, n } = this;
            let f = 0;
            for (let j = 0; j < n; j++) {
                let s = 0;
                for (let i = 0; i < m; i++)
                    s += Math.abs(A[i][j]);
                f = Math.max(f, s);
            }
            return f;
        }
        normInf() {
            const { A, m, n } = this;
            let f = 0;
            for (let i = 0; i < m; i++) {
                let s = 0;
                for (let j = 0; j < n; j++)
                    s += Math.abs(A[i][j]);
                f = Math.max(f, s);
            }
            return f;
        }
        uminus() {
            const { A, m, n } = this;
            let X = new Matrix(m, n), C = X.A;
            for (let i = 0; i < m; i++)
                for (let j = 0; j < n; j++)
                    C[i][j] = -A[i][j];
            return X;
        }
        plus(B) {
            const { A, m, n } = this;
            let X = new Matrix(m, n), C = X.A;
            for (let i = 0; i < m; i++)
                for (let j = 0; j < n; j++)
                    C[i][j] = A[i][j] + B.A[i][j];
            return X;
        }
        plusEquals(B) {
            const { A, m, n } = this;
            for (let i = 0; i < m; i++)
                for (let j = 0; j < n; j++)
                    A[i][j] = A[i][j] + B.A[i][j];
            return this;
        }
        minus(B) {
            const { A, m, n } = this;
            let X = new Matrix(m, n), C = A;
            for (let i = 0; i < m; i++)
                for (let j = 0; j < n; j++)
                    C[i][j] = A[i][j] - B.A[i][j];
            return X;
        }
        minusEquals(B) {
            const { A, m, n } = this;
            for (let i = 0; i < m; i++)
                for (let j = 0; j < n; j++)
                    A[i][j] = A[i][j] - B.A[i][j];
            return this;
        }
        arrayTimes(B) {
            const { A, m, n } = this;
            let X = new Matrix(m, n), C = X.A;
            for (let i = 0; i < m; i++)
                for (let j = 0; j < n; j++)
                    C[i][j] = A[i][j] * B.A[i][j];
            return X;
        }
        arrayTimesEquals(B) {
            const { A, m, n } = this;
            for (let i = 0; i < m; i++)
                for (let j = 0; j < n; j++)
                    A[i][j] = A[i][j] * B.A[i][j];
            return this;
        }
        arrayRightDivide(B) {
            const { A, m, n } = this;
            let X = new Matrix(m, n), C = X.A;
            for (let i = 0; i < m; i++)
                for (let j = 0; j < n; j++)
                    C[i][j] = A[i][j] / B.A[i][j];
            return X;
        }
        arrayRightDivideEquals(B) {
            const { A, m, n } = this;
            for (let i = 0; i < m; i++)
                for (let j = 0; j < n; j++)
                    A[i][j] = A[i][j] / B.A[i][j];
            return this;
        }
        arrayLeftDivide(B) {
            const { A, m, n } = this;
            let X = new Matrix(m, n), C = X.A;
            for (let i = 0; i < m; i++)
                for (let j = 0; j < n; j++)
                    C[i][j] = B.A[i][j] / A[i][j];
            return X;
        }
        arrayLeftDivideEquals(B) {
            const { A, m, n } = this;
            for (let i = 0; i < m; i++)
                for (let j = 0; j < n; j++)
                    A[i][j] = B.A[i][j] / A[i][j];
            return this;
        }
        scalarTimes(s) {
            const { A, m, n } = this;
            let X = new Matrix(m, n), C = X.A;
            for (let i = 0; i < m; i++)
                for (let j = 0; j < n; j++)
                    C[i][j] = s * A[i][j];
            return X;
        }
        scalarTimesEquals(s) {
            const { A, m, n } = this;
            for (let i = 0; i < m; i++)
                for (let j = 0; j < n; j++)
                    A[i][j] = s * A[i][j];
            return this;
        }
        times(B) {
            const { A, m, n } = this;
            let X = new Matrix(m, B.n);
            let C = X.A, Bcolj = new Array(n);
            for (let j = 0; j < B.n; j++) {
                for (let k = 0; k < n; k++)
                    Bcolj[k] = B.A[k][j];
                for (let i = 0; i < m; i++) {
                    let Arowi = A[i];
                    let s = 0;
                    for (let k = 0; k < n; k++)
                        s += Arowi[k] * Bcolj[k];
                    C[i][j] = s;
                }
            }
            return X;
        }
        rank() {
            return new SingularValueDecomposition(this).rank();
        }
        cond() {
            return new SingularValueDecomposition(this).cond();
        }
        trace() {
            const { A, m, n } = this;
            let t = 0;
            for (let i = 0; i < Math.min(m, n); i++) {
                t += A[i][i];
            }
            return t;
        }
        static identity(m, n) {
            let mtx = new Matrix(m, n);
            let A = mtx.A;
            for (let i = 0; i < m; i++)
                for (let j = 0; j < n; j++)
                    A[i][j] = (i == j ? 1.0 : 0.0);
            return mtx;
        }
        toString() {
            let lines = ['['];
            for (let row of this.A)
                lines.push(JSON.stringify(row));
            lines.push(']');
            return lines.join('\n');
        }
    }
    WebMolKit.Matrix = Matrix;
    class SingularValueDecomposition {
        constructor(mtx) {
            let A = mtx.A;
            let m = this.m = mtx.m;
            let n = this.n = mtx.n;
            let nu = Math.min(m, n);
            let s = this.s = new Array(Math.min(m + 1, n));
            let U = this.U = new Array(m);
            let V = this.V = new Array(n);
            for (let i = 0; i < m; i++)
                U[i] = WebMolKit.Vec.numberArray(0, nu);
            for (let j = 0; j < n; j++)
                V[j] = WebMolKit.Vec.numberArray(0, n);
            let e = new Array(n);
            let work = new Array(m);
            let wantu = true, wantv = true;
            let nct = Math.min(m - 1, n);
            let nrt = Math.max(0, Math.min(n - 2, m));
            for (let k = 0; k < Math.max(nct, nrt); k++) {
                if (k < nct) {
                    s[k] = 0;
                    for (let i = k; i < m; i++)
                        s[k] = SingularValueDecomposition.hypot(s[k], A[i][k]);
                    if (s[k] != 0.0) {
                        if (A[k][k] < 0.0)
                            s[k] = -s[k];
                        for (let i = k; i < m; i++)
                            A[i][k] /= s[k];
                        A[k][k] += 1.0;
                    }
                    s[k] = -s[k];
                }
                for (let j = k + 1; j < n; j++) {
                    if ((k < nct) && (s[k] != 0.0)) {
                        let t = 0;
                        for (let i = k; i < m; i++)
                            t += A[i][k] * A[i][j];
                        t = -t / A[k][k];
                        for (let i = k; i < m; i++)
                            A[i][j] += t * A[i][k];
                    }
                    e[j] = A[k][j];
                }
                if (wantu && (k < nct)) {
                    for (let i = k; i < m; i++)
                        U[i][k] = A[i][k];
                }
                if (k < nrt) {
                    e[k] = 0;
                    for (let i = k + 1; i < n; i++)
                        e[k] = SingularValueDecomposition.hypot(e[k], e[i]);
                    if (e[k] != 0.0) {
                        if (e[k + 1] < 0.0)
                            e[k] = -e[k];
                        for (let i = k + 1; i < n; i++)
                            e[i] /= e[k];
                        e[k + 1] += 1.0;
                    }
                    e[k] = -e[k];
                    if ((k + 1 < m) && (e[k] != 0.0)) {
                        for (let i = k + 1; i < m; i++)
                            work[i] = 0.0;
                        for (let j = k + 1; j < n; j++)
                            for (let i = k + 1; i < m; i++)
                                work[i] += e[j] * A[i][j];
                        for (let j = k + 1; j < n; j++) {
                            let t = -e[j] / e[k + 1];
                            for (let i = k + 1; i < m; i++)
                                A[i][j] += t * work[i];
                        }
                    }
                    if (wantv) {
                        for (let i = k + 1; i < n; i++)
                            V[i][k] = e[i];
                    }
                }
            }
            let p = Math.min(n, m + 1);
            if (nct < n)
                s[nct] = A[nct][nct];
            if (m < p)
                s[p - 1] = 0.0;
            if (nrt + 1 < p)
                e[nrt] = A[nrt][p - 1];
            e[p - 1] = 0.0;
            if (wantu) {
                for (let j = nct; j < nu; j++) {
                    for (let i = 0; i < m; i++)
                        U[i][j] = 0.0;
                    U[j][j] = 1.0;
                }
                for (let k = nct - 1; k >= 0; k--) {
                    if (s[k] != 0.0) {
                        for (let j = k + 1; j < nu; j++) {
                            let t = 0;
                            for (let i = k; i < m; i++)
                                t += U[i][k] * U[i][j];
                            t = -t / U[k][k];
                            for (let i = k; i < m; i++)
                                U[i][j] += t * U[i][k];
                        }
                        for (let i = k; i < m; i++)
                            U[i][k] = -U[i][k];
                        U[k][k] = 1.0 + U[k][k];
                        for (let i = 0; i < k - 1; i++)
                            U[i][k] = 0.0;
                    }
                    else {
                        for (let i = 0; i < m; i++)
                            U[i][k] = 0.0;
                        U[k][k] = 1.0;
                    }
                }
            }
            if (wantv) {
                for (let k = n - 1; k >= 0; k--) {
                    if ((k < nrt) && (e[k] != 0.0)) {
                        for (let j = k + 1; j < nu; j++) {
                            let t = 0;
                            for (let i = k + 1; i < n; i++)
                                t += V[i][k] * V[i][j];
                            t = -t / V[k + 1][k];
                            for (let i = k + 1; i < n; i++)
                                V[i][j] += t * V[i][k];
                        }
                    }
                    for (let i = 0; i < n; i++)
                        V[i][k] = 0.0;
                    V[k][k] = 1.0;
                }
            }
            let pp = p - 1;
            let iter = 0;
            let eps = Math.pow(2.0, -52.0);
            let tiny = Math.pow(2.0, -966.0);
            while (p > 0) {
                let k, kase;
                for (k = p - 2; k >= -1; k--) {
                    if (k == -1)
                        break;
                    if (Math.abs(e[k]) <= tiny + eps * (Math.abs(s[k]) + Math.abs(s[k + 1]))) {
                        e[k] = 0.0;
                        break;
                    }
                }
                if (k == p - 2) {
                    kase = 4;
                }
                else {
                    let ks;
                    for (ks = p - 1; ks >= k; ks--) {
                        if (ks == k)
                            break;
                        let t = (ks != p ? Math.abs(e[ks]) : 0.) + (ks != k + 1 ? Math.abs(e[ks - 1]) : 0.);
                        if (Math.abs(s[ks]) <= tiny + eps * t) {
                            s[ks] = 0.0;
                            break;
                        }
                    }
                    if (ks == k)
                        kase = 3;
                    else if (ks == p - 1)
                        kase = 1;
                    else {
                        kase = 2;
                        k = ks;
                    }
                }
                k++;
                if (kase == 1) {
                    let f = e[p - 2];
                    e[p - 2] = 0.0;
                    for (let j = p - 2; j >= k; j--) {
                        let t = SingularValueDecomposition.hypot(s[j], f);
                        let cs = s[j] / t;
                        let sn = f / t;
                        s[j] = t;
                        if (j != k) {
                            f = -sn * e[j - 1];
                            e[j - 1] = cs * e[j - 1];
                        }
                        if (wantv) {
                            for (let i = 0; i < n; i++) {
                                t = cs * V[i][j] + sn * V[i][p - 1];
                                V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];
                                V[i][j] = t;
                            }
                        }
                    }
                }
                else if (kase == 2) {
                    let f = e[k - 1];
                    e[k - 1] = 0.0;
                    for (let j = k; j < p; j++) {
                        let t = SingularValueDecomposition.hypot(s[j], f);
                        let cs = s[j] / t;
                        let sn = f / t;
                        s[j] = t;
                        f = -sn * e[j];
                        e[j] = cs * e[j];
                        if (wantu) {
                            for (let i = 0; i < m; i++) {
                                t = cs * U[i][j] + sn * U[i][k - 1];
                                U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];
                                U[i][j] = t;
                            }
                        }
                    }
                }
                else if (kase == 3) {
                    let scale = Math.max(Math.max(Math.max(Math.max(Math.abs(s[p - 1]), Math.abs(s[p - 2])), Math.abs(e[p - 2])), Math.abs(s[k])), Math.abs(e[k]));
                    let sp = s[p - 1] / scale;
                    let spm1 = s[p - 2] / scale;
                    let epm1 = e[p - 2] / scale;
                    let sk = s[k] / scale;
                    let ek = e[k] / scale;
                    let b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;
                    let c = (sp * epm1) * (sp * epm1);
                    let shift = 0.0;
                    if ((b != 0.0) || (c != 0.0)) {
                        shift = Math.sqrt(b * b + c);
                        if (b < 0.0)
                            shift = -shift;
                        shift = c / (b + shift);
                    }
                    let f = (sk + sp) * (sk - sp) + shift;
                    let g = sk * ek;
                    for (let j = k; j < p - 1; j++) {
                        let t = SingularValueDecomposition.hypot(f, g);
                        let cs = f / t;
                        let sn = g / t;
                        if (j != k)
                            e[j - 1] = t;
                        f = cs * s[j] + sn * e[j];
                        e[j] = cs * e[j] - sn * s[j];
                        g = sn * s[j + 1];
                        s[j + 1] = cs * s[j + 1];
                        if (wantv) {
                            for (let i = 0; i < n; i++) {
                                t = cs * V[i][j] + sn * V[i][j + 1];
                                V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];
                                V[i][j] = t;
                            }
                        }
                        t = SingularValueDecomposition.hypot(f, g);
                        cs = f / t;
                        sn = g / t;
                        s[j] = t;
                        f = cs * e[j] + sn * s[j + 1];
                        s[j + 1] = -sn * e[j] + cs * s[j + 1];
                        g = sn * e[j + 1];
                        e[j + 1] = cs * e[j + 1];
                        if (wantu && (j < m - 1)) {
                            for (let i = 0; i < m; i++) {
                                t = cs * U[i][j] + sn * U[i][j + 1];
                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];
                                U[i][j] = t;
                            }
                        }
                    }
                    e[p - 2] = f;
                    iter = iter + 1;
                }
                else if (kase == 4) {
                    if (s[k] <= 0.0) {
                        s[k] = (s[k] < 0.0 ? -s[k] : 0.0);
                        if (wantv) {
                            for (let i = 0; i <= pp; i++)
                                V[i][k] = -V[i][k];
                        }
                    }
                    while (k < pp) {
                        if (s[k] >= s[k + 1])
                            break;
                        let t = s[k];
                        s[k] = s[k + 1];
                        s[k + 1] = t;
                        if (wantv && (k < n - 1)) {
                            for (let i = 0; i < n; i++) {
                                t = V[i][k + 1];
                                V[i][k + 1] = V[i][k];
                                V[i][k] = t;
                            }
                        }
                        if (wantu && (k < m - 1)) {
                            for (let i = 0; i < m; i++) {
                                t = U[i][k + 1];
                                U[i][k + 1] = U[i][k];
                                U[i][k] = t;
                            }
                        }
                        k++;
                    }
                    iter = 0;
                    p--;
                }
            }
        }
        getU() {
            return Matrix.fromArray(this.U);
        }
        getV() {
            return Matrix.fromArray(this.V);
        }
        getSingularValues() {
            return this.s;
        }
        getS() {
            const { n } = this;
            let X = new Matrix(n, n, 0);
            let S = X.A;
            for (let i = 0; i < n; i++)
                S[i][i] = this.s[i];
            return X;
        }
        norm2() {
            return this.s[0];
        }
        cond() {
            const { m, n, s } = this;
            return s[0] / s[Math.min(m, n) - 1];
        }
        rank() {
            const { m, n, s } = this;
            let eps = Math.pow(2.0, -52.0);
            let tol = Math.max(m, n) * s[0] * eps;
            let r = 0;
            for (let i = 0; i < s.length; i++)
                if (s[i] > tol)
                    r++;
            return r;
        }
        static hypot(a, b) {
            let r;
            if (Math.abs(a) > Math.abs(b)) {
                r = b / a;
                r = Math.abs(a) * Math.sqrt(1 + r * r);
            }
            else if (b != 0) {
                r = a / b;
                r = Math.abs(b) * Math.sqrt(1 + r * r);
            }
            else {
                r = 0.0;
            }
            return r;
        }
    }
    WebMolKit.SingularValueDecomposition = SingularValueDecomposition;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class Random {
        constructor(seed = null) {
            this.seed = seed;
            this.m = 0x8000000;
            this.invMN = 1.0 / (this.m - 1);
            this.a = 1103515245;
            this.c = 5425153011;
            if (seed == null)
                this.state = Math.floor(Math.random() * (this.m - 1));
            else
                this.state = seed;
        }
        next() {
            this.state = (this.a * this.state + this.c) % this.m;
            return this.state;
        }
        int(max) {
            return max <= 0 ? 0 : this.next() % max;
        }
        float() {
            return this.next() * this.invMN;
        }
        index(arr) {
            if (WebMolKit.Vec.isBlank(arr))
                return null;
            return this.int(arr.length);
        }
        peek(arr) {
            if (WebMolKit.Vec.isBlank(arr))
                return null;
            return arr[this.int(arr.length)];
        }
        pull(arr) {
            if (WebMolKit.Vec.isBlank(arr))
                return null;
            let idx = this.int(arr.length), val = arr[idx];
            arr.splice(idx, 1);
            return val;
        }
    }
    WebMolKit.Random = Random;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class Theme {
    }
    Theme.BASE_URL = null;
    Theme.RESOURCE_URL = null;
    Theme.foreground = 0x000000;
    Theme.background = 0xFFFFFF;
    Theme.lowlight = 0x24D0D0;
    Theme.lowlightEdge1 = 0x47D5D2;
    Theme.lowlightEdge2 = 0x008FD1;
    Theme.highlight = 0x00FF00;
    Theme.highlightEdge1 = 0x00CA59;
    Theme.highlightEdge2 = 0x008650;
    Theme.error = 0xFF0000;
    WebMolKit.Theme = Theme;
    function initWebMolKit(resourcePath) {
        Theme.RESOURCE_URL = resourcePath;
        try {
            let _ = document;
        }
        catch (e) {
            return;
        }
        if (document)
            installInlineCSS('main', composeMainCSS());
    }
    WebMolKit.initWebMolKit = initWebMolKit;
    let cssTagsInstalled = new Set();
    function hasInlineCSS(tag) { return cssTagsInstalled.has(tag); }
    WebMolKit.hasInlineCSS = hasInlineCSS;
    function installInlineCSS(tag, css) {
        if (cssTagsInstalled.has(tag))
            return false;
        let el = document.createElement('style');
        el.innerHTML = css;
        document.head.appendChild(el);
        cssTagsInstalled.add(tag);
        return true;
    }
    WebMolKit.installInlineCSS = installInlineCSS;
    function composeMainCSS() {
        let lowlight = WebMolKit.colourCode(Theme.lowlight), lowlightEdge1 = WebMolKit.colourCode(Theme.lowlightEdge1), lowlightEdge2 = WebMolKit.colourCode(Theme.lowlightEdge2);
        let highlight = WebMolKit.colourCode(Theme.highlight), highlightEdge1 = WebMolKit.colourCode(Theme.highlightEdge1), highlightEdge2 = WebMolKit.colourCode(Theme.highlightEdge2);
        return `
		.wmk-button
		{
			display: inline-block;
			padding: 6px 12px;
			margin-bottom: 0;
			font-family: 'Open Sans', sans-serif;
			font-size: 14px;
			font-weight: normal;
			line-height: 1.42857143;
			text-align: center;
			white-space: nowrap;
			vertical-align: middle;
			cursor: pointer;
			background-image: none;
			border: 1px solid transparent;
			border-radius: 4px;
			-ms-touch-action: manipulation; touch-action: manipulation;
			-webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
		}
		.wmk-button:focus,
		.wmk-button:active:focus,
		.wmk-button.active:focus,
		.wmk-button.focus,
		.wmk-button:active.focus,
		.wmk-button.active.focus
		{
			outline: thin dotted;
			outline: 5px auto -webkit-focus-ring-color;
			outline-offset: -2px;
		}
		.wmk-button:hover,
		.wmk-button:focus,
		.wmk-button.focus
		{
			color: #333;
			text-decoration: none;
		}
		.wmk-button:active,
		.wmk-button.active
		{
			background-image: none;
			outline: 0;
			-webkit-box-shadow: inset 0 3px 5px rgba(0, 0, 0, .125);
			box-shadow: inset 0 3px 5px rgba(0, 0, 0, .125);
		}
		.wmk-button.disabled,
		.wmk-button[disabled],
		fieldset[disabled] .wmk-button
		{
			cursor: not-allowed;
			filter: alpha(opacity=65);
			-webkit-box-shadow: none;
			box-shadow: none;
			opacity: .65;
		}
		a.wmk-button.disabled,
		fieldset[disabled] a.wmk-button
		{
			pointer-events: none;
		}

		/* shrunken button */

		.wmk-button-small
		{
			padding: 2px 4px;
			line-height: 1;
			font-size: 12px;
		}

		/* default button */

		.wmk-button-default
		{
			color: #333;
			background-color: #fff;
			background-image: linear-gradient(to right bottom, #FFFFFF, #E0E0E0);
			border-color: #ccc;
		}
		.wmk-button-default:focus,
		.wmk-button-default.focus
		{
			color: #333;
			background-color: #e6e6e6;
			border-color: #8c8c8c;
		}
		.wmk-button-default:hover
		{
			color: #333;
			background-color: #e6e6e6;
			border-color: #adadad;
		}
		.wmk-button-default:active,
		.wmk-button-default.active,
		.open > .dropdown-toggle.wmk-button-default
		{
			color: #333;
			background-color: #e6e6e6;
			border-color: #adadad;
		}
		.wmk-button-default:active:hover,
		.wmk-button-default.active:hover,
		.open > .dropdown-toggle.wmk-button-default:hover,
		.wmk-button-default:active:focus,
		.wmk-button-default.active:focus,
		.open > .dropdown-toggle.wmk-button-default:focus,
		.wmk-button-default:active.focus,
		.wmk-button-default.active.focus,
		.open > .dropdown-toggle.wmk-button-default.focus
		{
			color: #333;
			background-color: #d4d4d4;
			border-color: #8c8c8c;
		}
		.wmk-button-default:active,
		.wmk-button-default.active,
		.open > .dropdown-toggle.wmk-button-default
		{
			background-image: none;
		}
		.wmk-button-default.disabled:hover,
		.wmk-button-default[disabled]:hover,
		fieldset[disabled] .wmk-button-default:hover,
		.wmk-button-default.disabled:focus,
		.wmk-button-default[disabled]:focus,
		fieldset[disabled] .wmk-button-default:focus,
		.wmk-button-default.disabled.focus,
		.wmk-button-default[disabled].focus,
		fieldset[disabled] .wmk-button-default.focus
		{
			background-color: #fff;
			border-color: #ccc;
		}
		.wmk-button-default .badge
		{
			color: #fff;
			background-color: #333;
		}

		/* primary button */

		.wmk-button-primary
		{
			color: #fff;
			background-color: #008FD2;
			background-image: linear-gradient(to right bottom, ${lowlightEdge1}, ${lowlightEdge2});
			border-color: #00C0C0;
		}
		.wmk-button-primary:focus,
		.wmk-button-primary.focus
		{
			color: #fff;
			background-color: ${lowlight};
			border-color: #122b40;
		}
		.wmk-button-primary:hover
		{
			color: #fff;
			background-color: #286090;
			border-color: #204d74;
		}
		.wmk-button-primary:active,
		.wmk-button-primary.active,
		.open > .dropdown-toggle.wmk-button-primary
		{
			color: #fff;
			background-color: #286090;
			border-color: #20744d;
		}
		.wmk-button-primary:active:hover,
		.wmk-button-primary.active:hover,
		.open > .dropdown-toggle.wmk-button-primary:hover,
		.wmk-button-primary:active:focus,
		.wmk-button-primary.active:focus,
		.open > .dropdown-toggle.wmk-button-primary:focus,
		.wmk-button-primary:active.focus,
		.wmk-button-primary.active.focus,
		.open > .dropdown-toggle.wmk-button-primary.focus
		{
			color: #fff;
			background-color: ${highlight};
			background-image: linear-gradient(to right bottom, ${highlightEdge1}, ${highlightEdge2});
			border-color: #12802b;
		}
		.wmk-button-primary:active,
		.wmk-button-primary.active,
		.open > .dropdown-toggle.wmk-button-primary
		{
			background-image: none;
		}
		.wmk-button-primary.disabled:hover,
		.wmk-button-primary[disabled]:hover,
		fieldset[disabled] .wmk-button-primary:hover,
		.wmk-button-primary.disabled:focus,
		.wmk-button-primary[disabled]:focus,
		fieldset[disabled] .wmk-button-primary:focus,
		.wmk-button-primary.disabled.focus,
		.wmk-button-primary[disabled].focus,
		fieldset[disabled] .wmk-button-primary.focus
		{
			background-color: #337ab7;
			border-color: #2ea46d;
		}
		.wmk-button-primary .badge
		{
			color: #337ab7;
			background-color: #fff;
		}
	`;
    }
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    const EPSILON = Math.pow(2, -52);
    class Triangulation2D {
        constructor(px, py) {
            this.px = px;
            this.py = py;
            this.numTriangles = 0;
            this.edgeStack = WebMolKit.Vec.numberArray(0, 512);
            this.hull = null;
            this.px = px;
            this.py = py;
            this.sz = px.length;
            let maxTriangles = Math.max(2 * this.sz - 5, 0);
            this.triangles = new Array(maxTriangles * 3);
            this.halfedges = new Array(maxTriangles * 3);
            this.hashSize = Math.ceil(Math.sqrt(this.sz));
            this.hullPrev = new Array(this.sz);
            this.hullNext = new Array(this.sz);
            this.hullTri = new Array(this.sz);
            this.hullHash = WebMolKit.Vec.numberArray(-1, this.hashSize);
            this.ids = new Array(this.sz);
            this.dists = new Array(this.sz);
            this.update();
        }
        trimConcave(threshold) {
            const threshSq = WebMolKit.sqr(threshold);
            const { sz, px, py } = this;
            let tri = this.triangles.slice(0);
            let edgeCount = new Map();
            while (true) {
                const ntri = tri.length / 3;
                edgeCount.clear();
                for (let n = 0, i = 0; n < ntri; n++, i += 3) {
                    const e1 = sz * Math.min(tri[i + 0], tri[i + 1]) + Math.max(tri[i + 0], tri[i + 1]);
                    const e2 = sz * Math.min(tri[i + 0], tri[i + 2]) + Math.max(tri[i + 0], tri[i + 2]);
                    const e3 = sz * Math.min(tri[i + 1], tri[i + 2]) + Math.max(tri[i + 1], tri[i + 2]);
                    edgeCount.set(e1, (edgeCount.get(e1) || 0) + 1);
                    edgeCount.set(e2, (edgeCount.get(e2) || 0) + 1);
                    edgeCount.set(e3, (edgeCount.get(e3) || 0) + 1);
                }
                let mask = WebMolKit.Vec.booleanArray(true, ntri);
                for (let n = 0, i = 0; n < ntri; n++, i += 3) {
                    const i1 = tri[i], i2 = tri[i + 1], i3 = tri[i + 2];
                    const e1 = sz * Math.min(i1, i2) + Math.max(i1, i2);
                    const e2 = sz * Math.min(i1, i3) + Math.max(i1, i3);
                    const e3 = sz * Math.min(i2, i3) + Math.max(i2, i3);
                    const c1 = edgeCount.get(e1), c2 = edgeCount.get(e2), c3 = edgeCount.get(e3);
                    if (c1 == 1 && c2 != 1 && c3 != 1)
                        mask[n] = WebMolKit.norm2_xy(px[i1] - px[i2], py[i1] - py[i2]) < threshSq;
                    else if (c1 != 1 && c2 == 1 && c3 != 1)
                        mask[n] = WebMolKit.norm2_xy(px[i1] - px[i3], py[i1] - py[i3]) < threshSq;
                    else if (c1 != 1 && c2 != 1 && c3 == 1)
                        mask[n] = WebMolKit.norm2_xy(px[i2] - px[i3], py[i2] - py[i3]) < threshSq;
                }
                if (WebMolKit.Vec.allTrue(mask))
                    break;
                let rep = new Array(WebMolKit.Vec.maskCount(mask) * 3);
                for (let n = 0, i = 0, j = 0; n < ntri; n++, i += 3)
                    if (mask[n]) {
                        rep[j++] = tri[i];
                        rep[j++] = tri[i + 1];
                        rep[j++] = tri[i + 2];
                    }
                tri = rep;
            }
            return tri;
        }
        traceOutline(tri) {
            const ntri = tri.length / 3;
            const { sz, px, py } = this;
            let edgeCount = new Map();
            for (let n = 0, i = 0; n < ntri; n++, i += 3) {
                const e1 = sz * Math.min(tri[i + 0], tri[i + 1]) + Math.max(tri[i + 0], tri[i + 1]);
                const e2 = sz * Math.min(tri[i + 0], tri[i + 2]) + Math.max(tri[i + 0], tri[i + 2]);
                const e3 = sz * Math.min(tri[i + 1], tri[i + 2]) + Math.max(tri[i + 1], tri[i + 2]);
                edgeCount.set(e1, (edgeCount.get(e1) || 0) + 1);
                edgeCount.set(e2, (edgeCount.get(e2) || 0) + 1);
                edgeCount.set(e3, (edgeCount.get(e3) || 0) + 1);
            }
            let edges = [];
            for (let entry of edgeCount.entries())
                if (entry[1] == 1) {
                    const e = entry[0];
                    const i1 = Math.floor(e / sz), i2 = e % sz;
                    edges.push(i1);
                    edges.push(i2);
                }
            const idx = WebMolKit.Vec.uniqueUnstable(edges);
            const isz = idx.length;
            const idxMap = new Map();
            for (let n = 0; n < isz; n++)
                idxMap.set(idx[n], n);
            let g1 = WebMolKit.Vec.numberArray(-1, isz), g2 = WebMolKit.Vec.numberArray(-1, isz);
            for (let n = 0; n < edges.length; n += 2) {
                const i1 = idxMap.get(edges[n]), i2 = idxMap.get(edges[n + 1]);
                if (g1[i1] < 0)
                    g1[i1] = i2;
                else
                    g2[i1] = i2;
                if (g1[i2] < 0)
                    g1[i2] = i1;
                else
                    g2[i2] = i1;
            }
            let mask = WebMolKit.Vec.booleanArray(false, isz);
            let sequence = new Array(isz);
            sequence[0] = 0;
            mask[0] = true;
            for (let n = 1; n < isz; n++) {
                const i = sequence[n - 1];
                if (!mask[g1[i]])
                    sequence[n] = g1[i];
                else
                    sequence[n] = g2[i];
                mask[sequence[n]] = true;
            }
            return WebMolKit.Vec.idxGet(idx, sequence);
        }
        update() {
            const sz = this.sz;
            let { px, py, ids, dists, triangles, halfedges } = this;
            const minX = WebMolKit.Vec.min(px), minY = WebMolKit.Vec.min(py);
            const maxX = WebMolKit.Vec.max(px), maxY = WebMolKit.Vec.max(py);
            for (let n = 0; n < sz; n++)
                ids[n] = n;
            this.centreX = 0.5 * (minX + maxX);
            this.centreY = 0.5 * (minY + maxY);
            let i0 = 0, i1 = 0, i2 = 0;
            let minDist = Number.POSITIVE_INFINITY;
            for (let n = 0; n < sz; n++) {
                const d = WebMolKit.norm_xy(this.centreX - px[n], this.centreY - py[n]);
                if (d < minDist) {
                    i0 = n;
                    minDist = d;
                }
            }
            const i0x = px[i0], i0y = py[i0];
            minDist = Number.POSITIVE_INFINITY;
            for (let n = 0; n < sz; n++) {
                if (n == i0)
                    continue;
                const d = WebMolKit.norm_xy(i0x - px[n], i0y - py[n]);
                if (d < minDist && d > 0) {
                    i1 = n;
                    minDist = d;
                }
            }
            let i1x = px[i1], i1y = py[i1];
            let minRadius = Number.POSITIVE_INFINITY;
            for (let n = 0; n < sz; n++) {
                if (n == i0 || n == i1)
                    continue;
                let r = this.circumRadius(i0x, i0y, i1x, i1y, px[n], py[n]);
                if (r < minRadius) {
                    i2 = n;
                    minRadius = r;
                }
            }
            let i2x = px[i2], i2y = py[i2];
            if (!Number.isFinite(minRadius)) {
                for (let n = 0; n < sz; n++) {
                    dists[n] = px[n] - px[0];
                    if (dists[n] == 0)
                        dists[n] = py[n] - py[0];
                }
                this.quicksort(0, sz - 1);
                let hull = new Array(sz);
                let j = 0;
                let d0 = Number.NEGATIVE_INFINITY;
                for (let n = 0; n < sz; n++) {
                    let id = ids[n];
                    if (dists[id] > d0) {
                        hull[j++] = id;
                        d0 = dists[id];
                    }
                }
                this.hull = hull.slice(0, j);
                triangles = [];
                halfedges = [];
                return;
            }
            if (this.orient(i0x, i0y, i1x, i1y, i2x, i2y)) {
                let i = i1;
                let x = i1x, y = i1y;
                i1 = i2;
                i1x = i2x;
                i1y = i2y;
                i2 = i;
                i2x = x;
                i2y = y;
            }
            this.pickCircumCentre(i0x, i0y, i1x, i1y, i2x, i2y);
            for (let n = 0; n < sz; n++)
                dists[n] = WebMolKit.norm_xy(px[n] - this.centreX, py[n] - this.centreY);
            this.quicksort(0, sz - 1);
            this.hullStart = i0;
            let hullSize = 3;
            const { hullNext, hullPrev, hullTri, hullHash, hashSize } = this;
            hullNext[i0] = hullPrev[i2] = i1;
            hullNext[i1] = hullPrev[i0] = i2;
            hullNext[i2] = hullPrev[i1] = i0;
            hullTri[i0] = 0;
            hullTri[i1] = 1;
            hullTri[i2] = 2;
            hullHash.fill(-1);
            hullHash[this.hashKey(i0x, i0y)] = i0;
            hullHash[this.hashKey(i1x, i1y)] = i1;
            hullHash[this.hashKey(i2x, i2y)] = i2;
            this.numTriangles = 0;
            this.addTriangle(i0, i1, i2, -1, -1, -1);
            let xp = 0, yp = 0;
            for (let k = 0; k < ids.length; k++) {
                let i = ids[k];
                let x = px[i], y = py[i];
                if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON)
                    continue;
                xp = x;
                yp = y;
                if (i == i0 || i == i1 || i == i2)
                    continue;
                let start = 0;
                for (let j = 0, key = this.hashKey(x, y); j < hashSize; j++) {
                    start = hullHash[(key + j) % hashSize];
                    if (start >= 0 && start != hullNext[start])
                        break;
                }
                start = hullPrev[start];
                let e = start, q = hullNext[e];
                while (!this.orient(x, y, px[e], py[e], px[q], py[q])) {
                    e = q;
                    if (e == start) {
                        e = -1;
                        break;
                    }
                    q = hullNext[e];
                }
                if (e < 0)
                    continue;
                let t = this.addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);
                hullTri[i] = this.legalise(t + 2);
                hullTri[e] = t;
                hullSize++;
                let n = hullNext[e];
                q = hullNext[n];
                while (this.orient(x, y, px[n], py[n], px[q], py[q])) {
                    t = this.addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);
                    hullTri[i] = this.legalise(t + 2);
                    hullNext[n] = n;
                    hullSize--;
                    n = q;
                    q = hullNext[n];
                }
                if (e == start) {
                    q = hullPrev[e];
                    while (this.orient(x, y, px[q], py[q], px[e], py[e])) {
                        t = this.addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
                        this.legalise(t + 2);
                        hullTri[q] = t;
                        hullNext[e] = e;
                        hullSize--;
                        e = q;
                        q = hullPrev[e];
                    }
                }
                this.hullStart = hullPrev[i] = e;
                hullNext[e] = hullPrev[n] = i;
                hullNext[i] = n;
                hullHash[this.hashKey(x, y)] = i;
                hullHash[this.hashKey(px[e], py[e])] = e;
            }
            this.hull = new Array(hullSize);
            for (let n = 0, e = this.hullStart; n < hullSize; n++) {
                this.hull[n] = e;
                e = hullNext[e];
            }
            this.triangles = triangles.slice(0, this.numTriangles);
            this.halfedges = halfedges.slice(0, this.numTriangles);
        }
        hashKey(x, y) {
            return Math.floor(this.pseudoAngle(x - this.centreX, y - this.centreY) * this.hashSize) % this.hashSize;
        }
        legalise(a) {
            let i = 0;
            let ar = 0;
            while (true) {
                let b = this.halfedges[a];
                let a0 = a - a % 3;
                ar = a0 + (a + 2) % 3;
                if (b < 0) {
                    if (i == 0)
                        break;
                    a = this.edgeStack[--i];
                    continue;
                }
                const b0 = b - b % 3;
                const al = a0 + (a + 1) % 3;
                const bl = b0 + (b + 2) % 3;
                const { px, py, triangles, halfedges } = this;
                const p0 = triangles[ar];
                const pr = triangles[a];
                const pl = triangles[al];
                const p1 = triangles[bl];
                let illegal = this.inCircle(px[p0], py[p0], px[pr], py[pr], px[pl], py[pl], px[p1], py[p1]);
                if (illegal) {
                    this.triangles[a] = p1;
                    this.triangles[b] = p0;
                    const hbl = halfedges[bl];
                    if (hbl < 0) {
                        let e = this.hullStart;
                        do {
                            if (this.hullTri[e] == bl) {
                                this.hullTri[e] = a;
                                break;
                            }
                            e = this.hullPrev[e];
                        } while (e != this.hullStart);
                    }
                    this.link(a, hbl);
                    this.link(b, halfedges[ar]);
                    this.link(ar, bl);
                    const br = b0 + (b + 1) % 3;
                    if (i < this.edgeStack.length)
                        this.edgeStack[i++] = br;
                }
                else {
                    if (i == 0)
                        break;
                    a = this.edgeStack[--i];
                }
            }
            return ar;
        }
        link(a, b) {
            this.halfedges[a] = b;
            if (b >= 0)
                this.halfedges[b] = a;
        }
        addTriangle(i0, i1, i2, a, b, c) {
            const t = this.numTriangles;
            this.triangles[t] = i0;
            this.triangles[t + 1] = i1;
            this.triangles[t + 2] = i2;
            this.link(t, a);
            this.link(t + 1, b);
            this.link(t + 2, c);
            this.numTriangles += 3;
            return t;
        }
        pseudoAngle(dx, dy) {
            const p = dx / (Math.abs(dx) + Math.abs(dy));
            return (dy > 0 ? 3 - p : 1 + p) / 4;
        }
        orientIfSure(px, py, rx, ry, qx, qy) {
            const l = (ry - py) * (qx - px);
            const r = (rx - px) * (qy - py);
            return Math.abs(l - r) >= 3.3306690738754716e-16 * Math.abs(l + r) ? l - r : 0;
        }
        orient(rx, ry, qx, qy, px, py) {
            let o = this.orientIfSure(px, py, rx, ry, qx, qy);
            if (o != 0)
                return o < 0;
            o = this.orientIfSure(rx, ry, qx, qy, px, py);
            if (o != 0)
                return o < 0;
            o = this.orientIfSure(qx, qy, px, py, rx, ry);
            return o < 0;
        }
        inCircle(ax, ay, bx, by, cx, cy, px, py) {
            const dx = ax - px;
            const dy = ay - py;
            const ex = bx - px;
            const ey = by - py;
            const fx = cx - px;
            const fy = cy - py;
            const ap = dx * dx + dy * dy;
            const bp = ex * ex + ey * ey;
            const cp = fx * fx + fy * fy;
            return dx * (ey * cp - bp * fy) -
                dy * (ex * cp - bp * fx) +
                ap * (ex * fy - ey * fx) < 0;
        }
        circumRadius(ax, ay, bx, by, cx, cy) {
            const dx = bx - ax;
            const dy = by - ay;
            const ex = cx - ax;
            const ey = cy - ay;
            const bl = dx * dx + dy * dy;
            const cl = ex * ex + ey * ey;
            const d = 0.5 / (dx * ey - dy * ex);
            const x = (ey * bl - dy * cl) * d;
            const y = (dx * cl - ex * bl) * d;
            return x * x + y * y;
        }
        pickCircumCentre(ax, ay, bx, by, cx, cy) {
            const dx = bx - ax;
            const dy = by - ay;
            const ex = cx - ax;
            const ey = cy - ay;
            const bl = dx * dx + dy * dy;
            const cl = ex * ex + ey * ey;
            const d = 0.5 / (dx * ey - dy * ex);
            this.centreX = ax + (ey * bl - dy * cl) * d;
            this.centreY = ay + (dx * cl - ex * bl) * d;
        }
        quicksort(left, right) {
            const { ids, dists } = this;
            if (right - left <= 20) {
                for (let i = left + 1; i <= right; i++) {
                    const temp = ids[i];
                    const tempDist = dists[temp];
                    let j = i - 1;
                    while (j >= left && dists[ids[j]] > tempDist)
                        ids[j + 1] = ids[j--];
                    ids[j + 1] = temp;
                }
            }
            else {
                let median = (left + right) >> 1;
                let i = left + 1;
                let j = right;
                WebMolKit.Vec.swap(ids, median, i);
                if (dists[ids[left]] > dists[ids[right]])
                    WebMolKit.Vec.swap(ids, left, right);
                if (dists[ids[i]] > dists[ids[right]])
                    WebMolKit.Vec.swap(ids, i, right);
                if (dists[ids[left]] > dists[ids[i]])
                    WebMolKit.Vec.swap(ids, left, i);
                let temp = ids[i];
                const tempDist = dists[temp];
                while (true) {
                    do
                        i++;
                    while (dists[ids[i]] < tempDist);
                    do
                        j--;
                    while (dists[ids[j]] > tempDist);
                    if (j < i)
                        break;
                    WebMolKit.Vec.swap(ids, i, j);
                }
                ids[left + 1] = ids[j];
                ids[j] = temp;
                if (right - i + 1 >= j - left) {
                    this.quicksort(i, right);
                    this.quicksort(left, j - 1);
                }
                else {
                    this.quicksort(left, j - 1);
                    this.quicksort(i, right);
                }
            }
        }
    }
    WebMolKit.Triangulation2D = Triangulation2D;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class Vec {
        static isBlank(arr) { return arr == null || arr.length == 0; }
        static notBlank(arr) { return arr != null && arr.length > 0; }
        static safeArray(arr) { return arr == null ? [] : arr; }
        static len(arr) { return arr == null ? 0 : arr.length; }
        static arrayLength(arr) { return arr == null ? 0 : arr.length; }
        static anyTrue(arr) {
            if (arr == null)
                return false;
            for (let v of arr)
                if (v)
                    return true;
            return false;
        }
        static allTrue(arr) {
            if (arr == null)
                return true;
            for (let v of arr)
                if (!v)
                    return false;
            return true;
        }
        static anyFalse(arr) {
            if (arr == null)
                return false;
            for (let v of arr)
                if (!v)
                    return true;
            return false;
        }
        static allFalse(arr) {
            if (arr == null)
                return true;
            for (let v of arr)
                if (v)
                    return false;
            return true;
        }
        static swap(arr, idx1, idx2) {
            let v = arr[idx1];
            arr[idx1] = arr[idx2];
            arr[idx2] = v;
        }
        static duplicate(arr) {
            return arr == null ? [] : arr.slice(0);
        }
        static append(arr, item) {
            if (arr == null || arr.length == 0)
                return [item];
            arr = arr.slice(0);
            arr.push(item);
            return arr;
        }
        static prepend(arr, item) {
            if (arr == null || arr.length == 0)
                return [item];
            arr = arr.slice(0);
            arr.unshift(item);
            return arr;
        }
        static concat(arr1, arr2) {
            if (arr1 == null && arr2 == null)
                return [];
            if (arr1 == null)
                return arr2.slice(0);
            if (arr2 == null)
                return arr1.slice(0);
            return arr1.concat(arr2);
        }
        static remove(arr, idx) {
            arr = arr.slice(0);
            arr.splice(idx, 1);
            return arr;
        }
        static flatten(mtx) {
            let ret = [];
            for (let vec of mtx)
                ret.push(...vec);
            return ret;
        }
        static transpose(mtx) {
            let sz1 = mtx.length, sz2 = mtx[0].length;
            let ret = Vec.anyArray(null, sz2);
            for (let j = 0; j < sz2; j++) {
                ret[j] = Vec.anyArray(null, sz1);
                for (let i = 0; i < sz1; i++)
                    ret[j][i] = mtx[i][j];
            }
            return ret;
        }
        static equals(arr1, arr2) {
            if (arr1 == null && arr2 == null)
                return true;
            if (arr1 == null || arr2 == null)
                return false;
            if (arr1.length != arr2.length)
                return false;
            for (let n = 0; n < arr1.length; n++)
                if (arr1[n] != arr2[n])
                    return false;
            return true;
        }
        static equivalent(arr1, arr2) {
            const len1 = arr1 == null ? 0 : arr1.length, len2 = arr2 == null ? 0 : arr2.length;
            if (len1 != len2)
                return false;
            for (let n = 0; n < len1; n++)
                if (arr1[n] != arr2[n])
                    return false;
            return true;
        }
        static compareTo(arr1, arr2) {
            const sz = Math.max(arr1.length, arr2.length);
            for (let n = 0; n < sz; n++) {
                if (arr1[n] < arr2[n])
                    return -1;
                if (arr1[n] > arr2[n])
                    return 1;
            }
            return 0;
        }
        static booleanArray(val, sz) {
            let arr = new Array(sz);
            arr.fill(val);
            return arr;
        }
        static numberArray(val, sz) {
            let arr = new Array(sz);
            arr.fill(val);
            return arr;
        }
        static stringArray(val, sz) {
            let arr = new Array(sz);
            arr.fill(val);
            return arr;
        }
        static anyArray(val, sz) {
            let arr = new Array(sz);
            arr.fill(val);
            return arr;
        }
        static genericArray(val, sz) {
            let arr = new Array(sz);
            arr.fill(val);
            return arr;
        }
        static first(arr) { return arr == null || arr.length == 0 ? null : arr[0]; }
        static last(arr) { return arr == null || arr.length == 0 ? null : arr[arr.length - 1]; }
        static min(arr) {
            if (arr == null || arr.length == 0)
                return Number.MAX_VALUE;
            let v = arr[0];
            for (let n = 1; n < arr.length; n++)
                v = Math.min(v, arr[n]);
            return v;
        }
        static max(arr) {
            if (arr == null || arr.length == 0)
                return Number.MIN_VALUE;
            let v = arr[0];
            for (let n = 1; n < arr.length; n++)
                v = Math.max(v, arr[n]);
            return v;
        }
        static idxMin(arr) {
            if (arr == null || arr.length == 0)
                return -1;
            let idx = 0;
            for (let n = 1; n < arr.length; n++)
                if (arr[n] < arr[idx])
                    idx = n;
            return idx;
        }
        static idxMax(arr) {
            if (arr == null || arr.length == 0)
                return -1;
            let idx = 0;
            for (let n = 1; n < arr.length; n++)
                if (arr[n] > arr[idx])
                    idx = n;
            return idx;
        }
        static range(arr) {
            if (arr == null || arr.length == 0)
                return 0;
            let lo = arr[0], hi = arr[0];
            for (let n = 1; n < arr.length; n++) {
                if (arr[n] < lo)
                    lo = arr[n];
                if (arr[n] > hi)
                    hi = arr[n];
            }
            return hi - lo;
        }
        static reverse(arr) {
            let ret = [];
            for (let n = arr.length - 1; n >= 0; n--)
                ret.push(arr[n]);
            return ret;
        }
        static identity0(sz) {
            let ret = new Array(sz);
            for (let n = 0; n < sz; n++)
                ret[n] = n;
            return ret;
        }
        static identity1(sz) {
            let ret = new Array(sz);
            for (let n = 0; n < sz; n++)
                ret[n] = n + 1;
            return ret;
        }
        static identityN(start, sz) {
            let ret = new Array(sz);
            for (let n = 0; n < sz; n++)
                ret[n] = n + start;
            return ret;
        }
        static notMask(mask) {
            let ret = new Array(mask.length);
            for (let n = mask.length - 1; n >= 0; n--)
                ret[n] = !mask[n];
            return ret;
        }
        static idxGet(arr, idx) {
            let ret = [];
            for (let n = 0; n < idx.length; n++)
                ret.push(arr[idx[n]]);
            return ret;
        }
        static maskCount(mask) {
            if (!mask)
                return 0;
            let c = 0;
            for (let n = mask.length - 1; n >= 0; n--)
                if (mask[n])
                    c++;
            return c;
        }
        static maskIdx(mask) {
            let idx = [];
            for (let n = 0; n < mask.length; n++)
                if (mask[n])
                    idx.push(n);
            return idx;
        }
        static idxMask(idx, sz) {
            let mask = Vec.booleanArray(false, sz);
            for (let n of idx)
                mask[n] = true;
            return mask;
        }
        static maskMap(mask) {
            let ret = [];
            for (let n = 0, pos = 0; n < mask.length; n++)
                ret.push(mask[n] ? pos++ : -1);
            return ret;
        }
        static maskGet(arr, mask) {
            let ret = [];
            for (let n = 0, p = 0; n < arr.length; n++)
                if (mask[n])
                    ret.push(arr[n]);
            return ret;
        }
        static maskEqual(arr1, val) {
            let ret = [];
            if (val.constructor === Array) {
                let arr2 = val;
                for (let n = 0; n < arr1.length; n++)
                    ret.push(arr1[n] == arr2[n]);
            }
            else {
                for (let n = 0; n < arr1.length; n++)
                    ret.push(arr1[n] == val);
            }
            return ret;
        }
        static sum(arr) {
            if (arr == null || arr.length == 0)
                return 0;
            let t = arr[0];
            for (let n = 1; n < arr.length; n++)
                t += arr[n];
            return t;
        }
        static add(arr1, val) {
            let ret = [];
            if (val.constructor === Array) {
                let arr2 = val;
                for (let n = 0; n < arr1.length; n++)
                    ret.push(arr1[n] + arr2[n]);
            }
            else {
                for (let n = 0; n < arr1.length; n++)
                    ret.push(arr1[n] + val);
            }
            return ret;
        }
        static sub(arr1, val) {
            let ret = [];
            if (val.constructor === Array) {
                let arr2 = val;
                for (let n = 0; n < arr1.length; n++)
                    ret.push(arr1[n] - arr2[n]);
            }
            else {
                for (let n = 0; n < arr1.length; n++)
                    ret.push(arr1[n] - val);
            }
            return ret;
        }
        static mul(arr1, val) {
            let ret = [];
            if (val.constructor === Array) {
                let arr2 = val;
                for (let n = 0; n < arr1.length; n++)
                    ret.push(arr1[n] * arr2[n]);
            }
            else {
                for (let n = 0; n < arr1.length; n++)
                    ret.push(arr1[n] * val);
            }
            return ret;
        }
        static neg(arr) {
            let ret = arr.slice(0);
            for (let n = ret.length - 1; n >= 0; n--)
                ret[n] *= -1;
            return ret;
        }
        static setTo(arr, val) { for (let n = arr == null ? -1 : arr.length - 1; n >= 0; n--)
            arr[n] = val; }
        static addTo(arr, val) { for (let n = arr == null ? -1 : arr.length - 1; n >= 0; n--)
            arr[n] += val; }
        static mulBy(arr, val) { for (let n = arr == null ? -1 : arr.length - 1; n >= 0; n--)
            arr[n] *= val; }
        static addToArray(arr, val) { for (let n = arr == null ? -1 : arr.length - 1; n >= 0; n--)
            arr[n] += val[n]; }
        static subFromArray(arr, val) { for (let n = arr == null ? -1 : arr.length - 1; n >= 0; n--)
            arr[n] -= val[n]; }
        static mulByArray(arr, val) { for (let n = arr == null ? -1 : arr.length - 1; n >= 0; n--)
            arr[n] *= val[n]; }
        static divByArray(arr, val) { for (let n = arr == null ? -1 : arr.length - 1; n >= 0; n--)
            arr[n] /= val[n]; }
        static idxSort(arr) {
            let idx = new Array(arr.length);
            for (let n = 0; n < arr.length; n++)
                idx[n] = n;
            idx.sort((a, b) => arr[a] < arr[b] ? -1 : arr[a] > arr[b] ? 1 : 0);
            return idx;
        }
        static sort(arr) {
            arr.sort((v1, v2) => v1 - v2);
        }
        static sorted(arr) {
            arr = arr.slice(0);
            this.sort(arr);
            return arr;
        }
        static sortedUnique(arr) {
            if (arr == null || arr.length == 0)
                return [];
            let unique = Vec.uniqueUnstable(arr);
            if (typeof arr[0] == 'number')
                this.sort(unique);
            else
                unique.sort();
            return unique;
        }
        static uniqueUnstable(arr) {
            return Array.from(new Set(arr));
        }
        static uniqueStable(arr) {
            let set = new Set(arr), ret = [];
            for (let v of arr)
                if (set.has(v)) {
                    ret.push(v);
                    set.delete(v);
                }
            return ret;
        }
        static maskUnique(arr) {
            let set = new Set(arr), ret = this.booleanArray(false, arr.length);
            for (let n = 0; n < arr.length; n++)
                if (set.has(arr[n])) {
                    ret[n] = true;
                    set.delete(arr[n]);
                }
            return ret;
        }
        static idxUnique(arr) {
            let set = new Set(arr), ret = [];
            for (let n = 0; n < arr.length; n++)
                if (set.has(arr[n])) {
                    ret.push(n);
                    set.delete(arr[n]);
                }
            return ret;
        }
        static exclude(arr, excl) {
            const sz = Vec.len(arr);
            if (sz == 0)
                return [];
            let mask = new Array(sz);
            let count = 0;
            for (let n = 0; n < arr.length; n++) {
                mask[n] = excl.indexOf(arr[n]) < 0;
                if (mask[n])
                    count++;
            }
            if (count == sz)
                return arr;
            return Vec.maskGet(arr, mask);
        }
    }
    WebMolKit.Vec = Vec;
    class Permutation {
        static parityPerms(idx) {
            let v = Vec.booleanArray(false, idx.length);
            let p = 0;
            for (let i = idx.length - 1; i >= 0; i--) {
                if (v[i])
                    p++;
                else {
                    let j = i;
                    do {
                        j = idx[j];
                        v[j] = true;
                    } while (j != i);
                }
            }
            return p;
        }
        static parityIdentity(idx) {
            return this.parityPerms(idx) & 1;
        }
        static parityOrder(src) {
            if (src.length <= 1)
                return 0;
            else if (src.length == 2)
                return src[0] < src[1] ? 0 : 1;
            else if (src.length == 3) {
                let p = 1;
                if (src[0] < src[1])
                    p++;
                if (src[0] < src[2])
                    p++;
                if (src[1] < src[2])
                    p++;
                return p & 1;
            }
            else if (src.length == 4) {
                let p = 0;
                if (src[0] < src[1])
                    p++;
                if (src[0] < src[2])
                    p++;
                if (src[0] < src[3])
                    p++;
                if (src[1] < src[2])
                    p++;
                if (src[1] < src[3])
                    p++;
                if (src[2] < src[3])
                    p++;
                return p & 1;
            }
            let idx = [], sorted = src.slice(0);
            sorted.sort();
            for (let n = 0; n < src.length; n++)
                idx.push(sorted.indexOf(src[n]));
            return this.parityIdentity(idx);
        }
        static smallPermutation(sz) {
            if (sz == 1)
                return this.PERM1;
            else if (sz == 2)
                return this.PERM2;
            else if (sz == 3)
                return this.PERM3;
            else if (sz == 4)
                return this.PERM4;
            else
                return null;
        }
        static allPermutations(sz) {
            if (sz <= this.SMALL_PERMS)
                return this.smallPermutation(sz);
            while (this.PERM_CACHE.length < this.MAX_CACHE - this.SMALL_PERMS)
                this.PERM_CACHE.push(null);
            if (sz < this.MAX_CACHE && this.PERM_CACHE[sz - this.SMALL_PERMS] != null)
                return this.PERM_CACHE[sz - this.SMALL_PERMS];
            let nperms = 1;
            for (let n = 2; n <= sz; n++)
                nperms *= n;
            let perms = [];
            let idx = Vec.identity0(sz);
            perms.push(idx.slice(0));
            let mask = Vec.booleanArray(false, sz);
            for (let n = 1; n < nperms; n++) {
                nonunique: while (idx[0] < sz) {
                    idx[sz - 1]++;
                    for (let i = sz - 1; i > 0; i--) {
                        if (idx[i] < sz)
                            break;
                        idx[i] = 0;
                        idx[i - 1]++;
                    }
                    Vec.setTo(mask, false);
                    for (let i of idx) {
                        if (mask[i])
                            continue nonunique;
                        mask[i] = true;
                    }
                    perms[n] = idx.slice(0);
                    break;
                }
            }
            if (sz < this.MAX_CACHE)
                this.PERM_CACHE[sz - this.SMALL_PERMS] = perms;
            return perms;
        }
    }
    Permutation.PERM1 = [[0]];
    Permutation.PERM2 = [[0, 1], [1, 0]];
    Permutation.PERM3 = [[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]];
    Permutation.PERM4 = [
        [0, 1, 2, 3], [0, 1, 3, 2], [0, 2, 1, 3], [0, 2, 3, 1], [0, 3, 1, 2], [0, 3, 2, 1],
        [1, 0, 2, 3], [1, 0, 3, 2], [1, 2, 0, 3], [1, 2, 3, 0], [1, 3, 0, 2], [1, 3, 2, 0],
        [2, 0, 1, 3], [2, 0, 3, 1], [2, 1, 0, 3], [2, 1, 3, 0], [2, 3, 0, 1], [2, 3, 1, 0],
        [3, 0, 1, 2], [3, 0, 2, 1], [3, 1, 0, 2], [3, 1, 2, 0], [3, 2, 0, 1], [3, 2, 1, 0]
    ];
    Permutation.SMALL_PERMS = 4;
    Permutation.MAX_CACHE = 8;
    Permutation.PERM_CACHE = [];
    WebMolKit.Permutation = Permutation;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class XML {
        static parseXML(strXML) {
            let xmlDoc;
            if (this.customParser)
                xmlDoc = new this.customParser().parseFromString(strXML, 'application/xml');
            else
                xmlDoc = new DOMParser().parseFromString(strXML, 'application/xml');
            if (xmlDoc == null)
                return null;
            return xmlDoc;
        }
        static toString(doc) {
            if (this.customSerial)
                return new this.customSerial().serializeToString(doc.documentElement);
            else
                return new XMLSerializer().serializeToString(doc.documentElement);
        }
        static toPrettyString(doc) {
            let xslt = [
                '<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform">',
                '  <xsl:strip-space elements="*"/>',
                '  <xsl:template match="para[content-style][not(text())]">',
                '    <xsl:value-of select="normalize-space(.)"/>',
                '  </xsl:template>',
                '  <xsl:template match="node()|@*">',
                '    <xsl:copy><xsl:apply-templates select="node()|@*"/></xsl:copy>',
                '  </xsl:template>',
                '  <xsl:output indent="yes"/>',
                '</xsl:stylesheet>',
            ].join('\n');
            let xsltDoc = this.parseXML(xslt);
            let xsltProc = new XSLTProcessor();
            xsltProc.importStylesheet(xsltDoc);
            let resultDoc = xsltProc.transformToDocument(doc);
            return new XMLSerializer().serializeToString(resultDoc);
        }
        static nodeText(el) {
            let text = '';
            for (let child of Array.from(el.childNodes)) {
                if (child.nodeType == Node.TEXT_NODE || child.nodeType == Node.CDATA_SECTION_NODE)
                    text += child.nodeValue;
            }
            return text;
        }
        static childText(parent, tagName) {
            if (parent == null)
                return null;
            let el = this.findElement(parent, tagName);
            if (el == null)
                return null;
            return WebMolKit.nodeText(el);
        }
        static appendElement(parent, name) {
            let el = parent.ownerDocument.createElement(name);
            parent.appendChild(el);
            return el;
        }
        static appendElementAfter(presib, name) {
            let el = presib.ownerDocument.createElement(name);
            let postsib = presib.nextSibling;
            if (postsib == null)
                presib.parentNode.appendChild(el);
            else
                presib.parentNode.insertBefore(el, postsib);
            return el;
        }
        static appendText(parent, text, isCDATA = false) {
            if (text == null || text.length == 0)
                return;
            if (!isCDATA)
                parent.appendChild(parent.ownerDocument.createTextNode(text));
            else
                parent.appendChild(parent.ownerDocument.createCDATASection(text));
        }
        static createTextChild(parent, name, text, isCDATA = false) {
            let el = parent.ownerDocument.createElement(name);
            parent.appendChild(el);
            if (!isCDATA)
                el.textContent = text;
            else
                el.appendChild(parent.ownerDocument.createCDATASection(text));
        }
        static setText(parent, text, isCDATA = false) {
            while (parent.firstChild != null)
                parent.removeChild(parent.firstChild);
            this.appendText(parent, text, isCDATA);
        }
        static findElement(parent, tagName) {
            if (parent == null)
                return null;
            let node = parent.firstChild;
            while (node != null) {
                if (node.nodeType == Node.ELEMENT_NODE && node.nodeName == tagName)
                    return node;
                node = node.nextSibling;
            }
            return null;
        }
        static findChildElements(parent, tagName) {
            if (parent == null)
                return [];
            let list = [];
            let node = parent.firstChild;
            while (node != null) {
                if (node.nodeType == Node.ELEMENT_NODE && node.nodeName === tagName)
                    list.push(node);
                node = node.nextSibling;
            }
            return list;
        }
        static childElements(parent) {
            if (parent == null)
                return [];
            let list = [];
            let node = parent.firstChild;
            while (node != null) {
                if (node.nodeType == Node.ELEMENT_NODE)
                    list.push(node);
                node = node.nextSibling;
            }
            return list;
        }
    }
    XML.customParser = null;
    XML.customSerial = null;
    WebMolKit.XML = XML;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    function dom(obj) {
        if (typeof obj == 'string')
            return DOM.parse(obj);
        if (obj instanceof DOM)
            return obj;
        return new DOM(obj);
    }
    WebMolKit.dom = dom;
    function domLegacy(obj) {
        if (obj == null)
            return null;
        if (obj.jquery)
            return dom(obj[0]);
        return dom(obj);
    }
    WebMolKit.domLegacy = domLegacy;
    class DOM {
        constructor(el) {
            this.el = el;
        }
        get elHTML() { return this.el; }
        get elInput() { return this.el; }
        get elCanvas() { return this.el; }
        static parse(xhtml) {
            let xml = WebMolKit.XML.parseXML(xhtml);
            if (xml == null)
                throw 'Invalid XHTML string: ' + xhtml;
            let html = xml.documentElement.outerHTML;
            let template = document.createElement('template');
            template.innerHTML = html;
            return new DOM(template.content.firstChild);
        }
        static find(selector) {
            let el = document.querySelector(selector);
            return el ? new DOM(el) : null;
        }
        static findAll(selector) {
            let nodeList = document.querySelectorAll(selector);
            let domList = [];
            for (let n = 0; n < nodeList.length; n++)
                domList.push(new DOM(nodeList.item(n)));
            return domList;
        }
        parent() {
            let parent = this.el.parentElement;
            return parent ? new DOM(parent) : null;
        }
        ancestor(selector) {
            let el = this.el.closest(selector);
            return el ? new DOM(el) : null;
        }
        children(tag) {
            let domList = [];
            for (let child = this.el.firstElementChild; child; child = child.nextElementSibling) {
                if (tag && child.tagName != tag)
                    continue;
                domList.push(new DOM(child));
            }
            return domList;
        }
        find(selector) {
            let el = this.el.querySelector(selector);
            return el ? new DOM(el) : null;
        }
        findAll(selector) {
            let nodeList = this.el.querySelectorAll(selector);
            let domList = [];
            for (let n = 0; n < nodeList.length; n++)
                domList.push(new DOM(nodeList.item(n)));
            return domList;
        }
        exists() {
            return document.documentElement.contains(this.el);
        }
        isVisible() {
            return this.elHTML.offsetWidth > 0 || this.elHTML.offsetHeight > 0 || this.elHTML.getClientRects().length > 0;
        }
        append(child) {
            this.el.append(child.el);
        }
        appendTo(parent) {
            if (parent instanceof DOM)
                parent.el.append(this.el);
            else
                parent.appendChild(this.el);
            return this;
        }
        prepend(child) {
            this.el.prepend(child.el);
        }
        prependTo(parent) {
            if (parent instanceof DOM)
                parent.el.prepend(this.el);
            else
                parent.append(this.el);
            return this;
        }
        insertBefore(ref) {
            ref.el.parentElement.insertBefore(this.el, ref.el);
            return this;
        }
        insertAfter(ref) {
            let before = ref.el.nextElementSibling;
            if (before)
                ref.el.parentElement.insertBefore(this.el, before);
            else
                ref.el.parentElement.append(this.el);
            return this;
        }
        remove() {
            this.el.remove();
        }
        empty() {
            this.el.innerHTML = '';
        }
        getHTML() {
            return this.el.innerHTML;
        }
        setHTML(html) {
            this.el.innerHTML = html;
        }
        appendHTML(xhtml) {
            let xml = WebMolKit.XML.parseXML('<z>' + xhtml + '</z>');
            if (xml == null)
                throw 'Invalid XHTML string: ' + xhtml;
            let html = xml.documentElement.innerHTML;
            this.el.insertAdjacentHTML('beforeend', html);
        }
        getText() {
            return this.el.textContent;
        }
        setText(text) {
            this.el.textContent = text;
        }
        appendText(text) {
            let content = document.createTextNode(text);
            this.el.appendChild(content);
        }
        getValue() {
            return this.el.value;
        }
        setValue(str) {
            this.el.value = str || '';
        }
        getCSS(key) {
            return this.elHTML.style.getPropertyValue(key);
        }
        setCSS(key, value) {
            this.elHTML.style.setProperty(key, value);
        }
        css(dict) {
            for (let key in dict)
                this.setCSS(key, dict[key].toString());
            return this;
        }
        getAttr(key) {
            if (!this.el.hasAttribute(key))
                return null;
            return this.el.getAttribute(key);
        }
        setAttr(key, value) {
            this.el.setAttribute(key, value);
        }
        attr(dict) {
            for (let key in dict)
                this.setAttr(key, dict[key].toString());
            return this;
        }
        addClass(clsnames) {
            for (let cls of clsnames.split(' '))
                if (cls)
                    this.elHTML.classList.add(cls);
        }
        removeClass(clsnames) {
            for (let cls of clsnames.split(' '))
                if (cls)
                    this.elHTML.classList.remove(cls);
        }
        hasClass(clsname) {
            return this.elHTML.classList.contains(clsname);
        }
        setClass(clsname, flag) {
            if (flag)
                this.addClass(clsname);
            else
                this.removeClass(clsname);
        }
        class(clsname) {
            this.addClass(clsname);
            return this;
        }
        toggleClass(dict) {
            for (let key in dict) {
                if (dict[key])
                    this.elHTML.classList.add(key);
                else
                    this.elHTML.classList.remove(key);
            }
        }
        width() {
            return this.elHTML.offsetWidth;
        }
        height() {
            return this.elHTML.offsetHeight;
        }
        offset() {
            let rect = this.el.getBoundingClientRect();
            let win = this.el.ownerDocument.defaultView;
            return new WebMolKit.Pos(rect.left + win.pageXOffset, rect.top + win.pageYOffset);
        }
        size() {
            return new WebMolKit.Size(this.width(), this.height());
        }
        setBoundaryPixels(x, y, w, h) {
            this.css({ 'left': `${x}px`, 'top': `${y}px`, 'width': `${w}px`, 'height': `${h}px` });
        }
        hasFocus() {
            return this.el === document.activeElement;
        }
        grabFocus(delay = false) {
            if (delay)
                setTimeout(() => this.grabFocus(), 10);
            else
                this.elHTML.focus();
        }
        removeEvent(id, callback) {
            this.el.removeEventListener(id, callback);
        }
        onKeyDown(callback) {
            this.el.addEventListener('keydown', callback);
        }
        onKeyUp(callback) {
            this.el.addEventListener('keyup', callback);
        }
        onKeyPress(callback) {
            this.el.addEventListener('keypress', callback);
        }
        onScroll(callback) {
            this.el.addEventListener('scroll', callback);
        }
        onWheel(callback) {
            this.el.addEventListener('wheel', callback);
        }
        onClick(callback) {
            this.el.addEventListener('click', callback);
        }
        onContextMenu(callback) {
            this.el.addEventListener('contextmenu', callback);
        }
        onDblClick(callback) {
            this.el.addEventListener('dblclick', callback);
        }
        onMouseDown(callback) {
            this.el.addEventListener('mousedown', callback);
        }
        onMouseUp(callback) {
            this.el.addEventListener('mouseup', callback);
        }
        onMouseEnter(callback) {
            this.el.addEventListener('mouseenter', callback);
        }
        onMouseLeave(callback) {
            this.el.addEventListener('mouseleave', callback);
        }
        onMouseMove(callback) {
            this.el.addEventListener('mousemove', callback);
        }
        onMouseOver(callback) {
            this.el.addEventListener('mouseover', callback);
        }
        onChange(callback) {
            this.el.addEventListener('change', callback);
        }
        onInput(callback) {
            this.el.addEventListener('input', callback);
        }
        onTouchStart(callback) {
            this.el.addEventListener('touchstart', callback);
        }
        onTouchMove(callback) {
            this.el.addEventListener('touchmove', callback);
        }
        onTouchCancel(callback) {
            this.el.addEventListener('touchcancel', callback);
        }
        onTouchEnd(callback) {
            this.el.addEventListener('touchend', callback);
        }
    }
    WebMolKit.DOM = DOM;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class Validation {
        constructor() {
            this.tests = [];
            this.setupError = null;
            this.rec = {};
        }
        init() {
            return __awaiter(this, void 0, void 0, function* () {
            });
        }
        deinit() {
            return __awaiter(this, void 0, void 0, function* () {
            });
        }
        add(title, func) {
            this.tests.push({ 'title': title, 'func': func });
        }
        get count() { return this.tests.length; }
        getTitle(idx) { return this.tests[idx].title; }
        runTest(idx) {
            return __awaiter(this, void 0, void 0, function* () {
                this.recentSuccess = true;
                this.recentError = null;
                let timeStarted = new Date().getTime();
                try {
                    yield this.tests[idx].func.call(this);
                }
                catch (e) {
                    this.recentSuccess = false;
                    if (this.recentError == null) {
                        this.recentError = 'Exception: ' + (e.message || e);
                        if (e.fileName)
                            this.recentError += ', file: ' + e.fileName;
                        if (e.lineNumber)
                            this.recentError += ', line: ' + e.lineNumber;
                        console.log('Unhandled exception in validation:');
                        console.log(e);
                    }
                }
                let timeFinished = new Date().getTime();
                this.recentTimeTaken = (timeFinished - timeStarted) / 1000;
                yield this.gasp();
                return [this.recentSuccess, this.recentError, this.recentTimeTaken];
            });
        }
        gasp() {
            return __awaiter(this, void 0, void 0, function* () {
                yield WebMolKit.yieldDOM();
            });
        }
        assert(condition, message) {
            if (condition)
                return;
            this.recentError = message;
            throw '!';
        }
        assertEqual(thing1, thing2, message) {
            if (thing1 == thing2)
                return;
            this.recentError = message;
            throw '!';
        }
        assertNull(thing, message) {
            if (thing == null)
                return;
            this.recentError = message;
            throw '!';
        }
        assertNotNull(thing, message) {
            if (thing != null)
                return;
            this.recentError = message;
            throw '!';
        }
        fail(message) {
            this.recentError = message;
            throw '!';
        }
    }
    WebMolKit.Validation = Validation;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class ValidationHeadlessBasic extends WebMolKit.Validation {
        constructor() {
            super();
            this.add('Vector index sort', this.vectorIndexSort);
            this.add('Axis labeller', this.axisLabeller);
        }
        vectorIndexSort() {
            return __awaiter(this, void 0, void 0, function* () {
                let array = ['b', 'c', 'a'];
                let idx = WebMolKit.Vec.idxSort(array);
                this.assert(WebMolKit.Vec.equals(idx, [2, 0, 1]));
            });
        }
        axisLabeller() {
            return __awaiter(this, void 0, void 0, function* () {
                let textWidth = (str) => str.length * 4;
                let tfUnity = (val) => val, tfNegLog = (val) => -Math.log10(val), tfBackLog = (val) => Math.pow(10, -val);
                const TESTCASES = [
                    [1, 100, false, ['10', '100']],
                    [0, 1, false, ['0', '1']],
                    [0.01, 0.02, false, ['0.01', '0.02']],
                    [0.008, 0.022, false, ['0.008', '0.022']],
                    [0.00798, 0.0221, false, ['0.008', '0.022']],
                    [1E-5, 1E4, true, ['1e+4', '0.00001']],
                    [0.03162277660168379, 100, true, ['100', '0.03162']]
                ];
                for (let test of TESTCASES) {
                    let low = test[0], high = test[1];
                    let asLog = test[2];
                    if (asLog)
                        [low, high] = [tfNegLog(high), tfNegLog(low)];
                    let axis = new WebMolKit.AxisLabeller(100, low, high, textWidth, asLog ? tfBackLog : tfUnity);
                    axis.calculate();
                    let wanted = test[3];
                    let got = [];
                    for (let notch of axis.notches)
                        got.push(notch.label);
                    if (wanted.length == 0 || !WebMolKit.Vec.equals(wanted, got)) {
                        console.log('Test:' + JSON.stringify(test));
                        console.log('Notches:' + JSON.stringify(axis.notches));
                        console.log('Wanted:' + JSON.stringify(wanted));
                        console.log('Got:' + JSON.stringify(got));
                        this.fail('Did not get the expected axis labels.');
                    }
                }
            });
        }
    }
    WebMolKit.ValidationHeadlessBasic = ValidationHeadlessBasic;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class ValidationHeadlessMolecule extends WebMolKit.Validation {
        constructor(urlBase) {
            super();
            this.urlBase = urlBase;
            this.add('Parse SketchEl molecule (native format)', this.parseSketchEl);
            this.add('Parse MDL Molfile', this.parseMolfile);
            this.add('Parse DataSheet XML', this.parseDataXML);
            this.add('Parse MDL SDfile', this.parseSDfile);
            this.add('Calculate strict aromaticity', this.calcStrictArom);
            this.add('Calculate stereochemistry', this.calcStereoChem);
            this.add('Circular ECFP6 fingerprints', this.calcFingerprints);
            this.add('Molfile Round-trip', this.molfileRoundTrip);
        }
        init() {
            return __awaiter(this, void 0, void 0, function* () {
                this.strSketchEl = yield WebMolKit.readTextURL(this.urlBase + 'molecule.el');
                this.strMolfile = yield WebMolKit.readTextURL(this.urlBase + 'molecule.mol');
                this.strDataXML = yield WebMolKit.readTextURL(this.urlBase + 'datasheet.ds');
                this.strSDfile = yield WebMolKit.readTextURL(this.urlBase + 'datasheet.sdf');
                this.molStereo = WebMolKit.Molecule.fromString(yield WebMolKit.readTextURL(this.urlBase + 'stereo.el'));
                this.dsCircular = WebMolKit.DataSheetStream.readXML(yield WebMolKit.readTextURL(this.urlBase + 'circular.ds'));
                this.dsRoundtrip = WebMolKit.DataSheetStream.readXML(yield WebMolKit.readTextURL(this.urlBase + 'roundtrip.ds'));
            });
        }
        parseSketchEl() {
            return __awaiter(this, void 0, void 0, function* () {
                this.assert(!!this.strSketchEl, 'molecule not loaded');
                let mol = WebMolKit.MoleculeStream.readNative(this.strSketchEl);
                this.assert(mol != null, 'parsing failed');
                this.assert(mol.numAtoms == 10 && mol.numBonds == 10, 'wrong atom/bond count');
            });
        }
        parseMolfile() {
            return __awaiter(this, void 0, void 0, function* () {
                this.assert(!!this.strMolfile, 'molecule not loaded');
                let mol = WebMolKit.MoleculeStream.readMDLMOL(this.strMolfile);
                this.assert(mol != null, 'parsing failed');
                this.assert(mol.numAtoms == 10 && mol.numBonds == 10, 'wrong atom/bond count');
            });
        }
        parseDataXML() {
            return __awaiter(this, void 0, void 0, function* () {
                this.assert(!!this.strDataXML, 'datasheet not loaded');
                let ds = WebMolKit.DataSheetStream.readXML(this.strDataXML);
                this.assert(ds != null, 'parsing failed');
                this.assert(ds.numRows == 2 && ds.numCols == 5, 'wrong row/column count');
                let colTypes = ["molecule", "string", "integer", "real", "boolean"];
                for (let n = 0; n < colTypes.length; n++)
                    this.assert(ds.colType(n) == colTypes[n], 'column#' + (n + 1) + ' wrong type');
                this.assert(ds.getMolecule(0, 0).numAtoms == 1, 'row 1: invalid molecule');
                this.assert(ds.getString(0, 1) == 'string', 'row 1: invalid string');
                this.assert(ds.getInteger(0, 2) == 1, 'row 1: invalid integer');
                this.assert(ds.getReal(0, 3) == 1.5, 'row 1: invalid real');
                this.assert(ds.getBoolean(0, 4) == true, 'row 1: invalid boolean');
                this.assert(ds.getMolecule(1, 0).numAtoms == 1, 'row 2: invalid molecule');
                for (let n = 1; n < ds.numCols; n++)
                    this.assert(ds.isNull(1, n), 'row 2, column#' + (n + 1) + ' supposed to be null');
            });
        }
        parseSDfile() {
            return __awaiter(this, void 0, void 0, function* () {
                this.assert(!!this.strSDfile, 'datasheet not loaded');
                let rdr = new WebMolKit.MDLSDFReader(this.strSDfile);
                rdr.parse();
                let ds = rdr.ds;
                this.assert(ds != null, 'parsing failed');
                this.assert(ds.numRows == 2 && ds.numCols == 5, 'wrong row/column count');
                let colTypes = ["molecule", "string", "integer", "real", "boolean"];
                for (let n = 0; n < colTypes.length; n++)
                    this.assert(ds.colType(n) == colTypes[n], 'column#' + (n + 1) + ' wrong type');
                this.assert(ds.getMolecule(0, 0).numAtoms == 1, 'row 1: invalid molecule');
                this.assert(ds.getString(0, 1) == 'string', 'row 1: invalid string');
                this.assert(ds.getInteger(0, 2) == 1, 'row 1: invalid integer');
                this.assert(ds.getReal(0, 3) == 1.5, 'row 1: invalid real');
                this.assert(ds.getBoolean(0, 4) == true, 'row 1: invalid boolean');
                this.assert(ds.getMolecule(1, 0).numAtoms == 1, 'row 2: invalid molecule');
                for (let n = 1; n < ds.numCols; n++)
                    this.assert(ds.isNull(1, n), 'row 2, column#' + (n + 1) + ' supposed to be null');
            });
        }
        calcStrictArom() {
            return __awaiter(this, void 0, void 0, function* () {
                this.assert(this.molStereo != null, 'molecule not loaded');
                let meta = WebMolKit.MetaMolecule.createStrict(this.molStereo);
                this.assert(meta.atomArom != null, 'no aromaticity obtained');
                for (let n = 1; n <= 10; n++)
                    this.assert(meta.isAtomAromatic(n), 'atom #' + n + ' supposed to be aromatic');
                for (let n = 1; n <= 10; n++)
                    this.assert(meta.isBondAromatic(n), 'bond #' + n + ' supposed to be aromatic');
            });
        }
        calcStereoChem() {
            return __awaiter(this, void 0, void 0, function* () {
                this.assert(this.molStereo != null, 'molecule not loaded');
                let meta = WebMolKit.MetaMolecule.createStrictRubric(this.molStereo);
                this.assert(meta.rubricTetra != null, 'no tetrahedral rubric obtained');
                this.assert(meta.rubricSides != null, 'no cis/trans rubric obtained');
                let stereo = WebMolKit.Stereochemistry.create(meta);
                let tet11 = stereo.atomTetraChirality(11);
                this.assert(tet11 == WebMolKit.Stereochemistry.STEREO_NEG, 'atom 11: incorrect stereochemistry, got ' + tet11);
                let tet19 = stereo.atomTetraChirality(19);
                this.assert(tet19 == WebMolKit.Stereochemistry.STEREO_POS, 'atom 19: incorrect stereochemistry, got ' + tet19);
                let tet20 = stereo.atomTetraChirality(20);
                this.assert(tet20 == WebMolKit.Stereochemistry.STEREO_POS, 'atom 20: incorrect stereochemistry, got ' + tet20);
                let side26 = stereo.bondSideStereo(26);
                this.assert(side26 == WebMolKit.Stereochemistry.STEREO_NEG, 'bond 26: incorrect stereochemistry, got ' + side26);
            });
        }
        calcFingerprints() {
            return __awaiter(this, void 0, void 0, function* () {
                this.assert(this.dsCircular != null, 'datasheet not loaded');
                const ds = this.dsCircular;
                for (let n = 0; n < ds.numRows; n++) {
                    let mol = ds.getMolecule(n, 'Molecule');
                    let ecfp0 = [], ecfp2 = [], ecfp4 = [], ecfp6 = [];
                    for (let fp of ds.getString(n, 'ECFP0').split(','))
                        if (fp.length > 0)
                            ecfp0.push(parseInt(fp));
                    for (let fp of ds.getString(n, 'ECFP2').split(','))
                        if (fp.length > 0)
                            ecfp2.push(parseInt(fp));
                    for (let fp of ds.getString(n, 'ECFP4').split(','))
                        if (fp.length > 0)
                            ecfp4.push(parseInt(fp));
                    for (let fp of ds.getString(n, 'ECFP6').split(','))
                        if (fp.length > 0)
                            ecfp6.push(parseInt(fp));
                    WebMolKit.Vec.sort(ecfp0);
                    WebMolKit.Vec.sort(ecfp2);
                    WebMolKit.Vec.sort(ecfp4);
                    WebMolKit.Vec.sort(ecfp6);
                    let circ = WebMolKit.CircularFingerprints.create(mol, WebMolKit.CircularFingerprints.CLASS_ECFP6);
                    let got = [[], [], [], []];
                    for (let fp of circ.getFingerprints())
                        if (got[fp.iteration].indexOf(fp.hashCode) < 0)
                            got[fp.iteration].push(fp.hashCode);
                    for (let ecfp of got)
                        WebMolKit.Vec.sort(ecfp);
                    this.assert(WebMolKit.Vec.equals(ecfp0, got[0]), 'row#' + (n + 1) + ', iter#0: wanted ' + ecfp0 + ', got ' + got[0]);
                    this.assert(WebMolKit.Vec.equals(ecfp2, got[1]), 'row#' + (n + 1) + ', iter#1: wanted ' + ecfp2 + ', got ' + got[1]);
                    this.assert(WebMolKit.Vec.equals(ecfp4, got[2]), 'row#' + (n + 1) + ', iter#2: wanted ' + ecfp4 + ', got ' + got[2]);
                    this.assert(WebMolKit.Vec.equals(ecfp6, got[3]), 'row#' + (n + 1) + ', iter#3: wanted ' + ecfp6 + ', got ' + got[3]);
                }
            });
        }
        molfileRoundTrip() {
            return __awaiter(this, void 0, void 0, function* () {
                const ds = this.dsRoundtrip;
                for (let n = 0; n < ds.numRows; n++) {
                    let strRow = 'row#' + (n + 1);
                    let mol = ds.getMolecule(n, 'Molecule');
                    let mdl = new WebMolKit.MDLMOLWriter(mol).write();
                    let alt = new WebMolKit.MDLMOLReader(mdl).parse();
                    this.assert(mol.numAtoms == alt.numAtoms && mol.numBonds == alt.numBonds, strRow + ', atom/bond count differs');
                    let problems = [];
                    for (let i = 1; i <= mol.numAtoms; i++) {
                        if (mol.atomElement(i) != alt.atomElement(i))
                            problems.push(strRow + '/atom #' + i + ': elements different');
                        if (mol.atomCharge(i) != alt.atomCharge(i))
                            problems.push(strRow + '/atom #' + i + ': charges different');
                        if (mol.atomUnpaired(i) != alt.atomUnpaired(i))
                            problems.push(strRow + '/atom #' + i + ': unpaired different');
                        if (mol.atomIsotope(i) != alt.atomIsotope(i))
                            problems.push(strRow + '/atom #' + i + ': isotope different');
                        if (mol.atomMapNum(i) != alt.atomMapNum(i))
                            problems.push(strRow + '/atom #' + i + ': mapnum different');
                        if (mol.atomHydrogens(i) != alt.atomHydrogens(i))
                            problems.push(strRow + '/atom #' + i + ': hydrogens different');
                        if (mol.atomHExplicit(i) != alt.atomHExplicit(i))
                            problems.push(strRow + '/atom #' + i + ': explicitH different');
                    }
                    for (let i = 1; i <= mol.numBonds; i++) {
                        if (mol.bondOrder(i) != alt.bondOrder(i))
                            problems.push(strRow + '/bond #' + i + ': bond orders different');
                        if (mol.bondType(i) != alt.bondType(i))
                            problems.push(strRow + '/bond #' + i + ': bond types different');
                    }
                    if (problems.length > 0) {
                        console.log('Round trip problems:');
                        for (let p of problems)
                            console.log(p);
                        console.log('Original molecule:\n' + mol);
                        console.log('MDL Molfile CTAB:\n' + mdl);
                        console.log('Parsed back molecule:\n' + alt);
                    }
                    this.assert(problems.length == 0, problems.join('; '));
                    let wantMDL = ds.getString(n, 'Molfile');
                    if (mdl.trim() != WebMolKit.orBlank(wantMDL).trim()) {
                        if (wantMDL)
                            console.log('Molfile missing from validation data.');
                        else
                            console.log('Desired Molfile:\n' + wantMDL);
                        console.log('Got Molfile:\n' + mdl);
                        this.assert(false, strRow + ': initial Molfile invalid');
                    }
                }
            });
        }
    }
    WebMolKit.ValidationHeadlessMolecule = ValidationHeadlessMolecule;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class ValidationHeadlessReaction extends WebMolKit.Validation {
        constructor(urlBase) {
            super();
            this.urlBase = urlBase;
            this.add('Experiment aspect', this.confirmAspect);
        }
        init() {
            return __awaiter(this, void 0, void 0, function* () {
                this.strExperiment = yield WebMolKit.readTextURL(this.urlBase + 'experiment.ds');
            });
        }
        confirmAspect() {
            return __awaiter(this, void 0, void 0, function* () {
                this.assert(!!this.strExperiment, 'datasheet not loaded');
                let ds = WebMolKit.DataSheetStream.readXML(this.strExperiment);
                this.assert(ds != null, 'parsing failed');
                this.assert(WebMolKit.Experiment.isExperiment(ds), 'aspect claimed not an Experiment');
                let xs = new WebMolKit.Experiment(ds);
                let entry = xs.getEntry(0);
                this.assert(entry != null, 'null entry returned');
                this.assert(entry.steps.length == 2, 'reaction supposed to be 2 steps, got ' + entry.steps.length);
                this.assert(entry.steps[0].reactants.length == 1, 'require step 1: #reactants = 1');
                this.assert(entry.steps[0].reagents.length == 3, 'require step 1: #reagents = 3');
                this.assert(entry.steps[0].products.length == 2, 'require step 1: #products = 2');
                this.assert(entry.steps[1].reactants.length == 0, 'require step 2: #reactants = 0');
                this.assert(entry.steps[1].reagents.length == 1, 'require step 2: #reagents = 1');
                this.assert(entry.steps[1].products.length == 2, 'require step 2: #products = 2');
            });
        }
    }
    WebMolKit.ValidationHeadlessReaction = ValidationHeadlessReaction;
})(WebMolKit || (WebMolKit = {}));
var WebMolKit;
(function (WebMolKit) {
    class WebValExec {
        constructor(validation) {
            this.validation = validation;
        }
        runTests(parent) {
            return __awaiter(this, void 0, void 0, function* () {
                let domParent = WebMolKit.dom(parent);
                domParent.empty();
                if (this.validation.setupError) {
                    let div = WebMolKit.dom('<div/>').appendTo(domParent).css({ 'color': 'red' });
                    div.setText('Setup failed: ' + this.validation.setupError);
                    return;
                }
                let table = WebMolKit.dom('<table/>').appendTo(domParent);
                let tdStatus = [], tdInfo = [];
                for (let n = 0; n < this.validation.count; n++) {
                    let tr = WebMolKit.dom('<tr/>').appendTo(table);
                    let td = WebMolKit.dom('<td valign="top"/>').appendTo(tr);
                    tdStatus.push(td);
                    td = WebMolKit.dom('<td valign="top"></td>').appendTo(tr);
                    td.setText(this.validation.getTitle(n));
                    tdInfo.push(td);
                }
                for (let n = 0; n < this.validation.count; n++) {
                    tdStatus[n].setHTML('&#9744;');
                    let [success, message, time] = yield this.validation.runTest(n);
                    if (success) {
                        tdStatus[n].setHTML('&#9745;');
                        if (time >= 0.001) {
                            let span = WebMolKit.dom('<span style="color: #909090;"/>').appendTo(tdInfo[n]);
                            span.setText(' (' + time.toFixed(3) + ' sec)');
                        }
                    }
                    else {
                        tdStatus[n].setHTML('<span style="color: red;">&#9746;</span>');
                        let para = WebMolKit.dom('<p style="color: purple; margin-top: 0;"/>').appendTo(tdInfo[n]);
                        para.setText(message ? message : 'failed');
                        tdStatus[n].setCSS('background-color', '#FFF0F0');
                        tdInfo[n].setCSS('background-color', '#FFF0F0');
                    }
                }
            });
        }
    }
    WebMolKit.WebValExec = WebValExec;
})(WebMolKit || (WebMolKit = {}));
//# sourceMappingURL=webmolkit-build.js.map