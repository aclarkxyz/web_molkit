/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var WebMolKit;
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./dist/index-src.ts":
/*!***************************!*\
  !*** ./dist/index-src.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ASCENT_FUDGE\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.ASCENT_FUDGE),\n/* harmony export */   \"AbbrevContainer\": () => (/* reexport safe */ _src_data_AbbrevContainer__WEBPACK_IMPORTED_MODULE_14__.AbbrevContainer),\n/* harmony export */   \"ActivityType\": () => (/* reexport safe */ _src_sketcher_MoleculeActivity__WEBPACK_IMPORTED_MODULE_58__.ActivityType),\n/* harmony export */   \"ArrangeComponent\": () => (/* reexport safe */ _src_gfx_ArrangeExperiment__WEBPACK_IMPORTED_MODULE_40__.ArrangeComponent),\n/* harmony export */   \"ArrangeComponentAnnot\": () => (/* reexport safe */ _src_gfx_ArrangeExperiment__WEBPACK_IMPORTED_MODULE_40__.ArrangeComponentAnnot),\n/* harmony export */   \"ArrangeComponentType\": () => (/* reexport safe */ _src_gfx_ArrangeExperiment__WEBPACK_IMPORTED_MODULE_40__.ArrangeComponentType),\n/* harmony export */   \"ArrangeExperiment\": () => (/* reexport safe */ _src_gfx_ArrangeExperiment__WEBPACK_IMPORTED_MODULE_40__.ArrangeExperiment),\n/* harmony export */   \"ArrangeMolecule\": () => (/* reexport safe */ _src_gfx_ArrangeMolecule__WEBPACK_IMPORTED_MODULE_42__.ArrangeMolecule),\n/* harmony export */   \"Aspect\": () => (/* reexport safe */ _src_aspect_Aspect__WEBPACK_IMPORTED_MODULE_0__.Aspect),\n/* harmony export */   \"AspectList\": () => (/* reexport safe */ _src_aspect_AspectList__WEBPACK_IMPORTED_MODULE_1__.AspectList),\n/* harmony export */   \"AssayProvenance\": () => (/* reexport safe */ _src_aspect_AssayProvenance__WEBPACK_IMPORTED_MODULE_2__.AssayProvenance),\n/* harmony export */   \"AssayProvenanceHeader\": () => (/* reexport safe */ _src_aspect_AssayProvenance__WEBPACK_IMPORTED_MODULE_2__.AssayProvenanceHeader),\n/* harmony export */   \"AxisLabeller\": () => (/* reexport safe */ _src_gfx_AxisLabeller__WEBPACK_IMPORTED_MODULE_43__.AxisLabeller),\n/* harmony export */   \"BLineType\": () => (/* reexport safe */ _src_gfx_ArrangeMolecule__WEBPACK_IMPORTED_MODULE_42__.BLineType),\n/* harmony export */   \"BONDARTIFACT_EXTRA_ARENE\": () => (/* reexport safe */ _src_data_BondArtifact__WEBPACK_IMPORTED_MODULE_15__.BONDARTIFACT_EXTRA_ARENE),\n/* harmony export */   \"BONDARTIFACT_EXTRA_RESPATH\": () => (/* reexport safe */ _src_data_BondArtifact__WEBPACK_IMPORTED_MODULE_15__.BONDARTIFACT_EXTRA_RESPATH),\n/* harmony export */   \"BONDARTIFACT_EXTRA_RESRING\": () => (/* reexport safe */ _src_data_BondArtifact__WEBPACK_IMPORTED_MODULE_15__.BONDARTIFACT_EXTRA_RESRING),\n/* harmony export */   \"BayesianModel\": () => (/* reexport safe */ _src_calc_BayesianModel__WEBPACK_IMPORTED_MODULE_10__.BayesianModel),\n/* harmony export */   \"BayesianPrediction\": () => (/* reexport safe */ _src_aspect_BayesianPrediction__WEBPACK_IMPORTED_MODULE_3__.BayesianPrediction),\n/* harmony export */   \"BayesianPredictionModel\": () => (/* reexport safe */ _src_aspect_BayesianPrediction__WEBPACK_IMPORTED_MODULE_3__.BayesianPredictionModel),\n/* harmony export */   \"BayesianPredictionOutcome\": () => (/* reexport safe */ _src_aspect_BayesianPrediction__WEBPACK_IMPORTED_MODULE_3__.BayesianPredictionOutcome),\n/* harmony export */   \"BayesianSource\": () => (/* reexport safe */ _src_aspect_BayesianSource__WEBPACK_IMPORTED_MODULE_4__.BayesianSource),\n/* harmony export */   \"BayesianSourceModel\": () => (/* reexport safe */ _src_aspect_BayesianSource__WEBPACK_IMPORTED_MODULE_4__.BayesianSourceModel),\n/* harmony export */   \"BinaryData\": () => (/* reexport safe */ _src_aspect_BinaryData__WEBPACK_IMPORTED_MODULE_5__.BinaryData),\n/* harmony export */   \"BinaryDataField\": () => (/* reexport safe */ _src_aspect_BinaryData__WEBPACK_IMPORTED_MODULE_5__.BinaryDataField),\n/* harmony export */   \"BondArtifact\": () => (/* reexport safe */ _src_data_BondArtifact__WEBPACK_IMPORTED_MODULE_15__.BondArtifact),\n/* harmony export */   \"Box\": () => (/* reexport safe */ _src_util_Geom__WEBPACK_IMPORTED_MODULE_78__.Box),\n/* harmony export */   \"BuildSMILES\": () => (/* reexport safe */ _src_calc_BuildSMILES__WEBPACK_IMPORTED_MODULE_11__.BuildSMILES),\n/* harmony export */   \"ButtonBank\": () => (/* reexport safe */ _src_ui_ButtonBank__WEBPACK_IMPORTED_MODULE_65__.ButtonBank),\n/* harmony export */   \"ButtonView\": () => (/* reexport safe */ _src_ui_ButtonView__WEBPACK_IMPORTED_MODULE_66__.ButtonView),\n/* harmony export */   \"ButtonViewPosition\": () => (/* reexport safe */ _src_ui_ButtonView__WEBPACK_IMPORTED_MODULE_66__.ButtonViewPosition),\n/* harmony export */   \"Chemistry\": () => (/* reexport safe */ _src_data_Chemistry__WEBPACK_IMPORTED_MODULE_16__.Chemistry),\n/* harmony export */   \"CircularFingerprints\": () => (/* reexport safe */ _src_calc_CircularFingerprints__WEBPACK_IMPORTED_MODULE_12__.CircularFingerprints),\n/* harmony export */   \"ClipboardProxy\": () => (/* reexport safe */ _src_ui_ClipboardProxy__WEBPACK_IMPORTED_MODULE_67__.ClipboardProxy),\n/* harmony export */   \"ClipboardProxyHandler\": () => (/* reexport safe */ _src_ui_ClipboardProxy__WEBPACK_IMPORTED_MODULE_67__.ClipboardProxyHandler),\n/* harmony export */   \"ClipboardProxyWeb\": () => (/* reexport safe */ _src_ui_ClipboardProxy__WEBPACK_IMPORTED_MODULE_67__.ClipboardProxyWeb),\n/* harmony export */   \"CommandBank\": () => (/* reexport safe */ _src_sketcher_CommandBank__WEBPACK_IMPORTED_MODULE_49__.CommandBank),\n/* harmony export */   \"ContextSketch\": () => (/* reexport safe */ _src_sketcher_ContextSketch__WEBPACK_IMPORTED_MODULE_50__.ContextSketch),\n/* harmony export */   \"CoordUtil\": () => (/* reexport safe */ _src_data_CoordUtil__WEBPACK_IMPORTED_MODULE_17__.CoordUtil),\n/* harmony export */   \"DEGRAD\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.DEGRAD),\n/* harmony export */   \"DOM\": () => (/* reexport safe */ _src_util_dom__WEBPACK_IMPORTED_MODULE_85__.DOM),\n/* harmony export */   \"DataSheet\": () => (/* reexport safe */ _src_data_DataSheet__WEBPACK_IMPORTED_MODULE_18__.DataSheet),\n/* harmony export */   \"DataSheetColumn\": () => (/* reexport safe */ _src_data_DataSheet__WEBPACK_IMPORTED_MODULE_18__.DataSheetColumn),\n/* harmony export */   \"DataSheetStream\": () => (/* reexport safe */ _src_data_DataSheetStream__WEBPACK_IMPORTED_MODULE_19__.DataSheetStream),\n/* harmony export */   \"Dialog\": () => (/* reexport safe */ _src_dialog_Dialog__WEBPACK_IMPORTED_MODULE_38__.Dialog),\n/* harmony export */   \"DotPath\": () => (/* reexport safe */ _src_data_DotPath__WEBPACK_IMPORTED_MODULE_20__.DotPath),\n/* harmony export */   \"DotPathBond\": () => (/* reexport safe */ _src_data_DotPath__WEBPACK_IMPORTED_MODULE_20__.DotPathBond),\n/* harmony export */   \"DotPathCharge\": () => (/* reexport safe */ _src_data_DotPath__WEBPACK_IMPORTED_MODULE_20__.DotPathCharge),\n/* harmony export */   \"DraggingTool\": () => (/* reexport safe */ _src_sketcher_DrawCanvas__WEBPACK_IMPORTED_MODULE_51__.DraggingTool),\n/* harmony export */   \"DrawCanvas\": () => (/* reexport safe */ _src_sketcher_DrawCanvas__WEBPACK_IMPORTED_MODULE_51__.DrawCanvas),\n/* harmony export */   \"DrawCanvasDecoration\": () => (/* reexport safe */ _src_sketcher_DrawCanvas__WEBPACK_IMPORTED_MODULE_51__.DrawCanvasDecoration),\n/* harmony export */   \"DrawExperiment\": () => (/* reexport safe */ _src_gfx_DrawExperiment__WEBPACK_IMPORTED_MODULE_44__.DrawExperiment),\n/* harmony export */   \"DrawMolecule\": () => (/* reexport safe */ _src_gfx_DrawMolecule__WEBPACK_IMPORTED_MODULE_45__.DrawMolecule),\n/* harmony export */   \"EditAtom\": () => (/* reexport safe */ _src_sketcher_EditAtom__WEBPACK_IMPORTED_MODULE_52__.EditAtom),\n/* harmony export */   \"EditBond\": () => (/* reexport safe */ _src_sketcher_EditBond__WEBPACK_IMPORTED_MODULE_53__.EditBond),\n/* harmony export */   \"EditCompound\": () => (/* reexport safe */ _src_dialog_EditCompound__WEBPACK_IMPORTED_MODULE_39__.EditCompound),\n/* harmony export */   \"EditPolymer\": () => (/* reexport safe */ _src_sketcher_EditPolymer__WEBPACK_IMPORTED_MODULE_54__.EditPolymer),\n/* harmony export */   \"EmbedChemistry\": () => (/* reexport safe */ _src_ui_EmbedChemistry__WEBPACK_IMPORTED_MODULE_68__.EmbedChemistry),\n/* harmony export */   \"EmbedCollection\": () => (/* reexport safe */ _src_ui_EmbedCollection__WEBPACK_IMPORTED_MODULE_69__.EmbedCollection),\n/* harmony export */   \"EmbedMolecule\": () => (/* reexport safe */ _src_ui_EmbedMolecule__WEBPACK_IMPORTED_MODULE_70__.EmbedMolecule),\n/* harmony export */   \"EmbedReaction\": () => (/* reexport safe */ _src_ui_EmbedReaction__WEBPACK_IMPORTED_MODULE_71__.EmbedReaction),\n/* harmony export */   \"EmbedReactionFacet\": () => (/* reexport safe */ _src_ui_EmbedReaction__WEBPACK_IMPORTED_MODULE_71__.EmbedReactionFacet),\n/* harmony export */   \"Experiment\": () => (/* reexport safe */ _src_aspect_Experiment__WEBPACK_IMPORTED_MODULE_6__.Experiment),\n/* harmony export */   \"ExperimentComponent\": () => (/* reexport safe */ _src_aspect_Experiment__WEBPACK_IMPORTED_MODULE_6__.ExperimentComponent),\n/* harmony export */   \"ExperimentComponentType\": () => (/* reexport safe */ _src_aspect_Experiment__WEBPACK_IMPORTED_MODULE_6__.ExperimentComponentType),\n/* harmony export */   \"ExperimentEntry\": () => (/* reexport safe */ _src_aspect_Experiment__WEBPACK_IMPORTED_MODULE_6__.ExperimentEntry),\n/* harmony export */   \"ExperimentMeta\": () => (/* reexport safe */ _src_data_ExperimentMeta__WEBPACK_IMPORTED_MODULE_21__.ExperimentMeta),\n/* harmony export */   \"ExperimentMetaApplic\": () => (/* reexport safe */ _src_data_ExperimentMeta__WEBPACK_IMPORTED_MODULE_21__.ExperimentMetaApplic),\n/* harmony export */   \"ExperimentMetaRoleType\": () => (/* reexport safe */ _src_data_ExperimentMeta__WEBPACK_IMPORTED_MODULE_21__.ExperimentMetaRoleType),\n/* harmony export */   \"ExperimentMetaType\": () => (/* reexport safe */ _src_data_ExperimentMeta__WEBPACK_IMPORTED_MODULE_21__.ExperimentMetaType),\n/* harmony export */   \"ExperimentMetaValue\": () => (/* reexport safe */ _src_data_ExperimentMeta__WEBPACK_IMPORTED_MODULE_21__.ExperimentMetaValue),\n/* harmony export */   \"ExperimentStep\": () => (/* reexport safe */ _src_aspect_Experiment__WEBPACK_IMPORTED_MODULE_6__.ExperimentStep),\n/* harmony export */   \"ExtraFieldsWidget\": () => (/* reexport safe */ _src_sketcher_ExtraFieldsWidget__WEBPACK_IMPORTED_MODULE_55__.ExtraFieldsWidget),\n/* harmony export */   \"FontData\": () => (/* reexport safe */ _src_gfx_FontData__WEBPACK_IMPORTED_MODULE_46__.FontData),\n/* harmony export */   \"ForeignMolecule\": () => (/* reexport safe */ _src_data_ForeignMolecule__WEBPACK_IMPORTED_MODULE_22__.ForeignMolecule),\n/* harmony export */   \"ForeignMoleculeExtra\": () => (/* reexport safe */ _src_data_ForeignMolecule__WEBPACK_IMPORTED_MODULE_22__.ForeignMoleculeExtra),\n/* harmony export */   \"FormatList\": () => (/* reexport safe */ _src_data_FormatList__WEBPACK_IMPORTED_MODULE_23__.FormatList),\n/* harmony export */   \"FusionBank\": () => (/* reexport safe */ _src_sketcher_TemplateBank__WEBPACK_IMPORTED_MODULE_62__.FusionBank),\n/* harmony export */   \"FusionPermutation\": () => (/* reexport safe */ _src_sketcher_TemplateFusion__WEBPACK_IMPORTED_MODULE_63__.FusionPermutation),\n/* harmony export */   \"GeomUtil\": () => (/* reexport safe */ _src_util_Geom__WEBPACK_IMPORTED_MODULE_78__.GeomUtil),\n/* harmony export */   \"GeomWidget\": () => (/* reexport safe */ _src_sketcher_GeomWidget__WEBPACK_IMPORTED_MODULE_56__.GeomWidget),\n/* harmony export */   \"GeomWidgetSelType\": () => (/* reexport safe */ _src_sketcher_GeomWidget__WEBPACK_IMPORTED_MODULE_56__.GeomWidgetSelType),\n/* harmony export */   \"GeomWidgetType\": () => (/* reexport safe */ _src_sketcher_GeomWidget__WEBPACK_IMPORTED_MODULE_56__.GeomWidgetType),\n/* harmony export */   \"Geometry\": () => (/* reexport safe */ _src_data_SketchUtil__WEBPACK_IMPORTED_MODULE_36__.Geometry),\n/* harmony export */   \"Graph\": () => (/* reexport safe */ _src_data_Graph__WEBPACK_IMPORTED_MODULE_24__.Graph),\n/* harmony export */   \"GreenMetrics\": () => (/* reexport safe */ _src_data_QuantityCalc__WEBPACK_IMPORTED_MODULE_34__.GreenMetrics),\n/* harmony export */   \"INV_TWOPI\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.INV_TWOPI),\n/* harmony export */   \"KeyCode\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.KeyCode),\n/* harmony export */   \"Line\": () => (/* reexport safe */ _src_util_Geom__WEBPACK_IMPORTED_MODULE_78__.Line),\n/* harmony export */   \"MDLMOLReader\": () => (/* reexport safe */ _src_data_MDLReader__WEBPACK_IMPORTED_MODULE_25__.MDLMOLReader),\n/* harmony export */   \"MDLMOLWriter\": () => (/* reexport safe */ _src_data_MDLWriter__WEBPACK_IMPORTED_MODULE_26__.MDLMOLWriter),\n/* harmony export */   \"MDLMOL_VALENCE\": () => (/* reexport safe */ _src_data_MDLReader__WEBPACK_IMPORTED_MODULE_25__.MDLMOL_VALENCE),\n/* harmony export */   \"MDLSDFReader\": () => (/* reexport safe */ _src_data_MDLReader__WEBPACK_IMPORTED_MODULE_25__.MDLSDFReader),\n/* harmony export */   \"MDLSDFWriter\": () => (/* reexport safe */ _src_data_MDLWriter__WEBPACK_IMPORTED_MODULE_26__.MDLSDFWriter),\n/* harmony export */   \"Matrix\": () => (/* reexport safe */ _src_util_Matrix__WEBPACK_IMPORTED_MODULE_79__.Matrix),\n/* harmony export */   \"MeasurementData\": () => (/* reexport safe */ _src_aspect_MeasurementData__WEBPACK_IMPORTED_MODULE_7__.MeasurementData),\n/* harmony export */   \"MenuProxy\": () => (/* reexport safe */ _src_ui_MenuProxy__WEBPACK_IMPORTED_MODULE_72__.MenuProxy),\n/* harmony export */   \"MenuProxyWeb\": () => (/* reexport safe */ _src_ui_MenuProxy__WEBPACK_IMPORTED_MODULE_72__.MenuProxyWeb),\n/* harmony export */   \"MetaMolecule\": () => (/* reexport safe */ _src_data_MetaMolecule__WEBPACK_IMPORTED_MODULE_27__.MetaMolecule),\n/* harmony export */   \"MetaVector\": () => (/* reexport safe */ _src_gfx_MetaVector__WEBPACK_IMPORTED_MODULE_47__.MetaVector),\n/* harmony export */   \"MetalLigate\": () => (/* reexport safe */ _src_sketcher_MetalLigate__WEBPACK_IMPORTED_MODULE_57__.MetalLigate),\n/* harmony export */   \"Mixture\": () => (/* reexport safe */ _src_aspect_Mixture__WEBPACK_IMPORTED_MODULE_8__.Mixture),\n/* harmony export */   \"MixtureAttributeType\": () => (/* reexport safe */ _src_aspect_Mixture__WEBPACK_IMPORTED_MODULE_8__.MixtureAttributeType),\n/* harmony export */   \"MolUtil\": () => (/* reexport safe */ _src_data_MolUtil__WEBPACK_IMPORTED_MODULE_28__.MolUtil),\n/* harmony export */   \"Molecule\": () => (/* reexport safe */ _src_data_Molecule__WEBPACK_IMPORTED_MODULE_29__.Molecule),\n/* harmony export */   \"MoleculeActivity\": () => (/* reexport safe */ _src_sketcher_MoleculeActivity__WEBPACK_IMPORTED_MODULE_58__.MoleculeActivity),\n/* harmony export */   \"MoleculeStream\": () => (/* reexport safe */ _src_data_MoleculeStream__WEBPACK_IMPORTED_MODULE_30__.MoleculeStream),\n/* harmony export */   \"OntologyTree\": () => (/* reexport safe */ _src_data_OntologyTree__WEBPACK_IMPORTED_MODULE_31__.OntologyTree),\n/* harmony export */   \"OpenMolSpec\": () => (/* reexport safe */ _src_data_OpenMolSpec__WEBPACK_IMPORTED_MODULE_32__.OpenMolSpec),\n/* harmony export */   \"OpenMolType\": () => (/* reexport safe */ _src_data_OpenMolSpec__WEBPACK_IMPORTED_MODULE_32__.OpenMolType),\n/* harmony export */   \"OptionList\": () => (/* reexport safe */ _src_ui_OptionList__WEBPACK_IMPORTED_MODULE_73__.OptionList),\n/* harmony export */   \"OutlineMeasurement\": () => (/* reexport safe */ _src_gfx_ArrangeMeasurement__WEBPACK_IMPORTED_MODULE_41__.OutlineMeasurement),\n/* harmony export */   \"Oval\": () => (/* reexport safe */ _src_util_Geom__WEBPACK_IMPORTED_MODULE_78__.Oval),\n/* harmony export */   \"POLYMERBLOCK_EXTRA_POLYMER\": () => (/* reexport safe */ _src_data_PolymerBlock__WEBPACK_IMPORTED_MODULE_33__.POLYMERBLOCK_EXTRA_POLYMER),\n/* harmony export */   \"POLYMERBLOCK_SPECIAL_UNCAPPED\": () => (/* reexport safe */ _src_data_PolymerBlock__WEBPACK_IMPORTED_MODULE_33__.POLYMERBLOCK_SPECIAL_UNCAPPED),\n/* harmony export */   \"PeriodicTableWidget\": () => (/* reexport safe */ _src_sketcher_PeriodicTableWidget__WEBPACK_IMPORTED_MODULE_59__.PeriodicTableWidget),\n/* harmony export */   \"Permutation\": () => (/* reexport safe */ _src_util_Vec__WEBPACK_IMPORTED_MODULE_83__.Permutation),\n/* harmony export */   \"PolymerBlock\": () => (/* reexport safe */ _src_data_PolymerBlock__WEBPACK_IMPORTED_MODULE_33__.PolymerBlock),\n/* harmony export */   \"PolymerBlockConnectivity\": () => (/* reexport safe */ _src_data_PolymerBlock__WEBPACK_IMPORTED_MODULE_33__.PolymerBlockConnectivity),\n/* harmony export */   \"PolymerBlockUnit\": () => (/* reexport safe */ _src_data_PolymerBlock__WEBPACK_IMPORTED_MODULE_33__.PolymerBlockUnit),\n/* harmony export */   \"Popup\": () => (/* reexport safe */ _src_ui_Popup__WEBPACK_IMPORTED_MODULE_74__.Popup),\n/* harmony export */   \"Pos\": () => (/* reexport safe */ _src_util_Geom__WEBPACK_IMPORTED_MODULE_78__.Pos),\n/* harmony export */   \"QuantityCalc\": () => (/* reexport safe */ _src_data_QuantityCalc__WEBPACK_IMPORTED_MODULE_34__.QuantityCalc),\n/* harmony export */   \"QuantityCalcComp\": () => (/* reexport safe */ _src_data_QuantityCalc__WEBPACK_IMPORTED_MODULE_34__.QuantityCalcComp),\n/* harmony export */   \"QuantityCalcRole\": () => (/* reexport safe */ _src_data_QuantityCalc__WEBPACK_IMPORTED_MODULE_34__.QuantityCalcRole),\n/* harmony export */   \"QuantityCalcStat\": () => (/* reexport safe */ _src_data_QuantityCalc__WEBPACK_IMPORTED_MODULE_34__.QuantityCalcStat),\n/* harmony export */   \"QueryFieldsWidget\": () => (/* reexport safe */ _src_sketcher_QueryFieldsWidget__WEBPACK_IMPORTED_MODULE_60__.QueryFieldsWidget),\n/* harmony export */   \"QueryTypeAtom\": () => (/* reexport safe */ _src_data_QueryUtil__WEBPACK_IMPORTED_MODULE_35__.QueryTypeAtom),\n/* harmony export */   \"QueryTypeBond\": () => (/* reexport safe */ _src_data_QueryUtil__WEBPACK_IMPORTED_MODULE_35__.QueryTypeBond),\n/* harmony export */   \"QueryUtil\": () => (/* reexport safe */ _src_data_QueryUtil__WEBPACK_IMPORTED_MODULE_35__.QueryUtil),\n/* harmony export */   \"QuickHull\": () => (/* reexport safe */ _src_util_Geom__WEBPACK_IMPORTED_MODULE_78__.QuickHull),\n/* harmony export */   \"RADDEG\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.RADDEG),\n/* harmony export */   \"Random\": () => (/* reexport safe */ _src_util_Random__WEBPACK_IMPORTED_MODULE_80__.Random),\n/* harmony export */   \"RenderEffects\": () => (/* reexport safe */ _src_gfx_Rendering__WEBPACK_IMPORTED_MODULE_48__.RenderEffects),\n/* harmony export */   \"RenderPolicy\": () => (/* reexport safe */ _src_gfx_Rendering__WEBPACK_IMPORTED_MODULE_48__.RenderPolicy),\n/* harmony export */   \"ResonanceRemover\": () => (/* reexport safe */ _src_calc_ResonanceRemover__WEBPACK_IMPORTED_MODULE_13__.ResonanceRemover),\n/* harmony export */   \"RollingBall\": () => (/* reexport safe */ _src_util_Geom__WEBPACK_IMPORTED_MODULE_78__.RollingBall),\n/* harmony export */   \"SARTable\": () => (/* reexport safe */ _src_aspect_SARTable__WEBPACK_IMPORTED_MODULE_9__.SARTable),\n/* harmony export */   \"SingularValueDecomposition\": () => (/* reexport safe */ _src_util_Matrix__WEBPACK_IMPORTED_MODULE_79__.SingularValueDecomposition),\n/* harmony export */   \"Size\": () => (/* reexport safe */ _src_util_Geom__WEBPACK_IMPORTED_MODULE_78__.Size),\n/* harmony export */   \"SketchUtil\": () => (/* reexport safe */ _src_data_SketchUtil__WEBPACK_IMPORTED_MODULE_36__.SketchUtil),\n/* harmony export */   \"Sketcher\": () => (/* reexport safe */ _src_sketcher_Sketcher__WEBPACK_IMPORTED_MODULE_61__.Sketcher),\n/* harmony export */   \"Stereochemistry\": () => (/* reexport safe */ _src_data_Stereochemistry__WEBPACK_IMPORTED_MODULE_37__.Stereochemistry),\n/* harmony export */   \"TEMPLATE_FILES\": () => (/* reexport safe */ _src_data_AbbrevContainer__WEBPACK_IMPORTED_MODULE_14__.TEMPLATE_FILES),\n/* harmony export */   \"TWOPI\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.TWOPI),\n/* harmony export */   \"TabBar\": () => (/* reexport safe */ _src_ui_TabBar__WEBPACK_IMPORTED_MODULE_75__.TabBar),\n/* harmony export */   \"TemplateBank\": () => (/* reexport safe */ _src_sketcher_TemplateBank__WEBPACK_IMPORTED_MODULE_62__.TemplateBank),\n/* harmony export */   \"TemplateFusion\": () => (/* reexport safe */ _src_sketcher_TemplateFusion__WEBPACK_IMPORTED_MODULE_63__.TemplateFusion),\n/* harmony export */   \"TextAlign\": () => (/* reexport safe */ _src_gfx_MetaVector__WEBPACK_IMPORTED_MODULE_47__.TextAlign),\n/* harmony export */   \"Theme\": () => (/* reexport safe */ _src_util_Theme__WEBPACK_IMPORTED_MODULE_81__.Theme),\n/* harmony export */   \"ToolBank\": () => (/* reexport safe */ _src_sketcher_ToolBank__WEBPACK_IMPORTED_MODULE_64__.ToolBank),\n/* harmony export */   \"ToolBankItem\": () => (/* reexport safe */ _src_sketcher_ToolBank__WEBPACK_IMPORTED_MODULE_64__.ToolBankItem),\n/* harmony export */   \"Tooltip\": () => (/* reexport safe */ _src_ui_Tooltip__WEBPACK_IMPORTED_MODULE_76__.Tooltip),\n/* harmony export */   \"Triangulation2D\": () => (/* reexport safe */ _src_util_Triangulation2D__WEBPACK_IMPORTED_MODULE_82__.Triangulation2D),\n/* harmony export */   \"Vec\": () => (/* reexport safe */ _src_util_Vec__WEBPACK_IMPORTED_MODULE_83__.Vec),\n/* harmony export */   \"Widget\": () => (/* reexport safe */ _src_ui_Widget__WEBPACK_IMPORTED_MODULE_77__.Widget),\n/* harmony export */   \"XML\": () => (/* reexport safe */ _src_util_XML__WEBPACK_IMPORTED_MODULE_84__.XML),\n/* harmony export */   \"addText\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.addText),\n/* harmony export */   \"addTooltip\": () => (/* reexport safe */ _src_ui_Tooltip__WEBPACK_IMPORTED_MODULE_76__.addTooltip),\n/* harmony export */   \"angleDiff\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.angleDiff),\n/* harmony export */   \"angleDiffPos\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.angleDiffPos),\n/* harmony export */   \"angleNorm\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.angleNorm),\n/* harmony export */   \"blendRGB\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.blendRGB),\n/* harmony export */   \"clearTooltip\": () => (/* reexport safe */ _src_ui_Tooltip__WEBPACK_IMPORTED_MODULE_76__.clearTooltip),\n/* harmony export */   \"clone\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.clone),\n/* harmony export */   \"colourAlpha\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.colourAlpha),\n/* harmony export */   \"colourCanvas\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.colourCanvas),\n/* harmony export */   \"colourCode\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.colourCode),\n/* harmony export */   \"deepClone\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.deepClone),\n/* harmony export */   \"dictValues\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.dictValues),\n/* harmony export */   \"dom\": () => (/* reexport safe */ _src_util_dom__WEBPACK_IMPORTED_MODULE_85__.dom),\n/* harmony export */   \"domLegacy\": () => (/* reexport safe */ _src_util_dom__WEBPACK_IMPORTED_MODULE_85__.domLegacy),\n/* harmony export */   \"drawLine\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.drawLine),\n/* harmony export */   \"empiricalScrollerSize\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.empiricalScrollerSize),\n/* harmony export */   \"escapeHTML\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.escapeHTML),\n/* harmony export */   \"eventCoords\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.eventCoords),\n/* harmony export */   \"findNode\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.findNode),\n/* harmony export */   \"findNodes\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.findNodes),\n/* harmony export */   \"fltEqual\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.fltEqual),\n/* harmony export */   \"fontSansSerif\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.fontSansSerif),\n/* harmony export */   \"formatDate\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.formatDate),\n/* harmony export */   \"formatDouble\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.formatDouble),\n/* harmony export */   \"fromUTF8\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.fromUTF8),\n/* harmony export */   \"getBoundaryPixelsDOM\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.getBoundaryPixelsDOM),\n/* harmony export */   \"getOffsetPixelsDOM\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.getOffsetPixelsDOM),\n/* harmony export */   \"hasInlineCSS\": () => (/* reexport safe */ _src_util_Theme__WEBPACK_IMPORTED_MODULE_81__.hasInlineCSS),\n/* harmony export */   \"htmlToRGB\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.htmlToRGB),\n/* harmony export */   \"initWebMolKit\": () => (/* reexport safe */ _src_util_Theme__WEBPACK_IMPORTED_MODULE_81__.initWebMolKit),\n/* harmony export */   \"installInlineCSS\": () => (/* reexport safe */ _src_util_Theme__WEBPACK_IMPORTED_MODULE_81__.installInlineCSS),\n/* harmony export */   \"invZ\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.invZ),\n/* harmony export */   \"isDef\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.isDef),\n/* harmony export */   \"jsonPrettyPrint\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.jsonPrettyPrint),\n/* harmony export */   \"maxArray\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.maxArray),\n/* harmony export */   \"minArray\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.minArray),\n/* harmony export */   \"newElement\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.newElement),\n/* harmony export */   \"nodeText\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.nodeText),\n/* harmony export */   \"norm2_xy\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.norm2_xy),\n/* harmony export */   \"norm2_xyz\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.norm2_xyz),\n/* harmony export */   \"norm_xy\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.norm_xy),\n/* harmony export */   \"norm_xyz\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.norm_xyz),\n/* harmony export */   \"notDef\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.notDef),\n/* harmony export */   \"orBlank\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.orBlank),\n/* harmony export */   \"pathRoundedRect\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.pathRoundedRect),\n/* harmony export */   \"pixelDensity\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.pixelDensity),\n/* harmony export */   \"plural\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.plural),\n/* harmony export */   \"postJSONURL\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.postJSONURL),\n/* harmony export */   \"raiseToolTip\": () => (/* reexport safe */ _src_ui_Tooltip__WEBPACK_IMPORTED_MODULE_76__.raiseToolTip),\n/* harmony export */   \"randomInt\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.randomInt),\n/* harmony export */   \"readTextURL\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.readTextURL),\n/* harmony export */   \"realEqual\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.realEqual),\n/* harmony export */   \"registerAspect\": () => (/* reexport safe */ _src_aspect_AspectList__WEBPACK_IMPORTED_MODULE_1__.registerAspect),\n/* harmony export */   \"safeFloat\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.safeFloat),\n/* harmony export */   \"safeInt\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.safeInt),\n/* harmony export */   \"setBoundaryPixels\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.setBoundaryPixels),\n/* harmony export */   \"signum\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.signum),\n/* harmony export */   \"sortAngles\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.sortAngles),\n/* harmony export */   \"sqr\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.sqr),\n/* harmony export */   \"toUTF8\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.toUTF8),\n/* harmony export */   \"uniqueAngles\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.uniqueAngles),\n/* harmony export */   \"yieldDOM\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.yieldDOM),\n/* harmony export */   \"zip\": () => (/* reexport safe */ _src_util_util__WEBPACK_IMPORTED_MODULE_86__.zip)\n/* harmony export */ });\n/* harmony import */ var _src_aspect_Aspect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/aspect/Aspect */ \"./src/aspect/Aspect.ts\");\n/* harmony import */ var _src_aspect_AspectList__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/aspect/AspectList */ \"./src/aspect/AspectList.ts\");\n/* harmony import */ var _src_aspect_AssayProvenance__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/aspect/AssayProvenance */ \"./src/aspect/AssayProvenance.ts\");\n/* harmony import */ var _src_aspect_BayesianPrediction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/aspect/BayesianPrediction */ \"./src/aspect/BayesianPrediction.ts\");\n/* harmony import */ var _src_aspect_BayesianSource__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/aspect/BayesianSource */ \"./src/aspect/BayesianSource.ts\");\n/* harmony import */ var _src_aspect_BinaryData__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/aspect/BinaryData */ \"./src/aspect/BinaryData.ts\");\n/* harmony import */ var _src_aspect_Experiment__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/aspect/Experiment */ \"./src/aspect/Experiment.ts\");\n/* harmony import */ var _src_aspect_MeasurementData__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/aspect/MeasurementData */ \"./src/aspect/MeasurementData.ts\");\n/* harmony import */ var _src_aspect_Mixture__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/aspect/Mixture */ \"./src/aspect/Mixture.ts\");\n/* harmony import */ var _src_aspect_SARTable__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../src/aspect/SARTable */ \"./src/aspect/SARTable.ts\");\n/* harmony import */ var _src_calc_BayesianModel__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../src/calc/BayesianModel */ \"./src/calc/BayesianModel.ts\");\n/* harmony import */ var _src_calc_BuildSMILES__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../src/calc/BuildSMILES */ \"./src/calc/BuildSMILES.ts\");\n/* harmony import */ var _src_calc_CircularFingerprints__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../src/calc/CircularFingerprints */ \"./src/calc/CircularFingerprints.ts\");\n/* harmony import */ var _src_calc_ResonanceRemover__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../src/calc/ResonanceRemover */ \"./src/calc/ResonanceRemover.ts\");\n/* harmony import */ var _src_data_AbbrevContainer__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../src/data/AbbrevContainer */ \"./src/data/AbbrevContainer.ts\");\n/* harmony import */ var _src_data_BondArtifact__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../src/data/BondArtifact */ \"./src/data/BondArtifact.ts\");\n/* harmony import */ var _src_data_Chemistry__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../src/data/Chemistry */ \"./src/data/Chemistry.ts\");\n/* harmony import */ var _src_data_CoordUtil__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../src/data/CoordUtil */ \"./src/data/CoordUtil.ts\");\n/* harmony import */ var _src_data_DataSheet__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../src/data/DataSheet */ \"./src/data/DataSheet.ts\");\n/* harmony import */ var _src_data_DataSheetStream__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../src/data/DataSheetStream */ \"./src/data/DataSheetStream.ts\");\n/* harmony import */ var _src_data_DotPath__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../src/data/DotPath */ \"./src/data/DotPath.ts\");\n/* harmony import */ var _src_data_ExperimentMeta__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../src/data/ExperimentMeta */ \"./src/data/ExperimentMeta.ts\");\n/* harmony import */ var _src_data_ForeignMolecule__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../src/data/ForeignMolecule */ \"./src/data/ForeignMolecule.ts\");\n/* harmony import */ var _src_data_FormatList__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../src/data/FormatList */ \"./src/data/FormatList.ts\");\n/* harmony import */ var _src_data_Graph__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../src/data/Graph */ \"./src/data/Graph.ts\");\n/* harmony import */ var _src_data_MDLReader__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../src/data/MDLReader */ \"./src/data/MDLReader.ts\");\n/* harmony import */ var _src_data_MDLWriter__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../src/data/MDLWriter */ \"./src/data/MDLWriter.ts\");\n/* harmony import */ var _src_data_MetaMolecule__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../src/data/MetaMolecule */ \"./src/data/MetaMolecule.ts\");\n/* harmony import */ var _src_data_MolUtil__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../src/data/MolUtil */ \"./src/data/MolUtil.ts\");\n/* harmony import */ var _src_data_Molecule__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ../src/data/Molecule */ \"./src/data/Molecule.ts\");\n/* harmony import */ var _src_data_MoleculeStream__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ../src/data/MoleculeStream */ \"./src/data/MoleculeStream.ts\");\n/* harmony import */ var _src_data_OntologyTree__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ../src/data/OntologyTree */ \"./src/data/OntologyTree.ts\");\n/* harmony import */ var _src_data_OpenMolSpec__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ../src/data/OpenMolSpec */ \"./src/data/OpenMolSpec.ts\");\n/* harmony import */ var _src_data_PolymerBlock__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ../src/data/PolymerBlock */ \"./src/data/PolymerBlock.ts\");\n/* harmony import */ var _src_data_QuantityCalc__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ../src/data/QuantityCalc */ \"./src/data/QuantityCalc.ts\");\n/* harmony import */ var _src_data_QueryUtil__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ../src/data/QueryUtil */ \"./src/data/QueryUtil.ts\");\n/* harmony import */ var _src_data_SketchUtil__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ../src/data/SketchUtil */ \"./src/data/SketchUtil.ts\");\n/* harmony import */ var _src_data_Stereochemistry__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ../src/data/Stereochemistry */ \"./src/data/Stereochemistry.ts\");\n/* harmony import */ var _src_dialog_Dialog__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ../src/dialog/Dialog */ \"./src/dialog/Dialog.ts\");\n/* harmony import */ var _src_dialog_EditCompound__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ../src/dialog/EditCompound */ \"./src/dialog/EditCompound.ts\");\n/* harmony import */ var _src_gfx_ArrangeExperiment__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ../src/gfx/ArrangeExperiment */ \"./src/gfx/ArrangeExperiment.ts\");\n/* harmony import */ var _src_gfx_ArrangeMeasurement__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ../src/gfx/ArrangeMeasurement */ \"./src/gfx/ArrangeMeasurement.ts\");\n/* harmony import */ var _src_gfx_ArrangeMolecule__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ../src/gfx/ArrangeMolecule */ \"./src/gfx/ArrangeMolecule.ts\");\n/* harmony import */ var _src_gfx_AxisLabeller__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ../src/gfx/AxisLabeller */ \"./src/gfx/AxisLabeller.ts\");\n/* harmony import */ var _src_gfx_DrawExperiment__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ../src/gfx/DrawExperiment */ \"./src/gfx/DrawExperiment.ts\");\n/* harmony import */ var _src_gfx_DrawMolecule__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ../src/gfx/DrawMolecule */ \"./src/gfx/DrawMolecule.ts\");\n/* harmony import */ var _src_gfx_FontData__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ../src/gfx/FontData */ \"./src/gfx/FontData.ts\");\n/* harmony import */ var _src_gfx_MetaVector__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ../src/gfx/MetaVector */ \"./src/gfx/MetaVector.ts\");\n/* harmony import */ var _src_gfx_Rendering__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ../src/gfx/Rendering */ \"./src/gfx/Rendering.ts\");\n/* harmony import */ var _src_sketcher_CommandBank__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ../src/sketcher/CommandBank */ \"./src/sketcher/CommandBank.ts\");\n/* harmony import */ var _src_sketcher_ContextSketch__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ../src/sketcher/ContextSketch */ \"./src/sketcher/ContextSketch.ts\");\n/* harmony import */ var _src_sketcher_DrawCanvas__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ../src/sketcher/DrawCanvas */ \"./src/sketcher/DrawCanvas.ts\");\n/* harmony import */ var _src_sketcher_EditAtom__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ../src/sketcher/EditAtom */ \"./src/sketcher/EditAtom.ts\");\n/* harmony import */ var _src_sketcher_EditBond__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ../src/sketcher/EditBond */ \"./src/sketcher/EditBond.ts\");\n/* harmony import */ var _src_sketcher_EditPolymer__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ../src/sketcher/EditPolymer */ \"./src/sketcher/EditPolymer.ts\");\n/* harmony import */ var _src_sketcher_ExtraFieldsWidget__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ../src/sketcher/ExtraFieldsWidget */ \"./src/sketcher/ExtraFieldsWidget.ts\");\n/* harmony import */ var _src_sketcher_GeomWidget__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ../src/sketcher/GeomWidget */ \"./src/sketcher/GeomWidget.ts\");\n/* harmony import */ var _src_sketcher_MetalLigate__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ../src/sketcher/MetalLigate */ \"./src/sketcher/MetalLigate.ts\");\n/* harmony import */ var _src_sketcher_MoleculeActivity__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ../src/sketcher/MoleculeActivity */ \"./src/sketcher/MoleculeActivity.ts\");\n/* harmony import */ var _src_sketcher_PeriodicTableWidget__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ../src/sketcher/PeriodicTableWidget */ \"./src/sketcher/PeriodicTableWidget.ts\");\n/* harmony import */ var _src_sketcher_QueryFieldsWidget__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ../src/sketcher/QueryFieldsWidget */ \"./src/sketcher/QueryFieldsWidget.ts\");\n/* harmony import */ var _src_sketcher_Sketcher__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ../src/sketcher/Sketcher */ \"./src/sketcher/Sketcher.ts\");\n/* harmony import */ var _src_sketcher_TemplateBank__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ../src/sketcher/TemplateBank */ \"./src/sketcher/TemplateBank.ts\");\n/* harmony import */ var _src_sketcher_TemplateFusion__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ../src/sketcher/TemplateFusion */ \"./src/sketcher/TemplateFusion.ts\");\n/* harmony import */ var _src_sketcher_ToolBank__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ../src/sketcher/ToolBank */ \"./src/sketcher/ToolBank.ts\");\n/* harmony import */ var _src_ui_ButtonBank__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ../src/ui/ButtonBank */ \"./src/ui/ButtonBank.ts\");\n/* harmony import */ var _src_ui_ButtonView__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ../src/ui/ButtonView */ \"./src/ui/ButtonView.ts\");\n/* harmony import */ var _src_ui_ClipboardProxy__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ../src/ui/ClipboardProxy */ \"./src/ui/ClipboardProxy.ts\");\n/* harmony import */ var _src_ui_EmbedChemistry__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ../src/ui/EmbedChemistry */ \"./src/ui/EmbedChemistry.ts\");\n/* harmony import */ var _src_ui_EmbedCollection__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ../src/ui/EmbedCollection */ \"./src/ui/EmbedCollection.ts\");\n/* harmony import */ var _src_ui_EmbedMolecule__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ../src/ui/EmbedMolecule */ \"./src/ui/EmbedMolecule.ts\");\n/* harmony import */ var _src_ui_EmbedReaction__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ../src/ui/EmbedReaction */ \"./src/ui/EmbedReaction.ts\");\n/* harmony import */ var _src_ui_MenuProxy__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ../src/ui/MenuProxy */ \"./src/ui/MenuProxy.ts\");\n/* harmony import */ var _src_ui_OptionList__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ../src/ui/OptionList */ \"./src/ui/OptionList.ts\");\n/* harmony import */ var _src_ui_Popup__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ../src/ui/Popup */ \"./src/ui/Popup.ts\");\n/* harmony import */ var _src_ui_TabBar__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ../src/ui/TabBar */ \"./src/ui/TabBar.ts\");\n/* harmony import */ var _src_ui_Tooltip__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ../src/ui/Tooltip */ \"./src/ui/Tooltip.ts\");\n/* harmony import */ var _src_ui_Widget__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ../src/ui/Widget */ \"./src/ui/Widget.ts\");\n/* harmony import */ var _src_util_Geom__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ../src/util/Geom */ \"./src/util/Geom.ts\");\n/* harmony import */ var _src_util_Matrix__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ../src/util/Matrix */ \"./src/util/Matrix.ts\");\n/* harmony import */ var _src_util_Random__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ../src/util/Random */ \"./src/util/Random.ts\");\n/* harmony import */ var _src_util_Theme__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ../src/util/Theme */ \"./src/util/Theme.ts\");\n/* harmony import */ var _src_util_Triangulation2D__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ../src/util/Triangulation2D */ \"./src/util/Triangulation2D.ts\");\n/* harmony import */ var _src_util_Vec__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ../src/util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _src_util_XML__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ../src/util/XML */ \"./src/util/XML.ts\");\n/* harmony import */ var _src_util_dom__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! ../src/util/dom */ \"./src/util/dom.ts\");\n/* harmony import */ var _src_util_util__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! ../src/util/util */ \"./src/util/util.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://WebMolKit/./dist/index-src.ts?");

/***/ }),

/***/ "./dist/index-val.ts":
/*!***************************!*\
  !*** ./dist/index-val.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ASCENT_FUDGE\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.ASCENT_FUDGE),\n/* harmony export */   \"AbbrevContainer\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.AbbrevContainer),\n/* harmony export */   \"ActivityType\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.ActivityType),\n/* harmony export */   \"ArrangeComponent\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.ArrangeComponent),\n/* harmony export */   \"ArrangeComponentAnnot\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.ArrangeComponentAnnot),\n/* harmony export */   \"ArrangeComponentType\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.ArrangeComponentType),\n/* harmony export */   \"ArrangeExperiment\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.ArrangeExperiment),\n/* harmony export */   \"ArrangeMolecule\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.ArrangeMolecule),\n/* harmony export */   \"Aspect\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.Aspect),\n/* harmony export */   \"AspectList\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.AspectList),\n/* harmony export */   \"AssayProvenance\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.AssayProvenance),\n/* harmony export */   \"AssayProvenanceHeader\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.AssayProvenanceHeader),\n/* harmony export */   \"AxisLabeller\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.AxisLabeller),\n/* harmony export */   \"BLineType\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.BLineType),\n/* harmony export */   \"BONDARTIFACT_EXTRA_ARENE\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.BONDARTIFACT_EXTRA_ARENE),\n/* harmony export */   \"BONDARTIFACT_EXTRA_RESPATH\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.BONDARTIFACT_EXTRA_RESPATH),\n/* harmony export */   \"BONDARTIFACT_EXTRA_RESRING\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.BONDARTIFACT_EXTRA_RESRING),\n/* harmony export */   \"BayesianModel\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.BayesianModel),\n/* harmony export */   \"BayesianPrediction\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.BayesianPrediction),\n/* harmony export */   \"BayesianPredictionModel\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.BayesianPredictionModel),\n/* harmony export */   \"BayesianPredictionOutcome\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.BayesianPredictionOutcome),\n/* harmony export */   \"BayesianSource\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.BayesianSource),\n/* harmony export */   \"BayesianSourceModel\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.BayesianSourceModel),\n/* harmony export */   \"BinaryData\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.BinaryData),\n/* harmony export */   \"BinaryDataField\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.BinaryDataField),\n/* harmony export */   \"BondArtifact\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.BondArtifact),\n/* harmony export */   \"Box\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.Box),\n/* harmony export */   \"BuildSMILES\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.BuildSMILES),\n/* harmony export */   \"ButtonBank\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.ButtonBank),\n/* harmony export */   \"ButtonView\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.ButtonView),\n/* harmony export */   \"ButtonViewPosition\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.ButtonViewPosition),\n/* harmony export */   \"Chemistry\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.Chemistry),\n/* harmony export */   \"CircularFingerprints\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.CircularFingerprints),\n/* harmony export */   \"ClipboardProxy\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.ClipboardProxy),\n/* harmony export */   \"ClipboardProxyHandler\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.ClipboardProxyHandler),\n/* harmony export */   \"ClipboardProxyWeb\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.ClipboardProxyWeb),\n/* harmony export */   \"CommandBank\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.CommandBank),\n/* harmony export */   \"ContextSketch\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.ContextSketch),\n/* harmony export */   \"CoordUtil\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.CoordUtil),\n/* harmony export */   \"DEGRAD\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.DEGRAD),\n/* harmony export */   \"DOM\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.DOM),\n/* harmony export */   \"DataSheet\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.DataSheet),\n/* harmony export */   \"DataSheetColumn\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.DataSheetColumn),\n/* harmony export */   \"DataSheetStream\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.DataSheetStream),\n/* harmony export */   \"Dialog\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.Dialog),\n/* harmony export */   \"DotPath\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.DotPath),\n/* harmony export */   \"DotPathBond\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.DotPathBond),\n/* harmony export */   \"DotPathCharge\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.DotPathCharge),\n/* harmony export */   \"DraggingTool\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.DraggingTool),\n/* harmony export */   \"DrawCanvas\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.DrawCanvas),\n/* harmony export */   \"DrawCanvasDecoration\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.DrawCanvasDecoration),\n/* harmony export */   \"DrawExperiment\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.DrawExperiment),\n/* harmony export */   \"DrawMolecule\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.DrawMolecule),\n/* harmony export */   \"EditAtom\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.EditAtom),\n/* harmony export */   \"EditBond\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.EditBond),\n/* harmony export */   \"EditCompound\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.EditCompound),\n/* harmony export */   \"EditPolymer\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.EditPolymer),\n/* harmony export */   \"EmbedChemistry\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.EmbedChemistry),\n/* harmony export */   \"EmbedCollection\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.EmbedCollection),\n/* harmony export */   \"EmbedMolecule\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.EmbedMolecule),\n/* harmony export */   \"EmbedReaction\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.EmbedReaction),\n/* harmony export */   \"EmbedReactionFacet\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.EmbedReactionFacet),\n/* harmony export */   \"Experiment\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.Experiment),\n/* harmony export */   \"ExperimentComponent\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.ExperimentComponent),\n/* harmony export */   \"ExperimentComponentType\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.ExperimentComponentType),\n/* harmony export */   \"ExperimentEntry\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.ExperimentEntry),\n/* harmony export */   \"ExperimentMeta\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.ExperimentMeta),\n/* harmony export */   \"ExperimentMetaApplic\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.ExperimentMetaApplic),\n/* harmony export */   \"ExperimentMetaRoleType\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.ExperimentMetaRoleType),\n/* harmony export */   \"ExperimentMetaType\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.ExperimentMetaType),\n/* harmony export */   \"ExperimentMetaValue\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.ExperimentMetaValue),\n/* harmony export */   \"ExperimentStep\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.ExperimentStep),\n/* harmony export */   \"ExtraFieldsWidget\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.ExtraFieldsWidget),\n/* harmony export */   \"FontData\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.FontData),\n/* harmony export */   \"ForeignMolecule\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.ForeignMolecule),\n/* harmony export */   \"ForeignMoleculeExtra\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.ForeignMoleculeExtra),\n/* harmony export */   \"FormatList\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.FormatList),\n/* harmony export */   \"FusionBank\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.FusionBank),\n/* harmony export */   \"FusionPermutation\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.FusionPermutation),\n/* harmony export */   \"GeomUtil\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.GeomUtil),\n/* harmony export */   \"GeomWidget\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.GeomWidget),\n/* harmony export */   \"GeomWidgetSelType\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.GeomWidgetSelType),\n/* harmony export */   \"GeomWidgetType\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.GeomWidgetType),\n/* harmony export */   \"Geometry\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.Geometry),\n/* harmony export */   \"Graph\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.Graph),\n/* harmony export */   \"GreenMetrics\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.GreenMetrics),\n/* harmony export */   \"INV_TWOPI\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.INV_TWOPI),\n/* harmony export */   \"KeyCode\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.KeyCode),\n/* harmony export */   \"Line\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.Line),\n/* harmony export */   \"MDLMOLReader\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.MDLMOLReader),\n/* harmony export */   \"MDLMOLWriter\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.MDLMOLWriter),\n/* harmony export */   \"MDLMOL_VALENCE\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.MDLMOL_VALENCE),\n/* harmony export */   \"MDLSDFReader\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.MDLSDFReader),\n/* harmony export */   \"MDLSDFWriter\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.MDLSDFWriter),\n/* harmony export */   \"Matrix\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.Matrix),\n/* harmony export */   \"MeasurementData\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.MeasurementData),\n/* harmony export */   \"MenuProxy\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.MenuProxy),\n/* harmony export */   \"MenuProxyWeb\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.MenuProxyWeb),\n/* harmony export */   \"MetaMolecule\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.MetaMolecule),\n/* harmony export */   \"MetaVector\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.MetaVector),\n/* harmony export */   \"MetalLigate\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.MetalLigate),\n/* harmony export */   \"Mixture\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.Mixture),\n/* harmony export */   \"MixtureAttributeType\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.MixtureAttributeType),\n/* harmony export */   \"MolUtil\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.MolUtil),\n/* harmony export */   \"Molecule\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.Molecule),\n/* harmony export */   \"MoleculeActivity\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.MoleculeActivity),\n/* harmony export */   \"MoleculeStream\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream),\n/* harmony export */   \"OntologyTree\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.OntologyTree),\n/* harmony export */   \"OpenMolSpec\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.OpenMolSpec),\n/* harmony export */   \"OpenMolType\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.OpenMolType),\n/* harmony export */   \"OptionList\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.OptionList),\n/* harmony export */   \"OutlineMeasurement\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.OutlineMeasurement),\n/* harmony export */   \"Oval\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.Oval),\n/* harmony export */   \"POLYMERBLOCK_EXTRA_POLYMER\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.POLYMERBLOCK_EXTRA_POLYMER),\n/* harmony export */   \"POLYMERBLOCK_SPECIAL_UNCAPPED\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.POLYMERBLOCK_SPECIAL_UNCAPPED),\n/* harmony export */   \"PeriodicTableWidget\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.PeriodicTableWidget),\n/* harmony export */   \"Permutation\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.Permutation),\n/* harmony export */   \"PolymerBlock\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.PolymerBlock),\n/* harmony export */   \"PolymerBlockConnectivity\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.PolymerBlockConnectivity),\n/* harmony export */   \"PolymerBlockUnit\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.PolymerBlockUnit),\n/* harmony export */   \"Popup\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.Popup),\n/* harmony export */   \"Pos\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.Pos),\n/* harmony export */   \"QuantityCalc\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.QuantityCalc),\n/* harmony export */   \"QuantityCalcComp\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.QuantityCalcComp),\n/* harmony export */   \"QuantityCalcRole\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.QuantityCalcRole),\n/* harmony export */   \"QuantityCalcStat\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.QuantityCalcStat),\n/* harmony export */   \"QueryFieldsWidget\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.QueryFieldsWidget),\n/* harmony export */   \"QueryTypeAtom\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.QueryTypeAtom),\n/* harmony export */   \"QueryTypeBond\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.QueryTypeBond),\n/* harmony export */   \"QueryUtil\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.QueryUtil),\n/* harmony export */   \"QuickHull\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.QuickHull),\n/* harmony export */   \"RADDEG\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.RADDEG),\n/* harmony export */   \"Random\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.Random),\n/* harmony export */   \"RenderEffects\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.RenderEffects),\n/* harmony export */   \"RenderPolicy\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.RenderPolicy),\n/* harmony export */   \"ResonanceRemover\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.ResonanceRemover),\n/* harmony export */   \"RollingBall\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.RollingBall),\n/* harmony export */   \"SARTable\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.SARTable),\n/* harmony export */   \"SingularValueDecomposition\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.SingularValueDecomposition),\n/* harmony export */   \"Size\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.Size),\n/* harmony export */   \"SketchUtil\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.SketchUtil),\n/* harmony export */   \"Sketcher\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.Sketcher),\n/* harmony export */   \"Stereochemistry\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.Stereochemistry),\n/* harmony export */   \"TEMPLATE_FILES\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_FILES),\n/* harmony export */   \"TWOPI\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.TWOPI),\n/* harmony export */   \"TabBar\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.TabBar),\n/* harmony export */   \"TemplateBank\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.TemplateBank),\n/* harmony export */   \"TemplateFusion\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.TemplateFusion),\n/* harmony export */   \"TextAlign\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.TextAlign),\n/* harmony export */   \"Theme\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.Theme),\n/* harmony export */   \"ToolBank\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.ToolBank),\n/* harmony export */   \"ToolBankItem\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.ToolBankItem),\n/* harmony export */   \"Tooltip\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.Tooltip),\n/* harmony export */   \"Triangulation2D\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.Triangulation2D),\n/* harmony export */   \"Validation\": () => (/* reexport safe */ _val_src_Validation__WEBPACK_IMPORTED_MODULE_1__.Validation),\n/* harmony export */   \"ValidationHeadlessBasic\": () => (/* reexport safe */ _val_src_ValidationHeadlessBasic__WEBPACK_IMPORTED_MODULE_2__.ValidationHeadlessBasic),\n/* harmony export */   \"ValidationHeadlessMolecule\": () => (/* reexport safe */ _val_src_ValidationHeadlessMolecule__WEBPACK_IMPORTED_MODULE_3__.ValidationHeadlessMolecule),\n/* harmony export */   \"ValidationHeadlessReaction\": () => (/* reexport safe */ _val_src_ValidationHeadlessReaction__WEBPACK_IMPORTED_MODULE_4__.ValidationHeadlessReaction),\n/* harmony export */   \"Vec\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.Vec),\n/* harmony export */   \"WebValExec\": () => (/* reexport safe */ _val_src_WebValExec__WEBPACK_IMPORTED_MODULE_5__.WebValExec),\n/* harmony export */   \"Widget\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.Widget),\n/* harmony export */   \"XML\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.XML),\n/* harmony export */   \"addText\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.addText),\n/* harmony export */   \"addTooltip\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.addTooltip),\n/* harmony export */   \"angleDiff\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.angleDiff),\n/* harmony export */   \"angleDiffPos\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.angleDiffPos),\n/* harmony export */   \"angleNorm\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.angleNorm),\n/* harmony export */   \"blendRGB\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.blendRGB),\n/* harmony export */   \"clearTooltip\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.clearTooltip),\n/* harmony export */   \"clone\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.clone),\n/* harmony export */   \"colourAlpha\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.colourAlpha),\n/* harmony export */   \"colourCanvas\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.colourCanvas),\n/* harmony export */   \"colourCode\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.colourCode),\n/* harmony export */   \"deepClone\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.deepClone),\n/* harmony export */   \"dictValues\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.dictValues),\n/* harmony export */   \"dom\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.dom),\n/* harmony export */   \"domLegacy\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.domLegacy),\n/* harmony export */   \"drawLine\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.drawLine),\n/* harmony export */   \"empiricalScrollerSize\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.empiricalScrollerSize),\n/* harmony export */   \"escapeHTML\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.escapeHTML),\n/* harmony export */   \"eventCoords\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.eventCoords),\n/* harmony export */   \"findNode\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.findNode),\n/* harmony export */   \"findNodes\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.findNodes),\n/* harmony export */   \"fltEqual\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.fltEqual),\n/* harmony export */   \"fontSansSerif\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.fontSansSerif),\n/* harmony export */   \"formatDate\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.formatDate),\n/* harmony export */   \"formatDouble\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.formatDouble),\n/* harmony export */   \"fromUTF8\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.fromUTF8),\n/* harmony export */   \"getBoundaryPixelsDOM\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.getBoundaryPixelsDOM),\n/* harmony export */   \"getOffsetPixelsDOM\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.getOffsetPixelsDOM),\n/* harmony export */   \"hasInlineCSS\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.hasInlineCSS),\n/* harmony export */   \"htmlToRGB\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.htmlToRGB),\n/* harmony export */   \"initWebMolKit\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.initWebMolKit),\n/* harmony export */   \"installInlineCSS\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.installInlineCSS),\n/* harmony export */   \"invZ\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.invZ),\n/* harmony export */   \"isDef\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.isDef),\n/* harmony export */   \"jsonPrettyPrint\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.jsonPrettyPrint),\n/* harmony export */   \"maxArray\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.maxArray),\n/* harmony export */   \"minArray\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.minArray),\n/* harmony export */   \"newElement\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.newElement),\n/* harmony export */   \"nodeText\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.nodeText),\n/* harmony export */   \"norm2_xy\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.norm2_xy),\n/* harmony export */   \"norm2_xyz\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.norm2_xyz),\n/* harmony export */   \"norm_xy\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.norm_xy),\n/* harmony export */   \"norm_xyz\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.norm_xyz),\n/* harmony export */   \"notDef\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.notDef),\n/* harmony export */   \"orBlank\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.orBlank),\n/* harmony export */   \"pathRoundedRect\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.pathRoundedRect),\n/* harmony export */   \"pixelDensity\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.pixelDensity),\n/* harmony export */   \"plural\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.plural),\n/* harmony export */   \"postJSONURL\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.postJSONURL),\n/* harmony export */   \"raiseToolTip\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.raiseToolTip),\n/* harmony export */   \"randomInt\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.randomInt),\n/* harmony export */   \"readTextURL\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.readTextURL),\n/* harmony export */   \"realEqual\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.realEqual),\n/* harmony export */   \"registerAspect\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.registerAspect),\n/* harmony export */   \"safeFloat\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.safeFloat),\n/* harmony export */   \"safeInt\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.safeInt),\n/* harmony export */   \"setBoundaryPixels\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.setBoundaryPixels),\n/* harmony export */   \"signum\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.signum),\n/* harmony export */   \"sortAngles\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.sortAngles),\n/* harmony export */   \"sqr\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.sqr),\n/* harmony export */   \"toUTF8\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.toUTF8),\n/* harmony export */   \"uniqueAngles\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.uniqueAngles),\n/* harmony export */   \"yieldDOM\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.yieldDOM),\n/* harmony export */   \"zip\": () => (/* reexport safe */ _index_src__WEBPACK_IMPORTED_MODULE_0__.zip)\n/* harmony export */ });\n/* harmony import */ var _index_src__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-src */ \"./dist/index-src.ts\");\n/* harmony import */ var _val_src_Validation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../val/src/Validation */ \"./val/src/Validation.ts\");\n/* harmony import */ var _val_src_ValidationHeadlessBasic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../val/src/ValidationHeadlessBasic */ \"./val/src/ValidationHeadlessBasic.ts\");\n/* harmony import */ var _val_src_ValidationHeadlessMolecule__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../val/src/ValidationHeadlessMolecule */ \"./val/src/ValidationHeadlessMolecule.ts\");\n/* harmony import */ var _val_src_ValidationHeadlessReaction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../val/src/ValidationHeadlessReaction */ \"./val/src/ValidationHeadlessReaction.ts\");\n/* harmony import */ var _val_src_WebValExec__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../val/src/WebValExec */ \"./val/src/WebValExec.ts\");\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://WebMolKit/./dist/index-val.ts?");

/***/ }),

/***/ "./src/aspect/Aspect.ts":
/*!******************************!*\
  !*** ./src/aspect/Aspect.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Aspect\": () => (/* binding */ Aspect)\n/* harmony export */ });\n/* harmony import */ var _data_DataSheet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/DataSheet */ \"./src/data/DataSheet.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n\n\nclass Aspect {\n    constructor(code, ds, allowModify) {\n        this.code = code;\n        this.allowModify = true;\n        this.ds = ds ? ds : new _data_DataSheet__WEBPACK_IMPORTED_MODULE_0__.DataSheet();\n        if (allowModify != null)\n            this.allowModify = allowModify;\n    }\n    isColumnReserved(colName) { return false; }\n    areColumnsReserved(colNames) {\n        let resMask = _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.booleanArray(false, colNames.length);\n        for (let n = 0; n < colNames.length; n++)\n            resMask[n] = this.isColumnReserved(colNames[n]);\n        return resMask;\n    }\n    rowFirstBlock(row) { return true; }\n    rowBlockCount(row) { return 1; }\n    aspectUnion(other) { }\n    initiateNewRow(row) { }\n    columnEffectivelyBlank(row) { return []; }\n    numTextRenderings(row) { return 0; }\n    produceTextRendering(row, idx) { return null; }\n    numGraphicRenderings(row) { return 0; }\n    produceGraphicRendering(row, idx, policy) { return null; }\n    numHeaderRenderings() { return 0; }\n    produceHeaderRendering(idx) { return null; }\n}\nAspect.TEXT_PLAIN = 0;\nAspect.TEXT_LINK = 1;\nAspect.TEXT_HTML = 2;\n\n\n//# sourceURL=webpack://WebMolKit/./src/aspect/Aspect.ts?");

/***/ }),

/***/ "./src/aspect/AspectList.ts":
/*!**********************************!*\
  !*** ./src/aspect/AspectList.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AspectList\": () => (/* binding */ AspectList),\n/* harmony export */   \"registerAspect\": () => (/* binding */ registerAspect)\n/* harmony export */ });\nlet supportedAspects = {};\nfunction registerAspect(classdef) {\n    let code = classdef.CODE, name = classdef.NAME;\n    supportedAspects[code] = { code, name, classdef };\n}\nclass AspectList {\n    constructor(ds) {\n        this.ds = ds;\n    }\n    list() {\n        let present = [], absent = [];\n        let codes = new Set();\n        for (let n = 0; n < this.ds.numExtensions; n++)\n            codes.add(this.ds.getExtType(n));\n        for (let code in supportedAspects)\n            if (codes.has(code))\n                present.push(code);\n            else\n                absent.push(code);\n        return [present, absent];\n    }\n    instantiate(code) {\n        let supp = supportedAspects[code];\n        if (supp)\n            return new supp.classdef(this.ds);\n        return null;\n    }\n    enumerate() {\n        let aspects = [];\n        for (let n = 0; n < this.ds.numExtensions; n++) {\n            let code = this.ds.getExtType(n);\n            if (supportedAspects[code])\n                aspects.push(this.instantiate(code));\n        }\n        return aspects;\n    }\n    aspectName(code) {\n        let supp = supportedAspects[code];\n        return supp ? supp.name : null;\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/aspect/AspectList.ts?");

/***/ }),

/***/ "./src/aspect/AssayProvenance.ts":
/*!***************************************!*\
  !*** ./src/aspect/AssayProvenance.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AssayProvenance\": () => (/* binding */ AssayProvenance),\n/* harmony export */   \"AssayProvenanceHeader\": () => (/* binding */ AssayProvenanceHeader)\n/* harmony export */ });\n/* harmony import */ var _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/MoleculeStream */ \"./src/data/MoleculeStream.ts\");\n/* harmony import */ var _Aspect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Aspect */ \"./src/aspect/Aspect.ts\");\n/* harmony import */ var _AspectList__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AspectList */ \"./src/aspect/AspectList.ts\");\n\n\n\nclass AssayProvenanceHeader {\n    constructor() {\n        this.prefixes = {};\n        this.targetName = '';\n        this.targetURI = '';\n        this.organismName = '';\n        this.organismURI = '';\n        this.targetTypeName = '';\n        this.targetTypeURI = '';\n        this.cellName = '';\n        this.cellURI = '';\n        this.assayTypeName = '';\n        this.assayTypeURI = '';\n        this.assayDescription = '';\n        this.sourceName = '';\n        this.sourceURI = '';\n        this.sourceVersion = '';\n        this.documentName = '';\n        this.documentURI = '';\n        this.measureTypeName = '';\n        this.measureTypeURI = '';\n        this.unitNames = [];\n        this.unitURIs = [];\n    }\n}\nclass AssayProvenance extends _Aspect__WEBPACK_IMPORTED_MODULE_1__.Aspect {\n    constructor(ds, allowModify) {\n        super(AssayProvenance.CODE, ds, allowModify);\n        this.setup();\n    }\n    static isAssayProvenance(ds) {\n        for (let n = 0; n < ds.numExtensions; n++)\n            if (ds.getExtType(n) == AssayProvenance.CODE)\n                return true;\n        return false;\n    }\n    getHeader() {\n        for (let n = 0; n < this.ds.numExtensions; n++)\n            if (this.ds.getExtType(n) == AssayProvenance.CODE)\n                return this.parseMetaData(this.ds.getExtData(n));\n        return null;\n    }\n    setHeader(header) {\n        let content = this.formatMetaData(header);\n        for (let n = 0; n < this.ds.numExtensions; n++)\n            if (this.ds.getExtType(n) == AssayProvenance.CODE) {\n                this.ds.setExtData(n, content);\n                return;\n            }\n        this.ds.appendExtension(AssayProvenance.NAME, AssayProvenance.CODE, content);\n    }\n    getMolecule(row) {\n        let col = this.ds.findColByName(AssayProvenance.COLNAME_MOLECULE);\n        return col < 0 ? null : this.ds.getMolecule(row, col);\n    }\n    getName(row) {\n        let col = this.ds.findColByName(AssayProvenance.COLNAME_NAME);\n        return col < 0 ? null : this.ds.getString(row, col);\n    }\n    getValue(row) {\n        let col = this.ds.findColByName(AssayProvenance.COLNAME_VALUE);\n        return col < 0 ? null : this.ds.isNull(row, col) ? Number.NaN : this.ds.getReal(row, col);\n    }\n    getError(row) {\n        let col = this.ds.findColByName(AssayProvenance.COLNAME_ERROR);\n        if (col < 0)\n            return null;\n        if (this.ds.isNull(row, col))\n            return Number.NaN;\n        let err = this.ds.getReal(row, col);\n        if (err <= 0)\n            return Number.NaN;\n        return err;\n    }\n    getUnits(row) {\n        let col = this.ds.findColByName(AssayProvenance.COLNAME_UNITS);\n        return col < 0 ? null : this.ds.getString(row, col);\n    }\n    getRelation(row) {\n        let col = this.ds.findColByName(AssayProvenance.COLNAME_RELATION);\n        return col < 0 ? null : this.ds.getString(row, col);\n    }\n    getSourceURI(row) {\n        let col = this.ds.findColByName(AssayProvenance.COLNAME_SOURCEURI);\n        return col < 0 ? null : this.ds.getString(row, col);\n    }\n    setMolecule(row, v) {\n        let col = this.ds.findColByName(AssayProvenance.COLNAME_MOLECULE);\n        if (col >= 0)\n            this.ds.setMolecule(row, col, v);\n    }\n    setName(row, v) {\n        let col = this.ds.findColByName(AssayProvenance.COLNAME_NAME);\n        if (col >= 0)\n            this.ds.setString(row, col, v);\n    }\n    setValue(row, v) {\n        let col = this.ds.findColByName(AssayProvenance.COLNAME_VALUE);\n        if (col < 0) { }\n        else if (Number.isNaN(v))\n            this.ds.setToNull(row, col);\n        else\n            this.ds.setReal(row, col, v);\n    }\n    setError(row, v) {\n        let col = this.ds.findColByName(AssayProvenance.COLNAME_ERROR);\n        if (col < 0) { }\n        else if (Number.isNaN(v))\n            this.ds.setToNull(row, col);\n        else\n            this.ds.setReal(row, col, v);\n    }\n    setUnits(row, v) {\n        let col = this.ds.findColByName(AssayProvenance.COLNAME_UNITS);\n        if (col >= 0)\n            this.ds.setString(row, col, v);\n    }\n    setRelation(row, v) {\n        let col = this.ds.findColByName(AssayProvenance.COLNAME_RELATION);\n        if (col >= 0)\n            this.ds.setString(row, col, v);\n    }\n    setSourceURI(row, v) {\n        let col = this.ds.findColByName(AssayProvenance.COLNAME_SOURCEURI);\n        if (col >= 0)\n            this.ds.setString(row, col, v);\n    }\n    setup() {\n        this.parseAndCorrect();\n    }\n    parseAndCorrect() {\n        let header = new AssayProvenanceHeader();\n        let got = false;\n        for (let n = 0; n < this.ds.numExtensions; n++)\n            if (this.ds.getExtType(n) == AssayProvenance.CODE) {\n                header = this.parseMetaData(this.ds.getExtData(n));\n                got = true;\n                break;\n            }\n        if (this.allowModify) {\n            this.ds.ensureColumn(AssayProvenance.COLNAME_MOLECULE, \"molecule\", 'Molecular structure of compound being measured');\n            this.ds.ensureColumn(AssayProvenance.COLNAME_NAME, \"string\", 'Name of compound');\n            this.ds.ensureColumn(AssayProvenance.COLNAME_VALUE, \"real\", 'Measured value');\n            this.ds.ensureColumn(AssayProvenance.COLNAME_ERROR, \"real\", 'Experimental error of measurement');\n            this.ds.ensureColumn(AssayProvenance.COLNAME_UNITS, \"string\", 'Units of measurement');\n            this.ds.ensureColumn(AssayProvenance.COLNAME_RELATION, \"string\", 'Relation: exact, greater or less');\n            this.ds.ensureColumn(AssayProvenance.COLNAME_SOURCEURI, \"string\", 'Source identifier for activity measurement');\n        }\n        if (!got && this.allowModify) {\n            let content = this.formatMetaData(header);\n            this.ds.appendExtension(AssayProvenance.NAME, AssayProvenance.CODE, content);\n        }\n    }\n    parseMetaData(content) {\n        let header = new AssayProvenanceHeader();\n        for (let line of content.split(/\\r?\\n/)) {\n            let eq = line.indexOf('=');\n            if (eq < 0)\n                continue;\n            if (line.startsWith('pfx:'))\n                header.prefixes[_data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(4, eq))] = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('targetName='))\n                header.targetName = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('targetURI='))\n                header.targetURI = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('organismName='))\n                header.organismName = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('organismURI='))\n                header.organismURI = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('targetTypeName='))\n                header.targetTypeName = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('targetTypeURI='))\n                header.targetTypeURI = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('cellName='))\n                header.cellName = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('cellURI='))\n                header.cellURI = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('assayTypeName='))\n                header.assayTypeName = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('assayTypeURI='))\n                header.assayTypeURI = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('assayDescription='))\n                header.assayDescription = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('sourceName='))\n                header.sourceName = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('sourceURI='))\n                header.sourceURI = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('sourceVersion='))\n                header.sourceVersion = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('documentName='))\n                header.documentName = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('documentURI='))\n                header.documentURI = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('measureTypeName='))\n                header.measureTypeName = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('measureTypeURI='))\n                header.measureTypeURI = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('unit:')) {\n                header.unitNames.push(_data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(5, eq)));\n                header.unitURIs.push(_data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1)));\n            }\n        }\n        return header;\n    }\n    formatMetaData(header) {\n        let content = '';\n        for (let pfx in header.prefixes)\n            content += 'pfx:' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(pfx) + '=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(header.prefixes[pfx]) + '\\n';\n        content += 'targetName=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(header.targetName) + '\\n';\n        content += 'targetURI=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(header.targetURI) + '\\n';\n        content += 'organismName=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(header.organismName) + '\\n';\n        content += 'organismURI=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(header.organismURI) + '\\n';\n        content += 'targetTypeName=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(header.targetTypeName) + '\\n';\n        content += 'targetTypeURI=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(header.targetTypeURI) + '\\n';\n        content += 'cellName=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(header.cellName) + '\\n';\n        content += 'cellURI=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(header.cellURI) + '\\n';\n        content += 'assayTypeName=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(header.assayTypeName) + '\\n';\n        content += 'assayTypeURI=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(header.assayTypeURI) + '\\n';\n        content += 'assayDescription=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(header.assayDescription) + '\\n';\n        content += 'sourceName=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(header.sourceName) + '\\n';\n        content += 'sourceURI=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(header.sourceURI) + '\\n';\n        content += 'sourceVersion=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(header.sourceVersion) + '\\n';\n        content += 'documentName=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(header.documentName) + '\\n';\n        content += 'documentURI=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(header.documentURI) + '\\n';\n        content += 'measureTypeName=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(header.measureTypeName) + '\\n';\n        content += 'measureTypeURI=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(header.measureTypeURI) + '\\n';\n        for (let n = 0, num = Math.min(header.unitNames.length, header.unitURIs.length); n < num; n++)\n            content += 'unit:' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(header.unitNames[n]) + '=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(header.unitURIs[n]) + '\\n';\n        return content;\n    }\n    plainHeading() { return AssayProvenance.NAME; }\n    isColumnReserved(colName) {\n        return colName == AssayProvenance.COLNAME_VALUE || colName == AssayProvenance.COLNAME_ERROR ||\n            colName == AssayProvenance.COLNAME_UNITS || colName == AssayProvenance.COLNAME_RELATION ||\n            colName == AssayProvenance.COLNAME_SOURCEURI;\n    }\n    numTextRenderings(row) { return 2; }\n    produceTextRendering(row, idx) {\n        let header = this.getHeader();\n        if (idx == 0) {\n            let tr = {\n                'name': 'Activity',\n                'descr': 'Activity measurement details for this record',\n                'text': '',\n                'type': _Aspect__WEBPACK_IMPORTED_MODULE_1__.Aspect.TEXT_PLAIN\n            };\n            let val = this.getValue(row), error = this.getError(row);\n            let units = this.getUnits(row), rel = this.getRelation(row);\n            tr.text = '';\n            if (!Number.isNaN(val)) {\n                if (rel)\n                    tr.text += rel + ' ';\n                tr.text += val;\n                if (!Number.isNaN(error))\n                    tr.text += ' \\u{00B1} ' + error;\n                if (units)\n                    tr.text += ' ' + units;\n            }\n            return tr;\n        }\n        else if (idx == 1) {\n            let tr = {\n                'name': 'Source',\n                'descr': 'Origin of the structure and activity measurement',\n                'text': '',\n                'type': _Aspect__WEBPACK_IMPORTED_MODULE_1__.Aspect.TEXT_LINK\n            };\n            let url = this.getSourceURI(row);\n            for (let pfx in header.prefixes)\n                if (url.startsWith(pfx + ':')) {\n                    url = header.prefixes[pfx] + url.substring(pfx.length + 1);\n                    break;\n                }\n            tr.text = url;\n            return tr;\n        }\n        return null;\n    }\n}\nAssayProvenance.CODE = 'org.mmi.aspect.AssayProvenance';\nAssayProvenance.NAME = 'Assay Provenance';\nAssayProvenance.COLNAME_MOLECULE = 'Molecule';\nAssayProvenance.COLNAME_NAME = 'Name';\nAssayProvenance.COLNAME_VALUE = 'Value';\nAssayProvenance.COLNAME_ERROR = 'Error';\nAssayProvenance.COLNAME_UNITS = 'Units';\nAssayProvenance.COLNAME_RELATION = 'Relation';\nAssayProvenance.COLNAME_SOURCEURI = 'SourceURI';\nAssayProvenance.URI_UNIT_M = 'http://purl.obolibrary.org/obo/UO_0000062';\nAssayProvenance.URI_UNIT_mM = 'http://purl.obolibrary.org/obo/UO_0000063';\nAssayProvenance.URI_UNIT_uM = 'http://purl.obolibrary.org/obo/UO_0000064';\nAssayProvenance.URI_UNIT_nM = 'http://purl.obolibrary.org/obo/UO_0000065';\nAssayProvenance.URI_UNIT_pM = 'http://purl.obolibrary.org/obo/UO_0000066';\nAssayProvenance.URI_UNIT_logM = 'http://www.bioassayontology.org/bao#BAO_0000101';\nAssayProvenance.URI_UNIT_perM = 'http://www.bioassayontology.org/bao#BAO_0000102';\nAssayProvenance.URI_UNIT_gL = 'http://purl.obolibrary.org/obo/UO_0000175';\nAssayProvenance.URI_UNIT_mgL = 'http://purl.obolibrary.org/obo/UO_0000273';\nAssayProvenance.URI_UNIT_ugL = 'http://purl.obolibrary.org/obo/UO_0000275';\nAssayProvenance.URI_UNIT_binary = 'http://www.bioassayontology.org/bao#BAO_0080023';\n(0,_AspectList__WEBPACK_IMPORTED_MODULE_2__.registerAspect)(AssayProvenance);\n\n\n//# sourceURL=webpack://WebMolKit/./src/aspect/AssayProvenance.ts?");

/***/ }),

/***/ "./src/aspect/BayesianPrediction.ts":
/*!******************************************!*\
  !*** ./src/aspect/BayesianPrediction.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BayesianPrediction\": () => (/* binding */ BayesianPrediction),\n/* harmony export */   \"BayesianPredictionModel\": () => (/* binding */ BayesianPredictionModel),\n/* harmony export */   \"BayesianPredictionOutcome\": () => (/* binding */ BayesianPredictionOutcome)\n/* harmony export */ });\n/* harmony import */ var _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/MoleculeStream */ \"./src/data/MoleculeStream.ts\");\n/* harmony import */ var _Aspect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Aspect */ \"./src/aspect/Aspect.ts\");\n/* harmony import */ var _AspectList__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AspectList */ \"./src/aspect/AspectList.ts\");\n/* harmony import */ var _BayesianSource__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BayesianSource */ \"./src/aspect/BayesianSource.ts\");\n\n\n\n\nclass BayesianPredictionModel {\n}\nclass BayesianPredictionOutcome {\n}\nclass BayesianPrediction extends _Aspect__WEBPACK_IMPORTED_MODULE_1__.Aspect {\n    constructor(ds, allowModify) {\n        super(BayesianPrediction.CODE, ds, allowModify);\n        this.setup();\n    }\n    static isBayesianPrediction(ds) {\n        for (let n = 0; n < ds.numExtensions; n++)\n            if (ds.getExtType(n) == BayesianPrediction.CODE)\n                return true;\n        return false;\n    }\n    getModels() {\n        let content = '';\n        for (let n = 0; n < this.ds.numExtensions; n++)\n            if (this.ds.getExtType(n) == BayesianPrediction.CODE) {\n                content = this.ds.getExtData(n);\n                break;\n            }\n        let models = [];\n        let m = null;\n        for (let line of content.split('\\n')) {\n            if (line == 'model:') {\n                if (m != null)\n                    models.push(m);\n                m = {};\n                continue;\n            }\n            if (m == null)\n                continue;\n            let eq = line.indexOf('=');\n            if (eq < 0)\n                continue;\n            if (line.startsWith('colMolecule='))\n                m.colMolecule = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('colRaw='))\n                m.colRaw = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('colScaled='))\n                m.colScaled = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('colArcTan='))\n                m.colArcTan = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('colDomain='))\n                m.colDomain = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('colAtoms='))\n                m.colAtoms = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('name='))\n                m.name = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('description='))\n                m.description = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('targetName='))\n                m.targetName = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('isOffTarget='))\n                m.isOffTarget = line.substring(eq + 1) == 'true';\n        }\n        if (m != null)\n            models.push(m);\n        return models;\n    }\n    setModels(models) {\n        let lines = [];\n        for (let m of models) {\n            lines.push('model:');\n            lines.push('colMolecule=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(m.colMolecule));\n            lines.push('colRaw=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(m.colRaw));\n            lines.push('colScaled=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(m.colScaled));\n            lines.push('colArcTan=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(m.colArcTan));\n            lines.push('colDomain=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(m.colDomain));\n            lines.push('colAtoms=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(m.colAtoms));\n            lines.push('name=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(m.name));\n            lines.push('description=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(m.description));\n            lines.push('targetName=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(m.targetName));\n            lines.push('isOffTarget=' + m.isOffTarget);\n        }\n        let content = lines.join('\\n');\n        for (let n = 0; n < this.ds.numExtensions; n++)\n            if (this.ds.getExtType(n) == _BayesianSource__WEBPACK_IMPORTED_MODULE_3__.BayesianSource.CODE) {\n                this.ds.setExtData(n, content.toString());\n                return;\n            }\n        this.ds.appendExtension('BayesianPrediction', BayesianPrediction.CODE, content.toString());\n    }\n    getOutcome(row, model) {\n        let outcome = new BayesianPredictionOutcome();\n        outcome.raw = this.ds.getReal(row, model.colRaw);\n        outcome.scaled = this.ds.getReal(row, model.colScaled);\n        outcome.arctan = this.ds.getReal(row, model.colArcTan);\n        outcome.domain = this.ds.getReal(row, model.colDomain);\n        let strAtoms = this.ds.getString(row, model.colAtoms);\n        if (strAtoms) {\n            outcome.atoms = [];\n            for (let b of strAtoms.split(','))\n                outcome.atoms.push(parseFloat(b));\n        }\n        return outcome;\n    }\n    setOutcome(row, model, outcome) {\n        let col = this.ds.findColByName(model.colRaw, \"real\");\n        if (col >= 0)\n            this.ds.setReal(row, col, outcome.raw);\n        col = this.ds.findColByName(model.colScaled, \"real\");\n        if (col >= 0)\n            this.ds.setReal(row, col, outcome.scaled);\n        col = this.ds.findColByName(model.colArcTan, \"real\");\n        if (col >= 0)\n            this.ds.setReal(row, col, outcome.arctan);\n        col = this.ds.findColByName(model.colDomain, \"real\");\n        if (col >= 0)\n            this.ds.setReal(row, col, outcome.domain);\n        col = this.ds.findColByName(model.colAtoms, \"string\");\n        if (col >= 0)\n            this.ds.setString(row, col, outcome.atoms ? outcome.atoms.toString() : null);\n    }\n    setup() {\n        if (this.allowModify) {\n            let models = this.getModels();\n            this.setModels(models);\n        }\n    }\n    plainHeading() { return _BayesianSource__WEBPACK_IMPORTED_MODULE_3__.BayesianSource.NAME; }\n}\nBayesianPrediction.CODE = 'org.mmi.aspect.BayesianPrediction';\nBayesianPrediction.NAME = 'Bayesian Prediction';\n(0,_AspectList__WEBPACK_IMPORTED_MODULE_2__.registerAspect)(BayesianPrediction);\n\n\n//# sourceURL=webpack://WebMolKit/./src/aspect/BayesianPrediction.ts?");

/***/ }),

/***/ "./src/aspect/BayesianSource.ts":
/*!**************************************!*\
  !*** ./src/aspect/BayesianSource.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BayesianSource\": () => (/* binding */ BayesianSource),\n/* harmony export */   \"BayesianSourceModel\": () => (/* binding */ BayesianSourceModel)\n/* harmony export */ });\n/* harmony import */ var _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/MoleculeStream */ \"./src/data/MoleculeStream.ts\");\n/* harmony import */ var _Aspect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Aspect */ \"./src/aspect/Aspect.ts\");\n/* harmony import */ var _AspectList__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AspectList */ \"./src/aspect/AspectList.ts\");\n\n\n\nclass BayesianSourceModel {\n    constructor() {\n        this.colNameMolecule = '';\n        this.colNameValue = '';\n        this.thresholdValue = 0.5;\n        this.thresholdRelation = '>=';\n        this.folding = 0;\n        this.noteField = '';\n        this.noteTitle = '';\n        this.noteOrigin = '';\n        this.noteComment = '';\n    }\n}\nclass BayesianSource extends _Aspect__WEBPACK_IMPORTED_MODULE_1__.Aspect {\n    constructor(ds, allowModify) {\n        super(BayesianSource.CODE, ds, allowModify);\n        this.setup();\n    }\n    static isBayesianSource(ds) {\n        for (let n = 0; n < ds.numExtensions; n++)\n            if (ds.getExtType(n) == BayesianSource.CODE)\n                return true;\n        return false;\n    }\n    getModels() {\n        let content = '';\n        for (let n = 0; n < this.ds.numExtensions; n++)\n            if (this.ds.getExtType(n) == BayesianSource.CODE) {\n                content = this.ds.getExtData(n);\n                break;\n            }\n        let models = [];\n        let m = null;\n        for (let line of content.split('\\n')) {\n            if (line == 'model:') {\n                if (m != null)\n                    models.push(m);\n                m = {};\n                continue;\n            }\n            if (m == null)\n                continue;\n            let eq = line.indexOf('=');\n            if (eq < 0)\n                continue;\n            if (line.startsWith('colNameMolecule='))\n                m.colNameMolecule = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('colNameValue='))\n                m.colNameValue = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('thresholdValue='))\n                m.thresholdValue = parseFloat(line.substring(eq + 1));\n            else if (line.startsWith('thresholdRelation='))\n                m.thresholdRelation = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('folding='))\n                m.folding = parseInt(line.substring(eq + 1));\n            else if (line.startsWith('noteField='))\n                m.noteField = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('noteTitle='))\n                m.noteTitle = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('noteOrigin='))\n                m.noteOrigin = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('noteComment='))\n                m.noteComment = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n        }\n        if (m != null)\n            models.push(m);\n        return models;\n    }\n    setModels(models) {\n        let lines = [];\n        for (let m of models) {\n            lines.push('model:');\n            lines.push('colNameMolecule=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(m.colNameMolecule));\n            lines.push('colNameValue=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(m.colNameValue));\n            lines.push('thresholdValue=' + m.thresholdValue);\n            lines.push('thresholdRelation=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(m.thresholdRelation));\n            lines.push('folding=%d' + m.folding);\n            lines.push('noteField=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(m.noteField));\n            lines.push('noteTitle=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(m.noteTitle));\n            lines.push('noteOrigin=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(m.noteOrigin));\n            lines.push('noteComment=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(m.noteComment));\n        }\n        let content = lines.join('\\n');\n        for (let n = 0; n < this.ds.numExtensions; n++)\n            if (this.ds.getExtType(n) == BayesianSource.CODE) {\n                this.ds.setExtData(n, content.toString());\n                return;\n            }\n        this.ds.appendExtension('BayesianSource', BayesianSource.CODE, content.toString());\n    }\n    setup() {\n        if (this.allowModify) {\n            let models = this.getModels();\n            this.setModels(models);\n        }\n    }\n    plainHeading() { return BayesianSource.NAME; }\n}\nBayesianSource.CODE = 'org.mmi.aspect.BayesianSource';\nBayesianSource.NAME = 'Bayesian Source';\n(0,_AspectList__WEBPACK_IMPORTED_MODULE_2__.registerAspect)(BayesianSource);\n\n\n//# sourceURL=webpack://WebMolKit/./src/aspect/BayesianSource.ts?");

/***/ }),

/***/ "./src/aspect/BinaryData.ts":
/*!**********************************!*\
  !*** ./src/aspect/BinaryData.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BinaryData\": () => (/* binding */ BinaryData),\n/* harmony export */   \"BinaryDataField\": () => (/* binding */ BinaryDataField)\n/* harmony export */ });\n/* harmony import */ var _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/MoleculeStream */ \"./src/data/MoleculeStream.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _Aspect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Aspect */ \"./src/aspect/Aspect.ts\");\n/* harmony import */ var _AspectList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AspectList */ \"./src/aspect/AspectList.ts\");\n/* harmony import */ var _MeasurementData__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MeasurementData */ \"./src/aspect/MeasurementData.ts\");\n\n\n\n\n\nclass BinaryDataField {\n}\nclass BinaryData extends _Aspect__WEBPACK_IMPORTED_MODULE_2__.Aspect {\n    constructor(ds, allowModify) {\n        super(BinaryData.CODE, ds, allowModify);\n        this.fields = [];\n        this.setup();\n    }\n    static isBinaryData(ds) {\n        for (let n = 0; n < ds.numExtensions; n++)\n            if (ds.getExtType(n) == BinaryData.CODE)\n                return true;\n        return false;\n    }\n    getFields() {\n        return (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.deepClone)(this.fields);\n    }\n    setFields(fields) {\n        this.fields = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.deepClone)(fields);\n        let content = this.formatMetaData(fields);\n        for (let n = 0; n < this.ds.numExtensions; n++)\n            if (this.ds.getExtType(n) == _MeasurementData__WEBPACK_IMPORTED_MODULE_4__.MeasurementData.CODE) {\n                this.ds.setExtData(n, content);\n                return;\n            }\n        this.ds.appendExtension(_MeasurementData__WEBPACK_IMPORTED_MODULE_4__.MeasurementData.NAME, _MeasurementData__WEBPACK_IMPORTED_MODULE_4__.MeasurementData.CODE, content);\n    }\n    getValue(row, field) {\n        let value = this.getDestValue(row, field);\n        if (value != null)\n            return value;\n        return this.getSourceValue(row, field);\n    }\n    getSourceValue(row, field) {\n        let col = this.ds.findColByName(field.colNameSource);\n        if (col < 0 || this.ds.isNull(row, col))\n            return null;\n        let ct = this.ds.colType(col);\n        let value = 0;\n        if (ct == \"boolean\")\n            return this.ds.getBoolean(row, col);\n        else if (ct == \"integer\")\n            value = this.ds.getInteger(row, col);\n        else if (ct == \"real\")\n            value = this.ds.getReal(row, col);\n        else\n            return null;\n        if (field.thresholdRelation == '>')\n            return value > field.thresholdValue;\n        if (field.thresholdRelation == '<')\n            return value < field.thresholdValue;\n        if (field.thresholdRelation == '>=')\n            return value >= field.thresholdValue;\n        if (field.thresholdRelation == '<=')\n            return value <= field.thresholdValue;\n        return null;\n    }\n    getDestValue(row, field) {\n        return this.ds.getBoolean(row, field.colNameDest);\n    }\n    setup() {\n        this.parseAndCorrect();\n    }\n    parseAndCorrect() {\n        let got = false;\n        for (let n = 0; n < this.ds.numExtensions; n++)\n            if (this.ds.getExtType(n) == _MeasurementData__WEBPACK_IMPORTED_MODULE_4__.MeasurementData.CODE) {\n                this.fields = this.parseMetaData(this.ds.getExtData(n));\n                got = true;\n                break;\n            }\n        if (!got && this.allowModify) {\n            let content = this.formatMetaData(this.fields);\n            this.ds.appendExtension(_MeasurementData__WEBPACK_IMPORTED_MODULE_4__.MeasurementData.NAME, _MeasurementData__WEBPACK_IMPORTED_MODULE_4__.MeasurementData.CODE, content);\n        }\n    }\n    parseMetaData(content) {\n        let fields = [];\n        let f = null;\n        for (let line of content.split(/\\r?\\n/)) {\n            if (line == 'field:') {\n                if (f != null)\n                    fields.push(f);\n                f = { 'colNameSource': '', 'colNameDest': '', 'thresholdValue': 0.5, 'thresholdRelation': '>=' };\n                continue;\n            }\n            if (f == null)\n                continue;\n            let eq = line.indexOf('=');\n            if (eq < 0)\n                continue;\n            if (line.startsWith('colNameSource='))\n                f.colNameSource = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('colNameDest='))\n                f.colNameDest = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n            else if (line.startsWith('thresholdValue='))\n                f.thresholdValue = parseFloat(line.substring(eq + 1));\n            else if (line.startsWith('thresholdRelation='))\n                f.thresholdRelation = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n        }\n        if (f != null)\n            fields.push(f);\n        return fields;\n    }\n    formatMetaData(fields) {\n        let lines = [];\n        for (let f of fields) {\n            lines.push('field:');\n            lines.push('colNameSource=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(f.colNameSource));\n            lines.push('colNameDest=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(f.colNameDest));\n            lines.push('thresholdValue=' + f.thresholdValue);\n            lines.push('thresholdRelation=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(f.thresholdRelation));\n        }\n        return lines.join('\\n');\n    }\n    plainHeading() { return BinaryData.NAME; }\n    isColumnReserved(colName) { return false; }\n}\nBinaryData.CODE = 'org.mmi.aspect.BinaryData';\nBinaryData.NAME = 'Binary Data';\n(0,_AspectList__WEBPACK_IMPORTED_MODULE_3__.registerAspect)(BinaryData);\n\n\n//# sourceURL=webpack://WebMolKit/./src/aspect/BinaryData.ts?");

/***/ }),

/***/ "./src/aspect/Experiment.ts":
/*!**********************************!*\
  !*** ./src/aspect/Experiment.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Experiment\": () => (/* binding */ Experiment),\n/* harmony export */   \"ExperimentComponent\": () => (/* binding */ ExperimentComponent),\n/* harmony export */   \"ExperimentComponentType\": () => (/* binding */ ExperimentComponentType),\n/* harmony export */   \"ExperimentEntry\": () => (/* binding */ ExperimentEntry),\n/* harmony export */   \"ExperimentStep\": () => (/* binding */ ExperimentStep)\n/* harmony export */ });\n/* harmony import */ var _data_MolUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/MolUtil */ \"./src/data/MolUtil.ts\");\n/* harmony import */ var _gfx_ArrangeExperiment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../gfx/ArrangeExperiment */ \"./src/gfx/ArrangeExperiment.ts\");\n/* harmony import */ var _gfx_ArrangeMeasurement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../gfx/ArrangeMeasurement */ \"./src/gfx/ArrangeMeasurement.ts\");\n/* harmony import */ var _gfx_DrawExperiment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../gfx/DrawExperiment */ \"./src/gfx/DrawExperiment.ts\");\n/* harmony import */ var _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../gfx/MetaVector */ \"./src/gfx/MetaVector.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _Aspect__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Aspect */ \"./src/aspect/Aspect.ts\");\n/* harmony import */ var _AspectList__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./AspectList */ \"./src/aspect/AspectList.ts\");\n\n\n\n\n\n\n\n\nvar ExperimentComponentType;\n(function (ExperimentComponentType) {\n    ExperimentComponentType[ExperimentComponentType[\"Reactant\"] = 0] = \"Reactant\";\n    ExperimentComponentType[ExperimentComponentType[\"Reagent\"] = 1] = \"Reagent\";\n    ExperimentComponentType[ExperimentComponentType[\"Product\"] = 2] = \"Product\";\n})(ExperimentComponentType || (ExperimentComponentType = {}));\nclass ExperimentComponent {\n    constructor(mol, name) {\n        this.mol = null;\n        this.name = '';\n        this.stoich = '';\n        this.mass = null;\n        this.volume = null;\n        this.moles = null;\n        this.density = null;\n        this.conc = null;\n        this.yield = null;\n        this.primary = false;\n        this.waste = false;\n        this.equiv = null;\n        this.meta = '';\n        this.mol = mol;\n        if (name)\n            this.name = name;\n    }\n    clone() {\n        let dup = new ExperimentComponent(this.mol, this.name);\n        dup.stoich = this.stoich;\n        dup.mass = this.mass;\n        dup.volume = this.volume;\n        dup.moles = this.moles;\n        dup.density = this.density;\n        dup.conc = this.conc;\n        dup.yield = this.yield;\n        dup.primary = this.primary;\n        dup.waste = this.waste;\n        dup.equiv = this.equiv;\n        dup.meta = this.meta;\n        return dup;\n    }\n    equals(other) {\n        if (this.name != other.name)\n            return false;\n        if (this.stoich != other.stoich || this.mass != other.mass || this.volume != other.volume || this.moles != other.moles ||\n            this.density != other.density || this.conc != other.conc || this.yield != other.yield || this.primary != other.primary ||\n            this.waste != other.waste || this.equiv != other.equiv || this.meta != other.meta)\n            return false;\n        if (this.mol === other.mol)\n            return true;\n        if (this.mol == null || other.mol == null)\n            return false;\n        return this.mol.compareTo(other.mol) == 0;\n    }\n    isBlank() {\n        return _data_MolUtil__WEBPACK_IMPORTED_MODULE_0__.MolUtil.isBlank(this.mol) && !this.name;\n    }\n}\nclass ExperimentStep {\n    constructor() {\n        this.reactants = [];\n        this.reagents = [];\n        this.products = [];\n        this.meta = '';\n    }\n    clone() {\n        let dup = new ExperimentStep();\n        for (let c of this.reactants)\n            dup.reactants.push(c.clone());\n        for (let c of this.reagents)\n            dup.reagents.push(c.clone());\n        for (let c of this.products)\n            dup.products.push(c.clone());\n        dup.meta = this.meta;\n        return dup;\n    }\n    equals(other) {\n        if (this.reactants.length != other.reactants.length)\n            return false;\n        if (this.reagents.length != other.reagents.length)\n            return false;\n        if (this.products.length != other.products.length)\n            return false;\n        if (this.meta != other.meta)\n            return false;\n        for (let n = 0; n < this.reactants.length; n++)\n            if (!this.reactants[n].equals(other.reactants[n]))\n                return false;\n        for (let n = 0; n < this.reagents.length; n++)\n            if (!this.reagents[n].equals(other.reagents[n]))\n                return false;\n        for (let n = 0; n < this.products.length; n++)\n            if (!this.products[n].equals(other.products[n]))\n                return false;\n        return true;\n    }\n}\nclass ExperimentEntry {\n    constructor() {\n        this.title = '';\n        this.createDate = null;\n        this.modifyDate = null;\n        this.doi = '';\n        this.meta = '';\n        this.steps = [];\n    }\n    clone() {\n        let dup = new ExperimentEntry();\n        dup.title = this.title;\n        dup.createDate = this.createDate;\n        dup.modifyDate = this.modifyDate;\n        dup.doi = this.doi;\n        dup.meta = this.meta;\n        for (let s of this.steps)\n            dup.steps.push(s.clone());\n        return dup;\n    }\n    deepClone() {\n        let dup = this.clone();\n        for (let step of dup.steps) {\n            for (let comp of step.reactants)\n                if (comp.mol != null)\n                    comp.mol = comp.mol.clone();\n            for (let comp of step.reagents)\n                if (comp.mol != null)\n                    comp.mol = comp.mol.clone();\n            for (let comp of step.products)\n                if (comp.mol != null)\n                    comp.mol = comp.mol.clone();\n        }\n        return dup;\n    }\n    equals(other) {\n        if (this.title != other.title)\n            return false;\n        let d1 = this.createDate == null ? 0 : this.createDate.getTime(), d2 = other.createDate == null ? 0 : other.createDate.getTime();\n        if (d1 != d2)\n            return false;\n        let d3 = this.modifyDate == null ? 0 : this.modifyDate.getTime(), d4 = other.modifyDate == null ? 0 : other.modifyDate.getTime();\n        if (d3 != d4)\n            return false;\n        if (this.doi != other.doi || this.meta != other.meta)\n            return false;\n        if (this.steps.length != other.steps.length)\n            return false;\n        for (let n = 0; n < this.steps.length; n++)\n            if (!this.steps[n].equals(other.steps[n]))\n                return false;\n        return true;\n    }\n    getComponent(step, type, idx) {\n        if (type == ExperimentComponentType.Reactant)\n            return this.steps[step].reactants[idx];\n        if (type == ExperimentComponentType.Reagent)\n            return this.steps[step].reagents[idx];\n        if (type == ExperimentComponentType.Product)\n            return this.steps[step].products[idx];\n        return new ExperimentComponent();\n    }\n}\nclass Experiment extends _Aspect__WEBPACK_IMPORTED_MODULE_6__.Aspect {\n    constructor(ds, allowModify) {\n        super(Experiment.CODE, ds, allowModify);\n        if (Object.keys(Experiment.COLUMN_DESCRIPTIONS).length == 0) {\n            let v = Experiment.COLUMN_DESCRIPTIONS;\n            v[Experiment.COLNAME_EXPERIMENT_TITLE] = 'Title description for the experiment';\n            v[Experiment.COLNAME_EXPERIMENT_CREATEDATE] = 'Date the experiment was created (seconds since 1970)';\n            v[Experiment.COLNAME_EXPERIMENT_MODIFYDATE] = 'Date the experiment was last modified (seconds since 1970)';\n            v[Experiment.COLNAME_EXPERIMENT_DOI] = 'Digital object identifiers (DOI) for the experiment (whitespace separated)';\n            v[Experiment.COLNAME_EXPERIMENT_META] = 'Additional experiment metadata';\n            v[Experiment.COLNAME_STEP_META] = 'Additional step metadata';\n            v[Experiment.COLNAME_REACTANT_MOL] = 'Molecular structure of reactant';\n            v[Experiment.COLNAME_REACTANT_NAME] = 'Name of reactant';\n            v[Experiment.COLNAME_REACTANT_STOICH] = 'Stoichiometry of reactant';\n            v[Experiment.COLNAME_REACTANT_MASS] = 'Mass quantity of reactant (g)';\n            v[Experiment.COLNAME_REACTANT_VOLUME] = 'Volume quantity of reactant (mL)';\n            v[Experiment.COLNAME_REACTANT_MOLES] = 'Molar quantity of reactant (mol)';\n            v[Experiment.COLNAME_REACTANT_DENSITY] = 'Density of reactant (g/mL)';\n            v[Experiment.COLNAME_REACTANT_CONC] = 'Concentration of reactant (mol/L)';\n            v[Experiment.COLNAME_REACTANT_PRIMARY] = 'Whether the reactant is used for yield calculation';\n            v[Experiment.COLNAME_REACTANT_META] = 'Additional reactant metadata';\n            v[Experiment.COLNAME_REAGENT_MOL] = 'Molecular structure of reagent';\n            v[Experiment.COLNAME_REAGENT_NAME] = 'Name of reagent';\n            v[Experiment.COLNAME_REAGENT_EQUIV] = 'Molar equivalents of reagent';\n            v[Experiment.COLNAME_REAGENT_MASS] = 'Mass quantity of reagent (g)';\n            v[Experiment.COLNAME_REAGENT_VOLUME] = 'Volume quantity of reagent (mL)';\n            v[Experiment.COLNAME_REAGENT_MOLES] = 'Molar quantity of reagent (mol)';\n            v[Experiment.COLNAME_REAGENT_DENSITY] = 'Density of reagent (g/mL)';\n            v[Experiment.COLNAME_REAGENT_CONC] = 'Concentration of reagent (mol/L)';\n            v[Experiment.COLNAME_REAGENT_META] = 'Additional reagent metadata';\n            v[Experiment.COLNAME_PRODUCT_MOL] = 'Molecular structure of product';\n            v[Experiment.COLNAME_PRODUCT_NAME] = 'Name of product';\n            v[Experiment.COLNAME_PRODUCT_STOICH] = 'Stoichiometry of product';\n            v[Experiment.COLNAME_PRODUCT_MASS] = 'Mass quantity of reactant (g)';\n            v[Experiment.COLNAME_PRODUCT_VOLUME] = 'Volume quantity of reactant (mL)';\n            v[Experiment.COLNAME_PRODUCT_MOLES] = 'Molar quantity of reactant (mol)';\n            v[Experiment.COLNAME_PRODUCT_DENSITY] = 'Density of reactant (g/mL)';\n            v[Experiment.COLNAME_PRODUCT_CONC] = 'Concentration of reactant (mol/L)';\n            v[Experiment.COLNAME_PRODUCT_YIELD] = 'Yield of product (%)';\n            v[Experiment.COLNAME_PRODUCT_WASTE] = 'Whether the product is an unwanted byproduct';\n            v[Experiment.COLNAME_PRODUCT_META] = 'Additional product metadata';\n        }\n        this.setup();\n    }\n    static isExperiment(ds) {\n        for (let n = 0; n < ds.numExtensions; n++)\n            if (ds.getExtType(n) == Experiment.CODE)\n                return true;\n        return false;\n    }\n    isFirstStep(row) {\n        if (this.ds.notNull(row, Experiment.COLNAME_EXPERIMENT_CREATEDATE))\n            return true;\n        let mol = this.ds.getMolecule(row, Experiment.COLNAME_REACTANT_MOL + '1');\n        if (_data_MolUtil__WEBPACK_IMPORTED_MODULE_0__.MolUtil.notBlank(mol))\n            return true;\n        let name = this.ds.getString(row, Experiment.COLNAME_REACTANT_NAME + '1');\n        if (name)\n            return true;\n        return false;\n    }\n    numberOfSteps(row) {\n        if (row >= this.ds.numRows)\n            return 0;\n        let steps = 1;\n        while (row + steps < this.ds.numRows) {\n            if (this.isFirstStep(row + steps))\n                break;\n            steps++;\n        }\n        return steps;\n    }\n    getEntry(row) {\n        let entry = new ExperimentEntry();\n        let title = this.ds.getString(row, Experiment.COLNAME_EXPERIMENT_TITLE);\n        if (title)\n            entry.title = title;\n        let createDate = this.ds.getReal(row, Experiment.COLNAME_EXPERIMENT_CREATEDATE);\n        if (createDate)\n            entry.createDate = new Date(createDate * 1000);\n        let modifyDate = this.ds.getReal(row, Experiment.COLNAME_EXPERIMENT_MODIFYDATE);\n        if (modifyDate)\n            entry.modifyDate = new Date(modifyDate * 1000);\n        let doi = this.ds.getString(row, Experiment.COLNAME_EXPERIMENT_DOI);\n        if (doi)\n            entry.doi = doi;\n        let meta = this.ds.getString(row, Experiment.COLNAME_EXPERIMENT_META);\n        if (meta)\n            entry.meta = meta;\n        let [nreactants, nproducts, nreagents] = this.countComponents();\n        for (let pos = row; pos < this.ds.numRows; pos++) {\n            if (pos > row && this.isFirstStep(pos))\n                break;\n            let step = new ExperimentStep();\n            if (pos == row)\n                for (let n = 1; n <= nreactants; n++) {\n                    let comp = this.fetchReactant(pos, n);\n                    if (comp != null)\n                        step.reactants.push(comp);\n                    else\n                        break;\n                }\n            for (let n = 1; n <= nproducts; n++) {\n                let comp = this.fetchProduct(pos, n);\n                if (comp != null)\n                    step.products.push(comp);\n                else\n                    break;\n            }\n            for (let n = 1; n <= nreagents; n++) {\n                let comp = this.fetchReagent(pos, n);\n                if (comp != null)\n                    step.reagents.push(comp);\n                else\n                    break;\n            }\n            step.meta = this.ds.getString(pos, Experiment.COLNAME_STEP_META);\n            entry.steps.push(step);\n        }\n        return entry;\n    }\n    setEntry(row, entry) {\n        this.putEntry(row, entry, true);\n    }\n    addEntry(entry) {\n        this.putEntry(this.ds.numRows, entry, false);\n    }\n    insertEntry(row, entry) {\n        this.putEntry(row, entry, false);\n    }\n    deleteEntry(row) {\n        let nsteps = this.numberOfSteps(row);\n        for (let n = row + nsteps - 1; n >= row; n--)\n            this.ds.deleteRow(n);\n    }\n    setup() {\n        this.parseAndCorrect();\n    }\n    parseAndCorrect() {\n        let ds = this.ds;\n        let idxRxn = -1, idxYld = -1, idxExp = -1;\n        let extRxn = '', extYld = '', extExp = '';\n        for (let n = 0; n < ds.numExtensions; n++) {\n            if (ds.getExtType(n) == Experiment.CODE_RXN) {\n                idxRxn = n;\n                extRxn = ds.getExtData(n);\n            }\n            else if (ds.getExtType(n) == Experiment.CODE_YLD) {\n                idxYld = n;\n                extYld = ds.getExtData(n);\n            }\n            else if (ds.getExtType(n) == Experiment.CODE) {\n                idxExp = n;\n                extExp = ds.getExtData(n);\n            }\n        }\n        let [nreactants, nproducts, nreagents] = this.parseReactionMetaData(extRxn);\n        let meta = `nreactants=${nreactants}\\nnproducts=${nproducts}\\nnreagents=${nreagents}\\n`;\n        if (idxRxn >= 0)\n            ds.setExtData(idxRxn, meta);\n        else\n            ds.appendExtension(Experiment.NAME_RXN, Experiment.CODE_RXN, meta);\n        if (idxYld >= 0)\n            ds.setExtData(idxYld, '');\n        else\n            ds.appendExtension(Experiment.NAME_YLD, Experiment.CODE_YLD, '');\n        if (idxExp >= 0)\n            ds.setExtData(idxExp, '');\n        else\n            ds.appendExtension(Experiment.NAME, Experiment.CODE, '');\n        this.forceColumn(Experiment.COLNAME_EXPERIMENT_TITLE, \"string\");\n        this.forceColumn(Experiment.COLNAME_EXPERIMENT_CREATEDATE, \"real\");\n        this.forceColumn(Experiment.COLNAME_EXPERIMENT_MODIFYDATE, \"real\");\n        this.forceColumn(Experiment.COLNAME_EXPERIMENT_DOI, \"string\");\n        this.forceColumn(Experiment.COLNAME_EXPERIMENT_META, \"string\");\n        this.forceColumn(Experiment.COLNAME_STEP_META, \"string\");\n        for (let n = 1; n <= nreactants; n++)\n            this.forceReactantColumns(n);\n        for (let n = 1; n <= nreagents; n++)\n            this.forceReagentColumns(n);\n        for (let n = 1; n <= nproducts; n++)\n            this.forceProductColumns(n);\n    }\n    forceColumn(colName, type, suffix) {\n        let useName = colName + (suffix == null ? '' : suffix);\n        this.ds.ensureColumn(useName, type, Experiment.COLUMN_DESCRIPTIONS[colName]);\n    }\n    forceReactantColumns(suffix) {\n        this.forceColumn(Experiment.COLNAME_REACTANT_MOL, \"molecule\", suffix);\n        this.forceColumn(Experiment.COLNAME_REACTANT_NAME, \"string\", suffix);\n        this.forceColumn(Experiment.COLNAME_REACTANT_STOICH, \"string\", suffix);\n        this.forceColumn(Experiment.COLNAME_REACTANT_MASS, \"real\", suffix);\n        this.forceColumn(Experiment.COLNAME_REACTANT_VOLUME, \"real\", suffix);\n        this.forceColumn(Experiment.COLNAME_REACTANT_MOLES, \"real\", suffix);\n        this.forceColumn(Experiment.COLNAME_REACTANT_DENSITY, \"real\", suffix);\n        this.forceColumn(Experiment.COLNAME_REACTANT_CONC, \"real\", suffix);\n        this.forceColumn(Experiment.COLNAME_REACTANT_PRIMARY, \"boolean\", suffix);\n        this.forceColumn(Experiment.COLNAME_REACTANT_META, \"string\", suffix);\n    }\n    forceReagentColumns(suffix) {\n        this.forceColumn(Experiment.COLNAME_REAGENT_MOL, \"molecule\", suffix);\n        this.forceColumn(Experiment.COLNAME_REAGENT_NAME, \"string\", suffix);\n        this.forceColumn(Experiment.COLNAME_REAGENT_EQUIV, \"real\", suffix);\n        this.forceColumn(Experiment.COLNAME_REAGENT_MASS, \"real\", suffix);\n        this.forceColumn(Experiment.COLNAME_REAGENT_VOLUME, \"real\", suffix);\n        this.forceColumn(Experiment.COLNAME_REAGENT_MOLES, \"real\", suffix);\n        this.forceColumn(Experiment.COLNAME_REAGENT_DENSITY, \"real\", suffix);\n        this.forceColumn(Experiment.COLNAME_REAGENT_CONC, \"real\", suffix);\n        this.forceColumn(Experiment.COLNAME_REAGENT_META, \"string\", suffix);\n    }\n    forceProductColumns(suffix) {\n        this.forceColumn(Experiment.COLNAME_PRODUCT_MOL, \"molecule\", suffix);\n        this.forceColumn(Experiment.COLNAME_PRODUCT_NAME, \"string\", suffix);\n        this.forceColumn(Experiment.COLNAME_PRODUCT_STOICH, \"string\", suffix);\n        this.forceColumn(Experiment.COLNAME_PRODUCT_MASS, \"real\", suffix);\n        this.forceColumn(Experiment.COLNAME_PRODUCT_VOLUME, \"real\", suffix);\n        this.forceColumn(Experiment.COLNAME_PRODUCT_MOLES, \"real\", suffix);\n        this.forceColumn(Experiment.COLNAME_PRODUCT_DENSITY, \"real\", suffix);\n        this.forceColumn(Experiment.COLNAME_PRODUCT_CONC, \"real\", suffix);\n        this.forceColumn(Experiment.COLNAME_PRODUCT_YIELD, \"real\", suffix);\n        this.forceColumn(Experiment.COLNAME_PRODUCT_WASTE, \"boolean\", suffix);\n        this.forceColumn(Experiment.COLNAME_PRODUCT_META, \"string\", suffix);\n    }\n    parseReactionMetaData(content) {\n        let nreactants = 1, nproducts = 1, nreagents = 0;\n        for (let line of content.split(/\\r?\\n/)) {\n            if (line.startsWith('nreactants='))\n                nreactants = Math.max(nreactants, Math.min(100, parseInt(line.substring(11))));\n            else if (line.startsWith('nproducts='))\n                nproducts = Math.max(nproducts, Math.min(100, parseInt(line.substring(10))));\n            else if (line.startsWith('nreagents='))\n                nreagents = Math.max(nreagents, Math.min(100, parseInt(line.substring(10))));\n        }\n        return [nreactants, nproducts, nreagents];\n    }\n    countComponents() {\n        let nreactants = 0, nproducts = 0, nreagents = 0;\n        for (let n = 0; n < this.ds.numExtensions; n++)\n            if (this.ds.getExtType(n) == Experiment.CODE_RXN) {\n                [nreactants, nproducts, nreagents] = this.parseReactionMetaData(this.ds.getExtData(n));\n                break;\n            }\n        return [nreactants, nproducts, nreagents];\n    }\n    fetchReactant(row, idx) {\n        let mol = this.ds.getMolecule(row, `${Experiment.COLNAME_REACTANT_MOL}${idx}`);\n        let name = this.ds.getString(row, `${Experiment.COLNAME_REACTANT_NAME}${idx}`);\n        if (_data_MolUtil__WEBPACK_IMPORTED_MODULE_0__.MolUtil.isBlank(mol) && !name)\n            return null;\n        let comp = new ExperimentComponent(mol, name);\n        let stoich = this.ds.getString(row, `${Experiment.COLNAME_REACTANT_STOICH}${idx}`);\n        if (stoich)\n            comp.stoich = stoich;\n        comp.mass = this.ds.getReal(row, `${Experiment.COLNAME_REACTANT_MASS}${idx}`);\n        comp.volume = this.ds.getReal(row, `${Experiment.COLNAME_REACTANT_VOLUME}${idx}`);\n        comp.moles = this.ds.getReal(row, `${Experiment.COLNAME_REACTANT_MOLES}${idx}`);\n        comp.density = this.ds.getReal(row, `${Experiment.COLNAME_REACTANT_DENSITY}${idx}`);\n        comp.conc = this.ds.getReal(row, `${Experiment.COLNAME_REACTANT_CONC}${idx}`);\n        let primary = this.ds.getBoolean(row, `${Experiment.COLNAME_REACTANT_PRIMARY}${idx}`);\n        if (primary != null)\n            comp.primary = primary;\n        comp.meta = this.ds.getString(row, `${Experiment.COLNAME_REACTANT_META}${idx}`);\n        return comp;\n    }\n    fetchProduct(row, idx) {\n        let mol = this.ds.getMolecule(row, `${Experiment.COLNAME_PRODUCT_MOL}${idx}`);\n        let name = this.ds.getString(row, `${Experiment.COLNAME_PRODUCT_NAME}${idx}`);\n        if (_data_MolUtil__WEBPACK_IMPORTED_MODULE_0__.MolUtil.isBlank(mol) && !name)\n            return null;\n        let comp = new ExperimentComponent(mol, name);\n        let stoich = this.ds.getString(row, `${Experiment.COLNAME_PRODUCT_STOICH}${idx}`);\n        if (stoich)\n            comp.stoich = stoich;\n        comp.mass = this.ds.getReal(row, `${Experiment.COLNAME_PRODUCT_MASS}${idx}`);\n        comp.volume = this.ds.getReal(row, `${Experiment.COLNAME_PRODUCT_VOLUME}${idx}`);\n        comp.moles = this.ds.getReal(row, `${Experiment.COLNAME_PRODUCT_MOLES}${idx}`);\n        comp.density = this.ds.getReal(row, `${Experiment.COLNAME_PRODUCT_DENSITY}${idx}`);\n        comp.conc = this.ds.getReal(row, `${Experiment.COLNAME_PRODUCT_CONC}${idx}`);\n        comp.yield = this.ds.getReal(row, `${Experiment.COLNAME_PRODUCT_YIELD}${idx}`);\n        let waste = this.ds.getBoolean(row, `${Experiment.COLNAME_PRODUCT_WASTE}${idx}`);\n        if (waste != null)\n            comp.waste = waste;\n        comp.meta = this.ds.getString(row, `${Experiment.COLNAME_PRODUCT_META}${idx}`);\n        return comp;\n    }\n    fetchReagent(row, idx) {\n        let mol = this.ds.getMolecule(row, `${Experiment.COLNAME_REAGENT_MOL}${idx}`);\n        let name = this.ds.getString(row, `${Experiment.COLNAME_REAGENT_NAME}${idx}`);\n        if (_data_MolUtil__WEBPACK_IMPORTED_MODULE_0__.MolUtil.isBlank(mol) && !name)\n            return null;\n        let comp = new ExperimentComponent(mol, name);\n        comp.mass = this.ds.getReal(row, `${Experiment.COLNAME_REAGENT_MASS}${idx}`);\n        comp.volume = this.ds.getReal(row, `${Experiment.COLNAME_REAGENT_VOLUME}${idx}`);\n        comp.moles = this.ds.getReal(row, `${Experiment.COLNAME_REAGENT_MOLES}${idx}`);\n        comp.density = this.ds.getReal(row, `${Experiment.COLNAME_REAGENT_DENSITY}${idx}`);\n        comp.conc = this.ds.getReal(row, `${Experiment.COLNAME_REAGENT_CONC}${idx}`);\n        comp.equiv = this.ds.getReal(row, `${Experiment.COLNAME_REAGENT_EQUIV}${idx}`);\n        comp.meta = this.ds.getString(row, `${Experiment.COLNAME_REAGENT_META}${idx}`);\n        return comp;\n    }\n    putEntry(row, entry, replace) {\n        let [preactants, pproducts, preagents] = this.countComponents();\n        let [nreactants, nproducts, nreagents] = [preactants, pproducts, preagents];\n        for (let step of entry.steps) {\n            nreactants = Math.max(nreactants, step.reactants.length);\n            nproducts = Math.max(nproducts, step.products.length);\n            nreagents = Math.max(nreagents, step.reagents.length);\n        }\n        if (nreactants != preactants || nproducts != pproducts || nreagents != preagents) {\n            let meta = `nreactants=${nreactants}\\nnproducts=${nproducts}\\nnreagents=${nreagents}`;\n            let got = false;\n            for (let n = 0; n < this.ds.numExtensions; n++)\n                if (this.ds.getExtType(n) == Experiment.CODE_RXN) {\n                    this.ds.setExtData(n, meta);\n                    got = true;\n                    break;\n                }\n            if (!got)\n                this.ds.appendExtension(Experiment.NAME_RXN, Experiment.CODE_RXN, meta);\n        }\n        for (let n = 1; n <= nreactants; n++)\n            this.forceReactantColumns(n);\n        for (let n = 1; n <= nreagents; n++)\n            this.forceReagentColumns(n);\n        for (let n = 1; n <= nproducts; n++)\n            this.forceProductColumns(n);\n        let oldSteps = replace ? this.numberOfSteps(row) : 0, newSteps = entry.steps.length;\n        if (oldSteps > newSteps) {\n            for (let n = newSteps; n < oldSteps; n++)\n                this.ds.deleteRow(row + newSteps - 1);\n        }\n        else if (newSteps > oldSteps) {\n            for (let n = oldSteps; n < newSteps; n++)\n                this.ds.insertRow(row + oldSteps);\n        }\n        this.ds.setString(row, Experiment.COLNAME_EXPERIMENT_TITLE, entry.title);\n        this.ds.setReal(row, Experiment.COLNAME_EXPERIMENT_CREATEDATE, entry.createDate == null ? null : entry.createDate.getTime() * 1E-3);\n        this.ds.setReal(row, Experiment.COLNAME_EXPERIMENT_MODIFYDATE, entry.modifyDate == null ? null : entry.modifyDate.getTime() * 1E-3);\n        this.ds.setString(row, Experiment.COLNAME_EXPERIMENT_DOI, entry.doi);\n        this.ds.setString(row, Experiment.COLNAME_EXPERIMENT_META, entry.meta);\n        for (let s = 0; s < entry.steps.length; s++) {\n            let r = row + s, step = entry.steps[s];\n            if (s == 0)\n                for (let n = 0; n < step.reactants.length; n++) {\n                    let comp = step.reactants[n], i = n + 1;\n                    this.ds.setMolecule(r, `${Experiment.COLNAME_REACTANT_MOL}${i}`, comp.mol);\n                    this.ds.setString(r, `${Experiment.COLNAME_REACTANT_NAME}${i}`, comp.name);\n                    this.ds.setString(r, `${Experiment.COLNAME_REACTANT_STOICH}${i}`, comp.stoich);\n                    this.ds.setReal(r, `${Experiment.COLNAME_REACTANT_MASS}${i}`, comp.mass);\n                    this.ds.setReal(r, `${Experiment.COLNAME_REACTANT_VOLUME}${i}`, comp.volume);\n                    this.ds.setReal(r, `${Experiment.COLNAME_REACTANT_MOLES}${i}`, comp.moles);\n                    this.ds.setReal(r, `${Experiment.COLNAME_REACTANT_DENSITY}${i}`, comp.density);\n                    this.ds.setReal(r, `${Experiment.COLNAME_REACTANT_CONC}${i}`, comp.conc);\n                    this.ds.setBoolean(r, `${Experiment.COLNAME_REACTANT_PRIMARY}${i}`, comp.primary);\n                    this.ds.setString(r, `${Experiment.COLNAME_REACTANT_META}${i}`, comp.meta);\n                }\n            for (let n = 0; n < step.reagents.length; n++) {\n                let comp = step.reagents[n], i = n + 1;\n                this.ds.setMolecule(r, `${Experiment.COLNAME_REAGENT_MOL}${i}`, comp.mol);\n                this.ds.setString(r, `${Experiment.COLNAME_REAGENT_NAME}${i}`, comp.name);\n                this.ds.setReal(r, `${Experiment.COLNAME_REAGENT_EQUIV}${i}`, comp.equiv);\n                this.ds.setReal(r, `${Experiment.COLNAME_REAGENT_MASS}${i}`, comp.mass);\n                this.ds.setReal(r, `${Experiment.COLNAME_REAGENT_VOLUME}${i}`, comp.volume);\n                this.ds.setReal(r, `${Experiment.COLNAME_REAGENT_MOLES}${i}`, comp.moles);\n                this.ds.setReal(r, `${Experiment.COLNAME_REAGENT_DENSITY}${i}`, comp.density);\n                this.ds.setReal(r, `${Experiment.COLNAME_REAGENT_CONC}${i}`, comp.conc);\n                this.ds.setString(r, `${Experiment.COLNAME_REAGENT_META}${i}`, comp.meta);\n            }\n            for (let n = 0; n < step.products.length; n++) {\n                let comp = step.products[n], i = n + 1;\n                this.ds.setMolecule(r, `${Experiment.COLNAME_PRODUCT_MOL}${i}`, comp.mol);\n                this.ds.setString(r, `${Experiment.COLNAME_PRODUCT_NAME}${i}`, comp.name);\n                this.ds.setString(r, `${Experiment.COLNAME_PRODUCT_STOICH}${i}`, comp.stoich);\n                this.ds.setReal(r, `${Experiment.COLNAME_PRODUCT_MASS}${i}`, comp.mass);\n                this.ds.setReal(r, `${Experiment.COLNAME_PRODUCT_VOLUME}${i}`, comp.volume);\n                this.ds.setReal(r, `${Experiment.COLNAME_PRODUCT_MOLES}${i}`, comp.moles);\n                this.ds.setReal(r, `${Experiment.COLNAME_PRODUCT_DENSITY}${i}`, comp.density);\n                this.ds.setReal(r, `${Experiment.COLNAME_PRODUCT_CONC}${i}`, comp.conc);\n                this.ds.setReal(r, `${Experiment.COLNAME_PRODUCT_YIELD}${i}`, comp.yield);\n                this.ds.setBoolean(r, `${Experiment.COLNAME_PRODUCT_WASTE}${i}`, comp.waste);\n                this.ds.setString(r, `${Experiment.COLNAME_PRODUCT_META}${i}`, comp.meta);\n            }\n            this.ds.setString(r, Experiment.COLNAME_STEP_META, step.meta);\n        }\n        for (let s = 0; s < entry.steps.length; s++) {\n            let r = row + s;\n            let start = s > 0 ? 0 : entry.steps[s].reactants.length;\n            for (let n = start; n < nreactants; n++) {\n                let i = n + 1;\n                this.ds.setToNull(r, `${Experiment.COLNAME_REACTANT_MOL}${i}`);\n                this.ds.setToNull(r, `${Experiment.COLNAME_REACTANT_NAME}${i}`);\n                this.ds.setToNull(r, `${Experiment.COLNAME_REACTANT_STOICH}${i}`);\n                this.ds.setToNull(r, `${Experiment.COLNAME_REACTANT_MASS}${i}`);\n                this.ds.setToNull(r, `${Experiment.COLNAME_REACTANT_VOLUME}${i}`);\n                this.ds.setToNull(r, `${Experiment.COLNAME_REACTANT_MOLES}${i}`);\n                this.ds.setToNull(r, `${Experiment.COLNAME_REACTANT_DENSITY}${i}`);\n                this.ds.setToNull(r, `${Experiment.COLNAME_REACTANT_CONC}${i}`);\n                this.ds.setToNull(r, `${Experiment.COLNAME_REACTANT_PRIMARY}${i}`);\n                this.ds.setToNull(r, `${Experiment.COLNAME_REACTANT_META}${i}`);\n            }\n            for (let n = entry.steps[s].reagents.length; n < nreagents; n++) {\n                let i = n + 1;\n                this.ds.setToNull(r, `${Experiment.COLNAME_REAGENT_MOL}${i}`);\n                this.ds.setToNull(r, `${Experiment.COLNAME_REAGENT_NAME}${i}`);\n                this.ds.setToNull(r, `${Experiment.COLNAME_REAGENT_EQUIV}${i}`);\n                this.ds.setToNull(r, `${Experiment.COLNAME_REAGENT_MASS}${i}`);\n                this.ds.setToNull(r, `${Experiment.COLNAME_REAGENT_VOLUME}${i}`);\n                this.ds.setToNull(r, `${Experiment.COLNAME_REAGENT_MOLES}${i}`);\n                this.ds.setToNull(r, `${Experiment.COLNAME_REAGENT_DENSITY}${i}`);\n                this.ds.setToNull(r, `${Experiment.COLNAME_REAGENT_CONC}${i}`);\n                this.ds.setToNull(r, `${Experiment.COLNAME_REAGENT_META}${i}`);\n            }\n            for (let n = entry.steps[s].products.length; n < nproducts; n++) {\n                let i = n + 1;\n                this.ds.setToNull(r, `${Experiment.COLNAME_PRODUCT_MOL}${i}`);\n                this.ds.setToNull(r, `${Experiment.COLNAME_PRODUCT_NAME}${i}`);\n                this.ds.setToNull(r, `${Experiment.COLNAME_PRODUCT_STOICH}${i}`);\n                this.ds.setToNull(r, `${Experiment.COLNAME_PRODUCT_MASS}${i}`);\n                this.ds.setToNull(r, `${Experiment.COLNAME_PRODUCT_VOLUME}${i}`);\n                this.ds.setToNull(r, `${Experiment.COLNAME_PRODUCT_MOLES}${i}`);\n                this.ds.setToNull(r, `${Experiment.COLNAME_PRODUCT_DENSITY}${i}`);\n                this.ds.setToNull(r, `${Experiment.COLNAME_PRODUCT_CONC}${i}`);\n                this.ds.setToNull(r, `${Experiment.COLNAME_PRODUCT_WASTE}${i}`);\n                this.ds.setToNull(r, `${Experiment.COLNAME_PRODUCT_META}${i}`);\n            }\n        }\n    }\n    plainHeading() { return Experiment.NAME; }\n    rowFirstBlock(row) { return this.isFirstStep(row); }\n    rowBlockCount(row) { return this.numberOfSteps(row); }\n    initiateNewRow(row) {\n        let curTime = new Date().getTime() * 1E-3;\n        this.ds.setReal(row, Experiment.COLNAME_EXPERIMENT_CREATEDATE, curTime);\n    }\n    columnEffectivelyBlank(row) {\n        return [Experiment.COLNAME_EXPERIMENT_CREATEDATE];\n    }\n    isColumnReserved(colName) {\n        return this.areColumnsReserved([colName])[0];\n    }\n    areColumnsReserved(colNames) {\n        let resv = _util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.booleanArray(false, colNames.length);\n        for (let n = 0; n < colNames.length; n++) {\n            let name = colNames[n];\n            if (Experiment.ALL_COLUMN_LITERALS.indexOf(name) >= 0) {\n                resv[n] = true;\n                continue;\n            }\n            for (let pfx of Experiment.ALL_COLUMN_PREFIXES)\n                if (name.startsWith(pfx)) {\n                    resv[n] = true;\n                    break;\n                }\n        }\n        return resv;\n    }\n    numGraphicRenderings(row) { return 1; }\n    produceGraphicRendering(row, idx, policy) {\n        let measure = new _gfx_ArrangeMeasurement__WEBPACK_IMPORTED_MODULE_2__.OutlineMeasurement(0, 0, policy.data.pointScale);\n        let layout = new _gfx_ArrangeExperiment__WEBPACK_IMPORTED_MODULE_1__.ArrangeExperiment(this.getEntry(row), measure, policy);\n        layout.limitTotalW = 50 * policy.data.pointScale;\n        layout.limitTotalH = 50 * policy.data.pointScale;\n        layout.includeStoich = true;\n        layout.includeAnnot = false;\n        layout.arrange();\n        let metavec = new _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_4__.MetaVector();\n        new _gfx_DrawExperiment__WEBPACK_IMPORTED_MODULE_3__.DrawExperiment(layout, metavec).draw();\n        metavec.normalise();\n        return { 'name': 'Scheme', 'metavec': metavec };\n    }\n}\nExperiment.CODE = 'org.mmi.aspect.Experiment';\nExperiment.CODE_RXN = 'org.mmi.aspect.Reaction';\nExperiment.CODE_YLD = 'org.mmi.aspect.Yield';\nExperiment.NAME = 'Experiment';\nExperiment.NAME_RXN = 'Reaction';\nExperiment.NAME_YLD = 'Yield';\nExperiment.COLNAME_EXPERIMENT_TITLE = 'ExperimentTitle';\nExperiment.COLNAME_EXPERIMENT_CREATEDATE = 'ExperimentCreateDate';\nExperiment.COLNAME_EXPERIMENT_MODIFYDATE = 'ExperimentModifyDate';\nExperiment.COLNAME_EXPERIMENT_DOI = 'ExperimentDOI';\nExperiment.COLNAME_EXPERIMENT_META = 'ExperimentMeta';\nExperiment.COLNAME_STEP_META = 'ExperimentStepMeta';\nExperiment.COLNAME_REACTANT_MOL = 'ReactantMol';\nExperiment.COLNAME_REACTANT_NAME = 'ReactantName';\nExperiment.COLNAME_REACTANT_STOICH = 'ReactantStoich';\nExperiment.COLNAME_REACTANT_MASS = 'ReactantMass';\nExperiment.COLNAME_REACTANT_VOLUME = 'ReactantVolume';\nExperiment.COLNAME_REACTANT_MOLES = 'ReactantMoles';\nExperiment.COLNAME_REACTANT_DENSITY = 'ReactantDensity';\nExperiment.COLNAME_REACTANT_CONC = 'ReactantConc';\nExperiment.COLNAME_REACTANT_PRIMARY = 'ReactantPrimary';\nExperiment.COLNAME_REACTANT_META = 'ReactantMeta';\nExperiment.COLNAME_REAGENT_MOL = 'ReagentMol';\nExperiment.COLNAME_REAGENT_NAME = 'ReagentName';\nExperiment.COLNAME_REAGENT_EQUIV = 'ReagentEquiv';\nExperiment.COLNAME_REAGENT_MASS = 'ReagentMass';\nExperiment.COLNAME_REAGENT_VOLUME = 'ReagentVolume';\nExperiment.COLNAME_REAGENT_MOLES = 'ReagentMoles';\nExperiment.COLNAME_REAGENT_DENSITY = 'ReagentDensity';\nExperiment.COLNAME_REAGENT_CONC = 'ReagentConc';\nExperiment.COLNAME_REAGENT_META = 'ReagentMeta';\nExperiment.COLNAME_PRODUCT_MOL = 'ProductMol';\nExperiment.COLNAME_PRODUCT_NAME = 'ProductName';\nExperiment.COLNAME_PRODUCT_STOICH = 'ProductStoich';\nExperiment.COLNAME_PRODUCT_MASS = 'ProductMass';\nExperiment.COLNAME_PRODUCT_VOLUME = 'ProductVolume';\nExperiment.COLNAME_PRODUCT_MOLES = 'ProductMoles';\nExperiment.COLNAME_PRODUCT_DENSITY = 'ProductDensity';\nExperiment.COLNAME_PRODUCT_CONC = 'ProductConc';\nExperiment.COLNAME_PRODUCT_YIELD = 'ProductYield';\nExperiment.COLNAME_PRODUCT_WASTE = 'ProductWaste';\nExperiment.COLNAME_PRODUCT_META = 'ProductMeta';\nExperiment.COLUMN_DESCRIPTIONS = {};\nExperiment.ALL_COLUMN_LITERALS = [\n    Experiment.COLNAME_EXPERIMENT_TITLE,\n    Experiment.COLNAME_EXPERIMENT_CREATEDATE,\n    Experiment.COLNAME_EXPERIMENT_MODIFYDATE,\n    Experiment.COLNAME_EXPERIMENT_DOI,\n    Experiment.COLNAME_EXPERIMENT_META,\n    Experiment.COLNAME_STEP_META,\n];\nExperiment.ALL_COLUMN_PREFIXES = [\n    Experiment.COLNAME_REACTANT_MOL,\n    Experiment.COLNAME_REACTANT_NAME,\n    Experiment.COLNAME_REACTANT_STOICH,\n    Experiment.COLNAME_REACTANT_MASS,\n    Experiment.COLNAME_REACTANT_VOLUME,\n    Experiment.COLNAME_REACTANT_MOLES,\n    Experiment.COLNAME_REACTANT_DENSITY,\n    Experiment.COLNAME_REACTANT_CONC,\n    Experiment.COLNAME_REACTANT_PRIMARY,\n    Experiment.COLNAME_REACTANT_META,\n    Experiment.COLNAME_REAGENT_MOL,\n    Experiment.COLNAME_REAGENT_NAME,\n    Experiment.COLNAME_REAGENT_EQUIV,\n    Experiment.COLNAME_REAGENT_MASS,\n    Experiment.COLNAME_REAGENT_VOLUME,\n    Experiment.COLNAME_REAGENT_MOLES,\n    Experiment.COLNAME_REAGENT_DENSITY,\n    Experiment.COLNAME_REAGENT_CONC,\n    Experiment.COLNAME_REAGENT_META,\n    Experiment.COLNAME_PRODUCT_MOL,\n    Experiment.COLNAME_PRODUCT_NAME,\n    Experiment.COLNAME_PRODUCT_STOICH,\n    Experiment.COLNAME_PRODUCT_MASS,\n    Experiment.COLNAME_PRODUCT_VOLUME,\n    Experiment.COLNAME_PRODUCT_MOLES,\n    Experiment.COLNAME_PRODUCT_DENSITY,\n    Experiment.COLNAME_PRODUCT_CONC,\n    Experiment.COLNAME_PRODUCT_YIELD,\n    Experiment.COLNAME_PRODUCT_WASTE,\n    Experiment.COLNAME_PRODUCT_META,\n];\n(0,_AspectList__WEBPACK_IMPORTED_MODULE_7__.registerAspect)(Experiment);\n\n\n//# sourceURL=webpack://WebMolKit/./src/aspect/Experiment.ts?");

/***/ }),

/***/ "./src/aspect/MeasurementData.ts":
/*!***************************************!*\
  !*** ./src/aspect/MeasurementData.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MeasurementData\": () => (/* binding */ MeasurementData)\n/* harmony export */ });\n/* harmony import */ var _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/MoleculeStream */ \"./src/data/MoleculeStream.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _Aspect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Aspect */ \"./src/aspect/Aspect.ts\");\n/* harmony import */ var _AspectList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AspectList */ \"./src/aspect/AspectList.ts\");\n\n\n\n\nclass MeasurementData extends _Aspect__WEBPACK_IMPORTED_MODULE_2__.Aspect {\n    constructor(ds, allowModify) {\n        super(MeasurementData.CODE, ds, allowModify);\n        this.header = { 'units': [], 'fields': [] };\n        this.setup();\n    }\n    static isMeasurementData(ds) {\n        for (let n = 0; n < ds.numExtensions; n++)\n            if (ds.getExtType(n) == MeasurementData.CODE)\n                return true;\n        return false;\n    }\n    getHeader() {\n        return this.header;\n    }\n    setHeader(header) {\n        this.header = header;\n        let content = this.formatMetaData(header);\n        for (let n = 0; n < this.ds.numExtensions; n++)\n            if (this.ds.getExtType(n) == MeasurementData.CODE) {\n                this.ds.setExtData(n, content);\n                return;\n            }\n        this.ds.appendExtension(MeasurementData.NAME, MeasurementData.CODE, content);\n    }\n    effectHeader(header) {\n        this.setHeader(header);\n        this.ensureFields();\n    }\n    rename(fldidx, newName) {\n        let oldName = this.header.fields[fldidx].name;\n        if (oldName == newName)\n            return;\n        this.header.fields[fldidx].name = newName;\n        this.setHeader(this.header);\n        for (let sfx of [MeasurementData.SUFFIX_VALUE, MeasurementData.SUFFIX_ERROR, MeasurementData.SUFFIX_UNITS, MeasurementData.SUFFIX_MOD]) {\n            let col = this.ds.findColByName(oldName + sfx);\n            if (col >= 0)\n                this.ds.changeColumnName(col, newName + sfx, this.ds.colDescr(col));\n        }\n    }\n    reservedColumns(fldidx) {\n        let fieldName = this.header.fields[fldidx].name;\n        return [fieldName + MeasurementData.SUFFIX_VALUE, fieldName + MeasurementData.SUFFIX_ERROR,\n            fieldName + MeasurementData.SUFFIX_UNITS, fieldName + MeasurementData.SUFFIX_MOD];\n    }\n    getValue(row, fldidx) {\n        return this.getValueField(row, this.header.fields[fldidx]);\n    }\n    getValueField(row, field) {\n        let value = { 'value': Number.NaN, 'error': Number.NaN, 'units': '', 'mod': '' };\n        let colValue = this.ds.findColByName(field.name + MeasurementData.SUFFIX_VALUE, \"real\");\n        let colError = this.ds.findColByName(field.name + MeasurementData.SUFFIX_ERROR, \"real\");\n        let colUnits = this.ds.findColByName(field.name + MeasurementData.SUFFIX_UNITS, \"string\");\n        let colMod = this.ds.findColByName(field.name + MeasurementData.SUFFIX_MOD, \"string\");\n        if (colValue >= 0 && this.ds.notNull(row, colValue))\n            value.value = this.ds.getReal(row, colValue);\n        if (colError >= 0 && this.ds.notNull(row, colError))\n            value.error = this.ds.getReal(row, colError);\n        if (colUnits >= 0)\n            value.units = this.ds.getString(row, colUnits);\n        if (colMod >= 0)\n            value.mod = this.ds.getString(row, colMod);\n        return value;\n    }\n    setValue(row, fldidx, value) {\n        let fieldName = this.header.fields[fldidx].name;\n        let colValue = this.ds.findColByName(fieldName + MeasurementData.SUFFIX_VALUE, \"real\");\n        let colError = this.ds.findColByName(fieldName + MeasurementData.SUFFIX_ERROR, \"real\");\n        let colUnits = this.ds.findColByName(fieldName + MeasurementData.SUFFIX_UNITS, \"string\");\n        let colMod = this.ds.findColByName(fieldName + MeasurementData.SUFFIX_MOD, \"string\");\n        if (colValue >= 0)\n            if (isNaN(value.value))\n                this.ds.setToNull(row, colValue);\n            else\n                this.ds.setReal(row, colValue, value.value);\n        if (colError >= 0)\n            if (isNaN(value.error))\n                this.ds.setToNull(row, colError);\n            else\n                this.ds.setReal(row, colError, value.error);\n        if (colUnits >= 0)\n            this.ds.setString(row, colUnits, value.units);\n        if (colMod >= 0)\n            this.ds.setString(row, colMod, value.mod);\n    }\n    clearValue(row, fldidx) {\n        let fieldName = this.header.fields[fldidx].name;\n        let colValue = this.ds.findColByName(fieldName + MeasurementData.SUFFIX_VALUE, \"real\");\n        let colError = this.ds.findColByName(fieldName + MeasurementData.SUFFIX_ERROR, \"real\");\n        let colUnits = this.ds.findColByName(fieldName + MeasurementData.SUFFIX_UNITS, \"string\");\n        let colMod = this.ds.findColByName(fieldName + MeasurementData.SUFFIX_MOD, \"string\");\n        if (colValue >= 0)\n            this.ds.setToNull(row, colValue);\n        if (colError >= 0)\n            this.ds.setToNull(row, colError);\n        if (colUnits >= 0)\n            this.ds.setToNull(row, colUnits);\n        if (colMod >= 0)\n            this.ds.setToNull(row, colMod);\n    }\n    getDescr(row, fldidx) {\n        let col = this.ds.findColByName(this.header.fields[fldidx].name);\n        return col < 0 ? '' : this.ds.colDescr(col);\n    }\n    setDescr(row, fldidx, descr) {\n        let col = this.ds.findColByName(this.header.fields[fldidx].name);\n        if (col >= 0)\n            this.ds.changeColumnName(col, this.ds.colName(col), descr);\n    }\n    setup() {\n        this.parseAndCorrect();\n    }\n    parseAndCorrect() {\n        this.header = { 'units': [], 'fields': [] };\n        let got = false;\n        for (let n = 0; n < this.ds.numExtensions; n++)\n            if (this.ds.getExtType(n) == MeasurementData.CODE) {\n                this.header = this.parseMetaData(this.ds.getExtData(n));\n                got = true;\n                break;\n            }\n        this.ensureFields();\n        if (!got && this.allowModify) {\n            let content = this.formatMetaData(this.header);\n            this.ds.appendExtension(MeasurementData.NAME, MeasurementData.CODE, content);\n        }\n    }\n    ensureFields() {\n        for (let f of this.header.fields) {\n            let descr = 'Measurement';\n            let colidx = this.ds.findColByName(f.name);\n            if (colidx >= 0)\n                descr = this.ds.colDescr(colidx);\n            if (this.allowModify) {\n                this.ds.ensureColumn(f.name + MeasurementData.SUFFIX_VALUE, \"real\", descr);\n                this.ds.ensureColumn(f.name + MeasurementData.SUFFIX_ERROR, \"real\", 'Error');\n                this.ds.ensureColumn(f.name + MeasurementData.SUFFIX_UNITS, \"string\", 'Units');\n                this.ds.ensureColumn(f.name + MeasurementData.SUFFIX_MOD, \"string\", 'Modifier');\n            }\n        }\n    }\n    parseMetaData(content) {\n        let header = { 'units': [], 'fields': [] };\n        for (let line of content.split(/\\r?\\n/)) {\n            let eq = line.indexOf('=');\n            if (eq < 0)\n                continue;\n            if (line.startsWith('unit=')) {\n                let bits = line.substring(eq + 1).split(',');\n                if (bits.length >= 2)\n                    header.units.push({ 'name': _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(bits[0]), 'uri': _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(bits[1]) });\n            }\n            else if (line.startsWith('field=')) {\n                let bits = line.substring(eq + 1).split(',');\n                let f = { 'name': _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(bits[0]), 'units': [], 'defnURI': [] };\n                for (let n = 1; n < bits.length; n++)\n                    f.units.push(_data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(bits[n]));\n                header.fields.push(f);\n            }\n            else if (line.startsWith('definition=')) {\n                let bits = line.substring(eq + 1).split(',');\n                if (bits.length >= 2) {\n                    let f = header.fields.find((f) => f.name == bits[0]);\n                    if (!f)\n                        continue;\n                    for (let n = 1; n < bits.length; n++)\n                        f.defnURI.push(_data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(bits[n]));\n                }\n            }\n        }\n        return header;\n    }\n    formatMetaData(header) {\n        let lines = [];\n        for (let u of header.units) {\n            lines.push('unit=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(u.name) + ',' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(u.uri));\n        }\n        for (let f of header.fields) {\n            let line = 'field=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(f.name);\n            for (let u of f.units)\n                line += ',' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(u);\n            lines.push(line);\n            if (_util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.notBlank(f.defnURI)) {\n                line = 'definition=' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(f.name);\n                for (let d of f.defnURI)\n                    line += ',' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(d);\n                lines.push(line);\n            }\n        }\n        return lines.join('\\n');\n    }\n    plainHeading() { return MeasurementData.NAME; }\n    isColumnReserved(colName) {\n        return this.areColumnsReserved([colName])[0];\n    }\n    areColumnsReserved(colNames) {\n        let names = new Set();\n        for (let f of this.header.fields) {\n            names.add(f.name + MeasurementData.SUFFIX_VALUE);\n            names.add(f.name + MeasurementData.SUFFIX_ERROR);\n            names.add(f.name + MeasurementData.SUFFIX_UNITS);\n            names.add(f.name + MeasurementData.SUFFIX_MOD);\n        }\n        let resv = [];\n        for (let col of colNames)\n            resv.push(names.has(col));\n        return resv;\n    }\n    numTextRenderings(row) { return this.header.fields.length; }\n    produceTextRendering(row, idx) {\n        let field = this.header.fields[idx];\n        let colField = this.ds.findColByName(field.name);\n        let tr = {\n            'name': field.name,\n            'descr': colField < 0 ? '' : this.ds.colDescr(colField),\n            'text': '',\n            'type': _Aspect__WEBPACK_IMPORTED_MODULE_2__.Aspect.TEXT_PLAIN\n        };\n        let datum = this.getValue(row, idx);\n        if (!Number.isNaN(datum.value)) {\n            if (datum.mod)\n                tr.text += datum.mod + ' ';\n            tr.text += datum.value;\n            if (!Number.isNaN(datum.error))\n                tr.text += ' \\u{00B1} ' + datum.error;\n            if (datum.units)\n                tr.text += ' ' + datum.units;\n        }\n        return tr;\n    }\n}\nMeasurementData.CODE = 'org.mmi.aspect.MeasurementData';\nMeasurementData.NAME = 'Measurement Data';\nMeasurementData.SUFFIX_VALUE = '';\nMeasurementData.SUFFIX_ERROR = '_error';\nMeasurementData.SUFFIX_UNITS = '_units';\nMeasurementData.SUFFIX_MOD = '_mod';\n(0,_AspectList__WEBPACK_IMPORTED_MODULE_3__.registerAspect)(MeasurementData);\n\n\n//# sourceURL=webpack://WebMolKit/./src/aspect/MeasurementData.ts?");

/***/ }),

/***/ "./src/aspect/Mixture.ts":
/*!*******************************!*\
  !*** ./src/aspect/Mixture.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Mixture\": () => (/* binding */ Mixture),\n/* harmony export */   \"MixtureAttributeType\": () => (/* binding */ MixtureAttributeType)\n/* harmony export */ });\n/* harmony import */ var _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/MoleculeStream */ \"./src/data/MoleculeStream.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _Aspect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Aspect */ \"./src/aspect/Aspect.ts\");\n/* harmony import */ var _AspectList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AspectList */ \"./src/aspect/AspectList.ts\");\n/* harmony import */ var _MeasurementData__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MeasurementData */ \"./src/aspect/MeasurementData.ts\");\n\n\n\n\n\nvar MixtureAttributeType;\n(function (MixtureAttributeType) {\n    MixtureAttributeType[\"Structure\"] = \"structure\";\n    MixtureAttributeType[\"Name\"] = \"name\";\n    MixtureAttributeType[\"Quantity\"] = \"quantity\";\n    MixtureAttributeType[\"Bound\"] = \"bound\";\n    MixtureAttributeType[\"Error\"] = \"error\";\n    MixtureAttributeType[\"Ratio\"] = \"ratio\";\n    MixtureAttributeType[\"Units\"] = \"units\";\n    MixtureAttributeType[\"Relation\"] = \"relation\";\n    MixtureAttributeType[\"Identifier\"] = \"identifier\";\n    MixtureAttributeType[\"Link\"] = \"link\";\n    MixtureAttributeType[\"Property\"] = \"property\";\n})(MixtureAttributeType || (MixtureAttributeType = {}));\nclass Mixture extends _Aspect__WEBPACK_IMPORTED_MODULE_2__.Aspect {\n    constructor(ds, allowModify) {\n        super(Mixture.CODE, ds, allowModify);\n        this.header = { 'attributes': [] };\n        this.setup();\n    }\n    static isMixture(ds) {\n        for (let n = 0; n < ds.numExtensions; n++)\n            if (ds.getExtType(n) == Mixture.CODE)\n                return true;\n        return false;\n    }\n    getHeader() {\n        return this.header;\n    }\n    setHeader(header) {\n        this.header = header;\n        let content = this.formatMetaData(header);\n        for (let n = 0; n < this.ds.numExtensions; n++)\n            if (this.ds.getExtType(n) == Mixture.CODE) {\n                this.ds.setExtData(n, content);\n                return;\n            }\n        this.ds.appendExtension(Mixture.NAME, Mixture.CODE, content);\n    }\n    setup() {\n        this.parseAndCorrect();\n    }\n    parseAndCorrect() {\n        this.header = { 'attributes': [] };\n        let got = false;\n        for (let n = 0; n < this.ds.numExtensions; n++)\n            if (this.ds.getExtType(n) == Mixture.CODE) {\n                this.header = this.parseMetaData(this.ds.getExtData(n));\n                got = true;\n                break;\n            }\n        if (!got && this.allowModify) {\n            let content = this.formatMetaData(this.header);\n            this.ds.appendExtension(Mixture.NAME, Mixture.CODE, content);\n        }\n    }\n    parseMetaData(content) {\n        let header = { 'attributes': [] };\n        for (let line of content.split(/\\r?\\n/)) {\n            let eq = line.indexOf('=');\n            if (eq < 0)\n                continue;\n            if (line.startsWith('attr=')) {\n                let bits = line.substring(eq + 1).split(',');\n                if (bits.length < 3)\n                    continue;\n                let column = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(bits[0]);\n                let position = [];\n                if (bits[1] != '0')\n                    position = bits[1].split('.').map((str) => parseInt(str));\n                let type = bits[2];\n                let info = [];\n                for (let n = 3; n < bits.length; n++)\n                    info.push(_data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(bits[n]));\n                header.attributes.push({ column, position, type, info });\n            }\n        }\n        return header;\n    }\n    formatMetaData(header) {\n        let lines = [];\n        for (let a of header.attributes) {\n            let bits = [_data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(a.column)];\n            if (_util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.isBlank(a.position))\n                bits.push('0');\n            else\n                bits.push(a.position.join('.'));\n            bits.push(a.type);\n            if (a.info)\n                for (let str of a.info)\n                    bits.push(_data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(str));\n            lines.push('attr=' + bits.join(','));\n        }\n        return lines.join('\\n');\n    }\n    plainHeading() { return _MeasurementData__WEBPACK_IMPORTED_MODULE_4__.MeasurementData.NAME; }\n    isColumnReserved(colName) {\n        return this.areColumnsReserved([colName])[0];\n    }\n    areColumnsReserved(colNames) {\n        let names = new Set();\n        for (let a of this.header.attributes)\n            names.add(a.column);\n        let resv = [];\n        for (let col of colNames)\n            resv.push(names.has(col));\n        return resv;\n    }\n}\nMixture.CODE = 'org.mmi.aspect.Mixture';\nMixture.NAME = 'Mixture';\nMixture.SUFFIX_VALUE = '';\n(0,_AspectList__WEBPACK_IMPORTED_MODULE_3__.registerAspect)(Mixture);\n\n\n//# sourceURL=webpack://WebMolKit/./src/aspect/Mixture.ts?");

/***/ }),

/***/ "./src/aspect/SARTable.ts":
/*!********************************!*\
  !*** ./src/aspect/SARTable.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SARTable\": () => (/* binding */ SARTable)\n/* harmony export */ });\n/* harmony import */ var _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/MoleculeStream */ \"./src/data/MoleculeStream.ts\");\n/* harmony import */ var _data_MolUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/MolUtil */ \"./src/data/MolUtil.ts\");\n/* harmony import */ var _gfx_ArrangeMeasurement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../gfx/ArrangeMeasurement */ \"./src/gfx/ArrangeMeasurement.ts\");\n/* harmony import */ var _gfx_ArrangeMolecule__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../gfx/ArrangeMolecule */ \"./src/gfx/ArrangeMolecule.ts\");\n/* harmony import */ var _gfx_DrawMolecule__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../gfx/DrawMolecule */ \"./src/gfx/DrawMolecule.ts\");\n/* harmony import */ var _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../gfx/MetaVector */ \"./src/gfx/MetaVector.ts\");\n/* harmony import */ var _gfx_Rendering__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../gfx/Rendering */ \"./src/gfx/Rendering.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _Aspect__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Aspect */ \"./src/aspect/Aspect.ts\");\n/* harmony import */ var _AspectList__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./AspectList */ \"./src/aspect/AspectList.ts\");\n\n\n\n\n\n\n\n\n\n\nclass SARTable extends _Aspect__WEBPACK_IMPORTED_MODULE_8__.Aspect {\n    constructor(ds, allowModify) {\n        super(SARTable.CODE, ds, allowModify);\n        this.setup();\n    }\n    static isSARTable(ds) {\n        for (let n = 0; n < ds.numExtensions; n++)\n            if (ds.getExtType(n) == SARTable.CODE)\n                return true;\n        return false;\n    }\n    getFields() {\n        for (let n = 0; n < this.ds.numExtensions; n++)\n            if (this.ds.getExtType(n) == SARTable.CODE)\n                return this.parseMetaData(this.ds.getExtData(n));\n        return null;\n    }\n    setFields(fields) {\n        let content = this.formatMetaData(fields);\n        for (let n = 0; n < this.ds.numExtensions; n++)\n            if (this.ds.getExtType(n) == SARTable.CODE) {\n                this.ds.setExtData(n, content);\n                return;\n            }\n        this.ds.appendExtension(SARTable.NAME, SARTable.CODE, content);\n    }\n    getEntry(row) {\n        let fields = this.getFields();\n        let entry = {\n            'construct': this.ds.getMolecule(row, fields.construct),\n            'locked': !!this.ds.getBoolean(row, fields.locked),\n            'scaffold': this.ds.getMolecule(row, fields.scaffold),\n            'substNames': [],\n            'substituents': []\n        };\n        for (let subst of fields.substituents) {\n            entry.substNames.push(subst);\n            entry.substituents.push(this.ds.getMolecule(row, subst));\n        }\n        return entry;\n    }\n    setEntry(row, entry) {\n        let fields = this.getFields();\n        let colConstruct = this.ds.findColByName(fields.construct, \"molecule\");\n        if (colConstruct >= 0)\n            this.ds.setMolecule(row, colConstruct, entry.construct);\n        let colLocked = this.ds.findColByName(fields.locked, \"boolean\");\n        if (colLocked >= 0)\n            this.ds.setBoolean(row, colLocked, entry.locked);\n        let colScaffold = this.ds.findColByName(fields.scaffold, \"molecule\");\n        if (colScaffold >= 0)\n            this.ds.setMolecule(row, colScaffold, entry.scaffold);\n        for (let n = 0; n < fields.substituents.length; n++) {\n            let colSubst = this.ds.findColByName(fields.substituents[n], \"molecule\");\n            if (colSubst >= 0)\n                this.ds.setMolecule(row, colSubst, entry.substituents[n]);\n        }\n    }\n    createSubstituents(tobeAdded) {\n        if (tobeAdded.length == 0)\n            return;\n        let fields = this.getFields();\n        let modified = false;\n        for (let name of tobeAdded)\n            if (fields.substituents.indexOf(name) < 0) {\n                fields.substituents.push(name);\n                this.ds.ensureColumn(name, \"molecule\", SARTable.DESCR_SUBSTITUENT);\n                modified = true;\n            }\n        if (modified)\n            this.setFields(fields);\n    }\n    static isAttachment(mol, atom) {\n        return mol.atomicNumber(atom) == 0 && !_data_MolUtil__WEBPACK_IMPORTED_MODULE_1__.MolUtil.hasAbbrev(mol, atom) && mol.atomAdjCount(atom) == 1;\n    }\n    setup() {\n        this.parseAndCorrect();\n    }\n    parseAndCorrect() {\n        let fields = {\n            'construct': 'Molecule',\n            'locked': 'Molecule_locked',\n            'scaffold': 'Scaffold',\n            'substituents': [],\n            'metadata': []\n        };\n        let got = false;\n        for (let n = 0; n < this.ds.numExtensions; n++)\n            if (this.ds.getExtType(n) == SARTable.CODE) {\n                fields = this.parseMetaData(this.ds.getExtData(n));\n                got = true;\n                break;\n            }\n        this.ds.ensureColumn(fields.construct, \"molecule\", SARTable.DESCR_CONSTRUCT);\n        this.ds.ensureColumn(fields.locked, \"boolean\", SARTable.DESCR_LOCKED);\n        this.ds.ensureColumn(fields.scaffold, \"molecule\", SARTable.DESCR_SCAFFOLD);\n        for (let subst of fields.substituents)\n            this.ds.ensureColumn(subst, \"molecule\", SARTable.DESCR_SUBSTITUENT);\n        if (!got) {\n            let content = this.formatMetaData(fields);\n            this.ds.appendExtension(SARTable.NAME, SARTable.CODE, content);\n        }\n    }\n    parseMetaData(content) {\n        let fields = { 'construct': null, 'locked': null, 'scaffold': null, 'substituents': [], 'metadata': [] };\n        for (let line of content.split(/\\r?\\n/)) {\n            let pos = line.indexOf('=');\n            if (pos < 0)\n                continue;\n            let key = line.substring(0, pos), val = line.substring(pos + 1);\n            if (key == 'field') {\n                let bits = val.split(',');\n                if (bits.length >= 3) {\n                    let type = bits[0], name = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(bits[1]);\n                    if (type == 'construct') {\n                        fields.construct = name;\n                        fields.locked = name + '_locked';\n                        continue;\n                    }\n                    else if (type == 'scaffold') {\n                        fields.scaffold = name;\n                        continue;\n                    }\n                    else if (type == 'substituent') {\n                        fields.substituents.push(name);\n                        continue;\n                    }\n                }\n            }\n            fields.metadata.push(line);\n        }\n        return fields;\n    }\n    formatMetaData(fields) {\n        let content = '';\n        content += 'field=construct,' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(fields.construct) + ',\\n';\n        content += 'field=scaffold,' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(fields.scaffold) + ',\\n';\n        for (let subst of fields.substituents)\n            content += 'field=substituent,' + _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(subst) + ',\\n';\n        for (let meta of fields.metadata)\n            content += meta + '\\n';\n        return content;\n    }\n    plainHeading() { return SARTable.NAME; }\n    isColumnReserved(colName) {\n        return this.areColumnsReserved([colName])[0];\n    }\n    areColumnsReserved(colNames) {\n        let fields = this.getFields();\n        let used = new Set();\n        used.add(fields.construct);\n        used.add(fields.locked);\n        used.add(fields.scaffold);\n        for (let subst of fields.substituents)\n            used.add(subst);\n        let reserved = _util_Vec__WEBPACK_IMPORTED_MODULE_7__.Vec.booleanArray(false, colNames.length);\n        for (let n = 0; n < colNames.length; n++)\n            reserved[n] = used.has(colNames[n]);\n        return reserved;\n    }\n    numGraphicRenderings(row) {\n        let fields = this.getFields();\n        return 2 + fields.substituents.length;\n    }\n    produceGraphicRendering(row, idx, policy) {\n        let fields = this.getFields(), ds = this.ds;\n        if (idx == SARTable.RENDER_CONSTRUCT) {\n            let mol = ds.getMolecule(row, fields.construct);\n            let metavec = new _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_5__.MetaVector();\n            if (_data_MolUtil__WEBPACK_IMPORTED_MODULE_1__.MolUtil.notBlank(mol)) {\n                let effects = new _gfx_Rendering__WEBPACK_IMPORTED_MODULE_6__.RenderEffects();\n                for (let n = 1; n <= mol.numAtoms; n++)\n                    if (mol.atomMapNum(n) > 0)\n                        effects.colAtom[n] = 0x096E6F;\n                for (let n = 1; n <= mol.numBonds; n++) {\n                    let m1 = mol.atomMapNum(mol.bondFrom(n)), m2 = mol.atomMapNum(mol.bondTo(n));\n                    if (m1 > 0 && m2 > 0)\n                        effects.colBond[n] = 0x096E6F;\n                    else if (m1 > 0 || m2 > 0)\n                        effects.dottedBondCross[n] = 0x606060;\n                }\n                let measure = new _gfx_ArrangeMeasurement__WEBPACK_IMPORTED_MODULE_2__.OutlineMeasurement(0, 0, policy.data.pointScale);\n                let layout = new _gfx_ArrangeMolecule__WEBPACK_IMPORTED_MODULE_3__.ArrangeMolecule(mol, measure, policy, effects);\n                layout.arrange();\n                new _gfx_DrawMolecule__WEBPACK_IMPORTED_MODULE_4__.DrawMolecule(layout, metavec).draw();\n            }\n            else\n                metavec.drawText(0, 0, '?', 15, 0x000000);\n            metavec.normalise();\n            return { 'name': fields.construct, 'metavec': metavec };\n        }\n        else if (idx == SARTable.RENDER_SCAFFOLD) {\n            let mol = ds.getMolecule(row, fields.scaffold);\n            let metavec = new _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_5__.MetaVector();\n            if (_data_MolUtil__WEBPACK_IMPORTED_MODULE_1__.MolUtil.notBlank(mol)) {\n                let effects = new _gfx_Rendering__WEBPACK_IMPORTED_MODULE_6__.RenderEffects();\n                for (let n = 1; n <= mol.numAtoms; n++)\n                    if (SARTable.isAttachment(mol, n)) {\n                        let isDefined = false;\n                        let el = mol.atomElement(n);\n                        outer: for (let colName of fields.substituents) {\n                            let subst = ds.getMolecule(row, colName);\n                            if (subst != null)\n                                for (let i = 1; i <= subst.numAtoms; i++)\n                                    if (subst.atomElement(i) == el || (subst.atomElement(i) == 'R' && el == colName)) {\n                                        isDefined = true;\n                                        break outer;\n                                    }\n                        }\n                        effects.colAtom[n] = isDefined ? 0x096E6F : 0xFF0000;\n                        effects.dottedRectOutline[n] = isDefined ? 0x808080 : 0xFF0000;\n                    }\n                let measure = new _gfx_ArrangeMeasurement__WEBPACK_IMPORTED_MODULE_2__.OutlineMeasurement(0, 0, policy.data.pointScale);\n                let layout = new _gfx_ArrangeMolecule__WEBPACK_IMPORTED_MODULE_3__.ArrangeMolecule(mol, measure, policy, effects);\n                layout.arrange();\n                new _gfx_DrawMolecule__WEBPACK_IMPORTED_MODULE_4__.DrawMolecule(layout, metavec).draw();\n            }\n            else\n                metavec.drawText(0, 0, '?', 15, 0x000000);\n            metavec.normalise();\n            return { 'name': fields.scaffold, 'metavec': metavec };\n        }\n        else if (idx >= SARTable.RENDER_SUBSTITUENT && idx < SARTable.RENDER_SUBSTITUENT + fields.substituents.length) {\n            let sidx = idx - SARTable.RENDER_SUBSTITUENT, sname = fields.substituents[sidx];\n            let mol = ds.getMolecule(row, sname);\n            let metavec = new _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_5__.MetaVector();\n            if (_data_MolUtil__WEBPACK_IMPORTED_MODULE_1__.MolUtil.notBlank(mol)) {\n                let effects = new _gfx_Rendering__WEBPACK_IMPORTED_MODULE_6__.RenderEffects();\n                for (let n = 1; n <= mol.numAtoms; n++)\n                    if (SARTable.isAttachment(mol, n)) {\n                        effects.colAtom[n] = 0x096E6F;\n                        effects.dottedRectOutline[n] = 0x808080;\n                    }\n                let measure = new _gfx_ArrangeMeasurement__WEBPACK_IMPORTED_MODULE_2__.OutlineMeasurement(0, 0, policy.data.pointScale);\n                let layout = new _gfx_ArrangeMolecule__WEBPACK_IMPORTED_MODULE_3__.ArrangeMolecule(mol, measure, policy, effects);\n                layout.arrange();\n                new _gfx_DrawMolecule__WEBPACK_IMPORTED_MODULE_4__.DrawMolecule(layout, metavec).draw();\n            }\n            else {\n                let txt = '?';\n                let scaff = ds.getMolecule(row, fields.scaffold);\n                if (_data_MolUtil__WEBPACK_IMPORTED_MODULE_1__.MolUtil.notBlank(scaff)) {\n                    txt = 'n/a';\n                    for (let n = 1; n <= scaff.numAtoms; n++)\n                        if (scaff.atomElement(n) == sname) {\n                            txt = '?';\n                            break;\n                        }\n                    if (txt == '?')\n                        for (let n = 0; n < fields.substituents.length; n++)\n                            if (n != sidx) {\n                                let subst = ds.getMolecule(row, fields.substituents[n]);\n                                if (_data_MolUtil__WEBPACK_IMPORTED_MODULE_1__.MolUtil.notBlank(subst)) {\n                                    for (let i = 1; i <= subst.numAtoms; i++)\n                                        if (subst.atomElement(i) == sname) {\n                                            txt = 'n/a';\n                                            break;\n                                        }\n                                }\n                            }\n                }\n                metavec.drawText(0, 0, txt, 15, 0x000000);\n            }\n            metavec.normalise();\n            return { 'name': sname, 'metavec': metavec };\n        }\n        return null;\n    }\n}\nSARTable.CODE = 'org.mmi.aspect.SARTable';\nSARTable.NAME = 'SAR Table';\nSARTable.DESCR_CONSTRUCT = 'Structure of constructed molecule';\nSARTable.DESCR_LOCKED = 'Whether constructed molecule should be rebuilt';\nSARTable.DESCR_SCAFFOLD = 'Decorated core scaffold of molecule';\nSARTable.DESCR_SUBSTITUENT = 'Substituent fragment to be attached to scaffold';\nSARTable.RENDER_CONSTRUCT = 0;\nSARTable.RENDER_SCAFFOLD = 1;\nSARTable.RENDER_SUBSTITUENT = 2;\n(0,_AspectList__WEBPACK_IMPORTED_MODULE_9__.registerAspect)(SARTable);\n\n\n//# sourceURL=webpack://WebMolKit/./src/aspect/SARTable.ts?");

/***/ }),

/***/ "./src/calc/BayesianModel.ts":
/*!***********************************!*\
  !*** ./src/calc/BayesianModel.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BayesianModel\": () => (/* binding */ BayesianModel)\n/* harmony export */ });\n/* harmony import */ var _data_MetaMolecule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/MetaMolecule */ \"./src/data/MetaMolecule.ts\");\n/* harmony import */ var _data_MolUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/MolUtil */ \"./src/data/MolUtil.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _CircularFingerprints__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CircularFingerprints */ \"./src/calc/CircularFingerprints.ts\");\n\n\n\n\n\nclass BayesianModel {\n    constructor(classType, folding) {\n        this.classType = classType;\n        this.folding = folding;\n        this.numActive = 0;\n        this.inHash = {};\n        this.training = [];\n        this.activity = [];\n        this.contribs = {};\n        this.lowThresh = 0;\n        this.highThresh = 0;\n        this.range = 0;\n        this.invRange = 0;\n        this.estimates = null;\n        this.rocX = null;\n        this.rocY = null;\n        this.rocType = null;\n        this.rocAUC = Number.NaN;\n        this.trainingSize = 0;\n        this.trainingActives = 0;\n        this.atomicSlopeA = Number.NaN;\n        this.atomicInterceptB = Number.NaN;\n        this.truthTP = 0;\n        this.truthFP = 0;\n        this.truthTN = 0;\n        this.truthFN = 0;\n        this.precision = Number.NaN;\n        this.recall = Number.NaN;\n        this.specificity = Number.NaN;\n        this.statF1 = Number.NaN;\n        this.statKappa = Number.NaN;\n        this.statMCC = Number.NaN;\n        this.noteTitle = null;\n        this.noteOrigin = null;\n        this.noteField = null;\n        this.noteComments = null;\n        if (this.folding == null)\n            this.folding = 0;\n    }\n    addMolecule(mol, active, hashes) {\n        if (_data_MolUtil__WEBPACK_IMPORTED_MODULE_1__.MolUtil.isBlank(mol) && hashes == null)\n            throw 'Molecule cannot be blank or null.';\n        if (hashes == null) {\n            let meta = _data_MetaMolecule__WEBPACK_IMPORTED_MODULE_0__.MetaMolecule.createStrictRubric(mol);\n            let circ = new _CircularFingerprints__WEBPACK_IMPORTED_MODULE_4__.CircularFingerprints(meta, this.classType);\n            circ.calculate();\n            hashes = this.folding == 0 ? circ.getUniqueHashes() : circ.getFoldedHashes(this.folding);\n        }\n        if (active)\n            this.numActive++;\n        this.training.push(hashes);\n        this.activity.push(active);\n        for (let h of hashes) {\n            let stash = this.inHash[h];\n            if (stash == null)\n                stash = [0, 0];\n            if (active)\n                stash[0]++;\n            stash[1]++;\n            this.inHash[h] = stash;\n        }\n    }\n    build() {\n        this.trainingSize = this.training.length;\n        this.trainingActives = this.numActive;\n        this.contribs = [];\n        const sz = this.training.length;\n        const invSz = 1.0 / sz;\n        const P_AT = this.numActive * invSz;\n        for (let hashStr in this.inHash) {\n            let hash = parseInt(hashStr);\n            const AT = this.inHash[hash];\n            const A = AT[0], T = AT[1];\n            const Pcorr = (A + 1) / (T * P_AT + 1);\n            const P = Math.log(Pcorr);\n            this.contribs[hash] = P;\n        }\n        this.lowThresh = Number.POSITIVE_INFINITY;\n        this.highThresh = Number.NEGATIVE_INFINITY;\n        for (let fp of this.training) {\n            let val = 0;\n            for (let hash of fp)\n                val += this.contribs[hash];\n            this.lowThresh = Math.min(this.lowThresh, val);\n            this.highThresh = Math.max(this.highThresh, val);\n        }\n        this.range = this.highThresh - this.lowThresh;\n        this.invRange = this.range > 0 ? 1 / this.range : 0;\n    }\n    predictMolecule(mol) {\n        if (_data_MolUtil__WEBPACK_IMPORTED_MODULE_1__.MolUtil.isBlank(mol))\n            throw 'Molecule cannot be blank or null.';\n        let meta = _data_MetaMolecule__WEBPACK_IMPORTED_MODULE_0__.MetaMolecule.createStrictRubric(mol);\n        let circ = new _CircularFingerprints__WEBPACK_IMPORTED_MODULE_4__.CircularFingerprints(meta, this.classType);\n        circ.calculate();\n        let hashes = this.folding == 0 ? circ.getUniqueHashes() : circ.getFoldedHashes(this.folding);\n        return this.predictFP(hashes);\n    }\n    predictFP(hashes) {\n        let val = 0;\n        for (let h of hashes) {\n            let c = this.contribs[h];\n            if (c != null)\n                val += c;\n        }\n        return val;\n    }\n    scalePredictor(pred) {\n        if (this.range == 0)\n            return pred >= this.highThresh ? 1 : 0;\n        return (pred - this.lowThresh) * this.invRange;\n    }\n    scaleArcTan(scaled) {\n        const INVPI = 1.0 / Math.PI;\n        return Math.atan(2 * scaled - 1) * INVPI + 0.5;\n    }\n    calculateOverlap(mol) {\n        if (_data_MolUtil__WEBPACK_IMPORTED_MODULE_1__.MolUtil.isBlank(mol))\n            throw 'Molecule cannot be blank or null.';\n        let meta = _data_MetaMolecule__WEBPACK_IMPORTED_MODULE_0__.MetaMolecule.createStrictRubric(mol);\n        let circ = new _CircularFingerprints__WEBPACK_IMPORTED_MODULE_4__.CircularFingerprints(meta, this.classType);\n        circ.calculate();\n        let hashes = this.folding == 0 ? circ.getUniqueHashes() : circ.getFoldedHashes(this.folding);\n        return this.calculateOverlapFP(hashes);\n    }\n    calculateOverlapFP(hashes) {\n        if (hashes.length == 0)\n            return 0;\n        let count = 0.0;\n        for (let h of hashes)\n            if (this.contribs[h] != null)\n                count++;\n        return hashes.length == 1 ? count : count / hashes.length;\n    }\n    calculateAtomPredictors(mol) {\n        const na = mol.numAtoms;\n        let atomic = _util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.numberArray(0, na);\n        let predHashes = new Set();\n        let cover = this.determineCoverage(mol, predHashes);\n        for (let h in cover) {\n            let c = this.contribs[h];\n            if (c == null)\n                continue;\n            let mask = cover[h];\n            let msz = _util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.maskCount(mask);\n            let invSz = 1.0 / msz;\n            for (let n = 0; n < na; n++)\n                if (mask[n])\n                    atomic[n] += c * invSz;\n        }\n        if (!isNaN(this.atomicSlopeA)) {\n            for (let n = 0; n < na; n++)\n                atomic[n] = (this.atomicSlopeA * atomic[n]) + this.atomicInterceptB;\n            return atomic;\n        }\n        let pred = 0;\n        for (let h of predHashes) {\n            let c = this.contribs[h];\n            if (c != null)\n                pred += c;\n        }\n        const SCALE_STDDEV_TO = 0.25;\n        const invN = 1.0 / na;\n        _util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.addTo(atomic, -_util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.sum(atomic) * invN);\n        let stdDev = 0;\n        for (let a of atomic)\n            stdDev += a * a;\n        stdDev = Math.sqrt(stdDev * invN);\n        if (stdDev > 1E-3)\n            _util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.mulBy(atomic, SCALE_STDDEV_TO / stdDev);\n        let scaled = (this.scalePredictor(pred) - 0.5) * 2;\n        if (scaled < -1)\n            scaled = -1;\n        else if (scaled > 1)\n            scaled = 1;\n        _util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.addTo(atomic, scaled);\n        return atomic;\n    }\n    validateLeaveOneOut() {\n        const sz = this.training.length;\n        this.estimates = [];\n        for (let n = 0; n < sz; n++)\n            this.estimates.push(this.singleLeaveOneOut(n));\n        this.calculateROC();\n        this.calculateTruth();\n        this.rocType = 'leave-one-out';\n    }\n    validateFiveFold() {\n        this.rocType = 'five-fold';\n        this.validateNfold(5);\n    }\n    validateThreeFold() {\n        this.rocType = 'three-fold';\n        this.validateNfold(3);\n    }\n    clearTraining() {\n        this.training = [];\n        this.activity = [];\n    }\n    serialise() {\n        let lines = [];\n        let fpname = this.classType == _CircularFingerprints__WEBPACK_IMPORTED_MODULE_4__.CircularFingerprints.CLASS_ECFP0 ? 'ECFP0' : this.classType == _CircularFingerprints__WEBPACK_IMPORTED_MODULE_4__.CircularFingerprints.CLASS_ECFP2 ? 'ECFP2'\n            : this.classType == _CircularFingerprints__WEBPACK_IMPORTED_MODULE_4__.CircularFingerprints.CLASS_ECFP4 ? 'ECFP4' : this.classType == _CircularFingerprints__WEBPACK_IMPORTED_MODULE_4__.CircularFingerprints.CLASS_ECFP6 ? 'ECFP6'\n                : '?';\n        lines.push('Bayesian!(' + fpname + ',' + this.folding + ',' + this.lowThresh + ',' + this.highThresh + ')');\n        let sorted = [];\n        for (let hash in this.contribs)\n            sorted.push(parseInt(hash));\n        _util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.sort(sorted);\n        for (let hash of sorted) {\n            const c = this.contribs[hash];\n            lines.push(hash + '=' + c);\n        }\n        lines.push('training:size=' + this.trainingSize);\n        lines.push('training:actives=' + this.trainingActives);\n        if (!Number.isNaN(this.rocAUC))\n            lines.push('roc:auc=' + this.rocAUC);\n        if (this.rocType != null)\n            lines.push('roc:type=' + this.rocType);\n        if (this.rocX != null && this.rocY != null) {\n            let x = 'roc:x=';\n            for (let n = 0; n < this.rocX.length; n++)\n                x += (n == 0 ? '' : ',') + this.rocX[n];\n            lines.push(x);\n            let y = 'roc:y=';\n            for (let n = 0; n < this.rocY.length; n++)\n                y += (n == 0 ? '' : ',') + this.rocY[n];\n            lines.push(y);\n        }\n        if (this.truthTP > 0 || this.truthFP > 0 || this.truthTN > 0 || this.truthFP > 0) {\n            lines.push('truth:TP=' + this.truthTP);\n            lines.push('truth:FP=' + this.truthFP);\n            lines.push('truth:TN=' + this.truthTN);\n            lines.push('truth:FN=' + this.truthFN);\n            lines.push('truth:precision=' + this.precision);\n            lines.push('truth:recall=' + this.recall);\n            lines.push('truth:specificity=' + this.specificity);\n            lines.push('truth:F1=' + this.statF1);\n            lines.push('truth:kappa=' + this.statKappa);\n            lines.push('truth:MCC=' + this.statMCC);\n        }\n        if (!isNaN(this.atomicSlopeA) && !isNaN(this.atomicInterceptB)) {\n            lines.push('atomic:slope=' + this.atomicSlopeA);\n            lines.push('atomic:intercept=' + this.atomicInterceptB);\n        }\n        if (this.noteTitle)\n            lines.push('note:title=' + this.noteTitle);\n        if (this.noteOrigin)\n            lines.push('note:origin=' + this.noteOrigin);\n        if (this.noteField)\n            lines.push('note:field=' + this.noteField);\n        if (this.noteComments)\n            for (let comment of this.noteComments)\n                lines.push('note:comment=' + comment);\n        lines.push('!End');\n        return lines.join('\\n');\n    }\n    static deserialise(str) {\n        let lines = str.split('\\n'), lnum = 0;\n        function readLine() { return lnum >= lines.length ? null : lines[lnum++].trim(); }\n        let line = readLine();\n        if (line == null || !line.startsWith('Bayesian!(') || !line.endsWith(')'))\n            throw 'Not a serialised Bayesian model.';\n        let bits = line.substring(10, line.length - 1).split(',');\n        if (bits.length < 4)\n            throw 'Invalid header content';\n        let classType = bits[0] == 'ECFP0' ? _CircularFingerprints__WEBPACK_IMPORTED_MODULE_4__.CircularFingerprints.CLASS_ECFP0 : bits[0] == 'ECFP2' ? _CircularFingerprints__WEBPACK_IMPORTED_MODULE_4__.CircularFingerprints.CLASS_ECFP2\n            : bits[0] == 'ECFP4' ? _CircularFingerprints__WEBPACK_IMPORTED_MODULE_4__.CircularFingerprints.CLASS_ECFP4 : bits[0] == 'ECFP6' ? _CircularFingerprints__WEBPACK_IMPORTED_MODULE_4__.CircularFingerprints.CLASS_ECFP6\n                : 0;\n        if (classType == 0)\n            throw 'Unknown fingerprint type: ' + bits[0];\n        let folding = parseInt(bits[1]);\n        if (folding > 0)\n            for (let f = folding; f > 0; f = f >> 1) {\n                if ((f & 1) == 1 && f != 1) {\n                    folding = -1;\n                    break;\n                }\n            }\n        if (folding < 0)\n            throw 'Fingerprint folding ' + bits[1] + ' invalid: must be 0 or power of 2.';\n        let model = new BayesianModel(classType, folding);\n        model.lowThresh = parseFloat(bits[2]);\n        model.highThresh = parseFloat(bits[3]);\n        model.range = model.highThresh - model.lowThresh;\n        model.invRange = model.range > 0 ? 1 / model.range : 0;\n        const PTN_HASHLINE = new RegExp('^(-?\\\\d+)=([\\\\d\\\\.Ee-]+)');\n        while (true) {\n            line = readLine();\n            if (line == null)\n                throw 'Missing correct terminator line.';\n            if (line == '!End')\n                break;\n            let match = PTN_HASHLINE.exec(line);\n            if (match != null) {\n                let hash = parseInt(match[1]);\n                let c = parseFloat(match[2]);\n                model.contribs[hash] = c;\n            }\n            else if (line.startsWith('training:size='))\n                model.trainingSize = parseInt(line.substring(14));\n            else if (line.startsWith('training:actives='))\n                model.trainingActives = parseInt(line.substring(17));\n            else if (line.startsWith('roc:auc='))\n                model.rocAUC = parseFloat(line.substring(8));\n            else if (line.startsWith('roc:type='))\n                model.rocType = line.substring(9);\n            else if (line.startsWith('roc:x=')) {\n                model.rocX = [];\n                for (let s of line.substring(6).split(','))\n                    model.rocX.push(parseFloat(s));\n            }\n            else if (line.startsWith('roc:y=')) {\n                model.rocY = [];\n                for (let s of line.substring(6).split(','))\n                    model.rocY.push(parseFloat(s));\n            }\n            else if (line.startsWith('truth:TP='))\n                model.truthTP = parseInt(line.substring(9), 0);\n            else if (line.startsWith('truth:FP='))\n                model.truthFP = parseInt(line.substring(9), 0);\n            else if (line.startsWith('truth:TN='))\n                model.truthTN = parseInt(line.substring(9), 0);\n            else if (line.startsWith('truth:FN='))\n                model.truthFN = parseInt(line.substring(9), 0);\n            else if (line.startsWith('truth:precision='))\n                model.precision = parseFloat(line.substring(16));\n            else if (line.startsWith('truth:recall='))\n                model.recall = parseFloat(line.substring(13));\n            else if (line.startsWith('truth:specificity='))\n                model.specificity = parseFloat(line.substring(18));\n            else if (line.startsWith('truth:F1='))\n                model.statF1 = parseFloat(line.substring(9));\n            else if (line.startsWith('truth:kappa='))\n                model.statKappa = parseFloat(line.substring(12));\n            else if (line.startsWith('truth:MCC='))\n                model.statMCC = parseFloat(line.substring(10));\n            else if (line.startsWith('atomic:slope='))\n                model.atomicSlopeA = parseFloat(line.substring(13));\n            else if (line.startsWith('atomic:intercept='))\n                model.atomicInterceptB = parseFloat(line.substring(17));\n            else if (line.startsWith('note:title='))\n                model.noteTitle = line.substring(11);\n            else if (line.startsWith('note:origin='))\n                model.noteOrigin = line.substring(12);\n            else if (line.startsWith('note:field='))\n                model.noteField = line.substring(11);\n            else if (line.startsWith('note:comment=')) {\n                if (model.noteComments == null)\n                    model.noteComments = [];\n                model.noteComments.push(line.substring(13));\n            }\n        }\n        return model;\n    }\n    singleLeaveOneOut(idx) {\n        let exclActive = this.activity[idx];\n        let exclSet = new Set();\n        for (let fp of this.training[idx])\n            exclSet.add(fp);\n        const sz = this.training.length, szN = sz - 1;\n        const invSzN = 1.0 / szN;\n        const activeN = exclActive ? this.numActive - 1 : this.numActive;\n        const P_AT = activeN * invSzN;\n        let val = 0;\n        for (let hashStr in this.inHash) {\n            const hash = parseInt(hashStr);\n            if (!exclSet.has(hash))\n                continue;\n            const AT = this.inHash[hash];\n            const A = AT[0] - (exclActive ? 1 : 0), T = AT[1] - 1;\n            const Pcorr = (A + 1) / (T * P_AT + 1);\n            const P = Math.log(Pcorr);\n            val += P;\n        }\n        return val;\n    }\n    validateNfold(nsegs) {\n        const sz = this.training.length;\n        let order = _util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.numberArray(0, sz);\n        let p = 0;\n        for (let n = 0; n < sz; n++)\n            if (this.activity[n])\n                order[p++] = n;\n        for (let n = 0; n < sz; n++)\n            if (!this.activity[n])\n                order[p++] = n;\n        let segContribs = [];\n        for (let n = 0; n < nsegs; n++)\n            segContribs.push(this.buildPartial(order, n, nsegs));\n        this.estimates = _util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.numberArray(0, sz);\n        for (let n = 0; n < sz; n++)\n            this.estimates[order[n]] = this.estimatePartial(order, n, segContribs[n % nsegs]);\n        this.calculateROC();\n        this.calculateTruth();\n    }\n    buildPartial(order, seg, div) {\n        const sz = this.training.length;\n        let na = 0, nt = 0;\n        let ih = {};\n        for (let n = 0; n < sz; n++) {\n            if (n % div != seg) {\n                const active = this.activity[order[n]];\n                if (active)\n                    na++;\n                nt++;\n                for (let h of this.training[order[n]]) {\n                    let stash = ih[h];\n                    if (stash == null)\n                        stash = [0, 0];\n                    if (active)\n                        stash[0]++;\n                    stash[1]++;\n                    ih[h] = stash;\n                }\n            }\n        }\n        let segContribs = {};\n        const invSz = 1.0 / nt;\n        const P_AT = na * invSz;\n        for (let hashStr in ih) {\n            let hash = parseInt(hashStr);\n            const AT = ih[hash];\n            const A = AT[0], T = AT[1];\n            const Pcorr = (A + 1) / (T * P_AT + 1);\n            const P = Math.log(Pcorr);\n            segContribs[hash] = P;\n        }\n        return segContribs;\n    }\n    estimatePartial(order, idx, segContrib) {\n        let val = 0;\n        for (let h of this.training[order[idx]]) {\n            let c = segContrib[h];\n            if (c != null)\n                val += c;\n        }\n        return val;\n    }\n    calculateROC() {\n        const sz = this.training.length;\n        let idx = _util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.idxSort(this.estimates);\n        let thresholds = [];\n        thresholds.push(this.lowThresh - 0.01 * this.range);\n        for (let n = 0; n < sz - 1; n++) {\n            const th1 = this.estimates[idx[n]], th2 = this.estimates[idx[n + 1]];\n            if (th1 == th2)\n                continue;\n            thresholds.push(0.5 * (th1 + th2));\n        }\n        thresholds.push(this.highThresh + 0.01 * this.range);\n        this.rocX = [];\n        this.rocY = [];\n        let rocT = [];\n        let posTrue = 0, posFalse = 0, ipos = 0;\n        let invPos = 1.0 / this.numActive, invNeg = 1.0 / (sz - this.numActive);\n        for (let n = 0; n < thresholds.length; n++) {\n            const th = thresholds[n];\n            for (; ipos < sz; ipos++) {\n                if (th < this.estimates[idx[ipos]])\n                    break;\n                if (this.activity[idx[ipos]])\n                    posTrue++;\n                else\n                    posFalse++;\n            }\n            const x = posFalse * invNeg;\n            const y = posTrue * invPos;\n            const rsz = rocT.length;\n            if (rsz > 0 && x == this.rocX[rsz - 1] && y == this.rocY[rsz - 1])\n                continue;\n            this.rocX[rsz] = 1 - x;\n            this.rocY[rsz] = 1 - y;\n            rocT[rsz] = th;\n        }\n        this.rocX = _util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.reverse(this.rocX);\n        this.rocY = _util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.reverse(this.rocY);\n        rocT = _util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.reverse(rocT);\n        this.calibrateThresholds(this.rocX, this.rocY, rocT);\n        this.rocAUC = 0;\n        for (let n = 0; n < rocT.length - 1; n++) {\n            const w = this.rocX[n + 1] - this.rocX[n], h = 0.5 * (this.rocY[n] + this.rocY[n + 1]);\n            this.rocAUC += w * h;\n        }\n        const DIST = 0.002, DSQ = DIST * DIST;\n        let gx = [], gy = [];\n        gx.push(this.rocX[0]);\n        gy.push(this.rocY[0]);\n        for (let i = 1; i < rocT.length - 1; i++) {\n            const dx = this.rocX[i] - gx[gx.length - 1], dy = this.rocY[i] - gy[gy.length - 1];\n            if ((0,_util_util__WEBPACK_IMPORTED_MODULE_2__.norm2_xy)(dx, dy) < DSQ)\n                continue;\n            gx.push(this.rocX[i]);\n            gy.push(this.rocY[i]);\n        }\n        gx.push(this.rocX[rocT.length - 1]);\n        gy.push(this.rocY[rocT.length - 1]);\n    }\n    calculateTruth() {\n        let thresh = 0.5 * (this.lowThresh + this.highThresh);\n        this.truthTP = this.truthFP = this.truthTN = this.truthFN = 0;\n        for (let n = 0; n < this.activity.length; n++) {\n            let actual = this.activity[n], predicted = this.estimates[n] >= thresh;\n            if (actual && predicted)\n                this.truthTP++;\n            else if (!actual && predicted)\n                this.truthFP++;\n            else if (actual && !predicted)\n                this.truthFN++;\n            else if (!actual && !predicted)\n                this.truthTN++;\n        }\n        const TP = this.truthTP, FP = this.truthFP, TN = this.truthTN, FN = this.truthFN;\n        let invSize = 1.0 / this.activity.length;\n        this.precision = TP / (TP + FP);\n        this.recall = TP / (TP + FN);\n        this.specificity = TN / (TN + FP);\n        this.statF1 = 2 * (this.precision * this.recall) / (this.precision + this.recall);\n        let Pyes = (TP + FP) * invSize * (TP + FN) * invSize;\n        let Pno = (FP + TN) * invSize * (FN + TN) * invSize;\n        let P0 = (TP + TN) * invSize, Pe = Pyes + Pno;\n        this.statKappa = (P0 - Pe) / (1 - Pe);\n        let mccOver = TP * TN - FP * FN;\n        let mccUnder = (TP + FP) * (TP + FN) * (TN + FP) * (TN + FN);\n        this.statMCC = mccOver / Math.sqrt(mccUnder);\n    }\n    calibrateThresholds(x, y, t) {\n        const sz = t.length;\n        let idx = 0;\n        for (let n = 1; n < sz; n++)\n            if (y[n] - x[n] > y[idx] - x[idx])\n                idx = n;\n        const midThresh = t[idx];\n        let idxX = 0, idxY = sz - 1;\n        for (; idxX < idx - 1; idxX++)\n            if (x[idxX] > 0)\n                break;\n        for (; idxY > idx + 1; idxY--)\n            if (y[idxY] < 1)\n                break;\n        let delta = Math.min(t[idxX] - midThresh, midThresh - t[idxY]);\n        this.lowThresh = midThresh - delta;\n        this.highThresh = midThresh + delta;\n        this.range = 2 * delta;\n        this.invRange = this.range > 0 ? 1 / this.range : 0;\n    }\n    determineCoverage(mol, approvedHashes) {\n        const na = mol.numAtoms;\n        let cover = {};\n        const andBits = this.folding == 0 ? 0xFFFFFFFF : this.folding - 1;\n        let meta = _data_MetaMolecule__WEBPACK_IMPORTED_MODULE_0__.MetaMolecule.createStrictRubric(mol);\n        let circ = new _CircularFingerprints__WEBPACK_IMPORTED_MODULE_4__.CircularFingerprints(meta, this.classType);\n        let collectFP = (fp) => {\n            let idx = fp.hashCode & andBits;\n            if (this.contribs[idx] == null)\n                return;\n            let mask = cover[idx];\n            if (mask == null) {\n                mask = _util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.booleanArray(false, na);\n                cover[idx] = mask;\n            }\n            for (let a of fp.atoms)\n                mask[a - 1] = true;\n        };\n        circ.hookApplyNewFP = collectFP;\n        circ.hookConsiderNewFP = collectFP;\n        circ.calculate();\n        if (approvedHashes != null) {\n            let hashes = this.folding == 0 ? circ.getUniqueHashes() : circ.getFoldedHashes(this.folding);\n            for (let h of hashes)\n                approvedHashes.add(h);\n        }\n        return cover;\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/calc/BayesianModel.ts?");

/***/ }),

/***/ "./src/calc/BuildSMILES.ts":
/*!*********************************!*\
  !*** ./src/calc/BuildSMILES.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BuildSMILES\": () => (/* binding */ BuildSMILES)\n/* harmony export */ });\n/* harmony import */ var _data_Chemistry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/Chemistry */ \"./src/data/Chemistry.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n\n\nclass BuildSMILES {\n    constructor(mol, pri = null) {\n        this.mol = mol;\n        this.pri = pri;\n    }\n    generate() {\n        if (this.mol.numAtoms == 0)\n            return '';\n        this.walkSequence();\n        this.findLinks();\n        return this.assemble();\n    }\n    walkSequence() {\n        const mol = this.mol, na = mol.numAtoms, pri = this.pri;\n        this.seq = [];\n        let visited = _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.booleanArray(false, na);\n        let pos = 1;\n        if (pri != null)\n            pos = _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.idxMin(pri) + 1;\n        for (let count = 0; count < na; count++) {\n            this.seq.push(pos);\n            visited[pos - 1] = true;\n            if (count == na - 1)\n                break;\n            let adj = mol.atomAdjList(pos);\n            let cc = mol.atomConnComp(pos);\n            pos = 0;\n            for (let n = 0; n < adj.length; n++)\n                if (!visited[adj[n] - 1]) {\n                    if (pri == null) {\n                        pos = adj[n];\n                        break;\n                    }\n                    if (pos == 0 || pri[adj[n] - 1] < pri[pos - 1])\n                        pos = adj[n];\n                }\n            if (pos > 0)\n                continue;\n            for (let n = 1; n <= na; n++)\n                if (!visited[n - 1] && mol.atomConnComp(n) == cc) {\n                    if (pri == null) {\n                        pos = n;\n                        break;\n                    }\n                    if (pos == 0 || pri[n - 1] < pri[pos - 1])\n                        pos = n;\n                }\n            if (pos > 0)\n                continue;\n            for (let n = 1; n <= na; n++)\n                if (!visited[n - 1]) {\n                    if (pri == null) {\n                        pos = n;\n                        break;\n                    }\n                    if (pos == 0 || pri[n - 1] < pri[pos - 1])\n                        pos = n;\n                }\n            if (pos == 0)\n                throw 'Walk sequence failed.';\n        }\n    }\n    findLinks() {\n        const mol = this.mol, na = mol.numAtoms, pri = this.pri, seq = this.seq;\n        this.link = [];\n        this.conn = [];\n        for (let n = 0; n < na; n++) {\n            this.link.push([]);\n            this.conn.push([]);\n        }\n        let invseq = _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.numberArray(0, na);\n        for (let n = 0; n < na; n++)\n            invseq[seq[n] - 1] = n;\n        let inPlay = _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.numberArray(-1, na + 1);\n        for (let n = 0; n < na; n++) {\n            let prev = n > 0 ? seq[n - 1] : 0;\n            let cur = seq[n];\n            let next = n < na - 1 ? seq[n + 1] : 0;\n            for (let i = 1; i <= na; i++)\n                if (inPlay[i] >= 0 && n > inPlay[i])\n                    inPlay[i] = -1;\n            let adj = mol.atomAdjList(cur);\n            if (pri != null)\n                for (let p = 0; p < adj.length - 1;) {\n                    if (invseq[adj[p] - 1] > invseq[adj[p + 1] - 1]) {\n                        _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.swap(adj, p, p + 1);\n                        if (p > 0)\n                            p--;\n                    }\n                    else\n                        p++;\n                }\n            for (let i = 0; i < adj.length; i++) {\n                if (adj[i] == prev || adj[i] == next)\n                    continue;\n                let nbr = adj[i];\n                if (invseq[cur - 1] > invseq[nbr - 1])\n                    continue;\n                let num = -1;\n                for (let j = 1; j <= na; j++)\n                    if (inPlay[j] < 0) {\n                        num = j;\n                        inPlay[j] = Math.max(invseq[cur - 1], invseq[nbr - 1]);\n                        break;\n                    }\n                this.link[cur - 1].push(num);\n                this.conn[cur - 1].push(nbr);\n                this.link[nbr - 1].push(num);\n                this.conn[nbr - 1].push(cur);\n            }\n        }\n    }\n    assemble() {\n        const mol = this.mol, na = mol.numAtoms, seq = this.seq, link = this.link, conn = this.conn;\n        let smiles = '';\n        const NON_ESCAPED = ['C', 'N', 'O', 'P', 'S'];\n        for (let n = 0; n < na; n++) {\n            let prev = n > 0 ? seq[n - 1] : 0, cur = seq[n];\n            let bidx = prev > 0 ? mol.findBond(prev, cur) : 0;\n            if (prev > 0 && bidx == 0)\n                smiles += '.';\n            if (bidx > 0) {\n                let bo = mol.bondOrder(bidx);\n                if (bo == 2)\n                    smiles += '=';\n                else if (bo == 3)\n                    smiles += '#';\n            }\n            let el = mol.atomElement(cur);\n            if (_data_Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENTS.indexOf(el) < 0)\n                el = '*';\n            let chg = mol.atomCharge(cur);\n            if (NON_ESCAPED.indexOf(el) >= 0 && chg == 0) {\n                smiles += el;\n            }\n            else {\n                smiles += '[' + el;\n                if (chg > 0)\n                    smiles += '+' + chg;\n                if (chg < 0)\n                    smiles += chg;\n                smiles += ']';\n            }\n            let num = link[cur - 1];\n            if (num != null)\n                for (let i = 0; i < num.length; i++) {\n                    bidx = mol.findBond(cur, conn[cur - 1][i]);\n                    let bo = mol.bondOrder(bidx);\n                    if (bo == 2)\n                        smiles += '=';\n                    else if (bo == 3)\n                        smiles += '#';\n                    if (num[i] < 10)\n                        smiles += num[i];\n                    else\n                        smiles += '%' + num[i];\n                }\n        }\n        return smiles;\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/calc/BuildSMILES.ts?");

/***/ }),

/***/ "./src/calc/CircularFingerprints.ts":
/*!******************************************!*\
  !*** ./src/calc/CircularFingerprints.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CircularFingerprints\": () => (/* binding */ CircularFingerprints)\n/* harmony export */ });\n/* harmony import */ var _data_Chemistry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/Chemistry */ \"./src/data/Chemistry.ts\");\n/* harmony import */ var _data_MetaMolecule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/MetaMolecule */ \"./src/data/MetaMolecule.ts\");\n/* harmony import */ var _data_Molecule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data/Molecule */ \"./src/data/Molecule.ts\");\n/* harmony import */ var _data_MolUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../data/MolUtil */ \"./src/data/MolUtil.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n\n\n\n\n\nlet crc_table = [];\nfunction make_crc_table() {\n    if (crc_table.length > 0)\n        return;\n    for (let n = 0; n < 256; n++) {\n        let c = n;\n        for (let i = 0; i < 8; i++)\n            if ((c & 1) != 0)\n                c = 0xEDB88320 ^ (c >>> 1);\n            else\n                c = (c >>> 1);\n        crc_table.push(c);\n    }\n}\nconst BOOT_CRC = 0xFFFFFFFF;\nfunction start_crc() { return BOOT_CRC; }\nfunction feed_crc(crc, byte) {\n    let idx = (crc ^ byte) & 0xFF;\n    return crc_table[idx] ^ (crc >>> 8);\n}\nfunction end_crc(crc) { return crc ^ BOOT_CRC; }\nclass CircularFingerprints {\n    constructor(meta, kind) {\n        this.meta = meta;\n        this.kind = kind;\n        this.hookApplyNewFP = null;\n        this.hookConsiderNewFP = null;\n        this.identity = [];\n        this.resolvedChiral = [];\n        this.atomGroup = [];\n        this.fplist = [];\n        this.amask = [];\n        this.atomAdj = [];\n        this.bondAdj = [];\n        make_crc_table();\n    }\n    calculate() {\n        let mol = this.meta.mol, na = mol.numAtoms;\n        this.identity = _util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.numberArray(0, na);\n        this.resolvedChiral = _util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.booleanArray(false, na);\n        for (let n = 0; n < na; n++)\n            this.atomGroup.push([]);\n        this.amask = _util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.booleanArray(false, na);\n        for (let n = 0; n < na; n++) {\n            this.amask[n] = mol.atomicNumber(n + 1) >= 2 && !_data_MolUtil__WEBPACK_IMPORTED_MODULE_3__.MolUtil.hasAbbrev(mol, n + 1);\n            this.atomAdj.push([]);\n            this.bondAdj.push([]);\n        }\n        for (let n = 0; n < na; n++) {\n            if (!this.amask[n])\n                continue;\n            this.atomAdj[n] = mol.atomAdjList(n + 1);\n            this.bondAdj[n] = mol.atomAdjBonds(n + 1);\n            for (let i = this.atomAdj[n].length - 1; i >= 0; i--)\n                if (!this.amask[this.atomAdj[n][i] - 1]) {\n                    this.atomAdj[n].splice(i, 1);\n                    this.bondAdj[n].splice(i, 1);\n                }\n        }\n        for (let n = 0; n < na; n++)\n            if (this.amask[n]) {\n                this.identity[n] = this.initialIdentityECFP(n + 1);\n                this.atomGroup[n] = [n + 1];\n                this.applyNewFP({ 'hashCode': this.identity[n], 'iteration': 0, 'atoms': this.atomGroup[n], 'centralAtom': n + 1 });\n            }\n        let niter = this.kind;\n        for (let iter = 1; iter <= niter; iter++) {\n            let newident = _util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.numberArray(0, na);\n            for (let n = 0; n < na; n++)\n                if (this.amask[n])\n                    newident[n] = this.circularIterate(iter, n + 1);\n            this.identity = newident;\n            for (let n = 0; n < na; n++)\n                if (this.amask[n]) {\n                    this.atomGroup[n] = this.growAtoms(this.atomGroup[n]);\n                    this.considerNewFP({ 'hashCode': this.identity[n], 'iteration': iter, 'atoms': this.atomGroup[n], 'centralAtom': n + 1 });\n                }\n        }\n    }\n    static create(meta, kind) {\n        if (meta instanceof _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule)\n            meta = _data_MetaMolecule__WEBPACK_IMPORTED_MODULE_1__.MetaMolecule.createStrictRubric(meta);\n        let circ = new CircularFingerprints(meta, kind);\n        circ.calculate();\n        return circ;\n    }\n    getMolecule() { return this.meta.mol; }\n    get numFP() { return this.fplist.length; }\n    getFP(idx) { return this.fplist[idx]; }\n    getFingerprints() { return this.fplist.slice(0); }\n    getUniqueHashes() {\n        let hashes = new Set();\n        for (let fp of this.fplist)\n            hashes.add(fp.hashCode);\n        return _util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.sorted(Array.from(hashes));\n    }\n    getFoldedHashes(maxBits) {\n        let andBits = maxBits - 1;\n        let hashes = new Set();\n        for (let fp of this.fplist)\n            hashes.add(fp.hashCode & andBits);\n        return _util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.sorted(Array.from(hashes));\n    }\n    static tanimoto(hash1, hash2) {\n        let shared = 0, total = 0;\n        let sz1 = hash1.length, sz2 = hash2.length;\n        if (sz1 == 0 && sz2 == 0)\n            return 0;\n        let i1 = 0, i2 = 0;\n        while (i1 < sz1 || i2 < sz2) {\n            if (i1 == sz1) {\n                total += sz2 - i2;\n                break;\n            }\n            if (i2 == sz2) {\n                total += sz1 - i1;\n                break;\n            }\n            let v1 = hash1[i1], v2 = hash2[i2];\n            if (v1 == v2) {\n                shared += 1;\n                i1 += 1;\n                i2 += 1;\n            }\n            else if (v1 < v2)\n                i1 += 1;\n            else\n                i2 += 1;\n            total += 1;\n        }\n        return shared / total;\n    }\n    initialIdentityECFP(atom) {\n        const mol = this.meta.mol;\n        let adj = mol.atomAdjList(atom);\n        let nheavy = 0, nhydr = mol.atomHydrogens(atom);\n        for (let a of adj)\n            if (mol.atomElement(a) == 'H')\n                nhydr++;\n            else\n                nheavy++;\n        let atno = mol.atomicNumber(atom);\n        let degree = Math.max(0, _data_Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_BONDING[atno] - nhydr);\n        let chg = mol.atomCharge(atom);\n        let inring = mol.atomRingBlock(atom) > 0 ? 1 : 0;\n        let crc = start_crc();\n        crc = feed_crc(crc, (nheavy << 4) | degree);\n        crc = feed_crc(crc, atno);\n        crc = feed_crc(crc, chg + 0x80);\n        crc = feed_crc(crc, (nhydr << 4) | inring);\n        return end_crc(crc);\n    }\n    circularIterate(iter, atom) {\n        let adj = this.atomAdj[atom - 1], adjb = this.bondAdj[atom - 1];\n        let seq = _util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.numberArray(0, 2 + 2 * adj.length);\n        seq[0] = iter;\n        seq[1] = this.identity[atom - 1];\n        for (let n = 0; n < adj.length; n++) {\n            seq[2 * n + 2] = this.meta.isBondAromatic(adjb[n]) ? 0xF : this.meta.mol.bondOrder(adjb[n]);\n            seq[2 * n + 3] = this.identity[adj[n] - 1];\n        }\n        let p = 0;\n        while (p < adj.length - 1) {\n            let i = 2 + 2 * p;\n            if (seq[i] > seq[i + 2] || (seq[i] == seq[i + 2] && seq[i + 1] > seq[i + 3])) {\n                _util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.swap(seq, i, i + 2);\n                _util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.swap(seq, i + 1, i + 3);\n                if (p > 0)\n                    p--;\n            }\n            else\n                p++;\n        }\n        let crc = start_crc();\n        for (let n = 0; n < seq.length; n += 2) {\n            crc = feed_crc(crc, seq[n]);\n            let v = seq[n + 1];\n            crc = feed_crc(crc, v >> 24);\n            crc = feed_crc(crc, (v >> 16) & 0xFF);\n            crc = feed_crc(crc, (v >> 8) & 0xFF);\n            crc = feed_crc(crc, v & 0xFF);\n        }\n        if (!this.resolvedChiral[atom - 1] && _util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.len(this.meta.rubricTetra) > 0 && this.meta.rubricTetra[atom - 1] != null) {\n            let ru = this.meta.rubricTetra[atom - 1];\n            let par = [\n                ru[0] == 0 ? 0 : this.identity[ru[0] - 1],\n                ru[1] == 0 ? 0 : this.identity[ru[1] - 1],\n                ru[2] == 0 ? 0 : this.identity[ru[2] - 1],\n                ru[3] == 0 ? 0 : this.identity[ru[3] - 1]\n            ];\n            if (par[0] != par[1] && par[0] != par[2] && par[0] != par[3] && par[1] != par[2] && par[1] != par[3] && par[2] != par[3]) {\n                crc = feed_crc(crc, _util_Vec__WEBPACK_IMPORTED_MODULE_4__.Permutation.parityOrder(par) + 1);\n                this.resolvedChiral[atom - 1] = true;\n            }\n        }\n        return end_crc(crc);\n    }\n    growAtoms(atoms) {\n        let mask = _util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.booleanArray(false, this.meta.mol.numAtoms);\n        for (let n = 0; n < atoms.length; n++) {\n            mask[atoms[n] - 1] = true;\n            for (let a of this.atomAdj[atoms[n] - 1])\n                mask[a - 1] = true;\n        }\n        return _util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.add(_util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.maskIdx(mask), 1);\n    }\n    applyNewFP(newFP) {\n        if (this.hookConsiderNewFP)\n            this.hookConsiderNewFP(newFP);\n        if (this.hookApplyNewFP)\n            this.hookApplyNewFP(newFP);\n        this.fplist.push(newFP);\n    }\n    considerNewFP(newFP) {\n        if (this.hookConsiderNewFP)\n            this.hookConsiderNewFP(newFP);\n        let hit = -1;\n        let fp = null;\n        for (let n = 0; n < this.fplist.length; n++) {\n            let lookFP = this.fplist[n];\n            if (_util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.equals(lookFP.atoms, newFP.atoms)) {\n                fp = lookFP;\n                hit = n;\n                break;\n            }\n        }\n        if (hit < 0) {\n            this.fplist.push(newFP);\n            return;\n        }\n        if (fp.iteration < newFP.iteration || fp.hashCode < newFP.hashCode)\n            return;\n        this.fplist[hit] = newFP;\n        if (this.hookApplyNewFP)\n            this.hookApplyNewFP(newFP);\n    }\n}\nCircularFingerprints.CLASS_ECFP0 = 0;\nCircularFingerprints.CLASS_ECFP2 = 1;\nCircularFingerprints.CLASS_ECFP4 = 2;\nCircularFingerprints.CLASS_ECFP6 = 3;\n\n\n//# sourceURL=webpack://WebMolKit/./src/calc/CircularFingerprints.ts?");

/***/ }),

/***/ "./src/calc/ResonanceRemover.ts":
/*!**************************************!*\
  !*** ./src/calc/ResonanceRemover.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ResonanceRemover\": () => (/* binding */ ResonanceRemover)\n/* harmony export */ });\n/* harmony import */ var _data_Chemistry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/Chemistry */ \"./src/data/Chemistry.ts\");\n/* harmony import */ var _data_Graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/Graph */ \"./src/data/Graph.ts\");\n/* harmony import */ var _data_Molecule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data/Molecule */ \"./src/data/Molecule.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n\n\n\n\nclass ResonanceRemover {\n    constructor(mol, resBonds, atomHyd = []) {\n        this.mol = mol;\n        this.resBonds = resBonds;\n        this.atomHyd = atomHyd;\n        this.maxIter = 1000;\n        this.bondOrders = [];\n        this.tolerant = false;\n        this.mol = mol;\n        this.resBonds = resBonds;\n        this.atomHyd = atomHyd;\n        for (let n = 1; n <= mol.numBonds; n++)\n            this.bondOrders.push(mol.bondOrder(n));\n    }\n    perform() {\n        const { mol } = this;\n        if (this.atomHyd == null) {\n            this.atomHyd = [];\n            for (let n = 1; n <= mol.numAtoms; n++)\n                this.atomHyd.push(mol.atomHExplicit(n));\n        }\n        this.correctInputMask();\n        let g = new _data_Graph__WEBPACK_IMPORTED_MODULE_1__.Graph(mol.numAtoms);\n        for (let n = 1; n <= mol.numBonds; n++)\n            if (this.resBonds[n - 1])\n                g.addEdge(mol.bondFrom(n) - 1, mol.bondTo(n) - 1);\n        let cc = g.calculateComponentGroups();\n        for (let n = 0; n < cc.length; n++)\n            if (cc[n].length >= 2)\n                this.processComponent(cc[n]);\n    }\n    correctInputMask() {\n        const { mol, atomHyd } = this;\n        const na = mol.numAtoms, nb = mol.numBonds;\n        let exclude = _util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.booleanArray(false, na);\n        for (let n = 1; n <= na; n++) {\n            let atno = mol.atomicNumber(n);\n            let val = atno == _data_Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_C ? 4 :\n                atno == _data_Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_N || atno == _data_Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_P || atno == _data_Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_B ? 3 :\n                    atno == _data_Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_O || atno == _data_Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_S ? 2 : -1;\n            if (val < 0) {\n                exclude[n - 1] = true;\n                continue;\n            }\n            val += mol.atomCharge(n);\n            if (atomHyd[n - 1] > 0)\n                val -= atomHyd[n - 1];\n            if (mol.atomAdjCount(n) >= val)\n                exclude[n - 1] = true;\n        }\n        for (let n = 1; n <= nb; n++)\n            if (!this.resBonds[n - 1] && mol.bondOrder(n) != 1) {\n                exclude[mol.bondFrom(n) - 1] = true;\n                exclude[mol.bondTo(n) - 1] = true;\n            }\n        this.resBonds = this.resBonds.slice(0);\n        for (let n = 0; n < nb; n++)\n            if (this.resBonds[n] && (exclude[mol.bondFrom(n + 1) - 1] || exclude[mol.bondTo(n + 1) - 1])) {\n                this.bondOrders[n] = 1;\n                this.resBonds[n] = false;\n            }\n    }\n    processComponent(nodes) {\n        const { mol, resBonds, bondOrders, atomHyd } = this;\n        let sz = nodes.length;\n        if (sz == 2) {\n            let b = mol.findBond(nodes[0] + 1, nodes[1] + 1);\n            bondOrders[b - 1] = 2;\n            return;\n        }\n        let optionalH = _util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.booleanArray(false, sz);\n        for (let n = 0; n < sz; n++) {\n            let i = nodes[n], a = i + 1;\n            optionalH[n] = atomHyd[i] == _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.HEXPLICIT_UNKNOWN && mol.atomElement(a) == 'N' && mol.atomAdjCount(a) - mol.atomCharge(a) <= 2;\n        }\n        let g = new _data_Graph__WEBPACK_IMPORTED_MODULE_1__.Graph(sz);\n        let gravity = g.calculateGravity();\n        let mask = _util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.idxMask(nodes, mol.numAtoms);\n        let bsz = 0;\n        for (let n = 1; n <= mol.numBonds; n++)\n            if (resBonds[n - 1] && mask[mol.bondFrom(n) - 1] && mask[mol.bondTo(n) - 1])\n                bsz++;\n        let bfr = _util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.numberArray(0, bsz), bto = _util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.numberArray(0, bsz), bgrav = _util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.numberArray(0, bsz), bidx = _util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.numberArray(0, bsz);\n        bsz = 0;\n        for (let n = 1; n <= mol.numBonds; n++)\n            if (resBonds[n - 1] && mask[mol.bondFrom(n) - 1] && mask[mol.bondTo(n) - 1]) {\n                let f = nodes.indexOf(mol.bondFrom(n) - 1), t = nodes.indexOf(mol.bondTo(n) - 1);\n                bfr[bsz] = f;\n                bto[bsz] = t;\n                bgrav[bsz] = gravity[f] + gravity[t];\n                bidx[bsz] = n;\n                g.addEdge(f, t);\n                bsz++;\n            }\n        let seq = _util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.numberArray(0, bsz);\n        seq[0] = _util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.idxMax(bgrav);\n        let visited = _util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.booleanArray(false, bsz);\n        visited[seq[0]] = true;\n        for (let i = 1; i < bsz; i++) {\n            let b = -1;\n            for (let j = i - 1; j >= 0; j--) {\n                for (let n = 0; n < bsz; n++) {\n                    if (!visited[n])\n                        if (bfr[n] == bfr[seq[j]] || bfr[n] == bto[seq[j]] || bto[n] == bfr[seq[j]] || bto[n] == bto[seq[j]]) {\n                            if (b < 0 || bgrav[n] > bgrav[b])\n                                b = n;\n                        }\n                }\n                if (b >= 0)\n                    break;\n            }\n            if (b < 0)\n                throw 'Graph walk failed';\n            seq[i] = b;\n            visited[b] = true;\n        }\n        let paths = [];\n        paths.push([true]);\n        paths.push([false]);\n        let result = null;\n        let resultCount = 0;\n        let definiteMatch = Math.ceil(0.5 * bsz);\n        let iter = 0;\n        while (paths.length > 0) {\n            let p = paths[0];\n            let p1 = _util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.append(p, false), p2 = _util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.append(p, true);\n            if (!this.validPath(p1, seq, bfr, bto, g, optionalH))\n                p1 = null;\n            if (!this.validPath(p2, seq, bfr, bto, g, optionalH))\n                p2 = null;\n            if (_util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.len(p1) == bsz) {\n                let c = _util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.maskCount(p1);\n                if (c > resultCount) {\n                    result = p1;\n                    resultCount = c;\n                }\n                p1 = null;\n            }\n            if (_util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.len(p2) == bsz) {\n                let c = _util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.maskCount(p2);\n                if (c > resultCount) {\n                    result = p2;\n                    resultCount = c;\n                }\n                p2 = null;\n            }\n            if (resultCount >= definiteMatch)\n                break;\n            if (p1 == null && p2 == null)\n                paths.shift();\n            else if (p1 != null && p2 != null) {\n                paths[0] = p1;\n                paths.splice(1, 0, p2);\n            }\n            else if (p1 != null)\n                paths[0] = p1;\n            else\n                paths[0] = p2;\n            iter++;\n            if (iter > this.maxIter) {\n                if (result != null)\n                    break;\n                if (this.tolerant)\n                    return;\n                throw 'Resonance localisation exceeded maximum iteration count';\n            }\n        }\n        if (result == null) {\n            if (this.tolerant)\n                return;\n            throw 'Unable to find a solution to the resonance block.';\n        }\n        for (let n = 0; n < bsz; n++)\n            bondOrders[bidx[seq[n]] - 1] = result[n] ? 2 : 1;\n    }\n    validPath(path, seq, bfr, bto, g, optionalH) {\n        let sz = g.numNodes;\n        let count1 = _util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.numberArray(0, sz), count2 = _util_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.numberArray(0, sz);\n        for (let n = 0; n < path.length; n++) {\n            let a1 = bfr[seq[n]], a2 = bto[seq[n]];\n            if (path[n]) {\n                count2[a1]++;\n                count2[a2]++;\n            }\n            else {\n                count1[a1]++;\n                count1[a2]++;\n            }\n        }\n        for (let n = 0; n < sz; n++) {\n            if (count2[n] > 1)\n                return false;\n            if (!optionalH[n] && g.numEdges(n) > 1 && count1[n] == g.numEdges(n))\n                return false;\n        }\n        return true;\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/calc/ResonanceRemover.ts?");

/***/ }),

/***/ "./src/data/AbbrevContainer.ts":
/*!*************************************!*\
  !*** ./src/data/AbbrevContainer.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AbbrevContainer\": () => (/* binding */ AbbrevContainer),\n/* harmony export */   \"TEMPLATE_FILES\": () => (/* binding */ TEMPLATE_FILES)\n/* harmony export */ });\n/* harmony import */ var _util_Theme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Theme */ \"./src/util/Theme.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _CoordUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CoordUtil */ \"./src/data/CoordUtil.ts\");\n/* harmony import */ var _DataSheetStream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DataSheetStream */ \"./src/data/DataSheetStream.ts\");\n/* harmony import */ var _MolUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MolUtil */ \"./src/data/MolUtil.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\nconst TEMPLATE_FILES = [\n    'rings',\n    'termgrp',\n    'funcgrp',\n    'protgrp',\n    'nonplrings',\n    'largerings',\n    'crownethers',\n    'ligmonodent',\n    'ligbident',\n    'ligtrident',\n    'ligmultident',\n    'cagecmplx',\n    'aminoacids',\n    'biomolecules',\n    'saccharides'\n];\nclass AbbrevContainer {\n    constructor() {\n        this.abbrevs = [];\n    }\n    static needsSetup() { return !this.main; }\n    static setupData() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.main)\n                return;\n            if (!_util_Theme__WEBPACK_IMPORTED_MODULE_0__.Theme.RESOURCE_URL)\n                throw ('RPC resource URL not defined.');\n            this.main = new AbbrevContainer();\n            for (let tfn of TEMPLATE_FILES) {\n                let url = _util_Theme__WEBPACK_IMPORTED_MODULE_0__.Theme.RESOURCE_URL + '/data/templates/' + tfn + '.ds';\n                let dsstr = yield (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.readTextURL)(url);\n                let ds = _DataSheetStream__WEBPACK_IMPORTED_MODULE_3__.DataSheetStream.readXML(dsstr);\n                let colMol = ds.firstColOfType(\"molecule\"), colAbbrev = ds.findColByName('Abbrev', \"string\");\n                if (colMol < 0 || colAbbrev < 0)\n                    continue;\n                for (let n = 0; n < ds.numRows; n++) {\n                    let frag = ds.getMoleculeClone(n, colMol), name = ds.getString(n, colAbbrev);\n                    if (!frag || !name)\n                        continue;\n                    let attcount = 0, firstConn = 0;\n                    for (let i = 1; i <= frag.numAtoms; i++)\n                        if (frag.atomElement(i) == _MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.TEMPLATE_ATTACHMENT) {\n                            if (firstConn == 0)\n                                firstConn = i;\n                            frag.setAtomElement(i, _MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.ABBREV_ATTACHMENT);\n                            attcount++;\n                        }\n                    if (attcount != 1)\n                        continue;\n                    if (firstConn > 1)\n                        frag.swapAtoms(1, firstConn);\n                    this.main.submitAbbreviation(name, frag);\n                }\n            }\n        });\n    }\n    getAbbrevs() {\n        return this.abbrevs.slice(0);\n    }\n    submitAbbreviation(name, infrag, promote = false) {\n        let frag = infrag.clone();\n        this.submitFragment(name, frag, promote);\n    }\n    submitMolecule(inmol, promote = false) {\n        let mol = inmol.clone();\n        for (let n = 1; n <= mol.numAtoms; n++) {\n            let frag = _MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.getAbbrev(mol, n);\n            if (!frag)\n                continue;\n            this.submitFragment(mol.atomElement(n), frag, promote);\n        }\n    }\n    substituteAbbrevName(mol, atom) {\n        let frag = _MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.getAbbrev(mol, atom);\n        if (!frag)\n            return false;\n        for (let abbrev of this.abbrevs)\n            if (abbrev.frag.numAtoms == frag.numAtoms) {\n                if (_CoordUtil__WEBPACK_IMPORTED_MODULE_2__.CoordUtil.sketchEquivalent(frag, abbrev.frag)) {\n                    mol.setAtomElement(atom, abbrev.name);\n                    return true;\n                }\n            }\n        return false;\n    }\n    submitFragment(name, frag, promote) {\n        if (name == '?')\n            return;\n        let vx = 0, vy = 0;\n        let adj = frag.atomAdjList(1);\n        for (let a of adj) {\n            vx += frag.atomX(a) - frag.atomX(1);\n            vy += frag.atomY(a) - frag.atomY(1);\n        }\n        if (adj.length > 1) {\n            let inv = 1.0 / adj.length;\n            vx *= inv;\n            vy *= inv;\n        }\n        if ((0,_util_util__WEBPACK_IMPORTED_MODULE_1__.norm_xy)(vx, vy) > 0.1 * 0.1) {\n            let theta = Math.atan2(vy, vx);\n            if (Math.abs(theta) > 2 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD)\n                _CoordUtil__WEBPACK_IMPORTED_MODULE_2__.CoordUtil.rotateMolecule(frag, -theta);\n        }\n        let hit = -1;\n        for (let n = 0; n < this.abbrevs.length; n++) {\n            let a = this.abbrevs[n];\n            if (a.name != name)\n                continue;\n            hit = n;\n            break;\n        }\n        let [html, search] = this.formatAbbrevLabel(name);\n        let abv = { 'name': name, 'frag': frag, 'nameHTML': html, 'nameSearch': search };\n        if (hit < 0) {\n            if (promote)\n                this.abbrevs.unshift(abv);\n            else\n                this.abbrevs.push(abv);\n        }\n        else {\n            if (promote && hit > 0) {\n                this.abbrevs.splice(hit, 1);\n                this.abbrevs.unshift(abv);\n            }\n            else\n                this.abbrevs[hit] = abv;\n        }\n    }\n    formatAbbrevLabel(name) {\n        let html = '', search = '';\n        let append = (bit, tag) => {\n            if (tag)\n                html += '<' + tag + '>';\n            html += (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.escapeHTML)(bit);\n            search += bit;\n            if (tag)\n                html += '</' + tag + '>';\n        };\n        for (let bit of name.split('|')) {\n            while (true) {\n                let match = bit.match(/^(.*?)\\{(.*?)\\}(.*)$/);\n                if (!match)\n                    break;\n                let pre = match[1], mid = match[2], post = match[3];\n                append(pre, null);\n                if (mid.startsWith('^'))\n                    append(mid.substring(1), 'sup');\n                else\n                    append(mid, 'sub');\n                bit = post;\n            }\n            append(bit, null);\n        }\n        return [html, search.toLowerCase()];\n    }\n}\nAbbrevContainer.main = null;\n\n\n//# sourceURL=webpack://WebMolKit/./src/data/AbbrevContainer.ts?");

/***/ }),

/***/ "./src/data/BondArtifact.ts":
/*!**********************************!*\
  !*** ./src/data/BondArtifact.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BONDARTIFACT_EXTRA_ARENE\": () => (/* binding */ BONDARTIFACT_EXTRA_ARENE),\n/* harmony export */   \"BONDARTIFACT_EXTRA_RESPATH\": () => (/* binding */ BONDARTIFACT_EXTRA_RESPATH),\n/* harmony export */   \"BONDARTIFACT_EXTRA_RESRING\": () => (/* binding */ BONDARTIFACT_EXTRA_RESRING),\n/* harmony export */   \"BondArtifact\": () => (/* binding */ BondArtifact)\n/* harmony export */ });\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _Graph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Graph */ \"./src/data/Graph.ts\");\n\n\n\nconst BONDARTIFACT_EXTRA_RESPATH = 'xRESPATH:';\nconst BONDARTIFACT_EXTRA_RESRING = 'xRESRING:';\nconst BONDARTIFACT_EXTRA_ARENE = 'xARENE:';\nclass BondArtifact {\n    constructor(mol) {\n        this.mol = mol;\n        this.resPaths = new Map();\n        this.resRings = new Map();\n        this.arenes = new Map();\n        for (let n = 1; n <= this.mol.numAtoms; n++) {\n            for (let str of this.mol.atomExtra(n)) {\n                if (str.startsWith(BONDARTIFACT_EXTRA_RESPATH))\n                    this.appendResPath(n, str.substring(BONDARTIFACT_EXTRA_RESPATH.length).split(':'));\n                else if (str.startsWith(BONDARTIFACT_EXTRA_RESRING))\n                    this.appendResRing(n, str.substring(BONDARTIFACT_EXTRA_RESRING.length).split(':'));\n                else if (str.startsWith(BONDARTIFACT_EXTRA_ARENE))\n                    this.appendArene(n, str.substring(BONDARTIFACT_EXTRA_ARENE.length).split(':'));\n            }\n        }\n        for (let [blk, res] of this.resPaths.entries()) {\n            res.atoms = this.pack(res.atoms);\n            if (!this.pathify(res.atoms, false))\n                this.resPaths.delete(blk);\n        }\n        for (let [blk, res] of this.resRings.entries()) {\n            res.atoms = this.pack(res.atoms);\n            if (!this.pathify(res.atoms, true))\n                this.resRings.delete(blk);\n        }\n        for (let [blk, res] of this.arenes.entries()) {\n            res.atoms = this.pack(res.atoms);\n            if (res.atoms.length > 1)\n                res.centre = res.atoms.shift();\n            if (!this.pathify(res.atoms, false))\n                this.arenes.delete(blk);\n        }\n    }\n    getPathBlocks() { return Array.from(this.resPaths.keys()); }\n    getRingBlocks() { return Array.from(this.resRings.keys()); }\n    getAreneBlocks() { return Array.from(this.arenes.keys()); }\n    getResPaths() {\n        let list = [];\n        for (let key of _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.sorted(Array.from(this.resPaths.keys())))\n            list.push(this.resPaths.get(key));\n        return list;\n    }\n    getResRings() {\n        let list = [];\n        for (let key of _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.sorted(Array.from(this.resRings.keys())))\n            list.push(this.resRings.get(key));\n        return list;\n    }\n    getArenes() {\n        let list = [];\n        for (let key of _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.sorted(Array.from(this.arenes.keys())))\n            list.push(this.arenes.get(key));\n        return list;\n    }\n    rewriteMolecule() {\n        const mol = this.mol;\n        for (let n = 1; n <= mol.numAtoms; n++) {\n            let extra = mol.atomExtra(n), modified = false;\n            for (let i = extra.length - 1; i >= 0; i--) {\n                if (extra[i].startsWith(BONDARTIFACT_EXTRA_RESPATH) || extra[i].startsWith(BONDARTIFACT_EXTRA_RESRING) || extra[i].startsWith(BONDARTIFACT_EXTRA_ARENE)) {\n                    extra.splice(i);\n                    modified = true;\n                }\n            }\n            if (modified)\n                mol.setAtomExtra(n, extra);\n        }\n        for (let [blk, path] of this.resPaths.entries()) {\n            for (let n = 0; n < path.atoms.length; n++) {\n                let extra = mol.atomExtra(path.atoms[n]);\n                extra.push(BONDARTIFACT_EXTRA_RESPATH + blk + ':' + (n + 1));\n                mol.setAtomExtra(path.atoms[n], extra);\n            }\n        }\n        for (let [blk, ring] of this.resRings.entries()) {\n            for (let n = 0; n < ring.atoms.length; n++) {\n                let extra = mol.atomExtra(ring.atoms[n]);\n                extra.push(BONDARTIFACT_EXTRA_RESRING + blk + ':' + (n + 1));\n                mol.setAtomExtra(ring.atoms[n], extra);\n            }\n        }\n        for (let [blk, arene] of this.arenes.entries()) {\n            for (let n = -1; n < arene.atoms.length; n++) {\n                let atom = n < 0 ? arene.centre : arene.atoms[n];\n                let extra = mol.atomExtra(atom);\n                extra.push(BONDARTIFACT_EXTRA_ARENE + blk + ':' + (n + 2));\n                mol.setAtomExtra(atom, extra);\n            }\n        }\n    }\n    harmoniseNumbering(other) {\n        let blocks = other.getPathBlocks();\n        let stashPaths = this.getResPaths();\n        this.resPaths.clear();\n        for (let path of stashPaths) {\n            let blk = this.nextIdentifier(blocks);\n            this.resPaths.set(blk, path);\n            blocks.push(blk);\n        }\n        blocks = other.getRingBlocks();\n        let stashRings = this.getResRings();\n        this.resRings.clear();\n        for (let ring of stashRings) {\n            let blk = this.nextIdentifier(blocks);\n            this.resRings.set(blk, ring);\n            blocks.push(blk);\n        }\n        blocks = other.getAreneBlocks();\n        let stashArenes = this.getArenes();\n        this.arenes.clear();\n        for (let arene of stashArenes) {\n            let blk = this.nextIdentifier(blocks);\n            this.arenes.set(blk, arene);\n            blocks.push(blk);\n        }\n    }\n    createPath(atoms) {\n        if (this.alreadyExists(atoms))\n            return false;\n        let path = this.atomsAsPath(atoms);\n        if (path) {\n            let id = this.nextIdentifier(Array.from(this.resPaths.keys()));\n            this.resPaths.set(id, path);\n            return true;\n        }\n        return false;\n    }\n    createRing(atoms) {\n        if (this.alreadyExists(atoms))\n            return false;\n        let ring = this.atomsAsRing(atoms);\n        if (ring) {\n            let id = this.nextIdentifier(Array.from(this.resRings.keys()));\n            this.resRings.set(id, ring);\n            return true;\n        }\n        return false;\n    }\n    createArene(atoms) {\n        if (this.alreadyExists(atoms))\n            return false;\n        let arene = this.atomsAsArene(atoms);\n        if (arene) {\n            let id = this.nextIdentifier(Array.from(this.arenes.keys()));\n            this.arenes.set(id, arene);\n            return true;\n        }\n        return false;\n    }\n    removeArtifact(atoms) {\n        let type = 0, pick = 0, overlap = 0;\n        for (let [blk, path] of this.resPaths.entries()) {\n            let count = 0;\n            for (let a of path.atoms)\n                if (atoms.indexOf(a) >= 0)\n                    count++;\n            if (count > overlap) {\n                type = 1;\n                pick = blk;\n                overlap = count;\n            }\n        }\n        for (let [blk, ring] of this.resRings.entries()) {\n            let count = 0;\n            for (let a of ring.atoms)\n                if (atoms.indexOf(a) >= 0)\n                    count++;\n            if (count > overlap) {\n                type = 2;\n                pick = blk;\n                overlap = count;\n            }\n        }\n        for (let [blk, arene] of this.arenes.entries()) {\n            let count = atoms.indexOf(arene.centre) >= 0 ? 1 : 0;\n            for (let a of arene.atoms)\n                if (atoms.indexOf(a) >= 0)\n                    count++;\n            if (count > overlap) {\n                type = 3;\n                pick = blk;\n                overlap = count;\n            }\n        }\n        if (type == 0)\n            return false;\n        else if (type == 1)\n            this.resPaths.delete(pick);\n        else if (type == 2)\n            this.resRings.delete(pick);\n        else if (type == 3)\n            this.arenes.delete(pick);\n        return true;\n    }\n    static removeAll(mol) {\n        for (let n = 1; n <= mol.numAtoms; n++) {\n            let extra = mol.atomExtra(n);\n            let modified = false;\n            for (let i = extra.length - 1; i >= 0; i--) {\n                if (!extra[i].startsWith(BONDARTIFACT_EXTRA_RESPATH) && !extra[i].startsWith(BONDARTIFACT_EXTRA_RESRING) &&\n                    !extra[i].startsWith(BONDARTIFACT_EXTRA_ARENE))\n                    continue;\n                extra = _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.remove(extra, i);\n                modified = true;\n            }\n            if (modified)\n                mol.setAtomExtra(n, extra);\n        }\n    }\n    appendResPath(atom, bits) {\n        let blk = (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.safeInt)(bits[0], 0);\n        if (blk <= 0)\n            return;\n        let res = this.resPaths.get(blk);\n        if (res == null)\n            this.resPaths.set(blk, res = { 'atoms': _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.numberArray(0, this.mol.numAtoms) });\n        let idx = bits.length >= 2 ? (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.safeInt)(bits[1], 0) : 0;\n        if (res.atoms.indexOf(atom) >= 0)\n            return;\n        if (idx >= 1 && idx <= this.mol.numAtoms)\n            res.atoms[idx - 1] = atom;\n        else\n            res.atoms.push(atom);\n    }\n    appendResRing(atom, bits) {\n        let blk = (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.safeInt)(bits[0], 0);\n        if (blk <= 0)\n            return;\n        let res = this.resRings.get(blk);\n        if (res == null)\n            this.resRings.set(blk, res = { 'atoms': _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.numberArray(0, this.mol.numAtoms) });\n        let idx = bits.length >= 2 ? (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.safeInt)(bits[1], 0) : 0;\n        if (res.atoms.indexOf(atom) >= 0)\n            return;\n        if (idx >= 1 && idx <= this.mol.numAtoms)\n            res.atoms[idx - 1] = atom;\n        else\n            res.atoms.push(atom);\n    }\n    appendArene(atom, bits) {\n        let blk = (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.safeInt)(bits[0], 0);\n        if (blk <= 0)\n            return;\n        let res = this.arenes.get(blk);\n        if (res == null)\n            this.arenes.set(blk, res = { 'centre': 0, 'atoms': _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.numberArray(0, this.mol.numAtoms) });\n        let idx = bits.length >= 2 ? (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.safeInt)(bits[1], 0) : 0;\n        if (res.atoms.indexOf(atom) >= 0)\n            return;\n        if (idx >= 1 && idx <= this.mol.numAtoms)\n            res.atoms[idx - 1] = atom;\n        else\n            res.atoms.push(atom);\n    }\n    pack(arr) {\n        let ret = [];\n        for (let v of arr)\n            if (v != 0)\n                ret.push(v);\n        return ret;\n    }\n    pathify(atoms, requireRing) {\n        let sz = atoms.length;\n        if (sz < 2)\n            return false;\n        let g = _Graph__WEBPACK_IMPORTED_MODULE_2__.Graph.fromMolecule(this.mol);\n        for (let n = 0; n < this.mol.numAtoms; n++)\n            g.setIndex(n, n + 1);\n        g = g.subgraphIndex(_util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.add(atoms, -1));\n        let pos = 0;\n        for (let n = 1; n < sz; n++)\n            if (g.numEdges(n) < g.numEdges(pos))\n                pos = n;\n        _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.setTo(atoms, -1);\n        for (let n = 0; n < sz; n++) {\n            atoms[n] = pos;\n            if (n == sz - 1) {\n                if (requireRing)\n                    if (g.getEdges(pos).indexOf(atoms[0]) < 0)\n                        return false;\n            }\n            else {\n                let next = sz;\n                for (let i of g.getEdges(pos))\n                    if (atoms.indexOf(i) < 0 && i < next)\n                        next = i;\n                if (next == sz)\n                    return false;\n                pos = next;\n            }\n        }\n        for (let n = 0; n < sz; n++)\n            atoms[n] = g.getIndex(atoms[n]);\n        return true;\n    }\n    alreadyExists(atoms) {\n        atoms = _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.sorted(atoms);\n        for (let path of this.resPaths.values()) {\n            if (_util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.equals(atoms, _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.sorted(path.atoms)))\n                return true;\n        }\n        for (let ring of this.resRings.values()) {\n            if (_util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.equals(atoms, _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.sorted(ring.atoms)))\n                return true;\n        }\n        for (let arene of this.arenes.values()) {\n            let areneAtoms = _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.append(arene.atoms, arene.centre);\n            if (_util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.equals(atoms, _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.sorted(areneAtoms)))\n                return true;\n        }\n        return false;\n    }\n    atomsAsPath(atoms) {\n        if (atoms.length < 2)\n            return null;\n        let path = { 'atoms': atoms };\n        if (!this.pathify(path.atoms, false))\n            return null;\n        return path;\n    }\n    atomsAsRing(atoms) {\n        if (atoms.length < 3)\n            return null;\n        let ring = { 'atoms': atoms };\n        if (!this.pathify(ring.atoms, true))\n            return null;\n        return ring;\n    }\n    atomsAsArene(atoms) {\n        const sz = atoms.length;\n        if (sz < 3)\n            return null;\n        let g = _Graph__WEBPACK_IMPORTED_MODULE_2__.Graph.fromMolecule(this.mol).subgraphIndex(_util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.add(atoms, -1));\n        let best = 0;\n        if (sz == 3) {\n            let bsum = [0, 0, 0];\n            for (let n = 0; n < sz; n++) {\n                if (g.numEdges(n) != 2)\n                    return null;\n                for (let e of g.getEdges(n))\n                    bsum[n] += this.mol.bondOrder(this.mol.findBond(atoms[n], atoms[e]));\n                best = _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.idxMin(bsum);\n            }\n        }\n        else {\n            for (let n = 1; n < sz; n++)\n                if (g.numEdges(n) > g.numEdges(best))\n                    best = n;\n        }\n        let arene = { 'centre': atoms[best], 'atoms': _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.remove(atoms, best) };\n        if (!this.pathify(arene.atoms, false))\n            return null;\n        return arene;\n    }\n    nextIdentifier(inkeys) {\n        if (inkeys.length == 0)\n            return 1;\n        let keys = _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.sorted(inkeys);\n        for (let n = 0; n < keys.length - 1; n++)\n            if (keys[n + 1] != keys[n] + 1)\n                return keys[n] + 1;\n        return keys[keys.length - 1] + 1;\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/data/BondArtifact.ts?");

/***/ }),

/***/ "./src/data/Chemistry.ts":
/*!*******************************!*\
  !*** ./src/data/Chemistry.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Chemistry\": () => (/* binding */ Chemistry)\n/* harmony export */ });\nclass Chemistry {\n}\nChemistry.ELEMENTS = [\n    null,\n    'H', 'He',\n    'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne',\n    'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar',\n    'K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr',\n    'Rb', 'Sr', 'Y', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I', 'Xe',\n    'Cs', 'Ba',\n    'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb',\n    'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn',\n    'Fr', 'Ra',\n    'Ac', 'Th', 'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', 'Md', 'No',\n    'Lr', 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt', 'Ds', 'Rg', 'Cn'\n];\nChemistry.ELEMENT_GROUPS = [\n    0,\n    1, 18,\n    1, 2, 13, 14, 15, 16, 17, 18,\n    1, 2, 13, 14, 15, 16, 17, 18,\n    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,\n    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,\n    1, 2,\n    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n    3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,\n    1, 2,\n    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n    3, 4, 5, 6, 7, 8, 9, 10, 11, 12\n];\nChemistry.ELEMENT_ROWS = [\n    0,\n    1, 1,\n    2, 2, 2, 2, 2, 2, 2, 2,\n    3, 3, 3, 3, 3, 3, 3, 3,\n    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n    6, 6,\n    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n    7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7\n];\nChemistry.ELEMENT_BLOCKS = [\n    0,\n    1, 2,\n    1, 1, 2, 2, 2, 2, 2, 2,\n    1, 1, 2, 2, 2, 2, 2, 2,\n    1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2,\n    1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2,\n    1, 1,\n    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2,\n    1, 1,\n    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n    3, 3, 3, 3, 3, 3, 3, 3, 3, 3\n];\nChemistry.ELEMENT_VALENCE = [\n    0,\n    1, 2,\n    1, 2, 3, 4, 5, 6, 7, 8,\n    1, 2, 3, 4, 5, 6, 7, 8,\n    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 3, 4, 5, 6, 7, 8,\n    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 3, 4, 5, 6, 7, 8,\n    1, 2,\n    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n    3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 3, 4, 5, 6, 7, 8,\n    1, 1,\n    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n    3, 4, 5, 6, 7, 8, 9, 10, 11, 12\n];\nChemistry.ELEMENT_BONDING = [\n    0,\n    1, 0,\n    1, 2, 3, 4, 3, 2, 1, 0,\n    1, 2, 3, 4, 3, 2, 1, 0,\n    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 3, 4, 3, 2, 1, 0,\n    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 3, 4, 3, 2, 1, 0,\n    1, 2,\n    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n    3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 3, 4, 3, 2, 1, 0,\n    1, 1,\n    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n    3, 4, 5, 6, 7, 8, 9, 10, 11, 12\n];\nChemistry.ELEMENT_SHELL = [\n    0,\n    2, 2,\n    8, 8, 8, 8, 8, 8, 8, 8,\n    8, 8, 8, 8, 8, 8, 8, 8,\n    8, 8, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 8, 8, 8, 8, 8, 8,\n    8, 8, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 8, 8, 8, 8, 8, 8,\n    8, 8,\n    18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n    18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n    8, 8,\n    18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n    18, 18, 18, 18, 18, 18, 18, 18, 18, 18\n];\nChemistry.NATURAL_ATOMIC_WEIGHTS = [\n    0, 1.00794, 4.002602, 6.941, 9.012182, 10.811, 12.0107, 14.0067, 15.9994, 18.9984032, 20.1797,\n    22.989770, 24.3050, 26.981538, 28.0855, 30.973761, 32.065, 35.453, 39.948, 39.0983, 40.078,\n    44.955910, 47.867, 50.9415, 51.9961, 54.938049, 55.845, 58.933200, 58.6934, 63.546, 65.409,\n    69.723, 72.64, 74.92160, 78.96, 79.904, 83.798, 85.4678, 87.62, 88.90585, 91.224, 92.90638,\n    95.94, 98, 101.07, 102.90550, 106.42, 107.8682, 112.411, 114.818, 118.710, 121.760, 127.60,\n    126.90447, 131.293, 132.90545, 137.327, 138.9055, 140.116, 140.90765, 144.24, 145, 150.36,\n    151.964, 157.25, 158.92534, 162.500, 164.93032, 167.259, 168.93421, 173.04, 174.967, 178.49,\n    180.9479, 183.84, 186.207, 190.23, 192.217, 195.078, 196.96655, 200.59, 204.3833, 207.2, 208.98038,\n    209, 210, 222, 223, 226, 227, 230.0331266, 231.03588, 233.039628, 237, 244, 243, 247, 247, 251, 252, 257,\n    258, 259, 262, 261, 262, 266, 264, 277, 268, 271, 272, 285\n];\nChemistry.ELEMENT_H = 1;\nChemistry.ELEMENT_He = 2;\nChemistry.ELEMENT_Li = 3;\nChemistry.ELEMENT_Be = 4;\nChemistry.ELEMENT_B = 5;\nChemistry.ELEMENT_C = 6;\nChemistry.ELEMENT_N = 7;\nChemistry.ELEMENT_O = 8;\nChemistry.ELEMENT_F = 9;\nChemistry.ELEMENT_Ne = 10;\nChemistry.ELEMENT_Na = 11;\nChemistry.ELEMENT_Mg = 12;\nChemistry.ELEMENT_Al = 13;\nChemistry.ELEMENT_Si = 14;\nChemistry.ELEMENT_P = 15;\nChemistry.ELEMENT_S = 16;\nChemistry.ELEMENT_Cl = 17;\nChemistry.ELEMENT_Ar = 18;\nChemistry.ELEMENT_K = 19;\nChemistry.ELEMENT_Ca = 20;\nChemistry.ELEMENT_Sc = 21;\nChemistry.ELEMENT_Ti = 22;\nChemistry.ELEMENT_V = 23;\nChemistry.ELEMENT_Cr = 24;\nChemistry.ELEMENT_Mn = 25;\nChemistry.ELEMENT_Fe = 26;\nChemistry.ELEMENT_Co = 27;\nChemistry.ELEMENT_Ni = 28;\nChemistry.ELEMENT_Cu = 29;\nChemistry.ELEMENT_Zn = 30;\nChemistry.ELEMENT_Ga = 31;\nChemistry.ELEMENT_Ge = 32;\nChemistry.ELEMENT_As = 33;\nChemistry.ELEMENT_Se = 34;\nChemistry.ELEMENT_Br = 35;\nChemistry.ELEMENT_Kr = 36;\nChemistry.ELEMENT_Rb = 37;\nChemistry.ELEMENT_Sr = 38;\nChemistry.ELEMENT_Y = 39;\nChemistry.ELEMENT_Zr = 40;\nChemistry.ELEMENT_Nb = 41;\nChemistry.ELEMENT_Mo = 42;\nChemistry.ELEMENT_Tc = 43;\nChemistry.ELEMENT_Ru = 44;\nChemistry.ELEMENT_Rh = 45;\nChemistry.ELEMENT_Pd = 46;\nChemistry.ELEMENT_Ag = 47;\nChemistry.ELEMENT_Cd = 48;\nChemistry.ELEMENT_In = 49;\nChemistry.ELEMENT_Sn = 50;\nChemistry.ELEMENT_Sb = 51;\nChemistry.ELEMENT_Te = 52;\nChemistry.ELEMENT_I = 53;\nChemistry.ELEMENT_Xe = 54;\nChemistry.ELEMENT_Cs = 55;\nChemistry.ELEMENT_Ba = 56;\nChemistry.ELEMENT_La = 57;\nChemistry.ELEMENT_Ce = 58;\nChemistry.ELEMENT_Pr = 59;\nChemistry.ELEMENT_Nd = 60;\nChemistry.ELEMENT_Pm = 61;\nChemistry.ELEMENT_Sm = 62;\nChemistry.ELEMENT_Eu = 63;\nChemistry.ELEMENT_Gd = 64;\nChemistry.ELEMENT_Tb = 65;\nChemistry.ELEMENT_Dy = 66;\nChemistry.ELEMENT_Ho = 67;\nChemistry.ELEMENT_Er = 68;\nChemistry.ELEMENT_Tm = 69;\nChemistry.ELEMENT_Yb = 70;\nChemistry.ELEMENT_Lu = 71;\nChemistry.ELEMENT_Hf = 72;\nChemistry.ELEMENT_Ta = 73;\nChemistry.ELEMENT_W = 74;\nChemistry.ELEMENT_Re = 75;\nChemistry.ELEMENT_Os = 76;\nChemistry.ELEMENT_Ir = 77;\nChemistry.ELEMENT_Pt = 78;\nChemistry.ELEMENT_Au = 79;\nChemistry.ELEMENT_Hg = 80;\nChemistry.ELEMENT_Tl = 81;\nChemistry.ELEMENT_Pb = 82;\nChemistry.ELEMENT_Bi = 83;\nChemistry.ELEMENT_Po = 84;\nChemistry.ELEMENT_At = 85;\nChemistry.ELEMENT_Rn = 86;\nChemistry.ELEMENT_Fr = 87;\nChemistry.ELEMENT_Ra = 88;\nChemistry.ELEMENT_Ac = 89;\nChemistry.ELEMENT_Th = 90;\nChemistry.ELEMENT_Pa = 91;\nChemistry.ELEMENT_U = 92;\nChemistry.ELEMENT_Np = 93;\nChemistry.ELEMENT_Pu = 94;\nChemistry.ELEMENT_Am = 95;\nChemistry.ELEMENT_Cm = 96;\nChemistry.ELEMENT_Bk = 97;\nChemistry.ELEMENT_Cf = 98;\nChemistry.ELEMENT_Es = 99;\nChemistry.ELEMENT_Fm = 100;\nChemistry.ELEMENT_Md = 101;\nChemistry.ELEMENT_No = 102;\nChemistry.ELEMENT_Lr = 103;\nChemistry.ELEMENT_Rf = 104;\nChemistry.ELEMENT_Db = 105;\nChemistry.ELEMENT_Sg = 106;\nChemistry.ELEMENT_Bh = 107;\nChemistry.ELEMENT_Hs = 108;\nChemistry.ELEMENT_Mt = 109;\nChemistry.ELEMENT_Ds = 110;\nChemistry.ELEMENT_Rg = 111;\nChemistry.ELEMENT_Cn = 112;\n\n\n//# sourceURL=webpack://WebMolKit/./src/data/Chemistry.ts?");

/***/ }),

/***/ "./src/data/CoordUtil.ts":
/*!*******************************!*\
  !*** ./src/data/CoordUtil.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CoordUtil\": () => (/* binding */ CoordUtil)\n/* harmony export */ });\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _Graph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Graph */ \"./src/data/Graph.ts\");\n/* harmony import */ var _Molecule__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Molecule */ \"./src/data/Molecule.ts\");\n/* harmony import */ var _MolUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MolUtil */ \"./src/data/MolUtil.ts\");\n\n\n\n\n\nclass CoordUtil {\n    static atomAtPoint(mol, x, y, tolerance) {\n        if (tolerance == null)\n            tolerance = CoordUtil.OVERLAP_THRESHOLD;\n        const tolsq = tolerance * tolerance;\n        for (let n = 1; n <= mol.numAtoms; n++)\n            if ((0,_util_util__WEBPACK_IMPORTED_MODULE_0__.norm2_xy)(mol.atomX(n) - x, mol.atomY(n) - y) < tolsq)\n                return n;\n        return 0;\n    }\n    static sketchEquivalent(mol1, mol2, tolerance) {\n        if (tolerance == null)\n            tolerance = CoordUtil.DEFAULT_EQUIV_TOLERANCE;\n        const na = mol1.numAtoms, nb = mol1.numBonds;\n        if (na != mol2.numAtoms || nb != mol2.numBonds)\n            return false;\n        const tolsq = tolerance * tolerance;\n        let box1 = mol1.boundary(), box2 = mol2.boundary();\n        if (Math.abs(box1.minX() - box2.minX()) > tolerance)\n            return false;\n        if (Math.abs(box1.minY() - box2.minY()) > tolerance)\n            return false;\n        if (Math.abs(box1.maxX() - box2.maxX()) > tolerance)\n            return false;\n        if (Math.abs(box1.maxY() - box2.maxY()) > tolerance)\n            return false;\n        let mx1 = _MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.arrayAtomX(mol1), my1 = _MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.arrayAtomY(mol1);\n        let mx2 = _MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.arrayAtomX(mol2), my2 = _MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.arrayAtomY(mol2);\n        let map = _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.numberArray(0, na);\n        let mask = _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.booleanArray(false, na);\n        for (let i = 0; i < na; i++) {\n            let j = -1;\n            if ((0,_util_util__WEBPACK_IMPORTED_MODULE_0__.norm2_xy)(mx1[i] - mx2[i], my1[i] - my2[i]) < tolsq)\n                j = i;\n            if (j < 0) {\n                let bestdsq = Number.MAX_VALUE;\n                for (let n = 0; n < na; n++)\n                    if (!mask[n]) {\n                        let dsq = (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.norm2_xy)(mx1[i] - mx2[n], my1[i] - my2[n]);\n                        if (dsq < bestdsq) {\n                            bestdsq = dsq;\n                            j = n;\n                        }\n                    }\n                if (j < 0 || bestdsq > tolsq)\n                    return false;\n            }\n            map[i] = j + 1;\n            mask[j] = true;\n            if (mol1.atomElement(i + 1) != mol2.atomElement(j + 1))\n                return false;\n            if (mol1.atomCharge(i + 1) != mol2.atomCharge(j + 1))\n                return false;\n            if (mol1.atomUnpaired(i + 1) != mol2.atomUnpaired(j + 1))\n                return false;\n            if (mol1.atomHExplicit(i + 1) != mol2.atomHExplicit(j + 1) &&\n                mol1.atomHExplicit(i + 1) != _Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule.HEXPLICIT_UNKNOWN &&\n                mol2.atomHExplicit(j + 1) != _Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule.HEXPLICIT_UNKNOWN)\n                return false;\n        }\n        for (let i = 1; i <= nb; i++) {\n            let i1 = mol1.bondFrom(i), i2 = mol1.bondTo(i), j1 = map[i1 - 1], j2 = map[i2 - 1];\n            let j = mol2.findBond(j1, j2);\n            if (j == 0)\n                return false;\n            if (mol1.bondOrder(i) != mol2.bondOrder(j) || mol1.bondType(i) != mol2.bondType(j))\n                return false;\n            if (mol2.bondFrom(j) == j1 && mol2.bondTo(j) == j2) { }\n            else if (mol2.bondType(j) != _Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule.BONDTYPE_INCLINED &&\n                mol2.bondType(j) != _Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule.BONDTYPE_DECLINED &&\n                mol2.bondFrom(j) == j2 && mol2.bondTo(j) == j1) { }\n            else\n                return false;\n        }\n        return true;\n    }\n    static sketchMappable(mol1, mol2, tolerance) {\n        if (tolerance == null)\n            tolerance = CoordUtil.DEFAULT_EQUIV_TOLERANCE;\n        let box1 = mol1.boundary(), box2 = mol2.boundary();\n        let dx = box1.minX() - box2.minX(), dy = box1.minY() - box2.minY();\n        if (Math.abs(dx) > tolerance * 0.1 || Math.abs(dy) > tolerance * 0.1) {\n            mol2 = mol2.clone();\n            for (let n = 1; n <= mol2.numAtoms; n++)\n                mol2.setAtomPos(n, mol2.atomX(n) + dx, mol2.atomY(n) + dy);\n        }\n        return CoordUtil.sketchEquivalent(mol1, mol2, tolerance);\n    }\n    static atomBondAngles(mol, atom, adj) {\n        if (adj == null)\n            adj = mol.atomAdjList(atom);\n        let bndang = [];\n        let cx = mol.atomX(atom), cy = mol.atomY(atom);\n        for (let a of adj)\n            bndang.push(Math.atan2(mol.atomY(a) - cy, mol.atomX(a) - cx));\n        return bndang;\n    }\n    static overlapsAtom(mol, x, y, tol) {\n        const tolsq = tol * tol;\n        for (let n = 1; n <= mol.numAtoms; n++)\n            if ((0,_util_util__WEBPACK_IMPORTED_MODULE_0__.norm2_xy)(mol.atomX(n) - x, mol.atomY(n) - y) < tolsq)\n                return true;\n        return false;\n    }\n    static overlappingAtomMask(mol, thresh) {\n        if (thresh == null)\n            thresh = CoordUtil.OVERLAP_THRESHOLD;\n        const sz = mol.numAtoms;\n        let box = mol.boundary();\n        let p1, p2;\n        if (box.w > box.h) {\n            p1 = _MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.arrayAtomX(mol);\n            p2 = _MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.arrayAtomY(mol);\n        }\n        else {\n            p1 = _MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.arrayAtomY(mol);\n            p2 = _MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.arrayAtomX(mol);\n        }\n        let omask = _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.booleanArray(false, sz);\n        let idx = _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.idxSort(p1);\n        const threshSQ = thresh * thresh;\n        for (let i = 1; i < sz - 1; i++) {\n            for (let j = i - 1; j >= 0; j--) {\n                let d1 = p1[idx[i]] - p1[idx[j]];\n                if (d1 > thresh)\n                    break;\n                if ((0,_util_util__WEBPACK_IMPORTED_MODULE_0__.norm2_xy)(d1, p2[idx[i]] - p2[idx[j]]) < threshSQ) {\n                    omask[idx[i]] = true;\n                    omask[idx[j]] = true;\n                }\n            }\n            for (let j = i + 1; j < sz; j++) {\n                let d1 = p1[idx[j]] - p1[idx[i]];\n                if (d1 > thresh)\n                    break;\n                if ((0,_util_util__WEBPACK_IMPORTED_MODULE_0__.norm2_xy)(d1, p2[idx[j]] - p2[idx[i]]) < threshSQ) {\n                    omask[idx[i]] = true;\n                    omask[idx[j]] = true;\n                }\n            }\n        }\n        return omask;\n    }\n    static overlappingAtomList(mol, thresh) {\n        if (thresh == null)\n            thresh = CoordUtil.OVERLAP_THRESHOLD;\n        return _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.add(_util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.maskIdx(CoordUtil.overlappingAtomMask(mol, thresh)), 1);\n    }\n    static congestionPoint(mol, x, y, approach) {\n        if (approach == null)\n            approach = 1E-5;\n        let score = 0;\n        let na = mol.numAtoms;\n        for (let n = 1; n <= na; n++)\n            score += 1.0 / (approach + (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.norm2_xy)(mol.atomX(n) - x, mol.atomY(n) - y));\n        return score;\n    }\n    static congestionMolecule(mol, approach) {\n        if (approach == null)\n            approach = 1E-5;\n        let score = 0;\n        const na = mol.numAtoms;\n        let mx = _MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.arrayAtomX(mol), my = _MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.arrayAtomY(mol);\n        for (let i = 0; i < na - 1; i++)\n            for (let j = i + 1; j < na; j++)\n                score += 1.0 / (approach + (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.norm2_xy)(mx[i] - mx[j], my[i] - my[j]));\n        return score;\n    }\n    static translateMolecule(mol, ox, oy) {\n        for (let n = 1; n <= mol.numAtoms; n++)\n            mol.setAtomPos(n, mol.atomX(n) + ox, mol.atomY(n) + oy);\n    }\n    static rotateMolecule(mol, theta, cx, cy) {\n        if (cx == null || cy == null) {\n            let box = mol.boundary();\n            cx = box.midX();\n            cy = box.midY();\n        }\n        let cosTheta = Math.cos(theta), sinTheta = Math.sin(theta);\n        for (let n = 1; n <= mol.numAtoms; n++) {\n            let x = mol.atomX(n) - cx, y = mol.atomY(n) - cy;\n            mol.setAtomPos(n, cx + x * cosTheta - y * sinTheta, cy + x * sinTheta + y * cosTheta);\n        }\n    }\n    static rotateBond(mol, centre, atom, theta) {\n        theta = (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.angleNorm)(theta);\n        if (Math.abs(theta) < 0.1 * _util_util__WEBPACK_IMPORTED_MODULE_0__.DEGRAD)\n            return;\n        let g = _Graph__WEBPACK_IMPORTED_MODULE_2__.Graph.fromMolecule(mol);\n        g.isolateNode(centre - 1);\n        let cc = g.calculateComponents();\n        let cx = mol.atomX(centre), cy = mol.atomY(centre);\n        let cosTheta = Math.cos(theta), sinTheta = Math.sin(theta);\n        for (let n = 1; n <= mol.numAtoms; n++)\n            if (cc[n - 1] == cc[atom - 1]) {\n                let x = mol.atomX(n) - cx, y = mol.atomY(n) - cy;\n                mol.setAtomPos(n, cx + x * cosTheta - y * sinTheta, cy + x * sinTheta + y * cosTheta);\n            }\n    }\n    static rotateAtoms(mol, mask, cx, cy, theta) {\n        let cosTheta = Math.cos(theta), sinTheta = Math.sin(theta);\n        for (let n = 1; n <= mol.numAtoms; n++)\n            if (mask[n - 1]) {\n                let x = mol.atomX(n) - cx, y = mol.atomY(n) - cy;\n                mol.setAtomPos(n, cx + x * cosTheta - y * sinTheta, cy + x * sinTheta + y * cosTheta);\n            }\n    }\n    static angleNeighbours(mol, atom) {\n        let adj = mol.atomAdjList(atom);\n        if (adj.length <= 1)\n            return null;\n        let th = [];\n        for (let n = 0; n < adj.length; n++)\n            th.push(Math.atan2(mol.atomY(adj[n]) - mol.atomY(atom), mol.atomX(adj[n]) - mol.atomX(atom)));\n        if (adj.length == 2) {\n            if ((0,_util_util__WEBPACK_IMPORTED_MODULE_0__.angleDiff)(th[1], th[0]) > 0)\n                return adj;\n            return [adj[1], adj[0]];\n        }\n        let idx = _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.idxSort(th);\n        return _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.idxGet(adj, idx);\n    }\n    static mergeAtoms(mol, oldN, newN) {\n        for (let n = 1; n <= mol.numBonds; n++) {\n            if (mol.bondFrom(n) == oldN)\n                mol.setBondFrom(n, newN);\n            if (mol.bondTo(n) == oldN)\n                mol.setBondTo(n, newN);\n        }\n        mol.deleteAtomAndBonds(oldN);\n    }\n    static normaliseBondDistances(mol) {\n        const nb = mol.numBonds;\n        if (nb == 0)\n            return;\n        let dsq = [];\n        for (let n = 1; n <= nb; n++) {\n            let bfr = mol.bondFrom(n), bto = mol.bondTo(n);\n            dsq.push((0,_util_util__WEBPACK_IMPORTED_MODULE_0__.norm2_xy)(mol.atomX(bto) - mol.atomX(bfr), mol.atomY(bto) - mol.atomY(bfr)));\n        }\n        _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.sort(dsq);\n        let median = (nb & 1) == 1 ? Math.sqrt(dsq[nb >> 1]) : 0.5 * (Math.sqrt(dsq[nb >> 1]) + Math.sqrt(dsq[(nb >> 1) - 1]));\n        if (median < 0.1 || (median > _Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule.IDEALBOND * 0.9 && median < _Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule.IDEALBOND * 1.1))\n            return;\n        let box = mol.boundary();\n        let cx = box.midX(), cy = box.midY();\n        let scale = _Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule.IDEALBOND / median;\n        for (let n = mol.numAtoms; n >= 1; n--) {\n            let x = (mol.atomX(n) - cx) * scale + cx;\n            let y = (mol.atomY(n) - cy) * scale + cy;\n            mol.setAtomPos(n, x, y);\n        }\n    }\n    static mirrorImage(mol) {\n        mol = mol.clone();\n        for (let n = 1; n <= mol.numAtoms; n++)\n            mol.setAtomX(n, -mol.atomX(n));\n        for (let n = 1; n <= mol.numBonds; n++) {\n            if (mol.bondType(n) == _Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule.BONDTYPE_DECLINED)\n                mol.setBondType(n, _Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule.BONDTYPE_INCLINED);\n            else if (mol.bondType(n) == _Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule.BONDTYPE_INCLINED)\n                mol.setBondType(n, _Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule.BONDTYPE_DECLINED);\n        }\n        return mol;\n    }\n    static alignOrientFlip(mol1, idx1, mol2, idx2) {\n        if (idx1.length < 2 || idx1.length != idx2.length)\n            throw 'Invalid mapping indices.';\n        let x0 = mol1.atomX(idx1[0]), y0 = mol1.atomY(idx1[0]);\n        CoordUtil.translateMolecule(mol2, x0 - mol2.atomX(idx2[0]), y0 - mol2.atomY(idx2[0]));\n        const sz = idx1.length - 1;\n        let th1 = [], th2 = [];\n        let deltaA = 0, deltaB = 0;\n        for (let n = 0; n < sz; n++) {\n            th1.push(Math.atan2(mol1.atomY(idx1[n + 1]) - y0, mol1.atomX(idx1[n + 1]) - x0));\n            th2.push(Math.atan2(mol2.atomY(idx2[n + 1]) - y0, mol2.atomX(idx2[n + 1]) - x0));\n            let dthA = (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.angleDiff)(th1[n], th2[n]), dthB = (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.angleDiff)(th1[n], -th2[n]);\n            if (dthA < -175 * _util_util__WEBPACK_IMPORTED_MODULE_0__.DEGRAD && deltaA > 0)\n                dthA += _util_util__WEBPACK_IMPORTED_MODULE_0__.TWOPI;\n            else if (dthA > 175 * _util_util__WEBPACK_IMPORTED_MODULE_0__.DEGRAD && deltaA < 0)\n                dthA -= _util_util__WEBPACK_IMPORTED_MODULE_0__.TWOPI;\n            if (dthB < -175 * _util_util__WEBPACK_IMPORTED_MODULE_0__.DEGRAD && deltaB > 0)\n                dthB += _util_util__WEBPACK_IMPORTED_MODULE_0__.TWOPI;\n            else if (dthB > 175 * _util_util__WEBPACK_IMPORTED_MODULE_0__.DEGRAD && deltaB < 0)\n                dthB -= _util_util__WEBPACK_IMPORTED_MODULE_0__.TWOPI;\n            deltaA += dthA;\n            deltaB += dthB;\n        }\n        if (sz > 1) {\n            let inv = 1.0 / sz;\n            deltaA *= inv;\n            deltaB *= inv;\n        }\n        let scoreA = 0, scoreB = 0;\n        for (let n = 0; n < sz; n++) {\n            scoreA += Math.abs((0,_util_util__WEBPACK_IMPORTED_MODULE_0__.angleDiff)(th1[n], th2[n] + deltaA));\n            scoreB += Math.abs((0,_util_util__WEBPACK_IMPORTED_MODULE_0__.angleDiff)(th1[n], -th2[n] + deltaB));\n        }\n        if (scoreB < scoreA) {\n            for (let n = 1; n <= mol2.numAtoms; n++)\n                mol2.setAtomY(n, 2 * y0 - mol2.atomY(n));\n            for (let n = 1; n <= mol2.numBonds; n++) {\n                if (mol2.bondType(n) == _Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule.BONDTYPE_DECLINED)\n                    mol2.setBondType(n, _Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule.BONDTYPE_INCLINED);\n                else if (mol2.bondType(n) == _Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule.BONDTYPE_INCLINED)\n                    mol2.setBondType(n, _Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule.BONDTYPE_DECLINED);\n            }\n            CoordUtil.rotateMolecule(mol2, x0, y0, deltaB);\n        }\n        else\n            CoordUtil.rotateMolecule(mol2, x0, y0, deltaA);\n    }\n}\nCoordUtil.OVERLAP_THRESHOLD = 0.2;\nCoordUtil.OVERLAP_THRESHOLD_SQ = CoordUtil.OVERLAP_THRESHOLD * CoordUtil.OVERLAP_THRESHOLD;\nCoordUtil.DEFAULT_EQUIV_TOLERANCE = 0.2;\n\n\n//# sourceURL=webpack://WebMolKit/./src/data/CoordUtil.ts?");

/***/ }),

/***/ "./src/data/DataSheet.ts":
/*!*******************************!*\
  !*** ./src/data/DataSheet.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DataSheet\": () => (/* binding */ DataSheet),\n/* harmony export */   \"DataSheetColumn\": () => (/* binding */ DataSheetColumn)\n/* harmony export */ });\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _Molecule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Molecule */ \"./src/data/Molecule.ts\");\n\n\n\nvar DataSheetColumn;\n(function (DataSheetColumn) {\n    DataSheetColumn[\"Molecule\"] = \"molecule\";\n    DataSheetColumn[\"String\"] = \"string\";\n    DataSheetColumn[\"Real\"] = \"real\";\n    DataSheetColumn[\"Integer\"] = \"integer\";\n    DataSheetColumn[\"Boolean\"] = \"boolean\";\n    DataSheetColumn[\"Extend\"] = \"extend\";\n})(DataSheetColumn || (DataSheetColumn = {}));\nclass DataSheet {\n    constructor(data) {\n        if (!data)\n            data = {};\n        if (!data.title)\n            data.title = '';\n        if (!data.description)\n            data.description = '';\n        if (data.numCols == null)\n            data.numCols = _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.len(data.colData);\n        if (data.numRows == null)\n            data.numRows = _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.len(data.rowData);\n        if (data.numExtens == null)\n            data.numExtens = _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.len(data.extData);\n        if (data.colData == null)\n            data.colData = [];\n        if (data.rowData == null)\n            data.rowData = [];\n        if (data.extData == null)\n            data.extData = [];\n        this.data = data;\n    }\n    clone(withRows = true) {\n        let { numCols, numRows, colData, rowData } = this.data;\n        let data = {\n            'title': this.data.title,\n            'description': this.data.description,\n            'numCols': numCols,\n            'numRows': withRows ? numRows : 0,\n            'numExtens': this.data.numExtens,\n            'colData': (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.deepClone)(colData),\n            'rowData': withRows ? new Array(numRows) : [],\n            'extData': (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.deepClone)(this.data.extData),\n        };\n        if (withRows)\n            for (let r = 0; r < numRows; r++) {\n                let inRow = rowData[r], outRow = new Array(numCols);\n                for (let c = 0; c < numCols; c++) {\n                    if (inRow[c] != null && colData[c].type == \"molecule\" && inRow[c] instanceof _Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule)\n                        outRow[c] = inRow[c].clone();\n                    else\n                        outRow[c] = inRow[c];\n                }\n                data.rowData[r] = outRow;\n            }\n        return new DataSheet(data);\n    }\n    cloneMask(colMask, rowMask = null, inclExtn = true) {\n        let { numCols, numRows, colData, rowData } = this.data;\n        let data = {\n            'title': this.data.title,\n            'description': this.data.description,\n            'numCols': _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.maskCount(colMask),\n            'numRows': rowMask ? _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.maskCount(rowMask) : 0,\n            'numExtens': inclExtn ? this.data.numExtens : 0,\n            'colData': (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.deepClone)(_util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.maskGet(colData, colMask)),\n            'rowData': [],\n            'extData': inclExtn ? (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.deepClone)(this.data.extData) : [],\n        };\n        if (rowMask)\n            for (let r = 0; r < numRows; r++)\n                if (rowMask[r]) {\n                    let inRow = rowData[r], outRow = _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.maskGet(inRow, colMask);\n                    data.rowData.push(outRow);\n                }\n        const { 'colData': outCols, 'rowData': outRows } = data;\n        for (let c = outCols.length - 1; c >= 0; c--)\n            if (outCols[c].type == \"molecule\") {\n                for (let r = outRows.length - 1; r >= 0; r--)\n                    if (outRows[r][c] != null && outRows[r][c] instanceof _Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule)\n                        outRows[r][c] = outRows[r][c].clone();\n            }\n        return new DataSheet(data);\n    }\n    getData() {\n        return this.data;\n    }\n    get numCols() {\n        return this.data.numCols;\n    }\n    get numRows() {\n        return this.data.numRows;\n    }\n    get title() { return this.data.title; }\n    set title(title) { this.data.title = title; }\n    get description() { return this.data.description; }\n    set description(description) { this.data.description = description; }\n    get numExtensions() {\n        return this.data.numExtens;\n    }\n    getExtName(idx) {\n        return this.data.extData[idx].name;\n    }\n    getExtType(idx) {\n        return this.data.extData[idx].type;\n    }\n    getExtData(idx) {\n        return this.data.extData[idx].data;\n    }\n    setExtName(idx, val) {\n        this.data.extData[idx].name = val;\n    }\n    setExtType(idx, val) {\n        this.data.extData[idx].type = val;\n    }\n    setExtData(idx, val) {\n        this.data.extData[idx].data = val;\n    }\n    appendExtension(name, type, data) {\n        this.data.numExtens++;\n        this.data.extData.push({ 'name': name, 'type': type, 'data': data });\n        return this.data.numExtens - 1;\n    }\n    insertExtension(idx, name, type, data) {\n        this.data.numExtens++;\n        this.data.extData.splice(idx, 0, { 'name': name, 'type': type, 'data': data });\n    }\n    deleteExtension(idx) {\n        this.data.extData.splice(idx, 1);\n        this.data.numExtens--;\n    }\n    colName(col) {\n        return this.data.colData[col].name;\n    }\n    colType(col) {\n        return this.data.colData[col].type;\n    }\n    colDescr(col) {\n        return this.data.colData[col].descr;\n    }\n    isNull(row, col) {\n        if (typeof col === 'string')\n            col = this.findColByName(col);\n        if (col < 0)\n            return null;\n        return this.data.rowData[row][col] == null;\n    }\n    notNull(row, col) {\n        return !this.isNull(row, col);\n    }\n    isBlank(row, col) {\n        if (typeof col === 'string')\n            col = this.findColByName(col);\n        if (this.isNull(row, col))\n            return true;\n        let ct = this.colType(col);\n        if (ct == \"molecule\")\n            return this.getMolecule(row, col).numAtoms == 0;\n        if (ct == \"string\")\n            return this.getString(row, col).length == 0;\n        if (ct == \"extend\")\n            return this.getExtend(row, col).length == 0;\n        return false;\n    }\n    notBlank(row, col) {\n        return !this.isBlank(row, col);\n    }\n    getObject(row, col) {\n        if (typeof col === 'string')\n            col = this.findColByName(col);\n        return this.data.rowData[row][col];\n    }\n    getMolecule(row, col) {\n        if (typeof col === 'string')\n            col = this.findColByName(col);\n        if (col < 0)\n            return null;\n        let datum = this.data.rowData[row][col];\n        if (datum == null)\n            return null;\n        if (typeof datum === 'string') {\n            datum = _Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.fromString(datum);\n            this.data.rowData[row][col] = datum;\n        }\n        return datum;\n    }\n    getMoleculeClone(row, col) {\n        let mol = this.getMolecule(row, col);\n        return mol == null ? null : mol.clone();\n    }\n    getMoleculeBlank(row, col) {\n        let mol = this.getMolecule(row, col);\n        return mol ? mol : new _Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule();\n    }\n    getString(row, col) {\n        if (typeof col === 'string')\n            col = this.findColByName(col);\n        if (col < 0)\n            return null;\n        let str = this.data.rowData[row][col];\n        return str == null ? '' : str;\n    }\n    getInteger(row, col) {\n        if (typeof col === 'string')\n            col = this.findColByName(col);\n        if (col < 0)\n            return null;\n        return this.data.rowData[row][col];\n    }\n    getReal(row, col) {\n        if (typeof col === 'string')\n            col = this.findColByName(col);\n        if (col < 0)\n            return null;\n        return this.data.rowData[row][col];\n    }\n    getBoolean(row, col) {\n        if (typeof col === 'string')\n            col = this.findColByName(col);\n        if (col < 0)\n            return null;\n        return this.data.rowData[row][col];\n    }\n    getExtend(row, col) {\n        if (typeof col === 'string')\n            col = this.findColByName(col);\n        if (col < 0)\n            return null;\n        return this.data.rowData[row][col];\n    }\n    setToNull(row, col) {\n        if (typeof col === 'string')\n            col = this.findColByName(col);\n        if (col < 0)\n            return;\n        this.data.rowData[row][col] = null;\n    }\n    setObject(row, col, val) {\n        if (typeof col === 'string')\n            col = this.findColByName(col);\n        if (col < 0)\n            return;\n        this.data.rowData[row][col] = val;\n    }\n    setMolecule(row, col, mol) {\n        if (typeof col === 'string')\n            col = this.findColByName(col);\n        if (col < 0)\n            return;\n        this.data.rowData[row][col] = mol ? mol.clone() : null;\n    }\n    setString(row, col, val) {\n        if (typeof col === 'string')\n            col = this.findColByName(col);\n        if (col < 0)\n            return;\n        this.data.rowData[row][col] = val;\n    }\n    setInteger(row, col, val) {\n        if (typeof col === 'string')\n            col = this.findColByName(col);\n        if (col < 0)\n            return;\n        this.data.rowData[row][col] = val;\n    }\n    setReal(row, col, val) {\n        if (typeof col === 'string')\n            col = this.findColByName(col);\n        if (col < 0)\n            return;\n        this.data.rowData[row][col] = val;\n    }\n    setBoolean(row, col, val) {\n        if (typeof col === 'string')\n            col = this.findColByName(col);\n        if (col < 0)\n            return;\n        this.data.rowData[row][col] = val;\n    }\n    setExtend(row, col, val) {\n        if (typeof col === 'string')\n            col = this.findColByName(col);\n        if (col < 0)\n            return;\n        this.data.rowData[row][col] = val;\n    }\n    isEqualMolecule(row, col, mol) {\n        if (typeof col === 'string')\n            col = this.findColByName(col);\n        if (this.isNull(row, col) != (mol == null))\n            return false;\n        if (mol == null)\n            return true;\n        return this.getMolecule(row, col).compareTo(mol) == 0;\n    }\n    isEqualString(row, col, val) {\n        if (typeof col === 'string')\n            col = this.findColByName(col);\n        if (this.isNull(row, col) != (val == null || val == ''))\n            return false;\n        if (val == null || val == '')\n            return true;\n        return this.getString(row, col) == val;\n    }\n    isEqualInteger(row, col, val) {\n        if (typeof col === 'string')\n            col = this.findColByName(col);\n        if (this.isNull(row, col) != (val == null))\n            return false;\n        if (val == null)\n            return true;\n        return this.getInteger(row, col) == val;\n    }\n    isEqualReal(row, col, val) {\n        if (typeof col === 'string')\n            col = this.findColByName(col);\n        if (this.isNull(row, col) != (val == null))\n            return false;\n        if (val == null)\n            return true;\n        return this.getReal(row, col) == val;\n    }\n    isEqualBoolean(row, col, val) {\n        if (typeof col === 'string')\n            col = this.findColByName(col);\n        if (this.isNull(row, col) != (val == null))\n            return false;\n        if (val == null)\n            return true;\n        return this.getBoolean(row, col) == val;\n    }\n    appendColumn(name, type, descr) {\n        this.data.numCols++;\n        this.data.colData.push({ 'name': name, 'type': type, 'descr': descr });\n        for (let n = 0; n < this.data.numRows; n++)\n            this.data.rowData[n].push(null);\n        return this.data.numCols - 1;\n    }\n    insertColumn(col, name, type, descr) {\n        this.data.numCols++;\n        this.data.colData.splice(col, 0, { 'name': name, 'type': type, 'descr': descr });\n        for (let n = 0; n < this.data.numRows; n++)\n            this.data.rowData[n].splice(col, 0, null);\n    }\n    deleteColumn(col) {\n        this.data.numCols--;\n        this.data.colData.splice(col, 1);\n        for (let n = 0; n < this.data.numRows; n++)\n            this.data.rowData[n].splice(col, 1);\n    }\n    changeColumnName(col, name, descr) {\n        this.data.colData[col].name = name;\n        this.data.colData[col].descr = descr;\n    }\n    changeColumnType(col, newType) {\n        let oldType = this.colType(col);\n        if (oldType == newType)\n            return;\n        let incompatible = oldType == \"molecule\" || newType == \"molecule\" ||\n            oldType == \"extend\" || newType == \"extend\";\n        for (let n = this.data.rowData.length - 1; n >= 0; n--) {\n            let row = this.data.rowData[n];\n            if (row[col] == null)\n                continue;\n            if (incompatible) {\n                row[col] = null;\n                continue;\n            }\n            let val = '';\n            if (oldType == \"string\")\n                val = row[col];\n            else if (oldType == \"integer\")\n                val = row[col].toString();\n            else if (oldType == \"real\")\n                val = row[col].toString();\n            else if (oldType == \"boolean\")\n                val = row[col] ? 'true' : 'false';\n            row[col] = null;\n            if (newType == \"string\")\n                row[col] = val;\n            else if (newType == \"integer\") {\n                let num = parseInt(val);\n                row[col] = isFinite(num) ? num : null;\n            }\n            else if (newType == \"real\") {\n                let num = parseFloat(val);\n                row[col] = isFinite(num) ? num : null;\n            }\n            else if (newType == \"boolean\")\n                row[col] = val.toLowerCase() == 'true' ? true : false;\n        }\n        this.data.colData[col].type = newType;\n    }\n    ensureColumn(name, type, descr) {\n        for (let n = 0; n < this.data.numCols; n++)\n            if (this.data.colData[n].name == name) {\n                if (this.data.colData[n].type != type)\n                    this.changeColumnType(n, type);\n                this.data.colData[n].descr = descr;\n                return n;\n            }\n        return this.appendColumn(name, type, descr);\n    }\n    reorderColumns(order) {\n        let identity = true;\n        for (let n = 0; n < order.length - 1; n++)\n            if (order[n] != order[n + 1] - 1) {\n                identity = false;\n                break;\n            }\n        if (identity)\n            return;\n        this.data.colData = _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.idxGet(this.data.colData, order);\n        for (let n = 0; n < this.data.numRows; n++)\n            this.data.rowData[n] = _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.idxGet(this.data.rowData[n], order);\n    }\n    appendRow() {\n        this.data.numRows++;\n        let row = new Array();\n        for (let n = 0; n < this.data.numCols; n++)\n            row.push(null);\n        this.data.rowData.push(row);\n        return this.data.numRows - 1;\n    }\n    appendRowFrom(srcDS, row) {\n        this.data.numRows++;\n        this.data.rowData.push(srcDS.data.rowData[row].slice(0));\n        return this.data.numRows - 1;\n    }\n    insertRow(row) {\n        this.data.numRows++;\n        let data = new Array();\n        for (let n = 0; n < this.data.numCols; n++)\n            data.push(null);\n        this.data.rowData.splice(row, 0, data);\n    }\n    deleteRow(row) {\n        this.data.numRows--;\n        this.data.rowData.splice(row, 1);\n    }\n    deleteAllRows() {\n        this.data.numRows = 0;\n        this.data.rowData = new Array();\n    }\n    moveRowUp(row) {\n        let data = this.data.rowData[row];\n        this.data.rowData[row] = this.data.rowData[row - 1];\n        this.data.rowData[row - 1] = data;\n    }\n    moveRowDown(row) {\n        let data = this.data.rowData[row];\n        this.data.rowData[row] = this.data.rowData[row + 1];\n        this.data.rowData[row + 1] = data;\n    }\n    swapRows(row1, row2) {\n        _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.swap(this.data.rowData, row1, row2);\n    }\n    exciseSingleRow(row) {\n        let newData = {\n            'title': this.data.title,\n            'description': this.data.description,\n            'numCols': this.data.numCols,\n            'numRows': 1,\n            'numExtens': this.data.numExtens,\n            'colData': this.data.colData.slice(0),\n            'rowData': [this.data.rowData[row].slice(0)],\n            'extData': this.data.extData.slice(0)\n        };\n        return new DataSheet(newData);\n    }\n    colIsPrimitive(col) {\n        if (typeof col === 'string')\n            col = this.findColByName(col);\n        let ct = this.data.colData[col].type;\n        return ct == 'string' || ct == 'real' || ct == 'integer' || ct == 'boolean';\n    }\n    findColByName(name, type) {\n        for (let n = 0; n < this.data.numCols; n++)\n            if (this.data.colData[n].name == name) {\n                if (type == null || this.data.colData[n].type == type)\n                    return n;\n            }\n        return -1;\n    }\n    firstColOfType(type) {\n        for (let n = 0; n < this.data.numCols; n++)\n            if (this.data.colData[n].type == type)\n                return n;\n        return -1;\n    }\n    copyCell(toRow, toCol, fromDS, fromRow, fromCol) {\n        this.setToNull(toRow, toCol);\n        if (fromDS.isNull(fromRow, fromCol))\n            return;\n        let obj = fromDS.getObject(fromRow, fromCol);\n        this.setObject(toRow, toCol, DataSheet.convertType(obj, fromDS.colType(fromCol), this.colType(toCol)));\n    }\n    static convertType(obj, fromType, toType) {\n        const ft = fromType, tt = toType;\n        if (obj == null || ft == tt || (typeof obj == 'string' && obj == ''))\n            return obj;\n        if (tt == \"string\") {\n            if (ft == \"integer\")\n                return obj.toString();\n            else if (ft == \"real\")\n                return obj.toString();\n            else if (ft == \"boolean\")\n                return obj ? 'true' : 'false';\n        }\n        else if (tt == \"real\") {\n            if (ft == \"string\")\n                return (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.safeFloat)(obj, null);\n            else if (ft == \"integer\")\n                return obj;\n            else if (ft == \"boolean\")\n                return obj ? 1 : 0;\n        }\n        else if (tt == \"integer\") {\n            if (ft == \"string\")\n                return (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.safeInt)(obj, null);\n            else if (ft == \"real\")\n                return Math.round(obj);\n            else if (ft == \"boolean\")\n                return obj ? 1 : 0;\n        }\n        else if (tt == \"boolean\") {\n            if (ft == \"string\")\n                return obj.toLowerCase() == 'true';\n            else if (ft == \"integer\")\n                return obj > 0;\n            else if (ft == \"real\")\n                return obj >= 0.5;\n        }\n        return null;\n    }\n    toString(row, col) {\n        if (typeof col === 'string')\n            col = this.findColByName(col);\n        let obj = this.data.rowData[row][col];\n        return obj == null ? null : obj.toString();\n    }\n    toInt(row, col) {\n        if (!this.colIsPrimitive(col))\n            return null;\n        let obj = this.data.rowData[row][col];\n        return obj == null ? null : parseInt(obj);\n    }\n    toReal(row, col) {\n        if (!this.colIsPrimitive(col))\n            return null;\n        let obj = this.data.rowData[row][col];\n        return obj == null ? null : parseFloat(obj);\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/data/DataSheet.ts?");

/***/ }),

/***/ "./src/data/DataSheetStream.ts":
/*!*************************************!*\
  !*** ./src/data/DataSheetStream.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DataSheetStream\": () => (/* binding */ DataSheetStream)\n/* harmony export */ });\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _util_XML__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/XML */ \"./src/util/XML.ts\");\n/* harmony import */ var _DataSheet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DataSheet */ \"./src/data/DataSheet.ts\");\n/* harmony import */ var _Molecule__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Molecule */ \"./src/data/Molecule.ts\");\n/* harmony import */ var _MoleculeStream__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MoleculeStream */ \"./src/data/MoleculeStream.ts\");\n\n\n\n\n\nclass DataSheetStream {\n    static readXML(strXML) {\n        let xmlDoc;\n        if (_util_XML__WEBPACK_IMPORTED_MODULE_1__.XML.customParser)\n            xmlDoc = new _util_XML__WEBPACK_IMPORTED_MODULE_1__.XML.customParser().parseFromString(strXML, 'application/xml');\n        else\n            xmlDoc = new DOMParser().parseFromString(strXML, 'application/xml');\n        if (xmlDoc == null)\n            return null;\n        let root = xmlDoc.documentElement;\n        if (root == null)\n            return null;\n        let ds = new _DataSheet__WEBPACK_IMPORTED_MODULE_2__.DataSheet();\n        let summary = (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.findNode)(root, 'Summary');\n        if (summary == null)\n            return null;\n        ds.title = (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.nodeText)((0,_util_util__WEBPACK_IMPORTED_MODULE_0__.findNode)(summary, 'Title'));\n        ds.description = (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.nodeText)((0,_util_util__WEBPACK_IMPORTED_MODULE_0__.findNode)(summary, 'Description'));\n        let extRoot = (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.findNode)(root, 'Extension');\n        if (extRoot != null) {\n            let extList = (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.findNodes)(extRoot, 'Ext');\n            for (let n = 0; n < extList.length; n++) {\n                let ext = extList[n];\n                ds.appendExtension(ext.getAttribute('name'), ext.getAttribute('type'), (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.nodeText)(ext));\n            }\n        }\n        let header = (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.findNode)(root, 'Header');\n        let numCols = parseInt(header.getAttribute('ncols'));\n        let colList = (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.findNodes)(header, 'Column');\n        if (colList.length != numCols)\n            return null;\n        for (let n = 0; n < numCols; n++) {\n            let col = colList[n];\n            let id = parseInt(col.getAttribute('id'));\n            if (id != n + 1)\n                return null;\n            ds.appendColumn(col.getAttribute('name'), col.getAttribute('type'), (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.nodeText)(col));\n        }\n        let rowidx = 0;\n        for (let row of (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.findNodes)((0,_util_util__WEBPACK_IMPORTED_MODULE_0__.findNode)(root, 'Content'), 'Row')) {\n            if (parseInt(row.getAttribute('id')) != rowidx + 1)\n                return null;\n            ds.appendRow();\n            for (let col of (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.findNodes)(row, 'Cell')) {\n                let colidx = parseInt(col.getAttribute('id')) - 1;\n                let ct = ds.colType(colidx), val = (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.nodeText)(col);\n                if (val == '') { }\n                else if (ct == \"molecule\")\n                    ds.setObject(rowidx, colidx, val);\n                else if (ct == \"string\")\n                    ds.setString(rowidx, colidx, val);\n                else if (ct == \"real\")\n                    ds.setReal(rowidx, colidx, parseFloat(val));\n                else if (ct == \"integer\")\n                    ds.setInteger(rowidx, colidx, parseInt(val));\n                else if (ct == \"boolean\")\n                    ds.setBoolean(rowidx, colidx, val == 'true' ? true : val == 'false' ? false : null);\n                else if (ct == \"extend\")\n                    ds.setExtend(rowidx, colidx, val);\n                col = col.nextElementSibling;\n                colidx++;\n            }\n            row = row.nextElementSibling;\n            rowidx++;\n        }\n        return ds;\n    }\n    static readJSON(json) {\n        if (!json.colData || !json.rowData)\n            throw 'Not a JSON-formatted datasheet.';\n        return new _DataSheet__WEBPACK_IMPORTED_MODULE_2__.DataSheet((0,_util_util__WEBPACK_IMPORTED_MODULE_0__.deepClone)(json));\n    }\n    static writeXML(ds) {\n        let xml;\n        if (_util_XML__WEBPACK_IMPORTED_MODULE_1__.XML.customParser)\n            xml = new _util_XML__WEBPACK_IMPORTED_MODULE_1__.XML.customParser().parseFromString('<DataSheet/>', 'application/xml');\n        else\n            xml = new DOMParser().parseFromString('<DataSheet/>', 'application/xml');\n        let summary = xml.createElement('Summary');\n        xml.documentElement.appendChild(summary);\n        let title = xml.createElement('Title'), descr = xml.createElement('Description');\n        summary.appendChild(title);\n        title.appendChild(xml.createTextNode(ds.title));\n        summary.appendChild(descr);\n        descr.appendChild(xml.createCDATASection(ds.description));\n        let extension = xml.createElement('Extension');\n        xml.documentElement.appendChild(extension);\n        for (let n = 0; n < ds.numExtensions; n++) {\n            let ext = xml.createElement('Ext');\n            extension.appendChild(ext);\n            ext.setAttribute('name', ds.getExtName(n));\n            ext.setAttribute('type', ds.getExtType(n));\n            ext.appendChild(xml.createCDATASection(ds.getExtData(n)));\n        }\n        let header = xml.createElement('Header');\n        xml.documentElement.appendChild(header);\n        header.setAttribute('nrows', ds.numRows.toString());\n        header.setAttribute('ncols', ds.numCols.toString());\n        for (let n = 0; n < ds.numCols; n++) {\n            let column = xml.createElement('Column');\n            header.appendChild(column);\n            column.setAttribute('id', (n + 1).toString());\n            column.setAttribute('name', ds.colName(n));\n            column.setAttribute('type', ds.colType(n));\n            column.appendChild(xml.createTextNode(ds.colDescr(n)));\n        }\n        let content = xml.createElement('Content');\n        xml.documentElement.appendChild(content);\n        for (let r = 0; r < ds.numRows; r++) {\n            let row = xml.createElement('Row');\n            row.setAttribute('id', (r + 1).toString());\n            content.appendChild(row);\n            for (let c = 0; c < ds.numCols; c++) {\n                let cell = xml.createElement('Cell');\n                cell.setAttribute('id', (c + 1).toString());\n                row.appendChild(cell);\n                let ct = ds.colType(c);\n                let txtNode = null;\n                if (ds.isNull(r, c)) { }\n                else if (ct == \"molecule\") {\n                    let obj = ds.getObject(r, c);\n                    if (obj instanceof _Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule)\n                        obj = _MoleculeStream__WEBPACK_IMPORTED_MODULE_4__.MoleculeStream.writeNative(obj);\n                    txtNode = xml.createCDATASection(obj);\n                }\n                else if (ct == \"string\")\n                    txtNode = xml.createCDATASection(ds.getString(r, c));\n                else if (ct == \"real\")\n                    txtNode = xml.createTextNode(ds.getReal(r, c).toString());\n                else if (ct == \"integer\")\n                    txtNode = xml.createTextNode(ds.getInteger(r, c).toString());\n                else if (ct == \"boolean\")\n                    txtNode = xml.createTextNode(ds.getBoolean(r, c).toString());\n                else if (ct == \"extend\")\n                    txtNode = xml.createCDATASection(ds.getExtend(r, c));\n                if (txtNode != null)\n                    cell.appendChild(txtNode);\n            }\n        }\n        if (_util_XML__WEBPACK_IMPORTED_MODULE_1__.XML.customSerial)\n            return new _util_XML__WEBPACK_IMPORTED_MODULE_1__.XML.customSerial().serializeToString(xml.documentElement);\n        else\n            return new XMLSerializer().serializeToString(xml.documentElement);\n    }\n    static writeJSON(ds) {\n        let data = ds.data;\n        let nrow = ds.numRows, ncol = ds.numCols;\n        let rowData = new Array(nrow);\n        for (let n = 0; n < nrow; n++)\n            rowData[n] = new Array(ncol);\n        for (let c = 0; c < ncol; c++) {\n            let doConvert = ds.colType(c) == \"molecule\";\n            for (let r = 0; r < nrow; r++) {\n                let val = data.rowData[r][c];\n                if (val != null && doConvert)\n                    val = val.toString();\n                rowData[r][c] = val;\n            }\n        }\n        let json = {\n            'title': data.title,\n            'description': data.description,\n            'colData': (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.deepClone)(data.colData),\n            'rowData': rowData,\n            'extData': (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.deepClone)(data.extData),\n        };\n        return json;\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/data/DataSheetStream.ts?");

/***/ }),

/***/ "./src/data/DotPath.ts":
/*!*****************************!*\
  !*** ./src/data/DotPath.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DotPath\": () => (/* binding */ DotPath),\n/* harmony export */   \"DotPathBond\": () => (/* binding */ DotPathBond),\n/* harmony export */   \"DotPathCharge\": () => (/* binding */ DotPathCharge)\n/* harmony export */ });\n/* harmony import */ var _Chemistry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Chemistry */ \"./src/data/Chemistry.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _ForeignMolecule__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ForeignMolecule */ \"./src/data/ForeignMolecule.ts\");\n/* harmony import */ var _Graph__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Graph */ \"./src/data/Graph.ts\");\n\n\n\n\n\nvar DotPathBond;\n(function (DotPathBond) {\n    DotPathBond[DotPathBond[\"O0\"] = 0] = \"O0\";\n    DotPathBond[DotPathBond[\"O01\"] = 1] = \"O01\";\n    DotPathBond[DotPathBond[\"O1\"] = 2] = \"O1\";\n    DotPathBond[DotPathBond[\"O12\"] = 3] = \"O12\";\n    DotPathBond[DotPathBond[\"O2\"] = 4] = \"O2\";\n    DotPathBond[DotPathBond[\"O23\"] = 5] = \"O23\";\n    DotPathBond[DotPathBond[\"O3\"] = 6] = \"O3\";\n    DotPathBond[DotPathBond[\"O3X\"] = 7] = \"O3X\";\n})(DotPathBond || (DotPathBond = {}));\nvar DotPathCharge;\n(function (DotPathCharge) {\n    DotPathCharge[DotPathCharge[\"N1X\"] = -3] = \"N1X\";\n    DotPathCharge[DotPathCharge[\"N1\"] = -2] = \"N1\";\n    DotPathCharge[DotPathCharge[\"N01\"] = -1] = \"N01\";\n    DotPathCharge[DotPathCharge[\"Z0\"] = 0] = \"Z0\";\n    DotPathCharge[DotPathCharge[\"P01\"] = 1] = \"P01\";\n    DotPathCharge[DotPathCharge[\"P1\"] = 2] = \"P1\";\n    DotPathCharge[DotPathCharge[\"P1X\"] = 3] = \"P1X\";\n})(DotPathCharge || (DotPathCharge = {}));\nclass DotPath {\n    constructor(mol) {\n        this.mol = mol;\n        this.paths = [];\n        if (mol)\n            this.calculate();\n    }\n    clone() {\n        let dup = new DotPath(null);\n        dup.mol = this.mol;\n        dup.maskBlock = this.maskBlock;\n        dup.paths = this.paths.slice(0);\n        return dup;\n    }\n    getBondOrders() {\n        const mol = this.mol;\n        let orders = [];\n        for (let n = 1; n <= mol.numBonds; n++)\n            orders.push(mol.bondOrder(n));\n        for (let path of this.paths) {\n            let fract = path.numer / path.denom;\n            for (let n = 1; n <= 5; n++)\n                if ((0,_util_util__WEBPACK_IMPORTED_MODULE_1__.fltEqual)(fract, n))\n                    fract = n;\n            for (let b of path.bonds)\n                orders[b - 1] = fract;\n        }\n        return orders;\n    }\n    getBondClasses() {\n        const mol = this.mol;\n        let classes = [];\n        for (let n = 1; n <= mol.numBonds; n++) {\n            let bo = mol.bondOrder(n);\n            classes.push(bo == 0 ? 0 :\n                bo == 1 ? 2 :\n                    bo == 2 ? 4 :\n                        bo == 3 ? 6 : 7);\n        }\n        for (let path of this.paths) {\n            let fract = path.numer / path.denom;\n            let bcls = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.fltEqual)(fract, 0) ? 0 :\n                (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.fltEqual)(fract, 1) ? 2 :\n                    (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.fltEqual)(fract, 2) ? 4 :\n                        (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.fltEqual)(fract, 3) ? 6 :\n                            fract < 1 ? 1 :\n                                fract < 2 ? 3 :\n                                    fract < 3 ? 5 : 7;\n            for (let b of path.bonds)\n                classes[b - 1] = bcls;\n        }\n        return classes;\n    }\n    getChargeClasses() {\n        const mol = this.mol;\n        let classes = [];\n        for (let n = 1; n <= mol.numAtoms; n++) {\n            let chg = mol.atomCharge(n);\n            classes.push(chg == 0 ? 0 :\n                chg == -1 ? -2 :\n                    chg == 1 ? 2 :\n                        chg < -1 ? -3 : 3);\n        }\n        for (let path of this.paths) {\n            let chg = 0;\n            for (let a of path.atoms)\n                chg += mol.atomCharge(a);\n            chg /= path.atoms.length;\n            let ccls = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.fltEqual)(chg, 0) ? 0 :\n                (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.fltEqual)(chg, -1) ? -2 :\n                    (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.fltEqual)(chg, 1) ? 2 :\n                        chg > -1 && chg < 0 ? -1 :\n                            chg > 0 && chg < 1 ? 1 :\n                                chg < -1 ? -3 : 3;\n            for (let a of path.atoms)\n                classes[a - 1] = ccls;\n        }\n        return classes;\n    }\n    getAggregateCharges() {\n        const mol = this.mol;\n        let chg = [];\n        for (let n = 1; n <= mol.numAtoms; n++)\n            chg[n - 1] = mol.atomCharge(n);\n        for (let path of this.paths) {\n            let total = 0;\n            for (let a of path.atoms)\n                total += chg[a - 1];\n            for (let a of path.atoms)\n                chg[a - 1] = total;\n        }\n        return chg;\n    }\n    toString() {\n        let str = 'blocking=' + JSON.stringify(this.maskBlock) + '; paths=' + this.paths.length;\n        for (let p of this.paths)\n            str += ' [' + p.numer + '/' + p.denom + ';a=' + JSON.stringify(p.atoms) + ';b=' + JSON.stringify(p.bonds) + ']';\n        return str;\n    }\n    calculate() {\n        const mol = this.mol, na = mol.numAtoms, nb = mol.numBonds;\n        let nonsingle = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.booleanArray(false, na), pibonded = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.booleanArray(false, na), metalbonded = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.booleanArray(false, na);\n        let bondsum = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.numberArray(0, na);\n        for (let n = 0; n < na; n++)\n            bondsum[n] = mol.atomHydrogens(n + 1);\n        for (let n = 1; n <= nb; n++) {\n            let bo = mol.bondOrder(n), bfr = mol.bondFrom(n), bto = mol.bondTo(n);\n            if (bo != 1) {\n                nonsingle[bfr - 1] = true;\n                nonsingle[bto - 1] = true;\n            }\n            if (bo >= 2) {\n                pibonded[bfr - 1] = true;\n                pibonded[bto - 1] = true;\n            }\n            else {\n                let blk1 = _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_BLOCKS[mol.atomicNumber(bfr)], blk2 = _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_BLOCKS[mol.atomicNumber(bto)];\n                if (blk1 >= 3 || blk2 >= 3) {\n                    metalbonded[bfr - 1] = true;\n                    metalbonded[bto - 1] = true;\n                }\n            }\n            bondsum[bfr - 1] += bo;\n            bondsum[bto - 1] += bo;\n            if (mol.bondTransient(n).indexOf(_ForeignMolecule__WEBPACK_IMPORTED_MODULE_3__.ForeignMoleculeExtra.BondAromatic) >= 0) {\n                pibonded[bfr - 1] = true;\n                pibonded[bto - 1] = true;\n            }\n        }\n        let impliedPi = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.booleanArray(false, na);\n        for (let n = 1; n <= na; n++)\n            if (!pibonded[n - 1]) {\n                let adjpi = 0;\n                for (let adj of mol.atomAdjList(n))\n                    if (pibonded[adj - 1] || metalbonded[adj - 1])\n                        adjpi++;\n                if (adjpi >= 2)\n                    impliedPi[n - 1] = true;\n            }\n        for (let n = 0; n < na; n++)\n            if (impliedPi[n])\n                pibonded[n] = true;\n        this.maskBlock = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.booleanArray(false, na);\n        let maskMaybe = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.booleanArray(false, na);\n        const COULD_BLOCK = [\n            _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_H,\n            _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_B, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_C, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_N, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_O, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_F,\n            _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_Al, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_Si, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_P, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_S, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_Cl,\n            _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_Ga, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_Ge, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_As, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_Se, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_Br,\n            _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_In, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_Sn, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_Sb, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_Te, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_I,\n            _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_Tl, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_Pb, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_Bi, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_Po, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_At,\n        ];\n        const ACIDS = [\n            _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_B,\n            _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_Al, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_Si,\n            _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_Ga, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_Ge,\n            _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_In, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_Sn,\n            _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_Tl, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_Pb,\n        ];\n        const BASES = [\n            _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_N, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_O, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_F,\n            _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_P, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_S, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_Cl,\n            _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_As, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_Se, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_Br,\n            _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_Sb, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_Te, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_I,\n            _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_Bi, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_Po, _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_At,\n        ];\n        skip: for (let n = 0; n < na; n++) {\n            const a = n + 1;\n            if (nonsingle[n] || pibonded[n])\n                continue;\n            if (mol.atomCharge(a) != 0 || mol.atomUnpaired(a) != 0)\n                continue;\n            const atno = mol.atomicNumber(a);\n            if (atno == 0) {\n                this.maskBlock[n] = true;\n                continue;\n            }\n            if (COULD_BLOCK.indexOf(atno) < 0)\n                continue;\n            if (bondsum[n] != _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_BONDING[atno])\n                continue;\n            if (ACIDS.indexOf(atno) >= 0) {\n                for (let adj of mol.atomAdjList(a))\n                    if (BASES.indexOf(mol.atomicNumber(adj)) >= 0)\n                        continue skip;\n            }\n            if (BASES.indexOf(atno) >= 0) {\n                for (let adj of mol.atomAdjList(a))\n                    if (ACIDS.indexOf(mol.atomicNumber(adj)) >= 0)\n                        continue skip;\n            }\n            maskMaybe[n] = true;\n            if (atno == _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_C) {\n                let hasMetal = false;\n                for (let adj of mol.atomAdjList(a))\n                    if (COULD_BLOCK.indexOf(mol.atomicNumber(adj)) < 0)\n                        hasMetal = true;\n                if (!hasMetal)\n                    this.maskBlock[n] = true;\n            }\n            else if (atno == _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_H) {\n                this.maskBlock[n] = true;\n            }\n        }\n        skip: for (let n = 0; n < na; n++)\n            if (maskMaybe[n] && !this.maskBlock[n]) {\n                for (let a of mol.atomAdjList(n + 1))\n                    if (!maskMaybe[a - 1])\n                        continue skip;\n                this.maskBlock[n] = true;\n            }\n        let g = _Graph__WEBPACK_IMPORTED_MODULE_4__.Graph.fromMolecule(mol);\n        for (let n = 0; n < na; n++)\n            if (this.maskBlock[n])\n                g.isolateNode(n);\n        for (let cc of g.calculateComponentGroups()) {\n            if (cc.length == 1)\n                continue;\n            let amask = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.idxMask(cc, na);\n            _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.addTo(cc, 1);\n            let p = {\n                'atoms': cc,\n                'bonds': [],\n                'numer': 0,\n                'denom': 0\n            };\n            for (let n = 1; n <= nb; n++)\n                if (amask[mol.bondFrom(n) - 1] && amask[mol.bondTo(n) - 1])\n                    p.bonds.push(n);\n            let totalHave = 0, totalWant = 0;\n            for (let a of p.atoms) {\n                let others = mol.atomHydrogens(a);\n                for (let o of mol.atomAdjList(a))\n                    if (!amask[o - 1])\n                        others++;\n                let atno = mol.atomicNumber(a);\n                let have = _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_VALENCE[atno] - mol.atomCharge(a) - others;\n                let want = _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_SHELL[atno] - _Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_VALENCE[atno] - others;\n                totalHave += have;\n                totalWant += want;\n            }\n            let electrons = Math.min(totalHave, totalWant);\n            p.numer = electrons;\n            p.denom = 2 * p.bonds.length;\n            this.paths.push(p);\n        }\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/data/DotPath.ts?");

/***/ }),

/***/ "./src/data/ExperimentMeta.ts":
/*!************************************!*\
  !*** ./src/data/ExperimentMeta.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ExperimentMeta\": () => (/* binding */ ExperimentMeta),\n/* harmony export */   \"ExperimentMetaApplic\": () => (/* binding */ ExperimentMetaApplic),\n/* harmony export */   \"ExperimentMetaRoleType\": () => (/* binding */ ExperimentMetaRoleType),\n/* harmony export */   \"ExperimentMetaType\": () => (/* binding */ ExperimentMetaType),\n/* harmony export */   \"ExperimentMetaValue\": () => (/* binding */ ExperimentMetaValue)\n/* harmony export */ });\n/* harmony import */ var _MoleculeStream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MoleculeStream */ \"./src/data/MoleculeStream.ts\");\n\nvar ExperimentMetaType;\n(function (ExperimentMetaType) {\n    ExperimentMetaType[\"Role\"] = \"role\";\n    ExperimentMetaType[\"Pressure\"] = \"pressure\";\n    ExperimentMetaType[\"TurnoverNumber\"] = \"turnover_number\";\n    ExperimentMetaType[\"EnantiomericExcess\"] = \"enantiomeric_excess\";\n    ExperimentMetaType[\"Time\"] = \"time\";\n    ExperimentMetaType[\"Heat\"] = \"heat\";\n    ExperimentMetaType[\"Light\"] = \"light\";\n})(ExperimentMetaType || (ExperimentMetaType = {}));\nvar ExperimentMetaApplic;\n(function (ExperimentMetaApplic) {\n    ExperimentMetaApplic[ExperimentMetaApplic[\"Experiment\"] = 0] = \"Experiment\";\n    ExperimentMetaApplic[ExperimentMetaApplic[\"Step\"] = 1] = \"Step\";\n    ExperimentMetaApplic[ExperimentMetaApplic[\"Reactant\"] = 2] = \"Reactant\";\n    ExperimentMetaApplic[ExperimentMetaApplic[\"Reagent\"] = 3] = \"Reagent\";\n    ExperimentMetaApplic[ExperimentMetaApplic[\"Product\"] = 4] = \"Product\";\n})(ExperimentMetaApplic || (ExperimentMetaApplic = {}));\nvar ExperimentMetaValue;\n(function (ExperimentMetaValue) {\n    ExperimentMetaValue[ExperimentMetaValue[\"Boolean\"] = 0] = \"Boolean\";\n    ExperimentMetaValue[ExperimentMetaValue[\"Number\"] = 1] = \"Number\";\n    ExperimentMetaValue[ExperimentMetaValue[\"Optional\"] = 2] = \"Optional\";\n    ExperimentMetaValue[ExperimentMetaValue[\"String\"] = 3] = \"String\";\n})(ExperimentMetaValue || (ExperimentMetaValue = {}));\nvar ExperimentMetaRoleType;\n(function (ExperimentMetaRoleType) {\n    ExperimentMetaRoleType[\"Reagent\"] = \"reagent\";\n    ExperimentMetaRoleType[\"Catalyst\"] = \"catalyst\";\n    ExperimentMetaRoleType[\"Solvent\"] = \"solvent\";\n})(ExperimentMetaRoleType || (ExperimentMetaRoleType = {}));\nclass ExperimentMeta {\n    static unpackMeta(str) {\n        if (!str)\n            return [];\n        let list = [];\n        for (let line of str.split('\\n'))\n            if (line) {\n                let eq = line.indexOf('=');\n                let type = _MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(eq < 0 ? line : line.substring(0, eq));\n                let value = eq < 0 ? null : _MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skUnescape(line.substring(eq + 1));\n                let vtype = this.VALUES[type];\n                if (value != null && (vtype == ExperimentMetaValue.Number || vtype == ExperimentMetaValue.Optional))\n                    value = parseFloat(value);\n                list.push([type, value]);\n            }\n        return list;\n    }\n    static packMeta(list) {\n        let lines = [];\n        for (let [type, value] of list) {\n            if (value == null)\n                lines.push(_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(type));\n            else\n                lines.push(_MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(type) + '=' + _MoleculeStream__WEBPACK_IMPORTED_MODULE_0__.MoleculeStream.skEscape(value.toString()));\n        }\n        return lines.join('\\n');\n    }\n    static withMetaKey(metastr, type, value) {\n        let list = this.unpackMeta(metastr);\n        let item = list.find((look) => look[0] == type);\n        if (value != null) {\n            if (item)\n                item[1] = value;\n            else\n                list.push([type, value]);\n        }\n        else {\n            list = list.filter((look) => look[0] != type);\n        }\n        return this.packMeta(list);\n    }\n    static describeMeta(type, value) {\n        let formatFloat = (val, maxSigFig) => {\n            if (val == null)\n                return '';\n            if (val == 0)\n                return '0';\n            let digits = Math.ceil(-Math.log10(Math.abs(val)));\n            digits = Math.max(0, Math.max(digits, maxSigFig));\n            let str = val.toFixed(digits);\n            if (str.indexOf('.') < 0)\n                return str;\n            while (str.endsWith('0'))\n                str = str.substring(0, str.length - 1);\n            if (str.endsWith('.'))\n                str = str.substring(0, str.length - 1);\n            return str;\n        };\n        if (type == ExperimentMetaType.Role) {\n            if (!value)\n                return null;\n            return `role: ${value}`;\n        }\n        else if (type == ExperimentMetaType.Pressure) {\n            if (value == null)\n                return null;\n            return `${formatFloat(value, 2)} atm`;\n        }\n        else if (type == ExperimentMetaType.TurnoverNumber) {\n            if (value == null)\n                return null;\n            return `${formatFloat(value, 2)} turnover${value == 1 ? '' : 's'}`;\n        }\n        else if (type == ExperimentMetaType.EnantiomericExcess) {\n            if (value == null)\n                return null;\n            return `${formatFloat(value, 2)}% ee`;\n        }\n        else if (type == ExperimentMetaType.Time) {\n            if (value == null)\n                return null;\n            if (value < 1) {\n                let mins = value * 60;\n                return `${formatFloat(mins, 2)} min${mins == 1 ? '' : 's'}`;\n            }\n            else\n                return `${formatFloat(value, 2)} hour${value == 1 ? '' : 's'}`;\n        }\n        else if (type == ExperimentMetaType.Heat) {\n            if (value == null)\n                return '\\u{0394}';\n            return `${formatFloat(value, 2)} \\u{00B0}C`;\n        }\n        else if (type == ExperimentMetaType.Light) {\n            if (value == null)\n                return 'h\\u{03BD}';\n            return `${formatFloat(value, 2)} nm`;\n        }\n        return null;\n    }\n}\nExperimentMeta.APPLICABILITY = {\n    [ExperimentMetaType.Role]: [ExperimentMetaApplic.Reagent],\n    [ExperimentMetaType.Pressure]: [ExperimentMetaApplic.Reactant, ExperimentMetaApplic.Reagent],\n    [ExperimentMetaType.TurnoverNumber]: [ExperimentMetaApplic.Reagent],\n    [ExperimentMetaType.EnantiomericExcess]: [ExperimentMetaApplic.Product],\n    [ExperimentMetaType.Time]: [ExperimentMetaApplic.Step],\n    [ExperimentMetaType.Heat]: [ExperimentMetaApplic.Step],\n    [ExperimentMetaType.Light]: [ExperimentMetaApplic.Step],\n};\nExperimentMeta.NAMES = {\n    [ExperimentMetaType.Role]: 'Role',\n    [ExperimentMetaType.Pressure]: 'Pressure',\n    [ExperimentMetaType.TurnoverNumber]: 'Turnover Number',\n    [ExperimentMetaType.EnantiomericExcess]: 'Enantiomeric Excess',\n    [ExperimentMetaType.Time]: 'Time',\n    [ExperimentMetaType.Heat]: 'Heat',\n    [ExperimentMetaType.Light]: 'Light',\n};\nExperimentMeta.UNITS = {\n    [ExperimentMetaType.Pressure]: 'atm',\n    [ExperimentMetaType.TurnoverNumber]: null,\n    [ExperimentMetaType.EnantiomericExcess]: '%',\n    [ExperimentMetaType.Time]: 'hr',\n    [ExperimentMetaType.Heat]: '\\u{00B0}C',\n    [ExperimentMetaType.Light]: 'nm',\n};\nExperimentMeta.VALUES = {\n    [ExperimentMetaType.Role]: ExperimentMetaValue.String,\n    [ExperimentMetaType.Pressure]: ExperimentMetaValue.Number,\n    [ExperimentMetaType.TurnoverNumber]: ExperimentMetaValue.Number,\n    [ExperimentMetaType.EnantiomericExcess]: ExperimentMetaValue.Number,\n    [ExperimentMetaType.Time]: ExperimentMetaValue.Number,\n    [ExperimentMetaType.Heat]: ExperimentMetaValue.Optional,\n    [ExperimentMetaType.Light]: ExperimentMetaValue.Optional,\n};\n\n\n//# sourceURL=webpack://WebMolKit/./src/data/ExperimentMeta.ts?");

/***/ }),

/***/ "./src/data/ForeignMolecule.ts":
/*!*************************************!*\
  !*** ./src/data/ForeignMolecule.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ForeignMolecule\": () => (/* binding */ ForeignMolecule),\n/* harmony export */   \"ForeignMoleculeExtra\": () => (/* binding */ ForeignMoleculeExtra)\n/* harmony export */ });\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n\nvar ForeignMoleculeExtra;\n(function (ForeignMoleculeExtra) {\n    ForeignMoleculeExtra[\"AtomAromatic\"] = \"yAROMATIC\";\n    ForeignMoleculeExtra[\"BondAromatic\"] = \"yAROMATIC\";\n    ForeignMoleculeExtra[\"AtomChiralMDLOdd\"] = \"yCHIRAL_MDL_ODD\";\n    ForeignMoleculeExtra[\"AtomChiralMDLEven\"] = \"yCHIRAL_MDL_EVEN\";\n    ForeignMoleculeExtra[\"AtomChiralMDLRacemic\"] = \"yCHIRAL_MDL_RACEMIC\";\n})(ForeignMoleculeExtra || (ForeignMoleculeExtra = {}));\nclass ForeignMolecule {\n    static noteAromaticAtoms(mol) {\n        const sz = mol.numAtoms;\n        let mask = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.booleanArray(false, sz);\n        for (let n = 1; n <= sz; n++)\n            mask[n - 1] = mol.atomTransient(n).indexOf(ForeignMoleculeExtra.AtomAromatic) >= 0;\n        return mask;\n    }\n    static noteAromaticBonds(mol) {\n        const sz = mol.numBonds;\n        let mask = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.booleanArray(false, sz);\n        for (let n = 1; n <= sz; n++)\n            mask[n - 1] = mol.bondTransient(n).indexOf(ForeignMoleculeExtra.BondAromatic) >= 0;\n        return mask;\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/data/ForeignMolecule.ts?");

/***/ }),

/***/ "./src/data/FormatList.ts":
/*!********************************!*\
  !*** ./src/data/FormatList.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FormatList\": () => (/* binding */ FormatList)\n/* harmony export */ });\nclass FormatList {\n}\nFormatList.FMT_NATIVE = 'native';\nFormatList.FMT_XMLDS = 'xmlds';\nFormatList.FMT_MDLMOL = 'mdlmol';\nFormatList.FMT_MDLSDF = 'mdlsdf';\nFormatList.FMT_MDLRDF = 'mdlrdf';\nFormatList.FMT_MDLRXN = 'mdlrxn';\nFormatList.GFX_PNG = 'png';\nFormatList.GFX_PNGZIP = 'pngzip';\nFormatList.GFX_SVG = 'svg';\nFormatList.GFX_SVGZIP = 'svgzip';\nFormatList.GFX_PDF = 'pdf';\nFormatList.GFX_PDFZIP = 'pdfzip';\nFormatList.GFX_EPS = 'eps';\nFormatList.GFX_HTML = 'html';\nFormatList.GFX_OPENDOC_ODG = 'odg';\nFormatList.GFX_OPENDOC_ODT = 'odt';\nFormatList.GFX_OPENDOC_ODS = 'ods';\nFormatList.GFX_OOXML_DOCX = 'docx';\nFormatList.GFX_OOXML_XLSX = 'xlsx';\nFormatList.FORMAT_DESCR = {\n    'native': 'SketchEl Molecule',\n    'xmlds': 'DataSheet XML',\n    'mdlmol': 'MDL MOL (single molecule)',\n    'mdlsdf': 'MDL SDF (molecules + data)',\n    'mdlrdf': 'MDL RDF (reactions + data)',\n    'mdlrxn': 'MDL RXN (single reaction)',\n    'png': 'PNG image (raster)',\n    'pngzip': 'ZIP (multiple PNG files)',\n    'svg': 'SVG picture (vector)',\n    'svgzip': 'ZIP (multiple SVG files)',\n    'pdf': 'PDF diagram (vector)',\n    'pdfzip': 'ZIP (multiple PDF files)',\n    'eps': 'Encapsulated PostScript (vector)',\n    'html': 'HTML with embedded SVG',\n    'odg': 'OpenDocument Graphic',\n    'odt': 'OpenDocument Text',\n    'ods': 'OpenDocument SpreadSheet',\n    'docx': 'Microsoft Word',\n    'xlsx': 'Microsoft Excel'\n};\nFormatList.FORMAT_EXTN = {\n    'native': '.el',\n    'xmlds': '.ds',\n    'mdlmol': '.mol',\n    'mdlsdf': '.sdf',\n    'mdlrdf': '.rdf',\n    'mdlrxn': '.rxn',\n    'png': '.png',\n    'pngzip': '_png.zip',\n    'svg': '.svg',\n    'svgzip': '_svg.zip',\n    'pdf': '.pdf',\n    'pdfzip': '_pdf.zip',\n    'eps': '.eps',\n    'html': '.html',\n    'odg': '.odg',\n    'odt': '.odt',\n    'ods': '.ods',\n    'docx': '.docx',\n    'xlsx': '.xlsx'\n};\nFormatList.FORMAT_MIMETYPE = {\n    'native': 'chemical/x-sketchel',\n    'xmlds': 'chemical/x-datasheet',\n    'mdlmol': 'chemical/x-mdl-molfile',\n    'mdlsdf': 'chemical/x-mdl-sdfile',\n    'mdlrdf': 'chemical/x-mdl-rdfile',\n    'mdlrxn': 'chemical/x-mdl-rxnfile',\n    'png': 'image/png',\n    'pngzip': 'application/zip',\n    'svg': 'image/png',\n    'svgzip': 'application/zip',\n    'pdf': 'application/pdf',\n    'pdfzip': 'application/zip',\n    'eps': 'image/eps',\n    'html': 'text/html',\n    'odg': 'application/vnd.oasis.opendocument.graphics',\n    'odt': 'application/vnd.oasis.opendocument.text',\n    'ods': 'application/vnd.oasis.opendocument.spreadsheet',\n    'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n    'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n};\n\n\n//# sourceURL=webpack://WebMolKit/./src/data/FormatList.ts?");

/***/ }),

/***/ "./src/data/Graph.ts":
/*!***************************!*\
  !*** ./src/data/Graph.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Graph\": () => (/* binding */ Graph)\n/* harmony export */ });\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n\nclass Graph {\n    constructor(sz, edge1, edge2) {\n        this.nbrs = [];\n        this.indices = null;\n        this.labels = null;\n        this.props = null;\n        if (sz != null)\n            for (let n = 0; n < sz; n++)\n                this.nbrs.push([]);\n        if (edge1 != null && edge2 != null) {\n            for (let n = 0; n < edge1.length; n++) {\n                this.nbrs[edge1[n]].push(edge2[n]);\n                this.nbrs[edge2[n]].push(edge1[n]);\n            }\n        }\n    }\n    clone() {\n        let g = new Graph();\n        for (let nbr of this.nbrs)\n            g.nbrs.push(nbr.slice(0));\n        g.indices = this.indices == null ? null : this.indices.slice(0);\n        g.labels = this.labels == null ? null : this.labels.slice(0);\n        g.props = this.props == null ? null : this.props.slice(0);\n        return g;\n    }\n    static fromMolecule(mol) {\n        let g = new Graph();\n        g.indices = [];\n        for (let n = 0; n < mol.numAtoms; n++) {\n            g.nbrs.push([]);\n            g.indices.push(n + 1);\n        }\n        for (let n = 1; n <= mol.numBonds; n++) {\n            let bfr = mol.bondFrom(n) - 1, bto = mol.bondTo(n) - 1;\n            g.nbrs[bfr].push(bto);\n            g.nbrs[bto].push(bfr);\n        }\n        return g;\n    }\n    static fromNeighbours(nbrs) {\n        let g = new Graph();\n        g.nbrs = nbrs;\n        return g;\n    }\n    toString() {\n        let buff = '#nodes=' + this.nbrs.length;\n        for (let n = 0; n < this.nbrs.length; n++) {\n            buff += ' ' + n + ':{' + this.nbrs[n] + '}';\n            if (n < _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.len(this.indices))\n                buff += '[i=' + this.indices[n] + ']';\n            if (n < _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.len(this.labels))\n                buff += '[l=' + this.labels[n] + ']';\n        }\n        return buff;\n    }\n    get numNodes() { return this.nbrs.length; }\n    numEdges(node) { return this.nbrs[node].length; }\n    getEdge(node, edge) { return this.nbrs[node][edge]; }\n    getEdges(node) { return this.nbrs[node]; }\n    getIndex(node) { return this.indices == null ? 0 : this.indices[node]; }\n    setIndex(node, idx) {\n        if (this.indices == null)\n            this.indices = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.numberArray(0, this.nbrs.length);\n        this.indices[node] = idx;\n    }\n    getLabel(node) { return this.labels == null ? null : this.labels[node]; }\n    setLabel(node, lbl) {\n        if (this.labels == null)\n            this.labels = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.stringArray('', this.nbrs.length);\n        this.labels[node] = lbl;\n    }\n    getProperty(node) { return this.props == null ? null : this.props[node]; }\n    setProperty(node, prp) {\n        if (this.props == null)\n            this.props = new Array(this.nbrs.length);\n        this.props[node] = prp;\n    }\n    addNode() {\n        this.nbrs.push([]);\n        if (this.indices != null)\n            this.indices.push(0);\n        if (this.labels != null)\n            this.labels.push('');\n        if (this.props != null)\n            this.props.push(null);\n        return this.nbrs.length - 1;\n    }\n    hasEdge(node1, node2) {\n        if (this.nbrs[node1].length <= this.nbrs[node2].length)\n            return this.nbrs[node1].indexOf(node2) >= 0;\n        else\n            return this.nbrs[node2].indexOf(node1) >= 0;\n    }\n    addEdge(node1, node2) {\n        this.nbrs[node1].push(node2);\n        this.nbrs[node2].push(node1);\n    }\n    removeEdge(node1, node2) {\n        let i1 = this.nbrs[node1].indexOf(node2), i2 = this.nbrs[node2].indexOf(node1);\n        if (i1 >= 0)\n            this.nbrs[node1].splice(i1, 1);\n        if (i2 >= 0)\n            this.nbrs[node2].splice(i2, 1);\n    }\n    isolateNode(node) {\n        for (let o of this.nbrs[node]) {\n            let i = this.nbrs[o].indexOf(node);\n            if (i >= 0)\n                this.nbrs[o].splice(i, 1);\n        }\n        this.nbrs[node] = [];\n    }\n    keepNodesMask(mask) {\n        const oldsz = this.nbrs.length, newsz = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.maskCount(mask);\n        if (newsz == oldsz)\n            return;\n        if (newsz == 0) {\n            this.nbrs = [];\n            this.indices = null;\n            this.labels = null;\n            this.props = null;\n            return;\n        }\n        let newmap = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.maskMap(mask);\n        let newnbrs = [];\n        for (let n = 0; n < newsz; n++)\n            newnbrs.push([]);\n        for (let n = 0, pos = 0; n < oldsz; n++)\n            if (mask[n]) {\n                for (let i of this.nbrs[n])\n                    if (mask[i])\n                        newnbrs[pos].push(newmap[i]);\n                pos++;\n            }\n        this.nbrs = newnbrs;\n        if (this.indices != null)\n            this.indices = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.maskGet(this.indices, mask);\n        if (this.labels != null)\n            this.labels = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.maskGet(this.labels, mask);\n        if (this.props != null)\n            this.props = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.maskGet(this.props, mask);\n    }\n    keepNodesIndex(idx) { this.keepNodesMask(_util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.idxMask(idx, this.numNodes)); }\n    removeNodesMask(mask) { this.keepNodesMask(_util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.notMask(mask)); }\n    removeNodesIndex(idx) { this.removeNodesMask(_util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.idxMask(idx, this.numNodes)); }\n    subgraphIndex(idx) {\n        const nsz = idx.length;\n        let g = new Graph(nsz);\n        if (this.indices != null || this.labels != null || this.props != null)\n            for (let n = 0; n < nsz; n++) {\n                if (this.indices != null)\n                    g.setIndex(n, this.indices[idx[n]]);\n                if (this.labels != null)\n                    g.setLabel(n, this.labels[idx[n]]);\n                if (this.props != null)\n                    g.setProperty(n, this.props[idx[n]]);\n            }\n        for (let i = 0; i < nsz; i++) {\n            for (let n of this.nbrs[idx[i]]) {\n                let j = idx.indexOf(n);\n                if (j > i)\n                    g.addEdge(i, j);\n            }\n        }\n        return g;\n    }\n    subgraphMask(mask) {\n        let g = this.clone();\n        g.keepNodesMask(mask);\n        return g;\n    }\n    calculateComponents() {\n        const sz = this.nbrs.length;\n        if (sz == 0)\n            return [];\n        let cc = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.numberArray(0, sz);\n        cc[0] = 1;\n        let first = 1, high = 1;\n        while (true) {\n            while (first < sz && cc[first] > 0) {\n                first++;\n            }\n            if (first >= sz)\n                break;\n            let anything = false;\n            for (let i = first; i < sz; i++)\n                if (cc[i] == 0) {\n                    for (let j = 0; j < this.nbrs[i].length; j++) {\n                        if (cc[this.nbrs[i][j]] != 0) {\n                            cc[i] = cc[this.nbrs[i][j]];\n                            anything = true;\n                        }\n                    }\n                }\n            if (!anything)\n                cc[first] = ++high;\n        }\n        return cc;\n    }\n    calculateComponentGroups() {\n        if (this.nbrs.length == 0)\n            return [];\n        let cc = this.calculateComponents();\n        let sz = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.max(cc);\n        let grp = [];\n        for (let n = 0; n < sz; n++)\n            grp.push([]);\n        for (let n = 0; n < cc.length; n++)\n            grp[cc[n] - 1].push(n);\n        return grp;\n    }\n    calculateRingBlocks() {\n        let sz = this.numNodes, nbrs = this.nbrs;\n        if (sz == 0)\n            return [[], 0];\n        let rblk = new Array(this.numNodes);\n        let visited = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.booleanArray(false, sz);\n        _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.setTo(rblk, 0);\n        let path = new Array(sz + 1);\n        let plen = 0, numVisited = 0;\n        while (true) {\n            let last, current;\n            if (plen == 0) {\n                last = -1;\n                for (current = 0; visited[current]; current++) { }\n            }\n            else {\n                last = path[plen - 1];\n                current = -1;\n                for (let n = 0; n < nbrs[last].length; n++)\n                    if (!visited[nbrs[last][n]]) {\n                        current = nbrs[last][n];\n                        break;\n                    }\n            }\n            if (current >= 0 && plen >= 2) {\n                let back = path[plen - 1];\n                for (let n = 0; n < nbrs[current].length; n++) {\n                    let join = nbrs[current][n];\n                    if (join != back && visited[join]) {\n                        path[plen] = current;\n                        for (let i = plen; i == plen || path[i + 1] != join; i--) {\n                            let id = rblk[path[i]];\n                            if (id == 0)\n                                rblk[path[i]] = last;\n                            else if (id != last) {\n                                for (let j = 0; j < sz; j++)\n                                    if (rblk[j] == id)\n                                        rblk[j] = last;\n                            }\n                        }\n                    }\n                }\n            }\n            if (current >= 0) {\n                visited[current] = true;\n                path[plen++] = current;\n                numVisited++;\n            }\n            else {\n                plen--;\n            }\n            if (numVisited == sz)\n                break;\n        }\n        let nextID = 0;\n        for (let i = 0; i < sz; i++)\n            if (rblk[i] > 0) {\n                nextID--;\n                for (let j = sz - 1; j >= i; j--)\n                    if (rblk[j] == rblk[i])\n                        rblk[j] = nextID;\n            }\n        for (let i = 0; i < sz; i++)\n            rblk[i] = -rblk[i];\n        return [rblk, -nextID];\n    }\n    calculateRingBlockGroups() {\n        let [rblk, sz] = this.calculateRingBlocks();\n        if (sz == 0)\n            return [];\n        let cap = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.numberArray(0, sz);\n        for (let n = 0; n < rblk.length; n++)\n            if (rblk[n] > 0)\n                cap[rblk[n] - 1]++;\n        let grp = new Array(sz);\n        for (let n = 0; n < sz; n++) {\n            grp[n] = new Array(cap[n]);\n            cap[n] = 0;\n        }\n        for (let n = 0; n < rblk.length; n++) {\n            let i = rblk[n] - 1;\n            if (i < 0)\n                continue;\n            grp[i][cap[i]++] = n;\n        }\n        return grp;\n    }\n    findRingsOfSize(size) {\n        let [rblk, num] = this.calculateRingBlocks();\n        if (num == 0)\n            return [];\n        let rings = [];\n        let mask = new Array(this.numNodes);\n        for (let r = 1; r <= num; r++) {\n            for (let n = 0; n < this.numNodes; n++)\n                mask[n] = rblk[n] == r;\n            let newRings = this.findRingsOfSizeMask(size, mask);\n            for (let n = 0; n < newRings.length; n++)\n                rings.push(newRings[n]);\n        }\n        return rings;\n    }\n    findRingsOfSizeMask(size, mask) {\n        let rings = [];\n        for (let n = 0; n < this.numNodes; n++)\n            if (mask[n]) {\n                let path = new Array(size);\n                path[0] = n;\n                this.recursiveRingFind(path, 1, size, mask, rings);\n            }\n        return rings;\n    }\n    calculateBFS(idx) {\n        let ret = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.numberArray(-1, this.numNodes);\n        ret[idx] = 0;\n        let curnum = 0, lsz = 1, watermark = 0;\n        let list = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.numberArray(0, this.numNodes);\n        list[0] = idx;\n        while (true) {\n            let newsz = lsz;\n            for (let n = watermark; n < lsz; n++) {\n                for (let i = 0; i < this.nbrs[list[n]].length; i++) {\n                    let j = this.nbrs[list[n]][i];\n                    if (ret[j] < 0) {\n                        ret[j] = curnum + 1;\n                        list[newsz++] = j;\n                    }\n                }\n            }\n            if (newsz == lsz)\n                break;\n            watermark = lsz;\n            lsz = newsz;\n            curnum++;\n        }\n        return ret;\n    }\n    calculateGravity() {\n        const sz = this.numNodes;\n        const { nbrs } = this;\n        let wght = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.numberArray(1, sz), wmod = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.numberArray(0, sz);\n        for (let n = 0; n < sz; n++) {\n            _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.setTo(wmod, wght);\n            for (let i = 0; i < sz; i++)\n                for (let j = nbrs[i].length - 1; j >= 0; j--)\n                    wmod[i] += wght[nbrs[i][j]];\n            _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.setTo(wght, wmod);\n        }\n        return wght;\n    }\n    recursiveRingFind(path, psize, capacity, mask, rings) {\n        if (psize < capacity) {\n            let last = path[psize - 1];\n            for (let n = 0; n < this.nbrs[last].length; n++) {\n                let adj = this.nbrs[last][n];\n                if (!mask[adj])\n                    continue;\n                let fnd = false;\n                for (let i = 0; i < psize; i++)\n                    if (path[i] == adj) {\n                        fnd = true;\n                        break;\n                    }\n                if (!fnd) {\n                    let newPath = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.duplicate(path);\n                    newPath[psize] = adj;\n                    this.recursiveRingFind(newPath, psize + 1, capacity, mask, rings);\n                }\n            }\n            return;\n        }\n        let last = path[psize - 1];\n        let fnd = false;\n        for (let n = 0; n < this.nbrs[last].length; n++)\n            if (this.nbrs[last][n] == path[0]) {\n                fnd = true;\n                break;\n            }\n        if (!fnd)\n            return;\n        for (let n = 0; n < path.length; n++) {\n            let count = 0, p = path[n];\n            for (let i = 0; i < this.nbrs[p].length; i++)\n                if (path.indexOf(this.nbrs[p][i]) >= 0)\n                    count++;\n            if (count != 2)\n                return;\n        }\n        let first = 0;\n        for (let n = 1; n < psize; n++)\n            if (path[n] < path[first])\n                first = n;\n        let fm = (first - 1 + psize) % psize, fp = (first + 1) % psize;\n        let flip = path[fm] < path[fp];\n        if (first != 0 || flip) {\n            let newPath = new Array(psize);\n            for (let n = 0; n < psize; n++)\n                newPath[n] = path[(first + (flip ? psize - n : n)) % psize];\n            path = newPath;\n        }\n        for (let n = 0; n < rings.length; n++) {\n            let look = rings[n];\n            let same = true;\n            for (let i = 0; i < psize; i++)\n                if (look[i] != path[i]) {\n                    same = false;\n                    break;\n                }\n            if (same)\n                return;\n        }\n        rings.push(path);\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/data/Graph.ts?");

/***/ }),

/***/ "./src/data/MDLReader.ts":
/*!*******************************!*\
  !*** ./src/data/MDLReader.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MDLMOLReader\": () => (/* binding */ MDLMOLReader),\n/* harmony export */   \"MDLMOL_VALENCE\": () => (/* binding */ MDLMOL_VALENCE),\n/* harmony export */   \"MDLSDFReader\": () => (/* binding */ MDLSDFReader)\n/* harmony export */ });\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _BondArtifact__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BondArtifact */ \"./src/data/BondArtifact.ts\");\n/* harmony import */ var _CoordUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CoordUtil */ \"./src/data/CoordUtil.ts\");\n/* harmony import */ var _DataSheet__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DataSheet */ \"./src/data/DataSheet.ts\");\n/* harmony import */ var _Molecule__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Molecule */ \"./src/data/Molecule.ts\");\n/* harmony import */ var _MolUtil__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MolUtil */ \"./src/data/MolUtil.ts\");\n/* harmony import */ var _OpenMolSpec__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./OpenMolSpec */ \"./src/data/OpenMolSpec.ts\");\n/* harmony import */ var _PolymerBlock__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./PolymerBlock */ \"./src/data/PolymerBlock.ts\");\n\n\n\n\n\n\n\n\nconst MDLMOL_VALENCE = {\n    'H': [1],\n    'B': [3],\n    'C': [4],\n    'Si': [4],\n    'N': [3],\n    'P': [3, 5],\n    'As': [3, 5],\n    'O': [2],\n    'S': [2, 4, 6],\n    'Se': [2, 4, 6],\n    'Te': [2, 4, 6],\n    'F': [1],\n    'Cl': [1, 3, 5, 7],\n    'Br': [1],\n    'I': [1, 3, 5, 7],\n    'At': [1, 3, 5, 7],\n};\nclass MDLMOLReader {\n    constructor(strData) {\n        this.parseHeader = true;\n        this.parseExtended = true;\n        this.allowV3000 = true;\n        this.considerRescale = true;\n        this.relaxed = false;\n        this.keepAromatic = false;\n        this.keepParity = false;\n        this.mol = null;\n        this.molName = '';\n        this.openmol = new _OpenMolSpec__WEBPACK_IMPORTED_MODULE_6__.OpenMolSpec();\n        this.atomHyd = null;\n        this.resBonds = null;\n        this.explicitValence = [];\n        this.groupAttachAny = new Map();\n        this.groupAttachAll = new Map();\n        this.groupStereoAbsolute = [];\n        this.groupStereoRacemic = [];\n        this.groupStereoRelative = [];\n        this.groupLinkNodes = [];\n        this.groupMixtures = [];\n        this.pos = 0;\n        this.lines = strData.split(/\\r?\\n/);\n    }\n    parse() {\n        if (this.parseHeader) {\n            this.molName = this.lines[0];\n            if (this.molName) {\n                let src = { 'row': 0, 'col': 0, 'len': this.molName.length };\n                this.openmol.add(_OpenMolSpec__WEBPACK_IMPORTED_MODULE_6__.OpenMolType.MoleculeName, null, null, [src]);\n            }\n            this.pos = 3;\n        }\n        this.parseCTAB();\n        return this.mol;\n    }\n    nextLine() {\n        if (this.pos >= this.lines.length)\n            throw 'MDL Molfile parser: premature end, at line ' + (this.pos + 1);\n        return this.lines[this.pos++];\n    }\n    parseCTAB() {\n        this.mol = new _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule();\n        this.mol.keepTransient = true;\n        let line = this.nextLine();\n        if (!this.relaxed) {\n            let version = line.length >= 39 ? line.substring(34, 39) : '';\n            if (this.allowV3000 && version == 'V3000') {\n                this.parseV3000();\n                this.openmol.derive(this.mol);\n                return;\n            }\n            if (version != 'V2000')\n                throw 'Invalid MDL MOL: no Vx000 tag.';\n        }\n        let numAtoms = parseInt(line.substring(0, 3).trim());\n        let numBonds = parseInt(line.substring(3, 6).trim());\n        for (let n = 0; n < numAtoms; n++) {\n            line = this.nextLine();\n            if (line.length < 39)\n                throw 'Invalid MDL MOL: atom line' + (n + 1);\n            let x = parseFloat(line.substring(0, 10).trim());\n            let y = parseFloat(line.substring(10, 20).trim());\n            let z = parseFloat(line.substring(20, 30).trim());\n            let el = line.substring(31, 34).trim();\n            let chg = parseInt(line.substring(36, 39).trim()), rad = 0;\n            let stereo = line.length < 42 ? 0 : parseInt(line.substring(39, 42).trim());\n            let hyd = line.length < 45 ? 0 : parseInt(line.substring(42, 45).trim());\n            let val = line.length < 51 ? 0 : parseInt(line.substring(48, 51).trim());\n            let mapnum = line.length < 63 ? 0 : parseInt(line.substring(60, 63).trim());\n            if (chg >= 1 && chg <= 3)\n                chg = 4 - chg;\n            else if (chg == 4) {\n                chg = 0;\n                rad = 2;\n            }\n            else if (chg >= 5 && chg <= 7)\n                chg = 4 - chg;\n            else\n                chg = 0;\n            let a = this.mol.addAtom(el, x, y, chg, rad);\n            if (z != 0) {\n                this.mol.setAtomZ(a, z);\n                this.mol.setIs3D(true);\n            }\n            this.mol.setAtomMapNum(a, mapnum);\n            if (hyd > 0) {\n                this.openmol.addJoin(_OpenMolSpec__WEBPACK_IMPORTED_MODULE_6__.OpenMolType.QueryHCount, [a]);\n                if (this.atomHyd == null)\n                    this.atomHyd = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.numberArray(_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.HEXPLICIT_UNKNOWN, numAtoms);\n                this.atomHyd[n] = hyd - 1;\n            }\n            if (stereo > 0 && this.keepParity) {\n            }\n            this.explicitValence.push(val);\n        }\n        for (let n = 0; n < numBonds; n++) {\n            line = this.nextLine();\n            if (line.length < 12)\n                throw 'Invalid MDL MOL: bond line' + (n + 1);\n            let bfr = parseInt(line.substring(0, 3).trim()), bto = parseInt(line.substring(3, 6).trim());\n            let type = parseInt(line.substring(6, 9).trim()), stereo = parseInt(line.substring(9, 12).trim());\n            if (bfr == bto || bfr < 1 || bfr > numAtoms || bto < 1 || bto > numAtoms)\n                throw 'Invalid MDL MOL: bond line' + (n + 1);\n            let order = type >= 1 && type <= 3 ? type : type == 8 ? 0 : 1;\n            let style = _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_NORMAL;\n            if (stereo == 1)\n                style = _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_INCLINED;\n            else if (stereo == 6)\n                style = _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_DECLINED;\n            else if (stereo == 3 || stereo == 4)\n                style = _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_UNKNOWN;\n            let b = this.mol.addBond(bfr, bto, order, style);\n            if (type == 4) {\n                let src = { 'row': this.pos - 1, 'col': 6, 'len': 3 };\n                this.openmol.addJoin(_OpenMolSpec__WEBPACK_IMPORTED_MODULE_6__.OpenMolType.QueryResonance, null, [b], [src]);\n            }\n        }\n        const MBLK_CHG = 1, MBLK_RAD = 2, MBLK_ISO = 3, MBLK_RGP = 4, MBLK_HYD = 5, MBLK_ZCH = 6, MBLK_ZBO = 7, MBLK_ZPA = 8, MBLK_ZRI = 9, MBLK_ZAR = 10;\n        let resPaths = new Map(), resRings = new Map(), arenes = new Map();\n        let superatoms = new Map(), mixtures = new Map();\n        while (true) {\n            line = this.nextLine();\n            if (line.startsWith('M  END'))\n                break;\n            let type = 0;\n            if (line.startsWith('M  CHG'))\n                type = MBLK_CHG;\n            else if (line.startsWith('M  RAD'))\n                type = MBLK_RAD;\n            else if (line.startsWith('M  ISO'))\n                type = MBLK_ISO;\n            else if (line.startsWith('M  RGP'))\n                type = MBLK_RGP;\n            else if (this.parseExtended && line.startsWith('M  HYD'))\n                type = MBLK_HYD;\n            else if (this.parseExtended && line.startsWith('M  ZCH'))\n                type = MBLK_ZCH;\n            else if (this.parseExtended && line.startsWith('M  ZBO'))\n                type = MBLK_ZBO;\n            else if (this.parseExtended && line.startsWith('M  ZPA'))\n                type = MBLK_ZPA;\n            else if (this.parseExtended && line.startsWith('M  ZRI'))\n                type = MBLK_ZRI;\n            else if (this.parseExtended && line.startsWith('M  ZAR'))\n                type = MBLK_ZAR;\n            else if (line.startsWith('A  ') && line.length >= 6) {\n                let anum = parseInt(line.substring(3, 6).trim());\n                if (anum >= 1 && anum <= this.mol.numAtoms) {\n                    line = this.nextLine();\n                    if (line == null)\n                        break;\n                    this.mol.setAtomElement(anum, line);\n                    continue;\n                }\n            }\n            else if (line.startsWith('M  STY')) {\n                let len = parseInt(line.substring(6, 9).trim());\n                for (let n = 0; n < len; n++) {\n                    let idx = parseInt(line.substring(9 + 8 * n, 13 + 8 * n).trim());\n                    let stype = line.substring(14 + 8 * n, 17 + 8 * n);\n                    if (stype == 'SUP')\n                        superatoms.set(idx, { 'atoms': [], 'name': null });\n                    else if (stype == 'MIX' || stype == 'FOR')\n                        mixtures.set(idx, { 'index': idx, 'parent': 0, 'atoms': [], 'type': stype });\n                    else if (stype == 'SRU' || stype == 'COP')\n                        superatoms.set(idx, { 'atoms': [], 'name': null, 'bracketType': stype });\n                }\n            }\n            else if (line.startsWith('M  SPL')) {\n                let len = parseInt(line.substring(6, 9).trim());\n                for (let n = 0; n < len; n++) {\n                    let child = parseInt(line.substring(9 + 8 * n, 13 + 8 * n).trim());\n                    let parent = parseInt(line.substring(13 + 8 * n, 17 + 8 * n).trim());\n                    let mix = mixtures.get(child);\n                    if (mix != null)\n                        mix.parent = parent;\n                }\n            }\n            else if (line.startsWith('M  SAL')) {\n                let idx = parseInt(line.substring(6, 10).trim());\n                let sup = superatoms.get(idx);\n                if (sup != null) {\n                    let len = parseInt(line.substring(10, 13).trim());\n                    let atoms = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.numberArray(0, len);\n                    for (let n = 0; n < len; n++)\n                        atoms[n] = parseInt(line.substring(13 + 4 * n, 17 + 4 * n).trim());\n                    sup.atoms = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.concat(sup.atoms, atoms);\n                }\n                let mix = mixtures.get(idx);\n                if (mix != null) {\n                    let len = parseInt(line.substring(10, 13).trim());\n                    let atoms = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.numberArray(0, len);\n                    for (let n = 0; n < len; n++)\n                        atoms[n] = parseInt(line.substring(13 + 4 * n, 17 + 4 * n).trim());\n                    mix.atoms = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.concat(mix.atoms, atoms);\n                }\n            }\n            else if (line.startsWith('M  SBL')) {\n                let idx = parseInt(line.substring(6, 10).trim());\n                let sup = superatoms.get(idx);\n                if (sup != null) {\n                    let len = parseInt(line.substring(10, 13).trim());\n                    let bonds = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.numberArray(0, len);\n                    for (let n = 0; n < len; n++)\n                        bonds[n] = parseInt(line.substring(13 + 4 * n, 17 + 4 * n).trim());\n                    sup.bonds = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.concat(sup.bonds, bonds);\n                }\n            }\n            else if (line.startsWith('M  SMT')) {\n                let idx = parseInt(line.substring(6, 10).trim());\n                let sup = superatoms.get(idx);\n                if (sup != null)\n                    sup.name = line.substring(11).trim();\n            }\n            else if (line.startsWith('M  SCN')) {\n                let len = parseInt(line.substring(6, 9).trim());\n                for (let n = 0; n < len; n++) {\n                    let idx = parseInt(line.substring(9 + 8 * n, 13 + 8 * n).trim());\n                    let stype = line.substring(14 + 8 * n, 17 + 8 * n);\n                    let sup = superatoms.get(idx);\n                    if (sup != null)\n                        sup.connectType = stype.trim();\n                }\n            }\n            else if (line.startsWith('M  CRS')) {\n                let idx = parseInt(line.substring(6, 10).trim());\n                let sup = superatoms.get(idx);\n                if (sup != null) {\n                    let len = parseInt(line.substring(10, 13).trim());\n                    sup.bondConn = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.numberArray(0, len);\n                    for (let n = 0; n < len; n++)\n                        sup.bondConn[n] = parseInt(line.substring(13 + 4 * n, 17 + 4 * n).trim());\n                }\n            }\n            else if (line.startsWith('M  LIN')) {\n                let len = parseInt(line.substring(6, 9).trim());\n                for (let n = 0; n < len; n++) {\n                    let node = {\n                        'atom': parseInt(line.substring(9 + 8 * n, 13 + 8 * n).trim()),\n                        'nbrs': [],\n                        'minRep': 1,\n                        'maxRep': parseInt(line.substring(13 + 8 * n, 17 + 8 * n).trim()),\n                    };\n                    let nbr1 = parseInt(line.substring(17 + 8 * n, 21 + 8 * n).trim());\n                    let nbr2 = parseInt(line.substring(21 + 8 * n, 25 + 8 * n).trim());\n                    if (nbr1 > 0)\n                        node.nbrs.push(nbr1);\n                    if (nbr2 > 0)\n                        node.nbrs.push(nbr2);\n                    this.groupLinkNodes.push(node);\n                }\n            }\n            if (type == MBLK_ZPA || type == MBLK_ZRI || type == MBLK_ZAR) {\n                let len = parseInt(line.substring(6, 9).trim()), blk = parseInt(line.substring(9, 13).trim());\n                let map = type == MBLK_ZPA ? resPaths : type == MBLK_ZRI ? resRings : arenes;\n                for (let n = 0; n < len; n++) {\n                    let val = parseInt(line.substring(13 + 4 * n, 17 + 4 * n).trim());\n                    if (val < 1 || val > numAtoms)\n                        throw 'Invalid MDL MOL: M-block';\n                    let atoms = map.get(blk);\n                    if (!atoms)\n                        map.set(blk, atoms = []);\n                    atoms.push(val);\n                }\n            }\n            else if (type > 0) {\n                let len = parseInt(line.substring(6, 9).trim());\n                for (let n = 0; n < len; n++) {\n                    let pos = parseInt(line.substring(9 + 8 * n, 13 + 8 * n).trim());\n                    let val = parseInt(line.substring(13 + 8 * n, 17 + 8 * n).trim());\n                    if (pos < 1)\n                        throw 'Invalid MDL MOL: M-block';\n                    if (type == MBLK_CHG)\n                        this.mol.setAtomCharge(pos, val);\n                    else if (type == MBLK_RAD) {\n                        if (val == 1 || val == 3)\n                            this.mol.setAtomUnpaired(pos, 2);\n                        else if (val == 2)\n                            this.mol.setAtomUnpaired(pos, 1);\n                    }\n                    else if (type == MBLK_ISO)\n                        this.mol.setAtomIsotope(pos, val);\n                    else if (type == MBLK_RGP)\n                        this.mol.setAtomElement(pos, 'R' + val);\n                    else if (type == MBLK_HYD) {\n                        this.mol.setAtomHExplicit(pos, val);\n                        let src = { 'row': this.pos - 1, 'col': 9 + 8 * n, 'len': 8 };\n                        this.openmol.addJoin(_OpenMolSpec__WEBPACK_IMPORTED_MODULE_6__.OpenMolType.HydrogenCounting, [pos], null, [src]);\n                    }\n                    else if (type == MBLK_ZCH)\n                        this.mol.setAtomCharge(pos, val);\n                    else if (type == MBLK_ZBO) {\n                        this.mol.setBondOrder(pos, val);\n                        let src = { 'row': this.pos - 1, 'col': 9 + 8 * n, 'len': 8 };\n                        this.openmol.addJoin(_OpenMolSpec__WEBPACK_IMPORTED_MODULE_6__.OpenMolType.ZeroOrderBonds, null, [pos], [src]);\n                    }\n                }\n            }\n        }\n        this.postFix();\n        if (this.parseExtended) {\n            let artifacts = new _BondArtifact__WEBPACK_IMPORTED_MODULE_1__.BondArtifact(this.mol);\n            for (let atoms of resPaths.values())\n                artifacts.createPath(atoms);\n            for (let atoms of resRings.values())\n                artifacts.createRing(atoms);\n            for (let atoms of arenes.values())\n                artifacts.createArene(atoms);\n            artifacts.rewriteMolecule();\n        }\n        for (let key of _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.sorted(Array.from(superatoms.keys()))) {\n            let value = superatoms.get(key);\n            if (value.bracketType) {\n                superatoms.delete(key);\n                this.applyPolymerBlock(value);\n            }\n        }\n        for (let key of _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.sorted(Array.from(superatoms.keys()))) {\n            let value = superatoms.get(key);\n            superatoms.delete(key);\n            this.applySuperAtom(value, Array.from(superatoms.values()));\n        }\n        for (let key of _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.sorted(Array.from(mixtures.keys())))\n            this.groupMixtures.push(mixtures.get(key));\n        this.openmol.derive(this.mol);\n    }\n    postFix() {\n        const mol = this.mol;\n        for (let n = 1; n <= mol.numAtoms; n++) {\n            let el = mol.atomElement(n);\n            if (el == 'D') {\n                mol.setAtomElement(n, 'H');\n                mol.setAtomIsotope(n, 2);\n            }\n            else if (el == 'T') {\n                mol.setAtomElement(n, 'H');\n                mol.setAtomIsotope(n, 3);\n            }\n            let valence = this.explicitValence[n - 1], options = MDLMOL_VALENCE[el];\n            if (valence != 0) {\n                let hcount = valence < 0 || valence > 14 ? 0 : valence;\n                for (let b of mol.atomAdjBonds(n))\n                    hcount -= mol.bondOrder(b);\n                if (hcount != mol.atomHydrogens(n))\n                    mol.setAtomHExplicit(n, Math.max(0, hcount));\n            }\n            else if (options) {\n                let chg = mol.atomCharge(n);\n                let chgmod = (el == 'C' || el == 'H') ? Math.abs(chg) : el == 'B' ? -Math.abs(chg) : -chg;\n                let usedValence = chgmod;\n                let unp = mol.atomUnpaired(n);\n                if (unp > 0 && (el == 'C' || el == 'O' || el == 'S' || el == 'N' || el == 'P'))\n                    usedValence += unp;\n                for (let b of mol.atomAdjBonds(n))\n                    usedValence += mol.bondOrder(b);\n                for (let v of options)\n                    if (usedValence <= v) {\n                        let hcount = v - usedValence;\n                        if (hcount != mol.atomHydrogens(n))\n                            mol.setAtomHExplicit(n, Math.max(0, hcount));\n                        break;\n                    }\n            }\n        }\n        if (this.considerRescale)\n            _CoordUtil__WEBPACK_IMPORTED_MODULE_2__.CoordUtil.normaliseBondDistances(mol);\n        mol.keepTransient = false;\n    }\n    parseV3000() {\n        let Section;\n        (function (Section) {\n            Section[Section[\"ATOM\"] = 0] = \"ATOM\";\n            Section[Section[\"BOND\"] = 1] = \"BOND\";\n            Section[Section[\"COLL\"] = 2] = \"COLL\";\n            Section[Section[\"SGROUP\"] = 3] = \"SGROUP\";\n        })(Section || (Section = {}));\n        let inCTAB = false, section = null;\n        let lineCounts = null;\n        let lineAtom = [], lineBond = [], lineColl = [], lineSgroup = [];\n        const ERRPFX = 'Invalid MDL MOL V3000: ';\n        while (true) {\n            let line = this.nextLine();\n            if (line == 'M  END')\n                break;\n            if (!line.startsWith('M  V30 '))\n                continue;\n            line = line.substring(7);\n            if (line.startsWith('COUNTS '))\n                lineCounts = line.substring(7);\n            else if (line.startsWith('BEGIN CTAB'))\n                inCTAB = true;\n            else if (line.startsWith('BEGIN ATOM'))\n                section = Section.ATOM;\n            else if (line.startsWith('BEGIN BOND'))\n                section = Section.BOND;\n            else if (line.startsWith('BEGIN COLLECTION'))\n                section = Section.COLL;\n            else if (line.startsWith('BEGIN SGROUP'))\n                section = Section.SGROUP;\n            else if (line.startsWith('END '))\n                section = null;\n            else if (inCTAB && section == Section.ATOM)\n                lineAtom.push(line);\n            else if (inCTAB && section == Section.BOND)\n                lineBond.push(line);\n            else if (inCTAB && section == Section.COLL)\n                lineColl.push(line);\n            else if (inCTAB && section == Section.SGROUP)\n                lineSgroup.push(line);\n            else if (inCTAB && section == null) {\n                if (line.startsWith('LINKNODE ')) {\n                    let bits = this.splitWithQuotes(line.substring(9));\n                    let node = {\n                        'atom': 0,\n                        'nbrs': [],\n                        'minRep': parseInt(bits[0]),\n                        'maxRep': parseInt(bits[1])\n                    };\n                    let nb = parseInt(bits[2]);\n                    let atoms = [];\n                    for (let n = 0; n < nb * 2; n++)\n                        atoms.push(parseInt(bits[3 + n]));\n                    _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.sort(atoms);\n                    for (let n = 0; n < atoms.length; n++) {\n                        if (n < atoms.length - 1 && atoms[n] == atoms[n + 1])\n                            node.atom = atoms[n++];\n                        else\n                            node.nbrs.push(atoms[n]);\n                    }\n                    this.groupLinkNodes.push(node);\n                }\n            }\n        }\n        let counts = lineCounts.split(/\\s+/);\n        if (counts.length < 2)\n            throw ERRPFX + 'counts line malformatted';\n        let numAtoms = parseInt(counts[0]), numBonds = parseInt(counts[1]);\n        if (numAtoms < 0 || numAtoms > lineAtom.length)\n            throw ERRPFX + 'unreasonable atom count: ' + numAtoms;\n        if (numBonds < 0 || numBonds > lineBond.length)\n            throw ERRPFX + 'unreasonable bond count: ' + numBonds;\n        let atomBits = [], bondBits = [];\n        for (let n = 0; n < lineAtom.length; n++) {\n            let line = lineAtom[n];\n            while (n < lineAtom.length - 1 && line.endsWith('-')) {\n                n++;\n                line = line.substring(0, line.length - 1) + lineAtom[n];\n            }\n            let bits = this.splitWithQuotes(line);\n            if (bits.length < 6)\n                throw ERRPFX + 'atom line has too few components: ' + line;\n            let idx = parseInt(bits[0], 0);\n            if (idx < 1 || idx > numAtoms)\n                throw ERRPFX + 'invalid atom index: ' + bits[0];\n            if (atomBits[idx - 1] != null)\n                throw ERRPFX + 'duplicate atom index: ' + idx;\n            atomBits[idx - 1] = bits;\n        }\n        for (let n = 0; n < lineBond.length; n++) {\n            let line = lineBond[n];\n            while (n < lineBond.length - 1 && line.endsWith('-')) {\n                n++;\n                line = line.substring(0, line.length - 1) + lineBond[n];\n            }\n            let bits = this.splitWithQuotes(line);\n            if (bits.length < 4)\n                throw ERRPFX + 'bond line has too few components: ' + line;\n            let idx = parseInt(bits[0], 0);\n            if (idx < 1 || idx > numBonds)\n                throw ERRPFX + 'invalid bond index: ' + bits[0];\n            if (bondBits[idx - 1] != null)\n                throw ERRPFX + 'duplicate bond index: ' + idx;\n            bondBits[idx - 1] = bits;\n        }\n        this.explicitValence = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.numberArray(0, numAtoms);\n        for (let a = 1; a <= numAtoms; a++) {\n            let bits = atomBits[a - 1];\n            if (bits == null)\n                throw ERRPFX + 'atom definition missing for #' + a;\n            let type = bits[1];\n            let x = parseFloat(bits[2]), y = parseFloat(bits[3]), z = parseFloat(bits[4]);\n            let map = parseInt(bits[5]);\n            this.mol.addAtom(type, x, y);\n            this.mol.setAtomMapNum(a, map);\n            for (let i = 6; i < bits.length; i++) {\n                let eq = bits[i].indexOf('=');\n                if (eq < 0)\n                    continue;\n                let key = bits[i].substring(0, eq), val = bits[i].substring(eq + 1);\n                if (key == 'CHG')\n                    this.mol.setAtomCharge(a, parseInt(val));\n                else if (key == 'RAD') {\n                    let spin = parseInt(val);\n                    if (spin == 1 || spin == 3)\n                        this.mol.setAtomUnpaired(a, 2);\n                    else if (spin == 2)\n                        this.mol.setAtomUnpaired(a, 1);\n                }\n                else if (key == 'MASS')\n                    this.mol.setAtomIsotope(a, parseInt(val));\n                else if (key == 'CFG') {\n                    let stereo = parseInt(val);\n                    if (stereo > 0 && this.keepParity) {\n                    }\n                }\n                else if (key == 'VAL')\n                    this.explicitValence[a - 1] = parseInt(val);\n            }\n        }\n        for (let b = 1; b <= numBonds; b++) {\n            let bits = bondBits[b - 1];\n            if (bits == null)\n                throw ERRPFX + 'bond definition missing for #' + b;\n            let type = parseInt(bits[1]), bfr = parseInt(bits[2]), bto = parseInt(bits[3]);\n            let order = type >= 1 && type <= 3 ? type : type == 9 || type == 10 ? 0 : 1;\n            this.mol.addBond(bfr, bto, order);\n            if (type == 4) {\n            }\n            let endpts = null;\n            let attach = null;\n            for (let i = 4; i < bits.length; i++) {\n                let eq = bits[i].indexOf('=');\n                if (eq < 0)\n                    continue;\n                let key = bits[i].substring(0, eq), val = bits[i].substring(eq + 1);\n                if (key == 'CFG') {\n                    let dir = parseInt(val);\n                    this.mol.setBondType(b, dir == 1 ? _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_INCLINED :\n                        dir == 2 ? _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_UNKNOWN :\n                            dir == 3 ? _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_DECLINED : _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_NORMAL);\n                }\n                else if (key == 'DISP') {\n                    if (val == 'COORD')\n                        this.mol.setBondOrder(b, 0);\n                }\n                else if (key == 'ENDPTS')\n                    endpts = this.unpackList(val);\n                else if (key == 'ATTACH')\n                    attach = val;\n            }\n            if (attach != null && endpts != null) {\n                if (attach == 'ALL')\n                    this.groupAttachAll.set(b, endpts);\n                else if (attach == 'ANY')\n                    this.groupAttachAny.set(b, endpts);\n            }\n        }\n        this.postFix();\n        for (let n = 0; n < lineColl.length; n++) {\n            let line = lineColl[n];\n            while (n < lineColl.length - 1 && line.endsWith('-')) {\n                n++;\n                line = line.substring(0, line.length - 1) + lineColl[n];\n            }\n            let bits = this.splitWithQuotes(line);\n            if (bits[0].startsWith('MDLV30/STEABS')) {\n                if (bits[1].startsWith('ATOMS='))\n                    this.groupStereoAbsolute = this.unpackList(bits[1].substring(5));\n            }\n            else if (bits[0].startsWith('MDLV30/STERAC')) {\n                if (bits[1].startsWith('ATOMS='))\n                    this.groupStereoRacemic.push(this.unpackList(bits[1].substring(6)));\n            }\n            else if (bits[0].startsWith('MDLV30/STEREL')) {\n                if (bits[1].startsWith('ATOMS='))\n                    this.groupStereoRelative.push(this.unpackList(bits[1].substring(6)));\n            }\n        }\n        let superatoms = new Map();\n        for (let n = 0; n < lineSgroup.length; n++) {\n            let line = lineSgroup[n];\n            while (n < lineSgroup.length - 1 && line.endsWith('-')) {\n                n++;\n                line = line.substring(0, line.length - 1) + lineSgroup[n];\n            }\n            let bits = this.splitWithQuotes(line);\n            let idx = parseInt(bits[0]);\n            if (bits.length > 3 && idx > 0 && bits[1] == 'SUP' && parseInt(bits[2]) == idx) {\n                let sup = { 'atoms': [], 'name': null };\n                for (let i = 3; i < bits.length; i++) {\n                    if (bits[i].startsWith('ATOMS='))\n                        sup.atoms = this.unpackList(bits[i].substring(6));\n                    else if (bits[i].startsWith('LABEL='))\n                        sup.name = this.withoutQuotes(bits[i].substring(6));\n                }\n                superatoms.set(idx, sup);\n            }\n            else if (bits.length > 3 && idx > 0 && (bits[1] == 'MIX' || bits[1] == 'FOR') && parseInt(bits[2]) == idx) {\n                let mix = { 'index': idx, 'parent': 0, 'atoms': null, 'type': bits[1] };\n                for (let i = 3; i < bits.length; i++) {\n                    if (bits[i].startsWith('ATOMS='))\n                        mix.atoms = this.unpackList(bits[i].substring(6));\n                    else if (bits[i].startsWith('PARENT='))\n                        mix.parent = parseInt(bits[i].substring(7));\n                }\n                this.groupMixtures.push(mix);\n            }\n            else if (bits.length > 3 && idx > 0 && (bits[1] == 'SRU' || bits[1] == 'COP') && parseInt(bits[2]) == idx) {\n                let sup = { 'atoms': [], 'name': null, 'bracketType': bits[1] };\n                for (let i = 3; i < bits.length; i++) {\n                    if (bits[i].startsWith('ATOMS='))\n                        sup.atoms = this.unpackList(bits[i].substring(6));\n                    else if (bits[i].startsWith('BONDS='))\n                        sup.bonds = this.unpackList(bits[i].substring(6));\n                    else if (bits[i].startsWith('LABEL='))\n                        sup.name = this.withoutQuotes(bits[i].substring(6));\n                    else if (bits[i].startsWith('CONNECT='))\n                        sup.connectType = bits[i].substring(8);\n                    else if (bits[i].startsWith('XBCORR='))\n                        sup.bondConn = this.unpackList(bits[i].substring(7));\n                }\n                superatoms.set(idx, sup);\n            }\n        }\n        for (let key of _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.sorted(Array.from(superatoms.keys()))) {\n            let value = superatoms.get(key);\n            if (value.bracketType) {\n                superatoms.delete(key);\n                this.applyPolymerBlock(value);\n            }\n        }\n        for (let key of _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.sorted(Array.from(superatoms.keys()))) {\n            let value = superatoms.get(key);\n            superatoms.delete(key);\n            this.applySuperAtom(value, Array.from(superatoms.values()));\n        }\n    }\n    applySuperAtom(sup, residual) {\n        if (sup.name == null || _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.isBlank(sup.atoms))\n            return;\n        let mask = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.booleanArray(true, this.mol.numAtoms);\n        for (let a of sup.atoms)\n            mask[a - 1] = false;\n        let name = sup.name;\n        let i;\n        while ((i = name.indexOf('\\\\S')) >= 0)\n            name = name.substring(0, i) + '{^' + name.substring(i + 2);\n        while ((i = name.indexOf('\\\\s')) >= 0)\n            name = name.substring(0, i) + '{' + name.substring(i + 2);\n        while ((i = name.indexOf('\\\\n')) >= 0)\n            name = name.substring(0, i) + '}' + name.substring(i + 2);\n        let [mod, abvAtom] = _MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.convertToAbbrevIndex(this.mol, mask, name);\n        if (mod == null)\n            return;\n        this.mol = mod;\n        let map = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.maskMap(mask);\n        for (let res of residual) {\n            let subsumed = false;\n            for (let n = res.atoms.length - 1; n >= 0; n--) {\n                let atom = map[res.atoms[n] - 1] + 1;\n                if (atom == 0) {\n                    res.atoms = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.remove(res.atoms, n);\n                    subsumed = true;\n                }\n                else\n                    res.atoms[n] = atom;\n            }\n            if (subsumed)\n                res.atoms = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.sorted(_util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.append(res.atoms, abvAtom));\n        }\n    }\n    applyPolymerBlock(sup) {\n        let poly = new _PolymerBlock__WEBPACK_IMPORTED_MODULE_7__.PolymerBlock(this.mol);\n        let connect = null;\n        if (sup.connectType == null) { }\n        else if (sup.connectType == 'HT')\n            connect = _PolymerBlock__WEBPACK_IMPORTED_MODULE_7__.PolymerBlockConnectivity.HeadToTail;\n        else if (sup.connectType == 'HH')\n            connect = _PolymerBlock__WEBPACK_IMPORTED_MODULE_7__.PolymerBlockConnectivity.HeadToHead;\n        else if (sup.connectType == 'EU')\n            connect = _PolymerBlock__WEBPACK_IMPORTED_MODULE_7__.PolymerBlockConnectivity.Random;\n        else\n            return;\n        let bondConn = null;\n        if (_util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.len(sup.bondConn) == 3) {\n            let b1 = sup.bondConn[0], b2 = sup.bondConn[2], b3 = sup.bondConn[1], b4 = 0;\n            for (let n = 1; n <= this.mol.numBonds; n++)\n                if (n != b1 && n != b2 && n != b3) {\n                    let in1 = sup.atoms.indexOf(this.mol.bondFrom(n)) >= 0, in2 = sup.atoms.indexOf(this.mol.bondTo(n)) >= 0;\n                    if ((in1 && !in2) || (!in1 && in2)) {\n                        if (b4 > 0) {\n                            b4 = 0;\n                            break;\n                        }\n                        b4 = n;\n                    }\n                }\n            bondConn = [b1, b2, b3, b4];\n        }\n        else if (_util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.len(sup.bondConn) == 4) {\n            bondConn = sup.bondConn;\n        }\n        let unit = new _PolymerBlock__WEBPACK_IMPORTED_MODULE_7__.PolymerBlockUnit(sup.atoms);\n        unit.connect = connect;\n        unit.bondConn = bondConn;\n        poly.createUnit(unit);\n    }\n    withoutQuotes(str) {\n        if (str.length >= 2 && str.startsWith('\"') && str.endsWith('\"'))\n            return str.substring(1, str.length - 1);\n        return str;\n    }\n    splitWithQuotes(line) {\n        let segments = [];\n        let seg = '';\n        let depth = 0, quote = false;\n        for (let n = 0; n < line.length; n++) {\n            let ch = line.charAt(n);\n            if (ch == ' ' && depth == 0 && !quote) {\n                if (seg.length > 0)\n                    segments.push(seg);\n                seg = '';\n            }\n            else {\n                seg += ch;\n                if (ch == '\"')\n                    quote = !quote;\n                else if (ch == '(' || ch == '[')\n                    depth++;\n                else if (ch == ')' || ch == ']')\n                    depth--;\n            }\n        }\n        if (seg.length > 0)\n            segments.push(seg);\n        return segments;\n    }\n    unpackList(str) {\n        if (!str.startsWith('(') || !str.endsWith(')'))\n            return null;\n        str = str.substring(1, str.length - 1);\n        let values = [];\n        for (let bit of str.split(' '))\n            values.push(parseInt(bit));\n        if (values[0] != values.length - 1)\n            return null;\n        return _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.remove(values, 0);\n    }\n}\nclass MDLSDFReader {\n    constructor(strData) {\n        this.ds = new _DataSheet__WEBPACK_IMPORTED_MODULE_3__.DataSheet();\n        this.upcastColumns = true;\n        this.pos = 0;\n        this.lines = strData.split(/\\r?\\n/);\n    }\n    parse() {\n        this.parseStream();\n        if (this.upcastColumns)\n            this.upcastStringColumns();\n        return this.ds;\n    }\n    parseStream() {\n        let ds = this.ds;\n        ds.appendColumn('Molecule', \"molecule\", 'Molecular structure');\n        let colName = -1;\n        let entry = [];\n        while (this.pos < this.lines.length) {\n            let line = this.lines[this.pos++];\n            if (!line.startsWith('$$$$')) {\n                entry.push(line);\n                continue;\n            }\n            let rn = ds.appendRow();\n            let molstr = '';\n            let pos = 0;\n            while (pos < entry.length) {\n                line = entry[pos];\n                if (line.startsWith('> '))\n                    break;\n                molstr += line + '\\n';\n                pos++;\n                if (line.startsWith('M\tEND'))\n                    break;\n            }\n            let mol = null, name = null;\n            try {\n                if (molstr.length > 0) {\n                    let mdl = new MDLMOLReader(molstr);\n                    mdl.parse();\n                    mol = mdl.mol;\n                    name = mdl.molName;\n                }\n            }\n            catch (ex) {\n            }\n            if (mol != null)\n                ds.setMolecule(rn, 0, mol);\n            if (name) {\n                if (colName < 0)\n                    colName = ds.appendColumn('Name', \"string\", 'Molecule name');\n                ds.setString(rn, colName, name);\n            }\n            if (rn == 0 && mol != null) {\n                let str1 = entry[0], str3 = entry[2];\n                if (str1.length >= 7 && str1.startsWith('$name=')) {\n                    ds.changeColumnName(0, str1.substring(6), ds.colDescr(0));\n                }\n                if (str3.length >= 8 && str3.startsWith('$title=')) {\n                    ds.title = str3.substring(7);\n                }\n            }\n            for (; pos + 1 < entry.length; pos += 3) {\n                let key = entry[pos], val = entry[pos + 1];\n                if (!key.startsWith('>'))\n                    continue;\n                let z = key.indexOf('<');\n                if (z < 0)\n                    continue;\n                key = key.substring(z + 1);\n                z = key.indexOf('>');\n                if (z < 0)\n                    continue;\n                key = key.substring(0, z);\n                if (key.length == 0)\n                    continue;\n                while (pos + 2 < entry.length && entry[pos + 2].length > 0) {\n                    val += '\\n' + entry[pos + 2];\n                    pos++;\n                }\n                let cn = ds.findColByName(key);\n                if (cn < 0)\n                    cn = ds.appendColumn(key, \"string\", '');\n                if (val.length == 0)\n                    ds.setToNull(rn, cn);\n                else\n                    ds.setString(rn, cn, val);\n            }\n            entry = [];\n        }\n        if (ds.numRows == 0)\n            this.ds = null;\n    }\n    upcastStringColumns() {\n        let ds = this.ds;\n        for (let i = 0; i < ds.numCols; i++)\n            if (ds.colType(i) == \"string\") {\n                let allnull = true, allreal = true, allint = true, allbool = true;\n                for (let j = 0; j < ds.numRows; j++) {\n                    if (!allreal && !allint && !allbool)\n                        break;\n                    if (ds.isNull(j, i))\n                        continue;\n                    allnull = false;\n                    let val = ds.getString(j, i);\n                    if (allbool) {\n                        let lc = val.toLowerCase();\n                        if (lc != 'true' && lc != 'false')\n                            allbool = false;\n                    }\n                    if (allint) {\n                        let int = parseInt(val);\n                        if (!isFinite(int) || int != parseFloat(val))\n                            allint = false;\n                    }\n                    if (allreal) {\n                        if (!isFinite(parseFloat(val)))\n                            allreal = false;\n                    }\n                }\n                if (allnull) { }\n                else if (allint)\n                    ds.changeColumnType(i, \"integer\");\n                else if (allreal)\n                    ds.changeColumnType(i, \"real\");\n                else if (allbool)\n                    ds.changeColumnType(i, \"boolean\");\n            }\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/data/MDLReader.ts?");

/***/ }),

/***/ "./src/data/MDLWriter.ts":
/*!*******************************!*\
  !*** ./src/data/MDLWriter.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MDLMOLWriter\": () => (/* binding */ MDLMOLWriter),\n/* harmony export */   \"MDLSDFWriter\": () => (/* binding */ MDLSDFWriter)\n/* harmony export */ });\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _BondArtifact__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BondArtifact */ \"./src/data/BondArtifact.ts\");\n/* harmony import */ var _MDLReader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MDLReader */ \"./src/data/MDLReader.ts\");\n/* harmony import */ var _Molecule__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Molecule */ \"./src/data/Molecule.ts\");\n/* harmony import */ var _MolUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MolUtil */ \"./src/data/MolUtil.ts\");\n/* harmony import */ var _PolymerBlock__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./PolymerBlock */ \"./src/data/PolymerBlock.ts\");\n\n\n\n\n\n\nclass MDLMOLWriter {\n    constructor(mol) {\n        this.mol = mol;\n        this.includeHeader = true;\n        this.enhancedFields = true;\n        this.chargeSeparate = false;\n        this.abbrevSgroups = true;\n        this.polymerBlocks = true;\n        this.molName = '';\n        this.sgroupNames = [];\n        this.sgroupAtoms = [];\n        this.lines = [];\n    }\n    write() {\n        if (this.includeHeader) {\n            this.lines.push(this.molName);\n            this.lines.push('Generated by WebMolKit');\n            this.lines.push('');\n            this.writeCTAB();\n        }\n        return this.lines.join('\\n');\n    }\n    getResult() {\n        return this.lines.join('\\n');\n    }\n    writeCTAB() {\n        let mol = this.mol;\n        if (_MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.hasAnyAbbrev(mol)) {\n            mol = this.mol = mol.clone();\n            if (this.abbrevSgroups) {\n                this.partialAbbrevExpansion();\n                this.prepareSgroups();\n            }\n            else\n                _MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.expandAbbrevs(mol, true);\n        }\n        this.lines.push(this.intrpad(mol.numAtoms, 3) + this.intrpad(mol.numBonds, 3) + '  0  0  0  0  0  0  0  0999 V2000');\n        let chgidx = [], chgval = [];\n        let radidx = [], radval = [];\n        let isoidx = [], isoval = [];\n        let rgpidx = [], rgpval = [];\n        let hydidx = [], hydval = [];\n        let zchidx = [], zchval = [];\n        let zboidx = [], zboval = [];\n        for (let n = 1; n <= mol.numAtoms; n++) {\n            let x = mol.atomX(n), y = mol.atomY(n), z = 0;\n            let line = this.rpad(x.toFixed(4), 10) + this.rpad(y.toFixed(4), 10) + this.rpad(z.toFixed(4), 10);\n            let el = mol.atomElement(n);\n            let str = el;\n            if (str.length > 3)\n                str = str.substring(0, 3);\n            if (str.length > 1 && str.charAt(0) == 'R' && str.charAt(1) >= '0' && str.charAt(1) <= '9') {\n                rgpidx.push(n);\n                rgpval.push(parseInt(str.substring(1)));\n                str = 'R#';\n            }\n            while (str.length < 4)\n                str += ' ';\n            line += ' ' + str + '0';\n            let chg = mol.atomCharge(n), rad = mol.atomUnpaired(n), mapnum = mol.atomMapNum(n);\n            if (chg >= -3 && chg <= -1)\n                chg = 4 - chg;\n            else if (chg == 0 && rad == 2)\n                chg = 4;\n            else if (chg >= 1 && chg <= 3)\n                chg = 4 - chg;\n            else\n                chg = 0;\n            let val = this.mdlValence(mol, n, 15);\n            line += this.intrpad(chg, 3) + '  0  0  0' + this.intrpad(val, 3) + '  0  0  0' + this.intrpad(mapnum, 3) + '  0  0';\n            this.lines.push(line);\n            if (mol.atomCharge(n) != 0) {\n                chgidx.push(n);\n                chgval.push(mol.atomCharge(n));\n            }\n            if (this.enhancedFields) {\n                if (mol.atomHExplicit(n) != _Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule.HEXPLICIT_UNKNOWN) {\n                    hydidx.push(n);\n                    hydval.push(mol.atomHExplicit(n));\n                }\n            }\n            if (rad == 1) {\n                radidx.push(n);\n                radval.push(2);\n            }\n            if (rad == 2) {\n                radidx.push(n);\n                radval.push(1);\n            }\n            if (mol.atomIsotope(n) != _Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule.ISOTOPE_NATURAL) {\n                isoidx.push(n);\n                isoval.push(mol.atomIsotope(n));\n            }\n        }\n        for (let n = 1; n <= mol.numBonds; n++) {\n            let order = mol.bondOrder(n), type = order;\n            if (type == 0)\n                type = 8;\n            else if (type > 3)\n                type = 3;\n            let stereo = mol.bondType(n);\n            if (stereo == _Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule.BONDTYPE_NORMAL) { }\n            else if (stereo == _Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule.BONDTYPE_INCLINED) {\n                stereo = 1;\n            }\n            else if (stereo == _Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule.BONDTYPE_DECLINED) {\n                stereo = 6;\n            }\n            else if (stereo == _Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule.BONDTYPE_UNKNOWN) {\n                if (type == 1)\n                    stereo = 4;\n                else\n                    stereo = 3;\n            }\n            else\n                stereo = 0;\n            let line = this.intrpad(mol.bondFrom(n), 3) + this.intrpad(mol.bondTo(n), 3) +\n                this.intrpad(type, 3) + this.intrpad(stereo, 3) + '  0  0  0';\n            this.lines.push(line);\n            if (this.enhancedFields) {\n                if ((order < 1 || order > 3) || type != order) {\n                    zboidx.push(n);\n                    zboval.push(order);\n                }\n            }\n        }\n        this.writeMBlockPair('CHG', chgidx, chgval);\n        this.writeMBlockPair('RAD', radidx, radval);\n        this.writeMBlockPair('ISO', isoidx, isoval);\n        this.writeMBlockPair('RGP', rgpidx, rgpval);\n        this.writeMBlockPair('HYD', hydidx, hydval);\n        this.writeMBlockPair('ZCH', zchidx, zchval);\n        this.writeMBlockPair('ZBO', zboidx, zboval);\n        if (this.enhancedFields) {\n            let artifacts = new _BondArtifact__WEBPACK_IMPORTED_MODULE_1__.BondArtifact(this.mol);\n            let idx = 0;\n            for (let path of artifacts.getResPaths())\n                this.writeMBlockFlat('ZPA', ++idx, path.atoms);\n            for (let ring of artifacts.getResRings())\n                this.writeMBlockFlat('ZRI', ++idx, ring.atoms);\n            for (let arene of artifacts.getArenes())\n                this.writeMBlockFlat('ZAR', ++idx, _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.prepend(arene.atoms, arene.centre));\n        }\n        let inSgroup = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.booleanArray(false, mol.numAtoms);\n        for (let s = 0; s < this.sgroupAtoms.length; s++) {\n            let sgroup = this.sgroupAtoms[s];\n            for (let n of sgroup)\n                inSgroup[n - 1] = true;\n            let sidx = this.intrpad(s + 1, 4);\n            this.lines.push('M  STY  1' + sidx + ' SUP');\n            for (let n = 0; n < sgroup.length; n += 15) {\n                let sz = Math.min(sgroup.length - n, 15);\n                let line = 'M  SAL' + sidx + this.intrpad(sz, 3);\n                for (let i = 0; i < sz; i++)\n                    line += this.intrpad(sgroup[n + i], 4);\n                this.lines.push(line);\n            }\n            this.lines.push('M  SMT' + sidx + ' ' + this.sgroupNames[s]);\n        }\n        if (this.polymerBlocks)\n            this.encodePolymerBlocks(this.sgroupAtoms.length);\n        for (let n = 1; n <= mol.numAtoms; n++)\n            if (mol.atomElement(n).length > 2) {\n                this.lines.push('A  ' + this.intrpad(n, 3));\n                this.lines.push(mol.atomElement(n));\n            }\n        this.lines.push('M  END');\n    }\n    writeMBlockPair(token, idx, val) {\n        const sz = idx.length;\n        for (let i = 0; i < sz; i += 8) {\n            let count = Math.min(8, sz - i);\n            let line = 'M  ' + token + this.intrpad(count, 3);\n            for (let j = 0; j < count; j++)\n                line += this.intrpad(idx[i + j], 4) + this.intrpad(val[i + j], 4);\n            this.lines.push(line);\n        }\n    }\n    writeMBlockFlat(token, idx, val) {\n        const sz = val.length;\n        for (let i = 0; i < sz; i += 15) {\n            let count = Math.min(15, sz - i);\n            let line = 'M  ' + token + this.intrpad(count, 3) + this.intrpad(idx, 4);\n            for (let j = 0; j < count; j++)\n                line += this.intrpad(val[i + j], 4);\n            this.lines.push(line);\n        }\n    }\n    writeMBlockFlatIdxFirst(token, idx, val) {\n        const sz = val.length;\n        for (let i = 0; i < sz; i += 15) {\n            let count = Math.min(15, sz - i);\n            let line = 'M  ' + token + this.intrpad(idx, 4) + this.intrpad(count, 3);\n            for (let j = 0; j < count; j++)\n                line += this.intrpad(val[i + j], 4);\n            this.lines.push(line);\n        }\n    }\n    intrpad(num, sz) {\n        return this.rpad(num.toString(), sz);\n    }\n    rpad(str, sz) {\n        while (str.length < sz)\n            str = ' ' + str;\n        return str;\n    }\n    mdlValence(mol, atom, zeroVal) {\n        let hyd = mol.atomHydrogens(atom), el = mol.atomElement(atom);\n        let options = _MDLReader__WEBPACK_IMPORTED_MODULE_2__.MDLMOL_VALENCE[el];\n        if (options == null && hyd == 0)\n            return 0;\n        let chg = mol.atomCharge(atom);\n        let chgmod = (el == 'C' || el == 'H') ? Math.abs(chg) : el == 'B' ? -Math.abs(chg) : -chg;\n        let bondSum = 0;\n        for (let b of mol.atomAdjBonds(atom))\n            bondSum += mol.bondOrder(b);\n        let nativeVal = chgmod + hyd + bondSum;\n        if (options && options[0] == nativeVal)\n            return 0;\n        let val = nativeVal - chgmod;\n        return val <= 0 || val > 14 ? zeroVal : val;\n    }\n    partialAbbrevExpansion() {\n        const { mol } = this;\n        for (let n = 1; n <= mol.numAtoms; n++)\n            if (_MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.hasAbbrev(mol, n)) {\n                let frag = _MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.getAbbrev(mol, n);\n                if (frag == null || mol.atomAdjCount(n) != 1) {\n                    _MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.clearAbbrev(mol, n);\n                    continue;\n                }\n                if (_MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.hasAnyAbbrev(frag)) {\n                    _MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.expandAbbrevs(frag, true);\n                    _MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.setAbbrev(mol, n, frag);\n                }\n                let order = mol.bondOrder(mol.atomAdjBonds(n)[0]);\n                if (frag.atomAdjCount(1) == 1 && order == frag.bondOrder(frag.atomAdjBonds(1)[0]))\n                    continue;\n                _MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.expandOneAbbrev(mol, n, true);\n                n--;\n            }\n    }\n    prepareSgroups() {\n        const { mol } = this;\n        for (let n = 1; n <= mol.numAtoms; n++)\n            if (mol.atomMapNum(n) < 0)\n                mol.setAtomMapNum(n, 0);\n        let next = 0;\n        for (let n = 1; n <= mol.numAtoms; n++)\n            if (_MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.hasAbbrev(mol, n)) {\n                this.sgroupNames.push(mol.atomElement(n));\n                let mask = _MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.expandOneAbbrev(mol, n, true);\n                if (mask == null)\n                    continue;\n                next--;\n                for (let i = 0; i < mask.length; i++)\n                    if (mask[i])\n                        mol.setAtomMapNum(i + 1, next);\n                n--;\n            }\n        for (let idx = -1; idx >= next; idx--) {\n            let atoms = [];\n            for (let n = 1; n <= mol.numAtoms; n++)\n                if (mol.atomMapNum(n) == idx) {\n                    atoms.push(n);\n                    mol.setAtomMapNum(n, 0);\n                }\n            this.sgroupAtoms.push(atoms);\n        }\n    }\n    encodePolymerBlocks(idx) {\n        let polymers = new _PolymerBlock__WEBPACK_IMPORTED_MODULE_5__.PolymerBlock(this.mol);\n        for (let id of polymers.getIDList()) {\n            let unit = polymers.getUnit(id);\n            let sidx = this.intrpad(++idx, 4);\n            this.lines.push('M  STY  1' + sidx + ' SRU');\n            if (unit.connect == _PolymerBlock__WEBPACK_IMPORTED_MODULE_5__.PolymerBlockConnectivity.HeadToTail)\n                this.lines.push('M  SCN  1' + sidx + ' HT ');\n            else if (unit.connect == _PolymerBlock__WEBPACK_IMPORTED_MODULE_5__.PolymerBlockConnectivity.HeadToHead)\n                this.lines.push('M  SCN  1' + sidx + ' HH ');\n            else if (unit.connect == _PolymerBlock__WEBPACK_IMPORTED_MODULE_5__.PolymerBlockConnectivity.Random)\n                this.lines.push('M  SCN  1' + sidx + ' EU ');\n            this.writeMBlockFlatIdxFirst('SAL', idx, unit.atoms);\n            let bonds = null;\n            for (let n = 1; n <= this.mol.numBonds; n++) {\n                let fl1 = unit.atoms.indexOf(this.mol.bondFrom(n)) >= 0, fl2 = unit.atoms.indexOf(this.mol.bondTo(n)) >= 0;\n                if ((fl1 && !fl2) || (!fl1 && fl2))\n                    bonds = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.append(bonds, n);\n            }\n            if (bonds != null)\n                this.writeMBlockFlatIdxFirst('SBL', idx, bonds);\n            if (_util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.len(unit.bondConn) == 4) {\n                let bcrs = [unit.bondConn[0], unit.bondConn[2], unit.bondConn[1]];\n                this.writeMBlockFlatIdxFirst('CRS', idx, bcrs);\n            }\n            this.lines.push('M  SMT' + sidx + ' n');\n        }\n    }\n}\nclass MDLSDFWriter {\n    constructor(ds) {\n        this.ds = ds;\n        this.enhancedFields = true;\n        this.chargeSeparate = false;\n        this.abbrevSgroups = true;\n        this.lines = [];\n    }\n    write() {\n        let ds = this.ds, lines = this.lines;\n        let colMol = this.ds.firstColOfType(\"molecule\");\n        for (let i = 0; i < ds.numRows; i++) {\n            let mol = colMol < 0 ? null : ds.getMolecule(i, colMol);\n            if (mol != null) {\n                let wtr = new MDLMOLWriter(mol);\n                wtr.enhancedFields = this.enhancedFields;\n                wtr.chargeSeparate = this.chargeSeparate;\n                wtr.abbrevSgroups = this.abbrevSgroups;\n                let molstr = wtr.write();\n                lines.push(molstr);\n            }\n            for (let j = 0; j < ds.numCols; j++)\n                if (j != colMol && ds.notNull(i, j)) {\n                    let ct = ds.colType(j);\n                    let val = '';\n                    if (ct == \"string\")\n                        val = ds.getString(i, j);\n                    else if (ct == \"integer\")\n                        val = ds.getInteger(i, j).toString();\n                    else if (ct == \"real\")\n                        val = ds.getReal(i, j).toString();\n                    else if (ct == \"boolean\")\n                        val = ds.getBoolean(i, j) ? 'true' : 'false';\n                    if (val != '') {\n                        lines.push('> <' + ds.colName(j) + '>');\n                        lines.push(val);\n                        lines.push('');\n                    }\n                }\n            lines.push('$$$$');\n        }\n        return lines.join('\\n');\n    }\n    getResult() {\n        return this.lines.join('\\n');\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/data/MDLWriter.ts?");

/***/ }),

/***/ "./src/data/MetaMolecule.ts":
/*!**********************************!*\
  !*** ./src/data/MetaMolecule.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MetaMolecule\": () => (/* binding */ MetaMolecule)\n/* harmony export */ });\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _Chemistry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Chemistry */ \"./src/data/Chemistry.ts\");\n/* harmony import */ var _DotPath__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DotPath */ \"./src/data/DotPath.ts\");\n/* harmony import */ var _Molecule__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Molecule */ \"./src/data/Molecule.ts\");\n/* harmony import */ var _MolUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MolUtil */ \"./src/data/MolUtil.ts\");\n/* harmony import */ var _Stereochemistry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Stereochemistry */ \"./src/data/Stereochemistry.ts\");\n\n\n\n\n\n\nclass MetaMolecule {\n    constructor(mol) {\n        this.mol = mol;\n        this.atomArom = null;\n        this.bondArom = null;\n        this.rubricTetra = null;\n        this.rubricSquare = null;\n        this.rubricBipy = null;\n        this.rubricOcta = null;\n        this.rubricSides = null;\n        this.hash = null;\n        this.heavyHash = null;\n        this.uniqueElements = null;\n        this.dots = null;\n        this.piAtom = null;\n    }\n    calculateStrictAromaticity() {\n        let mol = this.mol;\n        this.atomArom = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.booleanArray(false, mol.numAtoms);\n        this.bondArom = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.booleanArray(false, mol.numBonds);\n        let rings = mol.findRingsOfSize(6);\n        const nr = rings.length;\n        if (nr == 0)\n            return;\n        this.ensurePiAtoms();\n        let mask = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.booleanArray(false, nr);\n        for (let n = 0; n < nr; n++) {\n            for (let i = 0; i < rings[n].length; i++) {\n                let a = rings[n][i];\n                if (!this.piAtom[a - 1]) {\n                    mask[n] = true;\n                    break;\n                }\n                let b = mol.findBond(a, rings[n][i == rings[n].length - 1 ? 0 : i + 1]);\n                let bo = mol.bondOrder(b);\n                if (bo != 1 && bo != 2) {\n                    mask[n] = true;\n                    break;\n                }\n            }\n        }\n        while (true) {\n            let anyChange = false;\n            for (let n = 0; n < nr; n++)\n                if (!mask[n]) {\n                    let phase1 = true, phase2 = true;\n                    for (let i = 0; i < rings[n].length; i++) {\n                        let b = mol.findBond(rings[n][i], rings[n][i == rings[n].length - 1 ? 0 : i + 1]);\n                        if (this.bondArom[b - 1])\n                            continue;\n                        let bo = mol.bondOrder(b);\n                        phase1 = phase1 && bo == (2 - (i & 1));\n                        phase2 = phase2 && bo == (1 + (i & 1));\n                    }\n                    if (!phase1 && !phase2)\n                        continue;\n                    for (let i = 0; i < rings[n].length; i++) {\n                        let b = mol.findBond(rings[n][i], rings[n][i == rings[n].length - 1 ? 0 : i + 1]);\n                        this.bondArom[b - 1] = true;\n                    }\n                    mask[n] = true;\n                    anyChange = true;\n                }\n            if (!anyChange)\n                break;\n        }\n        for (let n = 0; n < this.bondArom.length; n++)\n            if (this.bondArom[n]) {\n                this.atomArom[mol.bondFrom(n + 1) - 1] = true;\n                this.atomArom[mol.bondTo(n + 1) - 1] = true;\n            }\n    }\n    calculateRelaxedAromaticity() {\n        let mol = this.mol;\n        this.atomArom = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.booleanArray(false, mol.numAtoms);\n        this.bondArom = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.booleanArray(false, mol.numBonds);\n        this.ensurePiAtoms();\n        const na = mol.numAtoms, nb = mol.numBonds;\n        let electrons = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.numberArray(0, na);\n        let exocyclic = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.booleanArray(false, na);\n        for (let n = 1; n <= na; n++) {\n            let atno = mol.atomicNumber(n);\n            electrons[n - 1] = (_Chemistry__WEBPACK_IMPORTED_MODULE_1__.Chemistry.ELEMENT_BLOCKS[atno] == 2 ? _Chemistry__WEBPACK_IMPORTED_MODULE_1__.Chemistry.ELEMENT_VALENCE[atno] : 0) - mol.atomCharge(n) - mol.atomHydrogens(n)\n                - mol.atomUnpaired(n);\n        }\n        for (let n = 1; n <= nb; n++) {\n            const bfr = mol.bondFrom(n), bto = mol.bondTo(n), bo = mol.bondOrder(n);\n            electrons[bfr - 1] -= bo;\n            electrons[bto - 1] -= bo;\n            if (bo == 2) {\n                const rblk1 = mol.atomRingBlock(bfr), rblk2 = mol.atomRingBlock(bto);\n                if (rblk1 > 0 && rblk1 != rblk2)\n                    exocyclic[bfr - 1] = true;\n                if (rblk2 > 0 && rblk2 != rblk1)\n                    exocyclic[bto - 1] = true;\n            }\n        }\n        let rings = [];\n        for (let rsz = 3; rsz <= 7; rsz++)\n            for (let rng of mol.findRingsOfSize(rsz)) {\n                let valid = true;\n                for (let n = 0; n < rsz; n++) {\n                    const a = rng[n];\n                    if (!this.piAtom[a - 1] && electrons[a - 1] < 2 && !exocyclic[a - 1]) {\n                        valid = false;\n                        break;\n                    }\n                    let b = mol.findBond(a, rng[n < rsz - 1 ? n + 1 : 0]);\n                    let bo = mol.bondOrder(b);\n                    if (bo != 1 && bo != 2) {\n                        valid = false;\n                        break;\n                    }\n                }\n                if (valid)\n                    rings.push(rng);\n            }\n        while (rings.length > 0) {\n            let anyChange = false;\n            for (let n = 0; n < rings.length; n++) {\n                let r = rings[n];\n                let paths = [0];\n                for (let i = 0; i < r.length; i++) {\n                    const a = r[i];\n                    const b1 = mol.findBond(a, r[i < r.length - 1 ? i + 1 : 0]);\n                    const b2 = mol.findBond(a, r[i > 0 ? i - 1 : r.length - 1]);\n                    if (this.bondArom[b1 - 1]) {\n                        for (let j = paths.length - 1; j >= 0; j--) {\n                            const e = paths[j] + 2;\n                            if (paths.indexOf(e) < 0)\n                                paths = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.append(paths, e);\n                        }\n                    }\n                    else if (mol.bondOrder(b1) == 2)\n                        _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.addTo(paths, 2);\n                    else if (electrons[a - 1] >= 2 && mol.bondOrder(b1) == 1 && mol.bondOrder(b2) == 1)\n                        _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.addTo(paths, 2);\n                }\n                let arom = false;\n                for (let e of paths) {\n                    if (e == 2 && r.length == 3) {\n                        arom = true;\n                        break;\n                    }\n                    if (e == 6) {\n                        arom = true;\n                        break;\n                    }\n                }\n                if (arom) {\n                    for (let i = 0; i < r.length; i++) {\n                        let a = r[i], b = mol.findBond(a, r[i < r.length - 1 ? i + 1 : 0]);\n                        this.atomArom[a - 1] = true;\n                        this.bondArom[b - 1] = true;\n                    }\n                    rings.splice(n, 1);\n                    n--;\n                    anyChange = true;\n                }\n            }\n            if (!anyChange)\n                break;\n        }\n    }\n    calculateStereoRubric() {\n        const mol = this.mol, na = mol.numAtoms, nb = mol.numBonds;\n        this.rubricTetra = new Array(na);\n        this.rubricSquare = new Array(na);\n        this.rubricBipy = new Array(na);\n        this.rubricOcta = new Array(na);\n        this.rubricSides = new Array(nb);\n        for (let n = 1; n <= na; n++) {\n            let blk = _Chemistry__WEBPACK_IMPORTED_MODULE_1__.Chemistry.ELEMENT_BLOCKS[mol.atomicNumber(n)];\n            let adjc = mol.atomAdjCount(n), hc = mol.atomHydrogens(n);\n            let ninc = 0, ndec = 0;\n            for (let b of mol.atomAdjBonds(n)) {\n                if (mol.bondType(b) == _Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule.BONDTYPE_INCLINED && mol.bondFrom(b) == n)\n                    ninc++;\n                else if (mol.bondType(b) == _Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule.BONDTYPE_DECLINED && mol.bondFrom(b) == n)\n                    ndec++;\n            }\n            if (blk == 2 && ((adjc == 3 && hc == 1) || (adjc == 4 && hc == 0))) {\n                this.rubricTetra[n - 1] = _Stereochemistry__WEBPACK_IMPORTED_MODULE_5__.Stereochemistry.rubricTetrahedral(mol, n);\n            }\n            else if (blk >= 3 && adjc == 4 && ninc == 1 && ndec == 1) {\n                this.rubricTetra[n - 1] = _Stereochemistry__WEBPACK_IMPORTED_MODULE_5__.Stereochemistry.rubricTetrahedral(mol, n);\n            }\n            if (blk >= 3 && adjc == 4 && hc == 0) {\n                this.rubricSquare[n - 1] = _Stereochemistry__WEBPACK_IMPORTED_MODULE_5__.Stereochemistry.rubricSquarePlanar(mol, n);\n            }\n            if (blk >= 3 && (adjc == 4 || adjc == 5) && hc == 0) {\n                this.rubricBipy[n - 1] = _Stereochemistry__WEBPACK_IMPORTED_MODULE_5__.Stereochemistry.rubricBipyrimidal(mol, n);\n            }\n            if (blk >= 3 && (adjc == 5 || adjc == 6) && hc == 0) {\n                this.rubricOcta[n - 1] = _Stereochemistry__WEBPACK_IMPORTED_MODULE_5__.Stereochemistry.rubricOctahedral(mol, n);\n            }\n            else if (blk == 2 && adjc == 6 && hc == 0) {\n                this.rubricOcta[n - 1] = _Stereochemistry__WEBPACK_IMPORTED_MODULE_5__.Stereochemistry.rubricOctahedral(mol, n);\n            }\n        }\n        for (let n = 1; n <= mol.numBonds; n++) {\n            if (mol.bondOrder(n) != 2 || mol.bondType(n) == _Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule.BONDTYPE_UNKNOWN || this.isBondAromatic(n))\n                continue;\n            let bfr = mol.bondFrom(n), bto = mol.bondTo(n);\n            let blk1 = _Chemistry__WEBPACK_IMPORTED_MODULE_1__.Chemistry.ELEMENT_BLOCKS[mol.atomicNumber(bfr)];\n            let blk2 = _Chemistry__WEBPACK_IMPORTED_MODULE_1__.Chemistry.ELEMENT_BLOCKS[mol.atomicNumber(bto)];\n            let adjc1 = mol.atomAdjCount(bfr), hc1 = mol.atomHydrogens(bfr);\n            let adjc2 = mol.atomAdjCount(bto), hc2 = mol.atomHydrogens(bto);\n            if (blk1 == 2 && blk2 == 2 && (adjc1 + hc1 == 3 && hc1 <= 1) && (adjc2 + hc2 == 3 && hc2 <= 1)) {\n                this.rubricSides[n - 1] = _Stereochemistry__WEBPACK_IMPORTED_MODULE_5__.Stereochemistry.rubricBondSides(mol, n);\n            }\n        }\n    }\n    removeHydrogens() {\n        let mol = this.mol, na = mol.numAtoms, nb = mol.numBonds;\n        let atomMask = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.booleanArray(true, na), bondMask = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.booleanArray(true, nb);\n        for (let n = 1; n <= na; n++)\n            if (_MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.boringHydrogen(mol, n)) {\n                atomMask[n - 1] = false;\n                bondMask[mol.atomAdjBonds(n)[0] - 1] = false;\n            }\n        if (_util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.allTrue(atomMask))\n            return;\n        mol = _MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.subgraphMask(mol, atomMask);\n        if (this.atomArom)\n            this.atomArom = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.maskGet(this.atomArom, atomMask);\n        if (this.bondArom)\n            this.bondArom = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.maskGet(this.bondArom, bondMask);\n        if (this.rubricTetra || this.rubricSquare || this.rubricBipy || this.rubricOcta || this.rubricSides) {\n            if (this.rubricTetra)\n                this.rubricTetra = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.maskGet(this.rubricTetra, atomMask);\n            if (this.rubricSquare)\n                this.rubricSquare = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.maskGet(this.rubricSquare, atomMask);\n            if (this.rubricBipy)\n                this.rubricBipy = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.maskGet(this.rubricBipy, atomMask);\n            if (this.rubricOcta)\n                this.rubricOcta = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.maskGet(this.rubricOcta, atomMask);\n            if (this.rubricSides)\n                this.rubricSides = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.maskGet(this.rubricSides, bondMask);\n            let atomMap = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.prepend(_util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.add(_util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.maskMap(atomMask), 1), 0);\n            for (let n = 0; n < _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.len(this.rubricTetra); n++)\n                if (this.rubricTetra[n])\n                    this.rubricTetra[n] = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.idxGet(atomMap, this.rubricTetra[n]);\n            for (let n = 0; n < _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.len(this.rubricSquare); n++)\n                if (this.rubricSquare[n])\n                    this.rubricSquare[n] = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.idxGet(atomMap, this.rubricSquare[n]);\n            for (let n = 0; n < _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.len(this.rubricBipy); n++)\n                if (this.rubricBipy[n])\n                    this.rubricBipy[n] = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.idxGet(atomMap, this.rubricBipy[n]);\n            for (let n = 0; n < _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.len(this.rubricOcta); n++)\n                if (this.rubricOcta[n])\n                    this.rubricOcta[n] = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.idxGet(atomMap, this.rubricOcta[n]);\n            for (let n = 0; n < _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.len(this.rubricSides); n++)\n                if (this.rubricSides[n])\n                    this.rubricSides[n] = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.idxGet(atomMap, this.rubricSides[n]);\n        }\n    }\n    calculateSkeletonHash() {\n        if (MetaMolecule.skeletonHash == null)\n            throw 'Skeleton hash not available.';\n        this.hash = MetaMolecule.skeletonHash(this.mol);\n    }\n    calculateHeavyHash() {\n        let anyH = false;\n        for (let n = 1; n <= this.mol.numAtoms; n++)\n            if (this.mol.atomElement(n) == 'H') {\n                anyH = true;\n                break;\n            }\n        if (!anyH) {\n            this.heavyHash = this.getSkeletonHash();\n            return;\n        }\n        let hvy = this.mol.clone();\n        for (let n = hvy.numAtoms; n >= 1; n--)\n            if (hvy.atomElement(n) == 'H')\n                hvy.deleteAtomAndBonds(n);\n        this.heavyHash = MetaMolecule.skeletonHash(hvy);\n    }\n    isAtomAromatic(atom) {\n        return this.atomArom == null ? false : this.atomArom[atom - 1];\n    }\n    isBondAromatic(bond) {\n        return this.bondArom == null ? false : this.bondArom[bond - 1];\n    }\n    bondOrderArom(bond) {\n        return this.bondArom != null && this.bondArom[bond - 1] ? -1 : this.mol.bondOrder(bond);\n    }\n    getAtomAromaticity() {\n        return this.atomArom == null ? null : this.atomArom.slice(0);\n    }\n    getBondAromaticity() {\n        return this.bondArom == null ? null : this.bondArom.slice(0);\n    }\n    getSkeletonHash() {\n        if (this.hash == null)\n            this.calculateSkeletonHash();\n        return this.hash;\n    }\n    getHeavyHash() {\n        if (this.heavyHash == null)\n            this.calculateHeavyHash();\n        return this.heavyHash;\n    }\n    getDotPath() {\n        if (this.dots == null)\n            this.dots = new _DotPath__WEBPACK_IMPORTED_MODULE_2__.DotPath(this.mol);\n        return this.dots;\n    }\n    getUniqueElements() {\n        if (this.uniqueElements == null) {\n            this.uniqueElements = [];\n            for (let n = 1; n <= this.mol.numAtoms; n++) {\n                let el = this.mol.atomElement(n);\n                if (this.uniqueElements.indexOf(el) < 0)\n                    this.uniqueElements.push(el);\n            }\n        }\n        return this.uniqueElements;\n    }\n    equivalentTo(other, timeout = 1000) {\n        if (MetaMolecule.isomorphMatch == null)\n            throw 'Isomorph search unavailable.';\n        if (this.mol.numAtoms != other.mol.numAtoms || this.mol.numBonds != other.mol.numBonds)\n            return false;\n        if (this.hash == null)\n            this.calculateSkeletonHash();\n        if (other.hash == null)\n            other.calculateSkeletonHash();\n        if (this.hash != other.hash)\n            return false;\n        if (this.mol.compareTo(other.mol) == 0)\n            return true;\n        let uniq1 = this.getUniqueElements(), uniq2 = other.getUniqueElements();\n        for (let n = 0; n < uniq1.length; n++) {\n            if (!uniq2.includes(uniq1[n]))\n                return false;\n        }\n        return MetaMolecule.isomorphMatch(this, other, timeout);\n    }\n    static createRubric(mol) {\n        if (mol == null)\n            return null;\n        let meta = new MetaMolecule(mol);\n        meta.calculateStereoRubric();\n        return meta;\n    }\n    static createStrict(mol) {\n        if (mol == null)\n            return null;\n        let meta = new MetaMolecule(mol);\n        meta.calculateStrictAromaticity();\n        return meta;\n    }\n    static createStrictRubric(mol) {\n        if (mol == null)\n            return null;\n        let meta = new MetaMolecule(mol);\n        meta.calculateStrictAromaticity();\n        meta.calculateStereoRubric();\n        return meta;\n    }\n    static createRelaxed(mol) {\n        if (mol == null)\n            return null;\n        let meta = new MetaMolecule(mol);\n        meta.calculateRelaxedAromaticity();\n        return meta;\n    }\n    static createRelaxedRubric(mol) {\n        if (mol == null)\n            return null;\n        let meta = new MetaMolecule(mol);\n        meta.calculateRelaxedAromaticity();\n        meta.calculateStereoRubric();\n        return meta;\n    }\n    ensurePiAtoms() {\n        if (this.piAtom != null)\n            return;\n        this.piAtom = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.booleanArray(false, this.mol.numAtoms);\n        for (let n = 1; n <= this.mol.numBonds; n++)\n            if (this.mol.bondOrder(n) == 2) {\n                {\n                    this.piAtom[this.mol.bondFrom(n) - 1] = true;\n                    this.piAtom[this.mol.bondTo(n) - 1] = true;\n                }\n            }\n    }\n}\nMetaMolecule.skeletonHash = null;\nMetaMolecule.isomorphMatch = null;\n\n\n//# sourceURL=webpack://WebMolKit/./src/data/MetaMolecule.ts?");

/***/ }),

/***/ "./src/data/MolUtil.ts":
/*!*****************************!*\
  !*** ./src/data/MolUtil.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MolUtil\": () => (/* binding */ MolUtil)\n/* harmony export */ });\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _Chemistry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Chemistry */ \"./src/data/Chemistry.ts\");\n/* harmony import */ var _CoordUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CoordUtil */ \"./src/data/CoordUtil.ts\");\n/* harmony import */ var _Graph__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Graph */ \"./src/data/Graph.ts\");\n/* harmony import */ var _Molecule__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Molecule */ \"./src/data/Molecule.ts\");\n/* harmony import */ var _PolymerBlock__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./PolymerBlock */ \"./src/data/PolymerBlock.ts\");\n/* harmony import */ var _SketchUtil__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./SketchUtil */ \"./src/data/SketchUtil.ts\");\n\n\n\n\n\n\n\nclass MolUtil {\n    static isBlank(mol) {\n        if (mol == null)\n            return true;\n        return mol.numAtoms == 0;\n    }\n    static notBlank(mol) {\n        if (mol == null)\n            return false;\n        return mol.numAtoms > 0;\n    }\n    static orBlank(mol) { return mol == null ? new _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule() : mol; }\n    static hasAnyAbbrev(mol) {\n        for (let n = 1; n <= mol.numAtoms; n++)\n            if (MolUtil.hasAbbrev(mol, n))\n                return true;\n        return false;\n    }\n    static hasAbbrev(mol, atom) {\n        let extra = mol.atomExtra(atom);\n        for (let n = 0; n < (extra == null ? 0 : extra.length); n++)\n            if (extra[n].startsWith('a'))\n                return true;\n        return false;\n    }\n    static getAbbrev(mol, atom) {\n        let extra = mol.atomExtra(atom);\n        for (let n = 0; n < (extra != null ? extra.length : 0); n++)\n            if (extra[n].startsWith('a')) {\n                return _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.fromString(extra[n].substring(1));\n            }\n        return null;\n    }\n    static setAbbrev(mol, atom, frag) {\n        let attidx = 0;\n        for (let n = 1; n <= frag.numAtoms; n++)\n            if (frag.atomElement(n) == MolUtil.ABBREV_ATTACHMENT) {\n                if (attidx > 0)\n                    throw 'Multiple attachment points indicated: invalid.';\n                attidx = n;\n            }\n        if (attidx == 0)\n            throw 'No attachment points indicated.';\n        if (attidx >= 2) {\n            frag = frag.clone();\n            frag.swapAtoms(attidx, 1);\n        }\n        let adj = mol.atomAdjList(atom);\n        if (adj.length > 1)\n            throw 'Setting abbreviation for non-terminal atom.';\n        if (frag.atomAdjCount(1) == 1 && mol.atomAdjCount(atom) > 0) {\n            let b1 = mol.findBond(atom, mol.atomAdjList(atom)[0]);\n            let b2 = frag.findBond(1, frag.atomAdjList(1)[0]);\n            mol.setBondOrder(b1, frag.bondOrder(b2));\n        }\n        let extra = mol.atomExtra(atom);\n        let idx = -1;\n        for (let n = 0; n < (extra != null ? extra.length : 0); n++)\n            if (extra[n].startsWith('a')) {\n                idx = n;\n                break;\n            }\n        if (idx < 0)\n            idx = extra.push(null) - 1;\n        extra[idx] = 'a' + frag.toString();\n        mol.setAtomExtra(atom, extra);\n    }\n    static validateAbbrevs(mol) {\n        for (let n = 1; n <= mol.numAtoms; n++)\n            if (MolUtil.hasAbbrev(mol, n)) {\n                if (mol.atomAdjCount(n) > 1)\n                    MolUtil.clearAbbrev(mol, n);\n                if (mol.atomCharge(n) != 0)\n                    mol.setAtomCharge(n, 0);\n                if (mol.atomUnpaired(n) != 0)\n                    mol.setAtomUnpaired(n, 0);\n                if (mol.atomIsotope(n) != 0)\n                    mol.setAtomIsotope(n, _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.ISOTOPE_NATURAL);\n                if (mol.atomHExplicit(n) != _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.HEXPLICIT_UNKNOWN)\n                    mol.setAtomHExplicit(n, _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.HEXPLICIT_UNKNOWN);\n            }\n    }\n    static convertToAbbrev(mol, srcmask, abbrevName) {\n        let molidx = this.convertToAbbrevIndex(mol, srcmask, abbrevName);\n        return molidx ? molidx[0] : null;\n    }\n    static convertToAbbrevIndex(mol, srcmask, abbrevName) {\n        let junction = 0;\n        let polymerExtra = null;\n        for (let n = 1; n <= mol.numBonds; n++) {\n            let b1 = mol.bondFrom(n), b2 = mol.bondTo(n), atom = 0;\n            if (srcmask[b1 - 1] && !srcmask[b2 - 1]) {\n                atom = b1;\n                polymerExtra = _PolymerBlock__WEBPACK_IMPORTED_MODULE_5__.PolymerBlock.getPolymerExtensions(mol, b2);\n            }\n            else if (!srcmask[b1 - 1] && srcmask[b2 - 1]) {\n                atom = b2;\n                polymerExtra = _PolymerBlock__WEBPACK_IMPORTED_MODULE_5__.PolymerBlock.getPolymerExtensions(mol, b1);\n            }\n            if (atom == 0)\n                continue;\n            if (junction > 0 && atom != junction)\n                return null;\n            junction = atom;\n        }\n        if (junction == 0)\n            return null;\n        let na = mol.numAtoms, molidx = 0, fragidx = 0;\n        let maskmol = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.booleanArray(false, na), maskfrag = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.booleanArray(false, na);\n        for (let n = 0; n < na; n++) {\n            maskmol[n] = srcmask[n];\n            maskfrag[n] = !srcmask[n] || n + 1 == junction;\n            if (maskmol[n] && n + 1 <= junction)\n                molidx++;\n            if (maskfrag[n] && n + 1 <= junction)\n                fragidx++;\n        }\n        let bondType = _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_NORMAL, nadj = 0;\n        for (let a of mol.atomAdjList(junction))\n            if (!srcmask[a - 1]) {\n                if (nadj != 0) {\n                    bondType = _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_NORMAL;\n                    break;\n                }\n                let b = mol.findBond(junction, a);\n                if (mol.bondFrom(b) == junction)\n                    bondType = mol.bondType(b);\n                nadj++;\n            }\n        let frag = MolUtil.subgraphMask(mol, maskfrag);\n        frag.setAtomElement(fragidx, MolUtil.ABBREV_ATTACHMENT);\n        frag.setAtomCharge(fragidx, 0);\n        frag.setAtomUnpaired(fragidx, 0);\n        frag.setAtomHExplicit(fragidx, _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.HEXPLICIT_UNKNOWN);\n        frag.setAtomMapNum(fragidx, 0);\n        frag.setAtomExtra(fragidx, []);\n        frag.setAtomTransient(fragidx, []);\n        let adj = frag.atomAdjList(fragidx);\n        let x = 0, y = 0, inv = 1.0 / adj.length;\n        let bondOrder = 1;\n        for (let n = 0; n < adj.length; n++) {\n            x += frag.atomX(adj[n]);\n            y += frag.atomY(adj[n]);\n            let b = frag.findBond(fragidx, adj[n]);\n            if (n == 0)\n                bondOrder = frag.bondOrder(b);\n            else if (bondOrder != frag.bondOrder(b))\n                bondOrder = 1;\n        }\n        x *= inv;\n        y *= inv;\n        let newmol = MolUtil.subgraphMask(mol, maskmol);\n        let newatom = newmol.addAtom(abbrevName, x, y);\n        newmol.addBond(molidx, newatom, bondOrder, bondType);\n        MolUtil.setAbbrev(newmol, newatom, frag);\n        if (polymerExtra != null)\n            newmol.setAtomExtra(newatom, _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.concat(newmol.atomExtra(newatom), polymerExtra));\n        return [newmol, newatom];\n    }\n    static expandAbbrevs(mol, alignCoords) {\n        while (true) {\n            let anything = false;\n            for (let n = 1; n <= mol.numAtoms; n++)\n                if (MolUtil.hasAbbrev(mol, n)) {\n                    if (MolUtil.expandOneAbbrev(mol, n, alignCoords))\n                        anything = true;\n                    n--;\n                }\n            if (!anything)\n                break;\n        }\n    }\n    static expandOneAbbrev(mol, atom, alignCoords) {\n        let frag = MolUtil.getAbbrev(mol, atom);\n        if (frag == null)\n            return null;\n        if (mol.atomAdjCount(atom) != 1 || frag.numAtoms == 0) {\n            MolUtil.clearAbbrev(mol, atom);\n            return null;\n        }\n        let m = mol.atomMapNum(atom);\n        if (m > 0)\n            for (let n of frag.atomAdjList(1))\n                frag.setAtomMapNum(n, m);\n        return MolUtil.expandOneAbbrevFrag(mol, atom, frag, alignCoords);\n    }\n    static expandOneAbbrevFrag(mol, atom, frag, alignCoords) {\n        let polymerExtra = _PolymerBlock__WEBPACK_IMPORTED_MODULE_5__.PolymerBlock.getPolymerExtensions(mol, atom);\n        let nbr = mol.atomAdjCount(atom) == 1 ? mol.atomAdjList(atom)[0] : 0;\n        let connBond = mol.findBond(atom, nbr), connType = _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_NORMAL;\n        if (connBond > 0) {\n            connType = mol.bondType(connBond);\n            if (mol.bondFrom(connBond) != nbr && (connType == _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_INCLINED || connType == _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_DECLINED))\n                connType = _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_NORMAL;\n        }\n        if (alignCoords) {\n            let vx1 = mol.atomX(atom) - mol.atomX(nbr), vy1 = mol.atomY(atom) - mol.atomY(nbr);\n            let adj = frag.atomAdjList(1);\n            let vx2 = 0, vy2 = 0, inv = 1.0 / adj.length;\n            for (let n = 0; n < adj.length; n++) {\n                vx2 += frag.atomX(adj[n]) - frag.atomX(1);\n                vy2 += frag.atomY(adj[n]) - frag.atomY(1);\n            }\n            vx2 *= inv;\n            vy2 *= inv;\n            let th1 = Math.atan2(vy1, vx1), th2 = Math.atan2(vy2, vx2);\n            _CoordUtil__WEBPACK_IMPORTED_MODULE_2__.CoordUtil.rotateMolecule(frag, th1 - th2);\n            _CoordUtil__WEBPACK_IMPORTED_MODULE_2__.CoordUtil.translateMolecule(frag, mol.atomX(nbr) - frag.atomX(1), mol.atomY(nbr) - frag.atomY(1));\n        }\n        if (polymerExtra != null) {\n            for (let n = 1; n <= frag.numAtoms; n++) {\n                let extra = frag.atomExtra(n);\n                for (let i = extra.length - 1; i >= 0; i--)\n                    if (polymerExtra.indexOf(extra[i]) >= 0)\n                        extra.splice(i, 1);\n                frag.setAtomExtra(n, _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.concat(extra, polymerExtra));\n            }\n        }\n        let join = mol.numAtoms + 1;\n        mol.append(frag);\n        for (let n = 1; n <= mol.numBonds; n++) {\n            if (mol.bondFrom(n) == join) {\n                mol.setBondFrom(n, nbr);\n                mol.setBondType(n, connType);\n            }\n            else if (mol.bondTo(n) == join) {\n                mol.setBondFromTo(n, nbr, mol.bondFrom(n));\n                mol.setBondType(n, connType);\n            }\n        }\n        let mask = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.booleanArray(false, mol.numAtoms);\n        for (let n = mask.length - frag.numAtoms; n < mask.length; n++)\n            mask[n] = true;\n        mol.deleteAtomAndBonds(join);\n        mol.deleteAtomAndBonds(atom);\n        mask.splice(join - 1, 1);\n        mask.splice(atom - 1, 1);\n        return mask;\n    }\n    static clearAbbrev(mol, atom) {\n        let extra = mol.atomExtra(atom);\n        for (let n = 0; n < (extra != null ? extra.length : 0); n++)\n            if (extra[n].startsWith('a')) {\n                extra.splice(n, 1);\n                mol.setAtomExtra(atom, extra);\n                mol.setAtomElement(atom, 'C');\n                return;\n            }\n    }\n    static setAtomElement(mol, atom, el) {\n        if (mol.atomElement(atom) == el)\n            return;\n        this.clearAbbrev(mol, atom);\n        mol.setAtomElement(atom, el);\n    }\n    static addBond(mol, bfr, bto, order, type) {\n        if (type == null)\n            type = _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_NORMAL;\n        if (mol.atomAdjCount(bfr) >= 1)\n            this.clearAbbrev(mol, bfr);\n        if (mol.atomAdjCount(bto) >= 1)\n            this.clearAbbrev(mol, bto);\n        let b = mol.findBond(bfr, bto);\n        if (b > 0)\n            mol.deleteBond(b);\n        return mol.addBond(bfr, bto, order, type);\n    }\n    static subgraphMask(mol, mask) {\n        let invidx = [];\n        let sum = 0;\n        for (let n = 0; n < mol.numAtoms; n++) {\n            if (mask[n])\n                invidx.push(++sum);\n            else\n                invidx.push(0);\n        }\n        if (sum == 0)\n            return new _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule();\n        if (sum == mol.numAtoms)\n            return mol.clone();\n        let frag = new _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule();\n        for (let n = 1; n <= mol.numAtoms; n++)\n            if (mask[n - 1]) {\n                let num = frag.addAtom(mol.atomElement(n), mol.atomX(n), mol.atomY(n), mol.atomCharge(n), mol.atomUnpaired(n));\n                frag.setAtomIsotope(num, mol.atomIsotope(n));\n                frag.setAtomHExplicit(num, mol.atomHExplicit(n));\n                frag.setAtomMapNum(num, mol.atomMapNum(n));\n                frag.setAtomExtra(num, mol.atomExtra(n));\n            }\n        for (let n = 1; n <= mol.numBonds; n++) {\n            let bfr = invidx[mol.bondFrom(n) - 1], bto = invidx[mol.bondTo(n) - 1];\n            if (bfr > 0 && bto > 0) {\n                let num = frag.addBond(bfr, bto, mol.bondOrder(n), mol.bondType(n));\n                frag.setBondExtra(num, mol.bondExtra(n));\n            }\n        }\n        return frag;\n    }\n    static subgraphIndex(mol, idx) {\n        let invidx = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.numberArray(0, mol.numAtoms);\n        for (let n = 0; n < invidx.length; n++)\n            invidx[n] = 0;\n        for (let n = 0; n < idx.length; n++)\n            invidx[idx[n] - 1] = n + 1;\n        let frag = new _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule();\n        frag.keepTransient = mol.keepTransient;\n        for (let n = 0; n < idx.length; n++) {\n            let num = frag.addAtom(mol.atomElement(idx[n]), mol.atomX(idx[n]), mol.atomY(idx[n]), mol.atomCharge(idx[n]), mol.atomUnpaired(idx[n]));\n            frag.setAtomIsotope(num, mol.atomIsotope(idx[n]));\n            frag.setAtomHExplicit(num, mol.atomHExplicit(idx[n]));\n            frag.setAtomMapNum(num, mol.atomMapNum(idx[n]));\n            frag.setAtomExtra(num, mol.atomExtra(idx[n]));\n            if (mol.keepTransient)\n                frag.setAtomTransient(num, mol.atomTransient(idx[n]));\n        }\n        for (let n = 1; n <= mol.numBonds; n++) {\n            let bfr = invidx[mol.bondFrom(n) - 1], bto = invidx[mol.bondTo(n) - 1];\n            if (bfr > 0 && bto > 0) {\n                let num = frag.addBond(bfr, bto, mol.bondOrder(n), mol.bondType(n));\n                frag.setBondExtra(num, mol.bondExtra(n));\n                if (mol.keepTransient)\n                    frag.setBondTransient(num, mol.bondTransient(n));\n            }\n        }\n        return frag;\n    }\n    static subgraphWithAttachments(mol, mask) {\n        let xmask = mask.slice(0);\n        for (let n = 1; n <= mol.numBonds; n++) {\n            let bfr = mol.bondFrom(n) - 1, bto = mol.bondTo(n) - 1;\n            if (mask[bfr] && !mask[bto])\n                xmask[bto] = true;\n            else if (mask[bto] && !mask[bfr])\n                xmask[bfr] = true;\n        }\n        let xmol = mol.clone();\n        for (let n = 1; n <= xmol.numAtoms; n++)\n            if (xmask[n - 1] && !mask[n - 1]) {\n                xmol.setAtomElement(n, 'X');\n                xmol.setAtomCharge(n, 0);\n                xmol.setAtomUnpaired(n, 0);\n                xmol.setAtomHExplicit(n, _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.HEXPLICIT_UNKNOWN);\n                xmol.setAtomExtra(n, []);\n            }\n        return MolUtil.subgraphMask(xmol, xmask);\n    }\n    static append(mol, frag) {\n        let boxm = mol.boundary(), boxf = frag.boundary();\n        let dx = boxm.maxX() + _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.IDEALBOND - boxm.minX();\n        let dy = 0.5 * (boxm.minY() + boxm.maxY() - boxf.minY() - boxf.maxY());\n        let top = mol.numAtoms;\n        mol.append(frag);\n        for (let n = top + 1; n <= mol.numAtoms; n++)\n            mol.setAtomPos(n, mol.atomX(n) + dx, mol.atomY(n) + dy);\n    }\n    static deleteAtoms(mol, idx) {\n        let mask = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.booleanArray(true, mol.numAtoms);\n        for (let n = 0; n < idx.length; n++)\n            mask[idx[n] - 1] = false;\n        return MolUtil.subgraphMask(mol, mask);\n    }\n    static componentList(mol) {\n        let sz = mol.numAtoms;\n        if (sz == 0)\n            return null;\n        let g = _Graph__WEBPACK_IMPORTED_MODULE_3__.Graph.fromMolecule(mol);\n        let groups = g.calculateComponentGroups();\n        for (let grp of groups)\n            _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.addTo(grp, 1);\n        return groups;\n    }\n    static getAtomSides(mol, atom) {\n        let g = _Graph__WEBPACK_IMPORTED_MODULE_3__.Graph.fromMolecule(mol);\n        let cc = g.calculateComponents();\n        let mask = [];\n        for (let n = 0; n < cc.length; n++)\n            mask.push(cc[n] == cc[atom - 1]);\n        mask[atom - 1] = false;\n        let oldmap = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.maskIdx(mask);\n        g.keepNodesMask(mask);\n        cc = g.calculateComponents();\n        let ccmax = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.max(cc);\n        let grps = [];\n        for (let n = 0; n < ccmax; n++)\n            grps.push([atom]);\n        for (let n = 0; n < cc.length; n++)\n            grps[cc[n] - 1].push(oldmap[n] + 1);\n        return grps;\n    }\n    static getBondSides(mol, bond) {\n        let bf = mol.bondFrom(bond), bt = mol.bondTo(bond);\n        let inRing = mol.bondInRing(bond);\n        let g = _Graph__WEBPACK_IMPORTED_MODULE_3__.Graph.fromMolecule(mol);\n        let cc = g.calculateComponents();\n        let mask = [];\n        for (let n = 0; n < cc.length; n++)\n            mask.push(cc[n] == cc[bf - 1]);\n        if (!inRing)\n            g.removeEdge(bf - 1, bt - 1);\n        else {\n            mask[bf - 1] = false;\n            mask[bt - 1] = false;\n        }\n        let oldmap = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.maskIdx(mask);\n        g.keepNodesMask(mask);\n        cc = g.calculateComponents();\n        let ccmax = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.max(cc);\n        let grps = [];\n        for (let n = 0; n < ccmax; n++) {\n            grps[n] = [];\n            if (inRing) {\n                grps[n].push(bf);\n                grps[n].push(bt);\n            }\n        }\n        for (let n = 0; n < cc.length; n++)\n            grps[cc[n] - 1].push(oldmap[n] + 1);\n        return grps;\n    }\n    static arrayAtomX(mol) {\n        let x = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.numberArray(0, mol.numAtoms);\n        for (let n = x.length - 1; n >= 0; n--)\n            x[n] = mol.atomX(n + 1);\n        return x;\n    }\n    static arrayAtomY(mol) {\n        let y = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.numberArray(0, mol.numAtoms);\n        for (let n = y.length - 1; n >= 0; n--)\n            y[n] = mol.atomY(n + 1);\n        return y;\n    }\n    static arrayAtomMapNum(mol) {\n        let mapnum = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.numberArray(0, mol.numAtoms);\n        for (let n = mapnum.length - 1; n >= 0; n--)\n            mapnum[n] = mol.atomMapNum(n + 1);\n        return mapnum;\n    }\n    static molecularFormula(mol, punctuation) {\n        let puncEnter = '', puncExit = '', puncEnterSuper = '', puncExitSuper = '';\n        if (punctuation == true)\n            [puncEnter, puncExit] = ['{', '}', '{^', '}'];\n        else if (punctuation instanceof Array) {\n            puncEnter = punctuation[0];\n            puncExit = punctuation[1];\n            puncEnterSuper = punctuation[2];\n            puncExitSuper = punctuation[3];\n        }\n        for (let n = 1; n <= mol.numAtoms; n++)\n            if (MolUtil.hasAbbrev(mol, n)) {\n                mol = mol.clone();\n                MolUtil.expandAbbrevs(mol, false);\n                break;\n            }\n        let countC = 0, countH = 0;\n        let elements = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.stringArray('', mol.numAtoms);\n        for (let n = 1; n <= mol.numAtoms; n++) {\n            countH += mol.atomHydrogens(n);\n            let el = mol.atomElement(n);\n            if (mol.atomIsotope(n) != _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.ISOTOPE_NATURAL)\n                el = puncEnterSuper + mol.atomIsotope(n) + puncExitSuper + el;\n            if (el == 'C')\n                countC++;\n            else if (el == 'H')\n                countH++;\n            else\n                elements[n - 1] = el;\n        }\n        elements.sort();\n        let formula = '';\n        if (countC > 0)\n            formula += 'C';\n        if (countC > 1) {\n            if (punctuation)\n                formula += puncEnter;\n            formula += countC;\n            if (punctuation)\n                formula += puncExit;\n        }\n        if (countH > 0)\n            formula += 'H';\n        if (countH > 1) {\n            if (punctuation)\n                formula += puncEnter;\n            formula += countH;\n            if (punctuation)\n                formula += puncExit;\n        }\n        for (let n = 0; n < elements.length; n++)\n            if (elements[n].length > 0) {\n                let count = 1;\n                for (; n + 1 < elements.length && elements[n] == elements[n + 1]; n++)\n                    count++;\n                formula += elements[n];\n                if (count > 1) {\n                    if (punctuation)\n                        formula += puncEnter;\n                    formula += count;\n                    if (punctuation)\n                        formula += puncExit;\n                }\n            }\n        return formula.toString();\n    }\n    static molecularWeight(mol) {\n        for (let n = 1; n <= mol.numAtoms; n++)\n            if (MolUtil.hasAbbrev(mol, n)) {\n                mol = mol.clone();\n                MolUtil.expandAbbrevs(mol, false);\n                break;\n            }\n        let mw = 0;\n        for (let n = 1; n <= mol.numAtoms; n++) {\n            mw += mol.atomHydrogens(n) * _Chemistry__WEBPACK_IMPORTED_MODULE_1__.Chemistry.NATURAL_ATOMIC_WEIGHTS[1];\n            let iso = mol.atomIsotope(n);\n            if (iso != _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.ISOTOPE_NATURAL) {\n                mw += iso;\n                continue;\n            }\n            let an = _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.elementAtomicNumber(mol.atomElement(n));\n            if (an > 0 && an < _Chemistry__WEBPACK_IMPORTED_MODULE_1__.Chemistry.NATURAL_ATOMIC_WEIGHTS.length)\n                mw += _Chemistry__WEBPACK_IMPORTED_MODULE_1__.Chemistry.NATURAL_ATOMIC_WEIGHTS[an];\n        }\n        return mw;\n    }\n    static removeDuplicateBonds(mol) {\n        let bpri = [];\n        for (let n = 1; n <= mol.numBonds; n++) {\n            let p = Math.min(mol.bondFrom(n), mol.bondTo(n)) * mol.numAtoms + Math.max(mol.bondFrom(n), mol.bondTo(n));\n            bpri.push(p);\n        }\n        let bidx = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.idxSort(bpri);\n        let keepmask = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.booleanArray(false, bidx.length);\n        let p = 0;\n        while (p < bidx.length) {\n            let sz = 1;\n            while (p + sz < bidx.length && bpri[bidx[p]] == bpri[bidx[p + sz]])\n                sz++;\n            let best = p;\n            for (let n = p + 1; n < p + sz; n++) {\n                let b1 = bidx[best] + 1, b2 = bidx[n] + 1;\n                let a1 = mol.bondFrom(b1), a2 = mol.bondTo(b1);\n                let el1 = mol.atomElement(a1), el2 = mol.atomElement(a2);\n                let limit1 = 0, limit2 = 0;\n                if (el1 == 'C' || el1 == 'N')\n                    limit1 = 4;\n                else if (el1 == 'O')\n                    limit1 = 3;\n                if (el2 == 'C' || el2 == 'N')\n                    limit2 = 4;\n                else if (el2 == 'O')\n                    limit2 = 3;\n                if (limit1 > 0 || limit2 > 0) {\n                    let boB1A1 = 0, boB1A2 = 0, boB2A1 = 0, boB2A2 = 0;\n                    for (let i = 1; i <= mol.numBonds; i++) {\n                        if (i != b2 && (mol.bondFrom(i) == a1 || mol.bondTo(i) == a1))\n                            boB1A1 += mol.bondOrder(i);\n                        if (i != b2 && (mol.bondFrom(i) == a2 || mol.bondTo(i) == a2))\n                            boB1A2 += mol.bondOrder(i);\n                        if (i != b1 && (mol.bondFrom(i) == a1 || mol.bondTo(i) == a1))\n                            boB2A1 += mol.bondOrder(i);\n                        if (i != b1 && (mol.bondFrom(i) == a2 || mol.bondTo(i) == a2))\n                            boB2A2 += mol.bondOrder(i);\n                    }\n                    let bad1 = 0, bad2 = 0;\n                    if (limit1 > 0 && boB1A1 > limit1)\n                        bad1++;\n                    if (limit2 > 0 && boB1A2 > limit2)\n                        bad1++;\n                    if (limit1 > 0 && boB2A1 > limit1)\n                        bad2++;\n                    if (limit2 > 0 && boB2A2 > limit2)\n                        bad2++;\n                    if (bad1 < bad2)\n                        continue;\n                    if (bad1 > bad2) {\n                        best = n;\n                        continue;\n                    }\n                }\n                let exotic1 = 2 * mol.bondOrder(b1), exotic2 = 2 * mol.bondOrder(b2);\n                exotic1 += (exotic1 == 0 ? 4 : 0) + (mol.bondType(b1) != _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_NORMAL ? 1 : 0);\n                exotic2 += (exotic2 == 0 ? 4 : 0) + (mol.bondType(b2) != _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_NORMAL ? 1 : 0);\n                if (exotic2 > exotic1)\n                    best = n;\n            }\n            keepmask[bidx[best]] = true;\n            p += sz;\n        }\n        for (let n = mol.numBonds; n >= 1; n--)\n            if (!keepmask[n - 1] || mol.bondFrom(n) == mol.bondTo(n))\n                mol.deleteBond(n);\n    }\n    static calculateWalkWeight(mol, atom) {\n        let ccsz = 0, cc = _Graph__WEBPACK_IMPORTED_MODULE_3__.Graph.fromMolecule(mol).calculateComponents();\n        for (let n = 0; n < cc.length; n++)\n            if (cc[n] == cc[atom - 1])\n                ccsz++;\n        let w = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.numberArray(1, mol.numAtoms), wn = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.numberArray(0, mol.numAtoms);\n        w[atom - 1] = 0;\n        for (; ccsz > 0; ccsz--) {\n            for (let n = 0; n < mol.numAtoms; n++)\n                wn[n] = w[n];\n            for (let n = 1; n <= mol.numBonds; n++) {\n                let a1 = mol.bondFrom(n) - 1, a2 = mol.bondTo(n) - 1;\n                w[a1] += wn[a2] * 0.1;\n                w[a2] += wn[a1] * 0.1;\n            }\n            w[atom - 1] = 0;\n        }\n        return w;\n    }\n    static totalHydrogens(mol, atom) {\n        let hc = mol.atomHydrogens(atom);\n        let adj = mol.atomAdjList(atom);\n        for (let n = 0; n < adj.length; n++)\n            if (mol.atomElement(adj[n]) == 'H')\n                hc++;\n        return hc;\n    }\n    static stripHydrogens(mol, force = false) {\n        for (let n = mol.numAtoms; n >= 1; n--)\n            if ((force && mol.atomElement(n) == 'H') || this.boringHydrogen(mol, n))\n                mol.deleteAtomAndBonds(n);\n    }\n    static boringHydrogen(mol, atom) {\n        if (mol.atomElement(atom) != 'H')\n            return false;\n        if (mol.atomCharge(atom) != 0 || mol.atomUnpaired(atom) != 0)\n            return false;\n        if (mol.atomIsotope(atom) != _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.ISOTOPE_NATURAL)\n            return false;\n        if (_util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.notBlank(mol.atomExtra(atom)) || _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.notBlank(mol.atomTransient(atom)))\n            return false;\n        if (mol.atomAdjCount(atom) != 1)\n            return false;\n        let other = mol.atomAdjList(atom)[0];\n        if (mol.atomElement(other) == 'H')\n            return false;\n        let bond = mol.atomAdjBonds(atom)[0];\n        if (mol.bondOrder(bond) != 1 || mol.bondType(bond) != _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_NORMAL)\n            return false;\n        if (mol.atomHExplicit(other) != _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.HEXPLICIT_UNKNOWN)\n            return false;\n        if (_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.HYVALENCE_EL.indexOf(mol.atomElement(other)) < 0)\n            return false;\n        return true;\n    }\n    static createHydrogens(mol, position) {\n        if (position == null)\n            position = false;\n        let na = mol.numAtoms;\n        for (let n = 1; n <= na; n++) {\n            let hc = mol.atomHydrogens(n);\n            if (hc == 0)\n                continue;\n            if (mol.atomHExplicit(n) != _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.HEXPLICIT_UNKNOWN)\n                mol.setAtomHExplicit(n, 0);\n            if (!position) {\n                for (; hc > 0; hc--) {\n                    let a = mol.addAtom('H', mol.atomX(n), mol.atomY(n));\n                    mol.addBond(n, a, 1);\n                }\n            }\n            else\n                _SketchUtil__WEBPACK_IMPORTED_MODULE_6__.SketchUtil.placeAdditionalHydrogens(mol, n, hc);\n        }\n        return mol.numAtoms - na;\n    }\n    static atomVec3(mol, atom) {\n        if (mol.is3D())\n            return [mol.atomX(atom), mol.atomY(atom), mol.atomZ(atom)];\n        else\n            return [mol.atomX(atom), mol.atomY(atom), 0];\n    }\n    static atomOxidationState(mol, atom) {\n        if (mol.atomAdjCount(atom) == 0)\n            return null;\n        if (this.hasAbbrev(mol, atom))\n            return null;\n        let atno = mol.atomicNumber(atom);\n        if (atno == 0)\n            return null;\n        let nonMetal = atno == _Chemistry__WEBPACK_IMPORTED_MODULE_1__.Chemistry.ELEMENT_H || _Chemistry__WEBPACK_IMPORTED_MODULE_1__.Chemistry.ELEMENT_BLOCKS[atno] == 2;\n        let oxstate = mol.atomHydrogens(atom) + (nonMetal ? -mol.atomCharge(atom) : mol.atomCharge(atom));\n        for (let b of mol.atomAdjBonds(atom)) {\n            let bo = mol.bondOrder(b), other = mol.bondOther(b, atom);\n            let chalco = ['O', 'S', 'Se', 'Te'].includes(mol.atomElement(other));\n            if (nonMetal || chalco)\n                oxstate += bo;\n            else\n                oxstate += bo % 2;\n        }\n        if (atno == _Chemistry__WEBPACK_IMPORTED_MODULE_1__.Chemistry.ELEMENT_H && oxstate == 1)\n            return null;\n        if (atno == _Chemistry__WEBPACK_IMPORTED_MODULE_1__.Chemistry.ELEMENT_B && oxstate == 3)\n            return null;\n        if (atno == _Chemistry__WEBPACK_IMPORTED_MODULE_1__.Chemistry.ELEMENT_C && oxstate == 4)\n            return null;\n        if (atno == _Chemistry__WEBPACK_IMPORTED_MODULE_1__.Chemistry.ELEMENT_N && oxstate == 3)\n            return null;\n        if (atno == _Chemistry__WEBPACK_IMPORTED_MODULE_1__.Chemistry.ELEMENT_O && oxstate == 2)\n            return null;\n        if (atno == _Chemistry__WEBPACK_IMPORTED_MODULE_1__.Chemistry.ELEMENT_S && (oxstate == 2 || oxstate == 4 || oxstate == 6))\n            return null;\n        if (atno == _Chemistry__WEBPACK_IMPORTED_MODULE_1__.Chemistry.ELEMENT_P && (oxstate == 3 || oxstate == 5))\n            return null;\n        if ((atno == _Chemistry__WEBPACK_IMPORTED_MODULE_1__.Chemistry.ELEMENT_F || atno == _Chemistry__WEBPACK_IMPORTED_MODULE_1__.Chemistry.ELEMENT_Cl ||\n            atno == _Chemistry__WEBPACK_IMPORTED_MODULE_1__.Chemistry.ELEMENT_Br || atno == _Chemistry__WEBPACK_IMPORTED_MODULE_1__.Chemistry.ELEMENT_I) && oxstate == 1)\n            return null;\n        return oxstate;\n    }\n    static oxidationStateText(oxstate) {\n        if (oxstate == 0)\n            return '0';\n        let str = oxstate < 0 ? '-' : '';\n        let absox = Math.abs(oxstate);\n        if (absox == 1)\n            str += 'I';\n        else if (absox == 2)\n            str += 'II';\n        else if (absox == 3)\n            str += 'III';\n        else if (absox == 4)\n            str += 'IV';\n        else if (absox == 5)\n            str += 'V';\n        else if (absox == 6)\n            str += 'VI';\n        else if (absox == 7)\n            str += 'VII';\n        else if (absox == 8)\n            str += 'VIII';\n        else if (absox == 9)\n            str += 'IX';\n        else if (absox == 10)\n            str += 'X';\n        else if (absox == 11)\n            str += 'XI';\n        else if (absox == 12)\n            str += 'XII';\n        else\n            str = (oxstate > 0 ? '+' : '') + oxstate;\n        return str;\n    }\n}\nMolUtil.TEMPLATE_ATTACHMENT = 'X';\nMolUtil.ABBREV_ATTACHMENT = '*';\n\n\n//# sourceURL=webpack://WebMolKit/./src/data/MolUtil.ts?");

/***/ }),

/***/ "./src/data/Molecule.ts":
/*!******************************!*\
  !*** ./src/data/Molecule.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Molecule\": () => (/* binding */ Molecule)\n/* harmony export */ });\n/* harmony import */ var _util_Geom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Geom */ \"./src/util/Geom.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _Chemistry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Chemistry */ \"./src/data/Chemistry.ts\");\n/* harmony import */ var _MoleculeStream__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MoleculeStream */ \"./src/data/MoleculeStream.ts\");\n\n\n\n\n\nclass Atom {\n}\nclass Bond {\n}\nclass Molecule {\n    constructor() {\n        this.atoms = [];\n        this.bonds = [];\n        this.hasZCoord = false;\n        this.keepTransient = false;\n        this.hasTransient = false;\n        this.graph = null;\n        this.graphBond = null;\n        this.ringID = null;\n        this.compID = null;\n        this.ring3 = null;\n        this.ring4 = null;\n        this.ring5 = null;\n        this.ring6 = null;\n        this.ring7 = null;\n    }\n    clone() {\n        let dup = new Molecule();\n        dup.atoms = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.deepClone)(this.atoms);\n        dup.bonds = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.deepClone)(this.bonds);\n        dup.hasZCoord = this.hasZCoord;\n        dup.keepTransient = this.keepTransient;\n        dup.hasTransient = this.hasTransient;\n        dup.graph = this.graph;\n        dup.graphBond = this.graphBond;\n        dup.ringID = this.ringID;\n        dup.compID = this.compID;\n        dup.ring3 = this.ring3;\n        dup.ring4 = this.ring4;\n        dup.ring5 = this.ring5;\n        dup.ring6 = this.ring6;\n        dup.ring7 = this.ring7;\n        return dup;\n    }\n    static fromString(strData) { return _MoleculeStream__WEBPACK_IMPORTED_MODULE_4__.MoleculeStream.readNative(strData); }\n    toString() { return _MoleculeStream__WEBPACK_IMPORTED_MODULE_4__.MoleculeStream.writeNative(this); }\n    append(frag) {\n        let base = this.atoms.length;\n        for (let n = 1; n <= frag.numAtoms; n++) {\n            let num = this.addAtom(frag.atomElement(n), frag.atomX(n), frag.atomY(n), frag.atomCharge(n), frag.atomUnpaired(n));\n            this.setAtomIsotope(num, frag.atomIsotope(n));\n            this.setAtomHExplicit(num, frag.atomHExplicit(n));\n            this.setAtomMapNum(num, frag.atomMapNum(n));\n            this.setAtomExtra(num, frag.atomExtra(n));\n        }\n        for (let n = 1; n <= frag.numBonds; n++) {\n            let num = this.addBond(frag.bondFrom(n) + base, frag.bondTo(n) + base, frag.bondOrder(n), frag.bondType(n));\n            this.setBondExtra(num, frag.bondExtra(n));\n        }\n        this.trashTransient();\n    }\n    get numAtoms() { return this.atoms.length; }\n    getAtom(idx) {\n        if (idx < 1 || idx > this.atoms.length)\n            throw new Error(`Molecule.getAtom: index ${idx} out of range (#atoms=${this.atoms.length})`);\n        return this.atoms[idx - 1];\n    }\n    atomElement(idx) { return this.getAtom(idx).element; }\n    atomX(idx) { return this.getAtom(idx).x; }\n    atomY(idx) { return this.getAtom(idx).y; }\n    atomCharge(idx) { return this.getAtom(idx).charge; }\n    atomUnpaired(idx) { return this.getAtom(idx).unpaired; }\n    atomIsotope(idx) { return this.getAtom(idx).isotope; }\n    atomHExplicit(idx) { return this.getAtom(idx).hExplicit; }\n    atomMapNum(idx) { return this.getAtom(idx).mapNum; }\n    atomExtra(idx) { return this.getAtom(idx).extra.slice(0); }\n    atomTransient(idx) { return this.getAtom(idx).transient.slice(0); }\n    get numBonds() { return this.bonds.length; }\n    getBond(idx) {\n        if (idx < 1 || idx > this.bonds.length)\n            throw new Error(`Molecule.getBond: index ${idx} out of range (#bonds=${this.bonds.length})`);\n        return this.bonds[idx - 1];\n    }\n    bondFrom(idx) { return this.getBond(idx).from; }\n    bondTo(idx) { return this.getBond(idx).to; }\n    bondOrder(idx) { return this.getBond(idx).order; }\n    bondType(idx) { return this.getBond(idx).type; }\n    bondExtra(idx) { return this.getBond(idx).extra.slice(0); }\n    bondTransient(idx) { return this.getBond(idx).transient.slice(0); }\n    bondFromTo(idx) { let b = this.getBond(idx); return [b.from, b.to]; }\n    addAtom(element, x, y, charge = 0, unpaired = 0) {\n        let a = new Atom();\n        a.element = element;\n        a.x = x;\n        a.y = y;\n        a.charge = charge;\n        a.unpaired = unpaired;\n        a.isotope = Molecule.ISOTOPE_NATURAL;\n        a.hExplicit = Molecule.HEXPLICIT_UNKNOWN;\n        a.mapNum = 0;\n        a.extra = [];\n        a.transient = [];\n        this.atoms.push(a);\n        this.trashTransient();\n        this.trashGraph();\n        return this.atoms.length;\n    }\n    setAtomElement(idx, element) {\n        this.getAtom(idx).element = element;\n        this.trashTransient();\n    }\n    setAtomPos(idx, x, y, z) {\n        let a = this.getAtom(idx);\n        a.x = x;\n        a.y = y;\n        a.z = z == null ? 0 : z;\n        this.trashTransient();\n    }\n    setAtomX(idx, x) {\n        this.getAtom(idx).x = x;\n        this.trashTransient();\n    }\n    setAtomY(idx, y) {\n        this.getAtom(idx).y = y;\n        this.trashTransient();\n    }\n    setAtomCharge(idx, charge) {\n        this.getAtom(idx).charge = charge;\n        this.trashTransient();\n    }\n    setAtomUnpaired(idx, unpaired) {\n        this.getAtom(idx).unpaired = unpaired;\n        this.trashTransient();\n    }\n    setAtomIsotope(idx, isotope) {\n        this.getAtom(idx).isotope = isotope;\n        this.trashTransient();\n    }\n    setAtomHExplicit(idx, hExplicit) {\n        this.getAtom(idx).hExplicit = hExplicit;\n        this.trashTransient();\n    }\n    setAtomMapNum(idx, mapNum) {\n        this.getAtom(idx).mapNum = mapNum;\n        this.trashTransient();\n    }\n    setAtomExtra(idx, extra) {\n        this.getAtom(idx).extra = extra.slice(0);\n    }\n    setAtomTransient(idx, transi) {\n        this.getAtom(idx).transient = transi.slice(0);\n        if (transi.length > 0)\n            this.hasTransient = true;\n    }\n    swapAtoms(a1, a2) {\n        let a = this.atoms[a1 - 1];\n        this.atoms[a1 - 1] = this.atoms[a2 - 1];\n        this.atoms[a2 - 1] = a;\n        for (let n = 0; n < this.bonds.length; n++) {\n            let b = this.bonds[n];\n            if (b.from == a2)\n                b.from = a1;\n            else if (b.from == a1)\n                b.from = a2;\n            if (b.to == a2)\n                b.to = a1;\n            else if (b.to == a1)\n                b.to = a2;\n        }\n        this.trashGraph();\n    }\n    addBond(from, to, order, type = Molecule.BONDTYPE_NORMAL) {\n        let b = new Bond();\n        b.from = from;\n        b.to = to;\n        b.order = order;\n        b.type = type;\n        b.extra = [];\n        b.transient = [];\n        this.bonds.push(b);\n        this.trashTransient();\n        this.trashGraph();\n        return this.bonds.length;\n    }\n    setBondFrom(idx, bfr) {\n        this.getBond(idx).from = bfr;\n        this.trashTransient();\n        this.trashGraph();\n    }\n    setBondTo(idx, to) {\n        this.getBond(idx).to = to;\n        this.trashTransient();\n        this.trashGraph();\n    }\n    setBondFromTo(idx, bfr, bto) {\n        this.getBond(idx).from = bfr;\n        this.getBond(idx).to = bto;\n        this.trashTransient();\n        this.trashGraph();\n    }\n    setBondOrder(idx, order) {\n        this.getBond(idx).order = order;\n        this.trashTransient();\n    }\n    setBondType(idx, type) {\n        this.getBond(idx).type = type;\n        this.trashTransient();\n    }\n    setBondExtra(idx, extra) {\n        this.getBond(idx).extra = extra.slice(0);\n    }\n    setBondTransient(idx, transi) {\n        this.getBond(idx).transient = transi.slice(0);\n        if (transi.length > 0)\n            this.hasTransient = true;\n    }\n    deleteAtomAndBonds(idx) {\n        for (let n = this.numBonds; n >= 1; n--) {\n            if (this.bondFrom(n) == idx || this.bondTo(n) == idx)\n                this.deleteBond(n);\n            else {\n                if (this.bondFrom(n) > idx)\n                    this.setBondFrom(n, this.bondFrom(n) - 1);\n                if (this.bondTo(n) > idx)\n                    this.setBondTo(n, this.bondTo(n) - 1);\n            }\n        }\n        this.atoms.splice(idx - 1, 1);\n        this.trashTransient();\n        this.trashGraph();\n    }\n    deleteBond(idx) {\n        this.bonds.splice(idx - 1, 1);\n        this.trashTransient();\n        this.trashGraph();\n    }\n    atomHydrogens(idx) {\n        let hy = this.atomHExplicit(idx);\n        if (hy != Molecule.HEXPLICIT_UNKNOWN)\n            return hy;\n        for (let n = 0; n < Molecule.HYVALENCE_EL.length; n++)\n            if (Molecule.HYVALENCE_EL[n] == this.atomElement(idx)) {\n                hy = Molecule.HYVALENCE_VAL[n];\n                break;\n            }\n        if (hy == Molecule.HEXPLICIT_UNKNOWN)\n            return 0;\n        let ch = this.atomCharge(idx);\n        if (this.atomElement(idx) == 'C')\n            ch = -Math.abs(ch);\n        hy += ch - this.atomUnpaired(idx);\n        let adjBonds = this.atomAdjBonds(idx);\n        for (let n = 0; n < adjBonds.length; n++)\n            hy -= this.bondOrder(adjBonds[n]);\n        return hy < 0 ? 0 : hy;\n    }\n    findBond(a1, a2) {\n        for (let n = 1; n <= this.numBonds; n++) {\n            let b1 = this.bondFrom(n), b2 = this.bondTo(n);\n            if ((a1 == b1 && a2 == b2) || (a1 == b2 && a2 == b1))\n                return n;\n        }\n        return 0;\n    }\n    bondOther(idx, ref) {\n        let b1 = this.bondFrom(idx), b2 = this.bondTo(idx);\n        if (b1 == ref)\n            return b2;\n        if (b2 == ref)\n            return b1;\n        return 0;\n    }\n    atomExplicit(idx) {\n        let a = this.atoms[idx - 1];\n        if (a.isotope != Molecule.ISOTOPE_NATURAL)\n            return true;\n        if (a.element != 'C' || a.charge != 0 || a.unpaired != 0)\n            return true;\n        if (this.atomAdjCount(idx) == 0)\n            return true;\n        return false;\n    }\n    atomRingBlock(idx) {\n        if (this.graph == null)\n            this.buildGraph();\n        if (this.ringID == null)\n            this.buildRingID();\n        return this.ringID[idx - 1];\n    }\n    bondInRing(idx) {\n        let r1 = this.atomRingBlock(this.bondFrom(idx)), r2 = this.atomRingBlock(this.bondTo(idx));\n        return r1 > 0 && r1 == r2;\n    }\n    atomConnComp(idx) {\n        if (this.graph == null)\n            this.buildGraph();\n        if (this.compID == null)\n            this.buildConnComp();\n        return this.compID[idx - 1];\n    }\n    atomAdjCount(idx) {\n        this.buildGraph();\n        return this.graph[idx - 1].length;\n    }\n    atomAdjList(idx) {\n        this.buildGraph();\n        let adj = this.graph[idx - 1].slice(0);\n        for (let n = adj.length - 1; n >= 0; n--)\n            adj[n]++;\n        return adj;\n    }\n    atomAdjBonds(idx) {\n        this.buildGraph();\n        return this.graphBond[idx - 1].slice(0);\n    }\n    findRingsOfSize(size) {\n        let rings = null;\n        if (size == 3 && this.ring3 != null)\n            rings = this.ring3;\n        if (size == 4 && this.ring4 != null)\n            rings = this.ring4;\n        if (size == 5 && this.ring5 != null)\n            rings = this.ring5;\n        if (size == 6 && this.ring6 != null)\n            rings = this.ring6;\n        if (size == 7 && this.ring7 != null)\n            rings = this.ring7;\n        if (rings == null) {\n            if (this.graph == null)\n                this.buildGraph();\n            if (this.ringID == null)\n                this.buildRingID();\n            rings = [];\n            for (let n = 1; n <= this.atoms.length; n++) {\n                if (this.ringID[n - 1] > 0) {\n                    let path = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.numberArray(0, size);\n                    path[0] = n;\n                    this.recursiveRingFind(path, 1, size, this.ringID[n - 1], rings);\n                }\n            }\n            if (size == 3)\n                this.ring3 = rings;\n            if (size == 4)\n                this.ring4 = rings;\n            if (size == 5)\n                this.ring5 = rings;\n            if (size == 6)\n                this.ring6 = rings;\n            if (size == 7)\n                this.ring7 = rings;\n        }\n        let ret = [];\n        for (let n = 0; n < rings.length; n++)\n            ret.push(rings[n].slice(0));\n        return ret;\n    }\n    boundary() {\n        if (this.atoms.length == 0)\n            return _util_Geom__WEBPACK_IMPORTED_MODULE_0__.Box.zero();\n        let x1 = this.atoms[0].x, x2 = x1;\n        let y1 = this.atoms[0].y, y2 = y1;\n        for (let n = 1; n < this.atoms.length; n++) {\n            x1 = Math.min(x1, this.atoms[n].x);\n            y1 = Math.min(y1, this.atoms[n].y);\n            x2 = Math.max(x2, this.atoms[n].x);\n            y2 = Math.max(y2, this.atoms[n].y);\n        }\n        return new _util_Geom__WEBPACK_IMPORTED_MODULE_0__.Box(x1, y1, x2 - x1, y2 - y1);\n    }\n    atomicNumber(idx) {\n        return Molecule.elementAtomicNumber(this.atomElement(idx));\n    }\n    static elementAtomicNumber(element) {\n        return Math.max(0, _Chemistry__WEBPACK_IMPORTED_MODULE_3__.Chemistry.ELEMENTS.indexOf(element));\n    }\n    is3D() { return this.hasZCoord; }\n    setIs3D(v) { this.hasZCoord = v; }\n    atomZ(idx) { return this.getAtom(idx).z; }\n    setAtomZ(idx, z) { this.getAtom(idx).z = z; }\n    compareTo(other) {\n        if (other == null || other.numAtoms == 0)\n            return this.numAtoms == 0 ? 0 : 1;\n        if (this.numAtoms < other.numAtoms)\n            return -1;\n        if (this.numAtoms > other.numAtoms)\n            return 1;\n        if (this.numBonds < other.numBonds)\n            return -1;\n        if (this.numBonds > other.numBonds)\n            return 1;\n        for (let n = 1; n <= this.numAtoms; n++) {\n            if (this.atomElement(n) < other.atomElement(n))\n                return -1;\n            if (this.atomElement(n) > other.atomElement(n))\n                return 1;\n            if (this.atomX(n) < other.atomX(n))\n                return -1;\n            if (this.atomX(n) > other.atomX(n))\n                return 1;\n            if (this.atomY(n) < other.atomY(n))\n                return -1;\n            if (this.atomY(n) > other.atomY(n))\n                return 1;\n            if (this.atomCharge(n) < other.atomCharge(n))\n                return -1;\n            if (this.atomCharge(n) > other.atomCharge(n))\n                return 1;\n            if (this.atomUnpaired(n) < other.atomUnpaired(n))\n                return -1;\n            if (this.atomUnpaired(n) > other.atomUnpaired(n))\n                return 1;\n            if (this.atomHExplicit(n) < other.atomHExplicit(n))\n                return -1;\n            if (this.atomHExplicit(n) > other.atomHExplicit(n))\n                return 1;\n            if (this.atomIsotope(n) < other.atomIsotope(n))\n                return -1;\n            if (this.atomIsotope(n) > other.atomIsotope(n))\n                return 1;\n            if (this.atomMapNum(n) < other.atomMapNum(n))\n                return -1;\n            if (this.atomMapNum(n) > other.atomMapNum(n))\n                return 1;\n            let tx1 = this.atomExtra(n), tx2 = other.atomExtra(n);\n            if (tx1.length < tx2.length)\n                return -1;\n            if (tx1.length > tx2.length)\n                return 1;\n            for (let i = 0; i < tx1.length; i++)\n                if (tx1[i] < tx2[i])\n                    return -1;\n                else if (tx1[i] > tx2[i])\n                    return 1;\n            tx1 = this.atomTransient(n);\n            tx2 = other.atomTransient(n);\n            if (tx1.length < tx2.length)\n                return -1;\n            if (tx1.length > tx2.length)\n                return 1;\n            for (let i = 0; i < tx1.length; i++)\n                if (tx1[i] < tx2[i])\n                    return -1;\n                else if (tx1[i] > tx2[i])\n                    return 1;\n        }\n        for (let n = 1; n <= this.numBonds; n++) {\n            if (this.bondFrom(n) < other.bondFrom(n))\n                return -1;\n            if (this.bondFrom(n) > other.bondFrom(n))\n                return 1;\n            if (this.bondTo(n) < other.bondTo(n))\n                return -1;\n            if (this.bondTo(n) > other.bondTo(n))\n                return 1;\n            if (this.bondOrder(n) < other.bondOrder(n))\n                return -1;\n            if (this.bondOrder(n) > other.bondOrder(n))\n                return 1;\n            if (this.bondType(n) < other.bondType(n))\n                return -1;\n            if (this.bondType(n) > other.bondType(n))\n                return 1;\n            let tx1 = this.bondExtra(n), tx2 = other.bondExtra(n);\n            if (tx1.length < tx2.length)\n                return -1;\n            if (tx1.length > tx2.length)\n                return 1;\n            for (let i = 0; i < tx1.length; i++)\n                if (tx1[i] < tx2[i])\n                    return -1;\n                else if (tx1[i] > tx2[i])\n                    return 1;\n            tx1 = this.bondTransient(n);\n            tx2 = other.bondTransient(n);\n            if (tx1.length < tx2.length)\n                return -1;\n            if (tx1.length > tx2.length)\n                return 1;\n            for (let i = 0; i < tx1.length; i++)\n                if (tx1[i] < tx2[i])\n                    return -1;\n                else if (tx1[i] > tx2[i])\n                    return 1;\n        }\n        return 0;\n    }\n    trashGraph() {\n        this.graph = null;\n        this.graphBond = null;\n        this.ringID = null;\n        this.compID = null;\n        this.ring3 = null;\n        this.ring4 = null;\n        this.ring5 = null;\n        this.ring6 = null;\n        this.ring7 = null;\n    }\n    trashTransient() {\n        if (this.keepTransient || !this.hasTransient)\n            return;\n        for (let a of this.atoms)\n            a.transient = [];\n        for (let b of this.bonds)\n            b.transient = [];\n        this.hasTransient = false;\n    }\n    buildGraph() {\n        if (this.graph != null && this.graphBond != null)\n            return;\n        let graph = [], graphBond = [];\n        let na = this.numAtoms, nb = this.numBonds;\n        for (let n = 0; n < na; n++) {\n            graph.push([]);\n            graphBond.push([]);\n        }\n        for (let n = 1; n <= nb; n++) {\n            let b = this.getBond(n);\n            graph[b.from - 1].push(b.to - 1);\n            graph[b.to - 1].push(b.from - 1);\n            graphBond[b.from - 1].push(n);\n            graphBond[b.to - 1].push(n);\n        }\n        this.graph = graph;\n        this.graphBond = graphBond;\n    }\n    buildConnComp() {\n        const numAtoms = this.atoms.length;\n        this.compID = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.numberArray(0, numAtoms);\n        for (let n = 0; n < numAtoms; n++)\n            this.compID[n] = 0;\n        let comp = 1;\n        this.compID[0] = comp;\n        while (true) {\n            let anything = false;\n            for (let n = 0; n < numAtoms; n++)\n                if (this.compID[n] == comp) {\n                    for (let i = 0; i < this.graph[n].length; i++) {\n                        if (this.compID[this.graph[n][i]] == 0) {\n                            this.compID[this.graph[n][i]] = comp;\n                            anything = true;\n                        }\n                    }\n                }\n            if (!anything) {\n                for (let n = 0; n < numAtoms; n++) {\n                    if (this.compID[n] == 0) {\n                        this.compID[n] = ++comp;\n                        anything = true;\n                        break;\n                    }\n                }\n                if (!anything)\n                    break;\n            }\n        }\n    }\n    buildRingID() {\n        const numAtoms = this.atoms.length;\n        this.ringID = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.numberArray(0, numAtoms);\n        if (numAtoms == 0)\n            return;\n        let visited = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.booleanArray(false, numAtoms);\n        for (let n = 0; n < numAtoms; n++) {\n            this.ringID[n] = 0;\n            visited[n] = false;\n        }\n        let path = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.numberArray(0, numAtoms + 1), plen = 0, numVisited = 0;\n        while (true) {\n            let last, current;\n            if (plen == 0) {\n                last = -1;\n                for (current = 0; visited[current]; current++) { }\n            }\n            else {\n                last = path[plen - 1];\n                current = -1;\n                for (let n = 0; n < this.graph[last].length; n++) {\n                    if (!visited[this.graph[last][n]]) {\n                        current = this.graph[last][n];\n                        break;\n                    }\n                }\n            }\n            if (current >= 0 && plen >= 2) {\n                let back = path[plen - 1];\n                for (let n = 0; n < this.graph[current].length; n++) {\n                    let join = this.graph[current][n];\n                    if (join != back && visited[join]) {\n                        path[plen] = current;\n                        for (let i = plen; i == plen || path[i + 1] != join; i--) {\n                            let id = this.ringID[path[i]];\n                            if (id == 0)\n                                this.ringID[path[i]] = last;\n                            else if (id != last) {\n                                for (let j = 0; j < numAtoms; j++)\n                                    if (this.ringID[j] == id)\n                                        this.ringID[j] = last;\n                            }\n                        }\n                    }\n                }\n            }\n            if (current >= 0) {\n                visited[current] = true;\n                path[plen++] = current;\n                numVisited++;\n            }\n            else {\n                plen--;\n            }\n            if (numVisited == numAtoms)\n                break;\n        }\n        let nextID = 0;\n        for (let i = 0; i < numAtoms; i++) {\n            if (this.ringID[i] > 0) {\n                nextID--;\n                for (let j = numAtoms - 1; j >= i; j--)\n                    if (this.ringID[j] == this.ringID[i])\n                        this.ringID[j] = nextID;\n            }\n        }\n        for (let i = 0; i < numAtoms; i++)\n            this.ringID[i] = -this.ringID[i];\n    }\n    recursiveRingFind(path, psize, capacity, rblk, rings) {\n        const { graph } = this;\n        if (psize < capacity) {\n            let last = path[psize - 1];\n            for (let n = 0; n < graph[last - 1].length; n++) {\n                let adj = graph[last - 1][n] + 1;\n                if (this.ringID[adj - 1] != rblk)\n                    continue;\n                let fnd = false;\n                for (let i = 0; i < psize; i++) {\n                    if (path[i] == adj) {\n                        fnd = true;\n                        break;\n                    }\n                }\n                if (!fnd) {\n                    let newPath = path.slice(0);\n                    newPath[psize] = adj;\n                    this.recursiveRingFind(newPath, psize + 1, capacity, rblk, rings);\n                }\n            }\n            return;\n        }\n        let last = path[psize - 1];\n        let fnd = false;\n        for (let n = 0; n < graph[last - 1].length; n++) {\n            if (graph[last - 1][n] + 1 == path[0]) {\n                fnd = true;\n                break;\n            }\n        }\n        if (!fnd)\n            return;\n        for (let n = 0; n < path.length; n++) {\n            let count = 0, p = path[n] - 1;\n            for (let i = 0; i < graph[p].length; i++)\n                if (path.indexOf(graph[p][i] + 1) >= 0)\n                    count++;\n            if (count != 2)\n                return;\n        }\n        let first = 0;\n        for (let n = 1; n < psize; n++)\n            if (path[n] < path[first])\n                first = n;\n        let fm = (first - 1 + psize) % psize, fp = (first + 1) % psize;\n        let flip = path[fm] < path[fp];\n        if (first != 0 || flip) {\n            let newPath = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.numberArray(0, psize);\n            for (let n = 0; n < psize; n++)\n                newPath[n] = path[(first + (flip ? psize - n : n)) % psize];\n            path = newPath;\n        }\n        for (let n = 0; n < rings.length; n++) {\n            let look = rings[n];\n            let same = true;\n            for (let i = 0; i < psize; i++) {\n                if (look[i] != path[i]) {\n                    same = false;\n                    break;\n                }\n            }\n            if (same)\n                return;\n        }\n        rings.push(path);\n    }\n}\nMolecule.IDEALBOND = 1.5;\nMolecule.HEXPLICIT_UNKNOWN = -1;\nMolecule.ISOTOPE_NATURAL = 0;\nMolecule.BONDTYPE_NORMAL = 0;\nMolecule.BONDTYPE_INCLINED = 1;\nMolecule.BONDTYPE_DECLINED = 2;\nMolecule.BONDTYPE_UNKNOWN = 3;\nMolecule.HYVALENCE_EL = ['C', 'N', 'O', 'S', 'P'];\nMolecule.HYVALENCE_VAL = [4, 3, 2, 2, 3];\nMolecule.PREFIX_EXTRA = 'x';\nMolecule.PREFIX_TRANSIENT = 'y';\n\n\n//# sourceURL=webpack://WebMolKit/./src/data/Molecule.ts?");

/***/ }),

/***/ "./src/data/MoleculeStream.ts":
/*!************************************!*\
  !*** ./src/data/MoleculeStream.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MoleculeStream\": () => (/* binding */ MoleculeStream)\n/* harmony export */ });\n/* harmony import */ var _MDLReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MDLReader */ \"./src/data/MDLReader.ts\");\n/* harmony import */ var _MDLWriter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MDLWriter */ \"./src/data/MDLWriter.ts\");\n/* harmony import */ var _Molecule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Molecule */ \"./src/data/Molecule.ts\");\n\n\n\nclass MoleculeStream {\n    static readUnknown(strData) {\n        if (strData.startsWith('\"')) {\n            try {\n                let jsonStr = JSON.parse(strData);\n                let mol = MoleculeStream.readNative(jsonStr);\n                if (mol)\n                    return mol;\n            }\n            catch (ex) { }\n        }\n        let mol = MoleculeStream.readNative(strData);\n        if (mol)\n            return mol;\n        try {\n            mol = MoleculeStream.readMDLMOL(strData);\n        }\n        catch (e) { }\n        return mol;\n    }\n    static readNative(strData) {\n        let mol = new _Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule();\n        mol.keepTransient = true;\n        let lines = strData.split(/\\r?\\n/);\n        if (lines.length < 2)\n            return null;\n        if (!lines[0].startsWith('SketchEl!') && lines.length >= 4 && lines[3].indexOf('V2000') >= 0) {\n            let i = strData.indexOf('SketchEl!');\n            if (i < 0)\n                return null;\n            lines = strData.substring(i).split(/r?\\n/);\n        }\n        let bits = lines[0].match(/^SketchEl\\!\\((\\d+)\\,(\\d+)\\)/);\n        if (!bits)\n            return null;\n        let numAtoms = parseInt(bits[1]), numBonds = parseInt(bits[2]);\n        if (lines.length < 2 + numAtoms + numBonds)\n            return null;\n        if (!lines[1 + numAtoms + numBonds].match(/^!End/))\n            return null;\n        for (let n = 0; n < numAtoms; n++) {\n            bits = lines[1 + n].split(/[=,;]/);\n            let num = mol.addAtom(MoleculeStream.skUnescape(bits[0]), parseFloat(bits[1]), parseFloat(bits[2]), parseInt(bits[3]), parseInt(bits[4]));\n            let extra = [], trans = [];\n            for (let i = 5; i < bits.length; i++) {\n                let ch = bits[i].charAt(0);\n                if (bits[i].charAt(0) == 'i') { }\n                else if (bits[i].charAt(0) == 'e')\n                    mol.setAtomHExplicit(num, parseInt(bits[i].substring(1)));\n                else if (bits[i].charAt(0) == 'm')\n                    mol.setAtomIsotope(num, parseInt(bits[i].substring(1)));\n                else if (bits[i].charAt(0) == 'n')\n                    mol.setAtomMapNum(num, parseInt(bits[i].substring(1)));\n                else if (bits[i].charAt(0) == 'x')\n                    extra.push(MoleculeStream.skUnescape(bits[i]));\n                else if (bits[i].charAt(0) == 'y')\n                    trans.push(MoleculeStream.skUnescape(bits[i]));\n                else if (bits[i].charAt(0) == 'z') {\n                    mol.setAtomZ(num, parseFloat(bits[i].substring(1)));\n                    mol.setIs3D(true);\n                }\n                else\n                    extra.push(MoleculeStream.skUnescape(bits[i]));\n            }\n            mol.setAtomExtra(num, extra);\n            mol.setAtomTransient(num, trans);\n        }\n        for (let n = 0; n < numBonds; n++) {\n            bits = lines[1 + numAtoms + n].split(/[=,]/);\n            let frto = bits[0].split('-');\n            let bfr = parseInt(frto[0].trim()), bto = parseInt(frto[1].trim());\n            if (bfr == bto)\n                continue;\n            let num = mol.addBond(bfr, bto, parseInt(bits[1]), parseInt(bits[2]));\n            let extra = new Array(), trans = new Array();\n            for (let i = 3; i < bits.length; i++) {\n                let ch = bits[i].charAt(0);\n                if (bits[i].charAt(0) == 'x')\n                    extra.push(MoleculeStream.skUnescape(bits[i]));\n                else if (bits[i].charAt(0) == 'y')\n                    trans.push(MoleculeStream.skUnescape(bits[i]));\n                else\n                    extra.push(MoleculeStream.skUnescape(bits[i]));\n            }\n            mol.setBondExtra(num, extra);\n            mol.setBondTransient(num, trans);\n        }\n        mol.keepTransient = false;\n        return mol;\n    }\n    static writeNative(mol) {\n        let ret = 'SketchEl!(' + mol.numAtoms + ',' + mol.numBonds + ')\\n';\n        for (let n = 1; n <= mol.numAtoms; n++) {\n            let el = mol.atomElement(n), x = mol.atomX(n), y = mol.atomY(n), charge = mol.atomCharge(n), unpaired = mol.atomUnpaired(n);\n            let hy = mol.atomHExplicit(n) != _Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.HEXPLICIT_UNKNOWN ? ('e' + mol.atomHExplicit(n)) : ('i' + mol.atomHydrogens(n));\n            ret += MoleculeStream.skEscape(el) + '=' + x.toFixed(4) + ',' + y.toFixed(4) + ';' + charge + ',' + unpaired + ',' + hy;\n            if (mol.is3D())\n                ret += ',z' + mol.atomZ(n);\n            if (mol.atomIsotope(n) != _Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.ISOTOPE_NATURAL)\n                ret += ',m' + mol.atomIsotope(n);\n            if (mol.atomMapNum(n) > 0)\n                ret += ',n' + mol.atomMapNum(n);\n            ret += MoleculeStream.skEncodeExtra(mol.atomExtra(n));\n            ret += MoleculeStream.skEncodeExtra(mol.atomTransient(n));\n            ret += '\\n';\n        }\n        for (let n = 1; n <= mol.numBonds; n++) {\n            ret += mol.bondFrom(n) + '-' + mol.bondTo(n) + '=' + mol.bondOrder(n) + ',' + mol.bondType(n);\n            ret += MoleculeStream.skEncodeExtra(mol.bondExtra(n));\n            ret += MoleculeStream.skEncodeExtra(mol.bondTransient(n));\n            ret += '\\n';\n        }\n        ret += '!End\\n';\n        return ret;\n    }\n    static readMDLMOL(strData) {\n        let src = new _MDLReader__WEBPACK_IMPORTED_MODULE_0__.MDLMOLReader(strData);\n        src.parseHeader = true;\n        src.parse();\n        return src.mol;\n    }\n    static writeMDLMOL(mol) {\n        return new _MDLWriter__WEBPACK_IMPORTED_MODULE_1__.MDLMOLWriter(mol).write();\n    }\n    static skUnescape(str) {\n        let ret = '', match;\n        while (match = str.match(/^(.*?)\\\\([0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f])(.*)/)) {\n            ret += match[1] + String.fromCharCode(parseInt('0x' + match[2]));\n            str = match[3];\n        }\n        return ret + str;\n    }\n    static skEscape(str) {\n        let ret = '';\n        for (let n = 0; n < str.length; n++) {\n            let ch = str.charAt(n), code = str.charCodeAt(n);\n            if (code <= 32 || code > 127 || ch == '\\\\' || ch == ',' || ch == ';' || ch == '=') {\n                let hex = (code & 0xFFFF).toString(16).toUpperCase();\n                ret += '\\\\';\n                for (let i = 4 - hex.length; i > 0; i--)\n                    ret += '0';\n                ret += hex;\n            }\n            else\n                ret += ch;\n        }\n        return ret;\n    }\n    static skEncodeExtra(extra) {\n        let ret = '';\n        for (let n = 0; n < extra.length; n++)\n            ret += ',' + MoleculeStream.skEscape(extra[n]);\n        return ret;\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/data/MoleculeStream.ts?");

/***/ }),

/***/ "./src/data/OntologyTree.ts":
/*!**********************************!*\
  !*** ./src/data/OntologyTree.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"OntologyTree\": () => (/* binding */ OntologyTree)\n/* harmony export */ });\n/* harmony import */ var _util_Theme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Theme */ \"./src/util/Theme.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nlet globalInstance = null;\nconst ONTOLOGY_FILES = [\n    'units'\n];\nclass OntologyTree {\n    constructor() {\n        this.roots = [];\n        this.mapTerms = new Map();\n        this.alreadyLoaded = new Set();\n    }\n    static get main() { return globalInstance; }\n    static init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (globalInstance)\n                return;\n            globalInstance = new OntologyTree();\n            for (let fn of ONTOLOGY_FILES) {\n                let url = _util_Theme__WEBPACK_IMPORTED_MODULE_0__.Theme.RESOURCE_URL + '/data/ontology/' + fn + '.onto';\n                globalInstance.loadFromURL(url);\n            }\n        });\n    }\n    getRoots() {\n        return this.roots;\n    }\n    hasTerm(uri) { return this.mapTerms.has(uri); }\n    getBranch(uri) {\n        return this.mapTerms.get(uri);\n    }\n    getBranchList(root) {\n        if (typeof root == 'string') {\n            let look = this.mapTerms.get(root);\n            if (!look)\n                throw `Unknown branch URI: ${root}`;\n            if (look.length > 1)\n                throw `Ambiguous branch URI occurs more than once: ${root}`;\n            root = look[0];\n        }\n        let list = [];\n        let accumulate = (branch) => {\n            list.push(branch);\n            for (let child of _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.safeArray(branch.children))\n                accumulate(child);\n        };\n        accumulate(root);\n        return list;\n    }\n    loadFromURL(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.alreadyLoaded.has(url))\n                return;\n            this.alreadyLoaded.add(url);\n            let text = yield (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.readTextURL)(url);\n            if (!text)\n                throw `Resource not found: ${url}`;\n            this.loadContent(text);\n        });\n    }\n    loadContent(text) {\n        let termList = [];\n        let pos = 0;\n        for (let line of text.split(/\\n/)) {\n            pos++;\n            line = line.trim();\n            if (!line || line.startsWith('#'))\n                continue;\n            let idx = line.indexOf('http');\n            if (idx < 0)\n                throw `Line ${pos} invalid, no URI term: ${line}`;\n            let depth = 0;\n            for (let n = 0; n < idx; n++)\n                if (line.charAt(n) == '-')\n                    depth++;\n            let uri = line.substring(idx);\n            idx = uri.indexOf(' ');\n            if (idx < 0)\n                throw `Line ${pos} invalid, no label: ${line}`;\n            let label = uri.substring(idx + 1);\n            uri = uri.substring(0, idx);\n            let term = null;\n            if (depth == 0)\n                term = this.roots.find((look) => look.uri == uri);\n            if (!term) {\n                term = { uri, label, 'parent': null, 'children': [], depth };\n                if (depth == 0)\n                    this.roots.push(term);\n                else {\n                    for (let n = termList.length - 1; n >= 0; n--)\n                        if (termList[n].depth == depth - 1) {\n                            term.parent = termList[n];\n                            termList[n].children.push(term);\n                            break;\n                        }\n                    if (!term.parent)\n                        throw `Line ${pos} invalid hierarchy, no parent found`;\n                }\n                let list = this.mapTerms.get(uri);\n                if (list)\n                    list.push(term);\n                else\n                    this.mapTerms.set(uri, [term]);\n            }\n            termList.push(term);\n        }\n    }\n    debugString(term) {\n        let lines = [];\n        let emit = (term) => {\n            lines.push('* '.repeat(term.depth) + `<${term.uri}> \"${term.label}\"`);\n            for (let child of term.children)\n                emit(child);\n        };\n        emit(term);\n        return lines.join('\\n');\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/data/OntologyTree.ts?");

/***/ }),

/***/ "./src/data/OpenMolSpec.ts":
/*!*********************************!*\
  !*** ./src/data/OpenMolSpec.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"OpenMolSpec\": () => (/* binding */ OpenMolSpec),\n/* harmony export */   \"OpenMolType\": () => (/* binding */ OpenMolType)\n/* harmony export */ });\nvar OpenMolType;\n(function (OpenMolType) {\n    OpenMolType[OpenMolType[\"None\"] = 0] = \"None\";\n    OpenMolType[OpenMolType[\"AtomCount1000\"] = 1] = \"AtomCount1000\";\n    OpenMolType[OpenMolType[\"BondCount1000\"] = 2] = \"BondCount1000\";\n    OpenMolType[OpenMolType[\"InlineAbbreviations\"] = 3] = \"InlineAbbreviations\";\n    OpenMolType[OpenMolType[\"ZeroOrderBonds\"] = 4] = \"ZeroOrderBonds\";\n    OpenMolType[OpenMolType[\"HydrogenCounting\"] = 5] = \"HydrogenCounting\";\n    OpenMolType[OpenMolType[\"MoleculeName\"] = 6] = \"MoleculeName\";\n    OpenMolType[OpenMolType[\"QueryResonance\"] = 7] = \"QueryResonance\";\n    OpenMolType[OpenMolType[\"QueryHCount\"] = 8] = \"QueryHCount\";\n})(OpenMolType || (OpenMolType = {}));\nconst OPENMOL_LEVEL_1_1 = [\n    OpenMolType.AtomCount1000,\n    OpenMolType.BondCount1000,\n];\nconst OPENMOL_LEVEL_1_2 = [\n    OpenMolType.InlineAbbreviations,\n];\nconst OPENMOL_LEVEL_1_3 = [\n    OpenMolType.ZeroOrderBonds,\n    OpenMolType.HydrogenCounting,\n];\nconst OPENMOL_INVALID = [\n    OpenMolType.QueryResonance,\n    OpenMolType.QueryHCount,\n];\nclass OpenMolSpec {\n    constructor() {\n        this.level = 1.0;\n        this.invalid = false;\n        this.notes = [];\n    }\n    add(type, atoms, bonds, source) {\n        this.addNote({ 'type': type, 'atoms': atoms, 'bonds': bonds, 'source': source });\n    }\n    addNote(note) {\n        this.notes.push(note);\n        note.level = 1.0;\n        if (OPENMOL_LEVEL_1_1.indexOf(note.type) >= 0)\n            note.level = 1.1;\n        else if (OPENMOL_LEVEL_1_2.indexOf(note.type) >= 0)\n            note.level = 1.2;\n        else if (OPENMOL_LEVEL_1_3.indexOf(note.type) >= 0)\n            note.level = 1.3;\n        this.level = Math.max(this.level, note.level);\n        this.invalid = this.invalid || OPENMOL_INVALID.indexOf(note.type) >= 0;\n    }\n    addJoin(type, atoms, bonds, source) {\n        for (let note of this.notes)\n            if (note.type == type) {\n                if (atoms && note.atoms)\n                    note.atoms = note.atoms.concat(atoms);\n                else if (atoms)\n                    note.atoms = atoms;\n                if (bonds && note.bonds)\n                    note.bonds = note.bonds.concat(bonds);\n                else if (bonds)\n                    note.bonds = bonds;\n                if (source && note.source)\n                    note.source = note.source.concat(source);\n                else if (source)\n                    note.source = source;\n                return;\n            }\n        this.add(type, atoms, bonds, source);\n    }\n    derive(mol) {\n        if (mol.numAtoms >= 1000)\n            this.add(OpenMolType.AtomCount1000);\n        if (mol.numBonds >= 1000)\n            this.add(OpenMolType.BondCount1000);\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/data/OpenMolSpec.ts?");

/***/ }),

/***/ "./src/data/PolymerBlock.ts":
/*!**********************************!*\
  !*** ./src/data/PolymerBlock.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"POLYMERBLOCK_EXTRA_POLYMER\": () => (/* binding */ POLYMERBLOCK_EXTRA_POLYMER),\n/* harmony export */   \"POLYMERBLOCK_SPECIAL_UNCAPPED\": () => (/* binding */ POLYMERBLOCK_SPECIAL_UNCAPPED),\n/* harmony export */   \"PolymerBlock\": () => (/* binding */ PolymerBlock),\n/* harmony export */   \"PolymerBlockConnectivity\": () => (/* binding */ PolymerBlockConnectivity),\n/* harmony export */   \"PolymerBlockUnit\": () => (/* binding */ PolymerBlockUnit)\n/* harmony export */ });\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n\nconst POLYMERBLOCK_EXTRA_POLYMER = 'xPOLYMER:';\nconst POLYMERBLOCK_SPECIAL_UNCAPPED = '*';\nvar PolymerBlockConnectivity;\n(function (PolymerBlockConnectivity) {\n    PolymerBlockConnectivity[\"HeadToTail\"] = \"ht\";\n    PolymerBlockConnectivity[\"HeadToHead\"] = \"hh\";\n    PolymerBlockConnectivity[\"Random\"] = \"rnd\";\n})(PolymerBlockConnectivity || (PolymerBlockConnectivity = {}));\nclass PolymerBlockUnit {\n    constructor(atoms) {\n        this.atoms = atoms;\n        this.connect = null;\n        this.bondConn = null;\n        this.atomName = new Map();\n        this.bondIncl = new Map();\n        this.bondExcl = new Map();\n    }\n    clone() {\n        let dup = new PolymerBlockUnit(this.atoms.slice(0));\n        dup.connect = this.connect;\n        if (this.bondConn)\n            dup.bondConn = this.bondConn.slice(0);\n        for (let [k, v] of this.atomName.entries())\n            dup.atomName.set(k, v.slice(0));\n        for (let [k, v] of this.bondIncl.entries())\n            dup.bondIncl.set(k, v.slice(0));\n        for (let [k, v] of this.bondExcl.entries())\n            dup.bondExcl.set(k, v.slice(0));\n        return dup;\n    }\n}\nclass PolymerBlock {\n    constructor(mol) {\n        this.mol = mol;\n        this.units = new Map();\n        let blockAtoms = new Map();\n        for (let n = 1; n <= mol.numAtoms; n++) {\n            let extra = mol.atomExtra(n);\n            for (let str of extra)\n                if (str.startsWith(POLYMERBLOCK_EXTRA_POLYMER)) {\n                    let bits = str.substring(POLYMERBLOCK_EXTRA_POLYMER.length).split(':');\n                    let id = parseInt(bits[0]);\n                    if (id > 0) {\n                        let atoms = blockAtoms.get(id);\n                        if (atoms)\n                            atoms.push(n);\n                        else\n                            atoms = [n];\n                        blockAtoms.set(id, atoms);\n                    }\n                }\n        }\n        for (let key of _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.sorted(Array.from(blockAtoms.keys())))\n            this.appendBlock(key, blockAtoms.get(key));\n    }\n    getIDList() { return _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.sorted(Array.from(this.units.keys())); }\n    getUnit(id) { return this.units.get(id); }\n    getUnits() { return Array.from(this.units.values()); }\n    rewriteMolecule() {\n        this.purgeExtraFields();\n        for (let key of _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.sorted(Array.from(this.units.keys())))\n            this.writeUnit(key, this.units.get(key));\n    }\n    harmoniseNumbering(other) {\n        let allKeys = other.getIDList();\n        for (let key of this.getIDList())\n            if (allKeys.includes(key)) {\n                let unit = this.units.get(key);\n                this.units.delete(key);\n                key = this.nextIdentifier(allKeys);\n                this.units.set(key, unit);\n                allKeys.push(key);\n            }\n    }\n    removeUnit(id) {\n        let unit = this.units.get(id);\n        if (unit == null)\n            return;\n        this.units.delete(id);\n        let pfx = POLYMERBLOCK_EXTRA_POLYMER + id + ':';\n        for (let a of unit.atoms) {\n            let extra = this.mol.atomExtra(a);\n            for (let i = extra.length - 1; i >= 0; i--)\n                if (extra[i].startsWith(pfx))\n                    extra = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.remove(extra, i);\n            this.mol.setAtomExtra(a, extra);\n        }\n        for (let b = 1; b <= this.mol.numBonds; b++) {\n            let extra = this.mol.bondExtra(b);\n            if (_util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.isBlank(extra))\n                continue;\n            for (let i = extra.length - 1; i >= 0; i--)\n                if (extra[i].startsWith(pfx))\n                    extra = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.remove(extra, i);\n            this.mol.setBondExtra(b, extra);\n        }\n    }\n    removeAll() {\n        this.units.clear();\n        this.purgeExtraFields();\n    }\n    createUnit(unit) {\n        let id = this.nextIdentifier();\n        this.units.set(id, unit.clone());\n        this.writeUnit(id, unit);\n        return id;\n    }\n    static hasPolymerExtensions(mol) {\n        for (let n = 1; n <= mol.numAtoms; n++) {\n            let extra = mol.atomExtra(n);\n            if (extra != null)\n                for (let str of extra)\n                    if (str.startsWith(POLYMERBLOCK_EXTRA_POLYMER))\n                        return true;\n        }\n        return false;\n    }\n    static getPolymerExtensions(mol, atom) {\n        let extra = mol.atomExtra(atom), polext = null;\n        if (extra == null)\n            return null;\n        for (let str of extra)\n            if (str.startsWith(POLYMERBLOCK_EXTRA_POLYMER))\n                polext = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.append(polext, str);\n        return polext;\n    }\n    static removePolymerExtensions(mol, atom) {\n        let extra = mol.atomExtra(atom);\n        if (extra == null)\n            return;\n        let modified = false;\n        for (let i = extra.length - 1; i >= 0; i--)\n            if (extra[i].startsWith(POLYMERBLOCK_EXTRA_POLYMER)) {\n                extra = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.remove(extra, i);\n                modified = true;\n            }\n        if (modified)\n            mol.setAtomExtra(atom, extra);\n    }\n    appendBlock(id, atoms) {\n        const { mol } = this;\n        let nattach = 0;\n        let unit = new PolymerBlockUnit(atoms);\n        for (let atom of atoms)\n            for (let extra of mol.atomExtra(atom))\n                if (extra.startsWith(POLYMERBLOCK_EXTRA_POLYMER)) {\n                    let bits = extra.substring(POLYMERBLOCK_EXTRA_POLYMER.length).split(':');\n                    if (bits.length < 2 || parseInt(bits[0]) != id)\n                        continue;\n                    nattach = parseInt(bits[1]);\n                    for (let n = 2; n < bits.length; n++) {\n                        if (bits[n] == PolymerBlockConnectivity.HeadToTail)\n                            unit.connect = PolymerBlockConnectivity.HeadToTail;\n                        else if (bits[n] == PolymerBlockConnectivity.HeadToHead)\n                            unit.connect = PolymerBlockConnectivity.HeadToHead;\n                        else if (bits[n] == PolymerBlockConnectivity.Random)\n                            unit.connect = PolymerBlockConnectivity.Random;\n                        else if (bits[n].startsWith('n')) {\n                            let hasOuter = false;\n                            for (let adj of mol.atomAdjList(atom))\n                                if (!atoms.includes(adj)) {\n                                    hasOuter = true;\n                                    break;\n                                }\n                            if (hasOuter) {\n                                let subBits = bits[n].substring(1).split(',');\n                                unit.atomName.set(atom, subBits.map((str) => parseInt(str)));\n                            }\n                        }\n                    }\n                }\n        if (nattach < 0)\n            return;\n        for (let n = 1; n <= mol.numBonds; n++) {\n            let in1 = atoms.indexOf(mol.bondFrom(n)) >= 0, in2 = atoms.indexOf(mol.bondTo(n)) >= 0;\n            if ((in1 && !in2) || (!in1 && in2))\n                nattach--;\n        }\n        if (nattach != 0)\n            return;\n        let bonds = null, order = null;\n        for (let n = 1; n <= mol.numBonds; n++) {\n            for (let extra of mol.bondExtra(n))\n                if (extra.startsWith(POLYMERBLOCK_EXTRA_POLYMER)) {\n                    let bits = extra.substring(POLYMERBLOCK_EXTRA_POLYMER.length).split(':');\n                    if (bits.length < 2 || parseInt(bits[0]) != id)\n                        continue;\n                    for (let i = 1; i < bits.length; i++) {\n                        if (bits[i].startsWith('i')) {\n                            let subBits = bits[i].substring(1).split(',');\n                            unit.bondIncl.set(n, subBits.map((str) => parseInt(str)));\n                        }\n                        else if (bits[i].startsWith('e')) {\n                            let subBits = bits[i].substring(1).split(',');\n                            unit.bondExcl.set(n, subBits.map((str) => parseInt(str)));\n                        }\n                        else {\n                            let o = parseInt(bits[i]);\n                            if (o > 0) {\n                                bonds = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.append(bonds, n);\n                                order = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.append(order, o);\n                            }\n                        }\n                    }\n                }\n        }\n        if (bonds != null) {\n            if (bonds.length % 2 == 1)\n                return;\n            unit.bondConn = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.idxGet(bonds, _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.idxSort(order));\n        }\n        this.units.set(id, unit);\n    }\n    formatBlockAtom(id, unit, atom) {\n        let nbonds = 0;\n        for (let n = 1; n <= this.mol.numBonds; n++) {\n            let in1 = unit.atoms.indexOf(this.mol.bondFrom(n)) >= 0, in2 = unit.atoms.indexOf(this.mol.bondTo(n)) >= 0;\n            if ((in1 && !in2) || (!in1 && in2))\n                nbonds++;\n        }\n        let str = POLYMERBLOCK_EXTRA_POLYMER + id + ':' + nbonds;\n        if (unit.connect != null)\n            str += ':' + unit.connect;\n        let names = unit.atomName.get(atom);\n        if (_util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.notBlank(names))\n            str += ':n' + names.join(',');\n        return str;\n    }\n    formatBlockBond(id, unit, bond) {\n        let in1 = unit.atoms.includes(this.mol.bondFrom(bond)), in2 = unit.atoms.includes(this.mol.bondTo(bond));\n        let isBoundary = (in1 && !in2) || (in2 && !in1);\n        if (!isBoundary)\n            return null;\n        let idxConn = unit.bondConn ? unit.bondConn.indexOf(bond) : -1;\n        let incl = unit.bondIncl.get(bond), excl = unit.bondExcl.get(bond);\n        if (idxConn < 0 && _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.isBlank(incl) && _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.isBlank(excl))\n            return null;\n        let str = POLYMERBLOCK_EXTRA_POLYMER + id;\n        if (idxConn >= 0)\n            str += ':' + (idxConn + 1);\n        if (_util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.notBlank(incl))\n            str += ':i' + incl.join(',');\n        if (_util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.notBlank(excl))\n            str += ':e' + excl.join(',');\n        return str;\n    }\n    purgeExtraFields() {\n        for (let n = 1; n <= this.mol.numAtoms; n++) {\n            let extra = this.mol.atomExtra(n);\n            let modified = false;\n            for (let i = extra.length - 1; i >= 0; i--)\n                if (extra[i].startsWith(POLYMERBLOCK_EXTRA_POLYMER)) {\n                    extra = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.remove(extra, i);\n                    modified = true;\n                }\n            if (modified)\n                this.mol.setAtomExtra(n, extra);\n        }\n        for (let n = 1; n <= this.mol.numBonds; n++) {\n            let extra = this.mol.bondExtra(n);\n            let modified = false;\n            for (let i = extra.length - 1; i >= 0; i--)\n                if (extra[i].startsWith(POLYMERBLOCK_EXTRA_POLYMER)) {\n                    extra = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.remove(extra, i);\n                    modified = true;\n                }\n            if (modified)\n                this.mol.setBondExtra(n, extra);\n        }\n    }\n    writeUnit(id, unit) {\n        const { mol } = this;\n        for (let a of unit.atoms) {\n            let codeAtom = this.formatBlockAtom(id, unit, a);\n            mol.setAtomExtra(a, _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.append(mol.atomExtra(a), codeAtom));\n        }\n        for (let b = 1; b <= mol.numBonds; b++) {\n            let codeBond = this.formatBlockBond(id, unit, b);\n            if (codeBond)\n                mol.setBondExtra(b, _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.append(mol.bondExtra(b), codeBond));\n        }\n    }\n    nextIdentifier(keys) {\n        if (!keys)\n            keys = this.getIDList();\n        if (keys.length == 0)\n            return 1;\n        for (let n = 0; n < keys.length - 1; n++)\n            if (keys[n + 1] != keys[n] + 1)\n                return keys[n] + 1;\n        return keys[keys.length - 1] + 1;\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/data/PolymerBlock.ts?");

/***/ }),

/***/ "./src/data/QuantityCalc.ts":
/*!**********************************!*\
  !*** ./src/data/QuantityCalc.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GreenMetrics\": () => (/* binding */ GreenMetrics),\n/* harmony export */   \"QuantityCalc\": () => (/* binding */ QuantityCalc),\n/* harmony export */   \"QuantityCalcComp\": () => (/* binding */ QuantityCalcComp),\n/* harmony export */   \"QuantityCalcRole\": () => (/* binding */ QuantityCalcRole),\n/* harmony export */   \"QuantityCalcStat\": () => (/* binding */ QuantityCalcStat)\n/* harmony export */ });\n/* harmony import */ var _aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../aspect/Experiment */ \"./src/aspect/Experiment.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _MolUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MolUtil */ \"./src/data/MolUtil.ts\");\n\n\n\n\nvar QuantityCalcRole;\n(function (QuantityCalcRole) {\n    QuantityCalcRole[QuantityCalcRole[\"Primary\"] = 1] = \"Primary\";\n    QuantityCalcRole[QuantityCalcRole[\"Secondary\"] = 2] = \"Secondary\";\n    QuantityCalcRole[QuantityCalcRole[\"Product\"] = 3] = \"Product\";\n    QuantityCalcRole[QuantityCalcRole[\"Independent\"] = 4] = \"Independent\";\n})(QuantityCalcRole || (QuantityCalcRole = {}));\nvar QuantityCalcStat;\n(function (QuantityCalcStat) {\n    QuantityCalcStat[QuantityCalcStat[\"Unknown\"] = 0] = \"Unknown\";\n    QuantityCalcStat[QuantityCalcStat[\"Actual\"] = 1] = \"Actual\";\n    QuantityCalcStat[QuantityCalcStat[\"Virtual\"] = 2] = \"Virtual\";\n    QuantityCalcStat[QuantityCalcStat[\"Conflict\"] = 3] = \"Conflict\";\n})(QuantityCalcStat || (QuantityCalcStat = {}));\nclass QuantityCalcComp {\n    constructor(comp, step, type, idx) {\n        this.comp = comp;\n        this.step = step;\n        this.type = type;\n        this.idx = idx;\n        this.role = 0;\n        this.molw = 0;\n        this.valueEquiv = 0;\n        this.statEquiv = 0;\n        this.valueMass = QuantityCalc.UNSPECIFIED;\n        this.statMass = 0;\n        this.valueVolume = QuantityCalc.UNSPECIFIED;\n        this.statVolume = 0;\n        this.valueMoles = QuantityCalc.UNSPECIFIED;\n        this.statMoles = 0;\n        this.valueDensity = QuantityCalc.UNSPECIFIED;\n        this.statDensity = 0;\n        this.valueConc = QuantityCalc.UNSPECIFIED;\n        this.statConc = 0;\n        this.valueYield = QuantityCalc.UNSPECIFIED;\n        this.statYield = 0;\n    }\n}\nclass GreenMetrics {\n    constructor() {\n        this.step = 0;\n        this.idx = 0;\n        this.massReact = [];\n        this.massProd = [];\n        this.massWaste = [];\n        this.massProdWaste = [];\n        this.molwReact = [];\n        this.molwProd = [];\n        this.impliedWaste = 0;\n        this.isBlank = false;\n    }\n}\nclass QuantityCalc {\n    constructor(entry) {\n        this.entry = entry;\n        this.quantities = [];\n        this.primaryMoles = [];\n        this.idxPrimary = [];\n        this.idxYield = [];\n        this.allMassReact = [];\n        this.allMassProd = [];\n        this.allMassWaste = [];\n        this.greenMetrics = [];\n    }\n    static isStoichZero(stoich) {\n        if (this.isStoichUnity(stoich))\n            return false;\n        if (parseFloat(stoich) == 0)\n            return true;\n        return false;\n    }\n    static isStoichUnity(stoich) {\n        if (!stoich || stoich == '1')\n            return true;\n        let [numer, denom] = this.extractStoichFraction(stoich);\n        return numer != 0 && numer == denom;\n    }\n    static extractStoichFraction(stoich) {\n        if (!stoich)\n            return [1, 1];\n        let numer = 1, denom = 1;\n        let i = stoich.indexOf('/');\n        if (i < 0) {\n            let v = parseFloat(stoich);\n            if (v >= 0)\n                numer = v;\n        }\n        else {\n            let v1 = parseFloat(stoich.substring(0, i)), v2 = parseFloat(stoich.substring(i + 1));\n            if (v1 >= 0)\n                numer = v1;\n            if (v2 >= 0)\n                denom = v2;\n        }\n        return [numer, denom];\n    }\n    static extractStoichValue(stoich) {\n        let [numer, denom] = this.extractStoichFraction(stoich);\n        return denom <= 1 ? numer : numer / denom;\n    }\n    static stoichAsRatio(stoich) {\n        let [numer, denom] = this.extractStoichFraction(stoich);\n        if (numer == Math.floor(numer))\n            return [numer, denom];\n        return this.stoichFractAsRatio(numer);\n    }\n    static stoichFractAsRatio(fract) {\n        if (fract == Math.floor(fract))\n            return [fract, 1];\n        const MAX_DENOM = QuantityCalc.MAX_DENOM;\n        if (QuantityCalc.RATIO_FRACT == null) {\n            QuantityCalc.RATIO_FRACT = [];\n            for (let p = 0, j = 2; j <= MAX_DENOM; j++)\n                for (let i = 1; i < j && i < MAX_DENOM - 1; i++)\n                    QuantityCalc.RATIO_FRACT.push(i * 1.0 / j);\n        }\n        let whole = Math.floor(fract);\n        let resid = fract - whole;\n        let bestDiff = Number.MAX_VALUE;\n        let bestOver = 1, bestUnder = 1;\n        for (let p = 0, j = 2; j <= MAX_DENOM; j++)\n            for (let i = 1; i < j && i < MAX_DENOM - 1; i++) {\n                let diff = Math.abs(QuantityCalc.RATIO_FRACT[p++] - resid);\n                if (diff < bestDiff) {\n                    bestDiff = diff;\n                    bestOver = i;\n                    bestUnder = j;\n                }\n            }\n        return [bestOver + (whole * bestUnder), bestUnder];\n    }\n    static impliedReagentStoich(reagent, products) {\n        if (_MolUtil__WEBPACK_IMPORTED_MODULE_3__.MolUtil.isBlank(reagent.mol) || products.length == 0)\n            return 0;\n        let pstoich = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.numberArray(-1, products.length);\n        let rmol = reagent.mol;\n        let highest = 0;\n        for (let n = 1; n <= rmol.numAtoms; n++) {\n            let m = rmol.atomMapNum(n);\n            if (m == 0)\n                continue;\n            let total = 0;\n            for (let i = 0; i < products.length; i++) {\n                let pmol = products[i].mol;\n                if (_MolUtil__WEBPACK_IMPORTED_MODULE_3__.MolUtil.isBlank(pmol))\n                    continue;\n                let pcount = 0;\n                for (let j = 1; j <= pmol.numAtoms; j++)\n                    if (pmol.atomMapNum(j) == m)\n                        pcount++;\n                if (pcount > 0) {\n                    let rcount = 0;\n                    for (let k = 1; k <= rmol.numAtoms; k++)\n                        if (rmol.atomMapNum(k) == m)\n                            rcount++;\n                    if (pstoich[i] < 0)\n                        pstoich[i] = QuantityCalc.extractStoichValue(products[i].stoich);\n                    total += pcount * pstoich[i] / rcount;\n                }\n            }\n            highest = Math.max(highest, total);\n        }\n        return highest;\n    }\n    static componentRatio(entry, step) {\n        let numer = [], denom = [];\n        let reactants = step == 0 ? entry.steps[0].reactants : entry.steps[step - 1].products;\n        for (let comp of reactants) {\n            let [num, den] = this.stoichAsRatio(comp.stoich);\n            numer.push(num);\n            denom.push(den);\n        }\n        for (let comp of entry.steps[step].reagents) {\n            let fract = this.impliedReagentStoich(comp, entry.steps[step].products);\n            let [num, den] = fract == 0 ? [0, 1] : this.stoichFractAsRatio(fract);\n            numer.push(num == 0 ? 1 : num);\n            denom.push(den);\n        }\n        for (let comp of entry.steps[step].products) {\n            let [num, den] = this.stoichAsRatio(comp.stoich);\n            numer.push(num == 0 ? 1 : num);\n            denom.push(den);\n        }\n        let bigDenom = 1;\n        for (let n = 0; n < numer.length; n++)\n            if (denom[n] > 1 && bigDenom % denom[n] != 0)\n                bigDenom *= denom[n];\n        let ratioReactants = [], ratioReagents = [], ratioProducts = [];\n        let p = 0;\n        for (let n = 0; n < reactants.length; n++, p++)\n            ratioReactants.push(numer[p] * bigDenom / denom[p]);\n        for (let n = 0; n < entry.steps[step].reagents.length; n++, p++)\n            ratioReagents.push(numer[p] * bigDenom / denom[p]);\n        for (let n = 0; n < entry.steps[step].products.length; n++, p++)\n            ratioProducts.push(numer[p] * bigDenom / denom[p]);\n        return [ratioReactants, ratioReagents, ratioProducts];\n    }\n    calculate() {\n        this.classifyTypes();\n        while (this.calculateSomething()) { }\n        this.allMassReact = [];\n        this.allMassProd = [];\n        this.allMassWaste = [];\n        for (let n = 0; n < this.quantities.length; n++) {\n            let qc = this.quantities[n];\n            if (qc.type == _aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__.ExperimentComponentType.Reactant || qc.type == _aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__.ExperimentComponentType.Reagent) {\n                if (qc.valueEquiv == 0 && qc.type == _aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__.ExperimentComponentType.Reagent)\n                    continue;\n                this.allMassReact.push(qc.valueMass);\n            }\n            else if (qc.type == _aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__.ExperimentComponentType.Product) {\n                if (!qc.comp.waste) {\n                    this.allMassProd.push(qc.valueMass);\n                    this.calculateGreenMetrics(n);\n                }\n                else {\n                    this.allMassWaste.push(qc.valueMass);\n                }\n            }\n        }\n    }\n    get numQuantities() { return this.quantities.length; }\n    getQuantity(idx) { return this.quantities[idx]; }\n    getAllQuantities() { return this.quantities.slice(0); }\n    get numGreenMetrics() { return this.greenMetrics.length; }\n    getGreenMetrics(idx) { return this.greenMetrics[idx]; }\n    getAllGreenMetrics() { return this.greenMetrics.slice(0); }\n    getAllMassReact() { return this.allMassReact.slice(0); }\n    getAllMassProd() { return this.allMassProd.slice(0); }\n    getAllMassWaste() { return this.allMassWaste.slice(0); }\n    findComponent(step, type, idx) {\n        for (let qc of this.quantities)\n            if (qc.step == step && qc.type == type && qc.idx == idx)\n                return qc;\n        return null;\n    }\n    static formatMolWeight(value) {\n        if (value == QuantityCalc.UNSPECIFIED)\n            return '';\n        return (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.formatDouble)(value, 6) + ' g/mol';\n    }\n    static formatMass(value) {\n        if (value == QuantityCalc.UNSPECIFIED)\n            return '';\n        if (value <= 1E-6)\n            return (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.formatDouble)(value * 1E6, 6) + ' \\u03BCg';\n        if (value <= 1E-3)\n            return (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.formatDouble)(value * 1E3, 6) + ' mg';\n        if (value >= 1E3)\n            return (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.formatDouble)(value * 1E-3, 6) + ' kg';\n        return (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.formatDouble)(value, 6) + ' g';\n    }\n    static formatVolume(value) {\n        if (value == QuantityCalc.UNSPECIFIED)\n            return '';\n        if (value <= 1E-6)\n            return (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.formatDouble)(value * 1E6, 6) + ' nL';\n        if (value <= 1E-3)\n            return (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.formatDouble)(value * 1E3, 6) + ' \\u03BCL';\n        if (value >= 1E3)\n            return (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.formatDouble)(value * 1E-3, 6) + ' L';\n        return (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.formatDouble)(value, 6) + ' mL';\n    }\n    static formatMoles(value) {\n        if (value == QuantityCalc.UNSPECIFIED)\n            return '';\n        if (value <= 1E-9)\n            return (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.formatDouble)(value * 1E9, 6) + ' nmol';\n        if (value <= 1E-6)\n            return (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.formatDouble)(value * 1E6, 6) + ' \\u03BCmol';\n        if (value <= 1E-3)\n            return (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.formatDouble)(value * 1E3, 6) + ' mmol';\n        return (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.formatDouble)(value, 6) + ' mol';\n    }\n    static formatDensity(value) {\n        if (value == QuantityCalc.UNSPECIFIED)\n            return '';\n        return (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.formatDouble)(value, 6) + ' g/mL';\n    }\n    static formatConc(value) {\n        if (value == QuantityCalc.UNSPECIFIED)\n            return '';\n        if (value <= 1E-9)\n            return (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.formatDouble)(value * 1E9, 6) + ' nmol/L';\n        if (value <= 1E-6)\n            return (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.formatDouble)(value * 1E6, 6) + ' \\u03BCmol/L';\n        if (value <= 1E-3)\n            return (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.formatDouble)(value * 1E3, 6) + ' mmol/L';\n        return (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.formatDouble)(value, 6) + ' mol/L';\n    }\n    static formatPercent(value) {\n        if (value == QuantityCalc.UNSPECIFIED)\n            return '';\n        return (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.formatDouble)(value, 6) + '%';\n    }\n    static formatEquiv(value) {\n        if (value == QuantityCalc.UNSPECIFIED)\n            return '';\n        return (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.formatDouble)(value, 4) + ' equiv';\n    }\n    classifyTypes() {\n        for (let s = 0; s < this.entry.steps.length; s++) {\n            let step = this.entry.steps[s];\n            for (let n = 0; n < step.reactants.length; n++)\n                this.quantities.push(new QuantityCalcComp(step.reactants[n], s, _aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__.ExperimentComponentType.Reactant, n));\n            for (let n = 0; n < step.reagents.length; n++)\n                this.quantities.push(new QuantityCalcComp(step.reagents[n], s, _aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__.ExperimentComponentType.Reagent, n));\n            for (let n = 0; n < step.products.length; n++)\n                this.quantities.push(new QuantityCalcComp(step.products[n], s, _aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__.ExperimentComponentType.Product, n));\n        }\n        for (let n = 0; n < this.quantities.length; n++) {\n            let qc = this.quantities[n];\n            if (qc.type == _aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__.ExperimentComponentType.Reagent) {\n                if (qc.comp.equiv != null)\n                    qc.valueEquiv = qc.comp.equiv;\n                else {\n                    let eq = QuantityCalc.impliedReagentStoich(qc.comp, this.entry.steps[qc.step].products);\n                    if (eq > 0)\n                        qc.valueEquiv = eq;\n                }\n            }\n            else {\n                qc.valueEquiv = QuantityCalc.extractStoichValue(qc.comp.stoich);\n            }\n            if (qc.comp.mol != null)\n                qc.molw = _MolUtil__WEBPACK_IMPORTED_MODULE_3__.MolUtil.molecularWeight(qc.comp.mol);\n            qc.role = 4;\n            if (qc.step == 0 && qc.type == _aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__.ExperimentComponentType.Reactant) {\n                if (qc.comp.primary) {\n                    qc.role = 1;\n                    this.idxPrimary.push(n);\n                }\n                else\n                    qc.role = 2;\n            }\n            else if (qc.type == _aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__.ExperimentComponentType.Reagent) {\n                if (qc.valueEquiv > 0)\n                    qc.role = 2;\n            }\n            else if (qc.type == _aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__.ExperimentComponentType.Product && !qc.comp.waste) {\n                qc.role = 3;\n                this.idxYield.push(n);\n            }\n            else if (qc.valueEquiv > 0) {\n                qc.role = 2;\n            }\n            if (qc.comp.mass != null)\n                qc.valueMass = qc.comp.mass;\n            if (qc.comp.volume != null)\n                qc.valueVolume = qc.comp.volume;\n            if (qc.comp.moles != null)\n                qc.valueMoles = qc.comp.moles;\n            if (qc.comp.density != null)\n                qc.valueDensity = qc.comp.density;\n            if (qc.comp.conc != null)\n                qc.valueConc = qc.comp.conc;\n            if (qc.comp.yield != null)\n                qc.valueYield = qc.comp.yield;\n            qc.statEquiv = qc.valueEquiv == QuantityCalc.UNSPECIFIED ? 0 : 1;\n            qc.statMass = qc.valueMass == QuantityCalc.UNSPECIFIED ? 0 : 1;\n            qc.statVolume = qc.valueVolume == QuantityCalc.UNSPECIFIED ? 0 : 1;\n            qc.statMoles = qc.valueMoles == QuantityCalc.UNSPECIFIED ? 0 : 1;\n            qc.statDensity = qc.valueDensity == QuantityCalc.UNSPECIFIED ? 0 : 1;\n            qc.statConc = qc.valueConc == QuantityCalc.UNSPECIFIED ? 0 : 1;\n            qc.statYield = qc.valueYield == QuantityCalc.UNSPECIFIED ? 0 : 1;\n        }\n        if (this.idxPrimary.length == 0) {\n            for (let n = 0; n < this.quantities.length; n++) {\n                let qc = this.quantities[n];\n                if (qc.type == _aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__.ExperimentComponentType.Reactant && qc.step == 0) {\n                    qc.role = 1;\n                    this.idxPrimary.push(n);\n                }\n            }\n        }\n    }\n    calculateSomething() {\n        let anything = false;\n        for (let qc of this.quantities) {\n            if (qc.molw > 0 && qc.valueMass == QuantityCalc.UNSPECIFIED && qc.statMoles == 1) {\n                qc.valueMass = qc.valueMoles * qc.molw;\n                qc.statMass = 2;\n                anything = true;\n            }\n            if (qc.molw > 0 && qc.valueMass != QuantityCalc.UNSPECIFIED && qc.valueMoles == QuantityCalc.UNSPECIFIED) {\n                qc.valueMoles = qc.valueMass / qc.molw;\n                qc.statMoles = 2;\n                anything = true;\n            }\n            if (qc.molw > 0 && qc.statMass == 1 && qc.statMoles == 1) {\n                let calcMoles = qc.valueMass / qc.molw;\n                if (!this.closeEnough(qc.valueMoles, calcMoles)) {\n                    qc.statMass = 3;\n                    qc.statMoles = 3;\n                }\n            }\n            let isSoln = qc.statConc == 1 ||\n                (qc.statVolume == 1 && (qc.statMass == 1 || qc.statMoles == 1));\n            if (!isSoln) {\n                if (qc.valueDensity > 0 && qc.valueMass == QuantityCalc.UNSPECIFIED && qc.valueVolume != QuantityCalc.UNSPECIFIED) {\n                    qc.valueMass = qc.valueVolume * qc.valueDensity;\n                    qc.statMass = 2;\n                    anything = true;\n                }\n                if (qc.valueDensity > 0 && qc.valueMass != QuantityCalc.UNSPECIFIED && qc.valueVolume == QuantityCalc.UNSPECIFIED) {\n                    qc.valueVolume = qc.valueMass / qc.valueDensity;\n                    qc.statVolume = 2;\n                    anything = true;\n                }\n                if (qc.valueDensity == QuantityCalc.UNSPECIFIED && qc.valueMass != QuantityCalc.UNSPECIFIED &&\n                    qc.valueVolume != QuantityCalc.UNSPECIFIED && qc.valueConc == QuantityCalc.UNSPECIFIED) {\n                    if (qc.statMass == 1 || qc.statMoles == 1) {\n                        qc.valueDensity = qc.valueMass / qc.valueVolume;\n                        qc.statDensity = 2;\n                        anything = true;\n                    }\n                }\n            }\n            if (isSoln) {\n                if (qc.valueConc > 0 && qc.valueMoles == QuantityCalc.UNSPECIFIED && qc.valueVolume != QuantityCalc.UNSPECIFIED) {\n                    qc.valueMoles = 0.001 * qc.valueVolume * qc.valueConc;\n                    qc.statMoles = 2;\n                    anything = true;\n                }\n                if (qc.valueConc > 0 && qc.valueMoles != QuantityCalc.UNSPECIFIED && qc.valueVolume == QuantityCalc.UNSPECIFIED) {\n                    qc.valueVolume = 1000 * qc.valueMoles / qc.valueConc;\n                    qc.statVolume = 2;\n                    anything = true;\n                }\n                if (qc.valueConc == QuantityCalc.UNSPECIFIED && qc.valueMass != QuantityCalc.UNSPECIFIED && qc.valueVolume != QuantityCalc.UNSPECIFIED) {\n                    qc.valueConc = 1000 * qc.valueMoles / qc.valueVolume;\n                    qc.statConc = 2;\n                    anything = true;\n                }\n                if (qc.statConc == 1 && qc.valueMoles > 0 && qc.statVolume == 1) {\n                    let calcVolume = 1000 * qc.valueMoles / qc.valueConc;\n                    if (!this.closeEnough(qc.valueVolume, calcVolume)) {\n                        qc.statConc = 3;\n                        if (qc.statMass == 1)\n                            qc.statMass = 3;\n                        if (qc.statMoles == 1)\n                            qc.statMoles = 3;\n                        qc.statVolume = 3;\n                    }\n                }\n            }\n            if (qc.molw > 0 && qc.valueMass == QuantityCalc.UNSPECIFIED && qc.valueMoles != QuantityCalc.UNSPECIFIED) {\n                qc.valueMass = qc.valueMoles * qc.molw;\n                qc.statMass = 2;\n                anything = true;\n            }\n            if (qc.statDensity == 1 && qc.statConc == 1) {\n                qc.statDensity = 3;\n                qc.statConc = 3;\n            }\n        }\n        if (anything)\n            return true;\n        let hasRef = false;\n        let numSteps = this.entry.steps.length;\n        let primaryCounts = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.numberArray(0, numSteps);\n        let primaryEquivs = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.numberArray(0, numSteps);\n        let primaryMoles = this.primaryMoles = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.numberArray(0, numSteps);\n        for (let qc of this.quantities) {\n            let ref = -1;\n            if (qc.step == 0 && qc.type == _aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__.ExperimentComponentType.Reactant && qc.comp.primary)\n                ref = qc.step;\n            else if (qc.step < numSteps - 1 && qc.type == _aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__.ExperimentComponentType.Product && !qc.comp.waste)\n                ref = qc.step + 1;\n            else\n                continue;\n            if (primaryEquivs[ref] < 0)\n                continue;\n            if (qc.statMoles == 1) {\n                primaryEquivs[ref] = -1;\n                continue;\n            }\n            primaryCounts[ref]++;\n            primaryEquivs[ref] += qc.valueEquiv;\n            primaryMoles[ref] += qc.valueMoles;\n        }\n        if (primaryEquivs[0] <= 0) {\n            primaryCounts[0] = 0;\n            primaryEquivs[0] = 0;\n            primaryMoles[0] = 0;\n            for (let i of this.idxPrimary) {\n                let qc = this.quantities[i];\n                if (qc.statMoles == 0) {\n                    primaryCounts[0] = 0;\n                    primaryEquivs[0] = -1;\n                    primaryMoles[0] = 0;\n                    break;\n                }\n                primaryCounts[0]++;\n                primaryEquivs[0] += qc.valueEquiv;\n                primaryMoles[0] += qc.valueMoles;\n            }\n        }\n        let refMoles = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.numberArray(0, numSteps);\n        for (let n = 0; n < numSteps; n++) {\n            refMoles[n] = primaryCounts[n] == 0 || primaryEquivs[n] <= 0 ? 0 : primaryMoles[n] / primaryEquivs[n];\n            if (refMoles[n] > 0)\n                hasRef = true;\n        }\n        if (!hasRef) {\n            for (let n = 0; n < numSteps; n++) {\n                let prodMolar = [];\n                for (let qc of this.quantities) {\n                    if (qc.step != n || qc.role != 3)\n                        continue;\n                    if (qc.statMoles == 0 || qc.valueMoles <= 0 || qc.valueEquiv <= 0)\n                        continue;\n                    let yld = qc.valueYield > 0 ? qc.valueYield * 0.01 : 1;\n                    prodMolar.push(qc.valueMoles / (qc.valueEquiv * yld));\n                }\n                if (prodMolar.length > 0) {\n                    refMoles[n] = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.sum(prodMolar) / prodMolar.length;\n                    hasRef = true;\n                }\n            }\n        }\n        if (!hasRef)\n            return false;\n        for (let qc of this.quantities) {\n            if (qc.type != _aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__.ExperimentComponentType.Product)\n                continue;\n            if (refMoles[qc.step] == 0)\n                continue;\n            if (qc.valueYield == QuantityCalc.UNSPECIFIED && qc.valueMoles != QuantityCalc.UNSPECIFIED) {\n                qc.valueYield = 100 * qc.valueMoles / (refMoles[qc.step] * qc.valueEquiv);\n                qc.statYield = 2;\n                anything = true;\n            }\n            if (qc.valueYield != QuantityCalc.UNSPECIFIED && qc.valueMoles == QuantityCalc.UNSPECIFIED) {\n                qc.valueMoles = qc.valueYield * 0.01 * (refMoles[qc.step] * qc.valueEquiv);\n                qc.statMoles = 2;\n                anything = true;\n            }\n            if (qc.valueMoles > 0 && qc.statYield == 1) {\n                let calcYield = 100 * qc.valueMoles / (refMoles[qc.step] * qc.valueEquiv);\n                if (!this.closeEnough(qc.valueYield, calcYield)) {\n                    if (qc.statMass == 1)\n                        qc.statMass = 3;\n                    if (qc.statMoles == 1)\n                        qc.statMoles = 3;\n                    qc.statYield = 3;\n                }\n            }\n        }\n        if (anything)\n            return true;\n        for (let qc of this.quantities) {\n            if (refMoles[qc.step] == 0)\n                continue;\n            if (qc.valueMass == QuantityCalc.UNSPECIFIED && qc.valueMoles == QuantityCalc.UNSPECIFIED && qc.valueEquiv > 0) {\n                qc.valueMoles = refMoles[qc.step] * qc.valueEquiv;\n                qc.statMoles = 2;\n                anything = true;\n            }\n            if (qc.valueMoles != QuantityCalc.UNSPECIFIED && qc.valueEquiv == QuantityCalc.UNSPECIFIED) {\n                qc.valueEquiv = qc.valueMoles / refMoles[qc.step];\n                qc.statEquiv = 2;\n                anything = true;\n            }\n        }\n        return anything;\n    }\n    calculateGreenMetrics(idx) {\n        let qc = this.quantities[idx];\n        let gm = new GreenMetrics();\n        gm.step = qc.step;\n        gm.idx = qc.idx;\n        gm.isBlank = true;\n        for (let n = 0; n < this.quantities.length; n++) {\n            let sub = this.quantities[n];\n            if (sub.step > gm.step)\n                continue;\n            let eq = sub.valueEquiv;\n            if (eq == 0 && sub.type == _aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__.ExperimentComponentType.Reagent)\n                continue;\n            if (sub.valueMass != QuantityCalc.UNSPECIFIED)\n                gm.isBlank = false;\n            if (sub.type == _aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__.ExperimentComponentType.Reactant || sub.type == _aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__.ExperimentComponentType.Reagent) {\n                gm.massReact.push(sub.valueMass);\n                if (sub.step == gm.step && eq > 0 && sub.molw > 0)\n                    gm.molwReact.push(eq * sub.molw);\n            }\n            else if (sub.type == _aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__.ExperimentComponentType.Product) {\n                if (!sub.comp.waste) {\n                    if (sub.step == gm.step)\n                        gm.massProd.push(sub.valueMass);\n                    if (eq > 0 && sub.molw > 0) {\n                        if (sub.step == gm.step)\n                            gm.molwProd.push(eq * sub.molw);\n                        else if (sub.step == gm.step - 1)\n                            gm.molwReact.push(eq * sub.molw);\n                    }\n                }\n                else {\n                    gm.massWaste.push(sub.valueMass);\n                }\n                if (sub.step == gm.step)\n                    gm.massProdWaste.push(sub.valueMass);\n            }\n        }\n        gm.impliedWaste = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.sum(gm.massReact) - _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.sum(gm.massProdWaste);\n        if (Math.abs(gm.impliedWaste) > 1E-3)\n            gm.impliedWaste = 0;\n        this.greenMetrics.push(gm);\n    }\n    closeEnough(value1, value2) {\n        if (value1 <= 0 || value2 <= 0)\n            return true;\n        let ratio = value1 / value2;\n        return ratio >= 0.99 && ratio <= 1.01;\n    }\n}\nQuantityCalc.UNSPECIFIED = -1;\nQuantityCalc.MAX_DENOM = 16;\nQuantityCalc.RATIO_FRACT = null;\n\n\n//# sourceURL=webpack://WebMolKit/./src/data/QuantityCalc.ts?");

/***/ }),

/***/ "./src/data/QueryUtil.ts":
/*!*******************************!*\
  !*** ./src/data/QueryUtil.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"QueryTypeAtom\": () => (/* binding */ QueryTypeAtom),\n/* harmony export */   \"QueryTypeBond\": () => (/* binding */ QueryTypeBond),\n/* harmony export */   \"QueryUtil\": () => (/* binding */ QueryUtil)\n/* harmony export */ });\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _Molecule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Molecule */ \"./src/data/Molecule.ts\");\n/* harmony import */ var _MolUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MolUtil */ \"./src/data/MolUtil.ts\");\n\n\n\nvar QueryTypeAtom;\n(function (QueryTypeAtom) {\n    QueryTypeAtom[\"Charges\"] = \"qC:\";\n    QueryTypeAtom[\"Aromatic\"] = \"qA:\";\n    QueryTypeAtom[\"Elements\"] = \"qE:\";\n    QueryTypeAtom[\"ElementsNot\"] = \"qE!\";\n    QueryTypeAtom[\"RingSizes\"] = \"qR:\";\n    QueryTypeAtom[\"RingSizesNot\"] = \"qR!\";\n    QueryTypeAtom[\"RingBlock\"] = \"qB:\";\n    QueryTypeAtom[\"NumRings\"] = \"qN:\";\n    QueryTypeAtom[\"Adjacency\"] = \"qJ:\";\n    QueryTypeAtom[\"BondSums\"] = \"qO:\";\n    QueryTypeAtom[\"Valences\"] = \"qV:\";\n    QueryTypeAtom[\"Hydrogens\"] = \"qH:\";\n    QueryTypeAtom[\"Isotopes\"] = \"qI:\";\n    QueryTypeAtom[\"SubFrags\"] = \"qX:\";\n    QueryTypeAtom[\"SubFragsNot\"] = \"qX!\";\n})(QueryTypeAtom || (QueryTypeAtom = {}));\nvar QueryTypeBond;\n(function (QueryTypeBond) {\n    QueryTypeBond[\"RingSizes\"] = \"qR:\";\n    QueryTypeBond[\"RingSizesNot\"] = \"qR!\";\n    QueryTypeBond[\"RingBlock\"] = \"qB:\";\n    QueryTypeBond[\"NumRings\"] = \"qN:\";\n    QueryTypeBond[\"Orders\"] = \"qO:\";\n})(QueryTypeBond || (QueryTypeBond = {}));\nclass QueryUtil {\n    static hasAnyQueryAtom(mol, atom) {\n        let extra = mol.atomExtra(atom);\n        for (let n = extra.length - 1; n >= 0; n--)\n            if (extra[n].startsWith('q'))\n                return true;\n        return false;\n    }\n    static hasAnyQueryBond(mol, bond) {\n        let extra = mol.bondExtra(bond);\n        for (let n = extra.length - 1; n >= 0; n--)\n            if (extra[n].startsWith('q'))\n                return true;\n        return false;\n    }\n    static hasQueryAtom(mol, atom, type) {\n        let extra = mol.atomExtra(atom);\n        for (let n = extra.length - 1; n >= 0; n--)\n            if (extra[n].startsWith(type))\n                return true;\n        return false;\n    }\n    static hasQueryBond(mol, bond, type) {\n        let extra = mol.bondExtra(bond);\n        for (let n = extra.length - 1; n >= 0; n--)\n            if (extra[n].startsWith(type))\n                return true;\n        return false;\n    }\n    static deleteQueryAtom(mol, atom, type) {\n        let extra = mol.atomExtra(atom);\n        let modified = false;\n        for (let n = extra.length - 1; n >= 0; n--)\n            if (extra[n].startsWith(type)) {\n                extra.splice(n, 1);\n                modified = true;\n            }\n        if (modified)\n            mol.setAtomExtra(atom, extra);\n    }\n    static deleteQueryBond(mol, bond, type) {\n        let extra = mol.bondExtra(bond);\n        let modified = false;\n        for (let n = extra.length - 1; n >= 0; n--)\n            if (extra[n].startsWith(type)) {\n                extra.splice(n, 1);\n                modified = true;\n            }\n        if (modified)\n            mol.setBondExtra(bond, extra);\n    }\n    static deleteQueryAtomAll(mol, atom) {\n        mol.setAtomExtra(atom, mol.atomExtra(atom).filter((xtra) => !xtra.startsWith('q')));\n    }\n    static deleteQueryBondAll(mol, bond) {\n        mol.setBondExtra(bond, mol.bondExtra(bond).filter((xtra) => !xtra.startsWith('q')));\n    }\n    static queryAtomString(mol, atom, type) {\n        let extra = mol.atomExtra(atom);\n        for (let n = extra.length - 1; n >= 0; n--)\n            if (extra[n].startsWith(type))\n                return extra[n].substring(type.length);\n        return null;\n    }\n    static queryAtomStringList(mol, atom, type) {\n        let extra = mol.atomExtra(atom), list = null;\n        if (extra != null)\n            for (let str of extra)\n                if (str.startsWith(type))\n                    list = _util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.append(list, str.substring(type.length));\n        return list;\n    }\n    static queryBondString(mol, bond, type) {\n        let extra = mol.bondExtra(bond);\n        for (let n = extra.length - 1; n >= 0; n--)\n            if (extra[n].startsWith(type))\n                return extra[n].substring(type.length);\n        return null;\n    }\n    static setQueryAtom(mol, atom, type, str) {\n        if (!str) {\n            this.deleteQueryAtom(mol, atom, type);\n            return;\n        }\n        let value = type + str;\n        let extra = mol.atomExtra(atom);\n        for (let n = extra.length - 1; n >= 0; n--) {\n            if (extra[n].startsWith(type)) {\n                if (value != null) {\n                    extra[n] = value;\n                    value = null;\n                }\n                else\n                    extra.splice(n, 1);\n            }\n        }\n        if (value != null)\n            extra.push(value);\n        mol.setAtomExtra(atom, extra);\n    }\n    static setQueryAtomList(mol, atom, type, list) {\n        if (_util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.isBlank(list)) {\n            this.deleteQueryAtom(mol, atom, type);\n            return;\n        }\n        let extra = mol.atomExtra(atom);\n        for (let n = extra.length - 1; n >= 0; n--)\n            if (extra[n].startsWith(type))\n                extra.splice(n, 1);\n        for (let str of list)\n            extra.push(type + str);\n        mol.setAtomExtra(atom, extra);\n    }\n    static setQueryBond(mol, bond, type, str) {\n        if (!str) {\n            this.deleteQueryBond(mol, bond, type);\n            return;\n        }\n        let value = type + str;\n        let extra = mol.bondExtra(bond);\n        for (let n = extra.length - 1; n >= 0; n--) {\n            if (extra[n].startsWith(type)) {\n                if (value != null) {\n                    extra[n] = value;\n                    value = null;\n                }\n                else\n                    extra.splice(n, 1);\n            }\n        }\n        if (value != null)\n            extra.push(value);\n        mol.setBondExtra(bond, extra);\n    }\n    static queryAtomCharges(mol, atom) { return this.parseIntegers(this.queryAtomString(mol, atom, QueryTypeAtom.Charges)); }\n    static queryAtomAromatic(mol, atom) { return this.parseBoolean(this.queryAtomString(mol, atom, QueryTypeAtom.Aromatic)); }\n    static queryAtomElements(mol, atom) { return this.parseStrings(this.queryAtomString(mol, atom, QueryTypeAtom.Elements)); }\n    static queryAtomElementsNot(mol, atom) { return this.parseStrings(this.queryAtomString(mol, atom, QueryTypeAtom.ElementsNot)); }\n    static queryAtomRingSizes(mol, atom) { return this.parseIntegers(this.queryAtomString(mol, atom, QueryTypeAtom.RingSizes)); }\n    static queryAtomRingSizesNot(mol, atom) { return this.parseIntegers(this.queryAtomString(mol, atom, QueryTypeAtom.RingSizesNot)); }\n    static queryAtomRingBlock(mol, atom) { return this.parseBoolean(this.queryAtomString(mol, atom, QueryTypeAtom.RingBlock)); }\n    static queryAtomNumRings(mol, atom) { return this.parseIntegers(this.queryAtomString(mol, atom, QueryTypeAtom.NumRings)); }\n    static queryAtomAdjacency(mol, atom) { return this.parseIntegers(this.queryAtomString(mol, atom, QueryTypeAtom.Adjacency)); }\n    static queryAtomBondSums(mol, atom) { return this.parseIntegers(this.queryAtomString(mol, atom, QueryTypeAtom.BondSums)); }\n    static queryAtomValences(mol, atom) { return this.parseIntegers(this.queryAtomString(mol, atom, QueryTypeAtom.Valences)); }\n    static queryAtomHydrogens(mol, atom) { return this.parseIntegers(this.queryAtomString(mol, atom, QueryTypeAtom.Hydrogens)); }\n    static queryAtomIsotope(mol, atom) { return this.parseIntegers(this.queryAtomString(mol, atom, QueryTypeAtom.Isotopes)); }\n    static queryAtomSubFrags(mol, atom) { return this.parseMolecules(this.queryAtomStringList(mol, atom, QueryTypeAtom.SubFrags)); }\n    static queryAtomSubFragsNot(mol, atom) { return this.parseMolecules(this.queryAtomStringList(mol, atom, QueryTypeAtom.SubFragsNot)); }\n    static queryBondRingSizes(mol, bond) { return this.parseIntegers(this.queryBondString(mol, bond, QueryTypeBond.RingSizes)); }\n    static queryBondRingSizesNot(mol, bond) { return this.parseIntegers(this.queryBondString(mol, bond, QueryTypeBond.RingSizesNot)); }\n    static queryBondRingBlock(mol, bond) { return this.parseBoolean(this.queryBondString(mol, bond, QueryTypeBond.RingBlock)); }\n    static queryBondNumRings(mol, bond) { return this.parseIntegers(this.queryBondString(mol, bond, QueryTypeBond.NumRings)); }\n    static queryBondOrders(mol, bond) { return this.parseIntegers(this.queryBondString(mol, bond, QueryTypeBond.Orders)); }\n    static setQueryAtomCharges(mol, atom, value) { this.setQueryAtom(mol, atom, QueryTypeAtom.Charges, this.formatIntegers(value)); }\n    static setQueryAtomAromatic(mol, atom, value) { this.setQueryAtom(mol, atom, QueryTypeAtom.Aromatic, this.formatBoolean(value)); }\n    static setQueryAtomElements(mol, atom, value) { this.setQueryAtom(mol, atom, QueryTypeAtom.Elements, this.formatStrings(value)); }\n    static setQueryAtomElementsNot(mol, atom, value) { this.setQueryAtom(mol, atom, QueryTypeAtom.ElementsNot, this.formatStrings(value)); }\n    static setQueryAtomRingSizes(mol, atom, value) { this.setQueryAtom(mol, atom, QueryTypeAtom.RingSizes, this.formatIntegers(value)); }\n    static setQueryAtomRingSizesNot(mol, atom, value) { this.setQueryAtom(mol, atom, QueryTypeAtom.RingSizesNot, this.formatIntegers(value)); }\n    static setQueryAtomRingBlock(mol, atom, value) { this.setQueryAtom(mol, atom, QueryTypeAtom.RingBlock, this.formatBoolean(value)); }\n    static setQueryAtomNumRings(mol, atom, value) { this.setQueryAtom(mol, atom, QueryTypeAtom.NumRings, this.formatIntegers(value)); }\n    static setQueryAtomAdjacency(mol, atom, value) { this.setQueryAtom(mol, atom, QueryTypeAtom.Adjacency, this.formatIntegers(value)); }\n    static setQueryAtomBondSums(mol, atom, value) { this.setQueryAtom(mol, atom, QueryTypeAtom.BondSums, this.formatIntegers(value)); }\n    static setQueryAtomValences(mol, atom, value) { this.setQueryAtom(mol, atom, QueryTypeAtom.Valences, this.formatIntegers(value)); }\n    static setQueryAtomHydrogens(mol, atom, value) { this.setQueryAtom(mol, atom, QueryTypeAtom.Hydrogens, this.formatIntegers(value)); }\n    static setQueryAtomIsotope(mol, atom, value) { this.setQueryAtom(mol, atom, QueryTypeAtom.Isotopes, this.formatIntegers(value)); }\n    static setQueryAtomSubFrags(mol, atom, value) { this.setQueryAtomList(mol, atom, QueryTypeAtom.SubFrags, this.formatMolecules(value)); }\n    static setQueryAtomSubFragsNot(mol, atom, value) { this.setQueryAtomList(mol, atom, QueryTypeAtom.SubFragsNot, this.formatMolecules(value)); }\n    static setQueryBondRingSizes(mol, bond, value) { this.setQueryBond(mol, bond, QueryTypeBond.RingSizes, this.formatIntegers(value)); }\n    static setQueryBondRingSizesNot(mol, bond, value) { this.setQueryBond(mol, bond, QueryTypeBond.RingSizesNot, this.formatIntegers(value)); }\n    static setQueryBondRingBlock(mol, bond, value) { this.setQueryBond(mol, bond, QueryTypeBond.RingBlock, this.formatBoolean(value)); }\n    static setQueryBondNumRings(mol, bond, value) { this.setQueryBond(mol, bond, QueryTypeBond.NumRings, this.formatIntegers(value)); }\n    static setQueryBondOrders(mol, bond, value) { this.setQueryBond(mol, bond, QueryTypeBond.Orders, this.formatIntegers(value)); }\n    static parseIntegers(str) {\n        if (!str)\n            return null;\n        let strlist = str.split(',');\n        let intlist = new Array(strlist.length);\n        for (let n = 0; n < strlist.length; n++)\n            intlist[n] = parseInt(strlist[n]);\n        return intlist;\n    }\n    static parseStrings(str) {\n        if (!str)\n            return null;\n        return str.split(',');\n    }\n    static parseBoolean(str) {\n        return !str ? null : str == 'yes';\n    }\n    static parseMolecules(list) {\n        if (!list)\n            return null;\n        let mols = [];\n        for (let molstr of list) {\n            let mol = _Molecule__WEBPACK_IMPORTED_MODULE_1__.Molecule.fromString(molstr);\n            if (_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.notBlank(mol))\n                mols.push(mol);\n        }\n        return mols;\n    }\n    static formatIntegers(list) {\n        if (_util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.isBlank(list))\n            return null;\n        let str = '';\n        for (let n = 0; n < list.length; n++) {\n            if (n > 0)\n                str += ',';\n            str += list[n];\n        }\n        return str;\n    }\n    static formatStrings(list) {\n        if (_util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.isBlank(list))\n            return null;\n        let str = '';\n        for (let n = 0; n < list.length; n++) {\n            if (n > 0)\n                str += ',';\n            str += list[n];\n        }\n        return str;\n    }\n    static formatBoolean(value) {\n        return value ? 'yes' : 'no';\n    }\n    static formatMolecules(mols) {\n        if (_util_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.isBlank(mols))\n            return null;\n        let list = [];\n        for (let mol of mols)\n            if (_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.notBlank(mol))\n                list.push(mol.toString());\n        return list;\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/data/QueryUtil.ts?");

/***/ }),

/***/ "./src/data/SketchUtil.ts":
/*!********************************!*\
  !*** ./src/data/SketchUtil.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Geometry\": () => (/* binding */ Geometry),\n/* harmony export */   \"SketchUtil\": () => (/* binding */ SketchUtil)\n/* harmony export */ });\n/* harmony import */ var _util_Geom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Geom */ \"./src/util/Geom.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _Chemistry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Chemistry */ \"./src/data/Chemistry.ts\");\n/* harmony import */ var _CoordUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CoordUtil */ \"./src/data/CoordUtil.ts\");\n/* harmony import */ var _Molecule__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Molecule */ \"./src/data/Molecule.ts\");\n/* harmony import */ var _MolUtil__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./MolUtil */ \"./src/data/MolUtil.ts\");\n\n\n\n\n\n\n\nvar Geometry;\n(function (Geometry) {\n    Geometry[Geometry[\"Linear\"] = 0] = \"Linear\";\n    Geometry[Geometry[\"Bent\"] = 1] = \"Bent\";\n    Geometry[Geometry[\"Trigonal\"] = 2] = \"Trigonal\";\n    Geometry[Geometry[\"Tetra1\"] = 3] = \"Tetra1\";\n    Geometry[Geometry[\"Tetra2\"] = 4] = \"Tetra2\";\n    Geometry[Geometry[\"SqPlan\"] = 5] = \"SqPlan\";\n    Geometry[Geometry[\"BasePyram\"] = 6] = \"BasePyram\";\n    Geometry[Geometry[\"TrigBip\"] = 7] = \"TrigBip\";\n    Geometry[Geometry[\"Octa1\"] = 8] = \"Octa1\";\n    Geometry[Geometry[\"Octa2\"] = 9] = \"Octa2\";\n})(Geometry || (Geometry = {}));\nclass SketchUtil {\n    static placeNewAtom(mol, el) {\n        let box = mol.boundary();\n        let x = box.maxX() + _Molecule__WEBPACK_IMPORTED_MODULE_5__.Molecule.IDEALBOND, y = box.maxY();\n        return mol.addAtom(el, x, y);\n    }\n    static placeNewFragment(mol, frag) {\n        if (frag.numAtoms == 0)\n            return;\n        let dirX = [1, 0, -1, 1, -1, 1, 0, -1], dirY = [1, 1, 1, 0, 0, -1, -1, -1];\n        let dx = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.numberArray(0, 8), dy = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.numberArray(0, 8), score = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.numberArray(0, 8);\n        let mbox = mol.boundary(), fbox = frag.boundary();\n        for (let n = 0; n < 8; n++) {\n            let vx = dirX[n], vy = dirY[n];\n            if (n == 0 || n == 3 || n == 5)\n                dx[n] = mbox.minX() - fbox.maxX();\n            else if (n == 2 || n == 4 || n == 7)\n                dx[n] = mbox.maxX() - fbox.minX();\n            else\n                dx[n] = 0.5 * (mbox.minX() + mbox.maxX() - fbox.minX() - fbox.maxX());\n            if (n == 5 || n == 6 || n == 7)\n                dy[n] = mbox.minY() - fbox.maxY();\n            else if (n == 0 || n == 1 || n == 2)\n                dy[n] = mbox.maxY() - fbox.minY();\n            else\n                dy[n] = 0.5 * (mbox.minY() + mbox.maxY() - fbox.minY() - fbox.maxY());\n            dx[n] -= vx;\n            dy[n] -= vy;\n            score[n] = SketchUtil.fragPosScore(mol, frag, dx[n], dy[n]);\n            vx *= 0.25;\n            vy *= 0.25;\n            for (let iter = 100; iter > 0; iter--) {\n                let iscore = SketchUtil.fragPosScore(mol, frag, dx[n] + vx, dy[n] + vy);\n                if (iscore <= score[n])\n                    break;\n                score[n] = iscore;\n                dx[n] += vx;\n                dy[n] += vy;\n            }\n            for (let iter = 100; iter > 0; iter--)\n                for (let d = 0; d < 8; d++) {\n                    vx = dirX[d] * 0.1;\n                    vy = dirY[d] * 0.1;\n                    let iscore = SketchUtil.fragPosScore(mol, frag, dx[n] + vx, dy[n] + vy);\n                    if (iscore <= score[n])\n                        break;\n                    score[n] = iscore;\n                    dx[n] += vx;\n                    dy[n] += vy;\n                }\n        }\n        let best = 0;\n        for (let n = 1; n < 8; n++)\n            if (score[n] > score[best])\n                best = n;\n        frag = frag.clone();\n        for (let n = 1; n <= frag.numAtoms; n++)\n            frag.setAtomPos(n, frag.atomX(n) + dx[best], frag.atomY(n) + dy[best]);\n        mol.append(frag);\n    }\n    static fragPosScore(mol, frag, dx, dy) {\n        let score = 0;\n        for (let i = 1; i <= mol.numAtoms; i++)\n            for (let j = 1; j <= frag.numAtoms; j++) {\n                let ox = frag.atomX(j) + dx - mol.atomX(i), oy = frag.atomY(j) + dy - mol.atomY(i);\n                let dist2 = ox * ox + oy * oy;\n                if (dist2 < 1)\n                    return 0;\n                score += 1 / dist2;\n            }\n        let mbox = mol.boundary(), fbox = frag.boundary();\n        let minX = Math.min(fbox.minX() + dx, mbox.minX()), maxX = Math.max(fbox.maxX() + dx, mbox.maxX());\n        let minY = Math.min(fbox.minY() + dy, mbox.minY()), maxY = Math.max(fbox.maxY() + dy, mbox.maxY());\n        let rangeX = Math.max(1, maxX - minX), rangeY = Math.max(1, maxY - minY);\n        let ratio = Math.max(rangeX / rangeY, rangeY / rangeX);\n        return score / ratio;\n    }\n    static mergeOverlappingAtoms(mol) {\n        return SketchUtil.mergeFragmentsDiv(mol, 0);\n    }\n    static mergeFragmentsDiv(mol, div) {\n        const na = mol.numAtoms;\n        let omask = _CoordUtil__WEBPACK_IMPORTED_MODULE_4__.CoordUtil.overlappingAtomMask(mol);\n        let chopmask = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.booleanArray(false, na);\n        let mx = _MolUtil__WEBPACK_IMPORTED_MODULE_6__.MolUtil.arrayAtomX(mol), my = _MolUtil__WEBPACK_IMPORTED_MODULE_6__.MolUtil.arrayAtomY(mol);\n        let remap = [];\n        for (let n = 0; n < na; n++)\n            remap.push(n + 1);\n        let div1 = div, div2 = div + 1;\n        if (div == 0)\n            div1 = na;\n        for (let i = 1; i <= div1; i++)\n            if (omask[i - 1] && !chopmask[i - 1]) {\n                if (div == 0)\n                    div2 = i + 1;\n                for (let j = div2; j <= na; j++)\n                    if (omask[j - 1] && !chopmask[j - 1]) {\n                        if ((0,_util_util__WEBPACK_IMPORTED_MODULE_1__.norm2_xy)(mx[i - 1] - mx[j - 1], my[i - 1] - my[j - 1]) > _CoordUtil__WEBPACK_IMPORTED_MODULE_4__.CoordUtil.OVERLAP_THRESHOLD_SQ)\n                            continue;\n                        let oldN = j, newN = i;\n                        let exotic = [0, 0];\n                        for (let k = 0; k < 2; k++) {\n                            let a = k == 0 ? i : j;\n                            exotic[k] = (mol.atomElement(a) == 'C' ? 0 : 1)\n                                + (mol.atomElement(a) == 'X' ? -100 : 0)\n                                + (mol.atomCharge(a) != 0 ? 1 : 0)\n                                + (mol.atomUnpaired(a) != 0 ? 1 : 0)\n                                + (mol.atomIsotope(a) != _Molecule__WEBPACK_IMPORTED_MODULE_5__.Molecule.ISOTOPE_NATURAL ? 1 : 0)\n                                + (mol.atomHExplicit(a) != _Molecule__WEBPACK_IMPORTED_MODULE_5__.Molecule.HEXPLICIT_UNKNOWN ? 1 : 0)\n                                + (_MolUtil__WEBPACK_IMPORTED_MODULE_6__.MolUtil.hasAbbrev(mol, a) ? 1000 : 0);\n                        }\n                        if (exotic[1] > exotic[0]) {\n                            oldN = i;\n                            newN = j;\n                        }\n                        for (let n = 1; n <= mol.numBonds; n++) {\n                            if (mol.bondFrom(n) == oldN)\n                                mol.setBondFrom(n, newN);\n                            if (mol.bondTo(n) == oldN)\n                                mol.setBondTo(n, newN);\n                        }\n                        chopmask[oldN - 1] = true;\n                        remap[oldN - 1] = newN;\n                    }\n            }\n        for (let n = na; n >= 1; n--)\n            if (chopmask[n - 1]) {\n                if (n <= div)\n                    div--;\n                mol.deleteAtomAndBonds(n);\n                for (let i = 0; i < na; i++)\n                    if (remap[i] > n)\n                        remap[i]--;\n            }\n        for (let n = mol.numAtoms; n > div; n--)\n            if (mol.atomElement(n) == 'X') {\n                mol.deleteAtomAndBonds(n);\n                for (let i = 0; i < na; i++)\n                    if (remap[i] > n)\n                        remap[i]--;\n            }\n        _MolUtil__WEBPACK_IMPORTED_MODULE_6__.MolUtil.removeDuplicateBonds(mol);\n        return remap;\n    }\n    static mergeFragmentsMask(mol, mask) {\n        let chopmask = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.booleanArray(false, mol.numAtoms);\n        let na = mol.numAtoms;\n        let mx = _MolUtil__WEBPACK_IMPORTED_MODULE_6__.MolUtil.arrayAtomX(mol), my = _MolUtil__WEBPACK_IMPORTED_MODULE_6__.MolUtil.arrayAtomY(mol);\n        for (let i = 1; i <= na; i++)\n            if (mask[i - 1])\n                for (let j = 1; j <= na; j++)\n                    if (!mask[j - 1] && !chopmask[j - 1])\n                        if ((0,_util_util__WEBPACK_IMPORTED_MODULE_1__.norm2_xy)(mx[i - 1] - mx[j - 1], my[i - 1] - my[j - 1]) < _CoordUtil__WEBPACK_IMPORTED_MODULE_4__.CoordUtil.OVERLAP_THRESHOLD_SQ) {\n                            let oldN = j, newN = i;\n                            if (mol.atomElement(i) == 'C' && mol.atomElement(j) != 'C' && mol.atomElement(j) != 'X')\n                                [oldN, newN] = [i, j];\n                            if (mol.atomHExplicit(newN) == _Molecule__WEBPACK_IMPORTED_MODULE_5__.Molecule.HEXPLICIT_UNKNOWN)\n                                mol.setAtomHExplicit(newN, mol.atomHExplicit(oldN));\n                            mol.setAtomUnpaired(newN, mol.atomUnpaired(newN) + mol.atomUnpaired(oldN));\n                            mol.setAtomCharge(newN, mol.atomCharge(newN) + mol.atomCharge(oldN));\n                            mol.setAtomExtra(newN, _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.concat(mol.atomExtra(oldN), mol.atomExtra(newN)));\n                            for (let n = 1; n <= mol.numBonds; n++) {\n                                if (mol.bondFrom(n) == oldN)\n                                    mol.setBondFrom(n, newN);\n                                if (mol.bondTo(n) == oldN)\n                                    mol.setBondTo(n, newN);\n                            }\n                            chopmask[oldN - 1] = true;\n                        }\n        for (let n = chopmask.length; n >= 1; n--)\n            if (chopmask[n - 1])\n                mol.deleteAtomAndBonds(n);\n        _MolUtil__WEBPACK_IMPORTED_MODULE_6__.MolUtil.removeDuplicateBonds(mol);\n    }\n    static matchAngleGeometry(geom, theta) {\n        if (theta.length <= 1)\n            return true;\n        let match = SketchUtil.GEOM_ANGLES[geom], mtheta = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.numberArray(0, theta.length);\n        let hit = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.booleanArray(false, match.length);\n        for (let n = 0; n < theta.length; n++)\n            for (let s = 1; s >= -1; s -= 2) {\n                for (let i = 0; i < theta.length; i++)\n                    mtheta[i] = (theta[i] - theta[0]) * s;\n                _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.setTo(hit, false);\n                let gotall = true;\n                for (let i = 0; i < mtheta.length; i++) {\n                    let got = false;\n                    for (let j = 0; j < match.length; j++)\n                        if (!hit[j] && Math.abs((0,_util_util__WEBPACK_IMPORTED_MODULE_1__.angleDiff)(mtheta[i], match[j])) < 3 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD) {\n                            hit[j] = true;\n                            got = true;\n                            break;\n                        }\n                    if (!got) {\n                        gotall = false;\n                        break;\n                    }\n                }\n                if (gotall)\n                    return true;\n            }\n        return false;\n    }\n    static primeDirections(mol, atom) {\n        let angles = SketchUtil.calculateNewBondAngles(mol, atom, 1);\n        let exits = SketchUtil.exitVectors(mol, atom);\n        return _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.uniqueAngles(angles.concat(exits), 2 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD);\n    }\n    static exitVectors(mol, atom) {\n        let adj = mol.atomAdjList(atom), sz = adj.length;\n        if (sz == 0)\n            return [0, 90 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, 180 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, -90 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD];\n        if (sz == 1)\n            return [];\n        let ret = [];\n        let ang = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.sortAngles(_CoordUtil__WEBPACK_IMPORTED_MODULE_4__.CoordUtil.atomBondAngles(mol, atom, adj));\n        for (let n = 0; n < sz; n++) {\n            let nn = n < sz - 1 ? n + 1 : 0;\n            ret.push((0,_util_util__WEBPACK_IMPORTED_MODULE_1__.angleNorm)(ang[n] + 0.5 * (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.angleDiffPos)(ang[nn], ang[n])));\n        }\n        return ret;\n    }\n    static calculateNewBondAngles(mol, atom, order) {\n        let adj = mol.atomAdjList(atom);\n        const sz = adj.length;\n        if (sz == 0) {\n            let atno = mol.atomicNumber(atom), atblk = _Chemistry__WEBPACK_IMPORTED_MODULE_3__.Chemistry.ELEMENT_BLOCKS[atno];\n            if (atblk <= 2)\n                return [0, 90 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, 180 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, -90 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD];\n            else\n                return [90 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, -90 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, 30 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, 150 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, 210 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, -30 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, 180 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, 0 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD];\n        }\n        let geom = SketchUtil.guessAtomGeometry(mol, atom, order);\n        let ang = _CoordUtil__WEBPACK_IMPORTED_MODULE_4__.CoordUtil.atomBondAngles(mol, atom, adj);\n        for (let n = 0; n < geom.length; n++) {\n            let ret = SketchUtil.mapAngleSubstituent(geom[n], ang);\n            if (ret != null)\n                return ret;\n        }\n        return [];\n    }\n    static guessAtomGeometry(mol, atom, order) {\n        let adj = mol.atomAdjList(atom);\n        let sz = adj.length, atno = mol.atomicNumber(atom);\n        let atblk = _Chemistry__WEBPACK_IMPORTED_MODULE_3__.Chemistry.ELEMENT_BLOCKS[atno], elrow = _Chemistry__WEBPACK_IMPORTED_MODULE_3__.Chemistry.ELEMENT_ROWS[atno];\n        let el = mol.atomElement(atom);\n        let adjBO = [], adjAN = [], pri = [];\n        let allSingle = true;\n        for (let n = 0; n < sz; n++) {\n            adjBO.push(mol.bondOrder(mol.findBond(atom, adj[n])));\n            adjAN.push(mol.atomicNumber(adj[n]));\n            pri.push(adjBO[n] * 200 + adjAN[n]);\n            if (adjBO[n] != 1)\n                allSingle = true;\n        }\n        for (let p = 0; p < sz - 1;) {\n            if (pri[p] > pri[p + 1]) {\n                _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.swap(adj, p, p + 1);\n                _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.swap(adjBO, p, p + 1);\n                _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.swap(adjAN, p, p + 1);\n                _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.swap(pri, p, p + 1);\n                if (p > 0)\n                    p--;\n            }\n            else\n                p++;\n        }\n        let ang = _CoordUtil__WEBPACK_IMPORTED_MODULE_4__.CoordUtil.atomBondAngles(mol, atom, adj);\n        if (sz == 1) {\n            if (el == 'C' || el == 'N') {\n                if (adjBO[0] == 2 && order == 2)\n                    return [Geometry.Linear];\n                if ((adjBO[0] == 3 && order == 1) || (adjBO[0] == 1 && order == 3))\n                    return [Geometry.Linear];\n            }\n            if (atblk > 2)\n                return [Geometry.Octa1, Geometry.Octa2];\n            if (order != 0 && (el == 'C' || el == 'N' || el == 'O'))\n                return [Geometry.Trigonal];\n            return [Geometry.Trigonal, Geometry.Linear];\n        }\n        if (sz == 2 && Math.abs((0,_util_util__WEBPACK_IMPORTED_MODULE_1__.angleDiff)(ang[0], ang[1])) >= 175 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD) {\n            if (atblk <= 2)\n                return [Geometry.SqPlan];\n            else\n                return [Geometry.Octa1, Geometry.Octa2];\n        }\n        let geom = [];\n        if (atblk == 0)\n            geom = [Geometry.Trigonal, Geometry.SqPlan];\n        else if (atblk == 1)\n            geom = [Geometry.Trigonal, Geometry.SqPlan, Geometry.Octa1, Geometry.Octa2];\n        else if (atblk == 2) {\n            geom.push(Geometry.Trigonal);\n            if (el == 'C' && allSingle) {\n                geom.push(Geometry.Tetra1);\n                geom.push(Geometry.Tetra2);\n                geom.push(Geometry.SqPlan);\n            }\n            else if (el == 'C' && !allSingle) {\n            }\n            else if (elrow <= 3) {\n                geom.push(Geometry.Tetra1);\n                geom.push(Geometry.Tetra2);\n                geom.push(Geometry.SqPlan);\n            }\n            else {\n                geom.push(Geometry.Tetra1);\n                geom.push(Geometry.Tetra2);\n                geom.push(Geometry.SqPlan);\n                geom.push(Geometry.Octa1);\n                geom.push(Geometry.Octa2);\n            }\n        }\n        else {\n            geom.push(Geometry.Octa1);\n            geom.push(Geometry.Octa2);\n        }\n        for (let n = geom.length - 1; n >= 0; n--) {\n            if (!SketchUtil.matchAngleGeometry(geom[n], ang))\n                geom.splice(n, 1);\n        }\n        return geom;\n    }\n    static mapAngleSubstituent(geom, ang) {\n        let gtheta = SketchUtil.GEOM_ANGLES[geom];\n        const asz = ang.length, gsz = gtheta.length;\n        if (asz >= gsz)\n            return null;\n        if (asz == 0)\n            return gtheta.slice(0);\n        let vac = [];\n        for (let n = 0; n < asz; n++)\n            for (let k = 0; k < gsz; k++)\n                for (let s = 1; s >= -1; s -= 2) {\n                    let gang = [];\n                    for (let i = 0; i < gsz; i++)\n                        gang.push((0,_util_util__WEBPACK_IMPORTED_MODULE_1__.angleNorm)(ang[n] + s * (gtheta[i] - gtheta[k])));\n                    let mask = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.booleanArray(false, gsz);\n                    let mcount = 0;\n                    for (let i = 0; i < gsz; i++)\n                        if (!mask[i])\n                            for (let j = 0; j < asz; j++)\n                                if (Math.abs((0,_util_util__WEBPACK_IMPORTED_MODULE_1__.angleDiff)(gang[i], ang[j])) < 3 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD) {\n                                    mask[i] = true;\n                                    mcount++;\n                                    break;\n                                }\n                    if (mcount != asz)\n                        continue;\n                    for (let i = 0; i < gsz; i++)\n                        if (!mask[i])\n                            vac.push(gang[i]);\n                }\n        if (vac.length == 0)\n            return null;\n        vac = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.sortAngles(vac);\n        for (let n = 0; n < vac.length - 1; n++) {\n            let th1 = vac[n], th2 = vac[n + 1], dth = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.angleDiff)(th2, th1);\n            if (Math.abs(dth) < 5 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD) {\n                vac[n] = th1 + 0.5 * dth;\n                vac.splice(n + 1, 1);\n                n--;\n            }\n        }\n        return vac;\n    }\n    static refitAtomGeometry(mol, atom, geom) {\n        let gtheta = SketchUtil.GEOM_ANGLES[geom];\n        let gsz = gtheta.length;\n        let adj = mol.atomAdjList(atom);\n        let asz = adj.length;\n        if (asz <= 1 || asz > gsz)\n            return null;\n        let ang = _CoordUtil__WEBPACK_IMPORTED_MODULE_4__.CoordUtil.atomBondAngles(mol, atom, adj);\n        let inRing = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.booleanArray(false, asz);\n        let allInRing = true;\n        for (let n = 0; n < asz; n++) {\n            inRing[n] = mol.bondInRing(mol.findBond(atom, adj[n]));\n            if (!inRing[n])\n                allInRing = false;\n        }\n        if (allInRing)\n            return null;\n        let bestAng = null;\n        let bestScore = 0;\n        let ww = _MolUtil__WEBPACK_IMPORTED_MODULE_6__.MolUtil.calculateWalkWeight(mol, atom);\n        for (let i = 0; i < gsz; i++)\n            for (let j = 0; j < asz; j++)\n                for (let s = 1; s >= -1; s -= 2) {\n                    let newAng = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.numberArray(0, asz);\n                    let mask = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.booleanArray(false, gsz);\n                    for (let n1 = 0; n1 < asz; n1++) {\n                        let best = -1;\n                        let bdiff = 0;\n                        for (let n2 = 0; n2 < gsz; n2++)\n                            if (!mask[n2]) {\n                                let th = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.angleNorm)(gtheta[n2] * s - gtheta[i] + ang[j]);\n                                let diff = Math.abs((0,_util_util__WEBPACK_IMPORTED_MODULE_1__.angleDiff)(th, ang[n1]));\n                                if (best < 0 || diff < bdiff) {\n                                    best = n2;\n                                    bdiff = diff;\n                                    newAng[n1] = th;\n                                }\n                            }\n                        mask[best] = true;\n                    }\n                    let ringClash = false;\n                    for (let n = 0; n < asz; n++)\n                        if (inRing[n] && Math.abs((0,_util_util__WEBPACK_IMPORTED_MODULE_1__.angleDiff)(newAng[n], ang[n])) > 2 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD) {\n                            ringClash = true;\n                            break;\n                        }\n                    if (ringClash)\n                        continue;\n                    let score = 0;\n                    for (let n = 0; n < asz; n++)\n                        score += ww[adj[n] - 1] * Math.abs((0,_util_util__WEBPACK_IMPORTED_MODULE_1__.angleDiff)(newAng[n], ang[n]));\n                    if (bestAng == null || score < bestScore) {\n                        bestAng = newAng;\n                        bestScore = score;\n                    }\n                }\n        if (bestAng == null)\n            return null;\n        let same = true;\n        for (let n = 0; n < asz; n++)\n            if (Math.abs((0,_util_util__WEBPACK_IMPORTED_MODULE_1__.angleDiff)(bestAng[n], ang[n])) > 2 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD) {\n                same = false;\n                break;\n            }\n        if (same)\n            return null;\n        mol = mol.clone();\n        for (let n = 0; n < asz; n++)\n            if (!inRing[n])\n                _CoordUtil__WEBPACK_IMPORTED_MODULE_4__.CoordUtil.rotateBond(mol, atom, adj[n], bestAng[n] - ang[n]);\n        return mol;\n    }\n    static switchAtomGeometry(mol, src, dst, geoms) {\n        let bestAtom = 0;\n        let bestAng = 0, bestX = 0, bestY = 0;\n        let adj = mol.atomAdjList(src);\n        let ang = _CoordUtil__WEBPACK_IMPORTED_MODULE_4__.CoordUtil.atomBondAngles(mol, src, adj), theta = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.numberArray(0, ang.length - 1);\n        let cx = mol.atomX(src), cy = mol.atomY(src);\n        for (let i = 0; i < dst.length; i++) {\n            let a = adj.indexOf(dst[i]);\n            let curth = ang[a];\n            for (let n = 0, p = 0; n < adj.length; n++)\n                if (n != a)\n                    theta[p++] = ang[n];\n            let r = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.norm_xy)(mol.atomX(dst[i]) - cx, mol.atomY(dst[i]) - cy);\n            for (let j = 0; j < geoms.length; j++) {\n                if (adj.length >= SketchUtil.GEOM_ANGLES[geoms[j]].length)\n                    continue;\n                let newAng = SketchUtil.mapAngleSubstituent(geoms[j], theta);\n                if (newAng != null)\n                    for (let n = 0; n < newAng.length; n++) {\n                        let dth = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.angleDiff)(newAng[n], curth);\n                        if (Math.abs(dth) < 3 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD)\n                            continue;\n                        if (dth < 0)\n                            dth += _util_util__WEBPACK_IMPORTED_MODULE_1__.TWOPI;\n                        if (bestAtom == 0 || dth < bestAng - 2 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD || (dth < bestAng + 2 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD && dst[i] < bestAtom)) {\n                            let x = cx + r * Math.cos(newAng[n]);\n                            let y = cy + r * Math.sin(newAng[n]);\n                            if (_CoordUtil__WEBPACK_IMPORTED_MODULE_4__.CoordUtil.atomAtPoint(mol, x, y) != 0)\n                                continue;\n                            bestAtom = dst[i];\n                            bestAng = dth;\n                            bestX = x;\n                            bestY = y;\n                        }\n                    }\n                break;\n            }\n        }\n        if (bestAtom == 0)\n            return null;\n        mol = mol.clone();\n        mol.setAtomPos(bestAtom, bestX, bestY);\n        return mol;\n    }\n    static pickAtomsToConnect(mol, aidx) {\n        if (aidx.length < 2)\n            return null;\n        if (aidx.length == 2) {\n            if (mol.findBond(aidx[0], aidx[1]) > 0)\n                return null;\n            return aidx;\n        }\n        const AUTO_DSQ = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.sqr)(_Molecule__WEBPACK_IMPORTED_MODULE_5__.Molecule.IDEALBOND + 0.1);\n        let bestDSQ = Number.MAX_VALUE;\n        let bestA1 = 0, bestA2 = 0;\n        let conn = [];\n        for (let i = 0; i < aidx.length - 1; i++)\n            for (let j = i + 1; j < aidx.length; j++) {\n                if (mol.findBond(aidx[i], aidx[j]) > 0)\n                    continue;\n                let dsq = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.norm2_xy)(mol.atomX(aidx[i]) - mol.atomX(aidx[j]), mol.atomY(aidx[i]) - mol.atomY(aidx[j]));\n                if (dsq < AUTO_DSQ) {\n                    conn.push(aidx[i]);\n                    conn.push(aidx[j]);\n                }\n                else if (dsq < bestDSQ) {\n                    bestDSQ = dsq;\n                    bestA1 = aidx[i];\n                    bestA2 = aidx[j];\n                }\n            }\n        if (conn.length == 0 && bestA1 != 0) {\n            conn.push(bestA1);\n            conn.push(bestA2);\n        }\n        return conn.length == 0 ? null : conn;\n    }\n    static pickNewAtomDirection(mol, atom, theta) {\n        if (theta.length == 1)\n            return theta[0];\n        let bestTheta = theta[0], bestScore = Number.MAX_VALUE;\n        for (let n = 0; n < theta.length; n++) {\n            let px = mol.atomX(atom) + _Molecule__WEBPACK_IMPORTED_MODULE_5__.Molecule.IDEALBOND * Math.cos(theta[n]);\n            let py = mol.atomY(atom) + _Molecule__WEBPACK_IMPORTED_MODULE_5__.Molecule.IDEALBOND * Math.sin(theta[n]);\n            let score = _CoordUtil__WEBPACK_IMPORTED_MODULE_4__.CoordUtil.congestionPoint(mol, px, py);\n            if (score > bestScore)\n                continue;\n            if (_CoordUtil__WEBPACK_IMPORTED_MODULE_4__.CoordUtil.overlapsAtom(mol, px, py, 0.2))\n                score += 1E5;\n            if (score < bestScore) {\n                bestTheta = theta[n];\n                bestScore = score;\n            }\n        }\n        return bestTheta;\n    }\n    static joinOverlappingAtoms(mol, mask) {\n        mol = mol.clone();\n        mask = mask.slice(0);\n        const na = mol.numAtoms;\n        let mx = _MolUtil__WEBPACK_IMPORTED_MODULE_6__.MolUtil.arrayAtomX(mol), my = _MolUtil__WEBPACK_IMPORTED_MODULE_6__.MolUtil.arrayAtomY(mol);\n        let groups = [];\n        let groupX = [], groupY = [];\n        for (let i = 0; i < na - 1; i++)\n            if (mask[i]) {\n                let g = [i + 1];\n                let x = mx[i], y = my[i];\n                for (let j = i + 1; j < na; j++)\n                    if (mask[j]) {\n                        if ((0,_util_util__WEBPACK_IMPORTED_MODULE_1__.norm2_xy)(mx[j] - mx[i], my[j] - my[i]) > _CoordUtil__WEBPACK_IMPORTED_MODULE_4__.CoordUtil.OVERLAP_THRESHOLD_SQ)\n                            continue;\n                        g.push(j + 1);\n                        x += mx[j];\n                        y += my[j];\n                        let adjb = mol.atomAdjBonds(j + 1);\n                        for (let n = 0; n < adjb.length; n++) {\n                            if (mol.bondFrom(adjb[n]) == j + 1)\n                                mol.setBondFrom(adjb[n], i + 1);\n                            else if (mol.bondTo(adjb[n]) == j + 1)\n                                mol.setBondTo(adjb[n], i + 1);\n                        }\n                    }\n                if (g.length == 1)\n                    continue;\n                groups.push(g);\n                groupX.push(x / g.length);\n                groupY.push(y / g.length);\n            }\n        if (groups.length == 0)\n            return null;\n        let keepmask = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.booleanArray(true, na);\n        for (let n = 0; n < groups.length; n++) {\n            let g = groups[n];\n            mol.setAtomPos(g[0], groupX[n], groupY[n]);\n            for (let i = 1; i < g.length; i++)\n                keepmask[g[i] - 1] = false;\n        }\n        mol = _MolUtil__WEBPACK_IMPORTED_MODULE_6__.MolUtil.subgraphMask(mol, keepmask);\n        _MolUtil__WEBPACK_IMPORTED_MODULE_6__.MolUtil.removeDuplicateBonds(mol);\n        return mol;\n    }\n    static moveToEdge(mol, mask, dx, dy) {\n        let gotS = false, gotN = false;\n        let sx1 = 0, sy1 = 0, sx2 = 0, sy2 = 0;\n        let nx1 = 0, ny1 = 0, nx2 = 0, ny2 = 0;\n        for (let n = 1; n <= mol.numAtoms; n++) {\n            let x = mol.atomX(n), y = mol.atomY(n);\n            if (mask[n - 1]) {\n                if (!gotS || x < sx1)\n                    sx1 = x;\n                if (!gotS || y < sy1)\n                    sy1 = y;\n                if (!gotS || x > sx2)\n                    sx2 = x;\n                if (!gotS || y > sy2)\n                    sy2 = y;\n                gotS = true;\n            }\n            else {\n                if (!gotN || x < nx1)\n                    nx1 = x;\n                if (!gotN || y < ny1)\n                    ny1 = y;\n                if (!gotN || x > nx2)\n                    nx2 = x;\n                if (!gotN || y > ny2)\n                    ny2 = y;\n                gotN = true;\n            }\n        }\n        const SEPARATE = 1.0, SEPTEST = 0.9;\n        if ((dx < 0 && dy == 0 && sx2 <= nx1 - SEPTEST) ||\n            (dx > 0 && dy == 0 && sx1 >= nx2 + SEPTEST) ||\n            (dx == 0 && dy < 0 && sy2 <= ny1 - SEPTEST) ||\n            (dx == 0 && dy > 0 && sy1 >= ny2 + SEPTEST)) {\n            return null;\n        }\n        mol = mol.clone();\n        let ox = 0, oy = 0;\n        if (dx < 0)\n            ox = nx1 - sx2 - SEPARATE;\n        if (dx > 0)\n            ox = nx2 - sx1 + SEPARATE;\n        if (dy < 0)\n            oy = ny1 - sy2 - SEPARATE;\n        if (dy > 0)\n            oy = ny2 - sy1 + SEPARATE;\n        for (let n = 1; n <= mol.numAtoms; n++)\n            if (mask[n - 1])\n                mol.setAtomPos(n, mol.atomX(n) + ox, mol.atomY(n) + oy);\n        return mol;\n    }\n    static placeAdditionalHydrogens(mol, atom, numH) {\n        let base = mol.numAtoms;\n        const x0 = mol.atomX(atom), y0 = mol.atomY(atom);\n        let adj = mol.atomAdjList(atom);\n        if (adj.length == 2 && numH == 2) {\n            const th1 = Math.atan2(mol.atomY(adj[0]) - y0, mol.atomX(adj[0]) - x0);\n            const th2 = Math.atan2(mol.atomY(adj[1]) - y0, mol.atomX(adj[1]) - x0);\n            if (Math.abs((0,_util_util__WEBPACK_IMPORTED_MODULE_1__.angleDiff)(th1, th2)) < 170 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD) {\n                let theta = 0.5 * (th1 + th2) + Math.PI;\n                let th3 = theta - 30 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, th4 = theta + 30 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD;\n                mol.addAtom('H', x0 + _Molecule__WEBPACK_IMPORTED_MODULE_5__.Molecule.IDEALBOND * Math.cos(th3), y0 + _Molecule__WEBPACK_IMPORTED_MODULE_5__.Molecule.IDEALBOND * Math.sin(th3));\n                mol.addAtom('H', x0 + _Molecule__WEBPACK_IMPORTED_MODULE_5__.Molecule.IDEALBOND * Math.cos(th4), y0 + _Molecule__WEBPACK_IMPORTED_MODULE_5__.Molecule.IDEALBOND * Math.sin(th4));\n                mol.addBond(atom, base + 1, 1);\n                mol.addBond(atom, base + 2, 1);\n                return;\n            }\n        }\n        if (adj.length == 1 && numH == 3) {\n            let th1 = Math.atan2(mol.atomY(adj[0]) - y0, mol.atomX(adj[0]) - x0);\n            let th2 = th1 + 90 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, th3 = th1 + 180 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, th4 = th1 + 270 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD;\n            mol.addAtom('H', x0 + _Molecule__WEBPACK_IMPORTED_MODULE_5__.Molecule.IDEALBOND * Math.cos(th2), y0 + _Molecule__WEBPACK_IMPORTED_MODULE_5__.Molecule.IDEALBOND * Math.sin(th2));\n            mol.addAtom('H', x0 + _Molecule__WEBPACK_IMPORTED_MODULE_5__.Molecule.IDEALBOND * Math.cos(th3), y0 + _Molecule__WEBPACK_IMPORTED_MODULE_5__.Molecule.IDEALBOND * Math.sin(th3));\n            mol.addAtom('H', x0 + _Molecule__WEBPACK_IMPORTED_MODULE_5__.Molecule.IDEALBOND * Math.cos(th4), y0 + _Molecule__WEBPACK_IMPORTED_MODULE_5__.Molecule.IDEALBOND * Math.sin(th4));\n            mol.addBond(atom, base + 1, 1);\n            mol.addBond(atom, base + 2, 1);\n            mol.addBond(atom, base + 3, 1);\n            return;\n        }\n        let theta = SketchUtil.pickNewAtomDirection(mol, atom, SketchUtil.primeDirections(mol, atom));\n        mol.addAtom('H', x0 + _Molecule__WEBPACK_IMPORTED_MODULE_5__.Molecule.IDEALBOND * Math.cos(theta), y0 + _Molecule__WEBPACK_IMPORTED_MODULE_5__.Molecule.IDEALBOND * Math.sin(theta));\n        mol.addBond(atom, base + 1, 1);\n        if (numH > 1)\n            SketchUtil.placeAdditionalHydrogens(mol, atom, numH - 1);\n    }\n    static allViableDirections(mol, atom, order) {\n        if (mol.atomAdjCount(atom) == 0) {\n            let angles = [];\n            for (let n = 0; n < 12; n++)\n                angles.push(30 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD);\n            return angles;\n        }\n        let adj = mol.atomAdjList(atom);\n        let angles = SketchUtil.exitVectors(mol, atom);\n        let geom = SketchUtil.guessAtomGeometry(mol, atom, order);\n        if (adj.length == 1 && geom.indexOf(Geometry.Linear) < 0)\n            geom.push(Geometry.Linear);\n        let bndang = _CoordUtil__WEBPACK_IMPORTED_MODULE_4__.CoordUtil.atomBondAngles(mol, atom, adj);\n        for (let g of geom) {\n            let map = SketchUtil.mapAngleSubstituent(g, bndang);\n            if (map != null)\n                for (let th of map)\n                    angles.push(th);\n        }\n        return _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.uniqueAngles(angles, 2 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD);\n    }\n    static proposeNewRing(mol, rsz, x, y, dx, dy, snap) {\n        let theta = Math.atan2(dy, dx);\n        if (snap) {\n            const chunk = 30 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD;\n            theta = Math.round(theta / chunk) * chunk;\n        }\n        return SketchUtil.positionSimpleRing(mol, rsz, x, y, theta);\n    }\n    static proposeAtomRing(mol, rsz, atom, dx, dy) {\n        let thsnap = [];\n        let cx = mol.atomX(atom), cy = mol.atomY(atom);\n        if (mol.atomAdjCount(atom) == 0) {\n            for (let n = 0; n < 12; n++)\n                thsnap.push(_util_util__WEBPACK_IMPORTED_MODULE_1__.TWOPI * n / 12);\n        }\n        else if (mol.atomAdjCount(atom) == 1) {\n            let nbr = mol.atomAdjList(atom)[0];\n            thsnap.push((0,_util_util__WEBPACK_IMPORTED_MODULE_1__.angleNorm)(Math.atan2(mol.atomY(nbr) - cy, mol.atomX(nbr) - cx) + Math.PI));\n        }\n        else {\n            let angs = [];\n            for (let nbr of mol.atomAdjList(atom))\n                angs.push(Math.atan2(mol.atomY(nbr) - cy, mol.atomX(nbr) - cx));\n            angs = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.sortAngles)(angs);\n            for (let n = 0; n < angs.length; n++) {\n                let th1 = angs[n], th2 = angs[n < angs.length - 1 ? n + 1 : 0];\n                thsnap.push(th1 + 0.5 * (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.angleDiffPos)(th2, th1));\n            }\n        }\n        let theta = Math.atan2(dy, dx);\n        let bestTheta = 0, bestDelta = Number.MAX_VALUE;\n        for (let th of thsnap) {\n            let delta = Math.abs((0,_util_util__WEBPACK_IMPORTED_MODULE_1__.angleDiff)(th, theta));\n            if (delta < bestDelta) {\n                bestTheta = th;\n                bestDelta = delta;\n            }\n        }\n        return SketchUtil.positionSimpleRing(mol, rsz, mol.atomX(atom), mol.atomY(atom), bestTheta);\n    }\n    static proposeBondRing(mol, rsz, bond, dx, dy) {\n        let bfr = mol.bondFrom(bond), bto = mol.bondTo(bond);\n        let bx = mol.atomX(bto) - mol.atomX(bfr), by = mol.atomY(bto) - mol.atomY(bfr);\n        let sign = dx * by - dy * bx;\n        let delta = sign > 0 ? -90 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD : 90 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD;\n        let theta = Math.atan2(by, bx) + delta;\n        let dth = _util_util__WEBPACK_IMPORTED_MODULE_1__.TWOPI / rsz;\n        let rad = _Molecule__WEBPACK_IMPORTED_MODULE_5__.Molecule.IDEALBOND / (2.0 * Math.sin(0.5 * dth)), brad = rad * Math.cos(0.5 * dth);\n        let cx = 0.5 * (mol.atomX(bfr) + mol.atomX(bto)) + brad * Math.cos(theta);\n        let cy = 0.5 * (mol.atomY(bfr) + mol.atomY(bto)) + brad * Math.sin(theta);\n        let rx = [], ry = [];\n        for (let n = 0; n < rsz; n++) {\n            let th = theta - Math.PI + (n - 0.5) * dth;\n            rx.push(cx + Math.cos(th) * rad);\n            ry.push(cy + Math.sin(th) * rad);\n        }\n        let [i1, i2] = sign < 0 ? [bfr, bto] : [bto, bfr];\n        rx[0] = mol.atomX(i1);\n        ry[0] = mol.atomY(i1);\n        rx[1] = mol.atomX(i2);\n        ry[1] = mol.atomY(i2);\n        return [rx, ry];\n    }\n    static positionSimpleRing(mol, rsz, x, y, theta) {\n        let dth = _util_util__WEBPACK_IMPORTED_MODULE_1__.TWOPI / rsz;\n        let rad = _Molecule__WEBPACK_IMPORTED_MODULE_5__.Molecule.IDEALBOND / (2 * Math.sin(0.5 * dth));\n        let cx = x + rad * Math.cos(theta), cy = y + rad * Math.sin(theta);\n        let rx = [], ry = [];\n        for (let n = 0; n < rsz; n++) {\n            let th = theta - Math.PI + n * dth;\n            rx.push(cx + Math.cos(th) * rad);\n            ry.push(cy + Math.sin(th) * rad);\n        }\n        return [rx, ry];\n    }\n    static guidelineSprouts(mol, atom) {\n        let sprouts = [];\n        let angs = [], ords = [];\n        for (let n = 0; n < 3; n++) {\n            angs.push(SketchUtil.allViableDirections(mol, atom, n + 1));\n            ords.push([n + 1]);\n            for (let i = 0; i < n; i++)\n                if (angs[i] != null && _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.equals(angs[n], angs[i])) {\n                    angs[n] = null;\n                    ords[i].push(n + 1);\n                }\n        }\n        const cx = mol.atomX(atom), cy = mol.atomY(atom);\n        for (let n = 0; n < 3; n++)\n            if (angs[n] != null) {\n                let sprout = {\n                    'atom': atom,\n                    'orders': ords[n],\n                    'x': [],\n                    'y': [],\n                };\n                for (let i = 0; i < angs[n].length; i++) {\n                    sprout.x[i] = cx + Math.cos(angs[n][i]) * _Molecule__WEBPACK_IMPORTED_MODULE_5__.Molecule.IDEALBOND;\n                    sprout.y[i] = cy + Math.sin(angs[n][i]) * _Molecule__WEBPACK_IMPORTED_MODULE_5__.Molecule.IDEALBOND;\n                }\n                sprouts.push(sprout);\n            }\n        return sprouts;\n    }\n}\nSketchUtil.GEOM_ANGLES = [\n    [0, 180 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD],\n    [0, 120 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD],\n    [0, 120 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, 240 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD],\n    [0, 90 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, 150 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, 240 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD],\n    [0, 120 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, 180 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, 240 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD],\n    [0, 90 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, 180 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, 270 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD],\n    [0, 90 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, 150 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, 210 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, 270 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD],\n    [0, 60 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, 90 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, 180 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, 210 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD],\n    [0, 60 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, 120 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, 180 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, 240 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, 300 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD],\n    [0, 45 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, 90 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, 180 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, 225 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD, 270 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD]\n];\n\n\n//# sourceURL=webpack://WebMolKit/./src/data/SketchUtil.ts?");

/***/ }),

/***/ "./src/data/Stereochemistry.ts":
/*!*************************************!*\
  !*** ./src/data/Stereochemistry.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Stereochemistry\": () => (/* binding */ Stereochemistry)\n/* harmony export */ });\n/* harmony import */ var _util_Geom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Geom */ \"./src/util/Geom.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _Chemistry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Chemistry */ \"./src/data/Chemistry.ts\");\n/* harmony import */ var _Molecule__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Molecule */ \"./src/data/Molecule.ts\");\n/* harmony import */ var _MolUtil__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MolUtil */ \"./src/data/MolUtil.ts\");\n\n\n\n\n\n\nclass Stereochemistry {\n    constructor(meta) {\n        this.meta = meta;\n        this.mol = meta.mol;\n        this.priority = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.numberArray(0, this.mol.numAtoms);\n        this.chiralTetra = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.numberArray(Stereochemistry.STEREO_NONE, this.mol.numAtoms);\n        this.cistransBond = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.numberArray(Stereochemistry.STEREO_NONE, this.mol.numBonds);\n        this.squarePlanar = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.numberArray(Stereochemistry.STEREO_NONE, this.mol.numAtoms);\n    }\n    calculate() {\n        this.isH = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.booleanArray(false, this.mol.numAtoms);\n        for (let n = this.mol.numAtoms; n >= 1; n--)\n            this.isH[n - 1] = this.mol.atomElement(n) == 'H';\n        this.buildPriority();\n        this.buildTetraChirality();\n        this.buildBondCisTrans();\n        this.buildPlanarCisTrans();\n        this.buildOctaChirality();\n    }\n    atomPriority(atom) { return this.priority[atom - 1]; }\n    atomTetraChirality(atom) { return this.chiralTetra[atom - 1]; }\n    bondSideStereo(bond) { return this.cistransBond[bond - 1]; }\n    atomPlanarStereo(atom) { return this.squarePlanar[atom - 1]; }\n    getPriorities() { return this.priority.slice(0); }\n    getAtomTetraChiral() { return this.chiralTetra.slice(0); }\n    getBondSideStereo() { return this.cistransBond.slice(0); }\n    static create(meta) {\n        let stereo = new Stereochemistry(meta);\n        stereo.calculate();\n        return stereo;\n    }\n    static rubricTetrahedral(mol, atom) {\n        if (mol.atomAdjCount(atom) < 3 || mol.atomAdjCount(atom) + mol.atomHydrogens(atom) != 4)\n            return null;\n        let adjBonds = mol.atomAdjBonds(atom);\n        let hasWedge = false;\n        for (let n = 0; n < adjBonds.length; n++) {\n            let bt = mol.bondType(adjBonds[n]);\n            if (bt == _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_UNKNOWN)\n                return null;\n            if (mol.bondFrom(adjBonds[n]) != atom)\n                continue;\n            if (bt == _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_INCLINED || bt == _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_DECLINED)\n                hasWedge = true;\n        }\n        if (!hasWedge && !mol.is3D())\n            return null;\n        let adj = mol.atomAdjList(atom);\n        let x = [0, 0, 0, 0];\n        let y = [0, 0, 0, 0];\n        let z = [0, 0, 0, 0];\n        let numShort = 0, numWedges = 0;\n        for (let n = 0; n < adjBonds.length; n++) {\n            const bfr = mol.bondFrom(adjBonds[n]), bt = mol.bondType(adjBonds[n]);\n            x[n] = mol.atomX(adj[n]) - mol.atomX(atom);\n            y[n] = mol.atomY(adj[n]) - mol.atomY(atom);\n            if (mol.is3D()) {\n                z[n] = mol.atomZ(adj[n]) - mol.atomZ(atom);\n            }\n            else if (bfr == atom) {\n                if (bt == _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_INCLINED) {\n                    z[n] = 1;\n                    numWedges++;\n                }\n                else if (bt == _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_DECLINED) {\n                    z[n] = -1;\n                    numWedges++;\n                }\n            }\n            let dsq = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.norm_xyz)(x[n], y[n], z[n]);\n            if (dsq < 0.01 * 0.01) {\n                numShort++;\n                if (numShort > 1)\n                    return null;\n            }\n        }\n        if (adjBonds.length == 3) {\n            adj.push(0);\n            if (!mol.is3D() && numWedges == 1) {\n                let th0 = Math.atan2(y[0], x[0]), th1 = Math.atan2(y[1], x[1]), th2 = Math.atan2(y[2], x[2]);\n                let i1 = 1, i2 = 2;\n                if ((0,_util_util__WEBPACK_IMPORTED_MODULE_1__.angleDiffPos)(th1, th0) > (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.angleDiffPos)(th2, th0)) {\n                    i2 = 1;\n                    i1 = 2;\n                }\n                x[0] = 1.5;\n                y[0] = 0;\n                x[1] = -0.75;\n                y[i1] = 1.3;\n                x[2] = -0.75;\n                y[i2] = -1.3;\n            }\n            else {\n                x[3] = -(x[0] + x[1] + x[2]);\n                y[3] = -(y[0] + y[1] + y[2]);\n                z[3] = -(z[0] + z[1] + z[2]);\n                let dsq = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.norm2_xyz)(x[3], y[3], z[3]);\n                if (dsq < 0.01 * 0.01)\n                    return null;\n                let inv = 1.0 / Math.sqrt(dsq);\n                x[3] *= inv;\n                y[3] *= inv;\n                z[3] *= inv;\n            }\n        }\n        let one = 0, two = 0;\n        for (let i = 1; i <= 6; i++) {\n            let a = 0, b = 0;\n            if (i == 1) {\n                a = 1;\n                b = 2;\n            }\n            else if (i == 2) {\n                a = 2;\n                b = 3;\n            }\n            else if (i == 3) {\n                a = 3;\n                b = 1;\n            }\n            else if (i == 4) {\n                a = 2;\n                b = 1;\n            }\n            else if (i == 5) {\n                a = 3;\n                b = 2;\n            }\n            else if (i == 6) {\n                a = 1;\n                b = 3;\n            }\n            let xx = y[a] * z[b] - y[b] * z[a] - x[0];\n            let yy = z[a] * x[b] - z[b] * x[a] - y[0];\n            let zz = x[a] * y[b] - x[b] * y[a] - z[0];\n            if (i <= 3)\n                one += xx * xx + yy * yy + zz * zz;\n            else\n                two += xx * xx + yy * yy + zz * zz;\n        }\n        if (two > one)\n            _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.swap(adj, 2, 3);\n        return adj;\n    }\n    static rubricSquarePlanar(mol, atom) {\n        if (mol.atomAdjCount(atom) != 4)\n            return null;\n        if (!mol.is3D()) {\n            let ninc = 0, ndec = 0;\n            for (let b of mol.atomAdjBonds(atom)) {\n                let bt = mol.bondType(b);\n                if (bt == _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_INCLINED)\n                    ninc++;\n                else if (bt == _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_DECLINED)\n                    ndec++;\n            }\n            if (ninc == 2 && ndec == 2) { }\n            else if (ninc == 2 && ndec == 0) { }\n            else if (ninc == 0 && ndec == 2) { }\n            else\n                return null;\n        }\n        let adj = mol.atomAdjList(atom);\n        let v0 = _MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.atomVec3(mol, atom);\n        let v1 = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.sub(_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.atomVec3(mol, adj[0]), v0);\n        let v2 = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.sub(_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.atomVec3(mol, adj[1]), v0);\n        let v3 = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.sub(_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.atomVec3(mol, adj[2]), v0);\n        let v4 = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.sub(_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.atomVec3(mol, adj[3]), v0);\n        for (let v of [v1, v2, v3, v4]) {\n            let dsq = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.norm2_xyz)(v[0], v[1], v[2]);\n            if (dsq < 0.01 * 0.01)\n                continue;\n            let inv = 1.0 / Math.sqrt(dsq);\n            v[0] *= inv;\n            v[1] *= inv;\n            v[2] *= inv;\n        }\n        let d2 = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.dist2(v1, v2), d3 = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.dist2(v1, v3), d4 = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.dist2(v1, v4);\n        if (d2 > d3 && d2 >= d4) {\n            _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.swap(adj, 1, 2);\n            [v2, v3] = [v3, v2];\n        }\n        else if (d4 > d3) {\n            _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.swap(adj, 3, 2);\n            [v3, v4] = [v4, v3];\n        }\n        const MIN_ANGLE = (mol.is3D() ? 80 : 45) * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD;\n        const MAX_ANGLE = (mol.is3D() ? 100 : 135) * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD;\n        const th12 = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.acuteAngle(v1, v2);\n        if (th12 < MIN_ANGLE || th12 > MAX_ANGLE)\n            return null;\n        const th23 = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.acuteAngle(v2, v3);\n        if (th23 < MIN_ANGLE || th23 > MAX_ANGLE)\n            return null;\n        const th34 = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.acuteAngle(v3, v4);\n        if (th34 < MIN_ANGLE || th34 > MAX_ANGLE)\n            return null;\n        const th41 = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.acuteAngle(v4, v1);\n        if (th41 < MIN_ANGLE || th41 > MAX_ANGLE)\n            return null;\n        return adj;\n    }\n    static rubricBipyrimidal(mol, atom) {\n        const nadj = mol.atomAdjCount(atom);\n        if (nadj != 4 && nadj != 5)\n            return null;\n        let atom2 = 0, atom3 = 0;\n        let adj = mol.atomAdjList(atom), bonds = mol.atomAdjBonds(atom);\n        if (!mol.is3D()) {\n            for (let n = 0; n < adj.length; n++) {\n                if (mol.bondType(bonds[n]) == _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_INCLINED) {\n                    if (atom2 > 0)\n                        return null;\n                    atom2 = adj[n];\n                }\n                else if (mol.bondType(bonds[n]) == _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_DECLINED) {\n                    if (atom3 > 0)\n                        return null;\n                    atom3 = adj[n];\n                }\n            }\n            if (atom2 == 0 || atom3 == 0)\n                return null;\n            let th1 = Math.atan2(mol.atomY(atom2) - mol.atomY(atom), mol.atomX(atom2) - mol.atomX(atom));\n            let th2 = Math.atan2(mol.atomY(atom3) - mol.atomY(atom), mol.atomX(atom3) - mol.atomX(atom));\n            if (Math.abs((0,_util_util__WEBPACK_IMPORTED_MODULE_1__.angleDiff)(th1, th2)) > 160 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD)\n                return null;\n        }\n        let v0 = _MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.atomVec3(mol, atom);\n        let v = [[], [], [], [], []];\n        const THRESH = 0.1;\n        for (let n = 0; n < nadj; n++) {\n            v[n] = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.sub(_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.atomVec3(mol, adj[n]), v0);\n            const mag = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.magnitude(v[n]);\n            if (mag < THRESH)\n                return null;\n            _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.mulBy(v[n], 1.0 / mag);\n            if (adj[n] == atom2)\n                v[n][2] += 1;\n            else if (adj[n] == atom3)\n                v[n][2] -= 1;\n        }\n        let atom4 = 0, atom5 = 0;\n        const ANGLE_OPPOSITE = 175 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD;\n        for (let i = 0; i < nadj - 1; i++)\n            if (adj[i] != atom2 && adj[i] != atom3) {\n                for (let j = i + 1; j < nadj; j++)\n                    if (adj[j] != atom2 && adj[j] != atom3) {\n                        let theta = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.acuteAngle(v[i], v[j]);\n                        if (theta > ANGLE_OPPOSITE) {\n                            if (atom4 != 0)\n                                return null;\n                            atom4 = adj[i];\n                            atom5 = adj[j];\n                        }\n                    }\n            }\n        if (mol.is3D()) {\n            for (let a of adj)\n                if (a != atom4 && a != atom5) {\n                    if (atom2 == 0)\n                        atom2 = a;\n                    else if (atom3 == 0)\n                        atom3 = a;\n                }\n        }\n        if (!atom4 || !atom5)\n            return null;\n        let v1 = null;\n        let v2 = v[adj.indexOf(atom2)];\n        let v3 = v[adj.indexOf(atom3)];\n        let v4 = v[adj.indexOf(atom4)];\n        let v5 = v[adj.indexOf(atom5)];\n        let atom1 = 0;\n        if (nadj == 5) {\n            for (let n = 0; n < nadj; n++)\n                if (adj[n] != atom2 && adj[n] != atom3 && adj[n] != atom4 && adj[n] != atom5) {\n                    atom1 = adj[n];\n                    v1 = v[n];\n                    break;\n                }\n        }\n        else {\n            v1 = [0, 0, 0];\n            v1 = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.sub(v1, v2);\n            v1 = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.sub(v1, v3);\n            const mag = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.magnitude(v1);\n            if (mag < THRESH)\n                return null;\n            _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.mulBy(v1, 1.0 / mag);\n        }\n        let v45 = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.sub(v5, v4);\n        let cross = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.crossProduct(v45, v1);\n        let dsq2 = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.dist2(cross, v2), dsq3 = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.dist2(cross, v3);\n        if (dsq2 < dsq3)\n            return [atom1, atom2, atom3, atom4, atom5];\n        else\n            return [atom1, atom2, atom3, atom5, atom4];\n    }\n    static rubricOctahedral(mol, atom) {\n        const nadj = mol.atomAdjCount(atom);\n        if (nadj != 5 && nadj != 6)\n            return null;\n        let adj = mol.atomAdjList(atom), bonds = mol.atomAdjBonds(atom);\n        if (nadj == 5) {\n            adj.push(0);\n            bonds.push(0);\n        }\n        if (!mol.is3D()) {\n            let numWedges = 0;\n            for (let b of bonds)\n                if (b > 0) {\n                    const bt = mol.bondType(b);\n                    if (bt == _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_INCLINED || bt == _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_DECLINED)\n                        numWedges++;\n                }\n            if ((nadj == 5 && numWedges < 1) || (nadj == 6 && numWedges < 2))\n                return null;\n        }\n        const THRESH = 0.1;\n        let v0 = _MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.atomVec3(mol, atom);\n        let v = [[], [], [], [], [], []];\n        for (let n = 0; n < nadj; n++) {\n            v[n] = _MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.atomVec3(mol, adj[n]);\n            _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.subFromArray(v[n], v0);\n            let mag = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.magnitude(v[n]);\n            if (mag < THRESH)\n                return null;\n            _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.mulBy(v[n], 1 / mag);\n            let bt = mol.bondType(bonds[n]);\n            if (bt == _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_INCLINED) {\n                if (mol.bondFrom(bonds[n]) == atom)\n                    v[n][2] += 1;\n                else\n                    v[n][2] -= 1;\n            }\n            else if (bt == _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_DECLINED) {\n                if (mol.bondFrom(bonds[n]) == atom)\n                    v[n][2] -= 1;\n                else\n                    v[n][2] += 1;\n            }\n        }\n        if (nadj == 5) {\n            v[5] = [0, 0, 0];\n            for (let n = 0; n < 5; n++)\n                _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.subFromArray(v[5], v[n]);\n            let mag = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.magnitude(v[5]);\n            if (mag < THRESH)\n                return null;\n            _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.mulBy(v[5], 1 / mag);\n        }\n        let slots = [-1, -1, -1, -1, 0, 1];\n        let bestOpposite = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.acuteAngle(v[0], v[1]);\n        for (let i = 0; i < 5; i++)\n            for (let j = (i == 0 ? 2 : i + 1); j < 6; j++) {\n                let theta = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.acuteAngle(v[i], v[j]);\n                if (theta > bestOpposite) {\n                    slots[4] = i;\n                    slots[5] = j;\n                    bestOpposite = theta;\n                }\n            }\n        let axial = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.sub(v[slots[5]], v[slots[4]]);\n        let bestOrthogonal = Number.POSITIVE_INFINITY;\n        for (let n = 0; n < 6; n++)\n            if (n != slots[4] && n != slots[5]) {\n                let delta = Math.abs((90 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD) - _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.acuteAngle(v[n], axial));\n                if (delta < bestOrthogonal) {\n                    slots[0] = n;\n                    bestOrthogonal = delta;\n                }\n            }\n        for (let s = 1; s <= 2; s++) {\n            let cross = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.crossProduct(axial, v[slots[s - 1]]);\n            let bestOrient = Number.POSITIVE_INFINITY;\n            for (let n = 0; n < 6; n++) {\n                if (n == slots[4] || n == slots[5] || n == slots[0] || n == slots[1])\n                    continue;\n                let delta = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.acuteAngle(v[n], cross);\n                if (delta < bestOrient) {\n                    slots[s] = n;\n                    bestOrient = delta;\n                }\n            }\n        }\n        for (let n = 0; n < 6; n++)\n            if (slots.indexOf(n) < 0) {\n                slots[3] = n;\n                break;\n            }\n        let rubric = [0, 0, 0, 0, 0, 0];\n        for (let n = 0; n < 6; n++)\n            rubric[n] = slots[n] < 0 ? 0 : adj[slots[n]];\n        return rubric;\n    }\n    static rubricBondSides(mol, bond) {\n        const bfr = mol.bondFrom(bond), bto = mol.bondTo(bond);\n        const nfr = mol.atomAdjCount(bfr), nto = mol.atomAdjCount(bto);\n        if (nfr < 2 || nfr > 3 || nto < 2 || nto > 3)\n            return null;\n        let adj1 = mol.atomAdjList(bfr), adj2 = mol.atomAdjList(bto);\n        let f1 = 0, f2 = 0, t1 = 0, t2 = 0;\n        for (let i = 0; i < adj1.length; i++) {\n            if (adj1[i] != bto) {\n                if (f1 == 0)\n                    f1 = adj1[i];\n                else\n                    f2 = adj1[i];\n            }\n        }\n        for (let i = 0; i < adj2.length; i++) {\n            if (adj2[i] != bfr) {\n                if (t1 == 0)\n                    t1 = adj2[i];\n                else\n                    t2 = adj2[i];\n            }\n        }\n        if (f1 > 0 && f2 > 0 && mol.atomElement(f1) == 'H') {\n            let f = f1;\n            f1 = f2;\n            f2 = f;\n        }\n        if (t1 > 0 && t2 > 0 && mol.atomElement(t1) == 'H') {\n            let t = t1;\n            t1 = t2;\n            t2 = t;\n        }\n        let vfr = _MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.atomVec3(mol, bfr), vto = _MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.atomVec3(mol, bto);\n        let vbond = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.sub(vto, vfr);\n        let vf1 = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.sub(_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.atomVec3(mol, f1), vfr), vt1 = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.sub(_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.atomVec3(mol, t1), vto);\n        const THRESHSQ = 0.1 * 0.1;\n        let xf1 = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.crossProduct(vf1, vbond);\n        if (_util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.magnitude2(xf1) < THRESHSQ)\n            return null;\n        let xt1 = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.crossProduct(vt1, vbond);\n        if (_util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.magnitude2(xt1) < THRESHSQ)\n            return null;\n        let xf1N = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.neg(xf1);\n        let keepF1T1 = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.dist2(xf1, xt1) < _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.dist2(xf1N, xt1);\n        let keepF2T1 = keepF1T1, keepF1T2 = keepF1T1, keepF2T2 = keepF1T1;\n        let vf2 = null, vt2 = null, xf2 = null, xt2 = null, xf2N = null;\n        if (f2 > 0) {\n            vf2 = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.sub(_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.atomVec3(mol, f2), vfr);\n            if (_util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.magnitude2(vf2) < THRESHSQ) {\n                if (mol.atomElement(f2) != 'H')\n                    return null;\n            }\n            else {\n                xf2 = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.crossProduct(vf2, vbond);\n                if (_util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.magnitude2(xf2) < THRESHSQ)\n                    return null;\n                xf2N = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.neg(xf2);\n                keepF2T1 = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.dist2(xf2, xt1) > _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.dist2(xf2N, xt1);\n            }\n        }\n        if (t2 > 0) {\n            vt2 = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.sub(_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.atomVec3(mol, t2), vto);\n            if (_util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.magnitude2(vt2) < THRESHSQ) {\n                if (mol.atomElement(t2) != 'H')\n                    return null;\n            }\n            else {\n                xt2 = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.crossProduct(vt2, vbond);\n                if (_util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.magnitude2(xt2) < THRESHSQ)\n                    return null;\n                keepF1T2 = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.dist2(xf1, xt2) > _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.dist2(xf1N, xt2);\n            }\n        }\n        if (xf2 != null && xt2 != null) {\n            keepF2T2 = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.dist2(xf2, xt2) < _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.dist2(xf2N, xt2);\n        }\n        if (keepF1T1 && keepF2T1 && keepF1T2 && keepF2T2)\n            return [f1, f2, t1, t2];\n        if (!keepF1T1 && !keepF2T1 && !keepF1T2 && !keepF2T2)\n            return [f1, f2, t2, t1];\n        return null;\n    }\n    buildTetraChirality() {\n        const mol = this.mol, na = mol.numAtoms, nb = mol.numBonds;\n        let haswedge = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.booleanArray(false, na);\n        for (let n = 1; n <= nb; n++) {\n            if (mol.bondType(n) == _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_INCLINED || mol.bondType(n) == _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_DECLINED)\n                haswedge[mol.bondFrom(n) - 1] = true;\n        }\n        skip_atom: for (let n = 1; n <= na; n++) {\n            this.chiralTetra[n - 1] = Stereochemistry.STEREO_NONE;\n            let adj = mol.atomAdjList(n);\n            if (!(adj.length == 4 || (adj.length == 3 && mol.atomHydrogens(n) == 1)))\n                continue;\n            if (adj.length == 3 && (this.isH[adj[0] - 1] || this.isH[adj[1] - 1] || this.isH[adj[2] - 1]))\n                continue;\n            for (let i = 0; i < adj.length - 1; i++) {\n                for (let j = i + 1; j < adj.length; j++) {\n                    if (this.priority[adj[i] - 1] == this.priority[adj[j] - 1])\n                        continue skip_atom;\n                }\n            }\n            if (!haswedge[n - 1] && !mol.is3D()) {\n                this.chiralTetra[n - 1] = Stereochemistry.STEREO_UNKNOWN;\n                continue;\n            }\n            let rubric = Stereochemistry.rubricTetrahedral(mol, n);\n            if (rubric == null)\n                continue;\n            let pri = [\n                rubric[0] == 0 ? 0 : this.priority[rubric[0] - 1],\n                rubric[1] == 0 ? 0 : this.priority[rubric[1] - 1],\n                rubric[2] == 0 ? 0 : this.priority[rubric[2] - 1],\n                rubric[3] == 0 ? 0 : this.priority[rubric[3] - 1]\n            ];\n            pri = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.idxSort(pri);\n            let parity = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Permutation.parityIdentity(pri);\n            this.chiralTetra[n - 1] = (parity & 1) == 0 ? Stereochemistry.STEREO_POS : Stereochemistry.STEREO_NEG;\n        }\n    }\n    buildBondCisTrans() {\n        const mol = this.mol, na = mol.numAtoms, nb = mol.numBonds;\n        let sf = [0, 0], st = [0, 0];\n        let ringMask = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.booleanArray(false, nb);\n        for (let rsz = 3; rsz <= 7; rsz++) {\n            for (let r of mol.findRingsOfSize(rsz)) {\n                for (let n = 0; n < r.length; n++) {\n                    let b = mol.findBond(r[n], r[n < r.length - 1 ? n + 1 : 0]);\n                    ringMask[b - 1] = true;\n                }\n            }\n        }\n        skip_bond: for (let n = 1; n <= nb; n++) {\n            this.cistransBond[n - 1] = Stereochemistry.STEREO_NONE;\n            if (mol.bondOrder(n) != 2 || this.meta.isBondAromatic(n) || ringMask[n - 1])\n                continue;\n            let bfr = mol.bondFrom(n), bto = mol.bondTo(n);\n            let adj1 = mol.atomAdjList(bfr), adj2 = mol.atomAdjList(bto);\n            if (adj1.length <= 1 || adj2.length <= 1 || adj1.length > 3 || adj2.length > 3)\n                continue;\n            if (adj1.length == 2 && (this.isH[adj1[0] - 1] || this.isH[adj1[1] - 1]))\n                continue;\n            if (adj2.length == 2 && (this.isH[adj2[0] - 1] || this.isH[adj2[1] - 1]))\n                continue;\n            for (let i = 0; i < adj1.length - 1; i++)\n                if (adj1[i] != bfr)\n                    for (let j = i + 1; j < adj1.length; j++)\n                        if (adj1[j] != bfr)\n                            if (this.priority[adj1[i] - 1] == this.priority[adj1[j] - 1])\n                                continue skip_bond;\n            for (let i = 0; i < adj2.length - 1; i++)\n                if (adj2[i] != bto)\n                    for (let j = i + 1; j < adj2.length; j++)\n                        if (adj2[j] != bto)\n                            if (this.priority[adj2[i] - 1] == this.priority[adj2[j] - 1])\n                                continue skip_bond;\n            if (mol.bondType(n) == _Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_UNKNOWN) {\n                this.cistransBond[n - 1] = Stereochemistry.STEREO_UNKNOWN;\n                continue;\n            }\n            let rubric = Stereochemistry.rubricBondSides(mol, n);\n            if (rubric == null)\n                continue;\n            let pf1 = rubric[0] == 0 ? 0 : this.priority[rubric[0] - 1];\n            let pf2 = rubric[1] == 0 ? 0 : this.priority[rubric[1] - 1];\n            let pt1 = rubric[2] == 0 ? 0 : this.priority[rubric[2] - 1];\n            let pt2 = rubric[3] == 0 ? 0 : this.priority[rubric[3] - 1];\n            this.cistransBond[n - 1] = ((pf1 < pf2) == (pt1 < pt2)) ? Stereochemistry.STEREO_POS : Stereochemistry.STEREO_NEG;\n        }\n    }\n    buildPlanarCisTrans() {\n        const mol = this.mol, na = mol.numAtoms, nb = mol.numBonds;\n        skip_atom: for (let n = 1; n <= na; n++) {\n            this.squarePlanar[n - 1] = Stereochemistry.STEREO_NONE;\n            if (mol.atomAdjCount(n) != 4)\n                continue;\n            if (_Chemistry__WEBPACK_IMPORTED_MODULE_3__.Chemistry.ELEMENT_BLOCKS[mol.atomicNumber(n)] < 3)\n                continue;\n            let adj = mol.atomAdjList(n);\n            for (let i = 0; i < adj.length; i++) {\n                let count = 0;\n                for (let j = 0; j < adj.length; j++) {\n                    if (this.priority[adj[i] - 1] == this.priority[adj[j] - 1])\n                        count++;\n                }\n                if (count >= 3)\n                    continue skip_atom;\n            }\n            let rubric = Stereochemistry.rubricSquarePlanar(mol, n);\n            if (rubric == null)\n                continue;\n            let pri = [\n                rubric[0] == 0 ? 0 : this.priority[rubric[0] - 1],\n                rubric[1] == 0 ? 0 : this.priority[rubric[1] - 1],\n                rubric[2] == 0 ? 0 : this.priority[rubric[2] - 1],\n                rubric[3] == 0 ? 0 : this.priority[rubric[3] - 1]\n            ];\n            let parity = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Permutation.parityOrder(pri);\n            this.squarePlanar[n - 1] = (parity & 1) == 0 ? Stereochemistry.STEREO_POS : Stereochemistry.STEREO_NEG;\n        }\n    }\n    buildOctaChirality() {\n    }\n    buildPriority() {\n        const mol = this.mol, na = mol.numAtoms, nb = mol.numBonds;\n        let cipgr = [];\n        for (let n = 0; n < na; n++)\n            cipgr.push(_util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.numberArray(-1, mol.atomHydrogens(n + 1)));\n        for (let n = 1; n <= nb; n++) {\n            let bf = mol.bondFrom(n) - 1, bt = mol.bondTo(n) - 1, bo = mol.bondOrder(n);\n            if (this.meta.isBondAromatic(n))\n                bo = 2;\n            if (bf != bt)\n                for (let i = 0; i < bo; i++) {\n                    cipgr[bf].push(bt);\n                    cipgr[bt].push(bf);\n                }\n        }\n        this.priority = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.numberArray(0, na);\n        let anyActualH = false;\n        for (let n = 0; n < na; n++) {\n            this.priority[n] = mol.atomicNumber(n + 1);\n            if (this.priority[n] == 1)\n                anyActualH = true;\n        }\n        let prigr = [];\n        for (let n = 0; n < na; n++)\n            prigr.push([]);\n        while (true) {\n            for (let n = 0; n < na; n++) {\n                let cip = cipgr[n], pri = [];\n                for (let i = 0; i < cip.length; i++)\n                    pri.push(cip[i] < 0 ? 1 : this.priority[cip[i]]);\n                _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.sort(pri);\n                prigr[n] = pri;\n            }\n            let groups = this.sortAndGroup(this.priority);\n            let nextpri = anyActualH ? 0 : 1;\n            let repartitioned = false;\n            for (let n = 0; n < groups.length; n++) {\n                let g = groups[n];\n                for (let p = 0; p < g.length - 1;) {\n                    const i1 = g[p], i2 = g[p + 1];\n                    let cmp = 0, sz = Math.max(prigr[i1].length, prigr[i2].length);\n                    for (let i = 0; i < sz; i++) {\n                        let v1 = i < prigr[i1].length ? prigr[i1][i] : 0, v2 = i < prigr[i2].length ? prigr[i2][i] : 0;\n                        if (v1 < v2) {\n                            cmp = -1;\n                            break;\n                        }\n                        if (v1 > v2) {\n                            cmp = 1;\n                            break;\n                        }\n                    }\n                    if (cmp > 0) {\n                        g[p] = i2;\n                        g[p + 1] = i1;\n                        if (p > 0)\n                            p--;\n                    }\n                    else\n                        p++;\n                }\n                for (let i = 0; i < g.length; i++) {\n                    if (i == 0)\n                        nextpri++;\n                    else if (prigr[g[i]].length != prigr[g[i - 1]].length) {\n                        nextpri++;\n                        repartitioned = true;\n                    }\n                    else {\n                        for (let j = 0; j < prigr[g[i]].length; j++)\n                            if (prigr[g[i]][j] != prigr[g[i - 1]][j]) {\n                                nextpri++;\n                                repartitioned = true;\n                                break;\n                            }\n                    }\n                    this.priority[g[i]] = nextpri;\n                }\n            }\n            if (!repartitioned)\n                break;\n        }\n    }\n    sortAndGroup(val) {\n        let uset = new Set();\n        for (let v of val)\n            uset.add(v);\n        let unique = Array.from(uset);\n        _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.sort(unique);\n        let ret = [];\n        for (let n = 0; n < unique.length; n++)\n            ret.push([]);\n        for (let n = 0; n < val.length; n++) {\n            let grp = unique.indexOf(val[n]);\n            ret[grp].push(n);\n        }\n        return ret;\n    }\n}\nStereochemistry.STEREO_NONE = 0;\nStereochemistry.STEREO_POS = 1;\nStereochemistry.STEREO_NEG = 2;\nStereochemistry.STEREO_UNKNOWN = 3;\nStereochemistry.STEREO_BROKEN = 4;\nStereochemistry.RUBRIC_EQUIV_TETRA = [\n    [0, 1, 2, 3], [0, 2, 3, 1], [0, 3, 1, 2], [1, 0, 3, 2], [1, 2, 0, 3], [1, 3, 2, 0],\n    [2, 0, 1, 3], [2, 1, 3, 0], [2, 3, 0, 1], [3, 0, 2, 1], [3, 1, 0, 2], [3, 2, 1, 0]\n];\nStereochemistry.RUBRIC_EQUIV_SIDES = [\n    [0, 1, 2, 3], [1, 0, 3, 2], [2, 3, 0, 1], [3, 2, 1, 0]\n];\nStereochemistry.RUBRIC_EQUIV_SQUARE = [\n    [0, 1, 2, 3], [0, 3, 2, 1], [1, 2, 3, 0], [1, 0, 3, 2],\n    [2, 1, 0, 3], [2, 3, 0, 1], [3, 2, 1, 0], [3, 0, 1, 2]\n];\nStereochemistry.RUBRIC_EQUIV_BIPY = [\n    [0, 1, 2, 3, 4], [1, 2, 0, 3, 4], [2, 0, 1, 3, 4],\n    [0, 2, 1, 4, 3], [1, 0, 2, 4, 3], [2, 1, 0, 4, 3],\n];\nStereochemistry.RUBRIC_EQUIV_OCTA = [\n    [0, 1, 2, 3, 4, 5], [0, 3, 2, 1, 5, 4], [0, 4, 2, 5, 3, 1], [0, 5, 2, 4, 1, 3],\n    [1, 0, 3, 2, 5, 4], [1, 2, 3, 0, 4, 5], [1, 4, 3, 5, 0, 2], [1, 5, 3, 4, 2, 0],\n    [2, 1, 0, 3, 5, 4], [2, 3, 0, 1, 4, 5], [2, 4, 0, 5, 1, 3], [2, 5, 0, 4, 3, 1],\n    [3, 0, 1, 2, 4, 5], [3, 2, 1, 0, 5, 4], [3, 4, 1, 5, 2, 0], [3, 5, 1, 4, 0, 2],\n    [4, 0, 5, 2, 1, 3], [4, 1, 5, 3, 2, 0], [4, 2, 5, 0, 3, 1], [4, 3, 5, 1, 0, 2],\n    [5, 0, 4, 2, 3, 1], [5, 1, 4, 3, 0, 2], [5, 2, 4, 0, 1, 3], [5, 3, 4, 1, 2, 0]\n];\n\n\n//# sourceURL=webpack://WebMolKit/./src/data/Stereochemistry.ts?");

/***/ }),

/***/ "./src/dialog/Dialog.ts":
/*!******************************!*\
  !*** ./src/dialog/Dialog.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Dialog\": () => (/* binding */ Dialog)\n/* harmony export */ });\n/* harmony import */ var _util_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/dom */ \"./src/util/dom.ts\");\n/* harmony import */ var _util_Theme__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Theme */ \"./src/util/Theme.ts\");\n\n\nconst CSS_DIALOG = `\n    *.wmk-dialog\n    {\n        font-family: 'Open Sans', sans-serif;\n\t\tfont-size: 16px;\n\t\tcolor: black;\n\t\tuser-select: none;\n    }\n`;\nclass Dialog {\n    constructor(parent = null) {\n        this.minPortionWidth = 80;\n        this.maxPortionWidth = 80;\n        this.maximumWidth = 0;\n        this.maximumHeight = 0;\n        this.minPortionHeight = 20;\n        this.maxPortionHeight = 0;\n        this.topMargin = 50;\n        this.title = 'Dialog';\n        this.allowScroller = true;\n        this.callbackClose = null;\n        this.callbackShown = null;\n        this.parent = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.domLegacy)(parent);\n        (0,_util_Theme__WEBPACK_IMPORTED_MODULE_1__.installInlineCSS)('dialog', CSS_DIALOG);\n    }\n    onClose(callback) {\n        this.callbackClose = callback;\n    }\n    onShown(callback) {\n        this.callbackShown = callback;\n    }\n    open() {\n        let body = this.parent || (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)(document.body);\n        let zindex = 20000;\n        let bg = this.domObscureBackground = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<div/>').appendTo(body);\n        bg.css({ 'position': 'fixed', 'z-index': zindex });\n        bg.css({ 'left': '0', 'right': '0', 'top': '0', 'bottom': '0' });\n        bg.css({ 'background-color': 'black', 'opacity': 0.8 });\n        bg.onClick(() => this.close());\n        let fg = this.domObscureForeground = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<div/>').appendTo(body);\n        fg.css({ 'position': 'fixed', 'z-index': zindex + 1 });\n        fg.css({ 'left': '0', 'right': '0', 'top': '0', 'bottom': '0' });\n        let pb = this.domPanelBoundary = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<div class=\"wmk-dialog\"/>').appendTo(fg);\n        pb.css({ 'min-width': this.minPortionWidth + '%' });\n        if (this.maximumWidth > 0)\n            pb.css({ 'max-width': this.maximumWidth + 'px' });\n        else if (this.maxPortionWidth != null)\n            pb.css({ 'max-width': this.maxPortionWidth + '%' });\n        if (this.maximumHeight > 0)\n            pb.css({ 'max-height': this.maximumHeight + 'px' });\n        else if (this.maxPortionHeight > 0)\n            pb.css({ 'max-height': this.maxPortionHeight + 'vh' });\n        pb.css({ 'background-color': 'white', 'border-radius': '6px', 'border': '1px solid black' });\n        pb.css({ 'position': 'absolute' });\n        pb.css({ 'left': (50 - 0.5 * this.minPortionWidth) + '%' });\n        pb.css({ 'top': this.topMargin + 'px' });\n        pb.css({ 'min-height': this.minPortionHeight + '%' });\n        let divOuter = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<div/>').appendTo(pb).css({ 'display': 'flex' });\n        divOuter.css({ 'flex-direction': 'column', 'align-items': 'stretch' });\n        if (this.maximumHeight > 0)\n            divOuter.css({ 'max-height': this.maximumHeight + 'px' });\n        else if (this.maxPortionHeight > 0)\n            divOuter.css({ 'max-height': this.maxPortionHeight + 'vh' });\n        let tdiv = this.domTitle = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<div/>').appendTo(divOuter);\n        tdiv.css({ 'flex-shrink': '0', 'flex-grow': '0' });\n        tdiv.css({ 'margin': '0', 'padding': '0' });\n        tdiv.css({ 'background-color': '#F0F0F0' });\n        tdiv.css({ 'background-image': 'linear-gradient(to right bottom, #FFFFFF, #E0E0E0)' });\n        tdiv.css({ 'border-bottom': '1px solid #C0C0C0' });\n        tdiv.css({ 'border-radius': '6px 6px 0 0' });\n        let bdiv = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<div/>').appendTo(divOuter).css({ 'width': '100%' });\n        bdiv.css({ 'flex-shrink': '1', 'flex-grow': '0' });\n        if (this.allowScroller)\n            bdiv.css({ 'overflow-y': 'auto' });\n        this.domBody = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<div/>').appendTo(bdiv).css({ 'padding': '0.5em' });\n        let ttlTable = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<table/>').appendTo(tdiv), tr = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<tr/>').appendTo(ttlTable);\n        ttlTable.attr({ 'width': '100%' });\n        let tdTitle = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<td valign=\"center\"/>').appendTo(tr).css({ 'padding': '0.5em' });\n        let ttl = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<font/>').appendTo(tdTitle).css({ 'font-size': '1.5em', 'font-weight': '600' });\n        ttl.setText(this.title);\n        let tdButtons = this.domTitleButtons = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<td align=\"right\" valign=\"center\"/>').appendTo(tr).css({ 'padding': '0.5em' });\n        this.domClose = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<button class=\"wmk-button wmk-button-default\">Close</button>').appendTo(tdButtons);\n        this.domClose.onClick(() => this.close());\n        this.populate();\n        this.repositionSize();\n        if (this.callbackShown)\n            this.callbackShown(this);\n    }\n    close() {\n        this.domObscureBackground.remove();\n        this.domObscureForeground.remove();\n        if (this.callbackClose)\n            this.callbackClose(this);\n    }\n    bump() {\n        this.repositionSize();\n    }\n    bodyDOM() { return this.domBody; }\n    buttonsDOM() { return this.domTitleButtons; }\n    populate() {\n        this.bodyDOM().setText('Empty dialog box.');\n    }\n    repositionSize() {\n        let docW = window.innerWidth, dlgW = this.domPanelBoundary.width();\n        this.domPanelBoundary.css({ 'left': (0.5 * (docW - dlgW)) + 'px' });\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/dialog/Dialog.ts?");

/***/ }),

/***/ "./src/dialog/EditCompound.ts":
/*!************************************!*\
  !*** ./src/dialog/EditCompound.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EditCompound\": () => (/* binding */ EditCompound)\n/* harmony export */ });\n/* harmony import */ var _sketcher_Sketcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sketcher/Sketcher */ \"./src/sketcher/Sketcher.ts\");\n/* harmony import */ var _ui_ClipboardProxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ui/ClipboardProxy */ \"./src/ui/ClipboardProxy.ts\");\n/* harmony import */ var _util_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/dom */ \"./src/util/dom.ts\");\n/* harmony import */ var _Dialog__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Dialog */ \"./src/dialog/Dialog.ts\");\n\n\n\n\nclass EditCompound extends _Dialog__WEBPACK_IMPORTED_MODULE_3__.Dialog {\n    constructor(mol, parent = null) {\n        super(parent);\n        this.mol = mol;\n        this.sketcher = new _sketcher_Sketcher__WEBPACK_IMPORTED_MODULE_0__.Sketcher();\n        this.proxyClip = null;\n        this.proxyMenu = null;\n        this.callbackSave = null;\n        this.title = 'Edit Compound';\n        this.minPortionWidth = 20;\n        this.maxPortionWidth = 95;\n    }\n    onSave(callback) {\n        this.callbackSave = callback;\n    }\n    getMolecule() { return this.sketcher.getMolecule(); }\n    getSketcher() { return this.sketcher; }\n    defineClipboard(proxy) {\n        this.proxyClip = proxy;\n        let handler = new _ui_ClipboardProxy__WEBPACK_IMPORTED_MODULE_1__.ClipboardProxyHandler();\n        handler.copyEvent = (andCut, proxy) => {\n            this.sketcher.performCopySelection(andCut);\n            return true;\n        };\n        handler.pasteEvent = (proxy) => {\n            this.sketcher.pasteText(proxy.getString());\n            return true;\n        };\n        proxy.pushHandler(handler);\n        this.sketcher.defineClipboard(proxy);\n    }\n    defineContext(proxy) {\n        this.proxyMenu = proxy;\n        this.sketcher.defineContext(this.proxyMenu);\n    }\n    close() {\n        if (this.proxyClip)\n            this.proxyClip.popHandler();\n        super.close();\n    }\n    populate() {\n        let buttons = this.buttonsDOM(), body = this.bodyDOM();\n        this.btnClear = (0,_util_dom__WEBPACK_IMPORTED_MODULE_2__.dom)('<button class=\"wmk-button wmk-button-default\">Clear</button>').appendTo(buttons).css({ 'margin-left': '0.5em' });\n        this.btnClear.onClick(() => this.sketcher.clearMolecule());\n        this.btnCopy = (0,_util_dom__WEBPACK_IMPORTED_MODULE_2__.dom)('<button class=\"wmk-button wmk-button-default\">Copy</button>').appendTo(buttons).css({ 'margin-left': '0.5em' });\n        this.btnCopy.onClick(() => this.actionCopy());\n        buttons.append(this.domClose);\n        this.domClose.css({ 'margin-left': '0.5em' });\n        this.btnSave = (0,_util_dom__WEBPACK_IMPORTED_MODULE_2__.dom)('<button class=\"wmk-button wmk-button-primary\">Save</button>').appendTo(buttons).css({ 'margin-left': '0.5em' });\n        this.btnSave.onClick(() => { if (this.callbackSave)\n            this.callbackSave(this); });\n        let skw = 800, skh = 650;\n        let skdiv = (0,_util_dom__WEBPACK_IMPORTED_MODULE_2__.dom)('<div/>').appendTo(body).css({ 'width': `${skw}px`, 'height': `${skh}px` });\n        this.sketcher.setSize(skw, skh);\n        this.sketcher.defineMolecule(this.mol);\n        this.sketcher.setup(() => this.sketcher.render(skdiv));\n    }\n    actionCopy() {\n        this.sketcher.performCopySelection(false);\n    }\n    actionCut() {\n        this.sketcher.performCopySelection(true);\n    }\n    actionPaste() {\n        this.sketcher.performPaste();\n    }\n    actionUndo() {\n        this.sketcher.performUndo();\n    }\n    actionRedo() {\n        this.sketcher.performRedo();\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/dialog/EditCompound.ts?");

/***/ }),

/***/ "./src/gfx/ArrangeExperiment.ts":
/*!**************************************!*\
  !*** ./src/gfx/ArrangeExperiment.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ArrangeComponent\": () => (/* binding */ ArrangeComponent),\n/* harmony export */   \"ArrangeComponentAnnot\": () => (/* binding */ ArrangeComponentAnnot),\n/* harmony export */   \"ArrangeComponentType\": () => (/* binding */ ArrangeComponentType),\n/* harmony export */   \"ArrangeExperiment\": () => (/* binding */ ArrangeExperiment)\n/* harmony export */ });\n/* harmony import */ var _aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../aspect/Experiment */ \"./src/aspect/Experiment.ts\");\n/* harmony import */ var _data_ExperimentMeta__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/ExperimentMeta */ \"./src/data/ExperimentMeta.ts\");\n/* harmony import */ var _data_MolUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data/MolUtil */ \"./src/data/MolUtil.ts\");\n/* harmony import */ var _data_QuantityCalc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../data/QuantityCalc */ \"./src/data/QuantityCalc.ts\");\n/* harmony import */ var _util_Geom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Geom */ \"./src/util/Geom.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _ArrangeMolecule__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ArrangeMolecule */ \"./src/gfx/ArrangeMolecule.ts\");\n/* harmony import */ var _FontData__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./FontData */ \"./src/gfx/FontData.ts\");\n\n\n\n\n\n\n\n\n\nvar ArrangeComponentType;\n(function (ArrangeComponentType) {\n    ArrangeComponentType[ArrangeComponentType[\"Arrow\"] = 1] = \"Arrow\";\n    ArrangeComponentType[ArrangeComponentType[\"Plus\"] = 2] = \"Plus\";\n    ArrangeComponentType[ArrangeComponentType[\"Reactant\"] = 3] = \"Reactant\";\n    ArrangeComponentType[ArrangeComponentType[\"Reagent\"] = 4] = \"Reagent\";\n    ArrangeComponentType[ArrangeComponentType[\"Product\"] = 5] = \"Product\";\n    ArrangeComponentType[ArrangeComponentType[\"StepNote\"] = 6] = \"StepNote\";\n})(ArrangeComponentType || (ArrangeComponentType = {}));\nvar ArrangeComponentAnnot;\n(function (ArrangeComponentAnnot) {\n    ArrangeComponentAnnot[ArrangeComponentAnnot[\"None\"] = 0] = \"None\";\n    ArrangeComponentAnnot[ArrangeComponentAnnot[\"Primary\"] = 1] = \"Primary\";\n    ArrangeComponentAnnot[ArrangeComponentAnnot[\"Waste\"] = 2] = \"Waste\";\n    ArrangeComponentAnnot[ArrangeComponentAnnot[\"Implied\"] = 3] = \"Implied\";\n})(ArrangeComponentAnnot || (ArrangeComponentAnnot = {}));\nclass ArrangeComponent {\n    constructor() {\n        this.annot = ArrangeComponentAnnot.None;\n        this.box = new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Box();\n    }\n    clone() {\n        let dup = new ArrangeComponent();\n        dup.type = this.type;\n        dup.srcIdx = this.srcIdx;\n        dup.step = this.step;\n        dup.side = this.side;\n        dup.refIdx = this.refIdx;\n        dup.mol = this.mol;\n        dup.text = this.text;\n        dup.leftNumer = this.leftNumer;\n        dup.leftDenom = this.leftDenom;\n        dup.fszText = this.fszText;\n        dup.fszLeft = this.fszLeft;\n        dup.annot = this.annot;\n        dup.box = this.box.clone();\n        dup.padding = this.padding;\n        return dup;\n    }\n}\nconst PADDING = 0.25;\nconst PLUSSZ = 0.5;\nconst ARROW_W = 2;\nconst ARROW_H = 0.5;\nconst REAGENT_SCALE = 0.7;\nconst PLACEHOLDER_W = 2;\nconst PLACEHOLDER_H = 2;\nclass ArrangeExperiment {\n    constructor(entry, measure, policy) {\n        this.entry = entry;\n        this.measure = measure;\n        this.policy = policy;\n        this.width = 0;\n        this.height = 0;\n        this.components = [];\n        this.limitTotalW = 1000;\n        this.limitTotalH = 1000;\n        this.limitStructW = 0;\n        this.limitStructH = 0;\n        this.includeReagents = true;\n        this.includeNames = false;\n        this.includeStoich = true;\n        this.includeAnnot = false;\n        this.includeBlank = false;\n        this.includeDetails = false;\n        this.includeAtomMap = false;\n        this.colourAtomMap = 0x9D1A76;\n        this.allowVertical = true;\n        this.padding = 0;\n        this.scale = policy.data.pointScale;\n        this.limitStructW = this.limitStructH = this.scale * 10;\n        this.padding = PADDING * this.scale;\n    }\n    arrange() {\n        this.createComponents();\n        let fszText = this.scale * this.policy.data.fontSize, fszLeft = this.scale * this.policy.data.fontSize * 1.5;\n        for (let xc of this.components) {\n            if (xc.type == ArrangeComponentType.Plus)\n                xc.box = new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Box(0, 0, this.scale * PLUSSZ, this.scale * PLUSSZ);\n            else if (xc.type == ArrangeComponentType.Arrow) { }\n            else {\n                let w = 0, h = 0;\n                if (_data_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.notBlank(xc.mol)) {\n                    let sz = _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Size.fromArray(_ArrangeMolecule__WEBPACK_IMPORTED_MODULE_7__.ArrangeMolecule.guestimateSize(xc.mol, this.policy));\n                    if (xc.type == ArrangeComponentType.Reagent)\n                        sz.scaleBy(REAGENT_SCALE);\n                    if (xc.leftNumer) {\n                        xc.fszLeft = fszLeft;\n                        let wad = this.measure.measureText(xc.leftNumer, fszLeft);\n                        let lw = wad[0], lh = wad[1] + wad[2];\n                        if (xc.leftDenom)\n                            lw = Math.max(lw, this.measure.measureText(xc.leftDenom, fszLeft)[0]);\n                        sz.w += lw + ArrangeExperiment.COMP_GAP_LEFT * lh;\n                        sz.h = Math.max(sz.h, lh * (xc.leftDenom ? 2 : 1));\n                    }\n                    sz.fitInto(this.limitStructW, this.limitStructH);\n                    w = sz.w;\n                    h = sz.h;\n                }\n                if (_util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.notBlank(xc.text)) {\n                    if (_data_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.notBlank(xc.mol))\n                        h += 0.5 * fszText;\n                    for (let line of xc.text) {\n                        xc.fszText = fszText;\n                        let wad = this.measure.measureText(line, fszText);\n                        w = Math.max(w, wad[0]);\n                        h += wad[1] + wad[2];\n                    }\n                }\n                if (xc.annot != 0)\n                    w += ArrangeExperiment.COMP_ANNOT_SIZE * this.scale;\n                if ((_data_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.isBlank(xc.mol) && !xc.text && this.includeBlank) || w == 0 || h == 0) {\n                    w = Math.max(w, PLACEHOLDER_W * this.scale);\n                    h = Math.max(h, PLACEHOLDER_H * this.scale);\n                }\n                xc.box = new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Box(0, 0, w, h);\n            }\n            xc.padding = this.padding;\n            xc.box = new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Box(0, 0, xc.box.w + 2 * this.padding, xc.box.h + 2 * this.padding);\n        }\n        if (this.allowVertical) {\n            let best = null;\n            let bestScore = 0;\n            for (let bend = this.entry.steps.length + 1; bend >= 1; bend--)\n                for (let vert = 0; vert <= 1; vert++) {\n                    let trial = [];\n                    for (let xc of this.components)\n                        trial.push(xc.clone());\n                    this.arrangeComponents(trial, bend, vert > 0);\n                    let score = this.scoreArrangement(trial);\n                    if (best == null || score > bestScore) {\n                        best = trial;\n                        bestScore = score;\n                    }\n                }\n            this.components = best;\n        }\n        else {\n            this.arrangeComponents(this.components, this.entry.steps.length + 1, false);\n        }\n        this.width = this.height = 0;\n        for (let xc of this.components) {\n            this.width = Math.max(this.width, xc.box.maxX());\n            this.height = Math.max(this.height, xc.box.maxY());\n        }\n    }\n    get numComponents() { return this.components.length; }\n    getComponent(idx) { return this.components[idx]; }\n    getComponents() { return this.components; }\n    scaleComponents(modScale) {\n        if (modScale == 1)\n            return;\n        this.scale *= modScale;\n        this.width *= modScale;\n        this.height *= modScale;\n        for (let xc of this.components) {\n            xc.box.scaleBy(modScale);\n            xc.fszText *= modScale;\n            xc.fszLeft *= modScale;\n            xc.padding *= modScale;\n        }\n    }\n    static toExpType(compType) {\n        if (compType == ArrangeComponentType.Reactant)\n            return _aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__.ExperimentComponentType.Reactant;\n        if (compType == ArrangeComponentType.Reagent)\n            return _aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__.ExperimentComponentType.Reagent;\n        if (compType == ArrangeComponentType.Product)\n            return _aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__.ExperimentComponentType.Product;\n        return null;\n    }\n    createComponents() {\n        for (let n = 0; n < this.entry.steps[0].reactants.length; n++) {\n            if (n > 0)\n                this.createSegregator(ArrangeComponentType.Plus, 0, -1);\n            this.createReactant(n, 0);\n        }\n        if (this.components.length == 0 && this.includeBlank)\n            this.createBlank(ArrangeComponentType.Reactant, 0);\n        for (let s = 0; s < this.entry.steps.length; s++) {\n            this.createSegregator(ArrangeComponentType.Arrow, s, 0);\n            if (this.includeReagents) {\n                let any = false;\n                for (let n = 0; n < this.entry.steps[s].reagents.length; n++) {\n                    this.createReagent(n, s);\n                    any = true;\n                }\n                if (!any && this.includeBlank)\n                    this.createBlank(ArrangeComponentType.Reagent, s);\n            }\n            if (this.includeDetails)\n                this.createStepMeta(s);\n            let any = false;\n            for (let n = 0; n < this.entry.steps[s].products.length; n++) {\n                if (n > 0)\n                    this.createSegregator(ArrangeComponentType.Plus, s, 1);\n                this.createProduct(n, s);\n                any = true;\n            }\n            if (!any && this.includeBlank)\n                this.createBlank(ArrangeComponentType.Product, s);\n        }\n    }\n    createReactant(idx, step) {\n        let comp = this.entry.steps[step].reactants[idx];\n        let xc = new ArrangeComponent();\n        xc.type = ArrangeComponentType.Reactant;\n        xc.srcIdx = idx;\n        xc.step = step;\n        xc.side = -1;\n        if (_data_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.notBlank(comp.mol))\n            xc.mol = comp.mol;\n        if (comp.name && (this.includeNames || _data_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.isBlank(comp.mol)))\n            xc.text = this.wordWrapName(comp.name, xc.mol);\n        if (this.includeDetails)\n            this.supplementText(xc, comp);\n        if (_data_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.notBlank(comp.mol) && this.includeStoich && !_data_QuantityCalc__WEBPACK_IMPORTED_MODULE_3__.QuantityCalc.isStoichZero(comp.stoich) && !_data_QuantityCalc__WEBPACK_IMPORTED_MODULE_3__.QuantityCalc.isStoichUnity(comp.stoich)) {\n            let slash = comp.stoich.indexOf('/');\n            if (slash >= 0) {\n                xc.leftNumer = comp.stoich.substring(0, slash);\n                xc.leftDenom = comp.stoich.substring(slash + 1);\n            }\n            else\n                xc.leftNumer = comp.stoich;\n        }\n        if (this.includeAnnot && _data_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.notBlank(comp.mol) && comp.primary)\n            xc.annot = ArrangeComponentAnnot.Primary;\n        this.components.push(xc);\n    }\n    createReagent(idx, step) {\n        let comp = this.entry.steps[step].reagents[idx];\n        let xc = new ArrangeComponent();\n        xc.type = ArrangeComponentType.Reagent;\n        xc.srcIdx = idx;\n        xc.step = step;\n        xc.side = 0;\n        if (_data_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.notBlank(comp.mol))\n            xc.mol = comp.mol;\n        if (comp.name && (this.includeNames || _data_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.isBlank(comp.mol)))\n            xc.text = this.wordWrapName(comp.name, xc.mol);\n        if (this.includeDetails)\n            this.supplementText(xc, comp);\n        if (this.includeAnnot) {\n            let stoich = _data_QuantityCalc__WEBPACK_IMPORTED_MODULE_3__.QuantityCalc.impliedReagentStoich(comp, this.entry.steps[step].products);\n            if (stoich > 0)\n                xc.annot = ArrangeComponentAnnot.Implied;\n            if (stoich > 0 && stoich != 1) {\n                if ((0,_util_util__WEBPACK_IMPORTED_MODULE_5__.realEqual)(stoich, Math.round(stoich)))\n                    xc.leftNumer = Math.round(stoich).toString();\n                else\n                    xc.leftNumer = stoich.toString();\n            }\n        }\n        this.components.push(xc);\n    }\n    createProduct(idx, step) {\n        let comp = this.entry.steps[step].products[idx];\n        let xc = new ArrangeComponent();\n        xc.type = ArrangeComponentType.Product;\n        xc.srcIdx = idx;\n        xc.step = step;\n        xc.side = 1;\n        if (_data_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.notBlank(comp.mol))\n            xc.mol = comp.mol;\n        if (comp.name && (this.includeNames || _data_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.isBlank(comp.mol)))\n            xc.text = this.wordWrapName(comp.name, xc.mol);\n        if (this.includeDetails)\n            this.supplementText(xc, comp);\n        if (this.includeStoich && !_data_QuantityCalc__WEBPACK_IMPORTED_MODULE_3__.QuantityCalc.isStoichZero(comp.stoich) && !_data_QuantityCalc__WEBPACK_IMPORTED_MODULE_3__.QuantityCalc.isStoichUnity(comp.stoich)) {\n            let slash = comp.stoich.indexOf('/');\n            if (slash >= 0) {\n                xc.leftNumer = comp.stoich.substring(0, slash);\n                xc.leftDenom = comp.stoich.substring(slash + 1);\n            }\n            else\n                xc.leftNumer = comp.stoich;\n        }\n        if (this.includeAnnot && _data_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.notBlank(comp.mol) && comp.waste)\n            xc.annot = ArrangeComponentAnnot.Waste;\n        this.components.push(xc);\n    }\n    createSegregator(type, step, side) {\n        let xc = new ArrangeComponent();\n        xc.type = type;\n        xc.step = step;\n        xc.side = side;\n        this.components.push(xc);\n    }\n    createStepMeta(step) {\n        let lines = [];\n        for (let [type, value] of _data_ExperimentMeta__WEBPACK_IMPORTED_MODULE_1__.ExperimentMeta.unpackMeta(this.entry.steps[step].meta)) {\n            if (!_util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.safeArray(_data_ExperimentMeta__WEBPACK_IMPORTED_MODULE_1__.ExperimentMeta.APPLICABILITY[type]).includes(_data_ExperimentMeta__WEBPACK_IMPORTED_MODULE_1__.ExperimentMetaApplic.Step))\n                continue;\n            let descr = _data_ExperimentMeta__WEBPACK_IMPORTED_MODULE_1__.ExperimentMeta.describeMeta(type, value);\n            if (descr != null)\n                lines.push(descr);\n        }\n        if (lines.length == 0)\n            return;\n        let xc = new ArrangeComponent();\n        xc.type = ArrangeComponentType.StepNote;\n        xc.step = step;\n        xc.side = 0;\n        xc.text = lines;\n        this.components.push(xc);\n    }\n    createBlank(type, step) {\n        let xc = new ArrangeComponent();\n        xc.type = type;\n        xc.step = step;\n        xc.side = type == ArrangeComponentType.Reactant ? -1 : type == ArrangeComponentType.Product ? 1 : 0;\n        xc.srcIdx = -1;\n        this.components.push(xc);\n    }\n    arrangeComponents(comps, bendStep, vertComp) {\n        let blkMain = [];\n        let blkArrow = [];\n        let szMain = [], szArrow = [];\n        let midMain = [], midArrow = [];\n        blkMain.push(this.gatherBlock(comps, 0, -1));\n        szMain.push(this.arrangeMainBlock(blkMain[0], vertComp));\n        midMain.push(this.findMidBlock(blkMain[0], szMain[0]));\n        for (let n = 0; n < this.entry.steps.length; n++) {\n            let bent = n + 1 >= bendStep;\n            blkMain.push(this.gatherBlock(comps, n, 1));\n            szMain.push(this.arrangeMainBlock(blkMain[n + 1], vertComp && !bent));\n            midMain.push(this.findMidBlock(blkMain[n + 1], szMain[n + 1]));\n            blkArrow.push(this.gatherBlock(comps, n, 0));\n            if (!bent)\n                szArrow.push(this.arrangeHorizontalArrowBlock(blkArrow[n]));\n            else\n                szArrow.push(this.arrangeVerticalArrowBlock(blkArrow[n]));\n            midArrow.push(this.findMidBlock(blkArrow[n], szArrow[n]));\n        }\n        let midH = 0;\n        for (let n = 0; n < bendStep; n++) {\n            midH = Math.max(midH, midMain[n].y);\n            if (n > 0)\n                midH = Math.max(midH, midArrow[n - 1].y);\n        }\n        let sz = _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Size.zero();\n        for (let n = 0; n < bendStep; n++) {\n            sz.w += szMain[n].w;\n            sz.h = Math.max(sz.h, midH + (szMain[n].h - midMain[n].y));\n            if (n > 0) {\n                sz.w += szArrow[n - 1].w;\n                sz.h = Math.max(sz.h, midH + (szArrow[n - 1].h - midArrow[n - 1].y));\n            }\n        }\n        let x = 0, arrowX = 0;\n        for (let n = 0; n < bendStep; n++) {\n            if (n > 0) {\n                this.originateBlock(blkArrow[n - 1], x, midH - midArrow[n - 1].y);\n                x += szArrow[n - 1].w;\n            }\n            this.originateBlock(blkMain[n], x, midH - midMain[n].y);\n            arrowX = x + midMain[n].x;\n            x += szMain[n].w;\n        }\n        let y = sz.h, lowX = 0;\n        for (let n = bendStep; n <= this.entry.steps.length; n++) {\n            x = arrowX - midArrow[n - 1].x;\n            lowX = Math.min(lowX, x);\n            this.originateBlock(blkArrow[n - 1], x, y);\n            y += szArrow[n - 1].h;\n            sz.w = Math.max(sz.w, x + szArrow[n - 1].w);\n            x = arrowX - midMain[n].x;\n            lowX = Math.min(lowX, x);\n            this.originateBlock(blkMain[n], x, y);\n            y += szMain[n].h;\n            sz.w = Math.max(sz.w, x + szMain[n].w);\n        }\n        if (lowX < 0) {\n            for (let xc of comps)\n                xc.box.x -= lowX;\n        }\n    }\n    gatherBlock(comps, step, side) {\n        let block = [];\n        for (let xc of comps)\n            if (xc.side == side && xc.step == step)\n                block.push(xc);\n        return block;\n    }\n    arrangeMainBlock(block, vertComp) {\n        let sz = _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Size.zero();\n        if (!vertComp) {\n            for (let xc of block) {\n                sz.w += xc.box.w;\n                sz.h = Math.max(sz.h, xc.box.h);\n            }\n        }\n        else {\n            for (let xc of block) {\n                sz.w = Math.max(sz.w, xc.box.w);\n                sz.h += xc.box.h;\n            }\n        }\n        sz.w = Math.max(sz.w, this.scale * 2.0);\n        sz.h = Math.max(sz.h, this.scale * 2.0);\n        if (!vertComp) {\n            let x = 0;\n            for (let xc of block) {\n                xc.box.x = x;\n                xc.box.y = 0.5 * (sz.h - xc.box.h);\n                x += xc.box.w;\n            }\n        }\n        else {\n            let y = 0;\n            for (let xc of block) {\n                xc.box.x = 0.5 * (sz.w - xc.box.w);\n                xc.box.y = y;\n                y += xc.box.h;\n            }\n        }\n        return sz;\n    }\n    arrangeHorizontalArrowBlock(block) {\n        let arrow = null;\n        for (let xc of block)\n            if (xc.type == ArrangeComponentType.Arrow) {\n                arrow = xc;\n                xc.box.w = ARROW_W * this.scale + 2 * xc.padding;\n                xc.box.h = ARROW_H * this.scale + 2 * xc.padding;\n            }\n        let mid = block.length >> 1;\n        for (let xc of block)\n            arrow.box.w = Math.max(xc.box.w, arrow.box.w);\n        let sz = _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Size.zero();\n        let n = 0;\n        let y = 0;\n        let arrowPlaced = false;\n        for (let xc of block)\n            if (xc.type != ArrangeComponentType.Arrow) {\n                xc.box.x = 0.5 * (arrow.box.w - xc.box.w);\n                xc.box.y = y;\n                y += xc.box.h;\n                n++;\n                if (n == mid) {\n                    arrow.box.x = 0;\n                    arrow.box.y = y;\n                    y += arrow.box.h;\n                    arrowPlaced = true;\n                }\n            }\n        if (!arrowPlaced) {\n            arrow.box.x = 0;\n            arrow.box.y = y;\n            y += arrow.box.h;\n        }\n        sz.w = arrow.box.w;\n        sz.h = y;\n        return sz;\n    }\n    arrangeVerticalArrowBlock(block) {\n        let arrow = null;\n        for (let xc of block)\n            if (xc.type == ArrangeComponentType.Arrow) {\n                arrow = xc;\n                xc.box.w = ARROW_H * this.scale + 2 * xc.padding;\n                xc.box.h = ARROW_W * this.scale + 2 * xc.padding;\n            }\n        let mid = block.length >> 1;\n        let sz1 = _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Size.zero(), sz2 = _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Size.zero();\n        let n = 0;\n        for (let xc of block)\n            if (xc.type != ArrangeComponentType.Arrow) {\n                if (n < mid) {\n                    sz1.w = Math.max(sz1.w, xc.box.w);\n                    sz1.h += xc.box.h;\n                }\n                else {\n                    sz2.w = Math.max(sz2.w, xc.box.w);\n                    sz2.h += xc.box.h;\n                }\n                n++;\n            }\n        let sz = new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Size(sz1.w + sz2.w + arrow.box.w, Math.max(arrow.box.h, Math.max(sz1.h, sz2.h)));\n        arrow.box = new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Box(sz1.w, 0, arrow.box.w, sz.h);\n        let y1 = 0.5 * (sz.h - sz1.h), y2 = 0.5 * (sz.h - sz2.h);\n        n = 0;\n        for (let xc of block)\n            if (xc.type != ArrangeComponentType.Arrow) {\n                if (n < mid) {\n                    xc.box.x = sz1.w - xc.box.w;\n                    xc.box.y = y1;\n                    y1 += xc.box.h;\n                }\n                else {\n                    xc.box.x = sz.w - sz2.w;\n                    xc.box.y = y2;\n                    y2 += xc.box.h;\n                }\n                n++;\n            }\n        return sz;\n    }\n    findMidBlock(block, sz) {\n        let count = 0;\n        let mid = _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Pos.zero();\n        for (let xc of block)\n            if (xc.type == ArrangeComponentType.Plus || xc.type == ArrangeComponentType.Arrow) {\n                mid.x += xc.box.midX();\n                mid.y += xc.box.midY();\n                count++;\n            }\n        if (count == 0) {\n            mid.x = 0.5 * sz.w;\n            mid.y = 0.5 * sz.h;\n        }\n        else if (count > 1) {\n            let inv = 1.0 / count;\n            mid.x *= inv;\n            mid.y *= inv;\n        }\n        return mid;\n    }\n    scoreArrangement(comps) {\n        let w = 0;\n        for (let xc of comps)\n            w = Math.max(w, xc.box.maxX());\n        let score = 0;\n        score -= Math.abs(w - this.limitTotalW);\n        return score;\n    }\n    originateBlock(block, x, y) {\n        for (let xc of block) {\n            xc.box.x += x;\n            xc.box.y += y;\n        }\n    }\n    supplementText(xc, comp) {\n        if (!xc.text)\n            xc.text = [];\n        if (comp.mass > 0)\n            xc.text.push(_data_QuantityCalc__WEBPACK_IMPORTED_MODULE_3__.QuantityCalc.formatMass(comp.mass));\n        if (comp.volume > 0)\n            xc.text.push(_data_QuantityCalc__WEBPACK_IMPORTED_MODULE_3__.QuantityCalc.formatVolume(comp.volume));\n        if (comp.moles > 0)\n            xc.text.push(_data_QuantityCalc__WEBPACK_IMPORTED_MODULE_3__.QuantityCalc.formatMoles(comp.moles));\n        if (comp.conc > 0)\n            xc.text.push(_data_QuantityCalc__WEBPACK_IMPORTED_MODULE_3__.QuantityCalc.formatConc(comp.conc));\n        if (comp.yield != null && comp.yield >= 0)\n            xc.text.push(_data_QuantityCalc__WEBPACK_IMPORTED_MODULE_3__.QuantityCalc.formatPercent(comp.yield));\n        if (comp.equiv > 0)\n            xc.text.push(_data_QuantityCalc__WEBPACK_IMPORTED_MODULE_3__.QuantityCalc.formatEquiv(comp.equiv));\n        for (let [type, value] of _data_ExperimentMeta__WEBPACK_IMPORTED_MODULE_1__.ExperimentMeta.unpackMeta(comp.meta)) {\n            let descr = _data_ExperimentMeta__WEBPACK_IMPORTED_MODULE_1__.ExperimentMeta.describeMeta(type, value);\n            if (descr)\n                xc.text.push(descr);\n        }\n    }\n    wordWrapName(name, mol) {\n        let minLimW = 0;\n        if (_data_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.notBlank(mol))\n            minLimW = (mol.boundary().w + 2) * this.scale;\n        let limW = Math.max(minLimW, 10 * this.scale);\n        let fsz = this.scale * this.policy.data.fontSize;\n        let w = this.measure.measureText(name, fsz)[0];\n        if (w < limW)\n            return [name];\n        let wrap = () => {\n            let lines = [], residual = name, nclean = 0;\n            while (residual.length > 0) {\n                let wsz = _FontData__WEBPACK_IMPORTED_MODULE_8__.FontData.measureWidths(residual, fsz);\n                let pos = 0;\n                while (pos < wsz.length && wsz[pos] < limW)\n                    pos++;\n                for (let n = pos; n > 5; n--) {\n                    if (residual[n] == ' ') {\n                        pos = n;\n                        nclean++;\n                        break;\n                    }\n                    if (wsz[n] < limW * 0.8)\n                        break;\n                }\n                lines.push(residual.substring(0, pos));\n                residual = residual.substring(pos).trimLeft();\n            }\n            return [lines, nclean];\n        };\n        let [lines, nclean] = wrap();\n        for (; limW > 50; limW -= fsz) {\n            let [tryLines, tryClean] = wrap();\n            if (tryLines.length > lines.length)\n                break;\n            if (tryClean >= nclean)\n                [lines, nclean] = [tryLines, tryClean];\n        }\n        return lines;\n    }\n}\nArrangeExperiment.COMP_GAP_LEFT = 0.5;\nArrangeExperiment.COMP_ANNOT_SIZE = 1;\n\n\n//# sourceURL=webpack://WebMolKit/./src/gfx/ArrangeExperiment.ts?");

/***/ }),

/***/ "./src/gfx/ArrangeMeasurement.ts":
/*!***************************************!*\
  !*** ./src/gfx/ArrangeMeasurement.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"OutlineMeasurement\": () => (/* binding */ OutlineMeasurement)\n/* harmony export */ });\n/* harmony import */ var _FontData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FontData */ \"./src/gfx/FontData.ts\");\n\nclass OutlineMeasurement {\n    constructor(offsetX, offsetY, pointScale) {\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this.pointScale = pointScale;\n        this.invScale = 1 / pointScale;\n    }\n    scale() { return this.pointScale; }\n    angToX(ax) { return ax * this.pointScale + this.offsetX; }\n    angToY(ay) { return ay * -this.pointScale + this.offsetY; }\n    xToAng(px) { return (px - this.offsetX) * this.invScale; }\n    yToAng(py) { return (py - this.offsetY) * -this.invScale; }\n    yIsUp() { return false; }\n    measureText(str, fontSize) { return _FontData__WEBPACK_IMPORTED_MODULE_0__.FontData.main.measureText(str, fontSize); }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/gfx/ArrangeMeasurement.ts?");

/***/ }),

/***/ "./src/gfx/ArrangeMolecule.ts":
/*!************************************!*\
  !*** ./src/gfx/ArrangeMolecule.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ArrangeMolecule\": () => (/* binding */ ArrangeMolecule),\n/* harmony export */   \"BLineType\": () => (/* binding */ BLineType)\n/* harmony export */ });\n/* harmony import */ var _data_BondArtifact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/BondArtifact */ \"./src/data/BondArtifact.ts\");\n/* harmony import */ var _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/CoordUtil */ \"./src/data/CoordUtil.ts\");\n/* harmony import */ var _data_Molecule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data/Molecule */ \"./src/data/Molecule.ts\");\n/* harmony import */ var _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../data/PolymerBlock */ \"./src/data/PolymerBlock.ts\");\n/* harmony import */ var _util_Geom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Geom */ \"./src/util/Geom.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _FontData__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./FontData */ \"./src/gfx/FontData.ts\");\n/* harmony import */ var _Rendering__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Rendering */ \"./src/gfx/Rendering.ts\");\n\n\n\n\n\n\n\n\n\nvar BLineType;\n(function (BLineType) {\n    BLineType[BLineType[\"Normal\"] = 1] = \"Normal\";\n    BLineType[BLineType[\"Inclined\"] = 2] = \"Inclined\";\n    BLineType[BLineType[\"Declined\"] = 3] = \"Declined\";\n    BLineType[BLineType[\"Unknown\"] = 4] = \"Unknown\";\n    BLineType[BLineType[\"Dotted\"] = 5] = \"Dotted\";\n    BLineType[BLineType[\"DotDir\"] = 6] = \"DotDir\";\n    BLineType[BLineType[\"IncDouble\"] = 7] = \"IncDouble\";\n    BLineType[BLineType[\"IncTriple\"] = 8] = \"IncTriple\";\n    BLineType[BLineType[\"IncQuadruple\"] = 9] = \"IncQuadruple\";\n})(BLineType || (BLineType = {}));\nconst MINBOND_LINE = 0.25;\nconst MINBOND_EXOTIC = 0.5;\nclass ArrangeMolecule {\n    constructor(mol, measure, policy, effects = new _Rendering__WEBPACK_IMPORTED_MODULE_8__.RenderEffects()) {\n        this.mol = mol;\n        this.measure = measure;\n        this.policy = policy;\n        this.effects = effects;\n        this.points = [];\n        this.lines = [];\n        this.rings = [];\n        this.paths = [];\n        this.space = [];\n        this.wantArtifacts = true;\n        this.artifacts = null;\n        this.bondOrder = [];\n        this.atomCharge = [];\n        this.atomUnpaired = [];\n        this.artifactCharge = new Map();\n        this.artifactUnpaired = new Map();\n        this.artifactFract = new Map();\n    }\n    static guestimateSize(mol, policy, maxW, maxH) {\n        let box = mol.boundary();\n        let minX = box.minX(), minY = box.minY(), maxX = box.maxX(), maxY = box.maxY();\n        let fontSize = policy.data.fontSize * this.FONT_CORRECT;\n        for (let n = 1; n <= mol.numAtoms; n++)\n            if (mol.atomExplicit(n)) {\n                let numsym = 0;\n                for (let ch of mol.atomElement(n))\n                    if (!'|{}^'.includes(ch))\n                        numsym++;\n                let plusH = mol.atomHydrogens(n) > 0 ? 1 : 0;\n                const aw = 0.5 * 0.7 * fontSize * (numsym + plusH);\n                const ah = 0.5 * fontSize * (1 + plusH);\n                const ax = mol.atomX(n), ay = mol.atomY(n);\n                minX = Math.min(minX, ax - aw);\n                maxX = Math.max(maxX, ax + aw);\n                minY = Math.min(minY, ay - ah);\n                maxY = Math.max(maxY, ay + ah);\n            }\n        let w = Math.max(1, (maxX - minX)) * policy.data.pointScale;\n        let h = Math.max(1, (maxY - minY)) * policy.data.pointScale;\n        if (maxW > 0 && w > maxW) {\n            h *= maxW / w;\n            w = maxW;\n        }\n        if (maxH > 0 && h > maxH) {\n            w *= maxH / h;\n            h = maxH;\n        }\n        return [w, h];\n    }\n    getMolecule() { return this.mol; }\n    getMeasure() { return this.measure; }\n    getPolicy() { return this.policy; }\n    getEffects() { return this.effects; }\n    getScale() { return this.scale; }\n    setWantArtifacts(want) { this.wantArtifacts = want; }\n    getArtifacts() { return this.artifacts; }\n    setArtifacts(artifacts) { this.artifacts = artifacts; }\n    arrange() {\n        const { mol, measure, policy, effects } = this;\n        this.scale = measure.scale();\n        this.bondSepPix = policy.data.bondSep * measure.scale();\n        this.lineSizePix = policy.data.lineSize * measure.scale();\n        this.fontSizePix = policy.data.fontSize * measure.scale() * ArrangeMolecule.FONT_CORRECT;\n        this.ymul = measure.yIsUp() ? -1 : 1;\n        let artmask = null;\n        if (this.wantArtifacts && this.artifacts == null) {\n            this.artifacts = new _data_BondArtifact__WEBPACK_IMPORTED_MODULE_0__.BondArtifact(mol);\n            artmask = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.booleanArray(false, mol.numAtoms);\n            for (let path of this.artifacts.getResPaths())\n                for (let a of path.atoms)\n                    artmask[a - 1] = true;\n            for (let ring of this.artifacts.getResRings())\n                for (let a of ring.atoms)\n                    artmask[a - 1] = true;\n            for (let arene of this.artifacts.getArenes()) {\n                artmask[arene.centre - 1] = true;\n                for (let a of arene.atoms)\n                    artmask[a - 1] = true;\n            }\n        }\n        this.setupBondOrders();\n        for (let n = 1; n <= mol.numAtoms; n++) {\n            if (mol.atomElement(n).length > 2 && mol.atomHydrogens(n) == 0) {\n                this.points.push(null);\n                this.space.push(null);\n                continue;\n            }\n            let a = {\n                'anum': n,\n                'text': mol.atomExplicit(n) || this.atomIsWeirdLinear(n) ? mol.atomElement(n) : null,\n                'fsz': this.fontSizePix,\n                'bold': mol.atomMapNum(n) > 0,\n                'col': this.policy.data.atomCols[mol.atomicNumber(n)],\n                'oval': new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Oval(this.measure.angToX(mol.atomX(n)), this.measure.angToY(mol.atomY(n)), 0, 0)\n            };\n            let overCol = this.effects.colAtom[n];\n            if (overCol)\n                a.col = overCol;\n            if (artmask && artmask[n - 1] && mol.atomElement(n) == 'C')\n                a.text = null;\n            if (a.text != null) {\n                let wad = this.measure.measureText(a.text, a.fsz);\n                const PADDING = 1.1;\n                a.oval.rw = 0.5 * wad[0] * PADDING;\n                a.oval.rh = 0.5 * wad[1] * PADDING;\n            }\n            this.points.push(a);\n            this.space.push(this.computeSpacePoint(a));\n        }\n        for (let n = 1; n <= mol.numAtoms; n++)\n            if (this.points[n - 1] == null)\n                this.processLabel(n);\n        let bdbl = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.booleanArray(false, mol.numBonds);\n        for (let n = 1; n <= mol.numBonds; n++) {\n            let bfr = mol.bondFrom(n), bto = mol.bondTo(n);\n            let bt = mol.bondType(n), bo = this.bondOrder[n - 1];\n            if (bo < 0)\n                continue;\n            let col = this.effects.colBond[n];\n            if (!col)\n                col = this.policy.data.foreground;\n            bdbl[n - 1] = bo == 2 && (bt == _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.BONDTYPE_NORMAL || bt == _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.BONDTYPE_UNKNOWN);\n            let a1 = this.points[bfr - 1], a2 = this.points[bto - 1];\n            let x1 = a1.oval.cx, y1 = a1.oval.cy, x2 = a2.oval.cx, y2 = a2.oval.cy;\n            if (Math.abs(x2 - x1) <= 1 && Math.abs(y2 - y1) <= 1) {\n                bdbl[n - 1] = false;\n                continue;\n            }\n            if (bdbl[n - 1])\n                continue;\n            let minDist = (bo == 1 && bt == _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.BONDTYPE_NORMAL ? MINBOND_LINE : MINBOND_EXOTIC) * measure.scale();\n            let xy1 = this.backOffAtom(bfr, x1, y1, x2, y2, minDist);\n            let xy2 = this.backOffAtom(bto, x2, y2, x1, y1, minDist);\n            this.ensureMinimumBondLength(xy1, xy2, x1, y1, x2, y2, minDist);\n            let sz = this.lineSizePix, head = 0;\n            let ltype = BLineType.Normal;\n            if (bo == 1 && bt == _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.BONDTYPE_INCLINED) {\n                ltype = BLineType.Inclined;\n                head = 0.15 * measure.scale();\n            }\n            else if (bo == 1 && bt == _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.BONDTYPE_DECLINED) {\n                ltype = BLineType.Declined;\n                head = 0.15 * measure.scale();\n            }\n            else if (bt == _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.BONDTYPE_UNKNOWN) {\n                ltype = BLineType.Unknown;\n                head = 0.2 * measure.scale();\n            }\n            else if (bo == 0) {\n                if (bt == _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.BONDTYPE_INCLINED || bt == _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.BONDTYPE_DECLINED)\n                    ltype = BLineType.DotDir;\n                else\n                    ltype = BLineType.Dotted;\n            }\n            else if ((bo == 2 || bo == 3 || bo == 4) && (bt == _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.BONDTYPE_INCLINED || bt == _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.BONDTYPE_DECLINED)) {\n                ltype = bo == 2 ? BLineType.IncDouble : bo == 3 ? BLineType.IncTriple : BLineType.IncQuadruple;\n                head = (bo == 2 ? 0.20 : 0.25) * measure.scale();\n            }\n            if (bo == 0) {\n                let dx = xy2[0] - xy1[0], dy = xy2[1] - xy1[1];\n                let d = (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.norm_xy)(dx, dy), invD = 1 / d;\n                let ox = 0.5 * dx * invD * this.bondSepPix, oy = 0.5 * dy * invD * this.bondSepPix;\n                if (mol.atomAdjCount(bfr) > 1) {\n                    xy1[0] += ox;\n                    xy1[1] += oy;\n                }\n                if (mol.atomAdjCount(bto) > 1) {\n                    xy2[0] -= ox;\n                    xy2[1] -= oy;\n                }\n            }\n            if (bo != 1 && bt == _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.BONDTYPE_DECLINED)\n                [xy1, xy2] = [xy2, xy1];\n            if (bo > 1 && (bt == _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.BONDTYPE_NORMAL || bt == _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.BONDTYPE_UNKNOWN)) {\n                let oxy = this.orthogonalDelta(xy1[0], xy1[1], xy2[0], xy2[1], this.bondSepPix);\n                let v = -0.5 * (bo - 1);\n                for (let i = 0; i < bo; i++, v++) {\n                    let lx1 = xy1[0] + v * oxy[0], ly1 = xy1[1] + v * oxy[1], lx2 = xy2[0] + v * oxy[0], ly2 = xy2[1] + v * oxy[1];\n                    let b = {\n                        'bnum': n,\n                        'bfr': bfr,\n                        'bto': bto,\n                        'type': ltype,\n                        'line': new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Line(lx1, ly1, lx2, ly2),\n                        'size': sz,\n                        'head': head,\n                        'col': col\n                    };\n                    this.lines.push(b);\n                    this.space.push(this.computeSpaceLine(b));\n                }\n            }\n            else {\n                let b = {\n                    'bnum': n,\n                    'bfr': bfr,\n                    'bto': bto,\n                    'type': ltype,\n                    'line': new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Line(xy1[0], xy1[1], xy2[0], xy2[1]),\n                    'size': sz,\n                    'head': head,\n                    'col': col\n                };\n                this.lines.push(b);\n                this.space.push(this.computeSpaceLine(b));\n            }\n        }\n        let rings = this.orderedRingList();\n        for (let i = 0; i < rings.length; i++) {\n            for (let j = 0; j < rings[i].length; j++) {\n                let k = mol.findBond(rings[i][j], rings[i][j < rings[i].length - 1 ? j + 1 : 0]);\n                if (bdbl[k - 1]) {\n                    this.processDoubleBond(k, rings[i]);\n                    bdbl[k - 1] = false;\n                }\n            }\n        }\n        for (let i = 1; i <= mol.numBonds; i++)\n            if (bdbl[i - 1])\n                this.processDoubleBond(i, this.priorityDoubleSubstit(i));\n        let hcount = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.numberArray(0, mol.numAtoms);\n        for (let n = 1; n <= mol.numAtoms; n++)\n            hcount[n - 1] = this.points[n - 1].text == null ? 0 : mol.atomHydrogens(n);\n        for (let n = 0; n < mol.numAtoms; n++)\n            if (hcount[n] > 0 && this.placeHydrogen(n, hcount[n], true))\n                hcount[n] = 0;\n        for (let n = 0; n < mol.numAtoms; n++)\n            if (hcount[n] > 0)\n                this.placeHydrogen(n, hcount[n], false);\n        for (let n = 1; n <= mol.numAtoms; n++)\n            if (mol.atomIsotope(n) != _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.ISOTOPE_NATURAL) {\n                let isostr = mol.atomIsotope(n).toString();\n                let col = policy.data.atomCols[mol.atomicNumber(n)];\n                this.placeAdjunct(n, isostr, this.fontSizePix * 0.6, col, 150 * _util_util__WEBPACK_IMPORTED_MODULE_5__.DEGRAD);\n            }\n        for (let n = 1; n <= mol.numAtoms; n++) {\n            let str = '';\n            let chg = this.atomCharge[n - 1];\n            if (chg == -1)\n                str = '-';\n            else if (chg == 1)\n                str = '+';\n            else if (chg < -1)\n                str = Math.abs(chg) + '-';\n            else if (chg > 1)\n                str = chg + '+';\n            for (let i = this.atomUnpaired[n - 1]; i > 0; i--)\n                str += '.';\n            if (str.length == 0)\n                continue;\n            let col = policy.data.atomCols[mol.atomicNumber(n)];\n            this.placeAdjunct(n, str, str.length == 1 ? 0.8 * this.fontSizePix : 0.6 * this.fontSizePix, col, 30 * _util_util__WEBPACK_IMPORTED_MODULE_5__.DEGRAD);\n        }\n        for (let n = 0; n < effects.atomDecoText.length; n++) {\n            let txt = effects.atomDecoText[n];\n            if (!txt)\n                continue;\n            this.annotateAtom(n + 1, txt, effects.atomDecoCol[n], effects.atomDecoSize[n] * this.scale * ArrangeMolecule.FONT_CORRECT);\n        }\n        for (let n = 0; n < effects.bondDecoText.length; n++) {\n            let txt = effects.bondDecoText[n];\n            if (!txt)\n                continue;\n            this.annotateBond(n + 1, txt, effects.bondDecoCol[n], effects.bondDecoSize[n] * this.scale * ArrangeMolecule.FONT_CORRECT);\n        }\n        for (let n = 0; n < Math.min(effects.atomCircleSz.length, mol.numAtoms); n++)\n            if (effects.atomCircleSz[n] > 0) {\n                let dw = effects.atomCircleSz[n] * this.scale;\n                let a = this.points[n];\n                let box = new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Box(a.oval.cx - dw, a.oval.cy - dw, 2 * dw, 2 * dw);\n                let spc = {\n                    'anum': 0,\n                    'bnum': 0,\n                    'box': box,\n                    'px': [box.minX(), box.maxX(), box.maxX(), box.minX()],\n                    'py': [box.minY(), box.minY(), box.maxY(), box.maxY()]\n                };\n                this.space.push(spc);\n            }\n        if (this.artifacts != null) {\n            for (let path of this.artifacts.getResPaths()) {\n                this.createCurvedPath(path.atoms, this.artifactFract.get(path), 0);\n                this.delocalisedAnnotation(path.atoms, this.artifactCharge.get(path), this.artifactUnpaired.get(path));\n            }\n            for (let ring of this.artifacts.getResRings()) {\n                this.createCircularRing(ring.atoms);\n                this.delocalisedAnnotation(ring.atoms, this.artifactCharge.get(ring), this.artifactUnpaired.get(ring));\n            }\n            for (let arene of this.artifacts.getArenes()) {\n                let isRing = arene.atoms.length > 2;\n                if (isRing)\n                    for (let n = 0; n < arene.atoms.length; n++) {\n                        let nn = n < arene.atoms.length - 1 ? n + 1 : 0;\n                        if (mol.findBond(arene.atoms[n], arene.atoms[nn]) == 0) {\n                            isRing = false;\n                            break;\n                        }\n                    }\n                let alkeneLike = arene.atoms.length == 2;\n                this.createBondCentroid(arene.centre, arene.atoms);\n                if (!alkeneLike) {\n                    if (isRing)\n                        this.createCircularRing(arene.atoms);\n                    else\n                        this.createCurvedPath(arene.atoms, false, arene.centre);\n                }\n                this.delocalisedAnnotation(arene.atoms, this.artifactCharge.get(arene), this.artifactUnpaired.get(arene));\n            }\n        }\n        let polymers = new _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_3__.PolymerBlock(mol);\n        for (let id of polymers.getIDList())\n            this.processPolymerUnit(polymers.getUnit(id), polymers.getUnits());\n    }\n    numPoints() { return this.points.length; }\n    getPoint(idx) { return this.points[idx]; }\n    getPoints() { return this.points; }\n    numLines() { return this.lines.length; }\n    getLine(idx) { return this.lines[idx]; }\n    getLines() { return this.lines; }\n    numRings() { return this.rings.length; }\n    getRing(idx) { return this.rings[idx]; }\n    getRings() { return this.rings; }\n    numPaths() { return this.paths.length; }\n    getPath(idx) { return this.paths[idx]; }\n    getPaths() { return this.paths; }\n    numSpace() { return this.space.length; }\n    getSpace(idx) { return this.space[idx]; }\n    getSpaces() { return this.space; }\n    offsetEverything(dx, dy) {\n        for (let a of this.points)\n            a.oval.offsetBy(dx, dy);\n        for (let b of this.lines)\n            b.line.offsetBy(dx, dy);\n        for (let r of this.rings) {\n            r.cx += dx;\n            r.cy += dy;\n        }\n        for (let p of this.paths) {\n            _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.addTo(p.px, dx);\n            _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.addTo(p.py, dy);\n        }\n        for (let spc of this.space) {\n            spc.box.offsetBy(dx, dy);\n            _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.addTo(spc.px, dx);\n            _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.addTo(spc.py, dy);\n        }\n    }\n    offsetOrigin() {\n        let bounds = this.determineBoundary();\n        if (bounds[0] != 0 || bounds[1] != 0)\n            this.offsetEverything(-bounds[0], -bounds[1]);\n    }\n    scaleEverything(scaleBy) {\n        if (scaleBy == 1)\n            return;\n        this.scale *= scaleBy;\n        for (let a of this.points) {\n            a.oval.scaleBy(scaleBy);\n            a.fsz *= scaleBy;\n        }\n        for (let b of this.lines) {\n            b.line.scaleBy(scaleBy);\n            b.size *= scaleBy;\n            b.head *= scaleBy;\n        }\n        for (let r of this.rings) {\n            r.cx *= scaleBy;\n            r.cy *= scaleBy;\n            r.rw *= scaleBy;\n            r.rh *= scaleBy;\n            r.size *= scaleBy;\n        }\n        for (let p of this.paths) {\n            _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.mulBy(p.px, scaleBy);\n            _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.mulBy(p.py, scaleBy);\n            p.size *= scaleBy;\n        }\n        for (let spc of this.space) {\n            spc.box.scaleBy(scaleBy);\n            _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.mulBy(spc.px, scaleBy);\n            _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.mulBy(spc.py, scaleBy);\n        }\n    }\n    determineBoundary(padding) {\n        if (padding == null)\n            padding = 0;\n        if (this.space.length == 0)\n            return [0, 0, 2 * padding, 2 * padding];\n        let bounds = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.numberArray(0, 4);\n        let spc = this.space[0];\n        bounds[0] = spc.box.x;\n        bounds[1] = spc.box.y;\n        bounds[2] = spc.box.x + spc.box.w;\n        bounds[3] = spc.box.y + spc.box.h;\n        for (let n = this.space.length - 1; n > 0; n--) {\n            spc = this.space[n];\n            bounds[0] = Math.min(bounds[0], spc.box.x);\n            bounds[1] = Math.min(bounds[1], spc.box.y);\n            bounds[2] = Math.max(bounds[2], spc.box.x + spc.box.w);\n            bounds[3] = Math.max(bounds[3], spc.box.y + spc.box.h);\n        }\n        return bounds;\n    }\n    determineBoundaryBox() {\n        let [x1, y1, x2, y2] = this.determineBoundary();\n        return new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Box(x1, y1, x2 - x1, y2 - y1);\n    }\n    squeezeInto(x, y, w, h, padding) {\n        if (padding != null && padding > 0) {\n            x += padding;\n            y += padding;\n            w -= 2 * padding;\n            h -= 2 * padding;\n        }\n        let bounds = this.determineBoundary(0);\n        let bw = bounds[2] - bounds[0], bh = bounds[3] - bounds[1];\n        if (bw > w || bh > h) {\n            let downScale = 1;\n            if (bw > w)\n                downScale = w / bw;\n            if (bh > h)\n                downScale = Math.min(downScale, h / bh);\n            this.scaleEverything(downScale);\n            _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.mulBy(bounds, downScale);\n        }\n        this.offsetEverything(x - bounds[0] + 0.5 * (w - bounds[2] + bounds[0]), y - bounds[1] + 0.5 * (h - bounds[3] + bounds[1]));\n    }\n    limitBounds(w, h) {\n        let bounds = this.determineBoundary(0);\n        if (bounds[0] == bounds[2] && bounds[1] == bounds[3])\n            return;\n        let scale = Math.min(1, Math.min(w / (bounds[2] - bounds[0]), h / (bounds[3] - bounds[1])));\n        this.offsetEverything(-bounds[0], -bounds[1]);\n        this.scaleEverything(scale);\n    }\n    monochromate(col) {\n        for (let a of this.points)\n            a.col = col;\n        for (let b of this.lines)\n            b.col = col;\n    }\n    clone() {\n        let dup = new ArrangeMolecule(this.mol, this.measure, this.policy, this.effects);\n        dup.scale = this.scale;\n        dup.bondSepPix = this.bondSepPix;\n        dup.lineSizePix = this.lineSizePix;\n        dup.fontSizePix = this.fontSizePix;\n        dup.ymul = this.ymul;\n        for (let a of this.points)\n            dup.points.push((0,_util_util__WEBPACK_IMPORTED_MODULE_5__.clone)(a));\n        for (let b of this.lines)\n            dup.lines.push((0,_util_util__WEBPACK_IMPORTED_MODULE_5__.clone)(b));\n        for (let s of this.space)\n            dup.space.push((0,_util_util__WEBPACK_IMPORTED_MODULE_5__.clone)(s));\n        return dup;\n    }\n    setupBondOrders() {\n        const mol = this.mol;\n        for (let n = 0; n < mol.numBonds; n++)\n            this.bondOrder[n] = mol.bondOrder(n + 1);\n        for (let n = 0; n < mol.numAtoms; n++) {\n            this.atomCharge[n] = mol.atomCharge(n + 1);\n            this.atomUnpaired[n] = mol.atomUnpaired(n + 1);\n        }\n        let delocalise = (obj, atoms) => {\n            let charge = 0, unpaired = 0;\n            for (let a of atoms) {\n                charge += this.atomCharge[a - 1];\n                unpaired += this.atomUnpaired[a - 1];\n                this.atomCharge[a - 1] = this.atomUnpaired[a - 1] = 0;\n            }\n            this.artifactCharge.set(obj, charge);\n            this.artifactUnpaired.set(obj, unpaired);\n            for (let a1 of atoms)\n                for (let a2 of mol.atomAdjList(a1))\n                    if (!atoms.includes(a2)) {\n                        let b = mol.findBond(a1, a2);\n                        if (this.bondOrder[b - 1] >= 0)\n                            this.bondOrder[b - 1] = 1;\n                    }\n        };\n        if (this.artifacts == null)\n            return;\n        for (let path of this.artifacts.getResPaths()) {\n            let charge = 0, unpaired = 0, orders = 0;\n            for (let n = 0; n < path.atoms.length; n++) {\n                charge += mol.atomCharge(path.atoms[n]);\n                unpaired += mol.atomUnpaired(path.atoms[n]);\n                let b = mol.findBond(path.atoms[n], path.atoms[n < path.atoms.length - 1 ? n + 1 : 0]);\n                if (b > 0)\n                    orders += mol.bondOrder(b);\n            }\n            let fractional = (2 * orders - charge + unpaired) / path.atoms.length < 1;\n            this.artifactFract.set(path, fractional);\n            for (let n = 0; n < path.atoms.length - 1; n++) {\n                let b = mol.findBond(path.atoms[n], path.atoms[n + 1]);\n                if (b > 0)\n                    this.bondOrder[b - 1] = fractional ? -1 : 1;\n            }\n            delocalise(path, path.atoms);\n        }\n        for (let ring of this.artifacts.getResRings()) {\n            for (let n = 0; n < ring.atoms.length; n++) {\n                let b = mol.findBond(ring.atoms[n], ring.atoms[n < ring.atoms.length - 1 ? n + 1 : 0]);\n                if (b > 0)\n                    this.bondOrder[b - 1] = 1;\n            }\n            delocalise(ring, ring.atoms);\n        }\n        for (let arene of this.artifacts.getArenes()) {\n            let alkeneLike = arene.atoms.length == 2;\n            for (let n = 0; n < arene.atoms.length; n++) {\n                if (!alkeneLike) {\n                    let b = mol.findBond(arene.atoms[n], arene.atoms[n < arene.atoms.length - 1 ? n + 1 : 0]);\n                    if (b > 0)\n                        this.bondOrder[b - 1] = 1;\n                }\n                let b = mol.findBond(arene.centre, arene.atoms[n]);\n                if (b > 0)\n                    this.bondOrder[b - 1] = -1;\n            }\n            delocalise(arene, arene.atoms);\n        }\n    }\n    placeAdjunct(atom, str, fsz, col, angdir) {\n        let wad = this.measure.measureText(str, fsz);\n        let a = this.points[atom - 1];\n        let cx = a.oval.cx, cy = a.oval.cy, rw = 0.55 * wad[0], rh = 0.55 * wad[1];\n        if (str == '..') {\n            let zeroBonds = this.mol.atomAdjBonds(atom).filter((b) => this.mol.bondOrder(b) == 0);\n            if (zeroBonds.length == 1) {\n                let zpt = this.getPoint(this.mol.bondOther(zeroBonds[0], atom) - 1);\n                let dx = zpt.oval.cx - cx, dy = zpt.oval.cy - cy, inv = 1 / (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.norm_xy)(dx, dy);\n                let r = fsz * 0.15;\n                let ox = dy * inv * 2.5 * r, oy = -dx * inv * 2.5 * r;\n                let ext = 1.2 * (rw + rh) * inv;\n                [dx, dy] = [dx * ext, dy * ext];\n                this.points.push({ 'anum': 0, 'text': '.', 'fsz': fsz, 'bold': false, 'col': col, 'oval': new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Oval(cx + dx + ox, cy + dy + oy, r, r) });\n                this.points.push({ 'anum': 0, 'text': '.', 'fsz': fsz, 'bold': false, 'col': col, 'oval': new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Oval(cx + dx - ox, cy + dy - oy, r, r) });\n                return;\n            }\n        }\n        let bestScore = 0, bestDX = 0, bestDY = 0;\n        let px = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.numberArray(0, 4), py = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.numberArray(0, 4);\n        let angThresh = 10;\n        let shorted = false;\n        for (let ext = 0.5 * (a.oval.rw + a.oval.rh); !shorted && ext < 1.5 * this.measure.scale(); ext += 0.1 * this.measure.scale()) {\n            const DELTA = 5 * _util_util__WEBPACK_IMPORTED_MODULE_5__.DEGRAD;\n            for (let d = 0; !shorted && d < Math.PI - 0.0001; d += DELTA)\n                for (let s = -1; s <= 1; s += 2) {\n                    let dang = d * s + (s > 0 ? DELTA : 0), ang = angdir + dang;\n                    let dx = ext * Math.cos(ang), dy = ext * Math.sin(ang) * -this.ymul;\n                    let x1 = cx + dx - rw, x2 = cx + dx + rw, y1 = cy + dy - rh, y2 = cy + dy + rh;\n                    px[0] = x1;\n                    py[0] = y1;\n                    px[1] = x2;\n                    py[1] = y1;\n                    px[2] = x2;\n                    py[2] = y2;\n                    px[3] = x1;\n                    py[3] = y2;\n                    let viol = this.countPolyViolations(px, py, null, false);\n                    let score = 10 * viol + Math.abs(dang) + 10 * ext;\n                    let shortCircuit = viol == 0 && Math.abs(dang) < (angThresh + 1) * _util_util__WEBPACK_IMPORTED_MODULE_5__.DEGRAD;\n                    if (bestScore == 0 || shortCircuit || score < bestScore) {\n                        bestScore = score;\n                        bestDX = dx;\n                        bestDY = dy;\n                    }\n                    if (shortCircuit) {\n                        shorted = true;\n                        break;\n                    }\n                }\n            angThresh += 5;\n        }\n        a =\n            {\n                'anum': 0,\n                'text': str,\n                'fsz': fsz,\n                'bold': false,\n                'col': col,\n                'oval': new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Oval(cx + bestDX, cy + bestDY, rw, rh)\n            };\n        this.points.push(a);\n        let spc = {\n            'anum': 0,\n            'bnum': 0,\n            'box': new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Box(a.oval.cx - rw, a.oval.cy - rh, 2 * rw, 2 * rh),\n            'px': [a.oval.cx - rw, a.oval.cx + rw, a.oval.cx + rw, a.oval.cx - rw],\n            'py': [a.oval.cy - rh, a.oval.cy - rh, a.oval.cy + rh, a.oval.cy + rh]\n        };\n        this.space.push(spc);\n    }\n    processLabel(anum) {\n        let ax = this.mol.atomX(anum), ay = this.mol.atomY(anum);\n        let left = 0, right = 0;\n        let adj = this.mol.atomAdjList(anum);\n        for (let n = 0; n < adj.length; n++) {\n            let theta = Math.atan2(this.mol.atomY(adj[n]) - ay, this.mol.atomX(adj[n]) - ax) * _util_util__WEBPACK_IMPORTED_MODULE_5__.RADDEG;\n            if (theta >= -15 && theta <= 15)\n                right += 3;\n            else if (theta >= -85 && theta <= 85)\n                right++;\n            else if (theta > 85 && theta < 95) { }\n            else if (theta < -85 && theta > -95) { }\n            else if (theta > 165 || theta < -165)\n                left += 3;\n            else\n                left++;\n        }\n        let label = this.mol.atomElement(anum);\n        let ibar = label.indexOf('|'), ibrace = label.indexOf('{');\n        let side = 0;\n        if (left == 0 && right == 0 && ibar < 0 && ibrace < 0) { }\n        else if (left < right)\n            side = -1;\n        else if (right < left)\n            side = 1;\n        else {\n            let score1 = _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.congestionPoint(this.mol, ax - 1, ay);\n            let score2 = _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.congestionPoint(this.mol, ax + 1, ay);\n            if (score1 < 0.5 * score2)\n                side = -1;\n            else\n                side = 1;\n        }\n        let chunks = null;\n        let position = null;\n        let primary = null;\n        let refchunk = 0;\n        if (ibar < 0 && ibrace < 0) {\n            if (side == 0)\n                chunks = [label];\n            else if (side < 0) {\n                chunks = [label.substring(0, label.length - 1), label.substring(label.length - 1)];\n                refchunk = 1;\n            }\n            else\n                chunks = [label.substring(0, 1), label.substring(1)];\n        }\n        else {\n            let bits = [];\n            let bpos = [];\n            let bpri = [];\n            let blocks = label.split('|');\n            if (side < 0)\n                blocks = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.reverse(blocks);\n            let buff = '';\n            for (let i = 0; i < blocks.length; i++) {\n                let isPrimary = (side >= 0 && i == 0) || (side < 0 && i == blocks.length - 1);\n                if (side < 0 && refchunk == 0 && i == blocks.length - 1)\n                    refchunk = bits.length;\n                let pos = 0;\n                buff = '';\n                for (let j = 0; j < blocks[i].length; j++) {\n                    let ch = blocks[i].charAt(j);\n                    if (ch == '{' || ch == '}') {\n                        if (buff.length > 0) {\n                            bits.push(buff.toString());\n                            bpos.push(pos);\n                            bpri.push(isPrimary);\n                        }\n                        buff = '';\n                        pos = ch == '{' ? -1 : 0;\n                    }\n                    else if (ch == '^' && pos == -1 && buff.length == 0)\n                        pos = 1;\n                    else\n                        buff += ch;\n                }\n                if (buff.length > 0) {\n                    bits.push(buff.toString());\n                    bpos.push(pos);\n                    bpri.push(isPrimary);\n                }\n            }\n            chunks = bits;\n            position = bpos;\n            primary = bpri;\n            while (refchunk < chunks.length - 1 && position[refchunk] != 0)\n                refchunk++;\n        }\n        let PADDING = 1.1;\n        let SSFRACT = 0.6;\n        let chunkw = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.numberArray(0, chunks.length);\n        let tw = 0;\n        for (let n = 0; n < chunks.length; n++) {\n            chunkw[n] = this.measure.measureText(chunks[n], this.fontSizePix)[0];\n            if (position != null && position[n] != 0)\n                chunkw[n] *= SSFRACT;\n            tw += chunkw[n];\n        }\n        let x = this.measure.angToX(ax), y = this.measure.angToY(ay);\n        for (let n = 0; n < refchunk; n++)\n            x -= chunkw[n];\n        x -= 0.5 * chunkw[refchunk];\n        for (let n = 0; n < chunks.length; n++) {\n            let a = {\n                'anum': (n == refchunk || (primary != null && primary[n])) ? anum : 0,\n                'text': chunks[n],\n                'fsz': this.fontSizePix,\n                'bold': false,\n                'col': this.policy.data.atomCols[this.mol.atomicNumber(anum)],\n                'oval': new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Oval(x + 0.5 * chunkw[n], y, 0.5 * chunkw[n] * PADDING, 0.5 * this.fontSizePix * PADDING)\n            };\n            if (position != null && position[n] != 0) {\n                a.fsz *= SSFRACT;\n                if (position[n] < 0)\n                    a.oval.cy += a.fsz * 0.7 * (this.measure.yIsUp() ? -1 : 1);\n                else\n                    a.oval.cy -= a.fsz * 0.3 * (this.measure.yIsUp() ? -1 : 1);\n            }\n            if (n == refchunk) {\n                this.points[anum - 1] = a;\n                this.space[anum - 1] = this.computeSpacePoint(a);\n            }\n            else {\n                this.points.push(a);\n                this.space.push(this.computeSpacePoint(a));\n            }\n            x += chunkw[n];\n        }\n    }\n    atomIsWeirdLinear(idx) {\n        let bonds = this.mol.atomAdjBonds(idx);\n        if (bonds.length != 2)\n            return false;\n        for (let n = 0; n < bonds.length; n++)\n            if (this.mol.bondOrder(bonds[n]) == 3)\n                return false;\n        let adj = this.mol.atomAdjList(idx);\n        let th1 = Math.atan2(this.mol.atomY(adj[0]) - this.mol.atomY(idx), this.mol.atomX(adj[0]) - this.mol.atomX(idx));\n        let th2 = Math.atan2(this.mol.atomY(adj[1]) - this.mol.atomY(idx), this.mol.atomX(adj[1]) - this.mol.atomX(idx));\n        return Math.abs((0,_util_util__WEBPACK_IMPORTED_MODULE_5__.angleDiff)(th1, th2)) >= 175 * _util_util__WEBPACK_IMPORTED_MODULE_5__.DEGRAD;\n    }\n    backOffAtom(atom, x, y, fx, fy, minDist) {\n        if (x == fx && y == fy)\n            return [x, y];\n        let active = false;\n        let dx = 0, dy = 0, dst = 0, ext = 0;\n        for (let s = 0; s < this.space.length; s++) {\n            let spc = this.space[s];\n            if (spc.anum != atom)\n                continue;\n            const sz = spc.px.length;\n            if (sz == 0)\n                continue;\n            for (let n = 0; n < sz; n++) {\n                let nn = n < sz - 1 ? n + 1 : 0;\n                let x1 = spc.px[n], y1 = spc.py[n], x2 = spc.px[nn], y2 = spc.py[nn];\n                if (!_util_Geom__WEBPACK_IMPORTED_MODULE_4__.GeomUtil.doLineSegsIntersect(x, y, fx, fy, x1, y1, x2, y2))\n                    continue;\n                let xy = _util_Geom__WEBPACK_IMPORTED_MODULE_4__.GeomUtil.lineIntersect(x, y, fx, fy, x1, y1, x2, y2);\n                if (!active) {\n                    dx = x - fx;\n                    dy = y - fy;\n                    dst = (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.norm_xy)(dx, dy);\n                    ext = dst;\n                    active = true;\n                }\n                ext = Math.min(ext, (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.norm_xy)(xy[0] - fx, xy[1] - fy));\n            }\n        }\n        if (active) {\n            ext = Math.max(minDist, ext - 0.1 * this.measure.scale());\n            let idst = 1.0 / dst;\n            return [fx + ext * idst * dx, fy + ext * idst * dy];\n        }\n        else\n            return [x, y];\n    }\n    ensureMinimumBondLength(xy1, xy2, x1, y1, x2, y2, minDist) {\n        let dx = xy2[0] - xy1[0], dy = xy2[1] - xy1[1];\n        let dsq = (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.norm2_xy)(dx, dy);\n        minDist = Math.min(minDist, (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.norm_xy)(x2 - x1, y2 - y1));\n        if (dsq >= (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.sqr)(minDist - 0.0001))\n            return;\n        let d12 = Math.sqrt(dsq), d1 = (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.norm_xy)(xy1[0] - x1, xy1[1] - y1), d2 = (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.norm_xy)(x2 - xy2[0], y2 - xy2[1]);\n        let mag = 1 - minDist / d12, invD12 = 1.0 / (d1 + d2), mag1 = d1 * mag * invD12, mag2 = d2 * mag * invD12;\n        xy1[0] -= dx * mag1;\n        xy1[1] -= dy * mag1;\n        xy2[0] += dx * mag2;\n        xy2[1] += dy * mag2;\n    }\n    orderedRingList() {\n        let rings = [];\n        let SIZE_ORDER = [6, 5, 7, 4, 3];\n        for (let i = 0; i < SIZE_ORDER.length; i++) {\n            let nring = this.mol.findRingsOfSize(SIZE_ORDER[i]);\n            for (let j = 0; j < nring.length; j++)\n                rings.push(nring[j]);\n        }\n        let ringsz = rings.length;\n        let ringbusy = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.numberArray(0, this.mol.numAtoms);\n        for (let n = 0; n < ringsz; n++) {\n            let r = rings[n];\n            for (let i = 0; i < r.length; i++)\n                ringbusy[r[i] - 1]++;\n        }\n        let ringscore = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.numberArray(0, ringsz);\n        for (let n = 0; n < ringsz; n++) {\n            let r = rings[n];\n            for (let i = 0; i < r.length; i++)\n                ringscore[n] += ringbusy[r[i] - 1];\n        }\n        let ringorder = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.idxSort(ringscore);\n        let resbcount = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.numberArray(0, ringsz), maxbcount = 0;\n        for (let n = 0; n < ringsz; n++) {\n            let r = rings[ringorder[n]];\n            for (let i = 0; i < r.length; i++) {\n                let j = this.mol.findBond(r[i], r[i + 1 < r.length ? i + 1 : 0]);\n                if (this.mol.bondOrder(j) == 2)\n                    resbcount[n]++;\n            }\n            maxbcount = Math.max(maxbcount, resbcount[n]);\n        }\n        let pos = 0, ret = [];\n        for (let sz = maxbcount; sz >= 0; sz--) {\n            for (let n = 0; n < ringsz; n++)\n                if (resbcount[n] == sz)\n                    ret.push(rings[ringorder[n]]);\n        }\n        return ret;\n    }\n    orthogonalDelta(x1, y1, x2, y2, d) {\n        let ox = y1 - y2, oy = x2 - x1, dsq = (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.norm2_xy)(ox, oy);\n        let sc = dsq > 0 ? d / Math.sqrt(dsq) : 1;\n        return [ox * sc, oy * sc];\n    }\n    processDoubleBond(idx, priority) {\n        let bfr = this.mol.bondFrom(idx), bto = this.mol.bondTo(idx);\n        let nfr = this.mol.atomAdjList(bfr), nto = this.mol.atomAdjList(bto);\n        let a1 = this.points[bfr - 1], a2 = this.points[bto - 1];\n        let x1 = a1.oval.cx, y1 = a1.oval.cy, x2 = a2.oval.cx, y2 = a2.oval.cy;\n        const minDist = MINBOND_EXOTIC * this.measure.scale();\n        let xy1 = this.backOffAtom(bfr, x1, y1, x2, y2, minDist);\n        let xy2 = this.backOffAtom(bto, x2, y2, x1, y1, minDist);\n        this.ensureMinimumBondLength(xy1, xy2, x1, y1, x2, y2, minDist);\n        x1 = xy1[0];\n        y1 = xy1[1];\n        x2 = xy2[0];\n        y2 = xy2[1];\n        let dx = x2 - x1, dy = y2 - y1, btheta = Math.atan2(dy, dx);\n        let countFLeft = 0, countFRight = 0, countTLeft = 0, countTRight = 0;\n        let idxFLeft = 0, idxFRight = 0, idxTLeft = 0, idxTRight = 0;\n        let noshift = false;\n        for (let n = 0; n < nfr.length; n++)\n            if (nfr[n] != bto) {\n                let bo = this.mol.bondOrder(this.mol.findBond(bfr, nfr[n]));\n                if (bo == 0)\n                    continue;\n                if (bo > 1) {\n                    noshift = true;\n                    break;\n                }\n                let ispri = false;\n                for (let i = 0; i < (priority == null ? 0 : priority.length); i++)\n                    if (priority[i] == nfr[n])\n                        ispri = true;\n                let theta = (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.angleDiff)(Math.atan2(this.points[nfr[n] - 1].oval.cy - y1, this.points[nfr[n] - 1].oval.cx - x1), btheta);\n                if (Math.abs(theta) * _util_util__WEBPACK_IMPORTED_MODULE_5__.RADDEG > 175) {\n                    noshift = true;\n                    break;\n                }\n                if (theta > 0) {\n                    if (ispri)\n                        countFLeft++;\n                    idxFLeft = nfr[n];\n                }\n                else {\n                    if (ispri)\n                        countFRight++;\n                    idxFRight = nfr[n];\n                }\n            }\n        for (let n = 0; n < nto.length; n++)\n            if (nto[n] != bfr) {\n                let bo = this.mol.bondOrder(this.mol.findBond(bto, nto[n]));\n                if (bo == 0)\n                    continue;\n                if (bo > 1) {\n                    noshift = true;\n                    break;\n                }\n                let ispri = false;\n                for (let i = 0; i < (priority == null ? 0 : priority.length); i++)\n                    if (priority[i] == nto[n])\n                        ispri = true;\n                let theta = (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.angleDiff)(Math.atan2(this.points[nto[n] - 1].oval.cy - y2, this.points[nto[n] - 1].oval.cx - x2), btheta);\n                if (Math.abs(theta) * _util_util__WEBPACK_IMPORTED_MODULE_5__.RADDEG > 175) {\n                    noshift = true;\n                    break;\n                }\n                if (theta > 0) {\n                    if (ispri)\n                        countTLeft++;\n                    idxTLeft = nto[n];\n                }\n                else {\n                    if (ispri)\n                        countTRight++;\n                    idxTRight = nto[n];\n                }\n            }\n        let side = 0;\n        if (noshift || countFLeft > 1 || countFRight > 1 || countTLeft > 1 || countTRight > 1) { }\n        else if (countFLeft > 0 && countFRight > 0) { }\n        else if (countTLeft > 0 && countTRight > 0) { }\n        else if (countFLeft > 0 || countTLeft > 0)\n            side = 1;\n        else if (countFRight > 0 || countTRight > 0)\n            side = -1;\n        let sz = this.lineSizePix;\n        let oxy = this.orthogonalDelta(x1, y1, x2, y2, this.bondSepPix);\n        let ax1 = x1, ay1 = y1, ax2 = x2, ay2 = y2;\n        let bx1 = 0, by1 = 0, bx2 = 0, by2 = 0;\n        if (side == 0) {\n            ax1 = x1 + 0.5 * oxy[0];\n            ay1 = y1 + 0.5 * oxy[1];\n            ax2 = x2 + 0.5 * oxy[0];\n            ay2 = y2 + 0.5 * oxy[1];\n            bx1 = x1 - 0.5 * oxy[0];\n            by1 = y1 - 0.5 * oxy[1];\n            bx2 = x2 - 0.5 * oxy[0];\n            by2 = y2 - 0.5 * oxy[1];\n        }\n        else if (side > 0) {\n            bx1 = x1 + oxy[0];\n            by1 = y1 + oxy[1];\n            bx2 = x2 + oxy[0];\n            by2 = y2 + oxy[1];\n            if (nfr.length > 1 && this.points[bfr - 1].text == null) {\n                bx1 += oxy[1];\n                by1 -= oxy[0];\n            }\n            if (nto.length > 1 && this.points[bto - 1].text == null) {\n                bx2 -= oxy[1];\n                by2 += oxy[0];\n            }\n        }\n        else if (side < 0) {\n            bx1 = x1 - oxy[0];\n            by1 = y1 - oxy[1];\n            bx2 = x2 - oxy[0];\n            by2 = y2 - oxy[1];\n            if (nfr.length > 1 && this.points[bfr - 1].text == null) {\n                bx1 += oxy[1];\n                by1 -= oxy[0];\n            }\n            if (nto.length > 1 && this.points[bto - 1].text == null) {\n                bx2 -= oxy[1];\n                by2 += oxy[0];\n            }\n        }\n        if (side != 0) {\n            if (this.mol.atomElement(bfr).length <= 2 && this.mol.atomAdjCount(bfr) == 1 && this.points[bfr - 1].text != null) {\n                this.bumpAtomPosition(bfr, 0.5 * oxy[0] * side, 0.5 * oxy[1] * side);\n            }\n            if (this.mol.atomElement(bto).length <= 2 && this.mol.atomAdjCount(bto) == 1 && this.points[bto - 1].text != null) {\n                this.bumpAtomPosition(bto, 0.5 * oxy[0] * side, 0.5 * oxy[1] * side);\n            }\n        }\n        if (side == 0 && !noshift) {\n            let xy = null;\n            if (this.points[bfr - 1].text == null && !this.mol.bondInRing(idx)) {\n                xy = this.adjustBondPosition(idxFLeft, bfr, ax1, ay1, ax2, ay2);\n                if (xy != null) {\n                    ax1 = xy[0];\n                    ay1 = xy[1];\n                }\n                xy = this.adjustBondPosition(idxFRight, bfr, bx1, by1, bx2, by2);\n                if (xy != null) {\n                    bx1 = xy[0];\n                    by1 = xy[1];\n                }\n            }\n            if (this.points[bto - 1].text == null && !this.mol.bondInRing(idx)) {\n                xy = this.adjustBondPosition(idxTLeft, bto, ax2, ay2, ax1, ay1);\n                if (xy != null) {\n                    ax2 = xy[0];\n                    ay2 = xy[1];\n                }\n                xy = this.adjustBondPosition(idxTRight, bto, bx2, by2, bx1, by1);\n                if (xy != null) {\n                    bx2 = xy[0];\n                    by2 = xy[1];\n                }\n            }\n        }\n        let lt = this.mol.bondType(idx) == _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.BONDTYPE_UNKNOWN ? BLineType.Unknown : BLineType.Normal;\n        let head = lt == BLineType.Unknown ? 0.1 * this.scale : 0;\n        let col = this.effects.colBond[idx];\n        if (!col)\n            col = this.policy.data.foreground;\n        let b1 = {\n            'bnum': idx,\n            'bfr': bfr,\n            'bto': bto,\n            'type': lt,\n            'line': new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Line(ax1, ay1, ax2, ay2),\n            'size': sz,\n            'head': head,\n            'col': col\n        };\n        let b2 = {\n            'bnum': idx,\n            'bfr': bfr,\n            'bto': bto,\n            'type': lt,\n            'line': new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Line(bx1, by1, bx2, by2),\n            'size': sz,\n            'head': head,\n            'col': col\n        };\n        this.lines.push(b1);\n        this.lines.push(b2);\n        this.space.push(this.computeSpaceLine(b1));\n        this.space.push(this.computeSpaceLine(b2));\n    }\n    placeHydrogen(idx, hcount, fussy) {\n        let font = _FontData__WEBPACK_IMPORTED_MODULE_7__.FontData.main;\n        const SSFRACT = 0.6;\n        const GLYPH_H = font.getIndex('H');\n        let a = this.points[idx];\n        let emscale = a.fsz * font.INV_UNITS_PER_EM;\n        let sub = hcount >= 2 ? hcount.toString() : '';\n        let outlineX = font.getOutlineX(GLYPH_H), outlineY = font.getOutlineY(GLYPH_H);\n        let firstEMW = font.HORIZ_ADV_X[GLYPH_H], emw = firstEMW;\n        for (let n = 0; n < sub.length; n++) {\n            let ch = sub.charAt(n), g = font.getIndex(ch);\n            if (n == 0) {\n                emw += font.getKerning('H', ch);\n            }\n            else {\n                let chp = sub.charAt(n - 1);\n                emw += font.getKerning(chp, ch) * SSFRACT;\n            }\n            let extraX = font.getOutlineX(g), extraY = font.getOutlineY(g);\n            _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.addTo(extraX, emw / SSFRACT);\n            _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.addTo(extraY, (SSFRACT - 1) * font.ASCENT);\n            _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.mulBy(extraX, SSFRACT);\n            _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.mulBy(extraY, SSFRACT);\n            outlineX = outlineX.concat(extraX);\n            outlineY = outlineY.concat(extraY);\n            emw += font.HORIZ_ADV_X[g] * SSFRACT;\n        }\n        if (sub.length > 0) {\n            let qh = new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.QuickHull(outlineX, outlineY, 0);\n            outlineX = qh.hullX;\n            outlineY = qh.hullY;\n        }\n        let emdx = -0.5 * firstEMW, emdy = 0.5 * font.ASCENT;\n        for (let n = 0; n < outlineX.length; n++) {\n            outlineX[n] = a.oval.cx + (emdx + outlineX[n]) * emscale;\n            outlineY[n] = a.oval.cy + (emdy - outlineY[n]) * emscale * this.ymul;\n        }\n        let dx = 0, dy = 0;\n        let srcWAD = this.measure.measureText(a.text, a.fsz);\n        if (fussy) {\n            let RIGHTLEFT = [0, 1, 2, 3];\n            let LEFTRIGHT = [1, 0, 2, 3];\n            let UPDOWN = [2, 3, 0, 1];\n            let DOWNUP = [3, 2, 0, 1];\n            let quad = RIGHTLEFT, adj = this.mol.atomAdjList(a.anum);\n            if (adj.length == 0) {\n                let LEFTIES = ['O', 'S', 'F', 'Cl', 'Br', 'I'];\n                if (this.mol.atomCharge(a.anum) == 0 && this.mol.atomUnpaired(a.anum) == 0 &&\n                    LEFTIES.indexOf(this.mol.atomElement(a.anum)) >= 0)\n                    quad = LEFTRIGHT;\n                else\n                    quad = RIGHTLEFT;\n            }\n            else {\n                let allLeft = true, allRight = true, allUp = true, allDown = true;\n                const ax = this.mol.atomX(a.anum), ay = this.mol.atomY(a.anum);\n                for (let n = 0; n < adj.length; n++) {\n                    const bx = this.mol.atomX(adj[n]), by = this.mol.atomY(adj[n]);\n                    if (bx > ax + 0.01)\n                        allLeft = false;\n                    if (bx < ax - 0.01)\n                        allRight = false;\n                    if (by < ay - 0.01)\n                        allUp = false;\n                    if (by > ay + 0.01)\n                        allDown = false;\n                }\n                if (allLeft) { }\n                else if (allRight)\n                    quad = LEFTRIGHT;\n                else if (allUp)\n                    quad = DOWNUP;\n                else if (allDown)\n                    quad = UPDOWN;\n            }\n            for (let n = 0; n < 4; n++) {\n                let tx = 0, ty = 0;\n                if (quad[n] == 0)\n                    tx = 0.5 * srcWAD[0] + 0.5 * firstEMW * emscale;\n                else if (quad[n] == 1)\n                    tx = -0.5 * srcWAD[0] - (emw - 0.5 * firstEMW) * emscale;\n                else if (quad[n] == 2)\n                    ty = (1.1 * srcWAD[1] + 0.5 * srcWAD[2]) * -this.ymul;\n                else if (quad[n] == 3)\n                    ty = (1.1 * srcWAD[1] + 0.5 * srcWAD[2]) * this.ymul;\n                _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.addTo(outlineX, tx);\n                _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.addTo(outlineY, ty);\n                let viol = this.countPolyViolations(outlineX, outlineY, null, true);\n                _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.addTo(outlineX, -tx);\n                _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.addTo(outlineY, -ty);\n                if (viol == 0) {\n                    dx = tx;\n                    dy = ty;\n                    break;\n                }\n            }\n            if (dx == 0 && dy == 0)\n                return false;\n        }\n        else {\n            const mx1 = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.min(outlineY), mx2 = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.max(outlineX), my1 = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.min(outlineY), my2 = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.max(outlineY), cx = 0.5 * (mx1 + mx2), cy = 0.5 * (my1 + my2);\n            const mag = 1 + this.measure.scale() * this.policy.data.fontSize * ArrangeMolecule.FONT_CORRECT * 0.1 / Math.max(mx2 - cx, my2 - cy);\n            const psz = outlineX.length;\n            let magPX = outlineX.slice(0), magPY = outlineY.slice(0);\n            for (let n = 0; n < psz; n++) {\n                magPX[n] = (magPX[n] - cx) * mag + cx;\n                magPY[n] = (magPY[n] - cy) * mag + cy;\n            }\n            let bestScore = 0, bestExt = 0, bestAng = 0;\n            for (let ext = 0.5 * (a.oval.rw + a.oval.rh); ext < 1.5 * this.measure.scale(); ext += 0.1 * this.measure.scale()) {\n                let anyNoClash = false;\n                for (let ang = 0; ang < 2 * Math.PI; ang += 5 * _util_util__WEBPACK_IMPORTED_MODULE_5__.DEGRAD) {\n                    let tx = ext * Math.cos(ang), ty = ext * Math.sin(ang);\n                    _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.addTo(magPX, tx);\n                    _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.addTo(magPY, ty);\n                    let viol = this.countPolyViolations(magPX, magPY, null, false);\n                    _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.addTo(magPX, -tx);\n                    _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.addTo(magPY, -ty);\n                    if (viol == 0)\n                        anyNoClash = true;\n                    let score = 10 * viol + this.spatialCongestion(a.oval.cx + tx, a.oval.cy + ty, 0.5) + 2 * ext;\n                    if (bestScore == 0 || score < bestScore) {\n                        bestScore = score;\n                        bestExt = ext;\n                        bestAng = ang;\n                        dx = tx;\n                        dy = ty;\n                    }\n                }\n                if (anyNoClash)\n                    break;\n            }\n        }\n        let wad = this.measure.measureText('H', a.fsz);\n        const PADDING = 1.1;\n        let ah = {\n            'anum': 0,\n            'text': 'H',\n            'fsz': a.fsz,\n            'bold': a.bold,\n            'col': a.col,\n            'oval': new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Oval(a.oval.cx + dx, a.oval.cy + dy, 0.5 * wad[0] * PADDING, 0.5 * wad[1] * PADDING)\n        };\n        this.points.push(ah);\n        if (sub.length > 0) {\n            const subFsz = SSFRACT * a.fsz;\n            wad = this.measure.measureText(sub, subFsz);\n            let an = {\n                'anum': 0,\n                'text': sub,\n                'fsz': subFsz,\n                'bold': a.bold,\n                'col': a.col,\n                'oval': new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Oval(ah.oval.cx + 0.5 * firstEMW * a.fsz * font.INV_UNITS_PER_EM + 0.5 * wad[0], ah.oval.cy + (1 - SSFRACT) * a.fsz, 0.5 * wad[0] * PADDING, 0.5 * wad[1] * PADDING)\n            };\n            this.points.push(an);\n        }\n        _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.addTo(outlineX, dx);\n        _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.addTo(outlineY, dy);\n        let minX = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.min(outlineX), minY = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.min(outlineY);\n        let spc = {\n            'anum': 0,\n            'bnum': 0,\n            'box': new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Box(minX, minY, _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.max(outlineX) - minX, _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.max(outlineY) - minY),\n            'px': outlineX,\n            'py': outlineY\n        };\n        this.space.push(spc);\n        return true;\n    }\n    computeSpacePoint(a) {\n        let s = {\n            'anum': a.anum,\n            'bnum': 0,\n            'box': new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Box(),\n            'px': [],\n            'py': []\n        };\n        const font = _FontData__WEBPACK_IMPORTED_MODULE_7__.FontData.main;\n        let outlineX = [], outlineY = [];\n        let emw = 0, nglyphs = 0;\n        if (a.text != null) {\n            for (let n = 0; n < a.text.length; n++) {\n                let ch1 = a.text.charAt(n);\n                let i = font.getIndex(ch1);\n                if (i >= 0) {\n                    if (emw == 0) {\n                        outlineX = font.getOutlineX(i);\n                        outlineY = font.getOutlineY(i);\n                        nglyphs = 1;\n                    }\n                    else {\n                        let extraX = font.getOutlineX(i), extraY = font.getOutlineY(i);\n                        if (extraX.length > 0) {\n                            _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.addTo(extraX, emw);\n                            outlineX = outlineX.concat(extraX);\n                            outlineY = outlineY.concat(extraY);\n                            nglyphs++;\n                        }\n                    }\n                    emw += font.HORIZ_ADV_X[i];\n                }\n                else\n                    emw += font.MISSING_HORZ;\n                if (n < a.text.length - 1) {\n                    let ch2 = a.text.charAt(n + 1);\n                    emw += font.getKerning(ch1, ch2);\n                }\n            }\n        }\n        if (outlineX.length > 0) {\n            if (nglyphs > 1) {\n                let qh = new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.QuickHull(outlineX, outlineY, 0);\n                outlineX = qh.hullX;\n                outlineY = qh.hullY;\n            }\n            let emdx = -0.5 * emw, emdy = 0.5 * font.ASCENT;\n            let emscale = a.fsz * font.INV_UNITS_PER_EM;\n            for (let n = 0; n < outlineX.length; n++) {\n                outlineX[n] = a.oval.cx + (emdx + outlineX[n]) * emscale;\n                outlineY[n] = a.oval.cy + (emdy - outlineY[n]) * emscale * this.ymul;\n            }\n            s.px = outlineX;\n            s.py = outlineY;\n            let minX = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.min(outlineX), minY = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.min(outlineY);\n            s.box = new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Box(minX, minY, _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.max(outlineX) - minX, _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.max(outlineY) - minY);\n        }\n        else {\n            s.box = _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Box.fromOval(a.oval);\n            if (s.box.w > 0 && s.box.h > 0) {\n                s.px = [s.box.minX(), s.box.maxX(), s.box.maxX(), s.box.minX()];\n                s.py = [s.box.minY(), s.box.minY(), s.box.maxY(), s.box.maxY()];\n            }\n        }\n        return s;\n    }\n    computeSpaceLine(b) {\n        let s = {\n            'anum': 0,\n            'bnum': b.bnum,\n            'box': new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Box(),\n            'px': [],\n            'py': []\n        };\n        if (b.type == BLineType.Normal || b.type == BLineType.Dotted || b.type == BLineType.DotDir) {\n            s.px = [b.line.x1, b.line.x2];\n            s.py = [b.line.y1, b.line.y2];\n        }\n        else {\n            const dx = b.line.x2 - b.line.x1, dy = b.line.y2 - b.line.y1;\n            const norm = b.head / Math.sqrt(dx * dx + dy * dy);\n            const ox = norm * dy, oy = -norm * dx;\n            if (b.type == BLineType.Unknown) {\n                s.px = [b.line.x1 + ox, b.line.x1 - ox, b.line.x2 - ox, b.line.x2 + ox];\n                s.py = [b.line.y1 + oy, b.line.y1 - oy, b.line.y2 - oy, b.line.y2 + oy];\n            }\n            else {\n                s.px = [b.line.x1, b.line.x2 - ox, b.line.x2 + ox];\n                s.py = [b.line.y1, b.line.y2 - oy, b.line.y2 + oy];\n            }\n        }\n        s.box.x = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.min(s.px) - b.size;\n        s.box.y = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.min(s.py) - b.size;\n        s.box.w = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.max(s.px) - s.box.x + b.size;\n        s.box.h = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.max(s.py) - s.box.y + b.size;\n        return s;\n    }\n    bumpAtomPosition(atom, dx, dy) {\n        let p = this.points[atom - 1];\n        p.oval.cx += dx;\n        p.oval.cy += dy;\n        for (let n = this.space.length - 1; n >= 0; n--) {\n            let s = this.space[n - 1];\n            if (s == null || s.anum != atom)\n                continue;\n            s.box.x += dx;\n            s.box.y += dy;\n            _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.addTo(s.px, dx);\n            _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.addTo(s.py, dy);\n        }\n    }\n    spaceSubset(x, y, w, h) {\n        let subset = [];\n        for (let s of this.space)\n            if (_util_Geom__WEBPACK_IMPORTED_MODULE_4__.GeomUtil.rectsIntersect(x, y, w, h, s.box.x, s.box.y, s.box.w, s.box.h))\n                subset.push(s);\n        return subset;\n    }\n    countPolyViolations(px, py, space, shortCircuit) {\n        if (space == null)\n            space = this.space;\n        let hits = 0;\n        const psz = px.length, nspc = space.length;\n        let pr = new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Box(), sr = new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Box();\n        for (let i1 = 0; i1 < psz; i1++) {\n            let i2 = i1 < psz - 1 ? i1 + 1 : 0;\n            pr.x = Math.min(px[i1], px[i2]) - 1;\n            pr.y = Math.min(py[i1], py[i2]) - 1;\n            pr.w = Math.max(px[i1], px[i2]) - pr.x + 2;\n            pr.h = Math.max(py[i1], py[i2]) - pr.y + 2;\n            for (let j = 0; j < nspc; j++) {\n                let spc = space[j];\n                if (spc.px == null)\n                    continue;\n                sr.x = spc.box.x - 1;\n                sr.y = spc.box.y - 1;\n                sr.w = spc.box.w + 1;\n                sr.h = spc.box.h + 1;\n                if (!pr.intersects(sr))\n                    continue;\n                let ssz = spc.px.length;\n                for (let j1 = 0; j1 < ssz; j1++) {\n                    let j2 = j1 < ssz - 1 ? j1 + 1 : 0;\n                    sr.x = Math.min(spc.px[j1], spc.px[j2]) - 1;\n                    sr.y = Math.min(spc.py[j1], spc.py[j2]) - 1;\n                    sr.w = Math.max(spc.px[j1], spc.px[j2]) - sr.x + 2;\n                    sr.h = Math.max(spc.py[j1], spc.py[j2]) - sr.y + 2;\n                    if (!pr.intersects(sr))\n                        continue;\n                    if (_util_Geom__WEBPACK_IMPORTED_MODULE_4__.GeomUtil.doLineSegsIntersect(px[i1], py[i1], px[i2], py[i2], spc.px[j1], spc.py[j1], spc.px[j2], spc.py[j2])) {\n                        if (shortCircuit)\n                            return 1;\n                        hits++;\n                        break;\n                    }\n                    if (ssz == 1)\n                        break;\n                }\n            }\n        }\n        pr.x = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.min(px);\n        pr.y = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.min(py);\n        pr.w = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.max(px) - pr.x;\n        pr.h = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.max(py) - pr.y;\n        for (let n = nspc - 1; n >= 0; n--) {\n            let spc = space[n];\n            sr.x = spc.box.x;\n            sr.y = spc.box.y;\n            sr.w = spc.box.w;\n            sr.h = spc.box.h;\n            if (!pr.intersects(sr))\n                continue;\n            for (let i = spc.px.length - 1; i >= 0; i--)\n                if (_util_Geom__WEBPACK_IMPORTED_MODULE_4__.GeomUtil.pointInPolygon(spc.px[i], spc.py[i], px, py)) {\n                    if (shortCircuit)\n                        return 1;\n                    hits++;\n                    break;\n                }\n            for (let i = 0; i < psz; i++)\n                if (_util_Geom__WEBPACK_IMPORTED_MODULE_4__.GeomUtil.pointInPolygon(px[i], py[i], spc.px, spc.py)) {\n                    if (shortCircuit)\n                        return 1;\n                    hits++;\n                    break;\n                }\n        }\n        return hits;\n    }\n    adjustBondPosition(bf, bt, x1, y1, x2, y2) {\n        if (bf == 0 || bt == 0)\n            return null;\n        for (let n = 0; n < this.lines.length; n++) {\n            let b = this.lines[n];\n            if (this.mol.bondOrder(b.bnum) != 1 || this.mol.bondType(b.bnum) != _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.BONDTYPE_NORMAL)\n                continue;\n            let alt = false;\n            if (this.mol.bondFrom(b.bnum) == bf && this.mol.bondTo(b.bnum) == bt) { }\n            else if (this.mol.bondFrom(b.bnum) == bt && this.mol.bondTo(b.bnum) == bf)\n                alt = true;\n            else\n                continue;\n            let th = (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.angleDiff)(Math.atan2(b.line.y2 - b.line.y1, b.line.x2 - b.line.x1), Math.atan2(y2 - y1, x2 - x1)) * _util_util__WEBPACK_IMPORTED_MODULE_5__.RADDEG;\n            if ((th > -5 && th < 5) || th > 175 || th < -175)\n                continue;\n            let xy = _util_Geom__WEBPACK_IMPORTED_MODULE_4__.GeomUtil.lineIntersect(b.line.x1, b.line.y1, b.line.x2, b.line.y2, x1, y1, x2, y2);\n            if (this.mol.atomRingBlock(bt) == 0) {\n                if (alt) {\n                    b.line.x1 = xy[0];\n                    b.line.y1 = xy[1];\n                }\n                else {\n                    b.line.x2 = xy[0];\n                    b.line.y2 = xy[1];\n                }\n            }\n            return xy;\n        }\n        return null;\n    }\n    priorityDoubleSubstit(idx) {\n        let bf = this.mol.bondFrom(idx), bt = this.mol.bondTo(idx);\n        let nf = this.mol.atomAdjList(bf), nt = this.mol.atomAdjList(bt);\n        let a1 = this.points[bf - 1], a2 = this.points[bt - 1];\n        let x1 = a1.oval.cx, y1 = a1.oval.cy, x2 = a2.oval.cx, y2 = a2.oval.cy;\n        let dx = x2 - x1, dy = y2 - y1, btheta = Math.atan2(dy, dx);\n        let idxFLeft = 0, idxFRight = 0, idxTLeft = 0, idxTRight = 0;\n        for (let n = 0; n < nf.length; n++)\n            if (nf[n] != bt) {\n                let theta = (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.angleDiff)(Math.atan2(this.points[nf[n] - 1].oval.cy - y1, this.points[nf[n] - 1].oval.cx - x1), btheta);\n                if (theta > 0) {\n                    if (idxFLeft != 0)\n                        return null;\n                    idxFLeft = nf[n];\n                }\n                else {\n                    if (idxFRight != 0)\n                        return null;\n                    idxFRight = nf[n];\n                }\n            }\n        for (let n = 0; n < nt.length; n++)\n            if (nt[n] != bf) {\n                let theta = (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.angleDiff)(Math.atan2(this.points[nt[n] - 1].oval.cy - y2, this.points[nt[n] - 1].oval.cx - x2), btheta);\n                if (theta > 0) {\n                    if (idxTLeft != 0)\n                        return null;\n                    idxTLeft = nt[n];\n                }\n                else {\n                    if (idxTRight != 0)\n                        return null;\n                    idxTRight = nt[n];\n                }\n            }\n        let sumFrom = (idxFLeft > 0 ? 1 : 0) + (idxFRight > 0 ? 1 : 0), sumTo = (idxTLeft > 0 ? 1 : 0) + (idxTRight > 0 ? 1 : 0);\n        if (sumFrom == 1 && sumTo == 0)\n            return [idxFLeft > 0 ? idxFLeft : idxFRight];\n        if (sumFrom == 0 && sumTo == 1)\n            return [idxTLeft > 0 ? idxTLeft : idxTRight];\n        if (sumFrom == 1 && sumTo == 1) {\n            if (idxFLeft > 0 && idxTLeft > 0)\n                return [idxFLeft, idxTLeft];\n            if (idxFRight > 0 && idxTRight > 0)\n                return [idxFRight, idxTRight];\n            let oxy = this.orthogonalDelta(x1, y1, x2, y2, this.bondSepPix);\n            let congestLeft = this.spatialCongestion(0.5 * (x1 + x2) + oxy[0], 0.5 * (y1 + y2) + oxy[1]);\n            let congestRight = this.spatialCongestion(0.5 * (x1 + x2) - oxy[0], 0.5 * (y1 + y2) - oxy[1]);\n            if (congestLeft < congestRight)\n                return [idxFLeft > 0 ? idxFLeft : idxTLeft];\n            else\n                return [idxFRight > 0 ? idxFRight : idxTRight];\n        }\n        if (sumFrom == 2 && sumTo == 1) {\n            if (idxTLeft == 0)\n                return [idxFRight, idxTRight];\n            else\n                return [idxFLeft, idxTLeft];\n        }\n        if (sumFrom == 1 && sumTo == 2) {\n            if (idxFLeft == 0)\n                return [idxFRight, idxTRight];\n            else\n                return [idxFLeft, idxTLeft];\n        }\n        return null;\n    }\n    spatialCongestion(x, y, thresh) {\n        if (thresh == null)\n            thresh = 0.001;\n        let congest = 0;\n        for (let n = 0; n < this.points.length; n++) {\n            let a = this.points[n];\n            if (a == null)\n                continue;\n            let dx = a.oval.cx - x, dy = a.oval.cy - y;\n            congest += 1 / (dx * dx + dy * dy + thresh);\n        }\n        return congest;\n    }\n    annotateAtom(atom, text, col, fsz) {\n        let [tw, ta] = this.measure.measureText(text, fsz);\n        let a = this.points[atom - 1];\n        let cx = a.oval.cx, cy = a.oval.cy, rw = 0.6 * tw, rh = 0.6 * ta;\n        let otherTheta = [];\n        for (let a of this.mol.atomAdjList(atom)) {\n            let dx = this.points[a - 1].oval.cx - cx, dy = this.points[a - 1].oval.cy - cy;\n            otherTheta.push(Math.atan2(dy, dx));\n        }\n        let minExt = 0.5 * (a.oval.rw + a.oval.rh), stepsz = 0.1 * this.scale, nsteps = 8;\n        let angsteps = 36, angsz = _util_util__WEBPACK_IMPORTED_MODULE_5__.TWOPI / angsteps;\n        let bestScore = Number.POSITIVE_INFINITY, bestDX = 0, bestDY = 0;\n        let px = [0, 0, 0, 0], py = [0, 0, 0, 0];\n        let limX = rw + minExt + nsteps * stepsz, limY = rh + minExt + nsteps * stepsz;\n        let subSpace = this.spaceSubset(cx - limX, cy - limY, 2 * limX, 2 * limY);\n        for (let step = 0; step < nsteps; step++) {\n            let ext = minExt + step * stepsz;\n            for (let ang = 0; ang < angsteps; ang++) {\n                let th = angsz * ang;\n                let dx = ext * Math.cos(th), dy = ext * Math.sin(th);\n                let x1 = cx + dx - rw, x2 = cx + dx + rw, y1 = cy + dy - rh, y2 = cy + dy + rh;\n                px[0] = x1;\n                py[0] = y1;\n                px[1] = x2;\n                py[1] = y1;\n                px[2] = x2;\n                py[2] = y2;\n                px[3] = x1;\n                py[3] = y2;\n                let viol = this.countPolyViolations(px, py, subSpace, false);\n                let score = viol * 1000;\n                for (let oth of otherTheta)\n                    score -= Math.abs((0,_util_util__WEBPACK_IMPORTED_MODULE_5__.angleDiff)(th, oth));\n                if (score < bestScore) {\n                    bestScore = score;\n                    bestDX = dx;\n                    bestDY = dy;\n                }\n            }\n            if (bestScore < 500)\n                break;\n        }\n        let x = cx + bestDX, y = cy + bestDY;\n        let an = {\n            'anum': 0,\n            'text': text,\n            'fsz': fsz,\n            'bold': false,\n            'col': col,\n            'oval': new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Oval(x, y, rw, rh),\n        };\n        this.points.push(an);\n        let spc = {\n            'anum': 0,\n            'bnum': 0,\n            'box': new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Box(x - rw, y - rh, 2 * rw, 2 * rh),\n            'px': [x - rw, x + rw, x + rw, x - rw],\n            'py': [y - rh, y - rh, y + rh, y + rh],\n        };\n        this.space.push(spc);\n    }\n    annotateBond(bond, text, col, fsz) {\n        let [tw, ta] = this.measure.measureText(text, fsz);\n        let bfr = this.mol.bondFrom(bond), bto = this.mol.bondTo(bond);\n        let a1 = this.points[bfr - 1], a2 = this.points[bto - 1];\n        let cx = 0.5 * (a1.oval.cx + a2.oval.cx), cy = 0.5 * (a1.oval.cy + a2.oval.cy), rw = 0.6 * tw, rh = 0.6 * ta;\n        let bth = Math.atan2(a2.oval.cy - a1.oval.cy, a2.oval.cx - a1.oval.cx);\n        let otherTheta = [bth, bth + Math.PI];\n        for (let a of this.mol.atomAdjList(bfr))\n            if (a != bto) {\n                let dx = this.points[a - 1].oval.cx - this.points[bfr - 1].oval.cx, dy = this.points[a - 1].oval.cy - this.points[bfr - 1].oval.cy;\n                otherTheta.push(Math.atan2(dy, dx));\n            }\n        for (let a of this.mol.atomAdjList(bto))\n            if (a != bfr) {\n                let dx = this.points[a - 1].oval.cx - this.points[bto - 1].oval.cx, dy = this.points[a - 1].oval.cy - this.points[bto - 1].oval.cy;\n                otherTheta.push(Math.atan2(dy, dx));\n            }\n        let minExt = 0.2 * this.scale * this.bondOrder[bond - 1], stepsz = 0.1 * this.scale, nsteps = 8;\n        let angsteps = 36, angsz = _util_util__WEBPACK_IMPORTED_MODULE_5__.TWOPI / angsteps;\n        let bestScore = Number.POSITIVE_INFINITY, bestDX = 0, bestDY = 0;\n        let px = [0, 0, 0, 0], py = [0, 0, 0, 0];\n        let limX = rw + minExt + nsteps * stepsz, limY = rh + minExt + nsteps * stepsz;\n        let subSpace = this.spaceSubset(cx - limX, cy - limY, 2 * limX, 2 * limY);\n        for (let step = 0; step < nsteps; step++) {\n            let ext = minExt + step * stepsz;\n            for (let ang = 0; ang < angsteps; ang++) {\n                let th = angsz * ang;\n                let dx = ext * Math.cos(th), dy = ext * Math.sin(th);\n                let x1 = cx + dx - rw, x2 = cx + dx + rw, y1 = cy + dy - rh, y2 = cy + dy + rh;\n                px[0] = x1;\n                py[0] = y1;\n                px[1] = x2;\n                py[1] = y1;\n                px[2] = x2;\n                py[2] = y2;\n                px[3] = x1;\n                py[3] = y2;\n                let viol = this.countPolyViolations(px, py, subSpace, false);\n                let score = viol * 1000;\n                for (let oth of otherTheta)\n                    score -= Math.abs((0,_util_util__WEBPACK_IMPORTED_MODULE_5__.angleDiff)(th, oth));\n                if (score < bestScore) {\n                    bestScore = score;\n                    bestDX = dx;\n                    bestDY = dy;\n                }\n            }\n            if (bestScore < 500)\n                break;\n        }\n        let x = cx + bestDX, y = cy + bestDY;\n        let an = {\n            'anum': 0,\n            'text': text,\n            'fsz': fsz,\n            'bold': false,\n            'col': col,\n            'oval': new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Oval(x, y, rw, rh),\n        };\n        this.points.push(an);\n        let spc = {\n            'anum': 0,\n            'bnum': 0,\n            'box': new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Box(x - rw, y - rh, 2 * rw, 2 * rh),\n            'px': [x - rw, x + rw, x + rw, x - rw],\n            'py': [y - rh, y - rh, y + rh, y + rh],\n        };\n        this.space.push(spc);\n    }\n    boxOverlaps(x, y, w, h, pointmask, linemask) {\n        let vx1 = x, vy1 = y, vx2 = x + w, vy2 = y + h;\n        for (let n = 0; n < this.points.length; n++) {\n            if (pointmask != null && !pointmask[n])\n                continue;\n            let a = this.points[n];\n            let wx1 = a.oval.cx - a.oval.rw, wy1 = a.oval.cy - a.oval.rh, wx2 = a.oval.cx + a.oval.rw, wy2 = a.oval.cy + a.oval.rh;\n            if (vx2 < wx1 || vx1 > wx2 || vy2 < wy1 || vy1 > wy2)\n                continue;\n            return true;\n        }\n        for (let n = 0; n < this.lines.length; n++) {\n            if (linemask != null && !linemask[n])\n                continue;\n            let b = this.lines[n];\n            let wx1 = b.line.x1, wy1 = b.line.y1, wx2 = b.line.x2, wy2 = b.line.y2;\n            if (vx2 < Math.min(wx1, wx2) || vx1 > Math.max(wx1, wx2) || vy2 < Math.min(wy1, wy2) || vy1 > Math.max(wy1, wy2))\n                continue;\n            if (wx1 >= vx1 && wx1 <= vx2 && wy1 >= vy1 && wy1 <= vy2)\n                return true;\n            if (wx2 >= vx1 && wx2 <= vx2 && wy2 >= vy1 && wy2 <= vy2)\n                return true;\n            if (_util_Geom__WEBPACK_IMPORTED_MODULE_4__.GeomUtil.doLineSegsIntersect(wx1, wy1, wx2, wy2, vx1, vy1, vx2, vy1))\n                return true;\n            if (_util_Geom__WEBPACK_IMPORTED_MODULE_4__.GeomUtil.doLineSegsIntersect(wx1, wy1, wx2, wy2, vx1, vy2, vx2, vy2))\n                return true;\n            if (_util_Geom__WEBPACK_IMPORTED_MODULE_4__.GeomUtil.doLineSegsIntersect(wx1, wy1, wx2, wy2, vx1, vy1, vx1, vy2))\n                return true;\n            if (_util_Geom__WEBPACK_IMPORTED_MODULE_4__.GeomUtil.doLineSegsIntersect(wx1, wy1, wx2, wy2, vx2, vy1, vx2, vy2))\n                return true;\n        }\n        return false;\n    }\n    resolveLineCrossings(bondHigher, bondLower) {\n        while (true) {\n            let anything = false;\n            for (let i1 = 0; i1 < this.lines.length; i1++) {\n                let b1 = this.lines[i1];\n                if (b1.bnum != bondHigher)\n                    continue;\n                if (b1.type != BLineType.Normal && b1.type != BLineType.Dotted && b1.type != BLineType.DotDir)\n                    continue;\n                for (let i2 = 0; i2 < this.lines.length; i2++) {\n                    let b2 = this.lines[i2];\n                    if (b2.bnum != bondLower)\n                        continue;\n                    if (b2.type == BLineType.DotDir)\n                        b2.type = BLineType.Dotted;\n                    if (b2.type != BLineType.Normal && b2.type != BLineType.Dotted)\n                        continue;\n                    if (b1.bfr == b2.bfr || b1.bfr == b2.bto || b1.bto == b2.bfr || b1.bto == b2.bto)\n                        continue;\n                    if (!_util_Geom__WEBPACK_IMPORTED_MODULE_4__.GeomUtil.doLineSegsIntersect(b1.line.x1, b1.line.y1, b1.line.x2, b1.line.y2, b2.line.x1, b2.line.y1, b2.line.x2, b2.line.y2))\n                        continue;\n                    let xy = _util_Geom__WEBPACK_IMPORTED_MODULE_4__.GeomUtil.lineIntersect(b1.line.x1, b1.line.y1, b1.line.x2, b1.line.y2, b2.line.x1, b2.line.y1, b2.line.x2, b2.line.y2);\n                    let dx = b2.line.x2 - b2.line.x1, dy = b2.line.y2 - b2.line.y1;\n                    let ext = Math.abs(dx) > Math.abs(dy) ? (xy[0] - b2.line.x1) / dx : (xy[1] - b2.line.y1) / dy;\n                    let dist = (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.norm_xy)(dx, dy);\n                    let delta = b2.size / dist * (b2.type == BLineType.Normal ? 2 : 4);\n                    if (ext > delta && ext < 1 - delta) {\n                        let b3 = {\n                            'bnum': b2.bnum,\n                            'bfr': b2.bfr,\n                            'bto': b2.bto,\n                            'type': b2.type,\n                            'line': b2.line.clone(),\n                            'size': b2.size,\n                            'head': b2.head,\n                            'col': b2.col\n                        };\n                        this.lines.push(b3);\n                        b2.line.x2 = b2.line.x1 + dx * (ext - delta);\n                        b2.line.y2 = b2.line.y1 + dy * (ext - delta);\n                        b3.line.x1 = b3.line.x1 + dx * (ext + delta);\n                        b3.line.y1 = b3.line.y1 + dy * (ext + delta);\n                        anything = true;\n                    }\n                    else if (ext > delta) {\n                        b2.line.x2 = b2.line.x1 + dx * (ext - delta);\n                        b2.line.y2 = b2.line.y1 + dy * (ext - delta);\n                        anything = true;\n                    }\n                    else if (ext < 1 - delta) {\n                        b2.line.x1 = b2.line.x1 + dx * (ext + delta);\n                        b2.line.y1 = b2.line.y1 + dy * (ext + delta);\n                        anything = true;\n                    }\n                }\n            }\n            if (!anything)\n                break;\n        }\n    }\n    createCircularRing(atoms) {\n        let cx = 0, cy = 0;\n        for (let a of atoms) {\n            let pt = this.points[a - 1];\n            cx += pt.oval.cx;\n            cy += pt.oval.cy;\n        }\n        cx /= atoms.length;\n        cy /= atoms.length;\n        let bx = [], by = [];\n        let isRegular = true;\n        let regDist = Number.NaN;\n        for (let a of atoms) {\n            let pt = this.points[a - 1];\n            let x0 = pt.oval.cx - cx, y0 = pt.oval.cy - cy, x1 = x0 - pt.oval.rw, x2 = x0 + pt.oval.rw, y1 = y0 - pt.oval.rh, y2 = y0 + pt.oval.rh;\n            bx.push(x1);\n            by.push(y0);\n            bx.push(x1);\n            by.push(y1);\n            bx.push(x1);\n            by.push(y2);\n            bx.push(x0);\n            by.push(y1);\n            bx.push(x0);\n            by.push(y2);\n            bx.push(x2);\n            by.push(y0);\n            bx.push(x2);\n            by.push(y1);\n            bx.push(x2);\n            by.push(y2);\n            let dist = (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.norm_xy)(x0, y0), theta = Math.atan2(y0, x0);\n            const FRACT = 0.7;\n            bx.push(FRACT * dist * Math.cos(theta));\n            by.push(FRACT * dist * Math.sin(theta));\n            for (let b of this.mol.atomAdjList(a))\n                if (atoms.indexOf(b) >= 0) {\n                    let pb = this.points[b - 1];\n                    let mx = 0.5 * (pt.oval.cx + pb.oval.cx) - cx, my = 0.5 * (pt.oval.cy + pb.oval.cy) - cy;\n                    let mdist = (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.norm_xy)(mx, my), mtheta = Math.atan2(my, mx);\n                    bx.push(FRACT * mdist * Math.cos(mtheta));\n                    by.push(FRACT * mdist * Math.sin(mtheta));\n                }\n            if (!isRegular) { }\n            else if (Number.isFinite(regDist)) {\n                if (Math.abs(regDist - dist) > 1)\n                    isRegular = false;\n            }\n            else\n                regDist = dist;\n        }\n        let r = { 'atoms': atoms, 'cx': cx, 'cy': cy, 'rw': 0, 'rh': 0, 'size': 0 };\n        if (isRegular) {\n            r.rw = r.rh = _util_Geom__WEBPACK_IMPORTED_MODULE_4__.GeomUtil.fitCircle(bx, by);\n        }\n        else {\n            let lowX = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.min(bx) - 10 * _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.range(bx), highX = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.max(bx) + 10 * _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.range(bx);\n            let lowY = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.min(by) - 10 * _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.range(by), highY = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.max(by) + 10 * _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.range(by);\n            let minX = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\n            for (let n = 0; n < atoms.length; n++) {\n                let nn = n < atoms.length - 1 ? n + 1 : 0;\n                let p1 = this.points[atoms[n] - 1], p2 = this.points[atoms[nn] - 1];\n                let x1 = p1.oval.cx - cx - 0.1 * (p2.oval.cx - p1.oval.cx), y1 = p1.oval.cy - cy - 0.1 * (p2.oval.cy - p1.oval.cy);\n                let x2 = p2.oval.cx - cx + 0.1 * (p2.oval.cx - p1.oval.cx), y2 = p2.oval.cy - cy + 0.1 * (p2.oval.cy - p1.oval.cy);\n                if (_util_Geom__WEBPACK_IMPORTED_MODULE_4__.GeomUtil.doLineSegsIntersect(x1, y1, x2, y2, lowX, 0, highX, 0)) {\n                    let xy = _util_Geom__WEBPACK_IMPORTED_MODULE_4__.GeomUtil.lineIntersect(x1, y1, x2, y2, lowX, 0, highX, 0);\n                    minX = Math.min(minX, xy[0]);\n                    maxX = Math.max(maxX, xy[0]);\n                }\n                if (_util_Geom__WEBPACK_IMPORTED_MODULE_4__.GeomUtil.doLineSegsIntersect(x1, y1, x2, y2, 0, lowY, 0, highY)) {\n                    let xy = _util_Geom__WEBPACK_IMPORTED_MODULE_4__.GeomUtil.lineIntersect(x1, y1, x2, y2, 0, lowY, 0, highY);\n                    minY = Math.min(minY, xy[1]);\n                    maxY = Math.max(maxY, xy[1]);\n                }\n            }\n            let rwh = _util_Geom__WEBPACK_IMPORTED_MODULE_4__.GeomUtil.fitEllipse(bx, by, minX, minY, maxX, maxY);\n            r.rw = rwh[0];\n            r.rh = rwh[1];\n        }\n        r.size = this.lineSizePix;\n        this.rings.push(r);\n    }\n    createCurvedPath(atoms, fractional, extAtom) {\n        const sz = atoms.length, szn = sz - 1;\n        let x = [], y = [], symbol = [];\n        for (let n = 0; n < sz; n++) {\n            let pt = this.points[atoms[n] - 1];\n            x.push(pt.oval.cx);\n            y.push(pt.oval.cy);\n            symbol.push(pt.text != null);\n        }\n        let ox = [], oy = [];\n        const EXT = _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.IDEALBOND * 0.25 * this.scale;\n        for (let n = 0; n < sz - 1; n++) {\n            let dx = x[n + 1] - x[n], dy = y[n + 1] - y[n], invD = EXT * (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.invZ)((0,_util_util__WEBPACK_IMPORTED_MODULE_5__.norm_xy)(dx, dy));\n            ox.push(dy * invD);\n            oy.push(-dx * invD);\n        }\n        const FAR = 1.2, CLOSE = 0.7;\n        let sx1 = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.numberArray(0, sz), sy1 = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.numberArray(0, sz), sx2 = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.numberArray(0, sz), sy2 = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.numberArray(0, sz);\n        const capA = symbol[0] ? FAR : CLOSE;\n        if (!fractional) {\n            sx1[0] = x[0] + ox[0] * capA;\n            sy1[0] = y[0] + oy[0] * capA;\n            sx2[0] = x[0] - ox[0] * capA;\n            sy2[0] = y[0] - oy[0] * capA;\n        }\n        else {\n            const dx = -oy[0], dy = ox[0];\n            sx1[0] = x[0] + dx * capA;\n            sy1[0] = y[0] + dy * capA;\n            sx2[0] = x[0] + dx * capA;\n            sy2[0] = y[0] + dy * capA;\n        }\n        let ncross1 = 0, ncross2 = 0;\n        for (let n = 1; n < sz - 1; n++) {\n            const fr1 = symbol[n] ? FAR : CLOSE, fr2 = fr1;\n            sx1[n] = x[n] + fr1 * (ox[n - 1] + ox[n]);\n            sy1[n] = y[n] + fr1 * (oy[n - 1] + oy[n]);\n            sx2[n] = x[n] - fr2 * (ox[n - 1] + ox[n]);\n            sy2[n] = y[n] - fr2 * (oy[n - 1] + oy[n]);\n            for (let a of this.mol.atomAdjList(atoms[n]))\n                if (atoms.indexOf(a) < 0 && a != extAtom) {\n                    let pt = this.points[a - 1];\n                    let dx = pt.oval.cx - x[n], dy = pt.oval.cy - y[n];\n                    let dot1 = dx * (sx1[n] - x[n]) + dy * (sy1[n] - x[n]);\n                    let dot2 = dy * (sx2[n] - x[n]) + dy * (sy2[n] - x[n]);\n                    if (dot1 > dot2)\n                        ncross1++;\n                    else\n                        ncross2++;\n                }\n        }\n        let nn = sz - 1;\n        let capB = symbol[nn] ? FAR : CLOSE;\n        if (!fractional) {\n            sx1[nn] = x[nn] + ox[nn - 1] * capB;\n            sy1[nn] = y[nn] + oy[nn - 1] * capB;\n            sx2[nn] = x[nn] - ox[nn - 1] * capB;\n            sy2[nn] = y[nn] - oy[nn - 1] * capB;\n        }\n        else {\n            let dx = -oy[nn - 1], dy = ox[nn - 1];\n            sx1[nn] = x[nn] - dx * capB;\n            sy1[nn] = y[nn] - dy * capB;\n            sx2[nn] = x[nn] - dx * capB;\n            sy2[nn] = y[nn] - dy * capB;\n        }\n        let score1 = 0, score2 = 0;\n        for (let n = 0; n < sz - 1; n++) {\n            score1 += (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.norm_xy)(sx1[n + 1] - sx1[n], sy1[n + 1] - sy1[n]);\n            score2 += (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.norm_xy)(sx2[n + 1] - sx2[n], sy2[n + 1] - sy2[n]);\n        }\n        score1 *= ncross1 + 1;\n        score2 *= ncross2 + 1;\n        let sx = score1 < score2 ? sx1 : sx2;\n        let sy = score1 < score2 ? sy1 : sy2;\n        let p = { 'atoms': atoms, 'px': null, 'py': null, 'ctrl': null, 'size': this.lineSizePix };\n        this.splineInterpolate(p, sx, sy);\n        this.paths.push(p);\n    }\n    createBondCentroid(from, to) {\n        let pt = this.points[from - 1];\n        let x1 = pt.oval.cx, y1 = pt.oval.cy, x2 = 0, y2 = 0;\n        for (let a of to) {\n            pt = this.points[a - 1];\n            x2 += pt.oval.cx;\n            y2 += pt.oval.cy;\n        }\n        x2 /= to.length;\n        y2 /= to.length;\n        if (to.length <= 2) {\n            x2 -= 0.1 * (x2 - x1);\n            y2 -= 0.1 * (y2 - y1);\n        }\n        const minDist = MINBOND_LINE * this.measure.scale();\n        let xy1 = this.backOffAtom(from, x1, y1, x2, y2, minDist);\n        this.ensureMinimumBondLength(xy1, [x2, y2], x1, y1, x2, y2, minDist);\n        let b = {\n            'bnum': 0, 'bfr': from, 'bto': 0,\n            'type': BLineType.Normal, 'line': new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Line(xy1[0], xy1[1], x2, y2),\n            'size': this.lineSizePix, 'head': 0, 'col': this.policy.data.foreground\n        };\n        this.lines.push(b);\n        this.space.push(this.computeSpaceLine(b));\n    }\n    splineInterpolate(path, x, y) {\n        const sz = x.length;\n        const scale = 0.25;\n        for (let n = 0; n < sz; n++) {\n            if (n == 0) {\n                let dx = x[n + 1] - x[n], dy = y[n + 1] - y[n];\n                let qx = x[n] + scale * dx, qy = y[n] + scale * dy;\n                path.px = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.append(path.px, x[n]);\n                path.py = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.append(path.py, y[n]);\n                path.ctrl = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.append(path.ctrl, false);\n                path.px = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.append(path.px, qx);\n                path.py = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.append(path.py, qy);\n                path.ctrl = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.append(path.ctrl, true);\n            }\n            else if (n == sz - 1) {\n                let dx = x[n] - x[n - 1], dy = y[n] - y[n - 1];\n                let qx = x[n] - scale * dx, qy = y[n] - scale * dy;\n                path.px = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.append(path.px, qx);\n                path.py = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.append(path.py, qy);\n                path.ctrl = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.append(path.ctrl, true);\n                path.px = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.append(path.px, x[n]);\n                path.py = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.append(path.py, y[n]);\n                path.ctrl = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.append(path.ctrl, false);\n            }\n            else {\n                let dx = x[n + 1] - x[n - 1], dy = y[n + 1] - y[n - 1];\n                let invD = (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.invZ)((0,_util_util__WEBPACK_IMPORTED_MODULE_5__.norm_xy)(dx, dy));\n                dx *= invD;\n                dy *= invD;\n                let d1 = scale * (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.norm_xy)(x[n] - x[n - 1], y[n] - y[n - 1]), d2 = scale * (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.norm_xy)(x[n + 1] - x[n], y[n + 1] - y[n]);\n                let qx1 = x[n] - dx * d1, qy1 = y[n] - dy * d1;\n                let qx2 = x[n] + dx * d2, qy2 = y[n] + dy * d2;\n                path.px = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.append(path.px, qx1);\n                path.py = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.append(path.py, qy1);\n                path.ctrl = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.append(path.ctrl, true);\n                path.px = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.append(path.px, x[n]);\n                path.py = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.append(path.py, y[n]);\n                path.ctrl = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.append(path.ctrl, false);\n                path.px = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.append(path.px, qx2);\n                path.py = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.append(path.py, qy2);\n                path.ctrl = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.append(path.ctrl, true);\n            }\n        }\n    }\n    delocalisedAnnotation(atoms, charge, unpaired) {\n        const mol = this.mol;\n        let str = '';\n        if (charge == -1)\n            str = '-';\n        else if (charge == 1)\n            str = '+';\n        else if (charge < -1)\n            str = Math.abs(charge) + '-';\n        else if (charge > 1)\n            str = charge + '+';\n        if (unpaired > 0)\n            for (let n = 0; n < unpaired; n++)\n                str += '.';\n        if (str.length == 0)\n            return;\n        const sz = atoms.length;\n        let bestX = 0, bestY = 0;\n        for (let a of atoms) {\n            bestX += mol.atomX(a);\n            bestY += mol.atomY(a);\n        }\n        bestX /= sz;\n        bestY /= sz;\n        let bestScore = _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.congestionPoint(mol, bestX, bestY);\n        for (let n = 1; n < sz - 1; n++) {\n            let x = 0.5 * (mol.atomX(atoms[n - 1]) + mol.atomX(atoms[n + 1])), y = 0.5 * (mol.atomY(atoms[n - 1]) + mol.atomY(atoms[n + 1]));\n            let score = _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.congestionPoint(mol, x, y);\n            if (score < bestScore) {\n                bestScore = score;\n                bestX = x;\n                bestY = y;\n            }\n        }\n        let fsz = 0.8 * this.fontSizePix;\n        let wad = this.measure.measureText(str, fsz);\n        let rw = 0.55 * wad[0], rh = 0.55 * wad[1];\n        let a = {\n            'anum': 0,\n            'text': str,\n            'fsz': fsz,\n            'bold': false,\n            'col': this.policy.data.foreground,\n            'oval': new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Oval(this.measure.angToX(bestX), this.measure.angToY(bestY), rw, rh)\n        };\n        this.points.push(a);\n        let spc = {\n            'anum': 0,\n            'bnum': 0,\n            'box': new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Box(a.oval.cx - rw, a.oval.cy - rh, 2 * rw, 2 * rh),\n            'px': [a.oval.cx - rw, a.oval.cx + rw, a.oval.cx + rw, a.oval.cx - rw],\n            'py': [a.oval.cy - rh, a.oval.cy - rh, a.oval.cy + rh, a.oval.cy + rh]\n        };\n        this.space.push(spc);\n    }\n    processPolymerUnit(unit, allUnits) {\n        if (_util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.len(unit.bondConn) == 4) {\n            this.processPolymerUnitPair(unit);\n            return;\n        }\n        let brackets = [];\n        const { mol, measure } = this;\n        for (let n = 1; n <= mol.numBonds; n++) {\n            let a1 = mol.bondFrom(n), a2 = mol.bondTo(n);\n            let in1 = unit.atoms.indexOf(a1) >= 0, in2 = unit.atoms.indexOf(a2) >= 0;\n            let bracket = null;\n            if (in1 && !in2)\n                bracket = { a1, a2 };\n            else if (in2 && !in1)\n                bracket = { 'a1': a2, 'a2': a1 };\n            else\n                continue;\n            bracket.x1 = mol.atomX(bracket.a1);\n            bracket.y1 = mol.atomY(bracket.a1);\n            bracket.x2 = mol.atomX(bracket.a2);\n            bracket.y2 = mol.atomY(bracket.a2);\n            bracket.shared = false;\n            for (let other of allUnits)\n                if (unit !== other && other.atoms.includes(bracket.a2)) {\n                    bracket.shared = true;\n                    break;\n                }\n            let nestings = allUnits.filter((look) => look === unit || (look.atoms.includes(bracket.a1) && !look.atoms.includes(bracket.a2)));\n            if (nestings.length > 1) {\n                nestings.sort((u1, u2) => u1.atoms.length - u2.atoms.length);\n                for (let i = 0; i < nestings.length; i++)\n                    if (nestings[i] === unit)\n                        bracket.nestOrder = i;\n                bracket.nestCount = nestings.length;\n            }\n            brackets.push(bracket);\n        }\n        let tagidx = 0;\n        let atomX = unit.atoms.map((a) => mol.atomX(a)), atomY = unit.atoms.map((a) => mol.atomY(a));\n        let minX = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.min(atomX), minY = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.min(atomY);\n        let maxX = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.max(atomX), maxY = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.max(atomY);\n        for (let n = 1; n < brackets.length; n++) {\n            let b1 = brackets[tagidx], b2 = brackets[n];\n            let score1 = b1.x2 - minX - b1.y2 + minY;\n            let score2 = b2.x2 - minX - b2.y2 + minY;\n            if (score2 > score1)\n                tagidx = n;\n        }\n        let isLinear = false, isOuter = false;\n        if (brackets.length == 2) {\n            let left = brackets[tagidx == 0 ? 1 : 0], right = brackets[tagidx];\n            let theta1 = Math.atan2(left.y2 - left.y1, left.x2 - left.x1);\n            let theta2 = Math.atan2(right.y2 - right.y1, right.x2 - right.x1);\n            isLinear = (theta1 > 145 * _util_util__WEBPACK_IMPORTED_MODULE_5__.DEGRAD || theta1 < -145 * _util_util__WEBPACK_IMPORTED_MODULE_5__.DEGRAD) && theta2 < 35 * _util_util__WEBPACK_IMPORTED_MODULE_5__.DEGRAD && theta2 > -35 * _util_util__WEBPACK_IMPORTED_MODULE_5__.DEGRAD;\n        }\n        else if (brackets.length == 0) {\n            let ym = 0.5 * (minY + maxY);\n            brackets.push({ 'x1': minX, 'y1': ym, 'x2': minX - 1, 'y2': ym });\n            brackets.push({ 'x1': maxX, 'y1': ym, 'x2': maxX + 1, 'y2': ym });\n            tagidx = 1;\n            isOuter = true;\n        }\n        let bsz1 = (isOuter ? 0.5 * (maxY - minY + 1) : isLinear ? 1.0 : 0.5) * this.scale, bsz2 = 0.2 * this.scale;\n        const BASE_LINE = { 'bnum': 0, 'bfr': 0, 'bto': 0, 'type': BLineType.Normal, 'size': this.lineSizePix, 'head': 0, 'col': this.policy.data.foreground };\n        const BASE_TEXT = { 'anum': 0, 'fsz': 0.7 * this.fontSizePix, 'bold': false, 'col': this.policy.data.foreground };\n        for (let n = 0; n < brackets.length; n++) {\n            let bracket = brackets[n];\n            let x1 = measure.angToX(bracket.x1), y1 = measure.angToY(bracket.y1);\n            let x2 = measure.angToX(bracket.x2), y2 = measure.angToY(bracket.y2);\n            if (bracket.shared) {\n                x2 -= (x2 - x1) * 0.1;\n                y2 -= (y2 - y1) * 0.1;\n            }\n            if (bracket.nestCount > 1) {\n                let dx = x2 - x1, dy = y2 - y1, fract = (bracket.nestOrder + 1) / bracket.nestCount;\n                x2 = x1 + dx * fract;\n                y2 = y1 + dy * fract;\n            }\n            let mx = 0.5 * (x1 + x2), my = 0.5 * (y1 + y2);\n            if (isLinear) {\n                x1 = x2 = mx;\n                y1 = y2 = my;\n                if (n == tagidx) {\n                    x1--;\n                    x2++;\n                }\n                else {\n                    x1++;\n                    x2--;\n                }\n            }\n            let invDist = (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.invZ)((0,_util_util__WEBPACK_IMPORTED_MODULE_5__.norm_xy)(x2 - x1, y2 - y1));\n            let dx = (x2 - x1) * invDist, dy = (y2 - y1) * invDist;\n            let ox = dy, oy = -dx;\n            let px2 = mx - bsz1 * ox, py2 = my - bsz1 * oy;\n            let px3 = mx + bsz1 * ox, py3 = my + bsz1 * oy;\n            let px1 = px2 - bsz2 * dx, py1 = py2 - bsz2 * dy;\n            let px4 = px3 - bsz2 * dx, py4 = py3 - bsz2 * dy;\n            let line1 = Object.assign(Object.assign({}, BASE_LINE), { 'line': new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Line(px1, py1, px2, py2) });\n            let line2 = Object.assign(Object.assign({}, BASE_LINE), { 'line': new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Line(px2, py2, px3, py3) });\n            let line3 = Object.assign(Object.assign({}, BASE_LINE), { 'line': new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Line(px3, py3, px4, py4) });\n            this.lines.push(line1);\n            this.lines.push(line2);\n            this.lines.push(line3);\n            this.space.push(this.computeSpaceLine(line1));\n            this.space.push(this.computeSpaceLine(line2));\n            this.space.push(this.computeSpaceLine(line3));\n            if (n == tagidx) {\n                let xx, yy;\n                if (bracket.shared)\n                    [xx, yy] = [px2 - 0.5 * this.scale * ox, py2 - 0.5 * this.scale * oy];\n                else\n                    [xx, yy] = [px2 + bsz2 * 2 * dx, py2 + bsz2 * 2 * dy];\n                let pt1 = Object.assign(Object.assign({}, BASE_TEXT), { 'text': 'n', 'oval': new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Oval(xx, yy, 0, 0) });\n                this.points.push(pt1);\n                this.space.push(this.computeSpacePoint(pt1));\n                if (unit.connect != null) {\n                    let text = '?';\n                    if (unit.connect == _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_3__.PolymerBlockConnectivity.HeadToTail)\n                        text = 'ht';\n                    else if (unit.connect == _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_3__.PolymerBlockConnectivity.HeadToHead)\n                        text = 'hh';\n                    else if (unit.connect == _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_3__.PolymerBlockConnectivity.Random)\n                        text = 'eu';\n                    if (bracket.shared)\n                        [xx, yy] = [px3 + 0.5 * this.scale * ox, py3 + 0.5 * this.scale * oy];\n                    else\n                        [xx, yy] = [px3 + bsz2 * 2.5 * dx, py3 + bsz2 * 2.5 * dy];\n                    let pt2 = Object.assign(Object.assign({}, BASE_TEXT), { 'text': text, 'oval': new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Oval(xx, yy, 0, 0) });\n                    this.points.push(pt2);\n                    this.space.push(this.computeSpacePoint(pt2));\n                }\n            }\n        }\n    }\n    processPolymerUnitPair(unit) {\n        const { mol, measure } = this;\n        let xpos = [], ypos = [];\n        for (let b of unit.bondConn) {\n            let bfr = mol.bondFrom(b), bto = mol.bondTo(b);\n            xpos.push(measure.angToX(0.5 * (mol.atomX(bfr) + mol.atomX(bto))));\n            ypos.push(measure.angToY(0.5 * (mol.atomY(bfr) + mol.atomY(bto))));\n        }\n        let cx = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.sum(xpos) * 0.25, cy = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.sum(ypos) * 0.25;\n        let bsz = 0.5 * this.scale;\n        let rx = [], ry = [];\n        for (let [i1, i2] of [[0, 1], [2, 3]]) {\n            let dx = xpos[i2] - xpos[i1], dy = ypos[i2] - ypos[i1], inv = bsz * (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.invZ)((0,_util_util__WEBPACK_IMPORTED_MODULE_5__.norm_xy)(dx, dy) + 0.001);\n            [dx, dy] = [dx * inv, dy * inv];\n            xpos[i1] -= 2 * dx;\n            ypos[i1] -= 2 * dy;\n            xpos[i2] += 2 * dx;\n            ypos[i2] += 2 * dy;\n            let ox = dy, oy = -dx;\n            let dsq1 = (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.norm2_xy)(0.5 * (xpos[i1] + xpos[i2]) + ox - cx, 0.5 * (ypos[i1] + ypos[i2]) + oy - cy);\n            let dsq2 = (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.norm2_xy)(0.5 * (xpos[i1] + xpos[i2]) - ox - cx, 0.5 * (ypos[i1] + ypos[i2]) - oy - cy);\n            if (dsq2 < dsq1)\n                [ox, oy] = [-ox, -oy];\n            rx.push(...[ox, ox]);\n            ry.push(...[oy, oy]);\n        }\n        const BASE_LINE = { 'bnum': 0, 'bfr': 0, 'bto': 0, 'type': BLineType.Normal, 'size': this.lineSizePix, 'head': 0, 'col': this.policy.data.foreground };\n        const BASE_TEXT = { 'anum': 0, 'fsz': 0.7 * this.fontSizePix, 'bold': false, 'col': this.policy.data.foreground };\n        let drawLine = (x1, y1, x2, y2) => {\n            let line = Object.assign(Object.assign({}, BASE_LINE), { 'line': new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Line(x1, y1, x2, y2) });\n            this.lines.push(line);\n            this.space.push(this.computeSpaceLine(line));\n        };\n        let drawText = (x, y, txt) => {\n            let pt = Object.assign(Object.assign({}, BASE_TEXT), { 'text': txt, 'oval': new _util_Geom__WEBPACK_IMPORTED_MODULE_4__.Oval(x, y, 0, 0) });\n            this.points.push(pt);\n            this.space.push(this.computeSpacePoint(pt));\n        };\n        drawLine(xpos[0], ypos[0], xpos[1], ypos[1]);\n        drawLine(xpos[0], ypos[0], xpos[0] + rx[0], ypos[0] + ry[0]);\n        drawLine(xpos[1], ypos[1], xpos[1] + rx[1], ypos[1] + ry[1]);\n        drawLine(xpos[2], ypos[2], xpos[3], ypos[3]);\n        drawLine(xpos[2], ypos[2], xpos[2] + rx[2], ypos[2] + ry[2]);\n        drawLine(xpos[3], ypos[3], xpos[3] + rx[3], ypos[3] + ry[3]);\n        let xmin = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.min(xpos), ymin = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.min(ypos);\n        let dist = [];\n        for (let n = 0; n < 4; n++)\n            dist.push(xpos[n] - xmin + ypos[n] - ymin);\n        let idxN = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.idxMax(dist);\n        drawText(xpos[idxN] - rx[idxN], ypos[idxN] - ry[idxN], 'n');\n        let idxD2 = idxN + (idxN % 2 == 1 ? -1 : 1), idxD1 = (idxD2 + 2) % 4;\n        drawText(xpos[idxD1] - 0.5 * rx[idxD1], ypos[idxD1] - 0.5 * ry[idxD1], '*');\n        drawText(xpos[idxD2] - 0.5 * rx[idxD2], ypos[idxD2] - 0.5 * ry[idxD2], '*');\n    }\n}\nArrangeMolecule.FONT_CORRECT = 1.5;\n\n\n//# sourceURL=webpack://WebMolKit/./src/gfx/ArrangeMolecule.ts?");

/***/ }),

/***/ "./src/gfx/AxisLabeller.ts":
/*!*********************************!*\
  !*** ./src/gfx/AxisLabeller.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AxisLabeller\": () => (/* binding */ AxisLabeller)\n/* harmony export */ });\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n\nclass AxisLabeller {\n    constructor(width, minVal, maxVal, textWidth, inverse) {\n        this.width = width;\n        this.minVal = minVal;\n        this.maxVal = maxVal;\n        this.textWidth = textWidth;\n        this.inverse = inverse;\n        this.notches = [];\n    }\n    calculate() {\n        if (this.minVal == this.maxVal) {\n            this.notches.push({\n                'label': this.minVal.toString(),\n                'value': this.minVal,\n                'pos': 0.5 * this.width\n            });\n            return;\n        }\n        const width = this.width, minVal = this.minVal, maxVal = this.maxVal;\n        const range = maxVal - minVal, invRange = 1.0 / range;\n        let position = (val) => width * (val - minVal) * invRange;\n        let loT = null, hiT = null;\n        const bumpLess = 1 - 1E-5, bumpMore = 1 + 1E-5;\n        got: for (let outer = 1E-10; outer <= 1E11; outer *= 10)\n            for (let inner of [0.2, 0.5, 1]) {\n                let mag = outer * inner, inv = 1.0 / mag;\n                let t1 = Math.floor(minVal * mag * bumpLess) * inv, t2 = Math.round(minVal * mag) * inv, t3 = Math.ceil(minVal * mag * bumpMore) * inv;\n                let t4 = Math.floor(maxVal * mag * bumpLess) * inv, t5 = Math.round(maxVal * mag) * inv, t6 = Math.ceil(maxVal * mag * bumpMore) * inv;\n                let p1 = position(t1), p2 = position(t2), p3 = position(t3);\n                let p4 = position(t4), p5 = position(t5), p6 = position(t6);\n                if (((0,_util_util__WEBPACK_IMPORTED_MODULE_0__.fltEqual)(p1, 0) || p1 >= 0) && p1 <= 0.1 * width)\n                    loT = t1;\n                else if (((0,_util_util__WEBPACK_IMPORTED_MODULE_0__.fltEqual)(p2, 0) || p2 >= 0) && p2 <= 0.1 * width)\n                    loT = t2;\n                else if (((0,_util_util__WEBPACK_IMPORTED_MODULE_0__.fltEqual)(p3, 0) || p3 >= 0) && p3 <= 0.1 * width)\n                    loT = t3;\n                else\n                    continue;\n                if (p6 >= 0.9 * width && ((0,_util_util__WEBPACK_IMPORTED_MODULE_0__.fltEqual)(p6, width) || p6 <= width))\n                    hiT = t6;\n                else if (p5 >= 0.9 * width && ((0,_util_util__WEBPACK_IMPORTED_MODULE_0__.fltEqual)(p5, width) || p5 <= width))\n                    hiT = t5;\n                else if (p4 >= 0.9 * width && ((0,_util_util__WEBPACK_IMPORTED_MODULE_0__.fltEqual)(p4, width) || p4 <= width))\n                    hiT = t4;\n                else\n                    continue;\n                break got;\n            }\n        if (loT == null || hiT == null)\n            return;\n        let loVal = this.inverse(loT), hiVal = this.inverse(hiT);\n        this.notches.push({\n            'label': this.formatNumber(loVal),\n            'value': loVal,\n            'pos': position(loT)\n        });\n        this.notches.push({\n            'label': this.formatNumber(hiVal),\n            'value': hiVal,\n            'pos': position(hiT)\n        });\n    }\n    formatNumber(num) {\n        let str = num.toPrecision(4);\n        str = str.replace(/^(-?\\d+)\\.0+$/, '$1');\n        str = str.replace(/^(-?\\d+\\.0*[1-9]+)0+$/, '$1');\n        str = str.replace(/^(-?\\d+)\\.0+(e[\\+\\-]\\d+)$/, '$1$2');\n        str = str.replace(/^(-?\\d+\\.0*[1-9]+)0+(e[\\+\\-]\\d+)$/, '$1$2');\n        return str;\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/gfx/AxisLabeller.ts?");

/***/ }),

/***/ "./src/gfx/DrawExperiment.ts":
/*!***********************************!*\
  !*** ./src/gfx/DrawExperiment.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DrawExperiment\": () => (/* binding */ DrawExperiment)\n/* harmony export */ });\n/* harmony import */ var _data_MolUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/MolUtil */ \"./src/data/MolUtil.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _ArrangeExperiment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ArrangeExperiment */ \"./src/gfx/ArrangeExperiment.ts\");\n/* harmony import */ var _ArrangeMolecule__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ArrangeMolecule */ \"./src/gfx/ArrangeMolecule.ts\");\n/* harmony import */ var _DrawMolecule__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DrawMolecule */ \"./src/gfx/DrawMolecule.ts\");\n/* harmony import */ var _MetaVector__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./MetaVector */ \"./src/gfx/MetaVector.ts\");\n/* harmony import */ var _Rendering__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Rendering */ \"./src/gfx/Rendering.ts\");\n\n\n\n\n\n\n\n\nclass DrawExperiment {\n    constructor(layout, vg) {\n        this.layout = layout;\n        this.vg = vg;\n        this.preDrawComponent = null;\n        this.preDrawMolecule = null;\n        this.postDrawMolecule = null;\n        this.molDrawn = [];\n        this.entry = layout.entry;\n        this.measure = layout.measure;\n        this.policy = layout.policy;\n        this.scale = layout.scale;\n        this.invScale = 1.0 / this.scale;\n    }\n    draw() {\n        this.molDrawn = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.anyArray(null, this.layout.components.length);\n        for (let n = 0; n < this.layout.components.length; n++) {\n            let xc = this.layout.components[n];\n            if (xc.type == _ArrangeExperiment__WEBPACK_IMPORTED_MODULE_3__.ArrangeComponentType.Arrow)\n                this.drawSymbolArrow(xc);\n            else if (xc.type == _ArrangeExperiment__WEBPACK_IMPORTED_MODULE_3__.ArrangeComponentType.Plus)\n                this.drawSymbolPlus(xc);\n            else\n                this.drawComponent(n, xc);\n        }\n    }\n    drawComponent(idx, xc) {\n        let vg = this.vg, policy = this.policy;\n        let bx = xc.box.x + xc.padding, by = xc.box.y + xc.padding;\n        let bw = xc.box.w - 2 * xc.padding, bh = xc.box.h - 2 * xc.padding;\n        if (this.preDrawComponent)\n            this.preDrawComponent(vg, idx, xc);\n        if (xc.srcIdx < 0 || (_data_MolUtil__WEBPACK_IMPORTED_MODULE_0__.MolUtil.isBlank(xc.mol) && _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.isBlank(xc.text))) {\n            let fsz = 0.5 * bh;\n            vg.drawText(bx + 0.5 * bw, by + 0.5 * bh, '?', fsz, policy.data.foreground, _MetaVector__WEBPACK_IMPORTED_MODULE_6__.TextAlign.Centre | _MetaVector__WEBPACK_IMPORTED_MODULE_6__.TextAlign.Middle);\n            return;\n        }\n        if (_util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.notBlank(xc.text)) {\n            let wad = this.measure.measureText('!', xc.fszText), th = wad[1] + wad[2];\n            let totalH = th * xc.text.length;\n            let ty = by + bh - th * (xc.text.length - 1);\n            for (let line of xc.text) {\n                let wad = this.measure.measureText(line, xc.fszText);\n                vg.drawText(bx + 0.5 * bw, ty, line, xc.fszText, policy.data.foreground, _MetaVector__WEBPACK_IMPORTED_MODULE_6__.TextAlign.Centre | _MetaVector__WEBPACK_IMPORTED_MODULE_6__.TextAlign.Baseline);\n                ty += th;\n            }\n            bh -= totalH + 0.5 * xc.fszText;\n        }\n        if (xc.leftNumer) {\n            let wad1 = this.measure.measureText(xc.leftNumer, xc.fszLeft);\n            if (!xc.leftDenom) {\n                vg.drawText(bx, by + 0.5 * bh, xc.leftNumer, xc.fszLeft, policy.data.foreground, _MetaVector__WEBPACK_IMPORTED_MODULE_6__.TextAlign.Left | _MetaVector__WEBPACK_IMPORTED_MODULE_6__.TextAlign.Middle);\n                let useW = wad1[0] + _ArrangeExperiment__WEBPACK_IMPORTED_MODULE_3__.ArrangeExperiment.COMP_GAP_LEFT * (wad1[1] + wad1[2]);\n                bx += useW;\n                bw -= useW;\n            }\n            else {\n                let wad2 = this.measure.measureText(xc.leftDenom, xc.fszLeft);\n                let tw = Math.max(wad1[0], wad2[0]);\n                let x = bx + 0.5 * tw, y = by + 0.5 * bh;\n                vg.drawText(x, y, xc.leftNumer, xc.fszLeft, policy.data.foreground, _MetaVector__WEBPACK_IMPORTED_MODULE_6__.TextAlign.Centre | _MetaVector__WEBPACK_IMPORTED_MODULE_6__.TextAlign.Bottom);\n                vg.drawText(x, y + wad1[2], xc.leftDenom, xc.fszLeft, policy.data.foreground, _MetaVector__WEBPACK_IMPORTED_MODULE_6__.TextAlign.Centre | _MetaVector__WEBPACK_IMPORTED_MODULE_6__.TextAlign.Top);\n                vg.drawLine(bx, y, bx + tw, y, policy.data.foreground, this.scale * 0.03);\n                let useW = tw + _ArrangeExperiment__WEBPACK_IMPORTED_MODULE_3__.ArrangeExperiment.COMP_GAP_LEFT * (wad1[1] + wad1[2]);\n                bx += useW;\n                bw -= useW;\n            }\n        }\n        if (xc.annot != 0) {\n            let aw = _ArrangeExperiment__WEBPACK_IMPORTED_MODULE_3__.ArrangeExperiment.COMP_ANNOT_SIZE * this.scale;\n            bw -= aw;\n            this.drawAnnotation(xc.annot, bx + bw, by, aw, bh);\n        }\n        if (_data_MolUtil__WEBPACK_IMPORTED_MODULE_0__.MolUtil.notBlank(xc.mol)) {\n            let effects = new _Rendering__WEBPACK_IMPORTED_MODULE_7__.RenderEffects();\n            if (this.layout.includeAtomMap) {\n                effects.atomDecoText = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.stringArray('', xc.mol.numAtoms);\n                effects.atomDecoCol = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.numberArray(this.layout.colourAtomMap, xc.mol.numAtoms);\n                effects.atomDecoSize = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.numberArray(0.3, xc.mol.numAtoms);\n                for (let n = 1; n <= xc.mol.numAtoms; n++)\n                    if (xc.mol.atomMapNum(n) > 0)\n                        effects.atomDecoText[n - 1] = xc.mol.atomMapNum(n).toString();\n            }\n            let arrmol = new _ArrangeMolecule__WEBPACK_IMPORTED_MODULE_4__.ArrangeMolecule(xc.mol, this.layout.measure, policy, effects);\n            arrmol.arrange();\n            arrmol.squeezeInto(bx, by, bw, bh, 0);\n            if (this.preDrawMolecule)\n                this.preDrawMolecule(vg, idx, xc, arrmol);\n            let drawmol = new _DrawMolecule__WEBPACK_IMPORTED_MODULE_5__.DrawMolecule(arrmol, vg);\n            drawmol.draw();\n            if (this.postDrawMolecule)\n                this.postDrawMolecule(vg, idx, xc, arrmol);\n            this.molDrawn[idx] = arrmol;\n        }\n    }\n    drawSymbolArrow(xc) {\n        let bx = xc.box.x + xc.padding, by = xc.box.y + xc.padding;\n        let bw = xc.box.w - 2 * xc.padding, bh = xc.box.h - 2 * xc.padding;\n        if (bw > bh)\n            this.drawArrow(bx, by + 0.5 * bh, bx + bw, by + 0.5 * bh, bh, this.policy.data.foreground, this.scale * 0.05);\n        else\n            this.drawArrow(bx + 0.5 * bw, by, bx + 0.5 * bw, by + bh, bw, this.policy.data.foreground, this.scale * 0.05);\n    }\n    drawSymbolPlus(xc) {\n        let vg = this.vg, policy = this.policy;\n        let x1 = xc.box.x + xc.padding, y1 = xc.box.y + xc.padding;\n        let x3 = x1 + xc.box.w - 2 * xc.padding, y3 = y1 + xc.box.h - 2 * xc.padding;\n        let x2 = 0.5 * (x1 + x3), y2 = 0.5 * (y1 + y3);\n        let lw = 0.2 * 0.5 * (x3 - x1 + y3 - y1);\n        vg.drawLine(x1, y2, x3, y2, policy.data.foreground, lw);\n        vg.drawLine(x2, y1, x2, y3, policy.data.foreground, lw);\n    }\n    drawAnnotation(annot, bx, by, bw, bh) {\n        let vg = this.vg, policy = this.policy;\n        let sz = bw, x2 = bx + bw, y2 = by + bh, x1 = x2 - sz, y1 = by;\n        if (annot == _ArrangeExperiment__WEBPACK_IMPORTED_MODULE_3__.ArrangeComponentAnnot.Primary)\n            y2 = y1 + sz;\n        else if (annot == _ArrangeExperiment__WEBPACK_IMPORTED_MODULE_3__.ArrangeComponentAnnot.Waste)\n            y1 = y2 - sz;\n        if (annot == _ArrangeExperiment__WEBPACK_IMPORTED_MODULE_3__.ArrangeComponentAnnot.Primary) {\n            let cx = 0.5 * (x1 + x2), cy = 0.5 * (y1 + y2), ext = 0.25 * sz;\n            let px = [cx, cx + 0.866 * ext, cx + 0.866 * ext, cx, cx - 0.866 * ext, cx - 0.866 * ext];\n            let py = [cy - ext, cy - 0.5 * ext, cy + 0.5 * ext, cy + ext, cy + 0.5 * ext, cy - 0.5 * ext];\n            let lw = 0.05 * this.scale;\n            vg.drawLine(px[0], py[0], px[3], py[3], policy.data.foreground, lw);\n            vg.drawLine(px[1], py[1], px[4], py[4], policy.data.foreground, lw);\n            vg.drawLine(px[2], py[2], px[5], py[5], policy.data.foreground, lw);\n            let inset = 0.1 * sz;\n            vg.drawOval(x1 + 0.5 * sz, y1 + 0.5 * sz, 0.5 * sz - inset, 0.5 * sz - inset, policy.data.foreground, lw, _MetaVector__WEBPACK_IMPORTED_MODULE_6__.MetaVector.NOCOLOUR);\n        }\n        else if (annot == _ArrangeExperiment__WEBPACK_IMPORTED_MODULE_3__.ArrangeComponentAnnot.Waste) {\n            let cx = x1 + 0.7 * sz, cy = 0.5 * (y1 + y2), quart = 0.25 * sz;\n            let lw = 0.05 * this.scale;\n            let px = [x1 + 0.1 * sz, cx - quart, cx, cx, cx];\n            let py = [y1, y1, y1, cy - quart, cy];\n            let ctrl = [false, false, true, false, false];\n            vg.drawPath(px, py, ctrl, false, policy.data.foreground, lw, _MetaVector__WEBPACK_IMPORTED_MODULE_6__.MetaVector.NOCOLOUR, false);\n            for (let n = 0; n < 4; n++) {\n                let y = cy + n * 0.45 * sz * (1.0 / 3), dw = (3.1 - n) * 0.1 * sz;\n                vg.drawLine(cx - dw, y, cx + dw, y, policy.data.foreground, lw);\n            }\n        }\n        else if (annot == _ArrangeExperiment__WEBPACK_IMPORTED_MODULE_3__.ArrangeComponentAnnot.Implied) {\n            let tw = 0.5 * sz, th = 0.75 * sz;\n            let cx = x2 - 0.5 * tw, cy = y1 + 0.5 * th;\n            let ty = y1 + 0.25 * th, dsz = sz * 0.1, hsz = 0.5 * dsz;\n            let lw = 0.05 * this.scale, fg = policy.data.foreground;\n            vg.drawLine(cx, y1, cx, y1 + th, fg, lw);\n            vg.drawLine(x2 - tw, ty, x2, ty, fg, lw);\n            vg.drawLine(x2 - tw, cy, x2, cy, fg, lw);\n            vg.drawOval(x2 - tw + hsz, y1 + th - hsz, hsz, hsz, 0, 0, fg);\n            vg.drawOval(x2 - hsz, y1 + th - hsz, hsz, hsz, 0, 0, fg);\n        }\n    }\n    drawArrow(x1, y1, x2, y2, headsz, colour, linesz) {\n        let dx = x2 - x1, dy = y2 - y1, invD = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.invZ)((0,_util_util__WEBPACK_IMPORTED_MODULE_1__.norm_xy)(dx, dy));\n        dx *= invD;\n        dy *= invD;\n        let ox = dy, oy = -dx;\n        let hx = x2 - dx * headsz, hy = y2 - dy * headsz;\n        let px = [\n            x1 + ox * 0.5 * linesz,\n            hx + ox * 0.5 * linesz,\n            hx + ox * 0.5 * headsz,\n            x2,\n            hx - ox * 0.5 * headsz,\n            hx - ox * 0.5 * linesz,\n            x1 - ox * 0.5 * linesz\n        ];\n        let py = [\n            y1 + oy * 0.5 * linesz,\n            hy + oy * 0.5 * linesz,\n            hy + oy * 0.5 * headsz,\n            y2,\n            hy - oy * 0.5 * headsz,\n            hy - oy * 0.5 * linesz,\n            y1 - oy * 0.5 * linesz\n        ];\n        this.vg.drawPoly(px, py, _MetaVector__WEBPACK_IMPORTED_MODULE_6__.MetaVector.NOCOLOUR, 0, colour, true);\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/gfx/DrawExperiment.ts?");

/***/ }),

/***/ "./src/gfx/DrawMolecule.ts":
/*!*********************************!*\
  !*** ./src/gfx/DrawMolecule.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DrawMolecule\": () => (/* binding */ DrawMolecule)\n/* harmony export */ });\n/* harmony import */ var _util_Geom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Geom */ \"./src/util/Geom.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _ArrangeMolecule__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ArrangeMolecule */ \"./src/gfx/ArrangeMolecule.ts\");\n/* harmony import */ var _MetaVector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MetaVector */ \"./src/gfx/MetaVector.ts\");\n\n\n\n\n\nclass DrawMolecule {\n    constructor(layout, vg) {\n        this.layout = layout;\n        this.vg = vg;\n        this.mol = layout.getMolecule();\n        this.policy = layout.getPolicy();\n        this.effects = layout.getEffects();\n        this.scale = layout.getScale();\n        this.invScale = 1.0 / this.scale;\n    }\n    getMolecule() { return this.mol; }\n    getMetaVector() { return this.vg; }\n    getLayout() { return this.layout; }\n    getPolicy() { return this.policy; }\n    getEffects() { return this.effects; }\n    draw() {\n        let DRAW_SPACE = false;\n        if (DRAW_SPACE) {\n            let bounds = this.layout.determineBoundary();\n            this.vg.drawRect(bounds[0], bounds[1], bounds[2] - bounds[0], bounds[3] - bounds[1], 0xFF0000, 1, _MetaVector__WEBPACK_IMPORTED_MODULE_4__.MetaVector.NOCOLOUR);\n            for (let n = 0; n < this.layout.numSpace(); n++) {\n                let spc = this.layout.getSpace(n);\n                this.vg.drawRect(spc.box.x, spc.box.y, spc.box.w, spc.box.h, _MetaVector__WEBPACK_IMPORTED_MODULE_4__.MetaVector.NOCOLOUR, 0, 0xE0E0E0);\n                if (spc.px != null && spc.py != null && spc.px.length > 2)\n                    this.vg.drawPoly(spc.px, spc.py, 0x000000, 1, 0x808080FF, true);\n            }\n        }\n        this.drawUnderEffects();\n        let layout = this.layout, effects = this.effects, policy = this.policy, vg = this.vg;\n        for (let n = 0; n < layout.numLines(); n++) {\n            let b = layout.getLine(n);\n            if (effects.hideBonds.has(b.bnum))\n                continue;\n            if (b.type == _ArrangeMolecule__WEBPACK_IMPORTED_MODULE_3__.BLineType.Normal) {\n                vg.drawLine(b.line.x1, b.line.y1, b.line.x2, b.line.y2, b.col, b.size);\n            }\n            else if (b.type == _ArrangeMolecule__WEBPACK_IMPORTED_MODULE_3__.BLineType.Inclined)\n                this.drawBondInclined(b);\n            else if (b.type == _ArrangeMolecule__WEBPACK_IMPORTED_MODULE_3__.BLineType.Declined)\n                this.drawBondDeclined(b);\n            else if (b.type == _ArrangeMolecule__WEBPACK_IMPORTED_MODULE_3__.BLineType.Unknown)\n                this.drawBondUnknown(b);\n            else if (b.type == _ArrangeMolecule__WEBPACK_IMPORTED_MODULE_3__.BLineType.Dotted || b.type == _ArrangeMolecule__WEBPACK_IMPORTED_MODULE_3__.BLineType.DotDir)\n                this.drawBondDotted(b);\n            else if (b.type == _ArrangeMolecule__WEBPACK_IMPORTED_MODULE_3__.BLineType.IncDouble || b.type == _ArrangeMolecule__WEBPACK_IMPORTED_MODULE_3__.BLineType.IncTriple || b.type == _ArrangeMolecule__WEBPACK_IMPORTED_MODULE_3__.BLineType.IncQuadruple)\n                this.drawBondIncMulti(b);\n        }\n        let fg = policy.data.foreground;\n        for (let r of layout.getRings())\n            vg.drawOval(r.cx, r.cy, r.rw, r.rh, fg, r.size, _MetaVector__WEBPACK_IMPORTED_MODULE_4__.MetaVector.NOCOLOUR);\n        for (let p of layout.getPaths())\n            vg.drawPath(p.px, p.py, p.ctrl, false, fg, p.size, _MetaVector__WEBPACK_IMPORTED_MODULE_4__.MetaVector.NOCOLOUR, false);\n        for (let n = 0; n < layout.numPoints(); n++) {\n            let p = layout.getPoint(n);\n            if (effects.hideBonds.has(p.anum))\n                continue;\n            let txt = p.text;\n            if (txt == null)\n                continue;\n            let fsz = p.fsz;\n            let cx = p.oval.cx, cy = p.oval.cy, rw = p.oval.rw;\n            let col = p.col;\n            while (txt.endsWith('.')) {\n                let dw = rw / txt.length;\n                let r = fsz * 0.15;\n                vg.drawOval(cx + rw - dw, cy, r, r, _MetaVector__WEBPACK_IMPORTED_MODULE_4__.MetaVector.NOCOLOUR, 0, col);\n                cx -= dw;\n                rw -= dw;\n                txt = txt.substring(0, txt.length - 1);\n            }\n            while (txt.startsWith('+')) {\n                let dw = rw / txt.length;\n                let x = cx - rw + dw, y = cy, r = fsz * 0.18, lsz = fsz * 0.1;\n                vg.drawLine(x - r, y, x + r, y, col, lsz);\n                vg.drawLine(x, y - r, x, y + r, col, lsz);\n                cx += dw;\n                rw -= dw;\n                txt = txt.substring(1, txt.length);\n            }\n            while (txt.startsWith('-')) {\n                let dw = rw / txt.length;\n                let x = cx - rw + dw, y = cy, r = fsz * 0.18, lsz = fsz * 0.1;\n                vg.drawLine(x - r, y, x + r, y, col, lsz);\n                cx += dw;\n                rw -= dw;\n                txt = txt.substring(1, txt.length);\n            }\n            if (txt.length > 0) {\n                vg.drawText(cx, cy, txt, fsz, col, _MetaVector__WEBPACK_IMPORTED_MODULE_4__.TextAlign.Centre | _MetaVector__WEBPACK_IMPORTED_MODULE_4__.TextAlign.Middle);\n            }\n        }\n        this.drawOverEffects();\n    }\n    drawUnderEffects() {\n        let mol = this.mol, policy = this.policy, effects = this.effects, layout = this.layout, scale = this.scale, vg = this.vg;\n        for (let n = 0, num = Math.min(effects.atomFrameDotSz.length, mol.numAtoms); n < num; n++) {\n            if (effects.hideAtoms.has(n + 1))\n                continue;\n            let dw = effects.atomFrameDotSz[n] * scale, col = effects.atomFrameCol[n];\n            let a = layout.getPoint(n);\n            let rw = a.oval.rw + 0.1 * scale, rh = a.oval.rh + 0.1 * scale;\n            let wdots = Math.ceil(2 * rw / (3 * dw));\n            let hdots = Math.ceil(2 * rh / (3 * dw));\n            let wspc = 2 * rw / wdots, hspc = 2 * rh / hdots;\n            for (let i = 0; i <= wdots; i++) {\n                let x = a.oval.cx - rw + i * wspc;\n                vg.drawOval(x, a.oval.cy - rh, dw, dw, _MetaVector__WEBPACK_IMPORTED_MODULE_4__.MetaVector.NOCOLOUR, 0, col);\n                vg.drawOval(x, a.oval.cy + rh, dw, dw, _MetaVector__WEBPACK_IMPORTED_MODULE_4__.MetaVector.NOCOLOUR, 0, col);\n            }\n            for (let i = 1; i < hdots; i++) {\n                let y = a.oval.cy - rh + i * hspc;\n                vg.drawOval(a.oval.cx - rw, y, dw, dw, _MetaVector__WEBPACK_IMPORTED_MODULE_4__.MetaVector.NOCOLOUR, 0, col);\n                vg.drawOval(a.oval.cx + rw, y, dw, dw, _MetaVector__WEBPACK_IMPORTED_MODULE_4__.MetaVector.NOCOLOUR, 0, col);\n            }\n        }\n        for (let key in effects.dottedRectOutline) {\n            let atom = parseInt(key), col = effects.dottedRectOutline[key];\n            let a = layout.getPoint(atom - 1);\n            let rw = Math.max(a.oval.rw, 0.2 * scale), rh = Math.max(a.oval.rh, 0.2 * scale);\n            let sz = 0.05 * scale;\n            let xdots = Math.max(1, Math.round(rw / (2 * sz)));\n            let ydots = Math.max(1, Math.round(rh / (2 * sz)));\n            let invX = (2 * rw) / xdots, invY = (2 * rh) / ydots;\n            for (let n = 0; n <= xdots; n++) {\n                let x = a.oval.cx - rw + n * invX;\n                vg.drawOval(x, a.oval.cy - rh, sz, sz, _MetaVector__WEBPACK_IMPORTED_MODULE_4__.MetaVector.NOCOLOUR, 0, col);\n                vg.drawOval(x, a.oval.cy + rh, sz, sz, _MetaVector__WEBPACK_IMPORTED_MODULE_4__.MetaVector.NOCOLOUR, 0, col);\n            }\n            for (let n = 1; n < ydots; n++) {\n                let y = a.oval.cy - rh + n * invY;\n                vg.drawOval(a.oval.cx - rw, y, sz, sz, _MetaVector__WEBPACK_IMPORTED_MODULE_4__.MetaVector.NOCOLOUR, 0, col);\n                vg.drawOval(a.oval.cx + rw, y, sz, sz, _MetaVector__WEBPACK_IMPORTED_MODULE_4__.MetaVector.NOCOLOUR, 0, col);\n            }\n        }\n        for (let key in effects.dottedBondCross) {\n            let bond = parseInt(key), col = effects.dottedBondCross[key];\n            let x1 = 0, y1 = 0, x2 = 0, y2 = 0, bcount = 0;\n            for (let n = 0; n < layout.numLines(); n++) {\n                let b = layout.getLine(n);\n                if (b.bnum == bond) {\n                    x1 += b.line.x1;\n                    y1 += b.line.y1;\n                    x2 += b.line.x2;\n                    y2 += b.line.y2;\n                    bcount += 1;\n                }\n            }\n            if (bcount > 1) {\n                let inv = 1 / bcount;\n                [x1, y1, x2, y2] = [x1 * inv, y1 * inv, x2 * inv, y2 * inv];\n            }\n            let dx = x2 - x1, dy = y2 - y1;\n            let inv = 0.2 * scale * (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.invZ)((0,_util_util__WEBPACK_IMPORTED_MODULE_1__.norm_xy)(dx, dy)), ox = dy * inv, oy = -dx * inv;\n            let cx = 0.5 * (x1 + x2), cy = 0.5 * (y1 + y2), sz = 0.05 * scale;\n            for (let p of [-2, -1, 1, 2]) {\n                let x = cx + p * ox, y = cy + p * oy;\n                vg.drawOval(x, y, sz, sz, _MetaVector__WEBPACK_IMPORTED_MODULE_4__.MetaVector.NOCOLOUR, 0, col);\n            }\n        }\n    }\n    drawOverEffects() {\n        let mol = this.mol, policy = this.policy, effects = this.effects, layout = this.layout, scale = this.scale, vg = this.vg;\n        for (let a of effects.overlapAtoms) {\n            let p = layout.getPoint(a - 1);\n            let rad = scale * 0.2;\n            vg.drawLine(p.oval.cx - rad, p.oval.cy - rad, p.oval.cx + rad, p.oval.cy + rad, 0xFF0000, 1);\n            vg.drawLine(p.oval.cx + rad, p.oval.cy - rad, p.oval.cx - rad, p.oval.cy + rad, 0xFF0000, 1);\n        }\n        for (let n = 0, num = Math.min(effects.atomCircleSz.length, mol.numAtoms); n < num; n++)\n            if (effects.atomCircleSz[n] > 0) {\n                let dw = effects.atomCircleSz[n] * scale, col = effects.atomCircleCol[n];\n                let p = layout.getPoint(n);\n                vg.drawOval(p.oval.cx, p.oval.cy, dw, dw, _MetaVector__WEBPACK_IMPORTED_MODULE_4__.MetaVector.NOCOLOUR, 0, col);\n            }\n    }\n    drawBondInclined(b) {\n        let x1 = b.line.x1, y1 = b.line.y1, x2 = b.line.x2, y2 = b.line.y2;\n        let dx = x2 - x1, dy = y2 - y1;\n        let col = b.col;\n        let size = b.size, head = b.head;\n        let norm = head / Math.sqrt(dx * dx + dy * dy);\n        let ox = norm * dy, oy = -norm * dx;\n        let px = [x1, x2 - ox, x2 + ox], py = [y1, y2 - oy, y2 + oy];\n        if (this.layout.getPoint(b.bto - 1).text == null && this.mol.atomAdjCount(b.bto) == 2) {\n            let other = null;\n            for (let n = 0; n < this.layout.numLines(); n++) {\n                let o = this.layout.getLine(n);\n                if (o.type == _ArrangeMolecule__WEBPACK_IMPORTED_MODULE_3__.BLineType.Normal && (o.bfr == b.bto || o.bto == b.bto)) {\n                    if (other != null) {\n                        other = null;\n                        break;\n                    }\n                    other = o;\n                }\n            }\n            if (other != null) {\n                let th1 = Math.atan2(y1 - y2, x1 - x2);\n                let th2 = Math.atan2(other.line.y1 - other.line.y2, other.line.x1 - other.line.x2);\n                if (b.bto == other.bfr)\n                    th2 += Math.PI;\n                let diff = Math.abs((0,_util_util__WEBPACK_IMPORTED_MODULE_1__.angleDiff)(th1, th2));\n                if (diff > 105 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD && diff < 135 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD) {\n                    let ixy1 = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.lineIntersect(px[0], py[0], px[1], py[1], other.line.x1, other.line.y1, other.line.x2, other.line.y2);\n                    let ixy2 = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.lineIntersect(px[0], py[0], px[2], py[2], other.line.x1, other.line.y1, other.line.x2, other.line.y2);\n                    px[1] = ixy1[0];\n                    py[1] = ixy1[1];\n                    px[2] = ixy2[0];\n                    py[2] = ixy2[1];\n                    let dx1 = px[1] - px[0], dy1 = py[1] - py[0], inv1 = 0.5 * other.size / (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.norm_xy)(dx1, dy1);\n                    px[1] += dx1 * inv1;\n                    py[1] += dy1 * inv1;\n                    let dx2 = px[2] - px[0], dy2 = py[2] - py[0], inv2 = 0.5 * other.size / (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.norm_xy)(dx2, dy2);\n                    px[2] += dx2 * inv1;\n                    py[2] += dy2 * inv1;\n                }\n            }\n        }\n        if (this.layout.getPoint(b.bto - 1).text == null && this.mol.atomAdjCount(b.bto) == 3) {\n            let other1 = null, other2 = null;\n            for (let n = 0; n < this.layout.numLines(); n++) {\n                let o = this.layout.getLine(n);\n                if (o.type == _ArrangeMolecule__WEBPACK_IMPORTED_MODULE_3__.BLineType.Normal && (o.bfr == b.bto || o.bto == b.bto)) {\n                    if (other1 == null)\n                        other1 = o;\n                    else if (other2 == null)\n                        other2 = o;\n                    else {\n                        other1 = other2 = null;\n                        break;\n                    }\n                }\n            }\n            if (other1 != null && other2 != null) {\n                let th1 = Math.atan2(y1 - y2, x1 - x2);\n                let th2 = Math.atan2(other1.line.y1 - other1.line.y2, other1.line.x1 - other1.line.x2);\n                let th3 = Math.atan2(other2.line.y1 - other2.line.y2, other2.line.x1 - other2.line.x2);\n                if (b.bto == other1.bfr)\n                    th2 += Math.PI;\n                if (b.bto == other2.bfr)\n                    th3 += Math.PI;\n                let dth1 = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.angleDiff)(th1, th2), diff1 = Math.abs(dth1);\n                let dth2 = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.angleDiff)(th1, th3), diff2 = Math.abs(dth2);\n                let diff3 = Math.abs((0,_util_util__WEBPACK_IMPORTED_MODULE_1__.angleDiff)(th2, th3));\n                if (diff1 > 105 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD && diff1 < 135 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD ||\n                    diff2 > 105 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD && diff2 < 135 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD ||\n                    diff3 > 105 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD && diff3 < 135 * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD) {\n                    if (dth1 < 0)\n                        [other1, other2] = [other2, other1];\n                    let ixy1 = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.lineIntersect(px[0], py[0], px[1], py[1], other1.line.x1, other1.line.y1, other1.line.x2, other1.line.y2);\n                    let ixy2 = _util_Geom__WEBPACK_IMPORTED_MODULE_0__.GeomUtil.lineIntersect(px[0], py[0], px[2], py[2], other2.line.x1, other2.line.y1, other2.line.x2, other2.line.y2);\n                    px = [x1, ixy1[0], x2, ixy2[0]];\n                    py = [y1, ixy1[1], y2, ixy2[1]];\n                }\n            }\n        }\n        this.vg.drawPoly(px, py, _MetaVector__WEBPACK_IMPORTED_MODULE_4__.MetaVector.NOCOLOUR, 0, col, true);\n    }\n    drawBondDeclined(b) {\n        let x1 = b.line.x1, y1 = b.line.y1, x2 = b.line.x2, y2 = b.line.y2;\n        let dx = x2 - x1, dy = y2 - y1;\n        let col = b.col;\n        let size = b.size, head = b.head;\n        let ext = Math.sqrt(dx * dx + dy * dy);\n        let nsteps = Math.ceil(ext * 2.5 * this.invScale);\n        let norm = head / ext;\n        let ox = norm * dy, oy = -norm * dx, invSteps = 1.0 / (nsteps + 1);\n        let holdout = this.mol.atomAdjCount(b.bto) == 1 && this.layout.getPoint(b.bto - 1).text == null ? 1 : 1 - (0.15 * this.scale) / ext;\n        for (let i = 0; i <= nsteps + 1; i++) {\n            let cx = x1 + i * dx * invSteps * holdout, cy = y1 + i * dy * invSteps * holdout;\n            let ix = ox * i * invSteps, iy = oy * i * invSteps;\n            this.vg.drawLine(cx - ix, cy - iy, cx + ix, cy + iy, col, size);\n        }\n    }\n    drawBondUnknown(b) {\n        let x1 = b.line.x1, y1 = b.line.y1, x2 = b.line.x2, y2 = b.line.y2;\n        let dx = x2 - x1, dy = y2 - y1;\n        let col = b.col;\n        let size = b.size, head = b.head;\n        let ext = Math.sqrt(dx * dx + dy * dy);\n        let nsteps = Math.ceil(ext * 3.5 * this.invScale);\n        let norm = head / ext;\n        let ox = norm * dy, oy = -norm * dx;\n        let sz = 1 + 3 * (nsteps + 1);\n        let x = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.numberArray(0, sz), y = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.numberArray(0, sz), ctrl = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.booleanArray(false, sz);\n        x[0] = x1;\n        y[0] = y1;\n        ctrl[0] = false;\n        for (let i = 0, j = 1; i <= nsteps; i++, j += 3) {\n            let ax = x1 + i * dx / (nsteps + 1), ay = y1 + i * dy / (nsteps + 1);\n            let cx = x1 + (i + 1) * dx / (nsteps + 1), cy = y1 + (i + 1) * dy / (nsteps + 1);\n            let bx = (ax + cx) / 2, by = (ay + cy) / 2;\n            let sign = i % 2 == 0 ? 1 : -1;\n            x[j] = ax;\n            x[j + 1] = bx + sign * ox;\n            x[j + 2] = cx;\n            y[j] = ay;\n            y[j + 1] = by + sign * oy;\n            y[j + 2] = cy;\n            ctrl[j] = true;\n            ctrl[j + 1] = true;\n            ctrl[j + 2] = false;\n        }\n        this.vg.drawPath(x, y, ctrl, false, col, size, _MetaVector__WEBPACK_IMPORTED_MODULE_4__.MetaVector.NOCOLOUR, false);\n    }\n    drawBondDotted(b) {\n        let x1 = b.line.x1, y1 = b.line.y1, x2 = b.line.x2, y2 = b.line.y2;\n        let dx = x2 - x1, dy = y2 - y1;\n        let col = b.col;\n        let size = b.size;\n        let radius = size, dist = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.norm_xy)(dx, dy);\n        if (dist < 0.01)\n            return;\n        let nudge = 0.5 * size / dist;\n        x1 += nudge * dx;\n        y1 += nudge * dy;\n        x2 -= nudge * dx;\n        y2 -= nudge * dy;\n        dx = x2 - x1;\n        dy = y2 - y1;\n        let nsteps = Math.ceil(0.2 * dist / radius);\n        let invSteps = 1.0 / (nsteps + 1);\n        for (let i = 0; i <= nsteps + 1; i++) {\n            let r = radius;\n            if (b.type == _ArrangeMolecule__WEBPACK_IMPORTED_MODULE_3__.BLineType.DotDir)\n                r *= 1 + (i * (1.0 / (nsteps + 2)) - 0.5);\n            let cx = x1 + i * dx * invSteps, cy = y1 + i * dy * invSteps;\n            this.vg.drawOval(cx, cy, r, r, _MetaVector__WEBPACK_IMPORTED_MODULE_4__.MetaVector.NOCOLOUR, 0, col);\n        }\n    }\n    drawBondIncMulti(b) {\n        let x1 = b.line.x1, y1 = b.line.y1, x2 = b.line.x2, y2 = b.line.y2;\n        let dx = x2 - x1, dy = y2 - y1;\n        let col = b.col;\n        let size = b.size, head = b.head;\n        let norm = head / Math.sqrt(dx * dx + dy * dy);\n        let ox = norm * dy, oy = -norm * dx;\n        this.vg.drawPoly([x1, x2 - ox, x2 + ox], [y1, y2 - oy, y2 + oy], col, this.scale * 0.05, _MetaVector__WEBPACK_IMPORTED_MODULE_4__.MetaVector.NOCOLOUR, true);\n        if (b.type == _ArrangeMolecule__WEBPACK_IMPORTED_MODULE_3__.BLineType.IncDouble) {\n            this.vg.drawLine(x1, y1, x2, y2, col, this.scale * 0.03);\n        }\n        else {\n            this.vg.drawLine(x1, y1, x2 + 0.33 * ox, y2 + 0.33 * oy, col, this.scale * 0.03);\n            this.vg.drawLine(x1, y1, x2 - 0.33 * ox, y2 - 0.33 * oy, col, this.scale * 0.03);\n        }\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/gfx/DrawMolecule.ts?");

/***/ }),

/***/ "./src/gfx/FontData.ts":
/*!*****************************!*\
  !*** ./src/gfx/FontData.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FontData\": () => (/* binding */ FontData)\n/* harmony export */ });\n/* harmony import */ var _util_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/dom */ \"./src/util/dom.ts\");\n\nclass FontData {\n    constructor() {\n        this.UNITS_PER_EM = 2048;\n        this.INV_UNITS_PER_EM = 1.0 / this.UNITS_PER_EM;\n        this.PANOSE_1 = '2 11 6 4 3 5 4 4 2 4';\n        this.ASCENT = 1638;\n        this.DESCENT = -410;\n        this.MISSING_HORZ = 2048;\n        this.MISSING_DATA = 'M256 0v1536h1536v-1536h-1536zM384 128h1280v1280h-1280v-1280z';\n        this.ASCENT_FUDGE = 0.9;\n        this.UNICODE = [\n            ' ', '!', '\"', '#', '$', '%', '&', '\\'', '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<',\n            '=', '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n            '[', '\\\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\n            'x', 'y', 'z', '{', '|', '}', '~', '\\u00A0', '\\u00A1', '\\u00A2', '\\u00A3', '\\u00A4', '\\u00A5', '\\u00A6', '\\u00A7', '\\u00A8', '\\u00A9', '\\u00AA',\n            '\\u00AB', '\\u00AC', '\\u00AD', '\\u00AE', '\\u00AF', '\\u00B0', '\\u00B1', '\\u00B2', '\\u00B3', '\\u00B4', '\\u00B5', '\\u00B6', '\\u00B7', '\\u00B8', '\\u00B9',\n            '\\u00BA', '\\u00BB', '\\u00BC', '\\u00BD', '\\u00BE', '\\u00BF', '\\u00C0', '\\u00C1', '\\u00C2', '\\u00C3', '\\u00C4', '\\u00C5', '\\u00C6', '\\u00C7', '\\u00C8',\n            '\\u00C9', '\\u00CA', '\\u00CB', '\\u00CC', '\\u00CD', '\\u00CE', '\\u00CF', '\\u00D0', '\\u00D1', '\\u00D2', '\\u00D3', '\\u00D4', '\\u00D5', '\\u00D6', '\\u00D7',\n            '\\u00D8', '\\u00D9', '\\u00DA', '\\u00DB', '\\u00DC', '\\u00DD', '\\u00DE', '\\u00DF', '\\u00E0', '\\u00E1', '\\u00E2', '\\u00E3', '\\u00E4', '\\u00E5', '\\u00E6',\n            '\\u00E7', '\\u00E8', '\\u00E9', '\\u00EA', '\\u00EB', '\\u00EC', '\\u00ED', '\\u00EE', '\\u00EF', '\\u00F0', '\\u00F1', '\\u00F2', '\\u00F3', '\\u00F4', '\\u00F5',\n            '\\u00F6', '\\u00F7', '\\u00F8', '\\u00F9', '\\u00FA', '\\u00FB', '\\u00FC', '\\u00FD', '\\u00FE', '\\u037E', '\\u0384', '\\u0385', '\\u0386', '\\u0387', '\\u0388',\n            '\\u0389', '\\u038A', '\\u038C', '\\u038E', '\\u038F', '\\u0390', '\\u0391', '\\u0392', '\\u0393', '\\u0394', '\\u0395', '\\u0396', '\\u0397', '\\u0398', '\\u0399',\n            '\\u039A', '\\u039B', '\\u039C', '\\u039D', '\\u039E', '\\u039F', '\\u03A0', '\\u03A1', '\\u03A3', '\\u03A4', '\\u03A5', '\\u03A6', '\\u03A7', '\\u03A8', '\\u03A9',\n            '\\u03AA', '\\u03AB', '\\u03AC', '\\u03AD', '\\u03AE', '\\u03AF', '\\u03B0', '\\u03B1', '\\u03B2', '\\u03B3', '\\u03B4', '\\u03B5', '\\u03B6', '\\u03B7', '\\u03B8',\n            '\\u03B9', '\\u03BA', '\\u03BB', '\\u03BC', '\\u03BD', '\\u03BE', '\\u03BF', '\\u03C0', '\\u03C1', '\\u03C2', '\\u03C3', '\\u03C4', '\\u03C5', '\\u03C6', '\\u03C7',\n            '\\u03C8', '\\u03C9', '\\u03CA', '\\u03CB', '\\u03CC', '\\u03CD', '\\u03CE', '\\u2202', '\\u2206', '\\u220F', '\\u2211', '\\u2212', '\\u2215', '\\u2219', '\\u221A',\n            '\\u221E', '\\u222B', '\\u2248', '\\u2260', '\\u2264', '\\u2265'\n        ];\n        this.HORIZ_ADV_X = [\n            720, 806, 940, 1676, 1302, 2204, 1488, 550, 930, 930, 1302, 1676, 745, 930, 745, 930, 1302, 1302, 1302, 1302, 1302, 1302, 1302, 1302, 1302, 1302,\n            930, 930, 1676, 1676, 1676, 1117, 2048, 1400, 1404, 1430, 1578, 1295, 1177, 1588, 1539, 862, 931, 1419, 1140, 1726, 1532, 1612, 1235, 1612, 1424,\n            1400, 1262, 1499, 1400, 2025, 1403, 1260, 1403, 930, 930, 930, 1676, 1302, 1302, 1230, 1276, 1067, 1276, 1220, 720, 1276, 1296, 562, 705, 1212, 562,\n            1992, 1296, 1243, 1276, 1276, 874, 1067, 807, 1296, 1212, 1676, 1212, 1212, 1076, 1300, 930, 1300, 1676, 720, 806, 1302, 1302, 1302, 1302, 930, 1302,\n            1302, 2048, 1117, 1320, 1676, 930, 2048, 1302, 1110, 1676, 1110, 1110, 1302, 1314, 1302, 745, 1302, 1110, 1117, 1320, 2048, 2048, 2048, 1117, 1400,\n            1400, 1400, 1400, 1400, 1400, 2016, 1430, 1295, 1295, 1295, 1295, 862, 862, 862, 862, 1588, 1532, 1612, 1612, 1612, 1612, 1612, 1676, 1612, 1499,\n            1499, 1499, 1499, 1260, 1240, 1270, 1230, 1230, 1230, 1230, 1230, 1230, 1956, 1067, 1220, 1220, 1220, 1220, 562, 562, 562, 562, 1253, 1296, 1243,\n            1243, 1243, 1243, 1243, 1676, 1243, 1296, 1296, 1296, 1296, 1212, 1276, 930, 1302, 1302, 1400, 930, 1538, 1782, 1105, 1804, 1543, 1859, 562, 1400,\n            1404, 1160, 1440, 1295, 1403, 1539, 1612, 862, 1419, 1404, 1726, 1532, 1329, 1612, 1539, 1235, 1377, 1262, 1260, 1677, 1403, 1783, 1676, 862, 1260,\n            1276, 1050, 1296, 562, 1293, 1276, 1270, 1212, 1245, 1050, 937, 1296, 1278, 562, 1212, 1212, 1310, 1212, 1030, 1243, 1305, 1280, 1040, 1291, 1016,\n            1293, 1618, 1208, 1683, 1666, 562, 1293, 1243, 1293, 1666, 1302, 1489, 1676, 1489, 1676, 740, 745, 1676, 2048, 1302, 1676, 1676, 1676, 1676\n        ];\n        this.GLYPH_DATA = [\n            '',\n            'M515 1489l-26 -1079h-170l-28 1079h224zM505 0h-204v211h204v-211z',\n            'M772 1556l-43 -579h-132l-43 579h218zM386 1556l-43 -579h-132l-43 579h218z',\n            'M1481 932h-333l-92 -376h308v-135h-343l-104 -421h-129l104 421h-270l-104 -421h-129l104 421h-298v135h333l92 376h-308v135h343l105 422h129l-105 -422h270l105 422h129l-105 -422h298v-135zM1022 934h-274l-94 -380h274z',\n            'M1160 380q0 -155 -121 -257.5t-317 -121.5v-362h-118v357q-132 1 -248 25.5t-201 63.5v198h16q19 -14 68 -40.5t95 -43.5q52 -19 121.5 -35.5t148.5 -19.5v433q-40 8 -74 15.5t-63 15.5q-163 41 -234 123.5t-71 203.5q0 148 116.5 250t325.5 119v272h118v-270 q101 -2 207 -24t178 -51v-196h-14q-75 46 -156.5 81.5t-214.5 44.5v-431q30 -5 65 -13.5t61 -13.5q149 -32 230.5 -110t81.5 -213zM604 747v413q-107 -8 -180 -58.5t-73 -140.5q0 -91 54 -137t199 -77zM971 354q0 94 -58.5 137.5t-190.5 68.5v-414q120 12 184.5 61t64.5 147 z',\n            'M884 1076q0 -224 -94.5 -333t-272.5 -109q-182 0 -275 109t-93 332q0 224 95 333t273 109q181 0 274 -110t93 -331zM1575 1489l-780 -1489h-165l780 1489h165zM2055 413q0 -224 -95 -333t-273 -109q-181 0 -274 110t-93 331q0 224 94.5 333t272.5 109q182 0 275 -109 t93 -332zM706 1076q0 172 -44.5 240t-144.5 68q-102 0 -146 -68t-44 -241t44 -240.5t146 -67.5q100 0 144.5 67.5t44.5 241.5zM1877 413q0 172 -44.5 240t-144.5 68q-102 0 -146 -68t-44 -241t44 -240.5t146 -67.5q100 0 144.5 67.5t44.5 241.5z',\n            'M792 1191q0 95 -56.5 149.5t-144.5 54.5q-92 0 -150 -61.5t-58 -150.5q0 -75 39.5 -133t170.5 -137q98 35 148.5 102.5t50.5 175.5zM986 315l-478 466q-31 -15 -62 -39.5t-62 -66.5q-28 -39 -46 -94t-18 -124q0 -146 85.5 -235.5t242.5 -89.5q93 0 184.5 45.5 t153.5 137.5zM1287 909v-96q0 -96 -25 -216t-85 -229l378 -368h-246l-229 224q-115 -142 -235 -198.5t-247 -56.5q-208 0 -345.5 121.5t-137.5 318.5q0 92 26 159t61 116q35 47 87 88.5t105 72.5q-110 72 -158.5 145t-48.5 184q0 67 26.5 127.5t79.5 110.5q50 48 130.5 78 t177.5 30q173 0 280 -87.5t107 -221.5q0 -44 -12 -99.5t-41 -99.5q-32 -49 -91 -94t-153 -77l371 -362q14 40 21 88t8 100q2 56 1.5 125t-0.5 117h195z',\n            'M386 1556l-43 -579h-136l-43 579h222z',\n            'M783 -412h-229q-177 203 -275 443t-98 541t98 541t275 443h229v-10q-81 -73 -154.5 -168.5t-136.5 -222.5q-60 -123 -97.5 -271t-37.5 -312q0 -171 36.5 -313t98.5 -270q60 -123 137 -222.5t154 -168.5v-10z',\n            'M749 572q0 -301 -98 -541t-275 -443h-229v10q77 69 154.5 168.5t136.5 222.5q62 128 98.5 270t36.5 313q0 164 -37 312t-98 271q-63 127 -136.5 222.5t-154.5 168.5v10h229q177 -203 275 -443t98 -541z',\n            'M1137 887l-64 -110l-362 213l6 -360h-129l5 360l-361 -214l-65 110l381 207l-381 207l65 110l362 -213l-6 359h129l-7 -359l363 212l64 -110l-380 -205z',\n            'M1466 572h-545v-545h-166v545h-545v160h545v545h166v-545h545v-160z',\n            'M575 285l-282 -655h-146l174 655h254z',\n            'M777 561h-624v181h624v-181z',\n            'M492 0h-239v285h239v-285z',\n            'M860 1556l-717 -1860h-173l714 1860h176z',\n            'M1167 745q0 -401 -125.5 -588.5t-389.5 -187.5q-268 0 -391.5 190t-123.5 584q0 397 125 586.5t390 189.5q268 0 391.5 -192.5t123.5 -581.5zM904 291q35 81 47.5 190.5t12.5 263.5q0 152 -12.5 264t-48.5 190q-35 77 -95.5 116t-155.5 39q-94 0 -155.5 -39t-97.5 -118 q-34 -74 -46.5 -193t-12.5 -261q0 -156 11 -261t47 -188q33 -78 93.5 -119t160.5 -41q94 0 156 39t96 118z',\n            'M1084 0h-806v152h310v998h-310v136q63 0 135 10.5t109 30.5q46 25 72.5 63.5t30.5 103.5h155v-1342h304v-152z',\n            'M1169 0h-1008v209q105 90 210.5 180t196.5 179q192 186 263 295.5t71 236.5q0 116 -76.5 181.5t-213.5 65.5q-91 0 -197 -32t-207 -98h-10v210q71 35 189.5 64t229.5 29q229 0 359 -110.5t130 -299.5q0 -85 -21.5 -158.5t-63.5 -139.5q-39 -62 -91.5 -122t-127.5 -133 q-107 -105 -221 -203.5t-213 -182.5h801v-171z',\n            'M1038 717q48 -43 79 -108t31 -168q0 -102 -37 -187t-104 -148q-75 -70 -176.5 -103.5t-222.5 -33.5q-124 0 -244 29.5t-197 64.5v209h15q85 -56 200 -93t222 -37q63 0 134 21t115 62q46 44 68.5 97t22.5 134q0 80 -25.5 132.5t-70.5 82.5q-45 31 -109 42.5t-138 11.5h-90 v166h70q152 0 242.5 63.5t90.5 185.5q0 54 -23 94.5t-64 66.5q-43 26 -92 36t-111 10q-95 0 -202 -34t-202 -96h-10v209q71 35 189.5 64.5t229.5 29.5q109 0 192 -20t150 -64q72 -48 109 -116t37 -159q0 -124 -87.5 -216.5t-206.5 -116.5v-14q48 -8 110 -33.5t105 -63.5z ',\n            'M1203 419h-221v-419h-192v419h-713v230l721 840h184v-910h221v-160zM790 579v672l-577 -672h577z',\n            'M1157 473q0 -104 -38 -199t-104 -160q-72 -70 -171.5 -107.5t-230.5 -37.5q-122 0 -235 25.5t-191 61.5v211h14q82 -52 192 -88.5t216 -36.5q71 0 137.5 20t118.5 70q44 43 66.5 103t22.5 139q0 77 -26.5 130t-73.5 85q-52 38 -126.5 53.5t-166.5 15.5q-88 0 -169.5 -12 t-140.5 -24v767h896v-175h-703v-396q43 4 88 6t78 2q121 0 212 -20.5t167 -72.5q80 -55 124 -142t44 -218z',\n            'M1191 483q0 -227 -149.5 -370.5t-366.5 -143.5q-110 0 -200 34t-159 101q-86 83 -132.5 220t-46.5 330q0 198 42.5 351t135.5 272q88 113 227 176.5t324 63.5q59 0 99 -5t81 -18v-191h-10q-28 15 -84.5 28.5t-115.5 13.5q-215 0 -343 -134.5t-149 -363.5 q84 51 165.5 77.5t188.5 26.5q95 0 167.5 -17.5t148.5 -70.5q88 -61 132.5 -154t44.5 -226zM988 475q0 93 -27.5 154t-90.5 106q-46 32 -102 42t-117 10q-85 0 -158 -20t-150 -62q-2 -22 -3 -42.5t-1 -51.5q0 -158 32.5 -249.5t89.5 -144.5q46 -44 99.5 -64.5t116.5 -20.5 q145 0 228 88.5t83 254.5z',\n            'M1173 1266l-674 -1266h-214l717 1314h-848v175h1019v-223z',\n            'M1180 415q0 -193 -150.5 -321t-378.5 -128q-242 0 -385.5 125t-143.5 320q0 124 72 224.5t203 159.5v6q-120 64 -177.5 140t-57.5 190q0 168 138 280t351 112q223 0 356 -107t133 -272q0 -101 -63 -198.5t-185 -152.5v-6q140 -60 214 -148t74 -224zM943 1142 q0 107 -82.5 170.5t-210.5 63.5q-126 0 -206.5 -60t-80.5 -162q0 -72 40.5 -124.5t122.5 -93.5q37 -18 106.5 -47t135.5 -48q99 66 137 137t38 164zM974 396q0 92 -40.5 147.5t-158.5 111.5q-47 22 -103 41t-149 53q-90 -49 -144.5 -133t-54.5 -190q0 -135 93 -223t236 -88 q146 0 233.5 75t87.5 206z',\n            'M1167 834q0 -195 -44.5 -354t-134.5 -271q-91 -114 -228 -176t-322 -62q-52 0 -98 5.5t-82 17.5v191h10q29 -15 82 -28.5t118 -13.5q221 0 346.5 132.5t145.5 365.5q-93 -56 -175 -80t-179 -24q-92 0 -166.5 18t-149.5 70q-88 61 -132.5 155t-44.5 225q0 228 150 371 t366 143q108 0 200 -33.5t161 -100.5q85 -83 131 -213.5t46 -337.5zM965 877q0 155 -32 249t-88 146q-47 45 -101 64.5t-117 19.5q-144 0 -227.5 -90t-83.5 -253q0 -95 27 -155t91 -105q45 -31 99 -41.5t120 -10.5q78 0 158 21t150 61q1 21 2.5 41.5t1.5 52.5z',\n            'M585 832h-239v285h239v-285zM585 0h-239v285h239v-285z',\n            'M585 832h-239v285h239v-285zM658 285l-282 -655h-146l174 655h254z',\n            'M1408 77l-1154 513v124l1154 513v-180l-910 -395l910 -395v-180z',\n            'M1431 782h-1186v160h1186v-160zM1431 362h-1186v160h1186v-160z',\n            'M1422 590l-1154 -513v180l910 395l-910 395v180l1154 -513v-124z',\n            'M1005 1139q0 -98 -35 -174.5t-92 -135.5q-56 -57 -129 -107t-155 -97v-225h-179v305q65 37 140.5 81t123.5 89q58 52 90 107.5t32 141.5q0 113 -76.5 168.5t-197.5 55.5q-108 0 -204.5 -34t-152.5 -69h-10v204q70 27 177.5 48.5t203.5 21.5q215 0 339.5 -104.5 t124.5 -275.5zM610 0h-204v211h204v-211z',\n            'M1870 663q0 -139 -40.5 -269t-115.5 -237h-440l-27 116q-74 -60 -142 -92t-156 -32q-168 0 -268.5 127t-100.5 355q0 227 123 362t294 135q73 0 129 -16.5t121 -49.5v48h159v-842h243q42 75 63.5 187.5t21.5 201.5q0 164 -45.5 298t-133.5 230t-218 147.5t-295 51.5 q-160 0 -292.5 -58t-227.5 -156q-96 -98 -150.5 -234.5t-54.5 -290.5q0 -165 52 -301.5t147 -233.5q99 -101 232 -152.5t290 -51.5q86 0 177.5 11t175.5 35v-142q-97 -21 -181 -28.5t-173 -7.5q-186 0 -345 63.5t-273 177.5q-115 115 -179 276t-64 356q0 185 67 344.5 t183 276.5t275 184t340 67q196 0 350 -62t260 -174t162.5 -269.5t56.5 -350.5zM1245 408v518q-63 29 -113 41.5t-107 12.5q-129 0 -202 -90t-73 -256q0 -163 58 -246.5t181 -83.5q67 0 134 31t122 73z',\n            'M1374 0h-211l-146 415h-644l-146 -415h-201l542 1489h264zM956 585l-261 731l-262 -731h523z',\n            'M1323 458q0 -111 -42 -196t-113 -140q-84 -66 -184.5 -94t-255.5 -28h-528v1489h441q163 0 244 -12t155 -50q82 -43 119 -110.5t37 -161.5q0 -106 -54 -180.5t-144 -119.5v-8q151 -31 238 -132.5t87 -256.5zM990 1129q0 54 -18 91t-58 60q-47 27 -114 33.5t-166 6.5h-236 v-430h256q93 0 148 9.5t102 39.5t66.5 77.5t19.5 112.5zM1117 450q0 90 -27 143t-98 90q-48 25 -116.5 32.5t-166.5 7.5h-311v-554h262q130 0 213 13.5t136 49.5q56 39 82 89t26 129z',\n            'M1350 108q-55 -24 -99.5 -45t-116.5 -44q-61 -19 -132.5 -32.5t-157.5 -13.5q-162 0 -294.5 45.5t-230.5 142.5q-96 95 -150 241.5t-54 340.5q0 184 52 329t150 245q95 97 229.5 148t298.5 51q120 0 239.5 -29t265.5 -102v-235h-15q-123 103 -244 150t-259 47 q-113 0 -203.5 -36.5t-161.5 -113.5q-69 -75 -107.5 -189.5t-38.5 -264.5q0 -157 42.5 -270t109.5 -184q70 -74 163.5 -109.5t197.5 -35.5q143 0 268 49t234 147h14v-232z',\n            'M1458 743q0 -203 -88.5 -368t-235.5 -256q-102 -63 -227.5 -91t-330.5 -28h-376v1489h372q218 0 346.5 -31.5t217.5 -86.5q152 -95 237 -253t85 -375zM1251 746q0 175 -61 295t-182 189q-88 50 -187 69.5t-237 19.5h-186v-1149h186q143 0 249.5 21t195.5 78 q111 71 166.5 187t55.5 290z',\n            'M1181 0h-981v1489h981v-176h-783v-408h783v-176h-783v-553h783v-176z',\n            'M1151 1313h-753v-420h647v-176h-647v-717h-198v1489h951v-176z',\n            'M1442 110q-122 -56 -266.5 -97.5t-279.5 -41.5q-174 0 -319 48t-247 144q-103 97 -159 242.5t-56 340.5q0 357 208.5 563.5t572.5 206.5q127 0 259.5 -30.5t285.5 -103.5v-235h-18q-31 24 -90 63t-116 65q-69 31 -156.5 51.5t-198.5 20.5q-250 0 -395.5 -160.5 t-145.5 -434.5q0 -289 152 -449.5t414 -160.5q96 0 191.5 19t167.5 49v365h-399v174h595v-639z',\n            'M1339 0h-198v729h-743v-729h-198v1489h198v-584h743v584h198v-1489z',\n            'M725 0h-588v152h195v1185h-195v152h588v-152h-195v-1185h195v-152z',\n            'M746 387q0 -196 -119.5 -302t-320.5 -106q-48 0 -128 8.5t-134 20.5v185h11q41 -14 101 -29t123 -15q92 0 146.5 21t80.5 60q27 40 34.5 98t7.5 134v869h-315v158h513v-1102z',\n            'M1397 0h-257l-589 663l-148 -158v-505h-198v1489h198v-777l723 777h240l-665 -700z',\n            'M1142 0h-942v1489h198v-1313h744v-176z',\n            'M1526 0h-198v1283l-414 -873h-118l-411 873v-1283h-185v1489h270l397 -829l384 829h275v-1489z',\n            'M1336 0h-245l-706 1332v-1332h-185v1489h307l644 -1216v1216h185v-1489z',\n            'M1310 1318q91 -100 139.5 -245t48.5 -329t-49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5zM1292 744 q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5z',\n            'M1174 1039q0 -99 -34.5 -183.5t-96.5 -146.5q-77 -77 -182 -115.5t-265 -38.5h-198v-555h-198v1489h404q134 0 227 -22.5t165 -70.5q85 -57 131.5 -142t46.5 -215zM968 1034q0 77 -27 134t-82 93q-48 31 -109.5 44.5t-155.5 13.5h-196v-595h167q120 0 195 21.5t122 68.5 q47 48 66.5 101t19.5 119z',\n            'M1528 -365q-60 -15 -118.5 -21.5t-119.5 -6.5q-174 0 -279.5 95.5t-114.5 273.5q-24 -4 -46.5 -5.5t-43.5 -1.5q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5 q91 -100 139.5 -245t48.5 -329q0 -273 -111.5 -460t-299.5 -262q4 -114 54 -177t182 -63q41 0 97.5 12.5t80.5 22.5h27v-182zM1292 744q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5z',\n            'M1432 0h-257l-498 592h-279v-592h-198v1489h417q135 0 225 -17.5t162 -62.5q81 -51 126.5 -128.5t45.5 -196.5q0 -161 -81 -269.5t-223 -163.5zM969 1070q0 64 -22.5 113.5t-74.5 83.5q-43 29 -102 40.5t-139 11.5h-233v-562h200q94 0 164 16.5t119 61.5q45 42 66.5 96.5 t21.5 138.5z',\n            'M1282 425q0 -87 -40.5 -172t-113.5 -144q-80 -64 -186.5 -100t-256.5 -36q-161 0 -289.5 30t-261.5 89v248h14q113 -94 261 -145t278 -51q184 0 286.5 69t102.5 184q0 99 -48.5 146t-147.5 73q-75 20 -162.5 33t-185.5 33q-198 42 -293.5 143.5t-95.5 264.5 q0 187 158 306.5t401 119.5q157 0 288 -30t232 -74v-234h-14q-85 72 -223.5 119.5t-283.5 47.5q-159 0 -255.5 -66t-96.5 -170q0 -93 48 -146t169 -81q64 -14 182 -34t200 -41q166 -44 250 -133t84 -249z',\n            'M1262 1313h-532v-1313h-198v1313h-532v176h1262v-176z',\n            'M1321 598q0 -162 -35.5 -282.5t-116.5 -200.5q-77 -76 -180 -111t-240 -35q-140 0 -244 37t-175 109q-81 82 -116.5 198t-35.5 285v891h198v-901q0 -121 16.5 -191t55.5 -127q44 -65 119.5 -98t181.5 -33q107 0 182 32.5t120 98.5q39 57 55.5 130.5t16.5 182.5v906h198 v-891z',\n            'M1374 1489l-542 -1489h-264l-542 1489h212l467 -1310l467 1310h202z',\n            'M1933 1489l-387 -1489h-223l-313 1236l-306 -1236h-218l-394 1489h203l313 -1238l308 1238h201l311 -1250l311 1250h194z',\n            'M1336 1489l-514 -736l513 -753h-229l-406 613l-416 -613h-216l519 744l-507 745h228l401 -605l410 605h217z',\n            'M1254 1489l-524 -836v-653h-198v632l-526 857h219l407 -666l411 666h211z',\n            'M1288 0h-1162v184l913 1129h-879v176h1106v-179l-922 -1134h944v-176z',\n            'M759 -392h-520v1948h520v-143h-346v-1662h346v-143z',\n            'M960 -304h-173l-717 1860h176z',\n            'M691 -392h-520v143h346v1662h-346v143h520v-1948z',\n            'M1490 684h-198l-455 627l-454 -629h-197l589 807h126z',\n            'M1306 -300h-1310v120h1310v-120z',\n            'M762 1302h-149l-273 374h243z',\n            'M1053 0h-187v119q-25 -17 -67.5 -47.5t-82.5 -48.5q-47 -23 -108 -38.5t-143 -15.5q-151 0 -256 100t-105 255q0 127 54.5 205.5t155.5 123.5q102 45 245 61t307 24v29q0 64 -22.5 106t-64.5 66q-40 23 -96 31t-117 8q-74 0 -165 -19.5t-188 -56.5h-10v191q55 15 159 33 t205 18q118 0 205.5 -19.5t151.5 -66.5q63 -46 96 -119t33 -181v-758zM866 275v311q-86 -5 -202.5 -15t-184.5 -29q-81 -23 -131 -71.5t-50 -133.5q0 -96 58 -144.5t177 -48.5q99 0 181 38.5t152 92.5z',\n            'M1168 567q0 -140 -39.5 -252t-106.5 -188q-71 -79 -156 -118.5t-187 -39.5q-95 0 -166 22.5t-140 60.5l-12 -52h-176v1556h188v-556q79 65 168 106.5t200 41.5q198 0 312.5 -152t114.5 -429zM974 562q0 200 -66 303.5t-213 103.5q-82 0 -166 -35.5t-156 -91.5v-640 q80 -36 137.5 -50t130.5 -14q156 0 244.5 102.5t88.5 321.5z',\n            'M1011 70q-94 -45 -178.5 -70t-179.5 -25q-121 0 -222 35.5t-173 107.5q-73 72 -113 182t-40 257q0 274 150.5 430t397.5 156q96 0 188.5 -27t169.5 -66v-209h-10q-86 67 -177.5 103t-178.5 36q-160 0 -252.5 -107.5t-92.5 -315.5q0 -202 90.5 -310.5t254.5 -108.5 q57 0 116 15t106 39q41 21 77 44.5t57 40.5h10v-207z',\n            'M1091 0h-188v117q-81 -70 -169 -109t-191 -39q-200 0 -317.5 154t-117.5 427q0 142 40.5 253t109.5 189q68 76 158.5 116t187.5 40q88 0 156 -18.5t143 -57.5v484h188v-1556zM903 275v641q-76 34 -136 47t-131 13q-158 0 -246 -110t-88 -312q0 -199 68 -302.5t218 -103.5 q80 0 162 35.5t153 91.5z',\n            'M1120 539h-823q0 -103 31 -179.5t85 -125.5q52 -48 123.5 -72t157.5 -24q114 0 229.5 45.5t164.5 89.5h10v-205q-95 -40 -194 -67t-208 -27q-278 0 -434 150.5t-156 427.5q0 274 149.5 435t393.5 161q226 0 348.5 -132t122.5 -375v-102zM937 683q-1 148 -74.5 229 t-223.5 81q-151 0 -240.5 -89t-101.5 -221h640z',\n            'M786 1374h-10q-31 9 -81 18.5t-88 9.5q-121 0 -175.5 -53.5t-54.5 -193.5v-38h339v-158h-333v-959h-188v959h-127v158h127v37q0 199 99 305.5t286 106.5q63 0 113.5 -6t92.5 -14v-172z',\n            'M1091 127q0 -284 -129 -417t-397 -133q-89 0 -173.5 12.5t-166.5 35.5v192h10q46 -18 146 -44.5t200 -26.5q96 0 159 23t98 64q35 39 50 94t15 123v102q-85 -68 -162.5 -101.5t-197.5 -33.5q-200 0 -317.5 144.5t-117.5 407.5q0 144 40.5 248.5t110.5 180.5 q65 71 158 110.5t185 39.5q97 0 162.5 -19.5t138.5 -59.5l12 48h176v-990zM903 307v609q-75 34 -139.5 48.5t-128.5 14.5q-155 0 -244 -104t-89 -302q0 -188 66 -285t219 -97q82 0 164.5 31.5t151.5 84.5z',\n            'M1119 0h-188v636q0 77 -9 144.5t-33 105.5q-25 42 -72 62.5t-122 20.5q-77 0 -161 -38t-161 -97v-834h-188v1556h188v-563q88 73 182 114t193 41q181 0 276 -109t95 -314v-725z',\n            'M387 1304h-212v195h212v-195zM375 0h-188v1117h188v-1117z',\n            'M533 1304h-212v195h212v-195zM521 -27q0 -196 -100 -296t-268 -100q-40 0 -105.5 8t-109.5 20v179h10q28 -11 75.5 -25t92.5 -14q72 0 116 20t66 60t28.5 96.5t6.5 137.5v900h-233v158h421v-1144z',\n            'M1199 0h-248l-448 489l-122 -116v-373h-188v1556h188v-998l543 559h237l-519 -516z',\n            'M375 0h-188v1556h188v-1556z',\n            'M1815 0h-188v636q0 72 -6.5 139t-27.5 107q-23 43 -66 65t-124 22q-79 0 -158 -39.5t-158 -100.5q3 -23 5 -53.5t2 -60.5v-715h-188v636q0 74 -6.5 140.5t-27.5 106.5q-23 43 -66 64.5t-124 21.5q-77 0 -154.5 -38t-154.5 -97v-834h-188v1117h188v-124q88 73 175.5 114 t186.5 41q114 0 193.5 -48t118.5 -133q114 96 208 138.5t201 42.5q184 0 271.5 -111.5t87.5 -311.5v-725z',\n            'M1119 0h-188v636q0 77 -9 144.5t-33 105.5q-25 42 -72 62.5t-122 20.5q-77 0 -161 -38t-161 -97v-834h-188v1117h188v-124q88 73 182 114t193 41q181 0 276 -109t95 -314v-725z',\n            'M1137 558q0 -273 -140 -431t-375 -158q-237 0 -376.5 158t-139.5 431t139.5 431.5t376.5 158.5q235 0 375 -158.5t140 -431.5zM943 558q0 217 -85 322.5t-236 105.5q-153 0 -237.5 -105.5t-84.5 -322.5q0 -210 85 -318.5t237 -108.5q150 0 235.5 107.5t85.5 319.5z',\n            'M1168 572q0 -136 -39 -248.5t-110 -190.5q-66 -74 -155.5 -114.5t-189.5 -40.5q-87 0 -157.5 19t-143.5 59v-468h-188v1529h188v-117q75 63 168.5 105.5t199.5 42.5q202 0 314.5 -152.5t112.5 -423.5zM974 567q0 202 -69 302t-212 100q-81 0 -163 -35t-157 -92v-633 q80 -36 137.5 -49t130.5 -13q157 0 245 106t88 314z',\n            'M1091 -412h-188v538q-87 -75 -173 -111.5t-186 -36.5q-199 0 -317.5 153.5t-118.5 423.5q0 144 41.5 254.5t109.5 185.5q66 73 155 113t188 40q90 0 159.5 -20t141.5 -59l12 48h176v-1529zM903 284v632q-78 35 -138 49t-130 14q-163 0 -248 -110.5t-85 -304.5 q0 -196 68.5 -301.5t215.5 -105.5q82 0 164 35.5t153 91.5z',\n            'M882 912h-10q-42 10 -81.5 14.5t-93.5 4.5q-87 0 -168 -38.5t-156 -99.5v-793h-188v1117h188v-165q112 90 197.5 127.5t174.5 37.5q49 0 71 -2.5t66 -9.5v-193z',\n            'M983 322q0 -153 -126.5 -251t-345.5 -98q-124 0 -227.5 29.5t-173.5 64.5v211h10q89 -67 198 -106.5t209 -39.5q124 0 194 40t70 126q0 66 -38 100t-146 58q-40 9 -104.5 21t-117.5 26q-147 39 -208.5 114.5t-61.5 185.5q0 69 28.5 130t86.5 109q56 47 142.5 74.5 t193.5 27.5q100 0 202.5 -24.5t170.5 -59.5v-201h-10q-72 53 -175 89.5t-202 36.5q-103 0 -174 -39.5t-71 -117.5q0 -69 43 -104q42 -35 136 -57q52 -12 116.5 -24t107.5 -22q131 -30 202 -103q71 -74 71 -196z',\n            'M765 10q-53 -14 -115.5 -23t-111.5 -9q-171 0 -260 92t-89 295v594h-127v158h127v321h188v-321h388v-158h-388v-509q0 -88 4 -137.5t28 -92.5q22 -40 60.5 -58.5t117.5 -18.5q46 0 96 13.5t72 22.5h10v-169z',\n            'M1111 0h-188v124q-95 -75 -182 -115t-192 -40q-176 0 -274 107.5t-98 315.5v725h188v-636q0 -85 8 -145.5t34 -103.5q27 -44 70 -64t125 -20q73 0 159.5 38t161.5 97v834h188v-1117z',\n            'M1151 1117l-452 -1117h-189l-449 1117h204l346 -889l343 889h197z',\n            'M1590 1117l-291 -1117h-174l-287 861l-285 -861h-173l-294 1117h196l205 -865l279 865h155l286 -865l194 865h189z',\n            'M1152 0h-237l-317 429l-319 -429h-219l436 557l-432 560h237l315 -422l316 422h220l-439 -550z',\n            'M1151 1117l-652 -1529h-201l208 466l-445 1063h204l343 -828l346 828h197z',\n            'M995 0h-902v139l651 821h-637v157h871v-134l-654 -824h671v-159z',\n            'M1113 -392h-150q-179 0 -290.5 99.5t-111.5 287.5v149q0 169 -83 264.5t-254 95.5h-51v156h51q171 0 254 95.5t83 264.5v149q0 188 111.5 287.5t290.5 99.5h150v-138h-114q-136 0 -197.5 -63t-61.5 -203v-175q0 -139 -77 -233.5t-214 -149.5v-24q137 -55 214 -149.5 t77 -233.5v-175q0 -140 61.5 -203t197.5 -63h114v-138z',\n            'M552 -392h-174v1948h174v-1948z',\n            'M1127 504h-51q-171 0 -254 -95.5t-83 -264.5v-149q0 -188 -111.5 -287.5t-290.5 -99.5h-150v138h114q136 0 197.5 63t61.5 203v175q0 139 77 233.5t214 149.5v24q-137 55 -214 149.5t-77 233.5v175q0 140 -61.5 203t-197.5 63h-114v138h150q179 0 290.5 -99.5 t111.5 -287.5v-149q0 -169 83 -264.5t254 -95.5h51v-156z',\n            'M1489 927q-2 -99 -22.5 -195t-65.5 -171q-46 -77 -111 -121t-165 -44q-94 0 -167 39.5t-157 141.5q-102 125 -148 157t-96 32q-94 0 -144 -87.5t-59 -283.5h-167q2 100 22.5 194.5t64.5 171.5q43 74 112 119.5t165 45.5q93 0 166.5 -38.5t158.5 -142.5q80 -98 131 -143.5 t112 -45.5q103 0 151.5 101t51.5 270h167z',\n            '',\n            'M505 1278h-204v211h204v-211zM515 0h-224l26 1079h170z',\n            'M1120 74q-71 -30 -161 -53.5t-194 -26.5v-355h-118v359q-227 21 -357.5 165t-130.5 394q0 242 133.5 391.5t354.5 171.5v355h118v-351q104 -3 197 -25t158 -53v-203h-11q-55 44 -142 85t-202 50v-839q120 10 206.5 52.5t137.5 83.5h11v-201zM647 142v834 q-135 -20 -216 -125t-81 -294q0 -181 76 -286t221 -129z',\n            'M1163 0h-1026v207q118 32 169.5 126.5t51.5 279.5h-176v138h176v310q0 200 126.5 328.5t331.5 128.5q105 0 181 -17t140 -34v-206h-10q-62 42 -138 66t-162 24q-140 0 -209.5 -82.5t-69.5 -226.5v-291h415v-138h-415v-61q0 -126 -62 -219.5t-160 -150.5v-11h837v-171z ',\n            'M1168 257l-110 -110l-236 234q-44 -26 -81 -37t-89 -11q-46 0 -89.5 12.5t-79.5 35.5l-236 -236l-109 113l233 234q-23 37 -35 81.5t-12 87.5q0 52 11 88.5t37 79.5l-234 237l111 110l235 -235q36 23 79.5 35.5t88.5 12.5q44 0 88 -12t81 -35l234 234l113 -109l-235 -237 q24 -38 36 -79.5t12 -89.5q0 -45 -12.5 -89t-35.5 -80zM832 661q0 73 -52.5 129t-127.5 56q-73 0 -126.5 -55t-53.5 -130q0 -74 52.5 -129.5t127.5 -55.5q73 0 126.5 54.5t53.5 130.5z',\n            'M1191 1489l-448 -831v-94h372v-138h-370v-426h-188v426h-370v138h372v73l-451 852h212l332 -659l336 659h203z',\n            'M552 758h-174v798h174v-798zM552 -392h-174v798h174v-798z',\n            'M1128 601q0 -106 -59 -187t-158 -136v-7q97 -46 141 -118.5t44 -162.5q0 -77 -33 -146t-98 -119q-72 -56 -169 -83t-221 -27q-87 0 -170.5 13.5t-175.5 44.5v194h10q79 -37 169 -62t198 -25q134 0 215 48.5t81 135.5q0 56 -19.5 88.5t-64.5 57.5q-41 23 -113 41.5 t-154 38.5q-214 52 -296 133q-83 81 -83 210q0 98 57 182.5t159 141.5v7q-101 48 -143 121t-42 162q0 81 32 146.5t99 117.5q64 50 163.5 79t227.5 29q87 0 171 -14t175 -43v-194h-10q-58 27 -152.5 57t-215.5 30q-127 0 -211.5 -46t-84.5 -133q0 -57 21.5 -92.5t64.5 -58.5 t109 -41.5t157 -39.5q200 -46 290 -125q89 -79 89 -218zM881 399q28 33 43 65.5t15 90.5q0 51 -16.5 86t-45.5 58q-28 24 -67 39.5t-83 27.5q-39 11 -85.5 21.5t-116.5 30.5q-18 -9 -49 -31.5t-53 -46.5q-24 -26 -43 -69t-19 -92q0 -50 15.5 -85t44.5 -59q27 -23 67.5 -39 t84.5 -27q38 -10 86 -22t115 -31q20 11 53 34.5t54 48.5z',\n            'M958 1304h-199v195h199v-195zM545 1304h-199v195h199v-195z',\n            'M1889 655q0 -358 -253.5 -611.5t-611.5 -253.5t-611.5 253.5t-253.5 611.5t253.5 611.5t611.5 253.5t611.5 -253.5t253.5 -611.5zM1773 655q0 310 -219.5 532t-529.5 222t-529.5 -222t-219.5 -532t219.5 -532t529.5 -222t529.5 222t219.5 532zM1375 258 q-86 -39 -165.5 -58.5t-157.5 -19.5q-227 0 -359 123t-132 357q0 225 134.5 354t356.5 129q89 0 175 -24t148 -52v-181h-16q-54 40 -138.5 75t-173.5 35q-142 0 -221.5 -85.5t-79.5 -250.5q0 -159 76.5 -246t224.5 -87q83 0 161.5 29t150.5 81h16v-179z',\n            'M944 554h-170v94q-28 -20 -52.5 -38.5t-68.5 -37.5q-45 -20 -85.5 -30.5t-113.5 -10.5q-128 0 -215.5 85t-87.5 217q0 106 46.5 173.5t123.5 103.5q78 36 197.5 51.5t255.5 21.5v18q0 53 -18 85t-51 51q-34 18 -77.5 23t-91.5 5q-84 0 -168 -24t-123 -38h-14v172 q45 13 137 29t169 16q217 0 312 -84.5t95 -243.5v-638zM774 796v245q-69 -4 -160.5 -12t-145.5 -23q-64 -18 -103 -56.5t-39 -106.5q0 -76 45.5 -114t139.5 -38q82 0 147.5 33.5t115.5 71.5z',\n            'M1146 191l-528 419v85l528 418v-188l-357 -273l357 -273v-188zM716 162l-550 446v89l550 445v-196l-371 -294l371 -294v-196z',\n            'M1456 57h-171v545h-1075v160h1246v-705z',\n            'M777 561h-624v181h624v-181z',\n            'M1889 655q0 -358 -253.5 -611.5t-611.5 -253.5t-611.5 253.5t-253.5 611.5t253.5 611.5t611.5 253.5t611.5 -253.5t253.5 -611.5zM1773 655q0 310 -219.5 532t-529.5 222t-529.5 -222t-219.5 -532t219.5 -532t529.5 -222t529.5 222t219.5 532zM1581 215h-223l-331 355 h-162v-355h-165v915h312q94 0 155 -8t120 -39q63 -34 92.5 -82.5t29.5 -121.5q0 -97 -56.5 -161.5t-155.5 -102.5zM1229 868q0 36 -14 64t-47 46q-31 17 -66 22t-88 5h-149v-309h127q62 0 107 9.5t74 32.5q31 25 43.5 55t12.5 75z',\n            'M1306 1668h-1305l-5 120h1310v-120z',\n            'M956 1116q0 -168 -116 -284t-285 -116t-285 115.5t-116 284.5q0 168 116 284t285 116q170 0 285.5 -116t115.5 -284zM791 1116q0 102 -67 171.5t-169 69.5t-169 -69.5t-67 -171.5q0 -104 68.5 -172.5t167.5 -68.5q102 0 169 70t67 171z',\n            'M1461 179h-1246v158h540v422h-540v158h540v545h166v-545h540v-158h-540v-422h540v-158z',\n            'M967 566h-760v156q100 62 183.5 117t134.5 96q131 103 168 154.5t37 135.5q0 69 -53.5 107t-143.5 38q-89 0 -175 -30.5t-134 -61.5h-13v180q71 26 158.5 43.5t174.5 17.5q180 0 273.5 -78.5t93.5 -203.5q0 -99 -48.5 -174.5t-163.5 -165.5q-55 -43 -132.5 -94 t-143.5 -92h544v-145z',\n            'M956 817q0 -75 -33 -131.5t-89 -90.5q-57 -35 -131 -51.5t-163 -16.5q-94 0 -176.5 15t-156.5 43v179h14q41 -36 138.5 -65.5t190.5 -29.5q100 0 166.5 35.5t66.5 110.5q0 85 -59 115t-171 30h-143v141h128q112 0 165.5 38.5t53.5 106.5q0 61 -49.5 96.5t-153.5 35.5 q-77 0 -174.5 -31t-141.5 -67h-14v178q74 27 160.5 44.5t176.5 17.5q175 0 271.5 -68t96.5 -174q0 -89 -55 -146t-144 -83v-8q95 -17 160.5 -72.5t65.5 -151.5z',\n            'M963 1676l-273 -374h-149l179 374h243z',\n            'M1124 0h-178l-10 118q-59 -65 -123.5 -102t-155.5 -37q-86 0 -149.5 35t-129.5 99v-525h-188v1529h188v-838q32 -39 109.5 -80t168.5 -41q93 0 159.5 33.5t120.5 93.5v832h188v-1117z',\n            'M1106 -363h-148v1722h-214v-1722h-149v956q-206 5 -332 129t-126 328q0 207 130 323t373 116h466v-1852z',\n            'M492 511h-239v283h239v-283z',\n            'M880 -89q0 -162 -91.5 -248t-237.5 -86q-37 0 -95 7t-103 19v160h9q26 -10 70 -23t94 -13q104 0 153 39t49 127q0 29 -3 65.5t-6 61.5h153q2 -19 5 -45t3 -64z',\n            'M914 566h-615v122h234v568h-242v112q45 0 99 6.5t84 18.5q37 16 59 38t25 62h135v-805h221v-122z',\n            'M996 1025q0 -235 -122 -364.5t-315 -129.5q-201 0 -319.5 132.5t-118.5 361.5t118.5 362t319.5 133q193 0 315 -130t122 -365zM814 1025q0 172 -67.5 258t-187.5 86q-122 0 -189 -87t-67 -257t67 -256.5t189 -86.5q120 0 187.5 85.5t67.5 257.5z',\n            'M1154 608l-550 -446v196l371 294l-371 294v196l550 -445v-89zM702 610l-528 -419v188l357 273l-357 273v188l528 -418v-85z',\n            'M545 565h-165v681h-209v117q102 0 165 22t72 108h137v-928zM1410 1489l-780 -1489h-165l780 1489h165zM1857 220h-163v-220h-150v220h-465v185l466 539h149v-591h163v-133zM1548 353v400l-353 -400h353z',\n            'M545 565h-165v681h-209v117q102 0 165 22t72 108h137v-928zM1410 1489l-780 -1489h-165l780 1489h165zM1955 0h-688v148q91 69 158 121t106 89q109 103 141 157.5t32 136.5q0 70 -44 107t-120 37q-70 0 -141.5 -30t-112.5 -62h-15v179q65 27 140.5 44t152.5 17 q157 0 241.5 -79t84.5 -201q0 -93 -41 -167t-147 -168q-49 -43 -119.5 -96t-125.5 -94h498v-139z',\n            'M793 826q0 -71 -30 -127t-78 -90q-53 -37 -114.5 -53t-140.5 -16q-82 0 -153.5 15t-136.5 43v175h17q37 -35 114 -64.5t156 -29.5q84 0 139 36.5t55 108.5q0 83 -50 112.5t-141 29.5h-140v139h125q87 0 134.5 38t47.5 104q0 60 -41 95.5t-128 35.5q-66 0 -142.5 -31 t-113.5 -66h-17v175q64 27 139 44t154 17q152 0 237 -70t85 -168q0 -87 -48.5 -143.5t-125.5 -82.5v-8q80 -16 138.5 -70.5t58.5 -148.5zM1500 1489l-780 -1489h-165l780 1489h165zM1913 220h-163v-220h-150v220h-465v185l466 539h149v-591h163v-133zM1604 353v400 l-353 -400h353z',\n            'M712 1278h-204v211h204v-211zM958 40q-83 -30 -176 -50t-205 -20q-215 0 -339.5 104.5t-124.5 275.5q0 98 34.5 173t93.5 137q58 62 136.5 112.5t146.5 91.5v225h179v-305q-60 -33 -139 -81.5t-125 -88.5q-54 -47 -88 -109t-34 -140q0 -113 76.5 -168.5t197.5 -55.5 q103 0 201.5 33t155.5 70h10v-204z',\n            'M1374 0h-211l-146 415h-644l-146 -415h-201l542 1489h264zM956 585l-261 731l-262 -731h523zM862 1675h-149l-273 374h243z',\n            'M1374 0h-211l-146 415h-644l-146 -415h-201l542 1489h264zM956 585l-261 731l-262 -731h523zM955 2049l-273 -374h-149l179 374h243z',\n            'M1374 0h-211l-146 415h-644l-146 -415h-201l542 1489h264zM956 585l-261 731l-262 -731h523zM1033 1670h-159l-185 256l-184 -256h-155l228 379h227z',\n            'M1374 0h-211l-146 415h-644l-146 -415h-201l542 1489h264zM956 585l-261 731l-262 -731h523zM1119 1992q-11 -152 -77 -229t-177 -77q-54 0 -100 19.5t-87 56.5q-47 43 -79.5 64.5t-71.5 21.5q-52 0 -78 -45t-30 -121h-131q8 151 79 228t174 77q50 0 96.5 -19.5 t88.5 -55.5q47 -41 83.5 -61.5t69.5 -20.5q51 0 79.5 46t31.5 116h129z',\n            'M1374 0h-211l-146 415h-644l-146 -415h-201l542 1489h264zM956 585l-261 731l-262 -731h523zM1005 1677h-199v195h199v-195zM592 1677h-199v195h199v-195z',\n            'M1374 0h-211l-148 415h-640l-148 -415h-201l519 1407q-89 44 -142.5 123.5t-53.5 181.5q0 143 102 240t248 97q147 0 248.5 -97t101.5 -240q0 -100 -52.5 -181.5t-141.5 -123.5zM899 1710q0 86 -57 143.5t-143 57.5t-143 -58t-57 -143q0 -86 57.5 -143.5t142.5 -57.5 q86 0 143 57.5t57 143.5zM953 585l-258 715l-259 -715h517z',\n            'M1901 0h-944v556h-524l-212 -556h-207l594 1489h1293v-176h-749v-408h749v-176h-749v-553h749v-176zM957 723v601h-219l-239 -601h458z',\n            'M1350 108q-55 -24 -99.5 -45t-116.5 -44q-11 -3 -24 -7.5t-31 -7.5q2 -19 3.5 -44.5t1.5 -48.5q0 -162 -93.5 -248t-240.5 -86q-38 0 -97.5 7t-104.5 19v162h9q26 -10 71.5 -24t95.5 -14q106 0 155 40t49 126q0 19 -1 41.5t-3 42.5q-19 -2 -40.5 -3t-39.5 -1 q-162 0 -294.5 45.5t-230.5 142.5q-96 95 -150 241.5t-54 340.5q0 184 52 329t150 245q95 97 229.5 148t298.5 51q120 0 239.5 -29t265.5 -102v-235h-15q-123 103 -244 150t-259 47q-113 0 -203.5 -36.5t-161.5 -113.5q-69 -75 -107.5 -189.5t-38.5 -264.5q0 -157 42.5 -270 t109.5 -184q70 -74 163.5 -109.5t197.5 -35.5q143 0 268 49t234 147h14v-232z',\n            'M1181 0h-981v1489h981v-176h-783v-408h783v-176h-783v-553h783v-176zM822 1675h-149l-273 374h243z',\n            'M1181 0h-981v1489h981v-176h-783v-408h783v-176h-783v-553h783v-176zM993 2049l-273 -374h-149l179 374h243z',\n            'M1181 0h-981v1489h981v-176h-783v-408h783v-176h-783v-553h783v-176zM1031 1670h-159l-185 256l-184 -256h-155l228 379h227z',\n            'M1181 0h-981v1489h981v-176h-783v-408h783v-176h-783v-553h783v-176zM1038 1677h-199v195h199v-195zM625 1677h-199v195h199v-195z',\n            'M725 0h-588v152h195v1185h-195v152h588v-152h-195v-1185h195v-152zM568 1675h-149l-273 374h243z',\n            'M725 0h-588v152h195v1185h-195v152h588v-152h-195v-1185h195v-152zM725 2049l-273 -374h-149l179 374h243z',\n            'M725 0h-588v152h195v1185h-195v152h588v-152h-195v-1185h195v-152zM776 1670h-159l-185 256l-184 -256h-155l228 379h227z',\n            'M725 0h-588v152h195v1185h-195v152h588v-152h-195v-1185h195v-152zM738 1677h-199v195h199v-195zM325 1677h-199v195h199v-195z',\n            'M1468 743q0 -203 -88.5 -368t-235.5 -256q-102 -63 -227.5 -91t-330.5 -28h-376v740h-196v143h196v606h372q218 0 347 -31.5t217 -86.5q152 -95 237 -253t85 -375zM1261 746q0 175 -61 295t-182 189q-88 50 -187 69.5t-237 19.5h-188v-436h361v-143h-361v-570h188 q143 0 249.5 21t195.5 78q111 71 166.5 187t55.5 290z',\n            'M1336 0h-245l-706 1332v-1332h-185v1489h307l644 -1216v1216h185v-1489zM1208 1992q-11 -152 -77 -229t-177 -77q-54 0 -100 19.5t-87 56.5q-47 43 -79.5 64.5t-71.5 21.5q-52 0 -78 -45t-30 -121h-131q8 151 79 228t174 77q50 0 96.5 -19.5t88.5 -55.5 q47 -41 83.5 -61.5t69.5 -20.5q51 0 79.5 46t31.5 116h129z',\n            'M1310 1318q91 -100 139.5 -245t48.5 -329t-49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5zM1292 744 q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5zM932 1675h-149l-273 374h243z',\n            'M1310 1318q91 -100 139.5 -245t48.5 -329t-49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5zM1292 744 q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5zM1083 2049l-273 -374h-149l179 374h243z',\n            'M1310 1318q91 -100 139.5 -245t48.5 -329t-49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5zM1292 744 q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5zM1136 1670h-159l-185 256l-184 -256h-155l228 379h227z',\n            'M1310 1318q91 -100 139.5 -245t48.5 -329t-49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5zM1292 744 q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5zM1207 1992q-11 -152 -77 -229t-177 -77q-54 0 -100 19.5t-87 56.5q-47 43 -79.5 64.5t-71.5 21.5q-52 0 -78 -45t-30 -121h-131q8 151 79 228 t174 77q50 0 96.5 -19.5t88.5 -55.5q47 -41 83.5 -61.5t69.5 -20.5q51 0 79.5 46t31.5 116h129z',\n            'M1307 1318q91 -100 139.5 -245t48.5 -329t-49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5zM1289 744 q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5zM1108 1677h-199v195h199v-195zM695 1677h-199v195h199v-195z',\n            'M1385 216l-111 -111l-436 440l-436 -440l-111 111l440 436l-440 436l111 111l436 -440l436 440l111 -111l-440 -436z',\n            'M1498 744q0 -184 -49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-115 0 -215.5 29t-179.5 84l-159 -228h-132l205 294q-101 100 -155.5 250t-54.5 346q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q118 0 215 -27.5t179 -82.5l142 201h132 l-188 -268q101 -100 156.5 -248.5t55.5 -350.5zM1097 1260q-57 46 -129 68.5t-161 22.5q-110 0 -200 -38.5t-156 -116.5q-64 -76 -98.5 -190.5t-34.5 -261.5q0 -140 29.5 -252t87.5 -188zM1295 744q0 139 -30 253t-88 189l-664 -957q60 -45 132.5 -68t161.5 -23 q110 0 201.5 40t153.5 116q67 82 100 194.5t33 255.5z',\n            'M1321 598q0 -162 -35.5 -282.5t-116.5 -200.5q-77 -76 -180 -111t-240 -35q-140 0 -244 37t-175 109q-81 82 -116.5 198t-35.5 285v891h198v-901q0 -121 16.5 -191t55.5 -127q44 -65 119.5 -98t181.5 -33q107 0 182 32.5t120 98.5q39 57 55.5 130.5t16.5 182.5v906h198 v-891zM932 1675h-149l-273 374h243z',\n            'M1321 598q0 -162 -35.5 -282.5t-116.5 -200.5q-77 -76 -180 -111t-240 -35q-140 0 -244 37t-175 109q-81 82 -116.5 198t-35.5 285v891h198v-901q0 -121 16.5 -191t55.5 -127q44 -65 119.5 -98t181.5 -33q107 0 182 32.5t120 98.5q39 57 55.5 130.5t16.5 182.5v906h198 v-891zM1073 2049l-273 -374h-149l179 374h243z',\n            'M1321 598q0 -162 -35.5 -282.5t-116.5 -200.5q-77 -76 -180 -111t-240 -35q-140 0 -244 37t-175 109q-81 82 -116.5 198t-35.5 285v891h198v-901q0 -121 16.5 -191t55.5 -127q44 -65 119.5 -98t181.5 -33q107 0 182 32.5t120 98.5q39 57 55.5 130.5t16.5 182.5v906h198 v-891zM1084 1670h-159l-185 256l-184 -256h-155l228 379h227z',\n            'M1321 598q0 -162 -35.5 -282.5t-116.5 -200.5q-77 -76 -180 -111t-240 -35q-140 0 -244 37t-175 109q-81 82 -116.5 198t-35.5 285v891h198v-901q0 -121 16.5 -191t55.5 -127q44 -65 119.5 -98t181.5 -33q107 0 182 32.5t120 98.5q39 57 55.5 130.5t16.5 182.5v906h198 v-891zM1056 1677h-199v195h199v-195zM643 1677h-199v195h199v-195z',\n            'M1254 1489l-524 -836v-653h-198v632l-526 857h219l407 -666l411 666h211zM935 2049l-273 -374h-149l179 374h243z',\n            'M1174 787q0 -92 -35 -176.5t-95 -141.5q-78 -75 -187.5 -111t-260.5 -36h-198v-322h-198v1489h198v-270h205q133 0 230 -22.5t164 -66.5q83 -53 130 -138t47 -205zM968 782q0 72 -26 125.5t-82 88.5q-48 30 -112 42.5t-154 12.5h-196v-563h167q119 0 195 20.5t123 65.5 q44 41 64.5 92t20.5 116z',\n            'M1165 481q0 -214 -135.5 -359.5t-354.5 -145.5q-44 0 -101.5 7.5t-93.5 20.5v165h10q42 -24 91.5 -33t105.5 -9q74 0 129 29t88 78q35 52 50.5 115.5t15.5 139.5q0 166 -105.5 250.5t-303.5 84.5v150q157 0 234 59.5t77 188.5q0 35 -11 68t-41 64q-27 29 -71 46.5 t-105 17.5q-57 0 -103 -14.5t-86 -53.5q-37 -36 -59.5 -102t-22.5 -161v-1087h-188v1080q0 124 36 215.5t100 153.5q60 58 149.5 87.5t183.5 29.5q183 0 297.5 -87t114.5 -238q0 -112 -71 -201t-184 -121v-9q164 -37 259 -148.5t95 -280.5z',\n            'M1053 0h-187v119q-25 -17 -67.5 -47.5t-82.5 -48.5q-47 -23 -108 -38.5t-143 -15.5q-151 0 -256 100t-105 255q0 127 54.5 205.5t155.5 123.5q102 45 245 61t307 24v29q0 64 -22.5 106t-64.5 66q-40 23 -96 31t-117 8q-74 0 -165 -19.5t-188 -56.5h-10v191q55 15 159 33 t205 18q118 0 205.5 -19.5t151.5 -66.5q63 -46 96 -119t33 -181v-758zM866 275v311q-86 -5 -202.5 -15t-184.5 -29q-81 -23 -131 -71.5t-50 -133.5q0 -96 58 -144.5t177 -48.5q99 0 181 38.5t152 92.5zM738 1302h-149l-273 374h243z',\n            'M1053 0h-187v119q-25 -17 -67.5 -47.5t-82.5 -48.5q-47 -23 -108 -38.5t-143 -15.5q-151 0 -256 100t-105 255q0 127 54.5 205.5t155.5 123.5q102 45 245 61t307 24v29q0 64 -22.5 106t-64.5 66q-40 23 -96 31t-117 8q-74 0 -165 -19.5t-188 -56.5h-10v191q55 15 159 33 t205 18q118 0 205.5 -19.5t151.5 -66.5q63 -46 96 -119t33 -181v-758zM866 275v311q-86 -5 -202.5 -15t-184.5 -29q-81 -23 -131 -71.5t-50 -133.5q0 -96 58 -144.5t177 -48.5q99 0 181 38.5t152 92.5zM934 1676l-273 -374h-149l179 374h243z',\n            'M1053 0h-187v119q-25 -17 -67.5 -47.5t-82.5 -48.5q-47 -23 -108 -38.5t-143 -15.5q-151 0 -256 100t-105 255q0 127 54.5 205.5t155.5 123.5q102 45 245 61t307 24v29q0 64 -22.5 106t-64.5 66q-40 23 -96 31t-117 8q-74 0 -165 -19.5t-188 -56.5h-10v191q55 15 159 33 t205 18q118 0 205.5 -19.5t151.5 -66.5q63 -46 96 -119t33 -181v-758zM866 275v311q-86 -5 -202.5 -15t-184.5 -29q-81 -23 -131 -71.5t-50 -133.5q0 -96 58 -144.5t177 -48.5q99 0 181 38.5t152 92.5zM961 1297h-159l-185 256l-184 -256h-155l228 379h227z',\n            'M1053 0h-187v119q-25 -17 -67.5 -47.5t-82.5 -48.5q-47 -23 -108 -38.5t-143 -15.5q-151 0 -256 100t-105 255q0 127 54.5 205.5t155.5 123.5q102 45 245 61t307 24v29q0 64 -22.5 106t-64.5 66q-40 23 -96 31t-117 8q-74 0 -165 -19.5t-188 -56.5h-10v191q55 15 159 33 t205 18q118 0 205.5 -19.5t151.5 -66.5q63 -46 96 -119t33 -181v-758zM866 275v311q-86 -5 -202.5 -15t-184.5 -29q-81 -23 -131 -71.5t-50 -133.5q0 -96 58 -144.5t177 -48.5q99 0 181 38.5t152 92.5zM1038 1619q-11 -152 -77 -229t-177 -77q-54 0 -100 19.5t-87 56.5 q-47 43 -79.5 64.5t-71.5 21.5q-52 0 -78 -45t-30 -121h-131q8 151 79 228t174 77q50 0 96.5 -19.5t88.5 -55.5q47 -41 83.5 -61.5t69.5 -20.5q51 0 79.5 46t31.5 116h129z',\n            'M1053 0h-187v119q-25 -17 -67.5 -47.5t-82.5 -48.5q-47 -23 -108 -38.5t-143 -15.5q-151 0 -256 100t-105 255q0 127 54.5 205.5t155.5 123.5q102 45 245 61t307 24v29q0 64 -22.5 106t-64.5 66q-40 23 -96 31t-117 8q-74 0 -165 -19.5t-188 -56.5h-10v191q55 15 159 33 t205 18q118 0 205.5 -19.5t151.5 -66.5q63 -46 96 -119t33 -181v-758zM866 275v311q-86 -5 -202.5 -15t-184.5 -29q-81 -23 -131 -71.5t-50 -133.5q0 -96 58 -144.5t177 -48.5q99 0 181 38.5t152 92.5zM926 1304h-199v195h199v-195zM513 1304h-199v195h199v-195z',\n            'M1053 0h-187v119q-25 -17 -67.5 -47.5t-82.5 -48.5q-47 -23 -108 -38.5t-143 -15.5q-151 0 -256 100t-105 255q0 127 54.5 205.5t155.5 123.5q102 45 245 61t307 24v29q0 64 -22.5 106t-64.5 66q-40 23 -96 31t-117 8q-74 0 -165 -19.5t-188 -56.5h-10v191q55 15 159 33 t205 18q118 0 205.5 -19.5t151.5 -66.5q63 -46 96 -119t33 -181v-758zM866 275v311q-86 -5 -202.5 -15t-184.5 -29q-81 -23 -131 -71.5t-50 -133.5q0 -96 58 -144.5t177 -48.5q99 0 181 38.5t152 92.5zM956 1630q0 -143 -102 -242t-248 -99q-144 0 -247 98.5t-103 242.5 q0 143 102 241t248 98q147 0 248.5 -98t101.5 -241zM811 1630q0 86 -58.5 145.5t-146.5 59.5t-146.5 -59t-58.5 -146t59 -146t146 -59q88 0 146.5 59t58.5 146z',\n            'M1855 559h-819q0 -114 30 -195t85 -133q52 -48 123 -70.5t157 -22.5q111 0 217.5 41.5t172.5 93.5h12v-205q-78 -35 -184.5 -64.5t-215.5 -29.5q-166 0 -284.5 52t-194.5 155q-21 -19 -67 -59t-96 -68q-63 -36 -137 -59.5t-189 -23.5q-150 0 -255.5 97t-105.5 249 q0 124 54 200.5t155 118.5q95 39 241 53t308 17v61q0 65 -23 107.5t-64 65.5q-40 23 -96 31.5t-116 8.5q-79 0 -168.5 -21t-179.5 -57h-13v191q55 15 158 34t204 19q159 0 264.5 -46.5t162.5 -137.5q69 82 170 134t226 52q217 0 342.5 -128t125.5 -379v-82zM1673 703 q-5 68 -23.5 119t-50.5 88q-34 39 -88.5 61t-133.5 22q-133 0 -223 -75t-115 -215h634zM894 298q-20 53 -30.5 119t-10.5 141q-105 -3 -201 -7.5t-178 -25.5q-79 -20 -127.5 -65.5t-48.5 -128.5q0 -95 58 -141t176 -46q99 0 195.5 43t166.5 111z',\n            'M1011 70q-33 -15 -71.5 -30.5t-67.5 -24.5q3 -19 5.5 -47.5t2.5 -56.5q0 -162 -91.5 -248t-237.5 -86q-37 0 -95 7t-103 19v160h9q26 -10 70 -23t94 -13q104 0 153 39t49 127q0 22 -1.5 45t-3.5 43q-16 -2 -30.5 -4t-39.5 -2q-121 0 -222 35.5t-173 107.5 q-73 72 -113 182t-40 257q0 274 150.5 430t397.5 156q96 0 188.5 -27t169.5 -66v-209h-10q-86 67 -177.5 103t-178.5 36q-160 0 -252.5 -107.5t-92.5 -315.5q0 -202 90.5 -310.5t254.5 -108.5q57 0 116 15t106 39q41 21 77 44.5t57 40.5h10v-207z',\n            'M1120 539h-823q0 -103 31 -179.5t85 -125.5q52 -48 123.5 -72t157.5 -24q114 0 229.5 45.5t164.5 89.5h10v-205q-95 -40 -194 -67t-208 -27q-278 0 -434 150.5t-156 427.5q0 274 149.5 435t393.5 161q226 0 348.5 -132t122.5 -375v-102zM937 683q-1 148 -74.5 229 t-223.5 81q-151 0 -240.5 -89t-101.5 -221h640zM759 1302h-149l-273 374h243z',\n            'M1120 539h-823q0 -103 31 -179.5t85 -125.5q52 -48 123.5 -72t157.5 -24q114 0 229.5 45.5t164.5 89.5h10v-205q-95 -40 -194 -67t-208 -27q-278 0 -434 150.5t-156 427.5q0 274 149.5 435t393.5 161q226 0 348.5 -132t122.5 -375v-102zM937 683q-1 148 -74.5 229 t-223.5 81q-151 0 -240.5 -89t-101.5 -221h640zM960 1676l-273 -374h-149l179 374h243z',\n            'M1120 539h-823q0 -103 31 -179.5t85 -125.5q52 -48 123.5 -72t157.5 -24q114 0 229.5 45.5t164.5 89.5h10v-205q-95 -40 -194 -67t-208 -27q-278 0 -434 150.5t-156 427.5q0 274 149.5 435t393.5 161q226 0 348.5 -132t122.5 -375v-102zM937 683q-1 148 -74.5 229 t-223.5 81q-151 0 -240.5 -89t-101.5 -221h640zM986 1297h-159l-185 256l-184 -256h-155l228 379h227z',\n            'M1120 539h-823q0 -103 31 -179.5t85 -125.5q52 -48 123.5 -72t157.5 -24q114 0 229.5 45.5t164.5 89.5h10v-205q-95 -40 -194 -67t-208 -27q-278 0 -434 150.5t-156 427.5q0 274 149.5 435t393.5 161q226 0 348.5 -132t122.5 -375v-102zM937 683q-1 148 -74.5 229 t-223.5 81q-151 0 -240.5 -89t-101.5 -221h640zM951 1304h-199v195h199v-195zM538 1304h-199v195h199v-195z',\n            'M375 0h-188v1117h188v-1117zM401 1302h-149l-273 374h243z',\n            'M375 0h-188v1117h188v-1117zM582 1676l-273 -374h-149l179 374h243z',\n            'M572 1297h-151l-143 267l-142 -267h-147l178 379h227zM375 0h-188v1117h188v-1117z',\n            'M557 1304h-189v195h189v-195zM194 1304h-189v195h189v-195zM375 0h-188v1117h188v-1117z',\n            'M1137 637q0 -324 -142 -496t-383 -172q-229 0 -367.5 135t-138.5 380q0 226 137 358t339 132q108 0 185.5 -26.5t163.5 -79.5q-32 112 -99.5 219t-154.5 181l-264 -162l-66 97l237 142q-84 67 -156 107.5t-165 87.5v16h295q35 -25 84 -58.5t86 -59.5l210 128l66 -97 l-186 -109q153 -147 236 -325.5t83 -397.5zM847 226q49 59 75 143.5t26 234.5q0 32 -1.5 59.5t-3.5 57.5q-75 45 -157.5 66.5t-168.5 21.5q-147 0 -231.5 -87.5t-84.5 -239.5q0 -180 84.5 -267t227.5 -87q66 0 127.5 22t106.5 76z',\n            'M1119 0h-188v636q0 77 -9 144.5t-33 105.5q-25 42 -72 62.5t-122 20.5q-77 0 -161 -38t-161 -97v-834h-188v1117h188v-124q88 73 182 114t193 41q181 0 276 -109t95 -314v-725zM1075 1619q-11 -152 -77 -229t-177 -77q-54 0 -100 19.5t-87 56.5q-47 43 -79.5 64.5 t-71.5 21.5q-52 0 -78 -45t-30 -121h-131q8 151 79 228t174 77q50 0 96.5 -19.5t88.5 -55.5q47 -41 83.5 -61.5t69.5 -20.5q51 0 79.5 46t31.5 116h129z',\n            'M1137 558q0 -273 -140 -431t-375 -158q-237 0 -376.5 158t-139.5 431t139.5 431.5t376.5 158.5q235 0 375 -158.5t140 -431.5zM943 558q0 217 -85 322.5t-236 105.5q-153 0 -237.5 -105.5t-84.5 -322.5q0 -210 85 -318.5t237 -108.5q150 0 235.5 107.5t85.5 319.5z M732 1302h-149l-273 374h243z',\n            'M1137 558q0 -273 -140 -431t-375 -158q-237 0 -376.5 158t-139.5 431t139.5 431.5t376.5 158.5q235 0 375 -158.5t140 -431.5zM943 558q0 217 -85 322.5t-236 105.5q-153 0 -237.5 -105.5t-84.5 -322.5q0 -210 85 -318.5t237 -108.5q150 0 235.5 107.5t85.5 319.5z M933 1676l-273 -374h-149l179 374h243z',\n            'M1137 558q0 -273 -140 -431t-375 -158q-237 0 -376.5 158t-139.5 431t139.5 431.5t376.5 158.5q235 0 375 -158.5t140 -431.5zM943 558q0 217 -85 322.5t-236 105.5q-153 0 -237.5 -105.5t-84.5 -322.5q0 -210 85 -318.5t237 -108.5q150 0 235.5 107.5t85.5 319.5z M963 1297h-159l-185 256l-184 -256h-155l228 379h227z',\n            'M1137 558q0 -273 -140 -431t-375 -158q-237 0 -376.5 158t-139.5 431t139.5 431.5t376.5 158.5q235 0 375 -158.5t140 -431.5zM943 558q0 217 -85 322.5t-236 105.5q-153 0 -237.5 -105.5t-84.5 -322.5q0 -210 85 -318.5t237 -108.5q150 0 235.5 107.5t85.5 319.5z M1038 1619q-11 -152 -77 -229t-177 -77q-54 0 -100 19.5t-87 56.5q-47 43 -79.5 64.5t-71.5 21.5q-52 0 -78 -45t-30 -121h-131q8 151 79 228t174 77q50 0 96.5 -19.5t88.5 -55.5q47 -41 83.5 -61.5t69.5 -20.5q51 0 79.5 46t31.5 116h129z',\n            'M1137 558q0 -273 -140 -431t-375 -158q-237 0 -376.5 158t-139.5 431t139.5 431.5t376.5 158.5q235 0 375 -158.5t140 -431.5zM943 558q0 217 -85 322.5t-236 105.5q-153 0 -237.5 -105.5t-84.5 -322.5q0 -210 85 -318.5t237 -108.5q150 0 235.5 107.5t85.5 319.5z M928 1304h-199v195h199v-195zM515 1304h-199v195h199v-195z',\n            'M957 1022h-238v275h238v-275zM1466 572h-1256v160h1256v-160zM957 7h-238v275h238v-275z',\n            'M1137 558q0 -273 -140 -431t-375 -158q-84 0 -155.5 21t-130.5 60l-133 -198h-110l171 256q-75 77 -116.5 190t-41.5 260q0 273 139.5 431.5t376.5 158.5q87 0 158 -22t125 -57l116 172h111l-155 -231q76 -76 118 -188t42 -264zM813 930q-37 29 -86.5 43.5t-104.5 14.5 q-155 0 -240 -110t-85 -320q0 -97 17 -171t52 -128zM946 558q0 97 -17.5 173t-51.5 130l-448 -671q39 -31 86.5 -46t106.5 -15q150 0 237 108.5t87 320.5z',\n            'M1111 0h-188v124q-95 -75 -182 -115t-192 -40q-176 0 -274 107.5t-98 315.5v725h188v-636q0 -85 8 -145.5t34 -103.5q27 -44 70 -64t125 -20q73 0 159.5 38t161.5 97v834h188v-1117zM764 1302h-149l-273 374h243z',\n            'M1111 0h-188v124q-95 -75 -182 -115t-192 -40q-176 0 -274 107.5t-98 315.5v725h188v-636q0 -85 8 -145.5t34 -103.5q27 -44 70 -64t125 -20q73 0 159.5 38t161.5 97v834h188v-1117zM945 1676l-273 -374h-149l179 374h243z',\n            'M1111 0h-188v124q-95 -75 -182 -115t-192 -40q-176 0 -274 107.5t-98 315.5v725h188v-636q0 -85 8 -145.5t34 -103.5q27 -44 70 -64t125 -20q73 0 159.5 38t161.5 97v834h188v-1117zM985 1297h-159l-185 256l-184 -256h-155l228 379h227z',\n            'M1111 0h-188v124q-95 -75 -182 -115t-192 -40q-176 0 -274 107.5t-98 315.5v725h188v-636q0 -85 8 -145.5t34 -103.5q27 -44 70 -64t125 -20q73 0 159.5 38t161.5 97v834h188v-1117zM955 1304h-199v195h199v-195zM542 1304h-199v195h199v-195z',\n            'M1151 1117l-652 -1529h-201l208 466l-445 1063h204l343 -828l346 828h197zM928 1676l-273 -374h-149l179 374h243z',\n            'M1168 572q0 -136 -39 -248.5t-110 -190.5q-66 -74 -155.5 -114.5t-189.5 -40.5q-87 0 -157.5 19t-143.5 59v-468h-188v1968h188v-556q75 63 168.5 105.5t199.5 42.5q202 0 314.5 -152.5t112.5 -423.5zM974 567q0 202 -69 302t-212 100q-81 0 -163 -35t-157 -92v-633 q80 -36 137.5 -49t130.5 -13q157 0 245 106t88 314z',\n            'M585 832h-239v285h239v-285zM658 285l-282 -655h-146l174 655h254z',\n            'M773 1676l-49 -384h-145l-49 384h243z',\n            'M765 1676l-49 -384h-128l-49 384h226zM1048 1304h-191v195h191v-195zM447 1304h-191v195h191v-195z',\n            'M1374 0h-211l-146 415h-644l-146 -415h-201l542 1489h264zM956 585l-261 731l-262 -731h523zM250 1489l-49 -384h-145l-49 384h243z',\n            'M585 832h-239v285h239v-285z',\n            'M1424 0h-981v1489h981v-176h-783v-408h783v-176h-783v-553h783v-176zM243 1489l-49 -384h-145l-49 384h243z',\n            'M1582 0h-198v729h-743v-729h-198v1489h198v-584h743v584h198v-1489zM243 1489l-49 -384h-145l-49 384h243z',\n            'M968 0h-588v152h195v1185h-195v152h588v-152h-195v-1185h195v-152zM243 1489l-49 -384h-145l-49 384h243z',\n            'M1501 1318q91 -100 139.5 -245t48.5 -329t-49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5zM1483 744 q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5zM243 1489l-49 -384h-145l-49 384h243z',\n            'M1537 1489l-524 -836v-653h-198v632l-526 857h219l407 -666l411 666h211zM243 1489l-49 -384h-145l-49 384h243z',\n            'M1751 0h-576v387q60 38 119.5 82t103.5 101q45 59 71 138.5t26 185.5q0 206 -127 330.5t-347 124.5t-347 -124.5t-127 -330.5q0 -106 26 -185.5t71 -138.5q45 -57 104 -101t119 -82v-387h-576v174h410v124q-157 90 -258.5 246t-101.5 350q0 276 187.5 451t492.5 175 t492.5 -175t187.5 -451q0 -194 -101.5 -350t-258.5 -246v-124h410v-174zM243 1489l-49 -384h-145l-49 384h243z',\n            'M375 0h-188v1117h188v-1117zM379 1676l-56 -384h-84l-56 384h196zM615 1304h-171v195h171v-195zM118 1304h-171v195h171v-195z',\n            'M1374 0h-211l-146 415h-644l-146 -415h-201l542 1489h264zM956 585l-261 731l-262 -731h523z',\n            'M1323 458q0 -111 -42 -196t-113 -140q-84 -66 -184.5 -94t-255.5 -28h-528v1489h441q163 0 244 -12t155 -50q82 -43 119 -110.5t37 -161.5q0 -106 -54 -180.5t-144 -119.5v-8q151 -31 238 -132.5t87 -256.5zM990 1129q0 54 -18 91t-58 60q-47 27 -114 33.5t-166 6.5h-236 v-430h256q93 0 148 9.5t102 39.5t66.5 77.5t19.5 112.5zM1117 450q0 90 -27 143t-98 90q-48 25 -116.5 32.5t-166.5 7.5h-311v-554h262q130 0 213 13.5t136 49.5q56 39 82 89t26 129z',\n            'M1162 1313h-764v-1313h-198v1489h962v-176z',\n            'M1414 0h-1388l562 1489h264zM1147 168l-432 1147l-431 -1147h863z',\n            'M1181 0h-981v1489h981v-176h-783v-408h783v-176h-783v-553h783v-176z',\n            'M1288 0h-1162v184l913 1129h-879v176h1106v-179l-922 -1134h944v-176z',\n            'M1339 0h-198v729h-743v-729h-198v1489h198v-584h743v584h198v-1489z',\n            'M1310 1318q91 -100 139.5 -245t48.5 -329t-49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5zM1292 744 q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5zM1120 713h-627v179h627v-179z',\n            'M725 0h-588v152h195v1185h-195v152h588v-152h-195v-1185h195v-152z',\n            'M1397 0h-257l-589 663l-148 -158v-505h-198v1489h198v-777l723 777h240l-665 -700z',\n            'M1378 0h-213l-468 1285l-468 -1285h-203l556 1489h240z',\n            'M1526 0h-198v1283l-414 -873h-118l-411 873v-1283h-185v1489h270l397 -829l384 829h275v-1489z',\n            'M1336 0h-245l-706 1332v-1332h-185v1489h307l644 -1216v1216h185v-1489z',\n            'M1215 1313h-1101v176h1101v-176zM1163 729h-997v176h997v-176zM1215 0h-1101v176h1101v-176z',\n            'M1310 1318q91 -100 139.5 -245t48.5 -329t-49.5 -329.5t-138.5 -242.5q-92 -101 -217.5 -152t-286.5 -51q-157 0 -285.5 52t-218.5 151t-138.5 243t-48.5 329q0 182 48 326.5t140 247.5q88 98 218.5 150t284.5 52q160 0 287.5 -52.5t216.5 -149.5zM1292 744 q0 290 -130 447.5t-355 157.5q-227 0 -356.5 -157.5t-129.5 -447.5q0 -293 132 -448.5t354 -155.5t353.5 155.5t131.5 448.5z',\n            'M1339 0h-198v1313h-743v-1313h-198v1489h1139v-1489z',\n            'M1174 1039q0 -99 -34.5 -183.5t-96.5 -146.5q-77 -77 -182 -115.5t-265 -38.5h-198v-555h-198v1489h404q134 0 227 -22.5t165 -70.5q85 -57 131.5 -142t46.5 -215zM968 1034q0 77 -27 134t-82 93q-48 31 -109.5 44.5t-155.5 13.5h-196v-595h167q120 0 195 21.5t122 68.5 q47 48 66.5 101t19.5 119z',\n            'M1280 0h-1162v184l620 600l-600 526v179h1096v-176h-832l586 -506v-26l-630 -605h922v-176z',\n            'M1262 1313h-532v-1313h-198v1313h-532v176h1262v-176z',\n            'M1254 1489l-524 -836v-653h-198v632l-526 857h219l407 -666l411 666h211z',\n            'M1572 755q0 -140 -44.5 -248.5t-123.5 -181.5q-85 -79 -207 -125.5t-260 -49.5v-166h-197v166q-134 3 -257 48t-210 127q-79 74 -123.5 182t-44.5 248q0 136 43 238t119 178q81 81 202.5 128t270.5 51v155h197v-155q148 -3 271 -52t202 -127q75 -73 118.5 -177t43.5 -239 zM1366 763q0 99 -32 182t-91 140q-58 56 -129 82t-177 28v-890q94 2 171 30.5t127 75.5q65 60 98 147t33 205zM740 305v890q-106 -1 -177 -28t-129 -82t-90.5 -140t-32.5 -182q0 -112 33.5 -203t97.5 -149q49 -45 126.5 -75t171.5 -31z',\n            'M1336 1489l-514 -736l513 -753h-229l-406 613l-416 -613h-216l519 744l-507 745h228l401 -605l410 605h217z',\n            'M1604 910q0 -157 -40.5 -264.5t-117.5 -174.5q-80 -69 -192.5 -104t-263.5 -45v-322h-197v322q-154 11 -267 47t-188 102q-78 69 -118.5 176t-40.5 263v579h198v-602q0 -109 29.5 -180t81.5 -115q53 -45 130 -68.5t175 -30.5v996h197v-996q97 8 175 30.5t131 68.5 q56 49 83 115.5t27 179.5v602h198v-579z',\n            'M1568 0h-576v387q60 38 119.5 82t103.5 101q45 59 71 138.5t26 185.5q0 206 -127 330.5t-347 124.5t-347 -124.5t-127 -330.5q0 -106 26 -185.5t71 -138.5q45 -57 104 -101t119 -82v-387h-576v174h410v124q-157 90 -258.5 246t-101.5 350q0 276 187.5 451t492.5 175 t492.5 -175t187.5 -451q0 -194 -101.5 -350t-258.5 -246v-124h410v-174z',\n            'M725 0h-588v152h195v1185h-195v152h588v-152h-195v-1185h195v-152zM738 1677h-199v195h199v-195zM325 1677h-199v195h199v-195z',\n            'M1254 1489l-524 -836v-653h-198v632l-526 857h219l407 -666l411 666h211zM939 1677h-199v195h199v-195zM526 1677h-199v195h199v-195z',\n            'M1091 0h-188v117q-81 -70 -169 -109t-191 -39q-200 0 -317.5 154t-117.5 427q0 142 40.5 253t109.5 189q68 76 158.5 116t187.5 40q88 0 156 -22t143 -61v52h188v-1117zM903 275v636q-76 34 -136 49.5t-131 15.5q-158 0 -246 -110t-88 -312q0 -199 68 -302.5t218 -103.5 q80 0 162 35.5t153 91.5zM743 1676l-49 -384h-145l-49 384h243z',\n            'M1006 64q-107 -48 -210 -69t-218 -21q-79 0 -161 16t-152 56q-69 39 -112.5 102.5t-43.5 157.5q0 96 56.5 168t177.5 110v7q-91 24 -145 90t-54 158q0 89 47.5 147.5t112.5 92.5q64 33 145 49t160 16q98 0 180 -16.5t172 -44.5v-207h-13q-66 51 -163.5 79t-197.5 28 q-45 0 -84 -5.5t-81 -25.5q-35 -15 -60.5 -48.5t-25.5 -77.5q0 -61 28 -95t76 -49q45 -14 97 -15.5t105 -1.5h111v-166h-158q-62 0 -112 -4.5t-92 -21.5q-41 -17 -65.5 -54t-24.5 -96q0 -53 26 -90t67 -58q37 -19 87.5 -29t106.5 -10q102 0 218 36t187 98h13v-206zM721 1676 l-49 -384h-145l-49 384h243z',\n            'M1119 -412h-188v1048q0 77 -9 144.5t-33 105.5q-25 42 -72 62.5t-122 20.5q-77 0 -161 -38t-161 -97v-834h-188v1117h188v-124q88 73 182 114t193 41q181 0 276 -109t95 -314v-1137zM802 1676l-49 -384h-145l-49 384h243z',\n            'M375 0h-188v1117h188v-1117zM403 1676l-49 -384h-145l-49 384h243z',\n            'M1116 407q0 -218 -122 -327.5t-348 -109.5q-223 0 -346 107.5t-123 329.5v710h188v-641q0 -93 10 -153t42 -106q31 -43 84.5 -64.5t145.5 -21.5q86 0 143.5 22t87.5 66q29 44 39.5 105.5t10.5 151.5v641h188v-710zM760 1676l-49 -384h-128l-49 384h226zM1043 1304h-191 v195h191v-195zM442 1304h-191v195h191v-195z',\n            'M1091 0h-188v117q-81 -70 -169 -109t-191 -39q-200 0 -317.5 154t-117.5 427q0 142 40.5 253t109.5 189q68 76 158.5 116t187.5 40q88 0 156 -22t143 -61v52h188v-1117zM903 275v636q-76 34 -136 49.5t-131 15.5q-158 0 -246 -110t-88 -312q0 -199 68 -302.5t218 -103.5 q80 0 162 35.5t153 91.5z',\n            'M1165 444q0 -202 -134.5 -334t-339.5 -132q-79 0 -167 22t-151 64v-476h-188v1490q0 224 126.5 351t349.5 127q90 0 164.5 -21.5t133.5 -67.5q57 -43 91 -112t34 -160q0 -127 -69.5 -221.5t-196.5 -131.5v-17q159 -26 253 -125.5t94 -255.5zM971 449q0 89 -34.5 144.5 t-92.5 86.5q-59 32 -132 43t-146 11h-36v160h36q66 0 131 14.5t104 44.5q46 34 68.5 83t22.5 134q0 112 -69 170t-178 58q-73 0 -125 -26.5t-85 -70.5q-32 -44 -47 -102.5t-15 -120.5v-862q66 -38 141 -53.5t147 -15.5q149 0 229.5 78.5t80.5 223.5z',\n            'M1151 1117l-457 -1061v-468h-188v468l-445 1061h204l343 -828l346 828h197z',\n            'M1139 551q0 -272 -138.5 -427t-376.5 -155q-241 0 -379.5 151.5t-138.5 413.5q0 141 43 239.5t107 162.5q69 72 159 113t182 58q-76 63 -166 130.5t-192 139.5v179h810v-158h-561v-10q68 -46 179 -124t204 -162q150 -136 209 -261.5t59 -289.5zM945 551q0 135 -55 249 t-165 200q-66 -8 -138.5 -32t-138.5 -77q-63 -50 -105.5 -137t-42.5 -214q0 -201 85 -305t241 -104q153 0 236 105.5t83 314.5z',\n            'M1006 64q-107 -48 -210 -69t-218 -21q-79 0 -161 16t-152 56q-69 39 -112.5 102.5t-43.5 157.5q0 96 56.5 168t177.5 110v7q-91 24 -145 90t-54 158q0 89 47.5 147.5t112.5 92.5q64 33 145 49t160 16q98 0 180 -16.5t172 -44.5v-207h-13q-66 51 -163.5 79t-197.5 28 q-45 0 -84 -5.5t-81 -25.5q-35 -15 -60.5 -48.5t-25.5 -77.5q0 -61 28 -95t76 -49q45 -14 97 -15.5t105 -1.5h111v-166h-158q-62 0 -112 -4.5t-92 -21.5q-41 -17 -65.5 -54t-24.5 -96q0 -53 26 -90t67 -58q37 -19 87.5 -29t106.5 -10q102 0 218 36t187 98h13v-206z',\n            'M922 75q32 -40 46 -85.5t14 -85.5q0 -84 -45 -168.5t-112 -147.5h-179v14q90 79 128 138.5t38 128.5q0 57 -30.5 95t-77.5 38h-145q-229 0 -340 116t-111 345q0 140 46 268t124 247q75 112 173.5 214.5t206.5 196.5v9h-460v158h744v-135q-117 -78 -231.5 -181 t-204.5 -223q-89 -117 -146 -257t-57 -283q0 -34 3 -70t15 -76q10 -38 34.5 -75.5t63.5 -61.5q36 -22 96.5 -24.5t116.5 -2.5h86q71 0 122 -26t82 -66z',\n            'M1119 -412h-188v1048q0 77 -9 144.5t-33 105.5q-25 42 -72 62.5t-122 20.5q-77 0 -161 -38t-161 -97v-834h-188v1117h188v-124q88 73 182 114t193 41q181 0 276 -109t95 -314v-1137z',\n            'M1141 768q0 -190 -23 -316.5t-59 -210.5q-58 -135 -163 -203.5t-257 -68.5t-257 68.5t-163 203.5q-37 84 -59.5 210.5t-22.5 316.5q0 174 22.5 305.5t60.5 214.5q57 130 162.5 199t256.5 69t256.5 -69t162.5 -199q37 -84 60 -215t23 -305zM952 858q-4 143 -28.5 250 t-56.5 161q-41 70 -95 98.5t-133 28.5t-133 -28.5t-95 -98.5q-34 -55 -57.5 -161.5t-27.5 -249.5h626zM952 697h-626q0 -142 23 -258.5t59 -178.5q40 -69 96 -100t135 -31t135 31t96 100q36 62 59 178.5t23 258.5z',\n            'M375 0h-188v1117h188v-1117z',\n            'M1192 0h-248l-451 489l-112 -109v-380h-188v1117h188v-550l384 417q72 79 135.5 107t126.5 28q28 0 58 -1t37 -1v-166h-11q-16 2 -39.5 3t-36.5 1q-47 0 -85.5 -23.5t-67.5 -56.5l-251 -271z',\n            'M1151 0h-205l-328 829l-361 -829h-196l465 1056l-215 500h211z',\n            'M1125 0h-186v118q-74 -78 -141.5 -108.5t-145.5 -30.5q-75 0 -135 27t-144 107v-525h-188v1529h188v-838q32 -39 111 -80t170 -41q93 0 161 33.5t122 93.5v832h188v-1117z',\n            'M1151 1117l-452 -1117h-189l-449 1117h204l346 -889l343 889h197z',\n            'M1041 -96q0 -85 -45.5 -169t-111.5 -147h-180v14q92 79 129.5 139t37.5 128q0 55 -29 94t-75 39h-140q-140 0 -232.5 27t-155.5 84q-66 60 -100.5 135.5t-34.5 163.5q0 78 25 144t73 119q44 49 112.5 83.5t144.5 53.5v11q-125 28 -200 110.5t-75 186.5q0 83 43.5 150.5 t133.5 125.5v6h-228v154h824v-158h-256q-68 0 -122.5 -14.5t-102.5 -48.5q-45 -32 -72 -83t-27 -118q0 -79 32.5 -128t83.5 -75q45 -23 104 -34t139 -11h170v-165h-295q-66 0 -118.5 -20t-99.5 -59q-43 -37 -68.5 -90t-25.5 -112q0 -102 37.5 -159t101.5 -82 q63 -25 139.5 -28.5t166.5 -3.5h28q68 0 119.5 -23.5t84.5 -60.5q31 -35 48 -82.5t17 -96.5z',\n            'M1137 558q0 -273 -140 -431t-375 -158q-237 0 -376.5 158t-139.5 431t139.5 431.5t376.5 158.5q235 0 375 -158.5t140 -431.5zM943 558q0 217 -85 322.5t-236 105.5q-153 0 -237.5 -105.5t-84.5 -322.5q0 -210 85 -318.5t237 -108.5q150 0 235.5 107.5t85.5 319.5z',\n            'M1120 0h-188v955h-559v-955h-188v1117h935v-1117z',\n            'M1172 577q0 -258 -138.5 -428.5t-360.5 -170.5q-65 0 -146.5 18t-153.5 61v-469h-188v1058q0 123 35.5 215.5t101.5 158.5q62 62 155.5 95t195.5 33q243 0 371 -147t128 -424zM978 565q0 218 -80 320t-226 102q-158 0 -228.5 -96t-70.5 -278v-403q73 -34 132.5 -48.5 t134.5 -14.5q162 0 250 111t88 307z',\n            'M1018 -96q0 -87 -47 -172t-109 -144h-177v14q86 75 124.5 135.5t38.5 131.5q0 54 -30 93.5t-75 39.5h-92q-117 0 -216 30t-174 97q-73 66 -114.5 170t-41.5 250q0 270 155.5 432t414.5 162q84 0 164 -18.5t147 -45.5v-211h-12q-94 62 -172.5 87t-146.5 25 q-166 0 -260.5 -119t-94.5 -312q0 -112 28.5 -183t78.5 -116q50 -44 114.5 -63.5t139.5 -19.5h100q115 0 186 -76.5t71 -186.5z',\n            'M1137 558q0 -281 -140.5 -435t-373.5 -154q-241 0 -379 158t-138 431q0 275 141 432.5t378 157.5q55 0 108 -11t82 -20h480v-165h-288q62 -73 96 -170t34 -224zM943 558q0 215 -82 322t-236 107q-161 0 -243 -112t-82 -317q0 -209 83.5 -318t239.5 -109q152 0 236 107.5 t84 319.5z',\n            'M1006 952h-404v-952h-188v952h-404v165h996v-165z',\n            'M1116 407q0 -218 -122 -327.5t-348 -109.5q-223 0 -346 107.5t-123 329.5v710h188v-641q0 -93 10 -153t42 -106q31 -43 84.5 -64.5t145.5 -21.5q86 0 143.5 22t87.5 66q29 44 39.5 105.5t10.5 151.5v641h188v-710z',\n            'M1514 576q0 -259 -171.5 -417t-440.5 -173v-398h-187v398q-130 6 -240.5 46.5t-191.5 109.5q-85 74 -132 172t-47 232q0 159 59 296t192 275h229v-17q-136 -99 -210 -232t-74 -300q0 -189 112.5 -304t301.5 -121v1000q33 2 70.5 2.5t76.5 0.5q304 0 478.5 -149.5 t174.5 -420.5zM1319 586q0 184 -112 293.5t-305 109.5v-846q206 10 311.5 126t105.5 317z',\n            'M1160 -412h-213l-346 619l-350 -619h-203l444 770l-433 759h213l335 -600l339 600h203l-433 -751z',\n            'M1507 446q0 -114 -48 -198t-127 -137q-82 -55 -182 -82.5t-215 -32.5v-408h-187v408q-115 6 -214.5 32t-182.5 83q-80 54 -127.5 137.5t-47.5 197.5v671h188v-612q0 -113 37.5 -180.5t89.5 -102.5q56 -38 123 -53t134 -19v967h187v-967q67 5 134 19t123 53 q59 40 93 101.5t34 181.5v612h188v-671z',\n            'M1553 503q0 -96 -23.5 -192.5t-74.5 -171.5q-55 -80 -133.5 -124.5t-193.5 -44.5q-96 0 -177 49.5t-118 116.5h-6q-39 -68 -113 -117t-176 -49q-113 0 -194.5 46.5t-132.5 122.5t-74.5 171.5t-23.5 192.5q0 170 57 308.5t201 305.5h228v-17q-135 -108 -214.5 -262 t-79.5 -337q0 -66 8 -122.5t38 -119.5q26 -55 72.5 -91.5t117.5 -36.5q51 0 86.5 12.5t55.5 29.5q22 18 36.5 40t20.5 37v584h186v-584q9 -17 23 -39t35 -39q24 -19 52.5 -30t86.5 -11q70 0 117 35.5t74 92.5q25 55 36 116t11 126q0 182 -78.5 336t-215.5 263v17h228 q144 -167 201 -305.5t57 -308.5z',\n            'M557 1304h-189v195h189v-195zM194 1304h-189v195h189v-195zM375 0h-188v1117h188v-1117z',\n            'M1116 407q0 -218 -122 -327.5t-348 -109.5q-223 0 -346 107.5t-123 329.5v710h188v-641q0 -93 10 -153t42 -106q31 -43 84.5 -64.5t145.5 -21.5q86 0 143.5 22t87.5 66q29 44 39.5 105.5t10.5 151.5v641h188v-710zM953 1304h-199v195h199v-195zM540 1304h-199v195h199 v-195z',\n            'M1137 558q0 -273 -140 -431t-375 -158q-237 0 -376.5 158t-139.5 431t139.5 431.5t376.5 158.5q235 0 375 -158.5t140 -431.5zM943 558q0 217 -85 322.5t-236 105.5q-153 0 -237.5 -105.5t-84.5 -322.5q0 -210 85 -318.5t237 -108.5q150 0 235.5 107.5t85.5 319.5z M743 1676l-49 -384h-145l-49 384h243z',\n            'M1116 407q0 -218 -122 -327.5t-348 -109.5q-223 0 -346 107.5t-123 329.5v710h188v-641q0 -93 10 -153t42 -106q31 -43 84.5 -64.5t145.5 -21.5q86 0 143.5 22t87.5 66q29 44 39.5 105.5t10.5 151.5v641h188v-710zM768 1676l-49 -384h-145l-49 384h243z',\n            'M1553 503q0 -96 -23.5 -192.5t-74.5 -171.5q-55 -80 -133.5 -124.5t-193.5 -44.5q-96 0 -177 49.5t-118 116.5h-6q-39 -68 -113 -117t-176 -49q-113 0 -194.5 46.5t-132.5 122.5t-74.5 171.5t-23.5 192.5q0 170 57 308.5t201 305.5h228v-17q-135 -108 -214.5 -262 t-79.5 -337q0 -66 8 -122.5t38 -119.5q26 -55 72.5 -91.5t117.5 -36.5q51 0 86.5 12.5t55.5 29.5q22 18 36.5 40t20.5 37v584h186v-584q9 -17 23 -39t35 -39q24 -19 52.5 -30t86.5 -11q70 0 117 35.5t74 92.5q25 55 36 116t11 126q0 182 -78.5 336t-215.5 263v17h228 q144 -167 201 -305.5t57 -308.5zM955 1676l-49 -384h-145l-49 384h243z',\n            'M1145 837q0 -164 -39 -344t-121 -303q-85 -124 -186.5 -173t-214.5 -49q-192 0 -313.5 126.5t-121.5 329.5q0 228 134.5 372.5t336.5 144.5q90 0 169.5 -26t158.5 -91q2 26 3 55.5t1 55.5q0 217 -79 318t-231 101q-78 0 -169.5 -31.5t-169.5 -86.5h-11v194 q81 44 181.5 66.5t196.5 22.5q137 0 239.5 -54.5t164.5 -178.5q42 -86 56.5 -189t14.5 -260zM942 678q-60 47 -136 74t-148 27q-141 0 -225 -91t-84 -261q0 -145 67.5 -221.5t179.5 -76.5q128 0 209.5 97t115.5 287q6 33 11.5 73t9.5 92z',\n            'M1438 0h-1388l562 1489h264zM1171 168l-432 1147l-431 -1147h863z',\n            'M1532 1315h-200v-1508h-198v1508h-592v-1508h-198v1508h-200v174h1388v-174z',\n            'M1369 -189h-1182v191l673 668l-663 631v188h1133v-176h-891l648 -601v-72l-666 -653h948v-176z',\n            'M1456 572h-1236v160h1236v-160z',\n            'M843 1489l-780 -1489h-165l780 1489h165z',\n            'M492 511h-239v283h239v-283z',\n            'M1737 1788l-880 -1939h-102l-384 993h-237v139h393l313 -821l730 1628h167z',\n            'M1887 663q0 -239 -122.5 -372.5t-329.5 -133.5q-133 0 -244 76.5t-180 222.5q-79 -151 -184.5 -225t-248.5 -74q-191 0 -304 135.5t-113 349.5q0 238 125 372t327 134q134 0 245 -77t179 -222q79 150 185.5 224.5t247.5 74.5q191 0 304 -135.5t113 -349.5zM967 729 q-63 117 -155 175.5t-188 58.5q-138 0 -216 -83.5t-78 -237.5q0 -133 63.5 -216t182.5 -83q110 0 172 48.5t119 142.5q34 57 52.5 92.5t47.5 102.5zM1718 663q0 134 -64 216.5t-182 82.5q-88 0 -152.5 -35.5t-138.5 -155.5q-30 -48 -55.5 -99.5t-44.5 -95.5 q60 -115 153.5 -174.5t189.5 -59.5q138 0 216 83t78 238z',\n            'M1168 1367h-10q-32 8 -89.5 18.5t-89.5 10.5q-129 0 -181 -61q-53 -61 -53 -210v-1123q0 -206 -104 -315q-105 -110 -293 -110q-52 0 -106.5 5.5t-103.5 15.5v178h10q33 -8 87 -18.5t88 -10.5q129 0 182 61q52 61 52 210v1123q0 204 104 315q104 110 293 110 q58 0 109 -5.5t105 -15.5v-178z',\n            'M1431 1104q-20 -194 -111 -293t-249 -99q-77 0 -147 37.5t-126 82.5q-65 52 -117 79.5t-96 27.5q-75 0 -117 -48t-70 -172h-155q23 182 112.5 280t248.5 98q72 0 143 -37t130 -83q61 -48 114.5 -77.5t98.5 -29.5q76 0 120.5 54.5t63.5 179.5h157zM1432 588 q-25 -184 -112 -281.5t-250 -97.5q-72 0 -144 37.5t-129 82.5q-39 31 -103 69t-110 38q-78 0 -121 -55t-63 -179h-157q19 192 110.5 292t249.5 100q77 0 146 -37t127 -83q35 -28 97 -67.5t116 -39.5q75 0 117 49.5t69 171.5h157z',\n            'M1431 362h-608l-104 -335h-153l104 335h-425v156h474l84 268h-558v156h606l105 335h153l-105 -335h427v-156h-476l-83 -268h559v-156z',\n            'M1408 303l-1154 483v124l1154 483v-183l-889 -362l889 -362v-183zM1408 0h-1154v160h1154v-160z',\n            'M1422 786l-1154 -483v183l889 362l-889 362v183l1154 -483v-124zM1422 0h-1154v160h1154v-160z'\n        ];\n        this.OUTLINE_X = [\n            [], [291, 301, 505, 515], [168, 211, 729, 772, 554], [195, 389, 917, 1364, 1481, 1481, 1288, 760, 312, 195],\n            [155, 604, 722, 1129.8, 1160, 1107, 722, 604, 278.5, 191.1, 162, 155], [149, 172.3, 242, 630, 1687, 1844.3, 1960, 2031.3, 2055, 2031.8, 1962, 1575, 517, 359.8, 244, 172.8],\n            [115, 149.4, 252.5, 407.6, 598, 1555, 1287, 961.3, 881, 757.5, 601, 423.5, 293, 213.5, 187], [164, 207, 343, 386], [181, 205.5, 279, 554, 783, 783, 554, 279, 205.5],\n            [147, 376, 651, 724.5, 749, 724.5, 651, 376, 147], [167, 232, 588, 717, 1073, 1137, 1137, 1073, 717, 588, 232, 167], [210, 755, 921, 1466, 1466, 921, 755, 210],\n            [147, 293, 575, 321], [153, 777, 777, 153], [253, 492, 492, 253], [-30, 143, 860, 684],\n            [137, 167.9, 260.5, 420.1, 652, 881.4, 1041.5, 1135.6, 1167, 1136.1, 1043.5, 883.9, 652, 422, 262, 168.3], [278, 1084, 1084, 780, 625, 278],\n            [161, 1169, 1169, 1106, 1073.5, 976, 821.3, 617, 387.5, 198, 161], [167, 364, 608, 830.5, 1007, 1111, 1148, 1117, 1080, 971, 821, 629, 399.5, 210, 167],\n            [77, 790, 982, 1203, 1203, 982, 798, 77], [187, 378, 613, 843.5, 1015, 1119, 1157, 1147, 251, 187],\n            [137, 183.5, 316, 475, 675, 875.1, 1041.5, 1153.6, 1191, 1046, 965, 866, 542, 315, 179.5], [154, 285, 499, 1173, 1173, 154],\n            [122, 157.9, 265.5, 433.6, 651, 859.6, 1029.5, 1142.4, 1180, 1140, 1106.8, 1007, 851.5, 651, 456.8, 300, 196.5, 162],\n            [113, 258, 340, 438, 760, 988, 1122.5, 1167, 1121, 990, 829, 629, 429.5, 263, 150.5], [346, 585, 585, 346], [230, 376, 658, 585, 346], [254, 1408, 1408, 254],\n            [245, 1431, 1431, 245], [268, 1422, 1422, 268], [160, 406, 610, 970, 1005, 973.9, 880.5, 733.4, 541, 337.5, 160],\n            [176, 240, 419, 692, 1037, 1210, 1391, 1714, 1829.5, 1870, 1813.5, 1651, 1391, 1041, 701, 426, 243], [26, 1374, 832, 568],\n            [200, 728, 983.5, 1168, 1281, 1323, 1196, 1159, 1040, 885, 641, 200], [115, 169, 319, 549.5, 844, 1001.5, 1134, 1250.5, 1350, 1350, 1084.5, 845, 546.5, 317, 167],\n            [200, 576, 906.5, 1134, 1369.5, 1458, 1373, 1136, 918.5, 572, 200], [200, 1181, 1181, 200], [200, 398, 1045, 1151, 1151, 200],\n            [115, 171, 330, 577, 896, 1175.5, 1442, 1442, 1441, 1155.5, 896, 570.9, 323.5, 167.1], [200, 1339, 1339, 200], [137, 725, 725, 137],\n            [44, 178, 306, 486.6, 626.5, 716.1, 746, 746, 233, 44], [205, 1397, 1366, 205], [200, 1142, 1142, 398, 200], [200, 1526, 1526, 200], [200, 1336, 1336, 200],\n            [115, 163.5, 302, 520.5, 806, 1092.5, 1310, 1448.5, 1498, 1449.5, 1310, 1093.5, 806, 521.5, 303, 163], [200, 398, 1043, 1139.5, 1174, 1127.5, 996, 831, 604, 200],\n            [115, 163.5, 302, 520.5, 1010.5, 1133.1, 1290, 1409.5, 1528, 1528, 1498, 1449.5, 1310, 1093.5, 806, 521.5, 303, 163], [200, 1432, 1130.5, 1004, 842, 617, 200],\n            [134, 395.5, 685, 941.5, 1128, 1241.5, 1282, 1222, 990, 702, 480.3, 301, 182.5, 143, 134], [0, 532, 730, 1262, 1262, 0],\n            [178, 213.5, 330, 505, 749, 989, 1169, 1285.5, 1321, 1321, 178], [26, 568, 832, 1374, 238], [92, 486, 1546, 1933, 295], [68, 1335, 1336, 80], [6, 532, 730, 1254, 225],\n            [126, 1288, 1288, 1266, 160, 126], [239, 759, 759, 239], [70, 787, 960, 246], [171, 691, 691, 171], [186, 383, 1490, 901, 775], [-4, 1306, 1306, -4], [340, 613, 762, 583],\n            [104, 130.3, 209, 325.5, 465, 1053, 1053, 1020, 924, 772.5, 567, 362, 203], [185, 679, 866, 1022, 1128.5, 1168, 1139.4, 1053.5, 918.1, 373, 185],\n            [105, 145, 258, 431, 653, 832.5, 1011, 1011, 841.5, 653, 430.1, 255.5, 142.6], [108, 137.4, 225.5, 363.6, 543, 1091, 1091, 903, 258, 148.5],\n            [106, 145, 262, 448.5, 696, 904, 1098, 1120, 1120, 1089.4, 997.5, 849.1, 649, 428.6, 255.5, 143.4], [68, 195, 383, 716, 786, 786, 693.5, 580, 415, 294, 68],\n            [108, 225, 391.5, 565, 798.3, 962, 1058.8, 1091, 1091, 602, 417, 259, 148.5], [185, 1119, 1119, 1095.3, 1024, 373, 185], [175, 187, 375, 387, 387, 175],\n            [-62, 47.5, 153, 304, 421, 496, 521, 533, 533, 321, 100, -62], [193, 1199, 1161, 381, 193], [187, 375, 375, 187], [185, 1815, 1815, 1793.1, 1727.5, 1615.9, 1456, 735, 185],\n            [185, 1119, 1119, 1095.3, 1024, 907.5, 748, 185], [106, 140.9, 245.5, 409.4, 622, 833.3, 997, 1102, 1137, 1102, 997, 833.3, 622, 409.4, 245.5, 140.9],\n            [185, 373, 1019, 1129, 1168, 1139.9, 1055.5, 920.6, 741, 185], [108, 137.6, 226.5, 365.1, 903, 1091, 1091, 602, 414, 259, 149.5], [185, 373, 882, 882, 816, 745, 185],\n            [110, 283.5, 511, 706.9, 856.5, 951.4, 983, 939, 768.5, 566, 372.5, 230, 143.5, 115, 110], [62, 211.3, 278, 387.5, 538, 649.5, 765, 765, 377, 189, 62],\n            [177, 201.5, 275, 392.5, 549, 1111, 1111, 177], [61, 510, 699, 1151, 265], [86, 380, 1299, 1590, 766], [60, 1152, 1152, 64], [61, 298, 499, 1151, 265],\n            [93, 995, 995, 978, 107, 93], [173, 588.9, 672.5, 800.9, 963, 1113, 1113, 963, 800.9, 672.5, 588.9, 173], [378, 552, 552, 378],\n            [187, 337, 499.1, 627.5, 711.1, 1127, 1127, 711.1, 627.5, 499.1, 337, 187], [187, 354, 1125, 1290, 1401, 1466.5, 1489, 1322, 551, 386, 274, 209.5], [], [291, 515, 505, 301],\n            [159, 191.6, 289.5, 647, 765, 1120, 1120, 765, 647, 292.5, 192.4], [137, 1163, 1163, 1137, 997, 816, 630.6, 484.5, 389.6, 182, 137],\n            [138, 247, 1058, 1168, 1168, 1055, 249, 138], [108, 187, 557, 745, 1115, 1191, 320], [378, 552, 552, 378],\n            [172, 229, 404.5, 575, 796, 965, 1063, 1096, 1128, 1071, 896, 725, 497.5, 334, 235, 203], [346, 958, 958, 346],\n            [159, 222.4, 412.5, 692.1, 1024, 1355.9, 1635.5, 1825.6, 1889, 1825.6, 1635.5, 1355.9, 1024, 692.1, 412.5, 222.4],\n            [151, 238.5, 454, 944, 944, 920.3, 849, 723.5, 537, 368, 231], [166, 716, 1146, 1146, 716, 166], [210, 1285, 1456, 1456, 210], [153, 777, 777, 153],\n            [159, 222.4, 412.5, 692.1, 1024, 1355.9, 1635.5, 1825.6, 1889, 1825.6, 1635.5, 1355.9, 1024, 692.1, 412.5, 222.4], [-4, 1, 1306, 1306],\n            [154, 183, 270, 399.3, 555, 710.8, 840, 927, 956, 927.1, 840.5, 711.4, 555, 399.3, 270, 183], [215, 1461, 1461, 921, 755, 215],\n            [207, 967, 967, 911, 887.6, 817.5, 544, 369.5, 211, 207], [207, 363.5, 540, 703, 834, 923, 956, 929, 904.9, 832.5, 561, 384.5, 224, 207], [541, 690, 963, 720],\n            [190, 378, 1124, 1124, 190], [137, 168.5, 595, 1106, 1106, 640, 425.3, 267, 169.5], [253, 492, 492, 253], [353, 456, 551, 788.5, 857.1, 880, 877, 872, 719, 353],\n            [291, 299, 914, 914, 693, 558, 291], [121, 150.6, 239.5, 378.6, 559, 734.3, 874, 965.5, 996, 965.5, 874, 734.3, 559, 378.6, 239.5, 150.6], [174, 604, 1154, 1154, 604, 174],\n            [171, 465, 1694, 1857, 1857, 1694, 1410, 545, 408, 171], [171, 465, 1955, 1955, 1890, 1805.5, 1410, 545, 408, 171], [140, 555, 1750, 1913, 1913, 1750, 1500, 448, 294, 155, 140],\n            [113, 144.1, 237.5, 384.6, 577, 782, 958, 958, 712, 508, 147.5], [26, 1374, 862, 683, 440], [26, 1374, 955, 712, 533], [26, 1374, 1033, 805, 578, 350],\n            [26, 1374, 1119, 990, 541, 367, 288], [26, 1374, 1005, 806, 393], [26, 1374, 1049, 1023.6, 947.5, 834.6, 699, 564, 451, 374.5, 349], [14, 1901, 1901, 608],\n            [115, 169, 548, 652.5, 750, 990.5, 1350, 1350, 1084.5, 845, 546.5, 317, 167], [200, 1181, 1181, 643, 400, 200], [200, 1181, 1181, 993, 750, 200],\n            [200, 1181, 1181, 803, 576, 200], [200, 1181, 1181, 1038, 426, 200], [137, 725, 725, 389, 146, 137], [137, 725, 725, 482, 137], [93, 137, 725, 776, 548, 321],\n            [126, 137, 725, 738, 738, 126], [14, 210, 586, 916.5, 1144, 1379.5, 1468, 1383, 1146, 929, 582, 210, 14], [200, 1336, 1336, 1208, 1079, 630, 456, 200],\n            [115, 163.5, 302, 520.5, 806, 1092.5, 1310, 1448.5, 1498, 1449.5, 1310, 753, 510, 163], [115, 163.5, 302, 520.5, 806, 1092.5, 1310, 1448.5, 1498, 1449.5, 1083, 840, 303, 163],\n            [115, 163.5, 302, 520.5, 806, 1092.5, 1310, 1448.5, 1498, 1449.5, 1136, 908, 681, 453, 163],\n            [115, 163.5, 302, 520.5, 806, 1092.5, 1310, 1448.5, 1498, 1449.5, 1207, 1078, 629, 455, 163],\n            [112, 160.5, 299, 517.5, 803, 1089.5, 1307, 1445.5, 1495, 1446.5, 1108, 909, 496, 160], [291, 402, 1274, 1385, 1385, 1274, 402, 291],\n            [115, 120, 252, 1092.5, 1310, 1448.5, 1498, 1474, 1342, 806, 521.5, 303, 163], [178, 213.5, 330, 505, 749, 989, 1169, 1285.5, 1321, 1321, 753, 510, 178],\n            [178, 213.5, 330, 505, 749, 989, 1169, 1285.5, 1321, 1321, 1073, 830, 178], [178, 213.5, 330, 505, 749, 989, 1169, 1285.5, 1321, 1321, 856, 629, 178],\n            [178, 213.5, 330, 505, 749, 989, 1169, 1285.5, 1321, 1321, 1056, 444, 178], [6, 532, 730, 1254, 935, 692], [200, 398, 1044, 1139, 1174, 1127, 997, 398, 200],\n            [185, 675, 873.1, 1029.5, 1131.1, 1165, 1066, 1037.4, 951.5, 819.9, 654, 470.5, 321, 221, 185], [104, 130.3, 209, 325.5, 465, 1053, 1053, 1020, 559, 316, 203],\n            [104, 130.3, 209, 325.5, 465, 1053, 1053, 934, 691, 203], [104, 130.3, 209, 325.5, 465, 1053, 1053, 961, 733, 506, 278, 203],\n            [104, 130.3, 209, 325.5, 465, 1053, 1053, 1038, 909, 460, 286, 207], [104, 130.3, 209, 325.5, 465, 1053, 1053, 926, 314, 203],\n            [104, 130.3, 209, 325.5, 465, 1053, 1053, 956, 930.6, 854.5, 741.6, 606, 471, 358, 281.5, 256],\n            [104, 130.4, 209.5, 326.1, 465, 1433, 1648.5, 1833, 1855, 1855, 1823.6, 1729.5, 1581.1, 1387, 564, 360, 202],\n            [105, 145, 353, 456, 551, 788.5, 857.1, 1011, 1011, 841.5, 653, 430.1, 255.5, 142.6], [106, 145, 262, 448.5, 696, 904, 1098, 1120, 1120, 1089.4, 997.5, 580, 337, 143.4],\n            [106, 145, 262, 448.5, 696, 904, 1098, 1120, 1120, 1089.4, 960, 717, 255.5, 143.4], [106, 145, 262, 448.5, 696, 904, 1098, 1120, 1120, 1089.4, 986, 758, 531, 303, 143.4],\n            [106, 145, 262, 448.5, 696, 904, 1098, 1120, 1120, 1089.4, 951, 339, 143.4], [-21, 187, 375, 401, 222], [160, 187, 375, 582, 339], [-11, 187, 375, 572, 394, 167],\n            [5, 187, 375, 557, 557, 5], [106, 140.6, 244.5, 405.6, 612, 828.3, 995, 1101.5, 1137, 1004, 938, 263], [185, 1119, 1119, 1075, 946, 497, 323, 244, 185],\n            [106, 140.9, 245.5, 409.4, 622, 833.3, 997, 1102, 1137, 1102, 997, 553, 310, 140.9], [106, 140.9, 245.5, 409.4, 622, 833.3, 997, 1102, 1137, 1102, 933, 690, 245.5, 140.9],\n            [106, 140.9, 245.5, 409.4, 622, 833.3, 997, 1102, 1137, 1102, 963, 735, 508, 280, 140.9], [106, 140.9, 245.5, 409.4, 622, 833.3, 997, 1102, 1137, 1038, 909, 460, 286, 207],\n            [106, 140.9, 245.5, 409.4, 622, 833.3, 997, 1102, 1137, 1102, 928, 729, 316, 140.9], [210, 719, 957, 1466, 1466, 957, 719, 210],\n            [93, 203, 833.3, 997, 1102, 1137, 1132, 1021, 409.4, 245.5, 140.9, 106], [177, 201.5, 275, 392.5, 549, 1111, 1111, 585, 342, 177],\n            [177, 201.5, 275, 392.5, 549, 1111, 1111, 945, 702, 177], [177, 201.5, 275, 392.5, 549, 1111, 1111, 757, 530, 177], [177, 201.5, 275, 392.5, 549, 1111, 1111, 955, 343, 177],\n            [61, 298, 499, 1151, 928, 685], [185, 373, 1019, 1129, 1168, 1139.9, 1055.5, 920.6, 373, 185], [230, 376, 658, 585, 346], [530, 579, 724, 773],\n            [256, 588, 716, 1048, 1048, 765, 539, 256], [7, 26, 1374, 832], [346, 585, 585, 346], [0, 49, 443, 1424, 1424, 443], [0, 49, 443, 1582, 1582, 443], [0, 49, 380, 968, 968, 380],\n            [0, 49, 354.5, 493, 711.5, 997, 1283.5, 1501, 1639.5, 1689, 1640.5, 1501, 1284.5, 997], [0, 49, 815, 1013, 1537, 289],\n            [0, 49, 291, 1751, 1751, 1701, 1654.1, 1513.5, 1296.6, 1021], [-53, 187, 375, 615, 615, 379, 183, -53], [26, 1374, 832, 568],\n            [200, 728, 983.5, 1168, 1281, 1323, 1196, 1159, 1040, 885, 641, 200], [200, 398, 1162, 1162, 200], [26, 1414, 852, 588], [200, 1181, 1181, 200],\n            [126, 1288, 1288, 1266, 160, 126], [200, 1339, 1339, 200], [115, 163.5, 302, 520.5, 806, 1092.5, 1310, 1448.5, 1498, 1449.5, 1310, 1093.5, 806, 521.5, 303, 163],\n            [137, 725, 725, 137], [205, 1397, 1366, 205], [26, 1378, 822, 582], [200, 1526, 1526, 200], [200, 1336, 1336, 200], [114, 1215, 1215, 114],\n            [115, 163.5, 302, 520.5, 806, 1092.5, 1310, 1448.5, 1498, 1449.5, 1310, 1093.5, 806, 521.5, 303, 163], [200, 1339, 1339, 200],\n            [200, 398, 1043, 1139.5, 1174, 1127.5, 996, 831, 604, 200], [118, 1280, 1280, 1234, 138, 118], [0, 532, 730, 1262, 1262, 0], [6, 532, 730, 1254, 225],\n            [105, 149.5, 273, 740, 937, 1404, 1527.5, 1572, 1528.5, 1410, 937, 740, 267, 148], [68, 1335, 1336, 80], [179, 219.5, 338, 793, 990, 1446, 1563.5, 1604, 1604, 179],\n            [108, 1568, 1568, 1518, 1471.1, 1330.5, 1113.6, 838, 562.4, 345.5, 204.9, 158, 108], [126, 137, 725, 738, 738, 126], [6, 532, 730, 1254, 939, 740, 327],\n            [108, 137.4, 225.5, 363.6, 543, 1091, 1091, 743, 500, 148.5], [109, 152.5, 265, 417, 578, 796, 1006, 1006, 961, 721, 478, 191.5, 144],\n            [185, 931, 1119, 1119, 1095.3, 802, 559, 185], [160, 187, 375, 403], [177, 207.8, 300, 448, 646, 846, 994, 1085.5, 1116, 1116, 1043, 760, 534, 251, 177],\n            [108, 137.4, 225.5, 363.6, 543, 1091, 1091, 604, 416.5, 258, 148.5], [185, 373, 1030.5, 1131.4, 1165, 1084, 1050, 959, 825.5, 661, 462.1, 311.5, 216.6, 185],\n            [61, 506, 694, 1151, 265], [106, 140.6, 244.5, 408.6, 624, 837.1, 1000.5, 1104.4, 1139, 1049, 239],\n            [109, 152.5, 265, 417, 578, 796, 1006, 1006, 961, 789, 609, 449, 304, 191.5, 144], [108, 135.8, 219, 646, 825, 937, 982, 942, 198],\n            [185, 931, 1119, 1119, 1095.3, 1024, 907.5, 748, 185], [137, 159.5, 219, 382, 639, 896, 1059, 1118, 1141, 1118, 1058, 895.5, 639, 382.5, 220, 159.5], [187, 375, 375, 187],\n            [193, 1192, 1122, 1085, 1027, 193], [61, 1151, 522, 311], [185, 373, 1125, 1125, 185], [61, 510, 699, 1151, 265], [104, 138.5, 239, 704, 884, 995.5, 1041, 957, 133],\n            [106, 140.9, 245.5, 409.4, 622, 833.3, 997, 1102, 1137, 1102, 997, 833.3, 622, 409.4, 245.5, 140.9], [185, 1120, 1120, 185],\n            [185, 373, 1033.5, 1137.4, 1172, 1140, 1044, 887.3, 673, 477.5, 322, 220.5, 185], [105, 146.5, 261, 685, 862, 971, 1018, 986, 839, 675, 441.9, 260.5, 143.9],\n            [106, 140.5, 244, 407.8, 623, 832.9, 996.5, 1101.9, 1295, 1295, 625, 412, 247, 141.3], [10, 414, 602, 1006, 1006, 10],\n            [177, 207.8, 300, 448, 646, 846, 994, 1085.5, 1116, 1116, 177], [104, 151, 283, 715, 902, 1342.5, 1471.1, 1514, 1470.4, 1339.5, 1132.6, 861, 784.5, 714, 355, 163],\n            [48, 1160, 1149, 59], [176, 223.5, 748, 935, 1459, 1507, 1507, 176], [113, 136.5, 211, 343.5, 538, 1128, 1321.5, 1455, 1529.5, 1553, 1496, 1295, 371, 170],\n            [5, 187, 375, 557, 557, 5], [177, 207.8, 300, 448, 646, 846, 994, 1085.5, 1116, 1116, 953, 341, 177],\n            [106, 140.9, 245.5, 409.4, 622, 833.3, 997, 1102, 1137, 1102, 743, 500, 140.9], [177, 207.8, 300, 448, 646, 846, 994, 1085.5, 1116, 1116, 768, 525, 177],\n            [113, 136.5, 211, 343.5, 538, 1128, 1321.5, 1455, 1529.5, 1553, 1496, 955, 712, 170],\n            [149, 179.4, 270.5, 409.6, 584, 798.5, 985, 1106, 1145, 1130.5, 1074, 909.5, 670, 473.5, 292], [50, 1438, 876, 612], [144, 344, 1332, 1532, 1532, 144],\n            [187, 1369, 1369, 1330, 197, 187], [220, 1456, 1456, 220], [-102, 63, 843, 678], [253, 492, 492, 253], [134, 755, 857, 1737, 1570, 134],\n            [161, 189.3, 274, 406.5, 578, 1435, 1620.9, 1764.5, 1856.4, 1887, 1858.8, 1774, 1641.5, 1470, 613, 430.3, 286, 192.3],\n            [138, 241.5, 348, 515.3, 641, 719, 1168, 1168, 1063, 954, 786.3, 661, 583, 138], [243, 400, 1070, 1214, 1320, 1432, 1431, 1274, 604, 462.4, 355.5, 243],\n            [245, 566, 719, 1431, 1431, 1109, 956, 245], [254, 1408, 1408, 254], [268, 1422, 1422, 268]\n        ];\n        this.OUTLINE_Y = [\n            [], [1489, 0, 0, 1489], [1556, 977, 977, 1556, 1556], [421, 0, 0, 421, 932, 1067, 1489, 1489, 1067, 556],\n            [85, -361, -361, 238.1, 380, 1231, 1576, 1576, 1185, 1071.5, 935, 283], [1075, 880.5, 743, 0, -29, -1.8, 80, 217.8, 413, 607.5, 745, 1489, 1517, 1489.8, 1408, 1270.3],\n            [409, 230.9, 90.5, -0.6, -31, 0, 909, 1333.4, 1432.5, 1498.1, 1520, 1490, 1412, 1301.5, 1174], [1556, 977, 977, 1556], [572, 286.3, 31, -412, -412, 1556, 1556, 1113, 857.8],\n            [-412, -412, 31, 286.3, 572, 857.8, 1113, 1556, 1556], [886, 776, 630, 630, 777, 887, 1299, 1409, 1556, 1556, 1410, 1300], [572, 27, 27, 572, 732, 1277, 1277, 732],\n            [-370, -370, 285, 285], [561, 561, 742, 742], [0, 0, 285, 285], [-304, -304, 1556, 1556],\n            [743, 400, 159, 16.5, -31, 15.9, 156.5, 397.4, 745, 1084.9, 1326.5, 1470.9, 1519, 1471.6, 1329.5, 1088.1], [0, 0, 152, 1494, 1494, 1286],\n            [0, 0, 171, 1110, 1279.4, 1409.5, 1492.4, 1520, 1491, 1427, 209], [63, -1.5, -31, 2.5, 106, 254, 441, 1161, 1320, 1436, 1500, 1520, 1490.5, 1426, 272],\n            [419, 0, 0, 419, 579, 1489, 1489, 649], [56, -5.5, -31, 6.5, 114, 274, 473, 1489, 1489, 267],\n            [654, 324, 104, 3, -31, 4.9, 112.5, 276.9, 483, 1494, 1512, 1517, 1453.5, 1277, 1005], [1314, 0, 0, 1266, 1489, 1489],\n            [411, 233.5, 91, -2.8, -34, -2, 94, 238.3, 415, 1144, 1294.5, 1416, 1496.3, 1523, 1495, 1411, 1285, 1131],\n            [1005, -6, -23.5, -29, 33, 209, 480, 834, 1171.5, 1385, 1485.5, 1519, 1483.3, 1376, 1211.8], [0, 0, 1117, 1117], [-370, -370, 285, 1117, 1117], [590, 77, 1227, 714],\n            [362, 362, 942, 942], [77, 590, 714, 1227], [1245, 0, 0, 964.5, 1139, 1293.4, 1414.5, 1492.9, 1519, 1497.5, 1449],\n            [647, 291, 15, -162.5, -226, -218.5, -190, 157, 394, 663, 1013.5, 1283, 1457, 1519, 1452, 1268, 991.5], [0, 0, 1489, 1489],\n            [0, 0, 28, 122, 262, 458, 1155, 1316.5, 1427, 1477, 1489, 1489], [743, 402.5, 161, 18.5, -27, -13.5, 19, 63, 108, 1385, 1487, 1516, 1465, 1317, 1072],\n            [0, 0, 28, 119, 375, 743, 1118, 1371, 1457.5, 1489, 1489], [0, 0, 1489, 1489], [0, 0, 717, 1313, 1489, 1489],\n            [746, 405.5, 163, 19, -29, 12.5, 110, 749, 1382, 1485.5, 1516, 1464.4, 1309.5, 1065.4], [0, 0, 1489, 1489], [0, 0, 1489, 1489],\n            [8, -12.5, -21, 5.5, 85, 213.5, 387, 1489, 1489, 193], [0, 0, 1489, 1489], [0, 0, 176, 1489, 1489], [0, 0, 1489, 1489], [0, 0, 1489, 1489],\n            [744, 415, 172, 21, -31, 20, 172, 414.5, 744, 1073, 1318, 1467.5, 1520, 1468, 1318, 1070.5], [0, 0, 709, 855.5, 1039, 1254, 1396, 1466.5, 1489, 1489],\n            [744, 415, 172, 21, -297.5, -369.1, -393, -386.5, -365, -183, 744, 1073, 1318, 1467.5, 1520, 1468, 1318, 1070.5], [0, 0, 1280.5, 1409, 1471.5, 1489, 1489],\n            [92, 3, -27, 9, 109, 253, 425, 1412, 1486, 1516, 1486.1, 1396.5, 1260.1, 1090, 340], [1313, 0, 0, 1313, 1489, 1489], [598, 313, 115, 6, -31, 4, 115, 315.5, 598, 1489, 1489],\n            [1489, 0, 0, 1489, 1489], [1489, 0, 0, 1489, 1489], [0, 0, 1489, 1489], [1489, 0, 0, 1489, 1489], [0, 0, 176, 1489, 1489, 184], [-392, -392, 1556, 1556],\n            [1556, -304, -304, 1556], [-392, -392, 1556, 1556], [682, 682, 684, 1489, 1489], [-300, -300, -180, -180], [1676, 1302, 1302, 1676],\n            [324, 182.8, 69, -6, -31, 0, 758, 939, 1058, 1124.5, 1144, 1126, 1093], [0, -31, 8.5, 127, 315, 567, 812.8, 996, 1110, 1556, 1556],\n            [557, 300, 118, 10.5, -25, 0, 70, 1050, 1116, 1143, 1104, 987, 801.5], [550, 306.8, 123, 7.5, -31, 0, 1556, 1556, 992, 803],\n            [552, 306.6, 124.5, 11.6, -26, 1, 68, 539, 641, 856.3, 1016, 1115, 1148, 1107.8, 987, 797.8], [959, 0, 0, 959, 1374, 1546, 1560, 1566, 1539.4, 1459.5, 1117],\n            [569, -375, -410.5, -423, -389.8, -290, -119.3, 127, 1117, 1148, 1108.5, 998, 817.5], [0, 0, 725, 906, 1039, 1556, 1556], [1304, 0, 0, 1304, 1499, 1499],\n            [-395, -415, -423, -398, -323, -199, -27, 1304, 1499, 1499, 1117, -216], [0, 0, 1117, 1556, 1556], [0, 0, 1556, 1556], [0, 0, 725, 902.9, 1036.5, 1120.1, 1148, 1148, 1117],\n            [0, 0, 725, 906, 1039, 1120.8, 1148, 1117], [558, 313.8, 127, 8.5, -31, 8.5, 127, 313.8, 558, 802.4, 989.5, 1108.4, 1148, 1108.4, 989.5, 802.4],\n            [-412, -412, 133, 323.5, 572, 813.4, 995.5, 1109.9, 1148, 1117], [555, 314.1, 131.5, 16.4, -412, -412, 1117, 1148, 1108, 995, 809.5], [0, 0, 912, 1105, 1114.5, 1117, 1117],\n            [67, 2.5, -27, -2.5, 71, 182.8, 322, 1060, 1119.5, 1144, 1116.5, 1042, 933, 803, 278], [959, 189.8, 70, 1, -22, -13, 10, 1117, 1438, 1438, 1117],\n            [392, 209.1, 76.5, -4.1, -31, 0, 1117, 1117], [1117, 0, 0, 1117, 1117], [1117, 0, 0, 1117, 1117], [0, 0, 1117, 1117], [1117, -412, -412, 1117, 1117],\n            [0, 0, 159, 1117, 1117, 139], [504, -170.9, -292.5, -367.1, -392, -392, 1556, 1556, 1531.1, 1456.5, 1334.9, 660], [-392, -392, 1556, 1556],\n            [-392, -392, -367.1, -292.5, -170.9, 504, 660, 1334.9, 1456.5, 1531.1, 1556, 1556], [395, 395, 396, 440, 561, 732, 927, 927, 926, 880.5, 761, 589.5], [], [0, 0, 1489, 1489],\n            [557, 333.5, 163, -361, -361, 74, 1046, 1475, 1475, 948.5, 775.9], [0, 0, 171, 1467, 1501, 1518, 1485.9, 1389.5, 1243.1, 751, 207],\n            [258, 145, 147, 257, 1067, 1176, 1176, 1066], [1489, 426, 0, 0, 426, 1489, 1489], [-392, -392, 1556, 1556],\n            [533, -327, -371.5, -385, -358, -275, -156, -10, 601, 1462, 1505, 1519, 1490, 1411, 1293.5, 1147], [1304, 1304, 1499, 1499],\n            [655, 323.1, 43.5, -146.6, -210, -146.6, 43.5, 323.1, 655, 986.9, 1266.5, 1456.6, 1520, 1456.6, 1266.5, 986.9],\n            [833, 616, 531, 554, 1192, 1332.4, 1435.5, 1498.9, 1520, 1504, 1475], [608, 162, 191, 1113, 1142, 697], [602, 57, 57, 762, 762], [561, 561, 742, 742],\n            [655, 323.1, 43.5, -146.6, -210, -146.6, 43.5, 323.1, 655, 986.9, 1266.5, 1456.6, 1520, 1456.6, 1266.5, 986.9], [1788, 1668, 1668, 1788],\n            [1116, 960.4, 831.5, 744.9, 716, 745, 832, 961, 1116, 1271, 1400, 1487, 1516, 1487, 1400, 1271], [179, 179, 917, 1462, 1462, 917],\n            [566, 566, 711, 1237, 1350.4, 1440.5, 1519, 1501.5, 1458, 722], [585, 542, 527, 543.5, 595, 685.5, 817, 1278, 1374.5, 1452, 1520, 1502.5, 1458, 764],\n            [1302, 1302, 1676, 1676], [-412, -412, 0, 1117, 1117], [1050, 866, -363, -363, 1489, 1489, 1460, 1373, 1234.3], [511, 511, 794, 794],\n            [-397, -416, -423, -337, -232, -89, -25, 20, 20, -237], [1256, 566, 566, 688, 1493, 1493, 1368],\n            [1025, 820.1, 663.5, 564.1, 531, 563.4, 660.5, 816.4, 1025, 1233.8, 1390, 1487.5, 1520, 1486.8, 1387, 1230], [191, 162, 608, 697, 1142, 1113],\n            [1246, 0, 0, 220, 353, 944, 1489, 1493, 1493, 1363], [1246, 0, 0, 139, 664, 865, 1489, 1493, 1493, 1363], [598, 0, 0, 220, 353, 944, 1489, 1517, 1500, 1456, 773],\n            [350, 195.6, 74.5, -3.9, -30, -10, 40, 244, 1489, 1489, 523], [0, 0, 1675, 2049, 2049], [0, 0, 2049, 2049, 1675], [0, 0, 1670, 2049, 2049, 1670],\n            [0, 0, 1992, 1992, 1987, 1910, 1682], [0, 0, 1872, 1872, 1872], [0, 0, 1712, 1843.5, 1952, 2024.8, 2049, 2024.8, 1952, 1843.5, 1712], [0, 0, 1489, 1489],\n            [743, 402.5, -397, -416, -423, -337, 108, 1385, 1487, 1516, 1465, 1317, 1072], [0, 0, 1489, 2049, 2049, 1489], [0, 0, 1489, 2049, 2049, 1489], [0, 0, 1489, 2049, 2049, 1489],\n            [0, 0, 1489, 1872, 1872, 1489], [0, 0, 1489, 2049, 2049, 1489], [0, 0, 2049, 2049, 1489], [1670, 0, 0, 1670, 2049, 2049], [1677, 0, 0, 1677, 1872, 1872],\n            [740, 0, 0, 28, 119, 375, 743, 1118, 1371, 1457.5, 1489, 1489, 883], [0, 0, 1489, 1992, 1992, 1987, 1910, 1489],\n            [744, 415, 172, 21, -31, 20, 172, 414.5, 744, 1073, 1318, 2049, 2049, 1070.5], [744, 415, 172, 21, -31, 20, 172, 414.5, 744, 1073, 2049, 2049, 1318, 1070.5],\n            [744, 415, 172, 21, -31, 20, 172, 414.5, 744, 1073, 1670, 2049, 2049, 1670, 1070.5], [744, 415, 172, 21, -31, 20, 172, 414.5, 744, 1073, 1992, 1992, 1987, 1910, 1070.5],\n            [744, 415, 172, 21, -31, 20, 172, 414.5, 744, 1073, 1872, 1872, 1872, 1070.5], [216, 105, 105, 216, 1088, 1199, 1199, 1088],\n            [744, -146, -146, 20, 172, 414.5, 744, 1611, 1611, 1520, 1468, 1318, 1070.5], [598, 313, 115, 6, -31, 4, 115, 315.5, 598, 1489, 2049, 2049, 1489],\n            [598, 313, 115, 6, -31, 4, 115, 315.5, 598, 1489, 2049, 2049, 1489], [598, 313, 115, 6, -31, 4, 115, 315.5, 598, 1489, 2049, 2049, 1489],\n            [598, 313, 115, 6, -31, 4, 115, 315.5, 598, 1489, 1872, 1872, 1489], [1489, 0, 0, 1489, 2049, 2049], [0, 0, 469, 610.5, 787, 992, 1130, 1489, 1489],\n            [0, -24, 12.4, 121.5, 284.1, 481, 1241, 1376, 1479, 1544.3, 1566, 1536.5, 1449, 1295.5, 1080], [324, 182.8, 69, -6, -31, 0, 758, 939, 1676, 1676, 1093],\n            [324, 182.8, 69, -6, -31, 0, 758, 1676, 1676, 1093], [324, 182.8, 69, -6, -31, 0, 758, 1297, 1676, 1676, 1297, 1093],\n            [324, 182.8, 69, -6, -31, 0, 758, 1619, 1619, 1614, 1537, 1309], [324, 182.8, 69, -6, -31, 0, 758, 1499, 1499, 1093],\n            [324, 182.8, 69, -6, -31, 0, 758, 1630, 1761.8, 1871, 1944.5, 1969, 1944.5, 1871, 1761.8, 1630],\n            [317, 178.8, 68, -4.8, -29, -26, 3.5, 68, 559, 641, 861.3, 1020, 1116, 1148, 1146, 1127, 1093], [557, 300, -397, -416, -423, -337, -232, 70, 1050, 1116, 1143, 1104, 987, 801.5],\n            [552, 306.6, 124.5, 11.6, -26, 1, 68, 539, 641, 856.3, 1016, 1676, 1676, 797.8], [552, 306.6, 124.5, 11.6, -26, 1, 68, 539, 641, 856.3, 1676, 1676, 987, 797.8],\n            [552, 306.6, 124.5, 11.6, -26, 1, 68, 539, 641, 856.3, 1297, 1676, 1676, 1297, 797.8], [552, 306.6, 124.5, 11.6, -26, 1, 68, 539, 641, 856.3, 1499, 1499, 797.8],\n            [1676, 0, 0, 1302, 1676], [1302, 0, 0, 1676, 1676], [1297, 0, 0, 1297, 1676, 1676], [1304, 0, 0, 1304, 1499, 1499],\n            [484, 266.5, 104, 2.8, -31, 12, 141, 351, 637, 1469, 1566, 1556], [0, 0, 725, 1619, 1619, 1614, 1537, 1309, 1117],\n            [558, 313.8, 127, 8.5, -31, 8.5, 127, 313.8, 558, 802.4, 989.5, 1676, 1676, 802.4], [558, 313.8, 127, 8.5, -31, 8.5, 127, 313.8, 558, 802.4, 1676, 1676, 989.5, 802.4],\n            [558, 313.8, 127, 8.5, -31, 8.5, 127, 313.8, 558, 802.4, 1297, 1676, 1676, 1297, 802.4], [558, 313.8, 127, 8.5, -31, 8.5, 127, 313.8, 558, 1619, 1619, 1614, 1537, 1309],\n            [558, 313.8, 127, 8.5, -31, 8.5, 127, 313.8, 558, 802.4, 1499, 1499, 1499, 802.4], [572, 7, 7, 572, 732, 1297, 1297, 732],\n            [-148, -148, 8.5, 127, 313.8, 558, 1241, 1241, 1108.4, 989.5, 802.4, 558], [392, 209.1, 76.5, -4.1, -31, 0, 1117, 1676, 1676, 1117],\n            [392, 209.1, 76.5, -4.1, -31, 0, 1117, 1676, 1676, 1117], [392, 209.1, 76.5, -4.1, -31, 0, 1117, 1676, 1676, 1117], [392, 209.1, 76.5, -4.1, -31, 0, 1117, 1499, 1499, 1117],\n            [1117, -412, -412, 1117, 1676, 1676], [-412, -412, 133, 323.5, 572, 813.4, 995.5, 1109.9, 1556, 1556], [-370, -370, 285, 1117, 1117], [1676, 1292, 1292, 1676],\n            [1304, 1292, 1292, 1304, 1499, 1676, 1676, 1499], [1489, 0, 0, 1489], [832, 832, 1117, 1117], [1489, 1105, 0, 0, 1489, 1489], [1489, 1105, 0, 0, 1489, 1489],\n            [1489, 1105, 0, 0, 1489, 1489], [1489, 1105, 415, 172, 21, -31, 20, 172, 414.5, 744, 1073, 1318, 1467.5, 1520], [1489, 1105, 0, 0, 1489, 1489],\n            [1489, 1105, 0, 0, 174, 894, 1144.8, 1345, 1476.3, 1520], [1304, 0, 0, 1304, 1499, 1676, 1676, 1499], [0, 0, 1489, 1489],\n            [0, 0, 28, 122, 262, 458, 1155, 1316.5, 1427, 1477, 1489, 1489], [0, 0, 1313, 1489, 1489], [0, 0, 1489, 1489], [0, 0, 1489, 1489], [0, 0, 176, 1489, 1489, 184],\n            [0, 0, 1489, 1489], [744, 415, 172, 21, -31, 20, 172, 414.5, 744, 1073, 1318, 1467.5, 1520, 1468, 1318, 1070.5], [0, 0, 1489, 1489], [0, 0, 1489, 1489], [0, 0, 1489, 1489],\n            [0, 0, 1489, 1489], [0, 0, 1489, 1489], [0, 0, 1489, 1489], [744, 415, 172, 21, -31, 20, 172, 414.5, 744, 1073, 1318, 1467.5, 1520, 1468, 1318, 1070.5], [0, 0, 1489, 1489],\n            [0, 0, 709, 855.5, 1039, 1254, 1396, 1466.5, 1489, 1489], [0, 0, 176, 1489, 1489, 184], [1313, 0, 0, 1313, 1489, 1489], [1489, 0, 0, 1489, 1489],\n            [755, 507, 325, -16, -16, 325, 506.5, 755, 994, 1171, 1505, 1505, 1171, 993], [0, 0, 1489, 1489], [910, 647, 471, 0, 0, 471, 645.5, 910, 1489, 1489],\n            [0, 0, 174, 894, 1144.8, 1345, 1476.3, 1520, 1476.3, 1345, 1144.8, 894, 174], [1677, 0, 0, 1677, 1872, 1872], [1489, 0, 0, 1489, 1872, 1872, 1872],\n            [550, 306.8, 123, 7.5, -31, 0, 1117, 1676, 1676, 803], [306, 148.5, 46, -10, -26, -5, 64, 270, 1083, 1676, 1676, 986.5, 839], [0, -412, -412, 725, 906, 1676, 1676, 1117],\n            [1676, 0, 0, 1676], [407, 213.6, 77.5, -3.1, -30, -2.6, 79.5, 216.1, 407, 1117, 1499, 1676, 1676, 1499, 1117], [550, 306.8, 123, 7.5, -31, 0, 1117, 1148, 1108, 992, 803],\n            [-412, -412, 110, 259.5, 444, 1195, 1355, 1467, 1534.5, 1556, 1524.3, 1429, 1277.8, 1078], [1117, -412, -412, 1117, 1117],\n            [534, 299.6, 120.5, 6.9, -31, 7.8, 124, 308.3, 551, 1556, 1556], [306, 148.5, 46, -10, -26, -5, 64, 270, 1083, 1127.5, 1144, 1128, 1079, 986.5, 839],\n            [463, 262.3, 118, -412, -412, -264.5, -96, 1556, 1556], [0, -412, -412, 725, 906, 1039, 1120.8, 1148, 1117],\n            [768, 451.5, 241, 37.5, -31, 37.5, 241, 451.5, 768, 1073, 1288, 1487, 1556, 1487, 1288, 1073.5], [0, 0, 1117, 1117], [0, 0, 1117, 1118, 1119, 1117], [0, 0, 1556, 1556],\n            [-412, -412, 0, 1117, 1117], [1117, 0, 0, 1117, 1117], [412, 248.5, 113, -412, -412, -265, -96, 1556, 1556],\n            [558, 313.8, 127, 8.5, -31, 8.5, 127, 313.8, 558, 802.4, 989.5, 1108.4, 1148, 1108.4, 989.5, 802.4], [0, 0, 1117, 1117],\n            [-412, -412, 148.5, 340.9, 577, 821.5, 1001, 1111.3, 1148, 1115, 1020, 861.5, 646], [549, 299, 129, -412, -412, -268, -96, 1079, 1124.5, 1143, 1102.5, 981, 792],\n            [558, 313.8, 127, 8.5, -31, 7.5, 123, 308.8, 952, 1117, 1148, 1108.6, 990.5, 803.6], [952, 0, 0, 952, 1117, 1117],\n            [407, 213.6, 77.5, -3.1, -30, -2.6, 79.5, 216.1, 407, 1117, 1117], [546, 314, 142, -412, -412, 159, 342.3, 576, 816.6, 996.5, 1108.6, 1146, 1145.5, 1143, 1117, 842],\n            [-412, -412, 1117, 1117], [446, 248.5, -412, -412, 248, 446, 1117, 1117], [503, 310.5, 139, 16.5, -30, -30, 14.5, 139, 310.5, 503, 811.5, 1117, 1117, 811.5],\n            [1304, 0, 0, 1304, 1499, 1499], [407, 213.6, 77.5, -3.1, -30, -2.6, 79.5, 216.1, 407, 1117, 1499, 1499, 1117],\n            [558, 313.8, 127, 8.5, -31, 8.5, 127, 313.8, 558, 802.4, 1676, 1676, 802.4], [407, 213.6, 77.5, -3.1, -30, -2.6, 79.5, 216.1, 407, 1117, 1676, 1676, 1117],\n            [503, 310.5, 139, 16.5, -30, -30, 14.5, 139, 310.5, 503, 811.5, 1676, 1676, 811.5], [424, 240.1, 94.5, -0.4, -32, 17, 190, 493, 837, 1097, 1286, 1464.5, 1519, 1496.5, 1430],\n            [0, 0, 1489, 1489], [1315, -193, -193, 1315, 1489, 1489], [-189, -189, -13, 1489, 1489, 2], [572, 572, 732, 732], [0, 0, 1489, 1489], [511, 511, 794, 794],\n            [842, -151, -151, 1788, 1788, 981], [642, 447.6, 292.5, 190.9, 157, 157, 190.4, 290.5, 450.4, 663, 857.4, 1012.5, 1114.1, 1148, 1148, 1114.5, 1014, 854],\n            [-402, -417.5, -423, -395.5, -313, -179.8, 1367, 1545, 1560.5, 1566, 1538.5, 1456, 1321.8, -224], [202, 202, 209, 233.4, 306.5, 588, 1104, 1104, 1097, 1072.5, 999, 719],\n            [362, 27, 27, 362, 942, 1277, 1277, 942], [0, 0, 1393, 910], [0, 0, 910, 1393]\n        ];\n        this.KERN_C1 = [\n            '\\'', '\\'', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '.', '.', 'A', 'A', 'A', 'A', 'A', 'A', 'A',\n            'A', 'A', 'A', 'A', 'A', 'B', 'B', 'B', 'B', 'C', 'D', 'D', 'D', 'D', 'D', 'D', 'D', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F',\n            'I', 'J', 'J', 'J', 'J', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'K', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\n            'L', 'O', 'O', 'O', 'O', 'O', 'O', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P', 'Q', 'Q', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'S',\n            'S', 'S', 'S', 'S', 'S', 'S', 'S', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T', 'T',\n            'T', 'T', 'T', 'T', 'T', 'T', 'U', 'U', 'U', 'U', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'V', 'W', 'W', 'W', 'W', 'W', 'W',\n            'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y',\n            'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z', 'Z',\n            'a', 'a', 'a', 'b', 'b', 'b', 'c', 'c', 'e', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'h', 'h', 'h', 'k', 'k', 'k', 'k', 'm', 'm',\n            'm', 'n', 'n', 'n', 'o', 'o', 'o', 'o', 'o', 'p', 'p', 'p', 'r', 'r', 'r', 'r', 'r', 't', 't', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'w', 'w', 'w',\n            'w', 'w', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'y', 'y', 'y', 'y', 'y', 'y', 'y', 'y', 'y', 'y', 'y', 'y', 'y', 'z', 'z', 'z', 'z', 'z', 'z', 'z',\n            'z', 'z', '\\u00C7', '\\u00E7', '\\u00D8', '\\u00D8', '\\u00D8', '\\u00D8', '\\u00D8', '\\u00D8', '\\u00F8', '\\u00F8', '\\u00F8', '\\u00F8', '\\u00F8'\n        ];\n        this.KERN_C2 = [\n            '\\u00C6', 'A', '\\u00E6', '\\u00C6', 'z', 'y', 'x', 'w', 'v', 'a', 'Z', 'Y', 'X', 'W', 'V', 'T', 'S', 'J', 'I', 'A', '-', ',', 'y', 'w', 'v', 'u', 't',\n            'Y', 'W', 'V', 'U', 'T', 'S', '-', 'T', '.', '-', ',', '-', 'Z', 'Y', 'X', 'W', 'T', '.', ',', '\\u00F8', '\\u00E6', '\\u00C6', 'o', 'e', 'a', 'T', 'A',\n            '?', ';', ':', '.', ',', '-', '\\u00C6', 'A', '.', ',', '\\u00F8', '\\u00E6', '\\u00D8', 'y', 'w', 'v', 'u', 'o', 'e', 'a', 'O', '-', '\\u00D8', '\\u00C7',\n            'y', 'v', 'Y', 'W', 'V', 'T', 'O', 'J', 'G', 'C', '-', '\\'', 'Z', 'Y', 'X', 'T', '.', ',', '\\u00F8', '\\u00E6', '\\u00C6', 'o', 'e', 'a', 'Y', 'A',\n            '.', ',', '.', ',', '\\u00F8', '\\u00E6', 'y', 'u', 'o', 'e', 'a', 'Y', 'T', '-', '\\u00C6', 'y', 'w', 'v', 'S', 'A', '.', ',', '\\u00F8', '\\u00E6',\n            '\\u00D8', '\\u00C6', '\\u00C7', 'z', 'y', 'w', 'v', 'u', 's', 'r', 'o', 'g', 'e', 'c', 'a', 'T', 'S', 'O', 'G', 'C', 'A', '?', ';', ':', '.', '-', ',',\n            '\\u00C6', 'A', '.', ',', '\\u00F8', '\\u00E6', '\\u00C6', 'y', 'u', 'o', 'e', 'a', 'A', ';', ':', '.', '-', ',', '\\u00F8', '\\u00E6', '\\u00C6', 'y', 'u',\n            'r', 'o', 'e', 'a', 'A', ';', ':', '.', '-', ',', '\\u00F8', '\\u00E6', '\\u00D8', '\\u00C7', 'y', 'u', 'o', 'e', 'a', 'O', 'G', 'C', '-', '\\u00F8',\n            '\\u00E6', '\\u00D8', '\\u00C6', 'v', 'u', 's', 'r', 'q', 'p', 'o', 'n', 'm', 'g', 'e', 'd', 'a', 'O', 'A', ';', ':', '.', '-', ',', '\\u00F8', '\\u00E6',\n            '\\u00D8', '\\u00C7', 'y', 'w', 'o', 'e', 'a', 'Z', 'O', 'G', 'C', '-', 'y', 'w', 'v', 'y', '.', ',', 'T', '-', 'T', '}', 'y', ']', '\\\\', '?', '.',\n            '-', ',', '*', ')', '\\'', '\"', 'y', 'w', 'v', '\\u00F8', 'o', 'e', '-', 'y', 'w', 'v', 'y', 'w', 'v', 'y', 'x', 'v', '.', ',', 'y', '.', ',',\n            '\\u00E6', 'a', '.', '-', ',', 'y', '-', '\\u00F8', '\\u00E6', 'o', 'e', 'a', '.', '-', ',', '\\u00E6', 'a', '.', '-', ',', '\\u00F8', '\\u00E7', 'o', 'g',\n            'e', 'd', 'c', '-', '\\u00F8', '\\u00E6', '\\u00E7', 'q', 'o', 'g', 'e', 'd', 'c', 'a', '.', '-', ',', '\\u00F8', '\\u00E7', 'q', 'o', 'g', 'e', 'd', 'c',\n            '-', '-', '-', 'Z', 'Y', 'X', 'T', '.', ',', 'y', 'x', 'v', '.', ','\n        ];\n        this.KERN_K = [\n            100, 100, 20, 50, 40, 40, 50, 20, 40, 20, 30, 140, 80, 50, 50, 150, 20, 100, 30, 50, 160, 130, 50, 30, 50, 10, 20, 80, 50, 60, 10, 120, 10, 50, 60,\n            20, -10, 20, 50, 20, 20, 10, 20, 50, 50, 50, 50, 100, 110, 50, 50, 100, -30, 100, -60, 60, 60, 300, 300, 30, 10, 10, 20, 20, 70, 60, 20, 80, 70, 80,\n            50, 70, 70, 60, 20, 110, 20, 20, 110, 110, 160, 100, 110, 170, 20, -100, 20, 20, 160, 120, 20, 20, 10, 50, 30, 30, 50, 50, 70, 50, 50, 50, -20, 50,\n            300, 300, 30, 30, 50, 50, 55, 20, 50, 50, 40, 20, 60, 100, 20, 30, 20, 30, 22, 20, 20, 20, 220, 240, 50, 130, 40, 170, 200, 200, 200, 200, 180, 200,\n            220, 210, 220, 220, 240, 70, 12, 50, 40, 40, 120, -60, 200, 200, 290, 150, 290, 20, 10, 20, 20, 100, 100, 70, 65, 60, 100, 100, 100, 60, 80, 80, 290,\n            50, 290, 100, 100, 60, 65, 60, 60, 100, 100, 100, 50, 80, 80, 220, 50, 290, 60, 50, 10, 10, 80, 30, 60, 60, 50, 10, 10, 10, 80, 130, 140, 20, 80,\n            100, 110, 110, 100, 130, 100, 130, 100, 100, 130, 130, 120, 140, 20, 80, 200, 200, 290, 140, 290, 60, 50, 20, 20, 65, 40, 60, 60, 50, 10, 20, 20, 20,\n            60, 16, 10, 16, 5, 20, 30, 60, 20, 140, -100, 10, -100, -100, -110, 120, 50, 130, -50, -100, -60, -60, 20, 10, 20, 20, 20, 20, 100, 20, 10, 20, 20,\n            10, 20, 15, 20, 15, 20, 30, 5, 20, 30, 40, 36, 290, 20, 290, 10, 40, 18, 40, 18, 18, 40, 180, 40, 180, 20, 20, 70, 20, 70, 24, 20, 24, 10, 24, 10,\n            20, 50, 18, 40, 18, 10, 18, 10, 18, 10, 18, 40, 190, 40, 190, 12, 10, 10, 12, 10, 12, 10, 10, 20, 50, 20, 20, 20, 10, 50, 30, 30, 15, 20, 15, 20, 30\n        ];\n        this.pathCache = [];\n        this.pathMissing = null;\n        this.ctxReference = null;\n        for (let n = this.GLYPH_DATA.length - 1; n >= 0; n--)\n            this.pathCache[n] = null;\n    }\n    getKerning(ch1, ch2) {\n        const sz = this.KERN_K.length;\n        for (let n = 0; n < sz; n++)\n            if (this.KERN_C1[n] == ch1 && this.KERN_C2[n] == ch2)\n                return -this.KERN_K[n];\n        return 0;\n    }\n    static measureText(txt, size) { return this.main.measureText(txt, size); }\n    measureText(txt, size) {\n        let font = FontData.main;\n        let scale = size / font.UNITS_PER_EM;\n        let dx = 0;\n        for (let n = 0; n < txt.length; n++) {\n            let ch = txt.charAt(n);\n            let i = this.getIndex(ch);\n            if (i < 0) {\n                dx += font.MISSING_HORZ;\n                continue;\n            }\n            dx += font.HORIZ_ADV_X[i];\n            if (n < txt.length - 1)\n                dx += font.getKerning(ch, txt.charAt(n + 1));\n        }\n        return [dx * scale, font.ASCENT * scale * font.ASCENT_FUDGE, -font.DESCENT * scale];\n    }\n    static measureWidths(txt, size) { return this.main.measureWidths(txt, size); }\n    measureWidths(txt, size) {\n        let font = FontData.main;\n        let scale = size / font.UNITS_PER_EM;\n        let xpos = [0];\n        let dx = 0;\n        for (let n = 0; n < txt.length; n++) {\n            let ch = txt.charAt(n);\n            let i = this.getIndex(ch);\n            if (i < 0) {\n                dx += font.MISSING_HORZ;\n                xpos.push(dx * scale);\n                continue;\n            }\n            dx += font.HORIZ_ADV_X[i];\n            if (n < txt.length - 1)\n                dx += font.getKerning(ch, txt.charAt(n + 1));\n            xpos.push(dx * scale);\n        }\n        return xpos;\n    }\n    getIndex(ch) {\n        return this.UNICODE.indexOf(ch);\n    }\n    getRawGlyph(idx) {\n        return this.GLYPH_DATA[idx];\n    }\n    getGlyphPath(idx) {\n        let path = this.pathCache[idx];\n        if (path != null)\n            return path;\n        path = new Path2D(this.GLYPH_DATA[idx]);\n        this.pathCache[idx] = path;\n        return path;\n    }\n    getMissingPath() {\n        if (!this.pathMissing)\n            this.pathMissing = new Path2D(this.MISSING_DATA);\n        return this.pathMissing;\n    }\n    getOutlineX(idx) { return this.OUTLINE_X[idx].slice(0); }\n    getOutlineY(idx) { return this.OUTLINE_Y[idx].slice(0); }\n    initNativeFont(ctx) {\n        if (ctx == null && this.ctxReference)\n            return;\n        if (ctx == null) {\n            let canvas = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<canvas/>').appendTo(document.body);\n            this.ctxReference = canvas.el.getContext('2d');\n            canvas.remove();\n        }\n        else\n            this.ctxReference = ctx;\n    }\n    static measureTextNative(txt, family, size, opt = {}) {\n        return this.main.measureTextNative(txt, family, size, opt);\n    }\n    measureTextNative(txt, family, size, opt = {}) {\n        if (!this.ctxReference)\n            throw 'Calling measureTextNative without having called initNativeFont first';\n        this.ctxReference.save();\n        let pfx = '';\n        if (opt.bold)\n            pfx += 'bold ';\n        if (opt.italic)\n            pfx += 'italic ';\n        this.ctxReference.font = pfx + size + 'px ' + family;\n        let metrics = this.ctxReference.measureText(txt);\n        this.ctxReference.restore();\n        const FUDGE = this.ASCENT_FUDGE * this.ASCENT / this.UNITS_PER_EM;\n        return [metrics.width, size * FUDGE, size * (-this.DESCENT / this.ASCENT) * FUDGE];\n    }\n}\nFontData.main = new FontData();\n\n\n//# sourceURL=webpack://WebMolKit/./src/gfx/FontData.ts?");

/***/ }),

/***/ "./src/gfx/MetaVector.ts":
/*!*******************************!*\
  !*** ./src/gfx/MetaVector.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MetaVector\": () => (/* binding */ MetaVector),\n/* harmony export */   \"TextAlign\": () => (/* binding */ TextAlign)\n/* harmony export */ });\n/* harmony import */ var _util_Geom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Geom */ \"./src/util/Geom.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _util_XML__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/XML */ \"./src/util/XML.ts\");\n/* harmony import */ var _FontData__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./FontData */ \"./src/gfx/FontData.ts\");\n\n\n\n\n\nvar TextAlign;\n(function (TextAlign) {\n    TextAlign[TextAlign[\"Centre\"] = 0] = \"Centre\";\n    TextAlign[TextAlign[\"Left\"] = 1] = \"Left\";\n    TextAlign[TextAlign[\"Right\"] = 2] = \"Right\";\n    TextAlign[TextAlign[\"Baseline\"] = 0] = \"Baseline\";\n    TextAlign[TextAlign[\"Middle\"] = 4] = \"Middle\";\n    TextAlign[TextAlign[\"Top\"] = 8] = \"Top\";\n    TextAlign[TextAlign[\"Bottom\"] = 16] = \"Bottom\";\n})(TextAlign || (TextAlign = {}));\nconst PRIM_LINE = 1;\nconst PRIM_RECT = 2;\nconst PRIM_OVAL = 3;\nconst PRIM_PATH = 4;\nconst PRIM_TEXT = 5;\nconst PRIM_TEXTNATIVE = 6;\nclass MetaVector {\n    constructor(vec) {\n        this.types = [];\n        this.prims = [];\n        this.width = 0;\n        this.height = 0;\n        this.offsetX = 0;\n        this.offsetY = 0;\n        this.scale = 1;\n        this.density = 1;\n        this.charMissing = false;\n        this.lowX = null;\n        this.lowY = null;\n        this.highX = null;\n        this.highY = null;\n        const font = _FontData__WEBPACK_IMPORTED_MODULE_4__.FontData.main;\n        this.charMask = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.booleanArray(false, font.UNICODE.length);\n        if (vec != null) {\n            if (vec.size != null) {\n                this.width = vec.size[0];\n                this.height = vec.size[1];\n            }\n            if (vec.types != null)\n                this.types = vec.types;\n            if (vec.prims != null)\n                this.prims = vec.prims;\n            for (let p of this.prims)\n                if (p[0] == PRIM_TEXT) {\n                    let txt = p[4];\n                    for (let n = 0; n < txt.length; n++) {\n                        let i = font.getIndex(txt.charAt(n));\n                        if (i >= 0)\n                            this.charMask[i] = true;\n                        else\n                            this.charMissing = true;\n                    }\n                }\n        }\n    }\n    drawLine(x1, y1, x2, y2, colour, thickness) {\n        if (thickness == null)\n            thickness = 1;\n        let typeidx = this.findOrCreateType([PRIM_LINE, thickness, colour]);\n        const bump = 0.5 * thickness;\n        this.updateBounds(Math.min(x1, x2) - bump, Math.min(y1, y2) - bump);\n        this.updateBounds(Math.max(x1, x2) + bump, Math.max(y1, y2) + bump);\n        this.prims.push([PRIM_LINE, typeidx, x1, y1, x2, y2]);\n    }\n    drawRect(x, y, w, h, edgeCol, thickness, fillCol) {\n        if (edgeCol == null)\n            edgeCol = MetaVector.NOCOLOUR;\n        if (fillCol == null)\n            fillCol = MetaVector.NOCOLOUR;\n        if (thickness == null)\n            thickness = 1;\n        let typeidx = this.findOrCreateType([PRIM_RECT, edgeCol, fillCol, thickness]);\n        const bump = 0.5 * thickness;\n        this.updateBounds(x - bump, y - bump);\n        this.updateBounds(x + w + bump, y + h + bump);\n        this.prims.push([PRIM_RECT, typeidx, x, y, w, h]);\n    }\n    drawOval(cx, cy, rw, rh, edgeCol, thickness, fillCol) {\n        if (edgeCol == null)\n            edgeCol = MetaVector.NOCOLOUR;\n        if (fillCol == null)\n            fillCol = MetaVector.NOCOLOUR;\n        if (thickness == null)\n            thickness = 1;\n        const bump = 0.5 * thickness;\n        this.updateBounds(cx - rw - bump, cy - rh - bump);\n        this.updateBounds(cx + rw + bump, cy + rh + bump);\n        let typeidx = this.findOrCreateType([PRIM_OVAL, edgeCol, fillCol, thickness]);\n        this.prims.push([PRIM_OVAL, typeidx, cx, cy, rw, rh]);\n    }\n    drawPath(xpoints, ypoints, ctrlFlags, isClosed, edgeCol, thickness, fillCol, hardEdge) {\n        if (edgeCol == null)\n            edgeCol = MetaVector.NOCOLOUR;\n        if (fillCol == null)\n            fillCol = MetaVector.NOCOLOUR;\n        if (thickness == null)\n            thickness = 1;\n        if (hardEdge == null)\n            hardEdge = false;\n        const bump = 0.5 * thickness;\n        for (let n = 0; n < xpoints.length; n++) {\n            this.updateBounds(xpoints[n] - bump, ypoints[n] - bump);\n            if (bump != 0)\n                this.updateBounds(xpoints[n] + bump, ypoints[n] + bump);\n        }\n        let typeidx = this.findOrCreateType([PRIM_PATH, edgeCol, fillCol, thickness, hardEdge]);\n        this.prims.push([PRIM_PATH, typeidx, xpoints.length, (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.clone)(xpoints), (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.clone)(ypoints), (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.clone)(ctrlFlags), isClosed]);\n    }\n    drawPoly(xpoints, ypoints, edgeCol, thickness, fillCol, hardEdge) {\n        this.drawPath(xpoints, ypoints, null, true, edgeCol, thickness, fillCol, hardEdge);\n    }\n    drawText(x, y, txt, size, colour, align, direction) {\n        if (align == null)\n            align = TextAlign.Left | TextAlign.Baseline;\n        if (direction == null)\n            direction = 0;\n        let cosTheta = 1, sinTheta = 0;\n        if (direction != 0)\n            [cosTheta, sinTheta] = [Math.cos(direction * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD), Math.sin(direction * _util_util__WEBPACK_IMPORTED_MODULE_1__.DEGRAD)];\n        const font = _FontData__WEBPACK_IMPORTED_MODULE_4__.FontData.main;\n        for (let n = 0; n < txt.length; n++) {\n            let i = font.getIndex(txt.charAt(n));\n            if (i >= 0)\n                this.charMask[i] = true;\n            else\n                this.charMissing = true;\n        }\n        let metrics = font.measureText(txt, size);\n        let bx = 0, by = 0;\n        let dx = 0;\n        if ((align & TextAlign.Left) != 0) { }\n        else if ((align & TextAlign.Right) != 0)\n            dx = -metrics[0];\n        else\n            dx = -0.5 * metrics[0];\n        if (dx != 0) {\n            bx += dx * cosTheta;\n            by += dx * sinTheta;\n        }\n        let dy = 0;\n        if ((align & TextAlign.Middle) != 0)\n            dy = 0.5 * metrics[1];\n        else if ((align & TextAlign.Top) != 0)\n            dy = metrics[1];\n        else if ((align & TextAlign.Bottom) != 0)\n            dy = -metrics[2];\n        if (dy != 0) {\n            bx -= dy * sinTheta;\n            by += dy * cosTheta;\n        }\n        let x1 = 0, y1 = 0, x2 = 0, y2 = 0;\n        let tx = 0;\n        for (let n = 0; n < txt.length; n++) {\n            let ch = txt.charAt(n);\n            let i = font.getIndex(ch);\n            if (i >= 0) {\n                let outlineX = font.getOutlineX(i), outlineY = font.getOutlineY(i);\n                x1 = Math.min(x1, tx + _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.min(outlineX));\n                x2 = Math.max(x2, tx + _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.max(outlineX));\n                y1 = Math.min(y1, -_util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.max(outlineY));\n                y2 = Math.max(y2, -_util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.min(outlineY));\n                tx += font.HORIZ_ADV_X[i];\n                if (n < txt.length - 1)\n                    tx += font.getKerning(ch, txt.charAt(n + 1));\n            }\n            else\n                tx += font.MISSING_HORZ;\n        }\n        const mscale = size * font.INV_UNITS_PER_EM;\n        if (direction == 0) {\n            this.updateBounds(x + bx + x1 * mscale, y + by + y1 * mscale);\n            this.updateBounds(x + bx + x2 * mscale, y + by + y2 * mscale);\n        }\n        else {\n            let rx1 = x1 * mscale, ry1 = y1 * mscale;\n            let rx2 = x2 * mscale, ry2 = y2 * mscale;\n            this.updateBounds(x + bx + rx1 * cosTheta - ry1 * sinTheta, y + by + rx1 * sinTheta + ry1 * cosTheta);\n            this.updateBounds(x + bx + rx2 * cosTheta - ry1 * sinTheta, y + by + rx2 * sinTheta + ry1 * cosTheta);\n            this.updateBounds(x + bx + rx2 * cosTheta - ry2 * sinTheta, y + by + rx2 * sinTheta + ry2 * cosTheta);\n            this.updateBounds(x + bx + rx1 * cosTheta - ry2 * sinTheta, y + by + rx1 * sinTheta + ry2 * cosTheta);\n        }\n        let typeidx = this.findOrCreateType([PRIM_TEXT, size, colour]);\n        this.prims.push([PRIM_TEXT, typeidx, x + bx, y + by, txt, direction]);\n    }\n    drawTextNative(x, y, txt, fontFamily, fontSize, colour, align, opt) {\n        if (!opt)\n            opt = {};\n        if (align == null)\n            align = TextAlign.Left | TextAlign.Baseline;\n        const font = _FontData__WEBPACK_IMPORTED_MODULE_4__.FontData.main;\n        for (let n = 0; n < txt.length; n++) {\n            let i = font.getIndex(txt.charAt(n));\n            if (i >= 0)\n                this.charMask[i] = true;\n            else\n                this.charMissing = true;\n        }\n        let metrics = font.measureTextNative(txt, fontFamily, fontSize, opt);\n        let bx = 0, by = 0;\n        if ((align & TextAlign.Left) != 0) { }\n        else if ((align & TextAlign.Right) != 0)\n            bx = -metrics[0];\n        else\n            bx = -0.5 * metrics[0];\n        if ((align & TextAlign.Middle) != 0)\n            by += 0.5 * metrics[1];\n        else if ((align & TextAlign.Top) != 0)\n            by += metrics[1];\n        else if ((align & TextAlign.Bottom) != 0)\n            by -= metrics[2];\n        this.updateBounds(x, y - metrics[1]);\n        this.updateBounds(x + metrics[0], y + metrics[2]);\n        let typeidx = this.findOrCreateType([PRIM_TEXTNATIVE, fontFamily, fontSize, colour, opt]);\n        this.prims.push([PRIM_TEXTNATIVE, typeidx, x + bx, y + by, txt]);\n    }\n    boundLowX() { return this.lowX; }\n    boundLowY() { return this.lowY; }\n    boundHighX() { return this.highX; }\n    boundHighY() { return this.highY; }\n    getBounds() { return new _util_Geom__WEBPACK_IMPORTED_MODULE_0__.Box(this.lowX, this.lowY, this.highX - this.lowX, this.highY - this.lowY); }\n    measure() {\n        this.width = Math.ceil(this.highX - this.lowX);\n        this.height = Math.ceil(this.highY - this.lowY);\n    }\n    normalise() {\n        if (this.lowX != 0 || this.lowY != 0)\n            this.transformPrimitives(-this.lowX, -this.lowY, 1, 1);\n        this.width = Math.ceil(this.highX - this.lowX);\n        this.height = Math.ceil(this.highY - this.lowY);\n    }\n    setSize(width, height) { this.width = width; this.height = height; }\n    transformIntoBox(box) {\n        this.transformPrimitives(-this.lowX, -this.lowY, 1, 1);\n        let nw = Math.ceil(this.highX - this.lowX), nh = Math.ceil(this.highY - this.lowY);\n        let scale = 1;\n        if (nw > box.w) {\n            let mod = box.w / nw;\n            nw = box.w;\n            nh *= mod;\n            scale *= mod;\n        }\n        if (nh > box.h) {\n            let mod = box.h / nh;\n            nh = box.h;\n            nw *= mod;\n            scale *= mod;\n        }\n        let ox = 0.5 * (box.w - nw), oy = 0.5 * (box.h - nh);\n        this.transformPrimitives(box.x + ox, box.y + oy, scale, scale);\n    }\n    scaleExtent(maxWidth, maxHeight) {\n        let w = this.highX - this.lowX, h = this.highY - this.lowY;\n        if (w <= maxWidth && h <= maxHeight)\n            return;\n        let scale = Math.min(maxWidth / w, maxHeight / h);\n        this.transformPrimitives(0, 0, scale, scale);\n    }\n    transformPrimitives(ox, oy, sw, sh) {\n        if (ox == 0 && oy == 0 && sw == 1 && sh == 1)\n            return;\n        for (let a of this.prims) {\n            const type = a[0];\n            if (type == PRIM_LINE) {\n                a[2] = ox + a[2] * sw;\n                a[3] = oy + a[3] * sh;\n                a[4] = ox + a[4] * sw;\n                a[5] = oy + a[5] * sh;\n            }\n            else if (type == PRIM_RECT) {\n                a[2] = ox + a[2] * sw;\n                a[3] = oy + a[3] * sh;\n                a[4] = a[4] * sw;\n                a[5] = a[5] * sh;\n            }\n            else if (type == PRIM_OVAL) {\n                a[2] = ox + a[2] * sw;\n                a[3] = oy + a[3] * sh;\n                a[4] *= sw;\n                a[5] *= sh;\n            }\n            else if (type == PRIM_PATH) {\n                let sz = a[2], px = a[3], py = a[4];\n                for (let n = 0; n < sz; n++) {\n                    px[n] = ox + px[n] * sw;\n                    py[n] = oy + py[n] * sh;\n                }\n            }\n            else if (type == PRIM_TEXT || type == PRIM_TEXTNATIVE) {\n                a[2] = ox + a[2] * sw;\n                a[3] = oy + a[3] * sh;\n            }\n        }\n        let swsh = 0.5 * (sw + sh);\n        if (swsh != 1)\n            for (let t of this.types) {\n                const type = t[0];\n                if (type == PRIM_LINE)\n                    t[1] *= swsh;\n                else if (type == PRIM_RECT)\n                    t[3] *= swsh;\n                else if (type == PRIM_OVAL)\n                    t[3] *= swsh;\n                else if (type == PRIM_PATH)\n                    t[3] *= swsh;\n                else if (type == PRIM_TEXT)\n                    t[1] *= swsh;\n                else if (type == PRIM_TEXTNATIVE)\n                    t[2] *= swsh;\n            }\n        this.lowX = ox + this.lowX * sw;\n        this.lowY = oy + this.lowY * sh;\n        this.highX = ox + this.highX * sw;\n        this.highY = oy + this.highY * sh;\n    }\n    renderInto(parent) {\n        let canvas = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.newElement)(parent, 'canvas', { 'width': this.width, 'height': this.height });\n        this.renderCanvas(canvas);\n        return canvas;\n    }\n    renderCanvas(canvas, clearFirst) {\n        let ctx = canvas.getContext('2d');\n        if (clearFirst)\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n        let w = this.width, h = this.height;\n        this.density = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.pixelDensity)();\n        canvas.style.width = w + 'px';\n        canvas.style.height = h + 'px';\n        canvas.width = w * this.density;\n        canvas.height = h * this.density;\n        this.renderContext(ctx);\n    }\n    renderContext(ctx) {\n        ctx.save();\n        ctx.scale(this.density, this.density);\n        this.typeObj = [];\n        for (let n = 0; n < this.types.length; n++) {\n            let t = this.types[n];\n            if (t[0] == PRIM_LINE)\n                this.typeObj[n] = this.setupTypeLine(t);\n            else if (t[0] == PRIM_RECT)\n                this.typeObj[n] = this.setupTypeRect(t);\n            else if (t[0] == PRIM_OVAL)\n                this.typeObj[n] = this.setupTypeOval(t);\n            else if (t[0] == PRIM_PATH)\n                this.typeObj[n] = this.setupTypePath(t);\n            else if (t[0] == PRIM_TEXT)\n                this.typeObj[n] = this.setupTypeText(t);\n            else if (t[0] == PRIM_TEXTNATIVE)\n                this.typeObj[n] = this.setupTypeTextNative(t);\n        }\n        for (let n = 0; n < this.prims.length; n++) {\n            let p = this.prims[n];\n            if (p[0] == PRIM_LINE)\n                this.renderLine(ctx, p);\n            else if (p[0] == PRIM_RECT)\n                this.renderRect(ctx, p);\n            else if (p[0] == PRIM_OVAL)\n                this.renderOval(ctx, p);\n            else if (p[0] == PRIM_PATH)\n                this.renderPath(ctx, p);\n            else if (p[0] == PRIM_TEXT)\n                this.renderText(ctx, p);\n            else if (p[0] == PRIM_TEXTNATIVE)\n                this.renderTextNative(ctx, p);\n        }\n        ctx.restore();\n    }\n    createSVG(prettyPrint = false, withXlink = false) {\n        let xml = _util_XML__WEBPACK_IMPORTED_MODULE_3__.XML.parseXML('<svg/>');\n        let svg = xml.documentElement;\n        svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n        if (withXlink)\n            svg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');\n        svg.setAttribute('width', this.width.toString());\n        svg.setAttribute('height', this.height.toString());\n        svg.setAttribute('viewBox', `0 0 ${this.width} ${this.height}`);\n        this.renderSVG(svg, withXlink);\n        return prettyPrint ? _util_XML__WEBPACK_IMPORTED_MODULE_3__.XML.toPrettyString(xml) : _util_XML__WEBPACK_IMPORTED_MODULE_3__.XML.toString(xml);\n    }\n    renderSVG(svg, withXlink = false) {\n        this.typeObj = [];\n        const font = _FontData__WEBPACK_IMPORTED_MODULE_4__.FontData.main;\n        let defs = _util_XML__WEBPACK_IMPORTED_MODULE_3__.XML.appendElement(svg, 'defs');\n        if (this.charMissing) {\n            let path = _util_XML__WEBPACK_IMPORTED_MODULE_3__.XML.appendElement(defs, 'path');\n            path.setAttribute('id', 'missing');\n            path.setAttribute('d', font.MISSING_DATA);\n            path.setAttribute('edge', 'none');\n        }\n        for (let n = 0; n < font.UNICODE.length; n++)\n            if (this.charMask[n]) {\n                let path = _util_XML__WEBPACK_IMPORTED_MODULE_3__.XML.appendElement(defs, 'path');\n                path.setAttribute('id', 'char' + n);\n                path.setAttribute('d', font.GLYPH_DATA[n]);\n                path.setAttribute('edge', 'none');\n            }\n        for (let n = 0; n < this.types.length; n++) {\n            let t = this.types[n];\n            if (t[0] == PRIM_LINE)\n                this.typeObj[n] = this.setupTypeLine(t);\n            else if (t[0] == PRIM_RECT)\n                this.typeObj[n] = this.setupTypeRect(t);\n            else if (t[0] == PRIM_OVAL)\n                this.typeObj[n] = this.setupTypeOval(t);\n            else if (t[0] == PRIM_PATH)\n                this.typeObj[n] = this.setupTypePath(t);\n            else if (t[0] == PRIM_TEXT)\n                this.typeObj[n] = this.setupTypeText(t);\n            else if (t[0] == PRIM_TEXTNATIVE)\n                this.typeObj[n] = this.setupTypeTextNative(t);\n        }\n        for (let n = 0; n < this.prims.length;) {\n            let p = this.prims[n], num = 1;\n            if (p[0] != PRIM_PATH && p[0] != PRIM_TEXT && p[0] != PRIM_TEXTNATIVE) {\n                for (; n + num < this.prims.length; num++)\n                    if (this.prims[n + num][0] != p[0] || this.prims[n + num][1] != p[1])\n                        break;\n            }\n            if (p[0] == PRIM_LINE) {\n                if (num == 1)\n                    this.svgLine1(svg, p);\n                else\n                    this.svgLineN(svg, p, n, num);\n            }\n            else if (p[0] == PRIM_RECT) {\n                if (num == 1)\n                    this.svgRect1(svg, p);\n                else\n                    this.svgRectN(svg, p, n, num);\n            }\n            else if (p[0] == PRIM_OVAL) {\n                if (num == 1)\n                    this.svgOval1(svg, p);\n                else\n                    this.svgOvalN(svg, p, n, num);\n            }\n            else if (p[0] == PRIM_PATH)\n                this.svgPath(svg, p);\n            else if (p[0] == PRIM_TEXT)\n                this.svgText(svg, p, withXlink);\n            else if (p[0] == PRIM_TEXTNATIVE)\n                this.svgTextNative(svg, p);\n            n += num;\n        }\n    }\n    spool(into) {\n        for (let p of this.prims) {\n            if (p[0] == PRIM_LINE) {\n                let [_, typeidx, x1, y1, x2, y2] = p;\n                let [, thickness, colour] = this.types[typeidx];\n                into.drawLine(x1, y1, x2, y2, colour, thickness);\n            }\n            else if (p[0] == PRIM_RECT) {\n                let [_, typeidx, x, y, w, h] = p;\n                let [, edgeCol, fillCol, thickness] = this.types[typeidx];\n                into.drawRect(x, y, w, h, edgeCol, thickness, fillCol);\n            }\n            else if (p[0] == PRIM_OVAL) {\n                let [_, typeidx, x, y, w, h] = p;\n                let [, edgeCol, fillCol, thickness] = this.types[typeidx];\n                into.drawOval(x, y, w, h, edgeCol, thickness, fillCol);\n            }\n            else if (p[0] == PRIM_PATH) {\n                let [_, typeidx, numPoints, xpoints, ypoints, ctrlFlags, isClosed] = p;\n                let [, edgeCol, fillCol, thickness, hardEdge] = this.types[typeidx];\n                into.drawPath(xpoints, ypoints, ctrlFlags, isClosed, edgeCol, thickness, fillCol, hardEdge);\n            }\n            else if (p[0] == PRIM_TEXT) {\n                let [_, typeidx, x, y, txt, direction] = p;\n                let [, size, colour] = this.types[typeidx];\n                into.drawText(x, y, txt, size, colour, null, direction);\n            }\n            else if (p[0] == PRIM_TEXTNATIVE) {\n                let [_, typeidx, x, y, txt] = p;\n                let [, fontFamily, fontSize, colour] = this.types[typeidx];\n                into.drawTextNative(x, y, txt, fontFamily, fontSize, colour);\n            }\n        }\n    }\n    setupTypeLine(t) {\n        let thickness = t[1] * this.scale;\n        let colour = t[2];\n        return { 'thickness': thickness, 'colour': colour };\n    }\n    setupTypeRect(t) {\n        let edgeCol = t[1];\n        let fillCol = t[2];\n        let thickness = t[3] * this.scale;\n        return { 'edgeCol': edgeCol, 'fillCol': fillCol, 'thickness': thickness };\n    }\n    setupTypeOval(t) {\n        let edgeCol = t[1];\n        let fillCol = t[2];\n        let thickness = t[3] * this.scale;\n        return { 'edgeCol': edgeCol, 'fillCol': fillCol, 'thickness': thickness };\n    }\n    setupTypePath(t) {\n        let edgeCol = t[1];\n        let fillCol = t[2];\n        let thickness = t[3] * this.scale;\n        let hardEdge = t[4];\n        return { 'edgeCol': edgeCol, 'fillCol': fillCol, 'thickness': thickness, 'hardEdge': hardEdge };\n    }\n    setupTypeText(t) {\n        let sz = t[1] * this.scale;\n        let colour = t[2];\n        return { 'colour': colour, 'size': sz };\n    }\n    setupTypeTextNative(t) {\n        let family = t[1];\n        let sz = t[2] * this.scale;\n        let colour = t[3];\n        let opt = t[4];\n        return { 'colour': colour, 'family': family, 'size': sz, 'opt': opt };\n    }\n    renderLine(ctx, p) {\n        let type = this.typeObj[p[1]];\n        let x1 = p[2], y1 = p[3];\n        let x2 = p[4], y2 = p[5];\n        let colour = type.colour;\n        x1 = this.offsetX + this.scale * x1;\n        y1 = this.offsetY + this.scale * y1;\n        x2 = this.offsetX + this.scale * x2;\n        y2 = this.offsetY + this.scale * y2;\n        if (colour != null) {\n            ctx.beginPath();\n            ctx.moveTo(x1, y1);\n            ctx.lineTo(x2, y2);\n            ctx.strokeStyle = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.colourCanvas)(colour);\n            ctx.lineWidth = type.thickness;\n            ctx.lineCap = 'round';\n            ctx.stroke();\n        }\n    }\n    renderRect(ctx, p) {\n        let type = this.typeObj[p[1]];\n        let x = p[2], y = p[3];\n        let w = p[4], h = p[5];\n        let edgeCol = type.edgeCol, fillCol = type.fillCol;\n        x = this.offsetX + this.scale * x;\n        y = this.offsetY + this.scale * y;\n        w *= this.scale;\n        h *= this.scale;\n        if (fillCol != MetaVector.NOCOLOUR) {\n            ctx.fillStyle = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.colourCanvas)(fillCol);\n            ctx.fillRect(x, y, w, h);\n        }\n        if (edgeCol != MetaVector.NOCOLOUR) {\n            ctx.strokeStyle = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.colourCanvas)(edgeCol);\n            ctx.lineWidth = type.thickness;\n            ctx.lineCap = 'square';\n            ctx.strokeRect(x, y, w, h);\n        }\n    }\n    renderOval(ctx, p) {\n        let type = this.typeObj[p[1]];\n        let cx = p[2], cy = p[3];\n        let rw = p[4], rh = p[5];\n        let edgeCol = type.edgeCol, fillCol = type.fillCol;\n        cx = this.offsetX + this.scale * cx;\n        cy = this.offsetY + this.scale * cy;\n        rw *= this.scale;\n        rh *= this.scale;\n        if (fillCol != MetaVector.NOCOLOUR) {\n            ctx.fillStyle = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.colourCanvas)(fillCol);\n            ctx.beginPath();\n            ctx.ellipse(cx, cy, rw, rh, 0, 0, 2 * Math.PI, true);\n            ctx.fill();\n        }\n        if (edgeCol != MetaVector.NOCOLOUR) {\n            ctx.strokeStyle = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.colourCanvas)(edgeCol);\n            ctx.lineWidth = type.thickness;\n            ctx.beginPath();\n            ctx.ellipse(cx, cy, rw, rh, 0, 0, 2 * Math.PI, true);\n            ctx.stroke();\n        }\n    }\n    renderPath(ctx, p) {\n        let type = this.typeObj[p[1]];\n        let npts = p[2];\n        if (npts == 0)\n            return;\n        let x = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.duplicate(p[3]), y = _util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.duplicate(p[4]);\n        let ctrl = p[5];\n        let isClosed = p[6];\n        let edgeCol = type.edgeCol, fillCol = type.fillCol;\n        for (let n = 0; n < npts; n++) {\n            x[n] = this.offsetX + this.scale * x[n];\n            y[n] = this.offsetY + this.scale * y[n];\n        }\n        for (let layer = 1; layer <= 2; layer++) {\n            if (layer == 1 && fillCol == MetaVector.NOCOLOUR)\n                continue;\n            if (layer == 2 && edgeCol == MetaVector.NOCOLOUR)\n                continue;\n            ctx.beginPath();\n            ctx.moveTo(x[0], y[0]);\n            for (let i = 1; i < npts; i++) {\n                if (!ctrl || !ctrl[i]) {\n                    ctx.lineTo(x[i], y[i]);\n                }\n                else if (i < npts - 1 && !ctrl[i + 1]) {\n                    ctx.quadraticCurveTo(x[i], y[i], x[i + 1], y[i + 1]);\n                    i++;\n                }\n                else if (i < npts - 1 && !ctrl[i + 2]) {\n                    ctx.bezierCurveTo(x[i], y[i], x[i + 1], y[i + 1], x[i + 2], y[i + 2]);\n                    i += 2;\n                }\n            }\n            if (isClosed)\n                ctx.closePath();\n            if (layer == 1) {\n                ctx.fillStyle = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.colourCanvas)(type.fillCol);\n                ctx.fill();\n            }\n            else {\n                ctx.strokeStyle = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.colourCanvas)(type.edgeCol);\n                ctx.lineWidth = type.thickness;\n                ctx.lineCap = type.hardEdge ? 'square' : 'round';\n                ctx.lineJoin = type.hardEdge ? 'miter' : 'round';\n                ctx.stroke();\n            }\n        }\n    }\n    renderText(ctx, p) {\n        let type = this.typeObj[p[1]];\n        let x = p[2], y = p[3];\n        let txt = p[4];\n        let sz = type.size;\n        let fill = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.colourCanvas)(type.colour);\n        x = this.offsetX + this.scale * x;\n        y = this.offsetY + this.scale * y;\n        let font = _FontData__WEBPACK_IMPORTED_MODULE_4__.FontData.main;\n        let scale = sz / font.UNITS_PER_EM;\n        let dx = 0;\n        for (let n = 0; n < txt.length; n++) {\n            let ch = txt.charAt(n);\n            let i = font.getIndex(ch);\n            let path = null;\n            if (i < 0) {\n                dx += font.MISSING_HORZ;\n                path = font.getMissingPath();\n            }\n            else\n                path = font.getGlyphPath(i);\n            if (path) {\n                ctx.save();\n                ctx.translate(x + dx * scale, y);\n                ctx.scale(scale, -scale);\n                ctx.fillStyle = fill;\n                ctx.fill(path);\n                ctx.restore();\n            }\n            dx += font.HORIZ_ADV_X[i];\n            if (n < txt.length - 1)\n                dx += font.getKerning(ch, txt.charAt(n + 1));\n        }\n    }\n    renderTextNative(ctx, p) {\n        let type = this.typeObj[p[1]];\n        let x = p[2], y = p[3];\n        let txt = p[4];\n        let family = type.family, sz = type.size, opt = type.opt;\n        let fill = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.colourCanvas)(type.colour);\n        x = this.offsetX + this.scale * x;\n        y = this.offsetY + this.scale * y;\n        ctx.save();\n        let pfx = '';\n        if (opt.bold)\n            pfx += 'bold ';\n        if (opt.italic)\n            pfx += 'italic ';\n        ctx.font = pfx + sz + 'px ' + family;\n        ctx.fillStyle = fill;\n        ctx.fillText(txt, x, y);\n        ctx.restore();\n    }\n    svgLine1(svg, p) {\n        let type = this.typeObj[p[1]];\n        let x1 = p[2], y1 = p[3];\n        let x2 = p[4], y2 = p[5];\n        x1 = this.offsetX + this.scale * x1;\n        y1 = this.offsetY + this.scale * y1;\n        x2 = this.offsetX + this.scale * x2;\n        y2 = this.offsetY + this.scale * y2;\n        if (type.colour != MetaVector.NOCOLOUR) {\n            let line = _util_XML__WEBPACK_IMPORTED_MODULE_3__.XML.appendElement(svg, 'line');\n            line.setAttribute('x1', x1.toString());\n            line.setAttribute('y1', y1.toString());\n            line.setAttribute('x2', x2.toString());\n            line.setAttribute('y2', y2.toString());\n            this.defineSVGStroke(line, type.colour);\n            line.setAttribute('stroke-width', type.thickness.toString());\n            line.setAttribute('stroke-linecap', 'round');\n        }\n    }\n    svgLineN(svg, p, pos, sz) {\n        let type = this.typeObj[p[1]];\n        if (type.colour == MetaVector.NOCOLOUR)\n            return;\n        let g = _util_XML__WEBPACK_IMPORTED_MODULE_3__.XML.appendElement(svg, 'g');\n        this.defineSVGStroke(g, type.colour);\n        g.setAttribute('stroke-width', type.thickness.toString());\n        g.setAttribute('stroke-linecap', 'round');\n        for (let n = 0; n < sz; n++) {\n            let p = this.prims[pos + n];\n            let x1 = p[2], y1 = p[3];\n            let x2 = p[4], y2 = p[5];\n            x1 = this.offsetX + this.scale * x1;\n            y1 = this.offsetY + this.scale * y1;\n            x2 = this.offsetX + this.scale * x2;\n            y2 = this.offsetY + this.scale * y2;\n            let line = _util_XML__WEBPACK_IMPORTED_MODULE_3__.XML.appendElement(g, 'line');\n            line.setAttribute('x1', x1.toString());\n            line.setAttribute('y1', y1.toString());\n            line.setAttribute('x2', x2.toString());\n            line.setAttribute('y2', y2.toString());\n        }\n    }\n    svgRect1(svg, p) {\n        let type = this.typeObj[p[1]];\n        let x = p[2], y = p[3];\n        let w = p[4], h = p[5];\n        x = this.offsetX + this.scale * x;\n        y = this.offsetY + this.scale * y;\n        w *= this.scale;\n        h *= this.scale;\n        let rect = _util_XML__WEBPACK_IMPORTED_MODULE_3__.XML.appendElement(svg, 'rect');\n        rect.setAttribute('x', x.toString());\n        rect.setAttribute('y', y.toString());\n        rect.setAttribute('width', w.toString());\n        rect.setAttribute('height', h.toString());\n        this.defineSVGStroke(rect, type.edgeCol);\n        if (type.edgeCol != MetaVector.NOCOLOUR) {\n            rect.setAttribute('stroke-width', type.thickness.toString());\n            rect.setAttribute('stroke-linecap', 'square');\n        }\n        this.defineSVGFill(rect, type.fillCol);\n    }\n    svgRectN(svg, p, pos, sz) {\n        let type = this.typeObj[p[1]];\n        let g = _util_XML__WEBPACK_IMPORTED_MODULE_3__.XML.appendElement(svg, 'g');\n        this.defineSVGStroke(g, type.edgeCol);\n        if (type.edgeCol != MetaVector.NOCOLOUR) {\n            g.setAttribute('stroke-width', type.thickness.toString());\n            g.setAttribute('stroke-linecap', 'square');\n        }\n        this.defineSVGFill(g, type.fillCol);\n        for (let n = 0; n < sz; n++) {\n            let p = this.prims[pos + n];\n            let x = p[2], y = p[3];\n            let w = p[4], h = p[5];\n            x = this.offsetX + this.scale * x;\n            y = this.offsetY + this.scale * y;\n            w *= this.scale;\n            h *= this.scale;\n            let rect = _util_XML__WEBPACK_IMPORTED_MODULE_3__.XML.appendElement(g, 'rect');\n            rect.setAttribute('x', x.toString());\n            rect.setAttribute('y', y.toString());\n            rect.setAttribute('width', w.toString());\n            rect.setAttribute('height', h.toString());\n        }\n    }\n    svgOval1(svg, p) {\n        let type = this.typeObj[p[1]];\n        let cx = p[2], cy = p[3];\n        let rw = p[4], rh = p[5];\n        cx = this.offsetX + this.scale * cx;\n        cy = this.offsetY + this.scale * cy;\n        rw *= this.scale;\n        rh *= this.scale;\n        let oval = _util_XML__WEBPACK_IMPORTED_MODULE_3__.XML.appendElement(svg, 'ellipse');\n        oval.setAttribute('cx', cx.toString());\n        oval.setAttribute('cy', cy.toString());\n        oval.setAttribute('rx', rw.toString());\n        oval.setAttribute('ry', rh.toString());\n        this.defineSVGStroke(oval, type.edgeCol);\n        if (type.edgeCol != MetaVector.NOCOLOUR) {\n            oval.setAttribute('stroke-width', type.thickness.toString());\n        }\n        this.defineSVGFill(oval, type.fillCol);\n    }\n    svgOvalN(svg, p, pos, sz) {\n        let type = this.typeObj[p[1]];\n        let g = _util_XML__WEBPACK_IMPORTED_MODULE_3__.XML.appendElement(svg, 'g');\n        this.defineSVGStroke(g, type.edgeCol);\n        if (type.edgeCol != MetaVector.NOCOLOUR) {\n            g.setAttribute('stroke-width', type.thickness.toString());\n        }\n        this.defineSVGFill(g, type.fillCol);\n        for (let n = 0; n < sz; n++) {\n            let p = this.prims[pos + n];\n            let cx = p[2], cy = p[3];\n            let rw = p[4], rh = p[5];\n            cx = this.offsetX + this.scale * cx;\n            cy = this.offsetY + this.scale * cy;\n            rw *= this.scale;\n            rh *= this.scale;\n            let oval = _util_XML__WEBPACK_IMPORTED_MODULE_3__.XML.appendElement(g, 'ellipse');\n            oval.setAttribute('cx', cx.toString());\n            oval.setAttribute('cy', cy.toString());\n            oval.setAttribute('rx', rw.toString());\n            oval.setAttribute('ry', rh.toString());\n        }\n    }\n    svgPath(svg, p) {\n        let type = this.typeObj[p[1]];\n        let npts = p[2];\n        if (npts == 0)\n            return;\n        let x = p[3].slice(0), y = p[4].slice(0);\n        let ctrl = p[5];\n        let isClosed = p[6];\n        for (let n = 0; n < npts; n++) {\n            x[n] = this.offsetX + this.scale * x[n];\n            y[n] = this.offsetY + this.scale * y[n];\n        }\n        let shape = 'M ' + x[0] + ' ' + y[0];\n        let n = 1;\n        while (n < npts) {\n            if (!ctrl || !ctrl[n]) {\n                shape += ' L ' + x[n] + ' ' + y[n];\n                n++;\n            }\n            else if (ctrl[n] && n < npts - 1 && !ctrl[n + 1]) {\n                shape += ' Q ' + x[n] + ' ' + y[n] + ' ' + x[n + 1] + ' ' + y[n + 1];\n                n += 2;\n            }\n            else if (ctrl[n] && n < npts - 2 && ctrl[n + 1] && !ctrl[n + 2]) {\n                shape += ' C ' + x[n] + ' ' + y[n] + ' ' + x[n + 1] + ' ' + y[n + 1] + ' ' + x[n + 2] + ' ' + y[n + 2];\n                n += 3;\n            }\n            else\n                n++;\n        }\n        if (isClosed)\n            shape += ' Z';\n        let path = _util_XML__WEBPACK_IMPORTED_MODULE_3__.XML.appendElement(svg, 'path');\n        path.setAttribute('d', shape);\n        this.defineSVGStroke(path, type.edgeCol);\n        if (type.edgeCol != MetaVector.NOCOLOUR) {\n            path.setAttribute('stroke-width', type.thickness.toString());\n            path.setAttribute('stroke-linejoin', type.hardEdge ? 'miter' : 'round');\n            path.setAttribute('stroke-linecap', type.hardEdge ? 'square' : 'round');\n        }\n        this.defineSVGFill(path, type.fillCol);\n    }\n    svgText(svg, p, withXlink = true) {\n        let type = this.typeObj[p[1]];\n        let x = p[2], y = p[3];\n        let txt = p[4];\n        let direction = p[5];\n        let sz = type.size;\n        x = this.offsetX + this.scale * x;\n        y = this.offsetY + this.scale * y;\n        let font = _FontData__WEBPACK_IMPORTED_MODULE_4__.FontData.main;\n        let scale = sz / font.UNITS_PER_EM;\n        let parent = svg;\n        if (direction != 0) {\n            parent = _util_XML__WEBPACK_IMPORTED_MODULE_3__.XML.appendElement(parent, 'g');\n            parent.setAttribute('transform', `rotate(${direction},${x},${y})`);\n        }\n        let gdelta = _util_XML__WEBPACK_IMPORTED_MODULE_3__.XML.appendElement(parent, 'g');\n        gdelta.setAttribute('transform', 'translate(' + x + ',' + y + ')');\n        this.defineSVGFill(gdelta, type.colour);\n        let gscale = _util_XML__WEBPACK_IMPORTED_MODULE_3__.XML.appendElement(gdelta, 'g');\n        gscale.setAttribute('transform', 'scale(' + scale + ',' + (-scale) + ')');\n        let dx = 0;\n        for (let n = 0; n < txt.length; n++) {\n            let ch = txt.charAt(n);\n            let i = font.getIndex(ch);\n            let use = _util_XML__WEBPACK_IMPORTED_MODULE_3__.XML.appendElement(gscale, 'use');\n            let ref = i < 0 ? '#missing' : '#char' + i;\n            if (withXlink)\n                use.setAttribute('xlink:href', ref);\n            else\n                use.setAttribute('href', ref);\n            use.setAttribute('x', dx.toString());\n            if (i >= 0) {\n                dx += font.HORIZ_ADV_X[i];\n                if (n < txt.length - 1)\n                    dx += font.getKerning(ch, txt.charAt(n + 1));\n            }\n            else\n                dx += font.MISSING_HORZ;\n        }\n    }\n    svgTextNative(svg, p) {\n        let type = this.typeObj[p[1]];\n        let x = p[2], y = p[3];\n        let txt = p[4];\n        let family = type.family, sz = type.size, opt = type.opt;\n        x = this.offsetX + this.scale * x;\n        y = this.offsetY + this.scale * y;\n        let colour = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.colourCanvas)(type.colour);\n        let style = `fill: ${colour}; font-family: ${family}; font-size: ${sz};`;\n        if (opt.bold)\n            style += ' font-weight: bold;';\n        if (opt.italic)\n            style += ' font-style: italic;';\n        let node = _util_XML__WEBPACK_IMPORTED_MODULE_3__.XML.appendElement(svg, 'text');\n        node.setAttribute('xml:space', 'preserve');\n        node.setAttribute('x', x.toString());\n        node.setAttribute('y', y.toString());\n        node.setAttribute('style', style);\n        _util_XML__WEBPACK_IMPORTED_MODULE_3__.XML.setText(node, txt);\n    }\n    defineSVGStroke(obj, col) {\n        if (col == MetaVector.NOCOLOUR) {\n            obj.setAttribute('stroke-opacity', '0');\n            return;\n        }\n        obj.setAttribute('stroke', (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.colourCode)(col));\n        let alpha = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.colourAlpha)(col);\n        if (alpha != 1)\n            obj.setAttribute('stroke-opacity', alpha.toString());\n    }\n    defineSVGFill(obj, col) {\n        if (col == MetaVector.NOCOLOUR) {\n            obj.setAttribute('fill-opacity', '0');\n            return;\n        }\n        obj.setAttribute('fill', (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.colourCode)(col));\n        let alpha = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.colourAlpha)(col);\n        if (alpha != 1)\n            obj.setAttribute('fill-opacity', alpha.toString());\n    }\n    findOrCreateType(typeDef) {\n        for (let i = 0; i < this.types.length; i++) {\n            if (this.types[i].length != typeDef.length)\n                continue;\n            let match = true;\n            for (let j = 0; j < typeDef.length; j++)\n                if (typeDef[j] != this.types[i][j]) {\n                    match = false;\n                    break;\n                }\n            if (match)\n                return i;\n        }\n        this.types.push(typeDef);\n        return this.types.length - 1;\n    }\n    updateBounds(x, y) {\n        if (this.lowX == null) {\n            this.lowX = x;\n            this.lowY = y;\n            this.highX = x;\n            this.highY = y;\n            return;\n        }\n        this.lowX = Math.min(this.lowX, x);\n        this.lowY = Math.min(this.lowY, y);\n        this.highX = Math.max(this.highX, x);\n        this.highY = Math.max(this.highY, y);\n    }\n}\nMetaVector.NOCOLOUR = -1;\n\n\n//# sourceURL=webpack://WebMolKit/./src/gfx/MetaVector.ts?");

/***/ }),

/***/ "./src/gfx/Rendering.ts":
/*!******************************!*\
  !*** ./src/gfx/Rendering.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RenderEffects\": () => (/* binding */ RenderEffects),\n/* harmony export */   \"RenderPolicy\": () => (/* binding */ RenderPolicy)\n/* harmony export */ });\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n\nclass RenderPolicy {\n    constructor(data) {\n        if (!data) {\n            data =\n                {\n                    'name': 'default',\n                    'pointScale': 20,\n                    'resolutionDPI': 100,\n                    'fontSize': 0.65,\n                    'lineSize': 0.075,\n                    'bondSep': 0.2,\n                    'defaultPadding': 0.2,\n                    'foreground': 0x000000,\n                    'background': 0xFFFFFF,\n                    'atomCols': new Array(112)\n                };\n            for (let n = 0; n <= 111; n++)\n                data.atomCols[n] = 0x000000;\n            this.data = data;\n        }\n        else {\n            this.data = (0,_util_util__WEBPACK_IMPORTED_MODULE_0__.clone)(data);\n        }\n    }\n    static defaultBlackOnWhite(pixPerAng) {\n        let policy = new RenderPolicy();\n        if (pixPerAng)\n            policy.data.pointScale = pixPerAng;\n        return policy;\n    }\n    static defaultWhiteOnBlack(pixPerAng) {\n        let policy = new RenderPolicy();\n        if (pixPerAng)\n            policy.data.pointScale = pixPerAng;\n        policy.data.foreground = 0xFFFFFF;\n        policy.data.background = 0x000000;\n        for (let n = 0; n <= 111; n++)\n            policy.data.atomCols[n] = 0xFFFFFF;\n        return policy;\n    }\n    static defaultColourOnWhite(pixPerAng) {\n        let policy = RenderPolicy.defaultBlackOnWhite(pixPerAng);\n        policy.data.atomCols[0] = 0x404040;\n        policy.data.atomCols[1] = 0x808080;\n        policy.data.atomCols[6] = 0x000000;\n        policy.data.atomCols[7] = 0x0000FF;\n        policy.data.atomCols[8] = 0xFF0000;\n        policy.data.atomCols[9] = 0xFF8080;\n        policy.data.atomCols[15] = 0xFF8000;\n        policy.data.atomCols[16] = 0x808000;\n        policy.data.atomCols[17] = 0x00C000;\n        policy.data.atomCols[35] = 0xC04000;\n        return policy;\n    }\n    static defaultColourOnBlack(pixPerAng) {\n        let policy = RenderPolicy.defaultWhiteOnBlack(pixPerAng);\n        policy.data.atomCols[0] = 0xA0A0A0;\n        policy.data.atomCols[1] = 0x808080;\n        policy.data.atomCols[6] = 0xFFFFFF;\n        policy.data.atomCols[7] = 0x4040FF;\n        policy.data.atomCols[8] = 0xFF4040;\n        policy.data.atomCols[9] = 0xFF8080;\n        policy.data.atomCols[15] = 0xFF8000;\n        policy.data.atomCols[16] = 0xFFFF00;\n        policy.data.atomCols[17] = 0x40FF40;\n        policy.data.atomCols[35] = 0xFF8040;\n        return policy;\n    }\n    static defaultPrintedPublication() {\n        let policy = RenderPolicy.defaultBlackOnWhite(9.6);\n        policy.data.resolutionDPI = 600;\n        policy.data.fontSize = 0.80;\n        policy.data.bondSep = 0.27;\n        policy.data.lineSize = 0.0625;\n        return policy;\n    }\n}\nclass RenderEffects {\n    constructor() {\n        this.colAtom = {};\n        this.colBond = {};\n        this.dottedRectOutline = {};\n        this.dottedBondCross = {};\n        this.hideAtoms = new Set();\n        this.hideBonds = new Set();\n        this.atomFrameDotSz = [];\n        this.atomFrameCol = [];\n        this.atomCircleSz = [];\n        this.atomCircleCol = [];\n        this.atomDecoText = [];\n        this.atomDecoCol = [];\n        this.atomDecoSize = [];\n        this.bondDecoText = [];\n        this.bondDecoCol = [];\n        this.bondDecoSize = [];\n        this.overlapAtoms = [];\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/gfx/Rendering.ts?");

/***/ }),

/***/ "./src/sketcher/CommandBank.ts":
/*!*************************************!*\
  !*** ./src/sketcher/CommandBank.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CommandBank\": () => (/* binding */ CommandBank)\n/* harmony export */ });\n/* harmony import */ var _data_Molecule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/Molecule */ \"./src/data/Molecule.ts\");\n/* harmony import */ var _data_SketchUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/SketchUtil */ \"./src/data/SketchUtil.ts\");\n/* harmony import */ var _ui_ButtonBank__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ui/ButtonBank */ \"./src/ui/ButtonBank.ts\");\n/* harmony import */ var _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MoleculeActivity */ \"./src/sketcher/MoleculeActivity.ts\");\n\n\n\n\nconst ELEMENTS_NOBLE = [\n    'He', 'Ar', 'Kr', 'Xe', 'Rn'\n];\nconst ELEMENTS_S_BLOCK = [\n    'Li', 'Na', 'K', 'Rb', 'Cs', 'Fr', 'Sc',\n    'Be', 'Mg', 'Ca', 'Sr', 'Ba', 'Ra', 'Y'\n];\nconst ELEMENTS_P_BLOCK = [\n    'B', 'Al', 'Si', 'Ga', 'Ge', 'As', 'Se',\n    'In', 'Sn', 'Sb', 'Te', 'Tl', 'Pb', 'Bi', 'Po', 'At'\n];\nconst ELEMENTS_D_BLOCK = [\n    'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn',\n    'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd',\n    'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg'\n];\nconst ELEMENTS_F_BLOCK = [\n    'La', 'Ce', 'Pr', 'Nd', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy',\n    'Ho', 'Er', 'Tm', 'Yb', 'Lu', 'Ac', 'Th', 'Pa', 'U'\n];\nconst ELEMENTS_ABBREV = [\n    '*', 'A', 'X', 'Y', 'Z', 'Q', 'M', 'T', 'E', 'L', 'R',\n    'R0', 'R1', 'R2', 'R3', 'R4', 'R5', 'R6', 'R7', 'R8'\n];\nvar CommandType;\n(function (CommandType) {\n    CommandType[CommandType[\"Main\"] = 0] = \"Main\";\n    CommandType[CommandType[\"Atom\"] = 1] = \"Atom\";\n    CommandType[CommandType[\"Bond\"] = 2] = \"Bond\";\n    CommandType[CommandType[\"Select\"] = 3] = \"Select\";\n    CommandType[CommandType[\"Move\"] = 4] = \"Move\";\n    CommandType[CommandType[\"Abbrev\"] = 5] = \"Abbrev\";\n    CommandType[CommandType[\"SBlock\"] = 6] = \"SBlock\";\n    CommandType[CommandType[\"PBlock\"] = 7] = \"PBlock\";\n    CommandType[CommandType[\"DBlock\"] = 8] = \"DBlock\";\n    CommandType[CommandType[\"FBlock\"] = 9] = \"FBlock\";\n    CommandType[CommandType[\"Noble\"] = 10] = \"Noble\";\n})(CommandType || (CommandType = {}));\nconst COMMANDS_MAIN = [\n    { 'id': 'undo', 'imageFN': 'MainUndo', 'helpText': 'Undo last change.', 'mnemonic': 'CmdOrCtrl+Z' },\n    { 'id': 'redo', 'imageFN': 'MainRedo', 'helpText': 'Cancel last undo.', 'mnemonic': 'CmdOrCtrl+Shift+Z' },\n    { 'id': 'zoomin', 'imageFN': 'MainZoomIn', 'helpText': 'Zoom in.', 'mnemonic': '=' },\n    { 'id': 'zoomout', 'imageFN': 'MainZoomOut', 'helpText': 'Zoom out.', 'mnemonic': '-' },\n    { 'id': 'zoomfit', 'imageFN': 'MainZoomFit', 'helpText': 'Show whole diagram onscreen.', 'mnemonic': '' },\n    { 'id': 'selside', 'imageFN': 'MainSelSide', 'helpText': 'Select alternate side of current atom or bond.', 'mnemonic': 'E' },\n    { 'id': 'selall', 'imageFN': 'MainSelAll', 'helpText': 'Select all atoms.', 'mnemonic': 'Shift+A' },\n    { 'id': 'selnone', 'imageFN': 'MainSelNone', 'helpText': 'Clear selection.', 'mnemonic': 'Shift+Q' },\n    { 'id': 'delete', 'imageFN': 'MainDelete', 'helpText': 'Delete selected atoms and bonds.', 'mnemonic': 'D' },\n    { 'id': 'cut', 'imageFN': 'MainCut', 'helpText': 'Copy selection to clipboard, and remove.', 'mnemonic': 'CmdOrCtrl+X' },\n    { 'id': 'copy', 'imageFN': 'MainCopy', 'helpText': 'Copy selection to clipboard.', 'mnemonic': 'CmdOrCtrl+C' },\n    { 'id': 'paste', 'imageFN': 'MainPaste', 'helpText': 'Paste clipboard contents.' },\n    { 'id': 'atom', 'imageFN': 'MainAtom', 'helpText': 'Open the Atom submenu.', 'isSubMenu': true, 'mnemonic': 'A' },\n    { 'id': 'bond', 'imageFN': 'MainBond', 'helpText': 'Open the Bond submenu.', 'isSubMenu': true, 'mnemonic': 'B' },\n    { 'id': 'select', 'imageFN': 'MainSelect', 'helpText': 'Open the Selection submenu.', 'isSubMenu': true, 'mnemonic': 'S' },\n    { 'id': 'move', 'imageFN': 'MainMove', 'helpText': 'Open the Move submenu.', 'isSubMenu': true, 'mnemonic': 'M' },\n];\nconst COMMANDS_ATOM = [\n    { 'id': 'element:C', 'text': 'C', 'helpText': 'Change elements to Carbon.', 'mnemonic': 'Shift+C' },\n    { 'id': 'element:N', 'text': 'N', 'helpText': 'Change elements to Nitrogen.', 'mnemonic': 'Shift+N' },\n    { 'id': 'element:O', 'text': 'O', 'helpText': 'Change elements to Oxygen.', 'mnemonic': 'Shift+O' },\n    { 'id': 'element:S', 'text': 'S', 'helpText': 'Change elements to Sulfur.', 'mnemonic': 'Shift+S' },\n    { 'id': 'element:P', 'text': 'P', 'helpText': 'Change elements to Phosphorus.', 'mnemonic': 'Shift+P' },\n    { 'id': 'element:H', 'text': 'H', 'helpText': 'Change elements to Hydrogen.', 'mnemonic': 'Shift+H' },\n    { 'id': 'element:F', 'text': 'F', 'helpText': 'Change elements to Fluorine.', 'mnemonic': 'Shift+F' },\n    { 'id': 'element:Cl', 'text': 'Cl', 'helpText': 'Change elements to Chlorine.', 'mnemonic': 'Shift+L' },\n    { 'id': 'element:Br', 'text': 'Br', 'helpText': 'Change elements to Bromine.', 'mnemonic': 'Shift+B' },\n    { 'id': 'element:I', 'text': 'I', 'helpText': 'Change elements to Iodine.', 'mnemonic': 'Shift+I' },\n    { 'id': 'plus', 'imageFN': 'AtomPlus', 'helpText': 'Increase the atom charge.', 'mnemonic': 'Shift+=', 'key': '+' },\n    { 'id': 'minus', 'imageFN': 'AtomMinus', 'helpText': 'Decrease the atom charge.', 'mnemonic': 'Shift+-', 'key': '_' },\n    { 'id': 'abbrev', 'imageFN': 'AtomAbbrev', 'helpText': 'Open list of common labels.', 'isSubMenu': true, 'mnemonic': '' },\n    { 'id': 'sblock', 'imageFN': 'AtomSBlock', 'helpText': 'Open list of s-block elements.', 'isSubMenu': true, 'mnemonic': '' },\n    { 'id': 'pblock', 'imageFN': 'AtomPBlock', 'helpText': 'Open list of p-block elements.', 'isSubMenu': true, 'mnemonic': '' },\n    { 'id': 'dblock', 'imageFN': 'AtomDBlock', 'helpText': 'Open list of d-block elements.', 'isSubMenu': true, 'mnemonic': '' },\n    { 'id': 'fblock', 'imageFN': 'AtomFBlock', 'helpText': 'Open list of f-block elements.', 'isSubMenu': true, 'mnemonic': '' },\n    { 'id': 'noble', 'imageFN': 'AtomNoble', 'helpText': 'Open list of noble elements.', 'isSubMenu': true, 'mnemonic': '' },\n];\nconst COMMANDS_BOND = [\n    { 'id': 'one', 'imageFN': 'BondOne', 'helpText': 'Create or set bonds to single.', 'mnemonic': '1' },\n    { 'id': 'two', 'imageFN': 'BondTwo', 'helpText': 'Create or set bonds to double.', 'mnemonic': '2' },\n    { 'id': 'three', 'imageFN': 'BondThree', 'helpText': 'Create or set bonds to triple.', 'mnemonic': '3' },\n    { 'id': 'four', 'imageFN': 'BondFour', 'helpText': 'Create or set bonds to quadruple.', 'mnemonic': '' },\n    { 'id': 'zero', 'imageFN': 'BondZero', 'helpText': 'Create or set bonds to zero-order.', 'mnemonic': '0' },\n    { 'id': 'inclined', 'imageFN': 'BondUp', 'helpText': 'Create or set bonds to inclined.', 'mnemonic': '5' },\n    { 'id': 'declined', 'imageFN': 'BondDown', 'helpText': 'Create or set bonds to declined.', 'mnemonic': '6' },\n    { 'id': 'squig', 'imageFN': 'BondSquig', 'helpText': 'Create or set bonds to unknown stereochemistry.', 'mnemonic': '4' },\n    { 'id': 'bondQAny', 'imageFN': 'BondQAny', 'helpText': 'Query bond that matches anything.' },\n    { 'id': 'addtwo', 'imageFN': 'BondAddTwo', 'helpText': 'Add two new bonds to the subject atom.', 'mnemonic': 'Shift+D' },\n    { 'id': 'insert', 'imageFN': 'BondInsert', 'helpText': 'Insert a methylene into the subject bond.', 'mnemonic': '' },\n    { 'id': 'switch', 'imageFN': 'BondSwitch', 'helpText': 'Cycle through likely bond geometries.', 'mnemonic': '' },\n    { 'id': 'rotate', 'imageFN': 'BondRotate', 'helpText': 'Rotate bond to invert substituent orientation.', 'mnemonic': '' },\n    { 'id': 'linear', 'imageFN': 'BondLinear', 'helpText': 'Apply linear geometry.', 'mnemonic': 'Shift+V' },\n    { 'id': 'trigonal', 'imageFN': 'BondTrigonal', 'helpText': 'Apply trigonal geometry.', 'mnemonic': 'Shift+W' },\n    { 'id': 'tetra1', 'imageFN': 'BondTetra1', 'helpText': 'Apply tetrahedral geometry #1.', 'mnemonic': 'Shift+E' },\n    { 'id': 'tetra2', 'imageFN': 'BondTetra2', 'helpText': 'Apply tetrahedral geometry #2.', 'mnemonic': 'Shift+R' },\n    { 'id': 'sqplan', 'imageFN': 'BondSqPlan', 'helpText': 'Apply square planar geometry.', 'mnemonic': 'Shift+T' },\n    { 'id': 'octa1', 'imageFN': 'BondOcta1', 'helpText': 'Apply octahedral geometry #1.', 'mnemonic': 'Shift+Y' },\n    { 'id': 'octa2', 'imageFN': 'BondOcta2', 'helpText': 'Apply octahedral geometry #2.', 'mnemonic': 'Shift+U' },\n    { 'id': 'metalligate', 'imageFN': 'BondMetalLigate', 'helpText': 'Arrange ligands around metal centre.', 'mnemonic': '' },\n    { 'id': 'artifactpath', 'imageFN': 'BondArtifactPath', 'helpText': 'Add a path bond artifact.', 'mnemonic': '' },\n    { 'id': 'artifactring', 'imageFN': 'BondArtifactRing', 'helpText': 'Add a ring bond artifact.', 'mnemonic': '' },\n    { 'id': 'artifactarene', 'imageFN': 'BondArtifactArene', 'helpText': 'Add an arene bond artifact.', 'mnemonic': '' },\n    { 'id': 'artifactclear', 'imageFN': 'BondArtifactClear', 'helpText': 'Remove a bond artifact.', 'mnemonic': '' },\n    { 'id': 'polymer', 'imageFN': 'BondPolymer', 'helpText': 'Create a polymer block.', 'mnemonic': '' },\n];\nconst COMMANDS_SELECT = [\n    { 'id': 'selgrow', 'imageFN': 'SelectionGrow', 'helpText': 'Add adjacent atoms to selection.', 'mnemonic': '' },\n    { 'id': 'selshrink', 'imageFN': 'SelectionShrink', 'helpText': 'Unselect exterior atoms.', 'mnemonic': '' },\n    { 'id': 'selchain', 'imageFN': 'SelectionChain', 'helpText': 'Extend selection to non-ring atoms.', 'mnemonic': '' },\n    { 'id': 'smallring', 'imageFN': 'SelectionSmRing', 'helpText': 'Extend selection to small rings.', 'mnemonic': '' },\n    { 'id': 'ringblock', 'imageFN': 'SelectionRingBlk', 'helpText': 'Extend selection to ring blocks.', 'mnemonic': '' },\n    { 'id': 'curelement', 'imageFN': 'SelectionCurElement', 'helpText': 'Select all atoms of current element type.', 'mnemonic': '' },\n    { 'id': 'selprev', 'imageFN': 'MainSelPrev', 'helpText': 'Select previous connected component.', 'mnemonic': '[' },\n    { 'id': 'selnext', 'imageFN': 'MainSelNext', 'helpText': 'Select next connected component.', 'mnemonic': ']' },\n    { 'id': 'toggle', 'imageFN': 'SelectionToggle', 'helpText': 'Toggle selection of current.', 'mnemonic': ',' },\n    { 'id': 'uncurrent', 'imageFN': 'SelectionUncurrent', 'helpText': 'Undefine current object.', 'mnemonic': '.' },\n    { 'id': 'join', 'imageFN': 'MoveJoin', 'helpText': 'Overlapping atoms will be joined as one.', 'mnemonic': '' },\n    { 'id': 'new', 'imageFN': 'MainNew', 'helpText': 'Clear the molecular structure.', 'mnemonic': '' },\n    { 'id': 'inline', 'imageFN': 'AtomInline', 'helpText': 'Make selected atoms into an inline abbreviation.', 'mnemonic': '/' },\n    { 'id': 'formula', 'imageFN': 'AtomFormula', 'helpText': 'Make selected atoms into their molecule formula.', 'mnemonic': '\\\\' },\n    { 'id': 'expandabbrev', 'imageFN': 'AtomExpandAbbrev', 'helpText': 'Expand out the inline abbreviation.', 'mnemonic': 'Shift+/', 'key': '/' },\n    { 'id': 'clearabbrev', 'imageFN': 'AtomClearAbbrev', 'helpText': 'Remove inline abbreviation.', 'mnemonic': 'Shift+\\\\', 'key': '\\\\' },\n];\nconst COMMANDS_MOVE = [\n    { 'id': 'up', 'imageFN': 'MoveUp', 'helpText': 'Move subject atoms up slightly.', 'mnemonic': 'Shift+Up', 'key': \"ArrowUp\" },\n    { 'id': 'down', 'imageFN': 'MoveDown', 'helpText': 'Move subject atoms down slightly.', 'mnemonic': 'Shift+Down', 'key': \"ArrowDown\" },\n    { 'id': 'left', 'imageFN': 'MoveLeft', 'helpText': 'Move subject atoms slightly to the left.', 'mnemonic': 'Shift+Left', 'key': \"ArrowLeft\" },\n    { 'id': 'right', 'imageFN': 'MoveRight', 'helpText': 'Move subject atoms slightly to the right.', 'mnemonic': 'Shift+Right', 'key': \"ArrowRight\" },\n    { 'id': 'uplots', 'imageFN': 'MoveUpLots', 'helpText': 'Move subject atoms up somewhat.', 'mnemonic': '' },\n    { 'id': 'downlots', 'imageFN': 'MoveDownLots', 'helpText': 'Move subject atoms down somewhat.', 'mnemonic': '' },\n    { 'id': 'leftlots', 'imageFN': 'MoveLeftLots', 'helpText': 'Move subject atoms somewhat to the left.', 'mnemonic': '' },\n    { 'id': 'rightlots', 'imageFN': 'MoveRightLots', 'helpText': 'Move subject atoms somewhat to the right.', 'mnemonic': '' },\n    { 'id': 'upfar', 'imageFN': 'MoveUpFar', 'helpText': 'Move subject atoms far up.', 'mnemonic': '' },\n    { 'id': 'downfar', 'imageFN': 'MoveDownFar', 'helpText': 'Move subject atoms far down.', 'mnemonic': '' },\n    { 'id': 'leftfar', 'imageFN': 'MoveLeftFar', 'helpText': 'Move subject atoms far to the left.', 'mnemonic': '' },\n    { 'id': 'rightfar', 'imageFN': 'MoveRightFar', 'helpText': 'Move subject atoms far to the right.', 'mnemonic': '' },\n    { 'id': 'rotp01', 'imageFN': 'MoveRotP01', 'helpText': 'Rotate 1\\u00B0 counter-clockwise.', 'mnemonic': '' },\n    { 'id': 'rotm01', 'imageFN': 'MoveRotM01', 'helpText': 'Rotate 1\\u00B0 clockwise.', 'mnemonic': '' },\n    { 'id': 'rotp05', 'imageFN': 'MoveRotP05', 'helpText': 'Rotate 5\\u00B0 counter-clockwise.', 'mnemonic': '' },\n    { 'id': 'rotm05', 'imageFN': 'MoveRotM05', 'helpText': 'Rotate 5\\u00B0 clockwise.', 'mnemonic': '' },\n    { 'id': 'rotp15', 'imageFN': 'MoveRotP15', 'helpText': 'Rotate 15\\u00B0 counter-clockwise.', 'mnemonic': '' },\n    { 'id': 'rotm15', 'imageFN': 'MoveRotM15', 'helpText': 'Rotate 15\\u00B0 clockwise.', 'mnemonic': '' },\n    { 'id': 'rotp30', 'imageFN': 'MoveRotP30', 'helpText': 'Rotate 30\\u00B0 counter-clockwise.', 'mnemonic': 'Shift+[', 'key': '{' },\n    { 'id': 'rotm30', 'imageFN': 'MoveRotM30', 'helpText': 'Rotate 30\\u00B0 clockwise.', 'mnemonic': 'Shift+]', 'key': '}' },\n    { 'id': 'hflip', 'imageFN': 'MoveHFlip', 'helpText': 'Flip subject atoms horizontally.', 'mnemonic': 'Shift+,', 'key': ',' },\n    { 'id': 'vflip', 'imageFN': 'MoveVFlip', 'helpText': 'Flip subject atoms vertically.', 'mnemonic': 'Shift+.', 'key': '.' },\n    { 'id': 'shrink', 'imageFN': 'MoveShrink', 'helpText': 'Decrease subject bond distances.', 'mnemonic': 'Shift+Z' },\n    { 'id': 'grow', 'imageFN': 'MoveGrow', 'helpText': 'Increase subject bond distances.', 'mnemonic': 'Shift+X' },\n];\nclass CommandBank extends _ui_ButtonBank__WEBPACK_IMPORTED_MODULE_2__.ButtonBank {\n    constructor(owner, cmdType = CommandType.Main) {\n        super();\n        this.owner = owner;\n        this.cmdType = cmdType;\n    }\n    update() {\n        if (this.cmdType == CommandType.Main)\n            for (let btn of COMMANDS_MAIN)\n                this.buttons.push(btn);\n        else if (this.cmdType == CommandType.Atom)\n            for (let btn of COMMANDS_ATOM)\n                this.buttons.push(btn);\n        else if (this.cmdType == CommandType.Bond)\n            for (let btn of COMMANDS_BOND)\n                this.buttons.push(btn);\n        else if (this.cmdType == CommandType.Select)\n            for (let btn of COMMANDS_SELECT)\n                this.buttons.push(btn);\n        else if (this.cmdType == CommandType.Move)\n            for (let btn of COMMANDS_MOVE)\n                this.buttons.push(btn);\n        else if (this.cmdType == CommandType.Abbrev)\n            this.populateElements(ELEMENTS_ABBREV);\n        else if (this.cmdType == CommandType.SBlock)\n            this.populateElements(ELEMENTS_S_BLOCK);\n        else if (this.cmdType == CommandType.PBlock)\n            this.populateElements(ELEMENTS_P_BLOCK);\n        else if (this.cmdType == CommandType.DBlock)\n            this.populateElements(ELEMENTS_D_BLOCK);\n        else if (this.cmdType == CommandType.FBlock)\n            this.populateElements(ELEMENTS_F_BLOCK);\n        else if (this.cmdType == CommandType.Noble)\n            this.populateElements(ELEMENTS_NOBLE);\n    }\n    populateElements(elements) {\n        for (let el of elements) {\n            this.buttons.push({ 'id': `element:${el}`, 'text': el, 'helpText': `Change elements to ${el}.` });\n        }\n    }\n    hitButton(id) {\n        let actv = 0, param = null;\n        if (id.startsWith('element:')) {\n            let el = id.substring(8);\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Element;\n            param = { 'element': el };\n        }\n        else if (id == 'delete')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Delete;\n        else if (id == 'undo') {\n            if (this.owner.canUndo())\n                this.owner.performUndo();\n            else\n                this.owner.showMessage('Nothing to undo.');\n        }\n        else if (id == 'redo') {\n            if (this.owner.canRedo())\n                this.owner.performRedo();\n            else\n                this.owner.showMessage('Nothing to redo.');\n        }\n        else if (id == 'cut')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Cut;\n        else if (id == 'copy')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Copy;\n        else if (id == 'paste')\n            this.owner.performPaste();\n        else if (id == 'new')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Clear;\n        else if (id == 'zoomfit')\n            this.owner.autoScale();\n        else if (id == 'zoomout')\n            this.owner.zoom(0.8);\n        else if (id == 'zoomin')\n            this.owner.zoom(1.25);\n        else if (id == 'selall')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.SelectAll;\n        else if (id == 'selnone')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.SelectNone;\n        else if (id == 'selprev')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.SelectPrevComp;\n        else if (id == 'selnext')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.SelectNextComp;\n        else if (id == 'selside')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.SelectSide;\n        else if (id == 'plus') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Charge;\n            param = { 'delta': 1 };\n        }\n        else if (id == 'minus') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Charge;\n            param = { 'delta': -1 };\n        }\n        else if (id == 'one') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondOrder;\n            param = { 'order': 1 };\n        }\n        else if (id == 'two') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondOrder;\n            param = { 'order': 2 };\n        }\n        else if (id == 'three') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondOrder;\n            param = { 'order': 3 };\n        }\n        else if (id == 'four') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondOrder;\n            param = { 'order': 4 };\n        }\n        else if (id == 'zero') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondOrder;\n            param = { 'order': 0 };\n        }\n        else if (id == 'inclined') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondType;\n            param = { 'type': _data_Molecule__WEBPACK_IMPORTED_MODULE_0__.Molecule.BONDTYPE_INCLINED };\n        }\n        else if (id == 'declined') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondType;\n            param = { 'type': _data_Molecule__WEBPACK_IMPORTED_MODULE_0__.Molecule.BONDTYPE_DECLINED };\n        }\n        else if (id == 'squig') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondType;\n            param = { 'type': _data_Molecule__WEBPACK_IMPORTED_MODULE_0__.Molecule.BONDTYPE_UNKNOWN };\n        }\n        else if (id == 'linear') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondGeom;\n            param = { 'geom': _data_SketchUtil__WEBPACK_IMPORTED_MODULE_1__.Geometry.Linear };\n        }\n        else if (id == 'trigonal') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondGeom;\n            param = { 'geom': _data_SketchUtil__WEBPACK_IMPORTED_MODULE_1__.Geometry.Trigonal };\n        }\n        else if (id == 'tetra1') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondGeom;\n            param = { 'geom': _data_SketchUtil__WEBPACK_IMPORTED_MODULE_1__.Geometry.Tetra1 };\n        }\n        else if (id == 'tetra2') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondGeom;\n            param = { 'geom': _data_SketchUtil__WEBPACK_IMPORTED_MODULE_1__.Geometry.Tetra2 };\n        }\n        else if (id == 'sqplan') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondGeom;\n            param = { 'geom': _data_SketchUtil__WEBPACK_IMPORTED_MODULE_1__.Geometry.SqPlan };\n        }\n        else if (id == 'octa1') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondGeom;\n            param = { 'geom': _data_SketchUtil__WEBPACK_IMPORTED_MODULE_1__.Geometry.Octa1 };\n        }\n        else if (id == 'octa2') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondGeom;\n            param = { 'geom': _data_SketchUtil__WEBPACK_IMPORTED_MODULE_1__.Geometry.Octa2 };\n        }\n        else if (id == 'switch')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondSwitch;\n        else if (id == 'rotate')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondRotate;\n        else if (id == 'connect')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Connect;\n        else if (id == 'disconnect')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Disconnect;\n        else if (id == 'metalligate')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.MetalLigate;\n        else if (id == 'artifactpath')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondArtifactPath;\n        else if (id == 'artifactring')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondArtifactRing;\n        else if (id == 'artifactarene')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondArtifactArene;\n        else if (id == 'artifactclear')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondArtifactClear;\n        else if (id == 'polymer')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.PolymerBlock;\n        else if (id == 'addtwo')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondAddTwo;\n        else if (id == 'insert')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondInsert;\n        else if (id == 'curelement')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.SelectCurElement;\n        else if (id == 'selgrow')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.SelectGrow;\n        else if (id == 'selshrink')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.SelectShrink;\n        else if (id == 'selprev')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.SelectPrevComp;\n        else if (id == 'selnext')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.SelectNextComp;\n        else if (id == 'selchain')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.SelectChain;\n        else if (id == 'smallring')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.SelectSmRing;\n        else if (id == 'ringblock')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.SelectRingBlk;\n        else if (id == 'toggle')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.SelectToggle;\n        else if (id == 'uncurrent')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.SelectUnCurrent;\n        else if (id == 'join')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Join;\n        else if (id == 'inline')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.AbbrevGroup;\n        else if (id == 'formula')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.AbbrevFormula;\n        else if (id == 'clearabbrev')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.AbbrevClear;\n        else if (id == 'expandabbrev')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.AbbrevExpand;\n        else if (id == 'up') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Nudge;\n            param = { 'dir': 'up' };\n        }\n        else if (id == 'down') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Nudge;\n            param = { 'dir': 'down' };\n        }\n        else if (id == 'left') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Nudge;\n            param = { 'dir': 'left' };\n        }\n        else if (id == 'right') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Nudge;\n            param = { 'dir': 'right' };\n        }\n        else if (id == 'uplots') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.NudgeLots;\n            param = { 'dir': 'up' };\n        }\n        else if (id == 'downlots') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.NudgeLots;\n            param = { 'dir': 'down' };\n        }\n        else if (id == 'leftlots') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.NudgeLots;\n            param = { 'dir': 'left' };\n        }\n        else if (id == 'rightlots') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.NudgeLots;\n            param = { 'dir': 'right' };\n        }\n        else if (id == 'upfar') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.NudgeFar;\n            param = { 'dir': 'up' };\n        }\n        else if (id == 'downfar') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.NudgeFar;\n            param = { 'dir': 'down' };\n        }\n        else if (id == 'leftfar') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.NudgeFar;\n            param = { 'dir': 'left' };\n        }\n        else if (id == 'rightfar') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.NudgeFar;\n            param = { 'dir': 'right' };\n        }\n        else if (id == 'rotp01') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Rotate;\n            param = { 'theta': 1 };\n        }\n        else if (id == 'rotm01') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Rotate;\n            param = { 'theta': -1 };\n        }\n        else if (id == 'rotp05') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Rotate;\n            param = { 'theta': 5 };\n        }\n        else if (id == 'rotm05') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Rotate;\n            param = { 'theta': -5 };\n        }\n        else if (id == 'rotp15') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Rotate;\n            param = { 'theta': 15 };\n        }\n        else if (id == 'rotm15') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Rotate;\n            param = { 'theta': -15 };\n        }\n        else if (id == 'rotp30') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Rotate;\n            param = { 'theta': 30 };\n        }\n        else if (id == 'rotm30') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Rotate;\n            param = { 'theta': -30 };\n        }\n        else if (id == 'hflip') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Flip;\n            param = { 'axis': 'hor' };\n        }\n        else if (id == 'vflip') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Flip;\n            param = { 'axis': 'ver' };\n        }\n        else if (id == 'shrink') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Scale;\n            param = { 'mag': 1 / 1.1 };\n        }\n        else if (id == 'grow') {\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Scale;\n            param = { 'mag': 1.1 };\n        }\n        else if (id == 'bondQAny')\n            actv = _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.QueryBondAny;\n        else if (id == 'atom')\n            this.buttonView.pushBank(new CommandBank(this.owner, CommandType.Atom));\n        else if (id == 'bond')\n            this.buttonView.pushBank(new CommandBank(this.owner, CommandType.Bond));\n        else if (id == 'select')\n            this.buttonView.pushBank(new CommandBank(this.owner, CommandType.Select));\n        else if (id == 'move')\n            this.buttonView.pushBank(new CommandBank(this.owner, CommandType.Move));\n        else if (id == 'abbrev')\n            this.buttonView.pushBank(new CommandBank(this.owner, CommandType.Abbrev));\n        else if (id == 'sblock')\n            this.buttonView.pushBank(new CommandBank(this.owner, CommandType.SBlock));\n        else if (id == 'pblock')\n            this.buttonView.pushBank(new CommandBank(this.owner, CommandType.PBlock));\n        else if (id == 'dblock')\n            this.buttonView.pushBank(new CommandBank(this.owner, CommandType.DBlock));\n        else if (id == 'fblock')\n            this.buttonView.pushBank(new CommandBank(this.owner, CommandType.FBlock));\n        else if (id == 'noble')\n            this.buttonView.pushBank(new CommandBank(this.owner, CommandType.Noble));\n        else\n            alert('Unhandled command: \"' + id + '\"');\n        if (actv > 0) {\n            new _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.MoleculeActivity(this.owner.getState(), actv, param, this.owner).execute();\n        }\n    }\n    claimKey(event) {\n        for (let listItems of [COMMANDS_MAIN, COMMANDS_ATOM, COMMANDS_BOND, COMMANDS_SELECT, COMMANDS_MOVE])\n            for (let item of listItems) {\n                if (_ui_ButtonBank__WEBPACK_IMPORTED_MODULE_2__.ButtonBank.matchKey(event, item.mnemonic, item.key)) {\n                    this.hitButton(item.id);\n                    return true;\n                }\n            }\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/sketcher/CommandBank.ts?");

/***/ }),

/***/ "./src/sketcher/ContextSketch.ts":
/*!***************************************!*\
  !*** ./src/sketcher/ContextSketch.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ContextSketch\": () => (/* binding */ ContextSketch)\n/* harmony export */ });\n/* harmony import */ var _data_Molecule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/Molecule */ \"./src/data/Molecule.ts\");\n/* harmony import */ var _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/PolymerBlock */ \"./src/data/PolymerBlock.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MoleculeActivity */ \"./src/sketcher/MoleculeActivity.ts\");\n\n\n\n\nclass ContextSketch {\n    constructor(state, sketcher, proxyClip) {\n        this.state = state;\n        this.sketcher = sketcher;\n        this.proxyClip = proxyClip;\n    }\n    populate() {\n        const { state, sketcher } = this;\n        let menu = [];\n        if (sketcher.canUndo() || sketcher.canRedo()) {\n            if (sketcher.canUndo())\n                menu.push({ 'label': 'Undo', 'accelerator': 'CmdOrCtrl+Z', 'click': () => sketcher.performUndo() });\n            if (sketcher.canRedo())\n                menu.push({ 'label': 'Redo', 'accelerator': 'CmdOrCtrl+Shift+Z', 'click': () => sketcher.performRedo() });\n            menu.push(null);\n        }\n        if (state.currentAtom > 0 || state.currentBond > 0)\n            menu.push({ 'label': 'Edit', 'accelerator': 'Enter', 'click': () => sketcher.editCurrent() });\n        this.maybeAppend(menu, 'Delete', 'D', _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Delete);\n        this.maybeAppend(menu, 'Cut', 'CmdOrCtrl+X', _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Cut);\n        this.maybeAppend(menu, 'Copy', 'CmdOrCtrl+C', _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Copy);\n        if (this.proxyClip.canAlwaysGet())\n            menu.push({ 'label': 'Paste', 'accelerator': 'CmdOrCtrl+V', 'click': () => sketcher.performPaste() });\n        this.maybeAppend(menu, 'Charge +', 'Shift+=', _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Charge, { 'delta': 1 });\n        this.maybeAppend(menu, 'Charge -', 'Shift+-', _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Charge, { 'delta': -1 });\n        this.maybeAppend(menu, 'Bond Order 0', '0', _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondOrder, { 'order': 0 });\n        this.maybeAppend(menu, 'Bond Order 1', '1', _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondOrder, { 'order': 1 });\n        this.maybeAppend(menu, 'Bond Order 2', '2', _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondOrder, { 'order': 2 });\n        this.maybeAppend(menu, 'Bond Order 3', '3', _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondOrder, { 'order': 3 });\n        this.maybeAppend(menu, 'Bond Order 4', null, _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondOrder, { 'order': 4 });\n        this.maybeAppend(menu, 'Unknown Stereochemistry', '4', _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondType, { 'type': _data_Molecule__WEBPACK_IMPORTED_MODULE_0__.Molecule.BONDTYPE_UNKNOWN });\n        this.maybeAppend(menu, 'Bond Wedge Up', '5', _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondType, { 'type': _data_Molecule__WEBPACK_IMPORTED_MODULE_0__.Molecule.BONDTYPE_INCLINED });\n        this.maybeAppend(menu, 'Bond Wedge Down', '6', _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondType, { 'type': _data_Molecule__WEBPACK_IMPORTED_MODULE_0__.Molecule.BONDTYPE_DECLINED });\n        this.maybeAppend(menu, 'Switch Geometry', null, _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondSwitch);\n        this.maybeAppend(menu, 'Add Two Bonds', 'Shift+D', _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondAddTwo);\n        this.maybeAppend(menu, 'Insert Atom', null, _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondInsert);\n        this.maybeAppend(menu, 'Join Atoms', null, _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Join);\n        this.maybeAppend(menu, 'Abbreviate Group', '/', _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.AbbrevGroup);\n        this.maybeAppend(menu, 'Abbreviate Formula', '\\\\', _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.AbbrevFormula);\n        this.maybeAppend(menu, 'Clear Abbreviation', 'Shift+\\\\', _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.AbbrevClear);\n        this.maybeAppend(menu, 'Expand Abbreviation', 'Shift+/', _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.AbbrevExpand);\n        let rotateSub = this.rotateSubMenu();\n        if (_util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.notBlank(rotateSub))\n            menu.push({ 'label': 'Rotate', 'subMenu': rotateSub });\n        let querySub = this.querySubMenu();\n        if (_util_Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.notBlank(querySub))\n            menu.push({ 'label': 'Query', 'subMenu': querySub });\n        let poly = new _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_1__.PolymerBlock(state.mol);\n        for (let units of poly.getUnits()) {\n            let a1 = state.currentAtom, a2 = 0;\n            if (state.currentBond > 0)\n                [a1, a2] = state.mol.bondFromTo(state.currentBond);\n            if (units.atoms.includes(a1) || units.atoms.includes(a2)) {\n                let label = 'Polymer Block (' + units.atoms.length + ' atom' + (units.atoms.length == 1 ? '' : 's') + ')';\n                menu.push({ 'label': label, 'click': () => sketcher.performPolymerBlock(units.atoms) });\n            }\n        }\n        if (menu.length > 0)\n            menu.push(null);\n        menu.push({ 'label': 'Scale to Fit', 'click': () => sketcher.autoScale() });\n        menu.push({ 'label': 'Zoom In', 'accelerator': '=', 'click': () => sketcher.zoom(1.25) });\n        menu.push({ 'label': 'Zoom Out', 'accelerator': '-', 'click': () => sketcher.zoom(0.8) });\n        return menu;\n    }\n    maybeAppend(menu, title, accelerator, activ, param = null) {\n        let molact = new _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.MoleculeActivity(this.state, activ, param);\n        molact.execute();\n        if (!molact.output.mol && !molact.toClipboard)\n            return;\n        menu.push({ 'label': title, 'accelerator': accelerator, 'click': () => {\n                this.sketcher.setState(molact.output, true);\n                if (molact.toClipboard)\n                    this.proxyClip.setString(molact.toClipboard);\n            } });\n    }\n    rotateSubMenu() {\n        let menu = [];\n        this.maybeAppend(menu, 'Bond', null, _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.BondRotate);\n        this.maybeAppend(menu, '+1 \\u{00B0}', null, _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Rotate, { 'theta': 1 });\n        this.maybeAppend(menu, '-1 \\u{00B0}', null, _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Rotate, { 'theta': -1 });\n        this.maybeAppend(menu, '+5 \\u{00B0}', null, _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Rotate, { 'theta': 5 });\n        this.maybeAppend(menu, '-5 \\u{00B0}', null, _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Rotate, { 'theta': -5 });\n        this.maybeAppend(menu, '+15 \\u{00B0}', null, _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Rotate, { 'theta': 15 });\n        this.maybeAppend(menu, '-15 \\u{00B0}', null, _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Rotate, { 'theta': -15 });\n        this.maybeAppend(menu, '+30 \\u{00B0}', 'Shift+[', _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Rotate, { 'theta': 30 });\n        this.maybeAppend(menu, '-30 \\u{00B0}', 'Shift+]', _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Rotate, { 'theta': -30 });\n        this.maybeAppend(menu, 'H-Flip', 'Shift+,', _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Flip, { 'axis': 'hor' });\n        this.maybeAppend(menu, 'V-Flip', 'Shift+.', _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.Flip, { 'axis': 'ver' });\n        this.maybeAppend(menu, 'Align', null, _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.AlignRegular);\n        return menu;\n    }\n    querySubMenu() {\n        let menu = [];\n        this.maybeAppend(menu, 'Clear', null, _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.QueryClear);\n        this.maybeAppend(menu, 'Copy', null, _MoleculeActivity__WEBPACK_IMPORTED_MODULE_3__.ActivityType.QueryCopy);\n        return menu;\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/sketcher/ContextSketch.ts?");

/***/ }),

/***/ "./src/sketcher/DrawCanvas.ts":
/*!************************************!*\
  !*** ./src/sketcher/DrawCanvas.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DraggingTool\": () => (/* binding */ DraggingTool),\n/* harmony export */   \"DrawCanvas\": () => (/* binding */ DrawCanvas),\n/* harmony export */   \"DrawCanvasDecoration\": () => (/* binding */ DrawCanvasDecoration)\n/* harmony export */ });\n/* harmony import */ var _data_Chemistry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/Chemistry */ \"./src/data/Chemistry.ts\");\n/* harmony import */ var _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/CoordUtil */ \"./src/data/CoordUtil.ts\");\n/* harmony import */ var _data_MetaMolecule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data/MetaMolecule */ \"./src/data/MetaMolecule.ts\");\n/* harmony import */ var _data_Molecule__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../data/Molecule */ \"./src/data/Molecule.ts\");\n/* harmony import */ var _data_MolUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../data/MolUtil */ \"./src/data/MolUtil.ts\");\n/* harmony import */ var _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../data/PolymerBlock */ \"./src/data/PolymerBlock.ts\");\n/* harmony import */ var _data_QueryUtil__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../data/QueryUtil */ \"./src/data/QueryUtil.ts\");\n/* harmony import */ var _data_SketchUtil__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../data/SketchUtil */ \"./src/data/SketchUtil.ts\");\n/* harmony import */ var _data_Stereochemistry__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../data/Stereochemistry */ \"./src/data/Stereochemistry.ts\");\n/* harmony import */ var _gfx_ArrangeMolecule__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../gfx/ArrangeMolecule */ \"./src/gfx/ArrangeMolecule.ts\");\n/* harmony import */ var _gfx_DrawMolecule__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../gfx/DrawMolecule */ \"./src/gfx/DrawMolecule.ts\");\n/* harmony import */ var _gfx_FontData__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../gfx/FontData */ \"./src/gfx/FontData.ts\");\n/* harmony import */ var _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../gfx/MetaVector */ \"./src/gfx/MetaVector.ts\");\n/* harmony import */ var _gfx_Rendering__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../gfx/Rendering */ \"./src/gfx/Rendering.ts\");\n/* harmony import */ var _ui_Widget__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../ui/Widget */ \"./src/ui/Widget.ts\");\n/* harmony import */ var _util_dom__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../util/dom */ \"./src/util/dom.ts\");\n/* harmony import */ var _util_Geom__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../util/Geom */ \"./src/util/Geom.ts\");\n/* harmony import */ var _util_Theme__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../util/Theme */ \"./src/util/Theme.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar DraggingTool;\n(function (DraggingTool) {\n    DraggingTool[DraggingTool[\"None\"] = 0] = \"None\";\n    DraggingTool[DraggingTool[\"Press\"] = 1] = \"Press\";\n    DraggingTool[DraggingTool[\"Lasso\"] = 2] = \"Lasso\";\n    DraggingTool[DraggingTool[\"Pan\"] = 3] = \"Pan\";\n    DraggingTool[DraggingTool[\"Zoom\"] = 4] = \"Zoom\";\n    DraggingTool[DraggingTool[\"Rotate\"] = 5] = \"Rotate\";\n    DraggingTool[DraggingTool[\"Move\"] = 6] = \"Move\";\n    DraggingTool[DraggingTool[\"Erasor\"] = 7] = \"Erasor\";\n    DraggingTool[DraggingTool[\"Atom\"] = 8] = \"Atom\";\n    DraggingTool[DraggingTool[\"Bond\"] = 9] = \"Bond\";\n    DraggingTool[DraggingTool[\"Charge\"] = 10] = \"Charge\";\n    DraggingTool[DraggingTool[\"Ring\"] = 11] = \"Ring\";\n})(DraggingTool || (DraggingTool = {}));\nvar DrawCanvasDecoration;\n(function (DrawCanvasDecoration) {\n    DrawCanvasDecoration[DrawCanvasDecoration[\"None\"] = 0] = \"None\";\n    DrawCanvasDecoration[DrawCanvasDecoration[\"Stereochemistry\"] = 1] = \"Stereochemistry\";\n    DrawCanvasDecoration[DrawCanvasDecoration[\"MappingNumber\"] = 2] = \"MappingNumber\";\n    DrawCanvasDecoration[DrawCanvasDecoration[\"AtomIndex\"] = 3] = \"AtomIndex\";\n})(DrawCanvasDecoration || (DrawCanvasDecoration = {}));\nclass DrawCanvas extends _ui_Widget__WEBPACK_IMPORTED_MODULE_14__.Widget {\n    constructor() {\n        super();\n        this.mol = null;\n        this.policy = null;\n        this.offsetX = 0;\n        this.offsetY = 0;\n        this.pointScale = 1;\n        this.viewOpt = {\n            'decoration': DrawCanvasDecoration.Stereochemistry,\n            'showOxState': true,\n            'showQuery': true,\n            'showArtifacts': true,\n        };\n        this.width = 0;\n        this.height = 0;\n        this.border = 0x808080;\n        this.borderRadius = 4;\n        this.background = 0xF8F8F8;\n        this.canvasUnder = null;\n        this.canvasMolecule = null;\n        this.canvasOver = null;\n        this.divMessage = null;\n        this.layout = null;\n        this.metavec = null;\n        this.stereo = null;\n        this.guidelines = null;\n        this.filthy = false;\n        this.dragType = DraggingTool.None;\n        this.currentAtom = 0;\n        this.currentBond = 0;\n        this.hoverAtom = 0;\n        this.hoverBond = 0;\n        this.selectedMask = null;\n        this.opAtom = 0;\n        this.opBond = 0;\n        this.opBudged = false;\n        this.opShift = false;\n        this.opCtrl = false;\n        this.opAlt = false;\n        this.lassoX = null;\n        this.lassoY = null;\n        this.lassoMask = null;\n        this.clickX = 0;\n        this.clickY = 0;\n        this.mouseX = 0;\n        this.mouseY = 0;\n        this.dragGuides = null;\n        this.templatePerms = null;\n        this.currentPerm = 0;\n        this.fusionBank = null;\n        this.cursorWatermark = 0;\n        this.cursorDX = 0;\n        this.cursorDY = 0;\n        this.toolAtomSymbol = '';\n        this.toolBondOrder = 0;\n        this.toolBondType = 0;\n        this.toolChargeDelta = 0;\n        this.toolRingArom = false;\n        this.toolRingFreeform = false;\n        this.toolRotateIncr = 0;\n        this.redrawCacheKey = '';\n        this.abbrevPolicy = _gfx_Rendering__WEBPACK_IMPORTED_MODULE_13__.RenderPolicy.defaultBlackOnWhite();\n        this.abbrevPolicy.data.foreground = 0xD0D0D0;\n        this.abbrevPolicy.data.atomCols = _util_Vec__WEBPACK_IMPORTED_MODULE_19__.Vec.numberArray(0xD0D0D0, this.abbrevPolicy.data.atomCols.length);\n    }\n    render(parent) {\n        if (!this.width || !this.height)\n            throw 'Sketcher.render called without width and height';\n        super.render(parent);\n        this.container = (0,_util_dom__WEBPACK_IMPORTED_MODULE_15__.dom)('<div/>').appendTo(this.contentDOM);\n        this.container.css({ 'position': 'relative', 'width': this.width + 'px', 'height': this.height + 'px' });\n        this.container.css({ 'background-color': (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.colourCanvas)(this.background) });\n        if (this.border != _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_12__.MetaVector.NOCOLOUR) {\n            this.container.css({ 'border': '1px solid ' + (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.colourCanvas)(this.border) });\n            this.container.css({ 'border-radius': this.borderRadius + 'px' });\n        }\n        this.container.css({ 'outline': 'none' });\n        this.container.attr({ 'tabindex': '0' });\n        let canvasStyle = { 'position': 'absolute', 'left': '0', 'top': '0', 'width': `${this.width}px`, 'height': `${this.height}`, 'pointer-events': 'none' };\n        this.divInfo = (0,_util_dom__WEBPACK_IMPORTED_MODULE_15__.dom)('<div/>').appendTo(this.container).css({ 'position': 'absolute', 'left': '0', 'top': '0', 'pointer-events': 'none' });\n        this.canvasUnder = (0,_util_dom__WEBPACK_IMPORTED_MODULE_15__.dom)('<canvas/>').appendTo(this.container).css(canvasStyle);\n        this.canvasMolecule = (0,_util_dom__WEBPACK_IMPORTED_MODULE_15__.dom)('<canvas/>').appendTo(this.container).css(canvasStyle);\n        this.canvasOver = (0,_util_dom__WEBPACK_IMPORTED_MODULE_15__.dom)('<canvas/>').appendTo(this.container).css(canvasStyle);\n        this.divMessage = (0,_util_dom__WEBPACK_IMPORTED_MODULE_15__.dom)('<div/>').appendTo(this.container).css(canvasStyle);\n        this.divMessage.css({ 'text-align': 'center', 'vertical-align': 'middle', 'font-weight': 'bold', 'font-size': '120%' });\n    }\n    getState() {\n        let state = {\n            'mol': this.mol.clone(),\n            'currentAtom': this.currentAtom,\n            'currentBond': this.currentBond,\n            'selectedMask': this.selectedMask == null ? null : this.selectedMask.slice(0)\n        };\n        return state;\n    }\n    getSelected(atom) {\n        if (this.selectedMask == null || atom > this.selectedMask.length)\n            return false;\n        return this.selectedMask[atom - 1];\n    }\n    getLassoed(atom) {\n        if (this.lassoMask == null || atom > this.lassoMask.length)\n            return false;\n        return this.lassoMask[atom - 1];\n    }\n    scale() { return this.pointScale; }\n    angToX(ax) {\n        return ax * this.pointScale + this.offsetX;\n    }\n    angToY(ay) {\n        return ay * -this.pointScale + this.offsetY;\n    }\n    xToAng(px) {\n        return (px - this.offsetX) / this.pointScale;\n    }\n    yToAng(py) {\n        return (py - this.offsetY) / -this.pointScale;\n    }\n    scaleToAng(scale) { return scale / this.pointScale; }\n    angToScale(ang) { return ang * this.pointScale; }\n    yIsUp() { return false; }\n    measureText(str, fontSize) { return _gfx_FontData__WEBPACK_IMPORTED_MODULE_11__.FontData.main.measureText(str, fontSize); }\n    delayedRedraw() {\n        if (this.canvasMolecule == null)\n            return;\n        this.filthy = true;\n        window.setTimeout(() => { if (this.filthy)\n            this.redraw(); }, 10);\n    }\n    layoutMolecule() {\n        let mol = this.mol;\n        if (this.hoverAtom > 0 && _data_MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.hasAbbrev(mol, this.hoverAtom)) {\n            mol = mol.clone();\n            mol.setAtomElement(this.hoverAtom, '');\n            mol.setAtomCharge(this.hoverAtom, 0);\n            mol.setAtomUnpaired(this.hoverAtom, 0);\n            _data_MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.clearAbbrev(mol, this.hoverAtom);\n        }\n        let effects = this.sketchEffects(mol);\n        this.layout = new _gfx_ArrangeMolecule__WEBPACK_IMPORTED_MODULE_9__.ArrangeMolecule(mol, this, this.policy, effects);\n        this.layout.setWantArtifacts(this.viewOpt.showArtifacts);\n        this.layout.arrange();\n    }\n    redrawMetaVector() {\n        this.metavec = new _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_12__.MetaVector();\n        new _gfx_DrawMolecule__WEBPACK_IMPORTED_MODULE_10__.DrawMolecule(this.layout, this.metavec).draw();\n        if (this.hoverAtom > 0 && _data_MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.hasAbbrev(this.mol, this.hoverAtom)) {\n            let abbrevMol = _data_MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.getAbbrev(this.mol, this.hoverAtom);\n            this.orientAbbreviation(this.hoverAtom, abbrevMol);\n            this.abbrevPolicy.data.pointScale = this.policy.data.pointScale;\n            let layout = new _gfx_ArrangeMolecule__WEBPACK_IMPORTED_MODULE_9__.ArrangeMolecule(abbrevMol, this, this.abbrevPolicy, new _gfx_Rendering__WEBPACK_IMPORTED_MODULE_13__.RenderEffects());\n            layout.arrange();\n            new _gfx_DrawMolecule__WEBPACK_IMPORTED_MODULE_10__.DrawMolecule(layout, this.metavec).draw();\n        }\n    }\n    redraw() {\n        this.filthy = false;\n        this.redrawInfo();\n        this.redrawUnder();\n        this.redrawMolecule();\n        this.redrawOver();\n    }\n    redrawInfo() {\n        let cacheKey = JSON.stringify([this.width, this.height, this.mol.toString()]);\n        if (cacheKey == this.redrawCacheKey)\n            return;\n        this.redrawCacheKey = cacheKey;\n        this.divInfo.empty();\n        this.divInfo.css({ 'visibility': 'hidden', 'left': '0', 'top': '0' });\n        if (this.mol.numAtoms == 0)\n            return;\n        let divText = (0,_util_dom__WEBPACK_IMPORTED_MODULE_15__.dom)('<div/>').appendTo(this.divInfo);\n        divText.css({ 'display': 'inline-block', 'text-align': 'right', 'font-family': 'sans-serif', 'font-size': '80%', 'color': '#C0C0C0' });\n        let html = _data_MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.molecularFormula(this.mol, ['<sub>', '</sub>', '<sup>', '</sup>']);\n        let chg = 0;\n        for (let n = 1; n <= this.mol.numAtoms; n++)\n            chg += this.mol.atomCharge(n);\n        if (chg == -1)\n            html += '<sup>-</sup>';\n        else if (chg < -1)\n            html += `<sup>${chg}</sup>`;\n        else if (chg == 1)\n            html += '<sup>+</sup>';\n        else if (chg > 1)\n            html += `<sup>+${chg}</sup>`;\n        html += '<br>' + _data_MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.molecularWeight(this.mol).toFixed(2);\n        divText.setHTML(html);\n        setTimeout(() => {\n            let w = divText.width(), h = divText.height();\n            (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.setBoundaryPixels)(this.divInfo, this.width - w - 1, 1, w, h);\n            this.divInfo.css({ 'visibility': 'visible' });\n        }, 1);\n    }\n    redrawUnder() {\n        let HOVER_COL = 0xE0E0E0;\n        let CURRENT_COL = 0xA0A0A0, CURRENT_BORD = 0x808080;\n        let SELECT_COL = 0xC0C0C0;\n        let LASSO_COL = 0xD0D0D0;\n        let density = (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.pixelDensity)();\n        this.canvasUnder.elCanvas.width = this.width * density;\n        this.canvasUnder.elCanvas.height = this.height * density;\n        this.canvasUnder.css({ 'width': `${this.width}px`, 'height': `${this.height}px` });\n        let ctx = this.canvasUnder.elCanvas.getContext('2d');\n        ctx.save();\n        ctx.scale(density, density);\n        ctx.clearRect(0, 0, this.width, this.height);\n        if (this.hoverAtom > 0) {\n            let units = new _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_5__.PolymerBlock(this.mol).getUnits();\n            for (let unit of units)\n                if (unit.atoms.includes(this.hoverAtom))\n                    this.drawPolymerUnit(ctx, unit, units);\n            let sz = 0;\n            if (this.hoverAtom == this.currentAtom)\n                sz += 0.1;\n            if (this.getSelected(this.hoverAtom))\n                sz += 0.1;\n            if (this.currentBond > 0 && (this.mol.bondFrom(this.currentBond) == this.hoverAtom || this.mol.bondTo(this.currentBond) == this.hoverAtom))\n                sz += 0.1;\n            this.drawAtomShade(ctx, this.hoverAtom, HOVER_COL, -1, sz);\n        }\n        if (this.hoverBond > 0) {\n            let bfr = this.mol.bondFrom(this.hoverBond), bto = this.mol.bondTo(this.hoverBond);\n            let units = new _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_5__.PolymerBlock(this.mol).getUnits();\n            for (let unit of units)\n                if (unit.atoms.includes(bfr) && unit.atoms.includes(bto))\n                    this.drawPolymerUnit(ctx, unit, units);\n            let sz = 0;\n            if (this.hoverBond == this.currentBond)\n                sz += 0.1;\n            if (this.getSelected(bfr) && this.getSelected(bto))\n                sz += 0.1;\n            this.drawBondShade(ctx, this.hoverBond, HOVER_COL, -1, sz);\n        }\n        for (let n = 1; n <= this.mol.numBonds; n++) {\n            let sz = n == this.currentBond ? 0.1 : 0;\n            let bfr = this.mol.bondFrom(n), bto = this.mol.bondTo(n);\n            let sfr = this.getSelected(bfr), sto = this.getSelected(bto), lfr = this.getLassoed(bfr), lto = this.getLassoed(bto);\n            if (sfr && sto)\n                this.drawBondShade(ctx, n, SELECT_COL, -1, sz);\n            else if ((sfr || lfr) && (sto || lto))\n                this.drawBondShade(ctx, n, LASSO_COL, -1, sz);\n        }\n        for (let n = 1; n <= this.mol.numAtoms; n++) {\n            let sz = this.currentAtom == n ? 0.1 : 0;\n            if (this.getSelected(n))\n                this.drawAtomShade(ctx, n, SELECT_COL, -1, sz);\n            else if (this.getLassoed(n))\n                this.drawAtomShade(ctx, n, LASSO_COL, -1, sz);\n        }\n        if (this.currentAtom > 0) {\n            this.drawAtomShade(ctx, this.currentAtom, CURRENT_COL, CURRENT_BORD, 0);\n        }\n        if (this.currentBond > 0) {\n            this.drawBondShade(ctx, this.currentBond, CURRENT_COL, CURRENT_BORD, 0);\n        }\n        if (this.dragType == DraggingTool.Move || (this.dragType == DraggingTool.Atom && this.opAtom > 0) || this.dragType == DraggingTool.Bond) {\n            if (this.dragGuides != null && this.dragGuides.length > 0) {\n                for (let g of this.dragGuides)\n                    for (let n = 0; n < g.x.length; n++) {\n                        let lw = this.policy.data.lineSize * this.pointScale;\n                        ctx.strokeStyle = '#C0C0C0';\n                        ctx.lineWidth = lw;\n                        (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.drawLine)(ctx, g.sourceX, g.sourceY, g.destX[n], g.destY[n]);\n                        ctx.beginPath();\n                        ctx.ellipse(g.destX[n], g.destY[n], 2 * lw, 2 * lw, 0, 0, _util_util__WEBPACK_IMPORTED_MODULE_18__.TWOPI, false);\n                        ctx.fillStyle = '#C0C0C0';\n                        ctx.fill();\n                    }\n            }\n        }\n        if (this.dragType == DraggingTool.Ring) {\n            let [ringX, ringY] = this.determineFauxRing();\n            let rsz = ringX == null ? 0 : ringX.length;\n            if (rsz > 0) {\n                let scale = this.pointScale;\n                let lw = this.policy.data.lineSize * scale;\n                ctx.strokeStyle = '#C0C0C0';\n                ctx.lineWidth = lw;\n                for (let n = 0; n < rsz; n++) {\n                    let nn = n < rsz - 1 ? n + 1 : 0;\n                    let x1 = this.angToX(ringX[n]), y1 = this.angToY(ringY[n]);\n                    let x2 = this.angToX(ringX[nn]), y2 = this.angToY(ringY[nn]);\n                    (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.drawLine)(ctx, x1, y1, x2, y2);\n                }\n                if (this.toolRingArom) {\n                    let cx = 0, cy = 0;\n                    for (let n = 0; n < rsz; n++) {\n                        cx += ringX[n];\n                        cy += ringY[n];\n                    }\n                    cx /= rsz;\n                    cy /= rsz;\n                    let rad = 0;\n                    for (let n = 0; n < rsz; n++)\n                        rad += (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.norm_xy)(ringX[n] - cx, ringY[n] - cy);\n                    rad = this.angToScale(rad * 0.5 / rsz);\n                    ctx.beginPath();\n                    ctx.ellipse(this.angToX(cx), this.angToY(cy), rad, rad, 0, 0, _util_util__WEBPACK_IMPORTED_MODULE_18__.TWOPI, false);\n                    ctx.stroke();\n                }\n            }\n        }\n        ctx.restore();\n    }\n    redrawMolecule() {\n        let density = (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.pixelDensity)();\n        this.canvasMolecule.elCanvas.width = this.width * density;\n        this.canvasMolecule.elCanvas.height = this.height * density;\n        this.canvasMolecule.css({ 'width': `${this.width}px`, 'height': `${this.height}px` });\n        let ctx = this.canvasMolecule.elCanvas.getContext('2d');\n        ctx.save();\n        ctx.scale(density, density);\n        ctx.clearRect(0, 0, this.width, this.height);\n        if (this.metavec != null)\n            this.metavec.renderContext(ctx);\n        if (this.templatePerms != null) {\n            let perm = this.templatePerms[this.currentPerm];\n            if (perm.metavec != null)\n                perm.metavec.renderContext(ctx);\n        }\n        ctx.restore();\n    }\n    redrawOver() {\n        let density = (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.pixelDensity)();\n        this.canvasOver.elCanvas.width = this.width * density;\n        this.canvasOver.elCanvas.height = this.height * density;\n        this.canvasOver.css({ 'width': `${this.width}px`, 'height': `${this.height}px` });\n        let ctx = this.canvasOver.elCanvas.getContext('2d');\n        ctx.save();\n        ctx.scale(density, density);\n        ctx.clearRect(0, 0, this.width, this.height);\n        if ((this.dragType == DraggingTool.Lasso || this.dragType == DraggingTool.Erasor) && this.lassoX.length > 1) {\n            let erasing = this.dragType == DraggingTool.Erasor;\n            let path = new Path2D();\n            path.moveTo(this.lassoX[0], this.lassoY[0]);\n            for (let n = 1; n < this.lassoX.length; n++)\n                path.lineTo(this.lassoX[n], this.lassoY[n]);\n            path.closePath();\n            ctx.fillStyle = (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.colourCanvas)(erasing ? 0xD0FF0000 : 0xF0000000);\n            ctx.fill(path);\n            ctx.strokeStyle = erasing ? '#804040' : '#808080';\n            ctx.lineWidth = 0.5;\n            ctx.stroke(path);\n        }\n        if (this.dragType == DraggingTool.Rotate) {\n            let [x0, y0, theta, magnitude] = this.determineDragTheta();\n            let scale = this.pointScale;\n            let lw = this.policy.data.lineSize * scale;\n            ctx.strokeStyle = '#E0E0E0';\n            ctx.lineWidth = 0.5 * lw;\n            (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.drawLine)(ctx, x0, y0, x0 + magnitude, y0);\n            ctx.strokeStyle = '#808080';\n            ctx.lineWidth = lw;\n            (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.drawLine)(ctx, x0, y0, x0 + magnitude * Math.cos(theta), y0 + magnitude * Math.sin(theta));\n            ctx.beginPath();\n            ctx.ellipse(x0, y0, 2 * lw, 2 * lw, 0, 0, _util_util__WEBPACK_IMPORTED_MODULE_18__.TWOPI, false);\n            ctx.fillStyle = '#808080';\n            ctx.fill();\n            for (let atom of this.subjectAtoms(true, false)) {\n                let ax = this.angToX(this.mol.atomX(atom)), ay = this.angToY(this.mol.atomY(atom));\n                let ang = Math.atan2(ay - y0, ax - x0), dist = (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.norm_xy)(ax - x0, ay - y0);\n                let nx = x0 + dist * Math.cos(ang + theta), ny = y0 + dist * Math.sin(ang + theta);\n                ctx.beginPath();\n                ctx.ellipse(nx, ny, 2 * lw, 2 * lw, 0, 0, _util_util__WEBPACK_IMPORTED_MODULE_18__.TWOPI, false);\n                ctx.strokeStyle = 'black';\n                ctx.lineWidth = 0.5;\n                ctx.stroke();\n            }\n        }\n        if (this.dragType == DraggingTool.Move) {\n            let [dx, dy] = this.determineMoveDelta();\n            let scale = this.pointScale;\n            let lw = this.policy.data.lineSize * scale;\n            for (let atom of this.subjectAtoms(false, true)) {\n                let ax = this.angToX(this.mol.atomX(atom)), ay = this.angToY(this.mol.atomY(atom));\n                ctx.beginPath();\n                ctx.ellipse(ax + dx, ay + dy, 2 * lw, 2 * lw, 0, 0, _util_util__WEBPACK_IMPORTED_MODULE_18__.TWOPI, false);\n                ctx.strokeStyle = 'black';\n                ctx.lineWidth = 0.5;\n                ctx.stroke();\n            }\n        }\n        if ((this.dragType == DraggingTool.Atom && this.opAtom > 0) || this.dragType == DraggingTool.Bond) {\n            let element = this.dragType == DraggingTool.Atom ? this.toolAtomSymbol : 'C';\n            let order = this.dragType == DraggingTool.Bond ? this.toolBondOrder : 1;\n            let type = this.dragType == DraggingTool.Bond ? this.toolBondType : _data_Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule.BONDTYPE_NORMAL;\n            this.drawOriginatingBond(ctx, element, order, type);\n        }\n        if (this.viewOpt.showQuery)\n            this.drawQueryFeatures(ctx);\n        ctx.restore();\n    }\n    subjectAtoms(allIfNone = false, useOpAtom = false) {\n        let atoms = [];\n        if (this.selectedMask != null) {\n            for (let n = 0; n < this.selectedMask.length; n++)\n                if (this.selectedMask[n])\n                    atoms.push(n + 1);\n            if (atoms.length > 0)\n                return atoms;\n        }\n        if (this.currentAtom > 0)\n            atoms.push(this.currentAtom);\n        else if (this.currentBond > 0) {\n            atoms.push(this.mol.bondFrom(this.currentBond));\n            atoms.push(this.mol.bondTo(this.currentBond));\n        }\n        if (useOpAtom && atoms.length == 0 && this.opAtom > 0)\n            atoms.push(this.opAtom);\n        if (allIfNone && atoms.length == 0) {\n            for (let n = 1; n <= this.mol.numAtoms; n++)\n                atoms.push(n);\n        }\n        return atoms;\n    }\n    updateLasso(x, y) {\n        if (this.dragType != DraggingTool.Lasso && this.dragType != DraggingTool.Erasor)\n            return;\n        if (x < 0 || y < 0 || x > this.width || y > this.height) {\n            this.dragType = DraggingTool.None;\n            this.lassoX = null;\n            this.lassoY = null;\n            this.lassoMask = null;\n            this.delayedRedraw();\n        }\n        let len = _util_Vec__WEBPACK_IMPORTED_MODULE_19__.Vec.len(this.lassoX);\n        if (len > 0 && this.lassoX[len - 1] == x && this.lassoY[len - 1] == y)\n            return;\n        this.lassoX.push(x);\n        this.lassoY.push(y);\n        this.calculateLassoMask();\n        this.delayedRedraw();\n    }\n    calculateLassoMask() {\n        this.lassoMask = new Array(this.mol.numAtoms);\n        for (let n = 0; n < this.mol.numAtoms; n++)\n            this.lassoMask[n] = false;\n        for (let n = 0; n < this.layout.numPoints(); n++) {\n            let p = this.layout.getPoint(n);\n            if (p.anum == 0)\n                continue;\n            this.lassoMask[p.anum - 1] = _util_Geom__WEBPACK_IMPORTED_MODULE_16__.GeomUtil.pointInPolygon(p.oval.cx, p.oval.cy, this.lassoX, this.lassoY);\n        }\n    }\n    drawAtomShade(ctx, atom, fillCol, borderCol, anghalo) {\n        if (this.layout == null)\n            return;\n        let p = null;\n        for (let n = 0; n < this.layout.numPoints(); n++)\n            if (this.layout.getPoint(n).anum == atom) {\n                p = this.layout.getPoint(n);\n                break;\n            }\n        if (p == null)\n            return;\n        let minRad = 0.2 * this.pointScale, minRadSq = (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.sqr)(minRad);\n        let cx = p.oval.cx, cy = p.oval.cy;\n        let rad = Math.max(minRad, Math.max(p.oval.rw, p.oval.rh)) + (0.1 + anghalo) * this.pointScale;\n        if (fillCol != -1) {\n            ctx.beginPath();\n            ctx.ellipse(cx, cy, rad, rad, 0, 0, _util_util__WEBPACK_IMPORTED_MODULE_18__.TWOPI, true);\n            ctx.fillStyle = (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.colourCanvas)(fillCol);\n            ctx.fill();\n        }\n        if (borderCol != -1) {\n            ctx.beginPath();\n            ctx.ellipse(cx, cy, rad, rad, 0, 0, _util_util__WEBPACK_IMPORTED_MODULE_18__.TWOPI, true);\n            ctx.strokeStyle = (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.colourCanvas)(borderCol);\n            ctx.lineWidth = 1;\n            ctx.stroke();\n        }\n    }\n    drawBondShade(ctx, bond, fillCol, borderCol, anghalo) {\n        if (this.layout == null)\n            return;\n        let x1 = 0, y1 = 0, x2 = 0, y2 = 0, nb = 0, sz = 0;\n        for (let n = 0; n < this.layout.numLines(); n++) {\n            let l = this.layout.getLine(n);\n            if (l.bnum != bond)\n                continue;\n            x1 += l.line.x1;\n            y1 += l.line.y1;\n            x2 += l.line.x2;\n            y2 += l.line.y2;\n            nb++;\n            sz += l.size + (0.2 + anghalo) * this.pointScale;\n        }\n        if (nb == 0)\n            return;\n        let invNB = 1 / nb;\n        sz *= invNB;\n        x1 *= invNB;\n        y1 *= invNB;\n        x2 *= invNB;\n        y2 *= invNB;\n        let dx = x2 - x1, dy = y2 - y1, invDist = 1 / (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.norm_xy)(dx, dy);\n        dx *= invDist;\n        dy *= invDist;\n        let ox = dy, oy = -dx;\n        let path = new Path2D(), mx, my, CIRC = 0.8;\n        path.moveTo(x1 + ox * sz, y1 + oy * sz);\n        mx = x1 + (ox * sz - dx * sz) * CIRC;\n        my = y1 + (oy * sz - dy * sz) * CIRC;\n        path.quadraticCurveTo(mx, my, x1 - dx * sz, y1 - dy * sz);\n        mx = x1 + (-ox * sz - dx * sz) * CIRC;\n        my = y1 + (-oy * sz - dy * sz) * CIRC;\n        path.quadraticCurveTo(mx, my, x1 - ox * sz, y1 - oy * sz);\n        path.lineTo(x2 - ox * sz, y2 - oy * sz);\n        mx = x2 + (-ox * sz + dx * sz) * CIRC;\n        my = y2 + (-oy * sz + dy * sz) * CIRC;\n        path.quadraticCurveTo(mx, my, x2 + dx * sz, y2 + dy * sz);\n        mx = x2 + (ox * sz + dx * sz) * CIRC;\n        my = y2 + (oy * sz + dy * sz) * CIRC;\n        path.quadraticCurveTo(mx, my, x2 + ox * sz, y2 + oy * sz);\n        path.closePath();\n        if (fillCol != -1) {\n            ctx.beginPath();\n            ctx.fillStyle = (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.colourCanvas)(fillCol);\n            ctx.fill(path);\n        }\n        if (borderCol != -1) {\n            ctx.beginPath();\n            ctx.strokeStyle = (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.colourCanvas)(borderCol);\n            ctx.lineWidth = 1;\n            ctx.stroke(path);\n        }\n    }\n    drawOriginatingBond(ctx, element, order, type) {\n        let x1 = this.clickX, y1 = this.clickY;\n        if (this.opAtom > 0) {\n            x1 = this.angToX(this.mol.atomX(this.opAtom));\n            y1 = this.angToY(this.mol.atomY(this.opAtom));\n        }\n        else if (this.opBond > 0) {\n            let [bfr, bto] = this.mol.bondFromTo(this.opBond);\n            x1 = this.angToX(0.5 * (this.mol.atomX(bfr) + this.mol.atomX(bto)));\n            y1 = this.angToY(0.5 * (this.mol.atomY(bfr) + this.mol.atomY(bto)));\n        }\n        let x2 = this.mouseX, y2 = this.mouseY;\n        let snapTo = this.snapToGuide(x2, y2), snapAtom = false;\n        if (snapTo)\n            [x2, y2, snapAtom] = snapTo;\n        let scale = this.pointScale;\n        ctx.strokeStyle = snapAtom ? '#4040FF' : '#808080';\n        ctx.lineWidth = this.policy.data.lineSize * scale * (snapAtom ? 1.5 : 1);\n        (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.drawLine)(ctx, x1, y1, x2, y2);\n        if (element != 'C') {\n            let fh = this.policy.data.fontSize * scale;\n            ctx.font = (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.fontSansSerif)(fh);\n            let metrics = ctx.measureText(element);\n            ctx.fillStyle = '#808080';\n            ctx.fillText(element, x2 - 0.5 * metrics.width, y2 + 0.5 * fh);\n        }\n    }\n    drawQueryFeatures(ctx) {\n        const { layout, mol } = this;\n        let annots = [];\n        for (let n = 1; n <= mol.numAtoms; n++)\n            if (_data_QueryUtil__WEBPACK_IMPORTED_MODULE_6__.QueryUtil.hasAnyQueryAtom(mol, n)) {\n                let bits = [];\n                for (let xtra of mol.atomExtra(n))\n                    if (xtra.startsWith('q'))\n                        bits.push(xtra);\n                let ap = layout.getPoint(n - 1);\n                annots.push({ 'txt': bits.join(','), 'x': ap.oval.cx + ap.oval.rw, 'y': ap.oval.cy });\n            }\n        for (let n = 1; n <= mol.numBonds; n++)\n            if (_data_QueryUtil__WEBPACK_IMPORTED_MODULE_6__.QueryUtil.hasAnyQueryBond(mol, n)) {\n                let bits = [];\n                for (let xtra of mol.bondExtra(n))\n                    if (xtra.startsWith('q'))\n                        bits.push(xtra);\n                let num = 0, cx = 0, cy = 0;\n                for (let bl of layout.getLines())\n                    if (bl.bnum == n) {\n                        num += 2;\n                        cx += bl.line.x1 + bl.line.x2;\n                        cy += bl.line.y1 + bl.line.y2;\n                    }\n                annots.push({ 'txt': bits.join(','), 'x': cx / num, 'y': cy / num });\n            }\n        let fh = 0.7 * this.policy.data.fontSize * this.pointScale;\n        for (let annot of annots) {\n            ctx.font = (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.fontSansSerif)(fh);\n            ctx.fillStyle = '#FF40C0';\n            ctx.fillText(annot.txt, annot.x, annot.y);\n        }\n    }\n    drawPolymerUnit(ctx, unit, allUnits) {\n        const { mol, layout } = this;\n        let x = [], y = [];\n        let scale = this.pointScale;\n        for (let a of unit.atoms) {\n            let pt = layout.getPoint(a - 1);\n            let rad = Math.max(0.5 * scale, Math.max(pt.oval.rw, pt.oval.rh));\n            const NPT = 36, THPT = _util_util__WEBPACK_IMPORTED_MODULE_18__.TWOPI / NPT;\n            for (let n = 0; n < NPT; n++) {\n                let th = n * THPT;\n                x.push(pt.oval.cx + rad * Math.cos(th));\n                y.push(pt.oval.cy + rad * Math.sin(th));\n            }\n        }\n        let extBonds = [], inAtoms = [], outAtoms = [];\n        for (let n = 1; n <= mol.numBonds; n++) {\n            let bfr = mol.bondFrom(n), bto = mol.bondTo(n);\n            let flag1 = unit.atoms.includes(bfr), flag2 = unit.atoms.includes(bto);\n            if (!flag1 && !flag2)\n                continue;\n            if (!flag2) {\n                extBonds.push(n);\n                inAtoms.push(bfr);\n                outAtoms.push(bto);\n            }\n            else if (!flag1) {\n                extBonds.push(n);\n                inAtoms.push(bto);\n                outAtoms.push(bfr);\n            }\n            let pt1 = layout.getPoint(bfr - 1), pt2 = layout.getPoint(bto - 1);\n            let x1 = pt1.oval.cx, y1 = pt1.oval.cy, x2 = pt2.oval.cx, y2 = pt2.oval.cy;\n            if (!flag1)\n                [x1, y1] = [0.5 * (x1 + x2), 0.5 * (y1 + y2)];\n            else if (!flag2)\n                [x2, y2] = [0.5 * (x1 + x2), 0.5 * (y1 + y2)];\n            let dx = x2 - x1, dy = y2 - y1, d = (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.norm_xy)(dx, dy), invD = (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.invZ)(d);\n            let ox = dy * invD * 0.3 * scale, oy = -dx * invD * 0.3 * scale;\n            let npWidth = Math.ceil(2 * d / scale) + 1, npHeight = Math.ceil(2 * (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.norm_xy)(ox, oy) / scale) + 1;\n            for (let n = 0; n <= npWidth; n++) {\n                x.push(x1 - ox + dx * n / npWidth);\n                y.push(y1 - oy + dy * n / npWidth);\n                x.push(x1 + ox + dx * n / npWidth);\n                y.push(y1 + oy + dy * n / npWidth);\n            }\n            for (let n = 1; n < npHeight; n++) {\n                x.push(x1 - ox + 2 * ox * n / npHeight);\n                y.push(y1 - oy + 2 * oy * n / npHeight);\n                x.push(x2 - ox + 2 * ox * n / npHeight);\n                y.push(y2 - oy + 2 * oy * n / npHeight);\n            }\n        }\n        let [px, py] = _util_Geom__WEBPACK_IMPORTED_MODULE_16__.GeomUtil.outlinePolygon(x, y, 0.5 * scale);\n        let path = new Path2D();\n        path.moveTo(px[0], py[0]);\n        for (let n = 1; n < px.length; n++)\n            path.lineTo(px[n], py[n]);\n        path.closePath();\n        ctx.save();\n        ctx.fillStyle = '#F9EFFF';\n        ctx.fill(path);\n        ctx.strokeStyle = '#C0C0C0';\n        ctx.lineWidth = 1;\n        ctx.stroke(path);\n        ctx.restore();\n        let selfLinks = [];\n        let innerLinks = [];\n        let outerLinks = [];\n        if (_util_Vec__WEBPACK_IMPORTED_MODULE_19__.Vec.len(unit.bondConn) == 4) {\n            innerLinks.push([inAtoms[extBonds.indexOf(unit.bondConn[0])], inAtoms[extBonds.indexOf(unit.bondConn[2])]]);\n            innerLinks.push([inAtoms[extBonds.indexOf(unit.bondConn[1])], inAtoms[extBonds.indexOf(unit.bondConn[3])]]);\n        }\n        else if (_util_Vec__WEBPACK_IMPORTED_MODULE_19__.Vec.len(extBonds) == 2 && unit.connect != null) {\n            if (unit.connect == _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_5__.PolymerBlockConnectivity.HeadToTail || unit.connect == _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_5__.PolymerBlockConnectivity.Random) {\n                innerLinks.push([inAtoms[0], inAtoms[1]]);\n            }\n            if (unit.connect == _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_5__.PolymerBlockConnectivity.HeadToHead || unit.connect == _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_5__.PolymerBlockConnectivity.Random) {\n                selfLinks.push(inAtoms[0]);\n                selfLinks.push(inAtoms[1]);\n            }\n        }\n        else {\n            for (let b of extBonds) {\n                let a1 = mol.bondFrom(b), a2 = mol.bondTo(b);\n                if (unit.atoms.includes(a2))\n                    [a1, a2] = [a2, a1];\n                let incl = unit.bondIncl.get(b), excl = unit.bondExcl.get(b);\n                let isCapped = mol.atomElement(a2) != _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_5__.POLYMERBLOCK_SPECIAL_UNCAPPED;\n                for (let look of (isCapped ? [unit] : allUnits))\n                    for (let a of look.atoms) {\n                        let isExt = false;\n                        for (let adj of mol.atomAdjList(a))\n                            if (!look.atoms.includes(adj)) {\n                                isExt = true;\n                                break;\n                            }\n                        if (!isExt)\n                            continue;\n                        if (_util_Vec__WEBPACK_IMPORTED_MODULE_19__.Vec.notBlank(incl)) {\n                            let anames = look.atomName.get(a), any = false;\n                            if (anames)\n                                for (let an of anames)\n                                    any = any || incl.includes(an);\n                            if (!any)\n                                continue;\n                        }\n                        if (_util_Vec__WEBPACK_IMPORTED_MODULE_19__.Vec.notBlank(excl)) {\n                            let anames = look.atomName.get(a), any = false;\n                            if (anames)\n                                for (let an of anames)\n                                    any = any || excl.includes(an);\n                            if (any)\n                                continue;\n                        }\n                        if (a == a1)\n                            selfLinks.push(a1);\n                        else if (unit === look)\n                            innerLinks.push([a1, a]);\n                        else\n                            outerLinks.push([a1, a]);\n                    }\n            }\n        }\n        selfLinks = _util_Vec__WEBPACK_IMPORTED_MODULE_19__.Vec.uniqueStable(selfLinks);\n        innerLinks = _util_Vec__WEBPACK_IMPORTED_MODULE_19__.Vec.maskGet(innerLinks, _util_Vec__WEBPACK_IMPORTED_MODULE_19__.Vec.maskUnique(innerLinks.map((pair) => _util_Vec__WEBPACK_IMPORTED_MODULE_19__.Vec.min(pair) * mol.numAtoms + _util_Vec__WEBPACK_IMPORTED_MODULE_19__.Vec.max(pair))));\n        outerLinks = _util_Vec__WEBPACK_IMPORTED_MODULE_19__.Vec.maskGet(outerLinks, _util_Vec__WEBPACK_IMPORTED_MODULE_19__.Vec.maskUnique(outerLinks.map((pair) => _util_Vec__WEBPACK_IMPORTED_MODULE_19__.Vec.min(pair) * mol.numAtoms + _util_Vec__WEBPACK_IMPORTED_MODULE_19__.Vec.max(pair))));\n        ctx.save();\n        ctx.strokeStyle = '#6329C1';\n        ctx.lineWidth = 2;\n        ctx.setLineDash([1, 1]);\n        ctx.beginPath();\n        for (let a of selfLinks) {\n            let p1 = layout.getPoint(a - 1), x1 = p1.oval.cx, y1 = p1.oval.cy;\n            let x2 = 0, y2 = 0, num = 0;\n            for (let n = 0; n < extBonds.length; n++)\n                if (inAtoms[n] == a) {\n                    let p2 = layout.getPoint(outAtoms[n] - 1);\n                    x2 += p2.oval.cx;\n                    y2 += p2.oval.cy;\n                    num++;\n                }\n            if (num > 1) {\n                x2 /= num;\n                y2 /= num;\n            }\n            x2 = x1 + 0.5 * (x2 - x1);\n            y2 = y1 + 0.5 * (y2 - y1);\n            let dx = x2 - x1, dy = y2 - y1, invD = (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.invZ)((0,_util_util__WEBPACK_IMPORTED_MODULE_18__.norm_xy)(dx, dy)), ox = dy * invD, oy = -dx * invD;\n            let cx = 0.5 * (x1 + x2), cy = 0.5 * (y1 + y2);\n            const EXT = 2 * scale;\n            ctx.moveTo(x1, y1);\n            ctx.quadraticCurveTo(cx + ox * EXT, cy + oy * EXT, x2, y2);\n            ctx.quadraticCurveTo(cx - ox * EXT, cy - oy * EXT, x1, y1);\n        }\n        for (let [a1, a2] of innerLinks) {\n            let x1 = mol.atomX(a1), y1 = mol.atomY(a1), x2 = mol.atomX(a2), y2 = mol.atomY(a2);\n            let dx = x2 - x1, dy = y2 - y1, invD = (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.invZ)((0,_util_util__WEBPACK_IMPORTED_MODULE_18__.norm_xy)(dx, dy)), ox = dy * invD, oy = -dx * invD;\n            let cx = 0.5 * (x1 + x2), cy = 0.5 * (y1 + y2);\n            const EXT = 5;\n            let px1 = cx + ox * EXT, py1 = cy + oy * EXT, px2 = cx - ox * EXT, py2 = cy - oy * EXT;\n            let [px, py] = _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.congestionPoint(mol, px1, py1) < _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.congestionPoint(mol, px2, py2) ? [px1, py1] : [px2, py2];\n            ctx.moveTo(this.angToX(x1), this.angToY(y1));\n            ctx.quadraticCurveTo(this.angToX(px), this.angToY(py), this.angToX(x2), this.angToY(y2));\n        }\n        for (let [a1, a2] of outerLinks) {\n            let p1 = layout.getPoint(a1 - 1), p2 = layout.getPoint(a2 - 1);\n            ctx.moveTo(p1.oval.cx, p1.oval.cy);\n            ctx.lineTo(p2.oval.cx, p2.oval.cy);\n        }\n        ctx.stroke();\n        ctx.restore();\n    }\n    determineFauxRing() {\n        let atom = this.opAtom, bond = this.opBond, mol = this.mol;\n        let x1 = atom > 0 ? mol.atomX(atom) : bond > 0 ? 0.5 * (mol.atomX(mol.bondFrom(bond)) + mol.atomX(mol.bondTo(bond))) : this.xToAng(this.clickX);\n        let y1 = atom > 0 ? mol.atomY(atom) : bond > 0 ? 0.5 * (mol.atomY(mol.bondFrom(bond)) + mol.atomY(mol.bondTo(bond))) : this.yToAng(this.clickY);\n        let x2 = this.xToAng(this.mouseX), y2 = this.yToAng(this.mouseY), dx = x2 - x1, dy = y2 - y1;\n        let rsz = Math.min(9, Math.round((0,_util_util__WEBPACK_IMPORTED_MODULE_18__.norm_xy)(dx, dy) * 2 / _data_Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule.IDEALBOND) + 2);\n        if (rsz < 3) { }\n        else if (bond > 0)\n            return _data_SketchUtil__WEBPACK_IMPORTED_MODULE_7__.SketchUtil.proposeBondRing(mol, rsz, bond, dx, dy);\n        else if (atom > 0 && mol.atomAdjCount(atom) > 0 && !this.toolRingFreeform)\n            return _data_SketchUtil__WEBPACK_IMPORTED_MODULE_7__.SketchUtil.proposeAtomRing(mol, rsz, atom, dx, dy);\n        else\n            return _data_SketchUtil__WEBPACK_IMPORTED_MODULE_7__.SketchUtil.proposeNewRing(mol, rsz, x1, y1, dx, dy, !this.toolRingFreeform);\n        return [null, null];\n    }\n    determineDragTheta() {\n        let x0 = this.clickX, y0 = this.clickY;\n        let snap = this.snapToGuide(x0, y0);\n        if (snap != null) {\n            x0 = snap[0];\n            y0 = snap[1];\n        }\n        let theta = Math.atan2(this.mouseY - y0, this.mouseX - x0), magnitude = (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.norm_xy)(this.mouseX - x0, this.mouseY - y0);\n        if (this.toolRotateIncr > 0)\n            theta = Math.round(theta / this.toolRotateIncr) * this.toolRotateIncr;\n        return [x0, y0, theta, magnitude];\n    }\n    determineMoveDelta() {\n        let x1 = this.clickX, y1 = this.clickY, x2 = this.mouseX, y2 = this.mouseY;\n        if (this.opAtom > 0) {\n            x1 = this.angToX(this.mol.atomX(this.opAtom));\n            y1 = this.angToY(this.mol.atomY(this.opAtom));\n            let snap = this.snapToGuide(x2, y2);\n            if (snap != null) {\n                x2 = snap[0];\n                y2 = snap[1];\n            }\n        }\n        return [x2 - x1, y2 - y1];\n    }\n    snapToGuide(x, y) {\n        if (this.opBond > 0) {\n            let obj = this.pickObject(x, y);\n            if (obj < 0) {\n                let [bfr, bto] = this.mol.bondFromTo(-obj);\n                let px = this.angToX(0.5 * (this.mol.atomX(bfr) + this.mol.atomX(bto)));\n                let py = this.angToY(0.5 * (this.mol.atomY(bfr) + this.mol.atomY(bto)));\n                return [px, py, false];\n            }\n            return null;\n        }\n        let bestDSQ = Number.POSITIVE_INFINITY, bestX = 0, bestY = 0, bestAtom = false;\n        const APPROACH = (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.sqr)(0.5 * this.pointScale);\n        if (this.dragGuides != null)\n            for (let i = 0; i < this.dragGuides.length; i++)\n                for (let j = 0; j < this.dragGuides[i].x.length; j++) {\n                    let px = this.dragGuides[i].destX[j], py = this.dragGuides[i].destY[j];\n                    let dsq = (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.norm2_xy)(px - x, py - y);\n                    if (dsq < APPROACH && dsq < bestDSQ)\n                        [bestDSQ, bestX, bestY, bestAtom] = [dsq, px, py, false];\n                }\n        for (let n = 1; n <= this.mol.numAtoms; n++) {\n            let px = this.angToX(this.mol.atomX(n)), py = this.angToY(this.mol.atomY(n));\n            let dsq = (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.norm2_xy)(px - x, py - y);\n            if (dsq < APPROACH && dsq < bestDSQ)\n                [bestDSQ, bestX, bestY, bestAtom] = [dsq, px, py, true];\n        }\n        if (isFinite(bestDSQ))\n            return [bestX, bestY, bestAtom];\n        return null;\n    }\n    pickObjectCanvas(x, y, opt = {}) {\n        let limitDist = 0.5 * this.pointScale;\n        let bestItem = 0, bestScore = Number.POSITIVE_INFINITY;\n        if (!opt.noAtoms)\n            for (let n = 0; n < this.layout.numPoints(); n++) {\n                let p = this.layout.getPoint(n);\n                if (p.anum == 0)\n                    continue;\n                let dx = Math.abs(x - p.oval.cx), dy = Math.abs(y - p.oval.cy);\n                let dsq = (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.norm2_xy)(dx, dy);\n                let limitDSQ = (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.sqr)(Math.max(limitDist, Math.max(p.oval.rw, p.oval.rh)));\n                if (dsq > limitDSQ)\n                    continue;\n                if (dsq < bestScore) {\n                    bestItem = p.anum;\n                    bestScore = dsq;\n                }\n            }\n        if (bestItem != 0)\n            return bestItem;\n        if (!opt.noBonds)\n            for (let n = 0; n < this.layout.numLines(); n++) {\n                let l = this.layout.getLine(n);\n                if (l.bnum == 0)\n                    continue;\n                let x1 = l.line.x1, y1 = l.line.y1;\n                let x2 = l.line.x2, y2 = l.line.y2;\n                if (x < Math.min(x1, x2) - limitDist || y < Math.min(y1, y2) - limitDist ||\n                    x > Math.max(x1, x2) + limitDist || y > Math.max(y1, y2) + limitDist)\n                    continue;\n                let dist = _util_Geom__WEBPACK_IMPORTED_MODULE_16__.GeomUtil.pointLineSegDistance(x, y, x1, y1, x2, y2);\n                if (dist > limitDist)\n                    continue;\n                if (dist < bestScore) {\n                    bestItem = -l.bnum;\n                    bestScore = dist;\n                }\n            }\n        return bestItem;\n    }\n    pickObject(x, y, opt = {}) {\n        return this.pickObjectCanvas(x, y, opt) || 0;\n    }\n    sketchEffects(mol) {\n        let effects = new _gfx_Rendering__WEBPACK_IMPORTED_MODULE_13__.RenderEffects();\n        for (let n = 1; n <= mol.numAtoms; n++)\n            if (_data_MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.hasAbbrev(mol, n) && n != this.hoverAtom)\n                effects.dottedRectOutline[n] = 0x808080;\n        effects.overlapAtoms = _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.overlappingAtomList(mol, 0.2);\n        effects.atomDecoText = _util_Vec__WEBPACK_IMPORTED_MODULE_19__.Vec.stringArray('', mol.numAtoms);\n        effects.atomDecoCol = _util_Vec__WEBPACK_IMPORTED_MODULE_19__.Vec.numberArray(_util_Theme__WEBPACK_IMPORTED_MODULE_17__.Theme.foreground, mol.numAtoms);\n        effects.atomDecoSize = _util_Vec__WEBPACK_IMPORTED_MODULE_19__.Vec.numberArray(0.3, mol.numAtoms);\n        effects.bondDecoText = _util_Vec__WEBPACK_IMPORTED_MODULE_19__.Vec.stringArray('', mol.numBonds);\n        effects.bondDecoCol = _util_Vec__WEBPACK_IMPORTED_MODULE_19__.Vec.numberArray(_util_Theme__WEBPACK_IMPORTED_MODULE_17__.Theme.foreground, mol.numBonds);\n        effects.bondDecoSize = _util_Vec__WEBPACK_IMPORTED_MODULE_19__.Vec.numberArray(0.3, mol.numBonds);\n        if (this.viewOpt.showOxState) {\n            for (let n = 1; n <= mol.numAtoms; n++) {\n                let ox = _data_MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.atomOxidationState(mol, n);\n                if (ox != null) {\n                    effects.atomDecoText[n - 1] = _data_MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.oxidationStateText(ox);\n                    effects.atomDecoCol[n - 1] = 0xFF8080;\n                }\n            }\n        }\n        if (this.viewOpt.decoration == DrawCanvasDecoration.Stereochemistry) {\n            if (!this.stereo)\n                this.stereo = _data_Stereochemistry__WEBPACK_IMPORTED_MODULE_8__.Stereochemistry.create(_data_MetaMolecule__WEBPACK_IMPORTED_MODULE_2__.MetaMolecule.createStrict(mol));\n            skip: for (let n = 1; n <= mol.numAtoms; n++) {\n                let chi = this.stereo.atomTetraChirality(n);\n                if (chi == _data_Stereochemistry__WEBPACK_IMPORTED_MODULE_8__.Stereochemistry.STEREO_NONE)\n                    continue;\n                for (let adjb of mol.atomAdjBonds(n))\n                    if (mol.bondOrder(adjb) != 1)\n                        continue skip;\n                if (chi == _data_Stereochemistry__WEBPACK_IMPORTED_MODULE_8__.Stereochemistry.STEREO_UNKNOWN) {\n                    for (let adj of mol.atomAdjList(n))\n                        if (_data_Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_BLOCKS[mol.atomicNumber(adj)] >= 3)\n                            continue skip;\n                }\n                effects.atomDecoText[n - 1] = chi == _data_Stereochemistry__WEBPACK_IMPORTED_MODULE_8__.Stereochemistry.STEREO_POS ? 'R' :\n                    chi == _data_Stereochemistry__WEBPACK_IMPORTED_MODULE_8__.Stereochemistry.STEREO_NEG ? 'S' :\n                        chi == _data_Stereochemistry__WEBPACK_IMPORTED_MODULE_8__.Stereochemistry.STEREO_UNKNOWN ? 'R/S' : '?';\n                effects.atomDecoCol[n - 1] = 0x00A000;\n            }\n            for (let n = 1; n <= mol.numBonds; n++) {\n                let side = this.stereo.bondSideStereo(n);\n                if (side == _data_Stereochemistry__WEBPACK_IMPORTED_MODULE_8__.Stereochemistry.STEREO_NONE)\n                    continue;\n                effects.bondDecoText[n - 1] = side == _data_Stereochemistry__WEBPACK_IMPORTED_MODULE_8__.Stereochemistry.STEREO_POS ? 'Z' :\n                    side == _data_Stereochemistry__WEBPACK_IMPORTED_MODULE_8__.Stereochemistry.STEREO_NEG ? 'E' :\n                        side == _data_Stereochemistry__WEBPACK_IMPORTED_MODULE_8__.Stereochemistry.STEREO_UNKNOWN ? 'Z/E' : '?';\n                effects.bondDecoCol[n - 1] = 0x00A000;\n            }\n        }\n        else if (this.viewOpt.decoration == DrawCanvasDecoration.MappingNumber) {\n            effects.atomDecoText = _util_Vec__WEBPACK_IMPORTED_MODULE_19__.Vec.stringArray('', mol.numAtoms);\n            effects.atomDecoCol = _util_Vec__WEBPACK_IMPORTED_MODULE_19__.Vec.numberArray(0x8000FF, mol.numAtoms);\n            effects.atomDecoSize = _util_Vec__WEBPACK_IMPORTED_MODULE_19__.Vec.numberArray(0.3, mol.numAtoms);\n            for (let n = 1; n <= mol.numAtoms; n++)\n                if (mol.atomMapNum(n) > 0)\n                    effects.atomDecoText[n - 1] = mol.atomMapNum(n).toString();\n        }\n        else if (this.viewOpt.decoration == DrawCanvasDecoration.AtomIndex) {\n            effects.atomDecoText = _util_Vec__WEBPACK_IMPORTED_MODULE_19__.Vec.stringArray('', mol.numAtoms);\n            effects.atomDecoCol = _util_Vec__WEBPACK_IMPORTED_MODULE_19__.Vec.numberArray(0x8000FF, mol.numAtoms);\n            effects.atomDecoSize = _util_Vec__WEBPACK_IMPORTED_MODULE_19__.Vec.numberArray(0.3, mol.numAtoms);\n            for (let n = 1; n <= mol.numAtoms; n++)\n                effects.atomDecoText[n - 1] = n.toString();\n        }\n        return effects;\n    }\n    orientAbbreviation(abbrevAtom, abbrevMol) {\n        const { mol } = this;\n        if (_data_MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.isBlank(abbrevMol))\n            return;\n        if (this.mol.atomAdjCount(abbrevAtom) != 1)\n            return;\n        let nbr = mol.atomAdjList(abbrevAtom)[0];\n        let vx1 = mol.atomX(abbrevAtom) - mol.atomX(nbr), vy1 = mol.atomY(abbrevAtom) - mol.atomY(nbr);\n        let adj = abbrevMol.atomAdjList(1);\n        let vx2 = 0, vy2 = 0, inv = (0,_util_util__WEBPACK_IMPORTED_MODULE_18__.invZ)(adj.length);\n        for (let a of adj) {\n            vx2 += abbrevMol.atomX(a) - abbrevMol.atomX(1);\n            vy2 += abbrevMol.atomY(a) - abbrevMol.atomY(1);\n        }\n        vx2 *= inv;\n        vy2 *= inv;\n        let th1 = Math.atan2(vy1, vx1), th2 = Math.atan2(vy2, vx2);\n        _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.rotateMolecule(abbrevMol, th1 - th2);\n        if (adj.length == 1) {\n            _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.translateMolecule(abbrevMol, mol.atomX(abbrevAtom) - abbrevMol.atomX(adj[0]), mol.atomY(abbrevAtom) - abbrevMol.atomY(adj[0]));\n            abbrevMol.setAtomPos(1, mol.atomX(nbr), mol.atomY(nbr));\n        }\n        else {\n            _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.translateMolecule(abbrevMol, mol.atomX(nbr) - abbrevMol.atomX(1), mol.atomY(nbr) - abbrevMol.atomY(1));\n        }\n        for (let b of abbrevMol.atomAdjBonds(1)) {\n            let a = abbrevMol.bondOther(b, 1);\n            if (abbrevMol.atomHExplicit(a) != _data_Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule.HEXPLICIT_UNKNOWN)\n                continue;\n            abbrevMol.setAtomHExplicit(a, Math.max(0, abbrevMol.atomHydrogens(a)));\n        }\n        abbrevMol.deleteAtomAndBonds(1);\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/sketcher/DrawCanvas.ts?");

/***/ }),

/***/ "./src/sketcher/EditAtom.ts":
/*!**********************************!*\
  !*** ./src/sketcher/EditAtom.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EditAtom\": () => (/* binding */ EditAtom)\n/* harmony export */ });\n/* harmony import */ var _data_AbbrevContainer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/AbbrevContainer */ \"./src/data/AbbrevContainer.ts\");\n/* harmony import */ var _data_Molecule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/Molecule */ \"./src/data/Molecule.ts\");\n/* harmony import */ var _data_MolUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data/MolUtil */ \"./src/data/MolUtil.ts\");\n/* harmony import */ var _dialog_Dialog__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dialog/Dialog */ \"./src/dialog/Dialog.ts\");\n/* harmony import */ var _gfx_ArrangeMeasurement__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../gfx/ArrangeMeasurement */ \"./src/gfx/ArrangeMeasurement.ts\");\n/* harmony import */ var _gfx_ArrangeMolecule__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../gfx/ArrangeMolecule */ \"./src/gfx/ArrangeMolecule.ts\");\n/* harmony import */ var _gfx_DrawMolecule__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../gfx/DrawMolecule */ \"./src/gfx/DrawMolecule.ts\");\n/* harmony import */ var _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../gfx/MetaVector */ \"./src/gfx/MetaVector.ts\");\n/* harmony import */ var _gfx_Rendering__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../gfx/Rendering */ \"./src/gfx/Rendering.ts\");\n/* harmony import */ var _ui_ClipboardProxy__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../ui/ClipboardProxy */ \"./src/ui/ClipboardProxy.ts\");\n/* harmony import */ var _ui_OptionList__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../ui/OptionList */ \"./src/ui/OptionList.ts\");\n/* harmony import */ var _ui_TabBar__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../ui/TabBar */ \"./src/ui/TabBar.ts\");\n/* harmony import */ var _util_dom__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../util/dom */ \"./src/util/dom.ts\");\n/* harmony import */ var _util_Theme__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../util/Theme */ \"./src/util/Theme.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _ExtraFieldsWidget__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./ExtraFieldsWidget */ \"./src/sketcher/ExtraFieldsWidget.ts\");\n/* harmony import */ var _GeomWidget__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./GeomWidget */ \"./src/sketcher/GeomWidget.ts\");\n/* harmony import */ var _MoleculeActivity__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./MoleculeActivity */ \"./src/sketcher/MoleculeActivity.ts\");\n/* harmony import */ var _PeriodicTableWidget__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./PeriodicTableWidget */ \"./src/sketcher/PeriodicTableWidget.ts\");\n/* harmony import */ var _QueryFieldsWidget__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./QueryFieldsWidget */ \"./src/sketcher/QueryFieldsWidget.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass EditAtom extends _dialog_Dialog__WEBPACK_IMPORTED_MODULE_3__.Dialog {\n    constructor(mol, atom, proxyClip, callbackApply) {\n        super();\n        this.atom = atom;\n        this.proxyClip = proxyClip;\n        this.callbackApply = callbackApply;\n        this.newX = 0;\n        this.newY = 0;\n        this.tabs = null;\n        this.abbrevList = null;\n        this.svgAbbrev = null;\n        this.abbrevIndices = [];\n        this.currentAbbrev = -1;\n        this.initMol = mol;\n        this.mol = mol.clone();\n        this.title = 'Edit Atom';\n        this.minPortionWidth = 20;\n        this.maxPortionWidth = 95;\n    }\n    populate() {\n        this.proxyClip.pushHandler(new _ui_ClipboardProxy__WEBPACK_IMPORTED_MODULE_9__.ClipboardProxyHandler());\n        let buttons = this.buttonsDOM(), body = this.bodyDOM();\n        this.btnApply = (0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<button class=\"wmk-button wmk-button-primary\">Apply</button>').appendTo(buttons).css({ 'margin-left': '0.5em' });\n        this.btnApply.onClick(() => this.applyChanges());\n        if (this.atom > 0) {\n            this.tabs = new _ui_TabBar__WEBPACK_IMPORTED_MODULE_11__.TabBar(['Atom', 'Abbreviation', 'Geometry', 'Query', 'Extra']);\n            this.tabs.render(body);\n            this.tabs.onSelect((idx) => this.selectedTab(idx));\n            this.populateAtom(this.tabs.getPanelDOM('Atom'));\n            this.populateAbbreviation(this.tabs.getPanelDOM('Abbreviation'));\n            if (this.atom > 0)\n                this.populateGeometry(this.tabs.getPanelDOM('Geometry'));\n            this.populateQuery(this.tabs.getPanelDOM('Query'));\n            this.populateExtra(this.tabs.getPanelDOM('Extra'));\n        }\n        else {\n            this.populateAtom(body);\n        }\n        let focusable = body.findAll('input,textarea');\n        if (focusable.length > 0)\n            focusable[0].grabFocus(true);\n        for (let dom of focusable) {\n            dom.css({ 'font': 'inherit' });\n            dom.onKeyDown((event) => {\n                if (event.key == \"Enter\")\n                    this.applyChanges();\n                else if (event.key == \"Escape\")\n                    this.close();\n                else if (event.key == \"PageUp\") {\n                    this.tabs.rotateSelected(-1);\n                    this.selectedTab(this.tabs.getSelectedIndex());\n                    event.preventDefault();\n                }\n                else if (event.key == \"PageDown\") {\n                    this.tabs.rotateSelected(1);\n                    this.selectedTab(this.tabs.getSelectedIndex());\n                    event.preventDefault();\n                }\n                event.stopPropagation();\n            });\n        }\n    }\n    close() {\n        this.proxyClip.popHandler();\n        super.close();\n    }\n    applyChanges() {\n        this.mol.keepTransient = true;\n        this.updateMolecule();\n        let selTab = this.tabs ? this.tabs.getSelectedValue() : null;\n        if (selTab == 'Abbreviation')\n            this.updateAbbrev();\n        if (selTab == 'Geometry')\n            this.updateGeometry();\n        if (selTab == 'Query')\n            this.updateQuery();\n        if (selTab == 'Extra')\n            this.updateExtra();\n        this.mol.keepTransient = false;\n        if (this.callbackApply)\n            this.callbackApply(this);\n    }\n    populateAtom(panel) {\n        let grid = (0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<div/>').appendTo(panel);\n        grid.css({ 'display': 'grid', 'align-items': 'center', 'justify-content': 'start' });\n        grid.css({ 'grid-row-gap': '0.5em', 'grid-column-gap': '0.5em' });\n        grid.css({ 'grid-template-columns': '[start col0] auto [col1] auto [col2] auto [col3] auto [col4 end]' });\n        grid.appendHTML('<div style=\"grid-area: 1 / col0;\">Symbol</div>');\n        this.inputSymbol = (0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<input size=\"20\"/>').appendTo(grid);\n        this.inputSymbol.css({ 'grid-area': '1 / col1 / auto / col4}' });\n        this.inputSymbol.onInput(() => this.periodicWidget.changeElement(this.inputSymbol.getValue()));\n        grid.appendHTML('<div style=\"grid-area: 2 / col0;\">Charge</div>');\n        this.inputCharge = (0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<input type=\"number\" size=\"6\"/>').appendTo(grid);\n        this.inputCharge.css({ 'grid-area': '2 / col1' });\n        grid.appendHTML('<div style=\"grid-area: 2 / col2;\">Unpaired</div>');\n        this.inputUnpaired = (0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<input type=\"number\" size=\"6\"/>').appendTo(grid);\n        this.inputUnpaired.css({ 'grid-area': '2 / col3' });\n        grid.appendHTML('<div style=\"grid-area: 3 / col0;\">Hydrogens</div>');\n        this.optionHydrogen = new _ui_OptionList__WEBPACK_IMPORTED_MODULE_10__.OptionList(['Auto', 'None', '1', '2', '3', '4', 'Other']);\n        this.optionHydrogen.render((0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<div style=\"grid-area: 3 / col1 / auto / col3\"/>').appendTo(grid));\n        this.optionHydrogen.onSelect((idx) => this.inputHydrogen.elInput.disabled = idx != 6);\n        this.inputHydrogen = (0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<input type=\"number\" size=\"4\"/>').appendTo(grid);\n        this.inputHydrogen.css({ 'grid-area': '3 / col3' });\n        this.inputHydrogen.elInput.disabled = true;\n        grid.appendHTML('<div style=\"grid-area: 4 / col0;\">Isotope</div>');\n        this.optionIsotope = new _ui_OptionList__WEBPACK_IMPORTED_MODULE_10__.OptionList(['Natural', 'Enriched']);\n        this.optionIsotope.render((0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<div style=\"grid-area: 4 / col1 / auto / col3\"/>').appendTo(grid));\n        this.optionIsotope.onSelect((idx) => this.inputIsotope.elInput.disabled = idx == 0);\n        this.inputIsotope = (0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<input type=\"number\" size=\"6\"/>').appendTo(grid);\n        this.inputIsotope.css({ 'grid-area': '4 / col3' });\n        this.inputIsotope.elInput.disabled = true;\n        grid.appendHTML('<div style=\"grid-area: 5 / col0;\">Mapping</div>');\n        this.inputMapping = (0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<input type=\"number\" size=\"6\"/>').appendTo(grid);\n        this.inputMapping.css({ 'grid-area': '5 / col1' });\n        grid.appendHTML('<div style=\"grid-area: 5 / col2;\">Index</div>');\n        this.inputIndex = (0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<input type=\"number\" size=\"6\" readonly=\"readonly\"/>').appendTo(grid);\n        this.inputIndex.css({ 'grid-area': '5 / col3' });\n        let divPeriodic = (0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<div/>').appendTo(grid).css({ 'grid-area': '6 / start / 6 / end' });\n        this.periodicWidget = new _PeriodicTableWidget__WEBPACK_IMPORTED_MODULE_19__.PeriodicTableWidget();\n        this.periodicWidget.onSelect((element) => this.inputSymbol.setValue(element));\n        this.periodicWidget.onDoubleClick(() => this.applyChanges());\n        this.periodicWidget.render(divPeriodic);\n        const mol = this.mol, atom = this.atom;\n        if (atom > 0) {\n            this.inputSymbol.setValue(mol.atomElement(atom));\n            this.inputCharge.setValue(mol.atomCharge(atom).toString());\n            this.inputUnpaired.setValue(mol.atomUnpaired(atom).toString());\n            let hc = mol.atomHExplicit(atom);\n            if (hc == _data_Molecule__WEBPACK_IMPORTED_MODULE_1__.Molecule.HEXPLICIT_UNKNOWN) {\n                this.optionHydrogen.setSelectedIndex(0);\n                this.inputHydrogen.setValue(mol.atomHydrogens(atom).toString());\n                this.inputHydrogen.elInput.disabled = true;\n            }\n            else if (hc <= 4) {\n                this.optionHydrogen.setSelectedIndex(hc + 1);\n                this.inputHydrogen.setValue(hc.toString());\n                this.inputHydrogen.elInput.disabled = true;\n            }\n            else {\n                this.optionHydrogen.setSelectedIndex(6);\n                this.inputHydrogen.setValue(hc.toString());\n                this.inputHydrogen.elInput.disabled = false;\n            }\n            this.optionIsotope.setSelectedIndex(mol.atomIsotope(atom) == _data_Molecule__WEBPACK_IMPORTED_MODULE_1__.Molecule.ISOTOPE_NATURAL ? 0 : 1);\n            if (mol.atomIsotope(atom) != _data_Molecule__WEBPACK_IMPORTED_MODULE_1__.Molecule.ISOTOPE_NATURAL)\n                this.inputIsotope.setValue(mol.atomIsotope(atom).toString());\n            this.inputIsotope.elInput.disabled = mol.atomIsotope(atom) == _data_Molecule__WEBPACK_IMPORTED_MODULE_1__.Molecule.ISOTOPE_NATURAL;\n            this.inputMapping.setValue(mol.atomMapNum(atom).toString());\n            this.inputIndex.setValue(atom.toString());\n            this.periodicWidget.changeElement(mol.atomElement(atom));\n        }\n    }\n    populateAbbreviation(panel) {\n        let divFlex = (0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<div/>').appendTo(panel).css({ 'display': 'flex', 'align-items': 'flex-start' });\n        divFlex.css({ 'max-width': '60vw', 'max-height': '50vh', 'overflow-y': 'scroll' });\n        let spanSearch = (0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<div/>').appendTo(divFlex).css({ 'margin-right': '0.5em', 'flex': '0 0' });\n        let spanList = (0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<div/>').appendTo(divFlex).css({ 'flex': '1 1 100%' });\n        this.inputAbbrevSearch = (0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<input size=\"10\"/>').appendTo(spanSearch);\n        this.inputAbbrevSearch.setAttr('placeholder', 'Search');\n        let lastSearch = '';\n        this.inputAbbrevSearch.onKeyDown((event) => {\n            if (event.key == \"ArrowUp\")\n                this.cycleAbbreviation(-1);\n            else if (event.key == \"ArrowDown\")\n                this.cycleAbbreviation(1);\n        });\n        this.inputAbbrevSearch.onInput(() => {\n            let search = this.inputAbbrevSearch.getValue();\n            if (search == lastSearch)\n                return;\n            lastSearch = search;\n            this.fillAbbreviations();\n        });\n        let divButtons = (0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<div/>').appendTo(spanSearch).css({ 'margin-top': '0.5em' });\n        let btnClear = (0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<button class=\"wmk-button wmk-button-default\">Clear</button>').appendTo(divButtons);\n        btnClear.onClick(() => {\n            this.selectAbbreviation(-1);\n            if (this.atom > 0 && _data_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.hasAbbrev(this.mol, this.atom))\n                this.applyChanges();\n        });\n        this.tableAbbrev = (0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<table/>').appendTo(spanList).css({ 'border-collapse': 'collapse', 'width': '100%' });\n        this.fillAbbreviations();\n    }\n    populateGeometry(panel) {\n        const { mol, atom } = this;\n        let divContainer1 = (0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<div/>').appendTo(panel).css({ 'text-align': 'center' });\n        let divContainer2 = (0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<div/>').appendTo(divContainer1).css({ 'display': 'inline-block' });\n        let grid = (0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<div/>').appendTo(divContainer2);\n        grid.css({ 'display': 'grid', 'align-items': 'center', 'justify-content': 'start' });\n        grid.css({ 'grid-row-gap': '0.5em', 'grid-column-gap': '0.5em' });\n        grid.css({ 'grid-template-columns': '[start col0] auto [col1] auto [col2] auto [col3] auto [col4 end]' });\n        this.geomWidget = new _GeomWidget__WEBPACK_IMPORTED_MODULE_17__.GeomWidget(_GeomWidget__WEBPACK_IMPORTED_MODULE_17__.GeomWidgetType.Atom, mol, atom);\n        this.geomWidget.render((0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<div/>').appendTo(grid).css({ 'grid-area': '1 / col0 / auto / col4', 'text-align': 'center' }));\n        let label1 = (0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<div/>').appendTo(grid).css({ 'grid-area': '2 / col0' });\n        this.inputGeom1 = (0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<input type=\"number\" size=\"8\"/>').appendTo(grid).css({ 'grid-area': '2 / col1' });\n        let label2 = (0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<div/>').appendTo(grid).css({ 'grid-area': '2 / col2' });\n        this.inputGeom2 = (0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<input type=\"number\" size=\"8\"/>').appendTo(grid).css({ 'grid-area': '2 / col3' });\n        this.geomWidget.callbackSelect = (sel) => {\n            let atoms = this.geomWidget.selectionAtoms(sel);\n            if (sel.type == _GeomWidget__WEBPACK_IMPORTED_MODULE_17__.GeomWidgetSelType.Position) {\n                label1.setText('Position X');\n                label2.setText('Y');\n                this.inputGeom1.setValue(this.refGeom1 = mol.atomX(atoms[0]).toFixed(3));\n                this.inputGeom2.setValue(this.refGeom2 = mol.atomY(atoms[0]).toFixed(3));\n            }\n            else if (sel.type == _GeomWidget__WEBPACK_IMPORTED_MODULE_17__.GeomWidgetSelType.Link) {\n                let dx = mol.atomX(atoms[1]) - mol.atomX(atoms[0]), dy = mol.atomY(atoms[1]) - mol.atomY(atoms[0]);\n                label1.setText('Distance');\n                label2.setText('Angle');\n                this.inputGeom1.setValue(this.refGeom1 = (0,_util_util__WEBPACK_IMPORTED_MODULE_14__.norm_xy)(dx, dy).toFixed(3));\n                this.inputGeom2.setValue(this.refGeom2 = (Math.atan2(dy, dx) * _util_util__WEBPACK_IMPORTED_MODULE_14__.RADDEG).toFixed(1));\n            }\n            else if (sel.type == _GeomWidget__WEBPACK_IMPORTED_MODULE_17__.GeomWidgetSelType.Torsion) {\n                let cx = mol.atomX(atoms[0]), cy = mol.atomY(atoms[0]);\n                let th2 = Math.atan2(mol.atomY(atoms[1]) - cy, mol.atomX(atoms[1]) - cx);\n                let th1 = Math.atan2(mol.atomY(atoms[2]) - cy, mol.atomX(atoms[2]) - cx);\n                label1.setText('Angle');\n                label2.setText('');\n                this.inputGeom1.setValue(this.refGeom1 = ((0,_util_util__WEBPACK_IMPORTED_MODULE_14__.angleDiffPos)(th2, th1) * _util_util__WEBPACK_IMPORTED_MODULE_14__.RADDEG).toFixed(1));\n                this.inputGeom2.setValue(this.refGeom2 = '');\n            }\n            label2.setCSS('display', sel.type == _GeomWidget__WEBPACK_IMPORTED_MODULE_17__.GeomWidgetSelType.Torsion ? 'none' : 'block');\n            this.inputGeom2.setCSS('display', sel.type == _GeomWidget__WEBPACK_IMPORTED_MODULE_17__.GeomWidgetSelType.Torsion ? 'none' : 'block');\n        };\n        this.geomWidget.callbackSelect(this.geomWidget.selected);\n    }\n    populateQuery(panel) {\n        this.queryWidget = new _QueryFieldsWidget__WEBPACK_IMPORTED_MODULE_20__.QueryFieldsWidget(this.mol, this.atom, 0);\n        this.queryWidget.render(panel);\n    }\n    populateExtra(panel) {\n        let fields = [...this.mol.atomExtra(this.atom), ...this.mol.atomTransient(this.atom)];\n        this.fieldsWidget = new _ExtraFieldsWidget__WEBPACK_IMPORTED_MODULE_16__.ExtraFieldsWidget(fields);\n        this.fieldsWidget.render(panel);\n    }\n    updateMolecule() {\n        let { mol, atom } = this;\n        if (atom == 0)\n            atom = this.atom = mol.addAtom('C', this.newX, this.newY);\n        let sym = this.inputSymbol.getValue();\n        if (sym != '')\n            mol.setAtomElement(atom, sym);\n        let chg = parseInt(this.inputCharge.getValue());\n        if (chg > -20 && chg < 20)\n            mol.setAtomCharge(atom, chg);\n        let unp = parseInt(this.inputUnpaired.getValue());\n        if (unp >= 0 && unp < 20)\n            mol.setAtomUnpaired(atom, unp);\n        let hcidx = this.optionHydrogen.getSelectedIndex();\n        if (hcidx == 0)\n            mol.setAtomHExplicit(atom, _data_Molecule__WEBPACK_IMPORTED_MODULE_1__.Molecule.HEXPLICIT_UNKNOWN);\n        else if (hcidx <= 5)\n            mol.setAtomHExplicit(atom, hcidx - 1);\n        else {\n            let hyd = parseInt(this.inputHydrogen.getValue());\n            if (hyd >= 0 && hyd < 20)\n                mol.setAtomHExplicit(atom, hyd);\n        }\n        if (this.optionIsotope.getSelectedIndex() == 1) {\n            let iso = parseInt(this.inputIsotope.getValue());\n            if (iso >= 0 && iso < 300)\n                mol.setAtomIsotope(atom, iso);\n        }\n        else\n            mol.setAtomIsotope(atom, _data_Molecule__WEBPACK_IMPORTED_MODULE_1__.Molecule.ISOTOPE_NATURAL);\n        let map = parseInt(this.inputMapping.getValue());\n        if (!isNaN(map))\n            mol.setAtomMapNum(atom, map);\n    }\n    updateAbbrev() {\n        const { mol, atom } = this;\n        if (this.currentAbbrev < 0) {\n            let el = mol.atomElement(atom);\n            _data_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.clearAbbrev(mol, atom);\n            mol.setAtomElement(atom, el);\n        }\n        else {\n            let abbrev = this.abbrevList[this.currentAbbrev];\n            mol.setAtomElement(atom, abbrev.name);\n            _data_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.setAbbrev(mol, atom, abbrev.frag);\n        }\n    }\n    updateGeometry() {\n        let strval1 = this.inputGeom1.getValue(), strval2 = this.inputGeom2.getValue();\n        if (this.refGeom1 == strval1 && this.refGeom2 == strval2)\n            return;\n        const { mol } = this;\n        let sel = this.geomWidget.selected, atoms = this.geomWidget.selectionAtoms(sel);\n        if (sel.type == _GeomWidget__WEBPACK_IMPORTED_MODULE_17__.GeomWidgetSelType.Position) {\n            let x = parseFloat(strval1), y = parseFloat(strval2);\n            if (isNaN(x) || isNaN(y) || Math.abs(x) > 1E6 || Math.abs(y) > 1E6)\n                return;\n            mol.setAtomPos(atoms[0], x, y);\n        }\n        else if (sel.type == _GeomWidget__WEBPACK_IMPORTED_MODULE_17__.GeomWidgetSelType.Link) {\n            if (this.refGeom1 != strval1) {\n                let dist = parseFloat(strval1);\n                if (isNaN(dist) || Math.abs(dist) > 100)\n                    return;\n                let mask = _util_Vec__WEBPACK_IMPORTED_MODULE_15__.Vec.booleanArray(false, mol.numAtoms);\n                mask[atoms[1] - 1] = true;\n                let instate = { 'mol': mol, 'currentAtom': 0, 'currentBond': mol.findBond(atoms[0], atoms[1]), 'selectedMask': mask };\n                let molact = new _MoleculeActivity__WEBPACK_IMPORTED_MODULE_18__.MoleculeActivity(instate, _MoleculeActivity__WEBPACK_IMPORTED_MODULE_18__.ActivityType.BondDist, { 'dist': dist });\n                molact.execute();\n                if (molact.output.mol)\n                    this.mol = molact.output.mol;\n                return;\n            }\n            else if (this.refGeom2 != strval2) {\n                let angle = parseFloat(strval2);\n                if (isNaN(angle))\n                    return;\n                let mask = _util_Vec__WEBPACK_IMPORTED_MODULE_15__.Vec.booleanArray(false, mol.numAtoms);\n                mask[atoms[1] - 1] = true;\n                let instate = { 'mol': mol, 'currentAtom': 0, 'currentBond': mol.findBond(atoms[0], atoms[1]), 'selectedMask': mask };\n                let molact = new _MoleculeActivity__WEBPACK_IMPORTED_MODULE_18__.MoleculeActivity(instate, _MoleculeActivity__WEBPACK_IMPORTED_MODULE_18__.ActivityType.AlignAngle, { 'angle': angle * _util_util__WEBPACK_IMPORTED_MODULE_14__.DEGRAD });\n                molact.execute();\n                if (molact.output.mol)\n                    this.mol = molact.output.mol;\n                return;\n            }\n        }\n        else if (sel.type == _GeomWidget__WEBPACK_IMPORTED_MODULE_17__.GeomWidgetSelType.Torsion) {\n            let angle = parseFloat(strval1);\n            if (isNaN(angle))\n                return;\n            let mask = _util_Vec__WEBPACK_IMPORTED_MODULE_15__.Vec.booleanArray(false, mol.numAtoms);\n            for (let a of atoms)\n                mask[a - 1] = true;\n            let instate = { 'mol': mol, 'currentAtom': atoms[2], 'currentBond': 0, 'selectedMask': mask };\n            let molact = new _MoleculeActivity__WEBPACK_IMPORTED_MODULE_18__.MoleculeActivity(instate, _MoleculeActivity__WEBPACK_IMPORTED_MODULE_18__.ActivityType.AdjustTorsion, { 'angle': angle * _util_util__WEBPACK_IMPORTED_MODULE_14__.DEGRAD });\n            molact.execute();\n            if (molact.output.mol)\n                this.mol = molact.output.mol;\n            return;\n        }\n    }\n    updateQuery() {\n        this.queryWidget.updateAtom();\n    }\n    updateExtra() {\n        this.mol.setAtomExtra(this.atom, this.fieldsWidget.getExtraFields());\n        this.mol.setAtomTransient(this.atom, this.fieldsWidget.getTransientFields());\n    }\n    fillAbbreviations() {\n        if (_data_AbbrevContainer__WEBPACK_IMPORTED_MODULE_0__.AbbrevContainer.needsSetup()) {\n            setTimeout(() => _data_AbbrevContainer__WEBPACK_IMPORTED_MODULE_0__.AbbrevContainer.setupData().then(() => this.fillAbbreviations()), 1);\n            return;\n        }\n        this.tableAbbrev.empty();\n        _data_AbbrevContainer__WEBPACK_IMPORTED_MODULE_0__.AbbrevContainer.main.submitMolecule(this.mol, true);\n        this.abbrevList = _data_AbbrevContainer__WEBPACK_IMPORTED_MODULE_0__.AbbrevContainer.main.getAbbrevs();\n        if (!this.svgAbbrev) {\n            this.svgAbbrev = [];\n            let policy = _gfx_Rendering__WEBPACK_IMPORTED_MODULE_8__.RenderPolicy.defaultColourOnWhite(10);\n            let measure = new _gfx_ArrangeMeasurement__WEBPACK_IMPORTED_MODULE_4__.OutlineMeasurement(0, 0, policy.data.pointScale);\n            for (let abbrev of this.abbrevList) {\n                let effects = new _gfx_Rendering__WEBPACK_IMPORTED_MODULE_8__.RenderEffects();\n                let mol = abbrev.frag.clone();\n                effects.atomCircleSz = _util_Vec__WEBPACK_IMPORTED_MODULE_15__.Vec.numberArray(0, mol.numAtoms);\n                effects.atomCircleCol = _util_Vec__WEBPACK_IMPORTED_MODULE_15__.Vec.numberArray(0, mol.numAtoms);\n                for (let n = 1; n <= mol.numAtoms; n++)\n                    if (mol.atomElement(n) == _data_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.ABBREV_ATTACHMENT) {\n                        mol.setAtomElement(n, 'C');\n                        effects.atomCircleSz[n - 1] = 0.2;\n                        effects.atomCircleCol[n - 1] = 0x00C000;\n                    }\n                let layout = new _gfx_ArrangeMolecule__WEBPACK_IMPORTED_MODULE_5__.ArrangeMolecule(mol, measure, policy, effects);\n                layout.arrange();\n                let gfx = new _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_7__.MetaVector();\n                new _gfx_DrawMolecule__WEBPACK_IMPORTED_MODULE_6__.DrawMolecule(layout, gfx).draw();\n                gfx.normalise();\n                this.svgAbbrev.push(gfx.createSVG());\n            }\n            const { mol, atom } = this;\n            if (atom > 0 && _data_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.hasAbbrev(mol, atom)) {\n                let name = mol.atomElement(atom), mf = _data_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.molecularFormula(_data_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.getAbbrev(mol, atom));\n                for (let n = 0; n < this.abbrevList.length; n++)\n                    if (name == this.abbrevList[n].name) {\n                        if (mf == _data_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.molecularFormula(this.abbrevList[n].frag))\n                            this.currentAbbrev = n;\n                        break;\n                    }\n            }\n        }\n        let tr = (0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<tr/>').appendTo(this.tableAbbrev);\n        tr.appendHTML('<td><u>Label</u></td>');\n        tr.appendHTML('<td><u>Structure</u></td>');\n        this.abbrevEntries = [];\n        this.abbrevIndices = [];\n        let search = this.inputAbbrevSearch.getValue().toLowerCase();\n        for (let n = 0; n < this.abbrevList.length; n++) {\n            if (this.currentAbbrev != n && !this.abbrevList[n].nameSearch.includes(search))\n                continue;\n            let entry = {\n                'tr': (0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<tr/>').appendTo(this.tableAbbrev),\n                'idx': n,\n                'bgcol': this.abbrevEntries.length % 2 == 0 ? '#FFFFFF' : '#F8F8F8'\n            };\n            entry.tr.setCSS('background-color', this.currentAbbrev == entry.idx ? (0,_util_util__WEBPACK_IMPORTED_MODULE_14__.colourCode)(_util_Theme__WEBPACK_IMPORTED_MODULE_13__.Theme.lowlight) : entry.bgcol);\n            let tdLabel = (0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<td/>').appendTo(entry.tr), tdStruct = (0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)('<td/>').appendTo(entry.tr);\n            tdLabel.setHTML(this.abbrevList[n].nameHTML);\n            (0,_util_dom__WEBPACK_IMPORTED_MODULE_12__.dom)(this.svgAbbrev[n]).appendTo(tdStruct).css({ 'display': 'block', 'pointer-events': 'none' });\n            entry.tr.css({ 'cursor': 'pointer' });\n            entry.tr.onClick(() => this.selectAbbreviation(n));\n            entry.tr.onDblClick((event) => this.applyChanges());\n            this.abbrevEntries.push(entry);\n            this.abbrevIndices.push(n);\n        }\n    }\n    selectAbbreviation(idx) {\n        if (this.currentAbbrev == idx)\n            return;\n        this.currentAbbrev = idx;\n        for (let entry of this.abbrevEntries) {\n            entry.tr.setCSS('background-color', this.currentAbbrev == entry.idx ? (0,_util_util__WEBPACK_IMPORTED_MODULE_14__.colourCode)(_util_Theme__WEBPACK_IMPORTED_MODULE_13__.Theme.lowlight) : entry.bgcol);\n            if (this.currentAbbrev == entry.idx)\n                entry.tr.el.scrollIntoView({ 'block': 'nearest' });\n        }\n    }\n    cycleAbbreviation(dir) {\n        let sz = this.abbrevIndices.length;\n        if (sz == 0)\n            return;\n        let idx = this.abbrevIndices.indexOf(this.currentAbbrev);\n        if (idx < 0) {\n            if (dir < 0)\n                idx = sz - 1;\n            else\n                idx = 0;\n        }\n        else\n            idx = (idx + sz + dir) % sz;\n        this.selectAbbreviation(this.abbrevIndices[idx]);\n    }\n    selectedTab(idx) {\n        if (idx == 0)\n            this.inputSymbol.grabFocus();\n        else if (idx == 1)\n            this.inputAbbrevSearch.grabFocus();\n        else if (idx == 2)\n            this.inputGeom1.grabFocus();\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/sketcher/EditAtom.ts?");

/***/ }),

/***/ "./src/sketcher/EditBond.ts":
/*!**********************************!*\
  !*** ./src/sketcher/EditBond.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EditBond\": () => (/* binding */ EditBond)\n/* harmony export */ });\n/* harmony import */ var _dialog_Dialog__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dialog/Dialog */ \"./src/dialog/Dialog.ts\");\n/* harmony import */ var _ui_ClipboardProxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ui/ClipboardProxy */ \"./src/ui/ClipboardProxy.ts\");\n/* harmony import */ var _ui_OptionList__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ui/OptionList */ \"./src/ui/OptionList.ts\");\n/* harmony import */ var _ui_TabBar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ui/TabBar */ \"./src/ui/TabBar.ts\");\n/* harmony import */ var _util_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/dom */ \"./src/util/dom.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _ExtraFieldsWidget__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ExtraFieldsWidget */ \"./src/sketcher/ExtraFieldsWidget.ts\");\n/* harmony import */ var _GeomWidget__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./GeomWidget */ \"./src/sketcher/GeomWidget.ts\");\n/* harmony import */ var _MoleculeActivity__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./MoleculeActivity */ \"./src/sketcher/MoleculeActivity.ts\");\n/* harmony import */ var _QueryFieldsWidget__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./QueryFieldsWidget */ \"./src/sketcher/QueryFieldsWidget.ts\");\n\n\n\n\n\n\n\n\n\n\nclass EditBond extends _dialog_Dialog__WEBPACK_IMPORTED_MODULE_0__.Dialog {\n    constructor(mol, bond, proxyClip, callbackApply) {\n        super();\n        this.bond = bond;\n        this.proxyClip = proxyClip;\n        this.callbackApply = callbackApply;\n        this.initMol = mol;\n        this.mol = mol.clone();\n        this.title = 'Edit Bond';\n        this.minPortionWidth = 20;\n        this.maxPortionWidth = 95;\n    }\n    populate() {\n        this.proxyClip.pushHandler(new _ui_ClipboardProxy__WEBPACK_IMPORTED_MODULE_1__.ClipboardProxyHandler());\n        let buttons = this.buttonsDOM(), body = this.bodyDOM();\n        this.btnApply = (0,_util_dom__WEBPACK_IMPORTED_MODULE_4__.dom)('<button class=\"wmk-button wmk-button-primary\">Apply</button>').appendTo(buttons).css({ 'margin-left': '0.5em' });\n        this.btnApply.onClick(() => this.applyChanges());\n        this.tabs = new _ui_TabBar__WEBPACK_IMPORTED_MODULE_3__.TabBar(['Bond', 'Geometry', 'Query', 'Extra']);\n        this.tabs.render(body);\n        this.tabs.onSelect((idx) => this.selectedTab(idx));\n        this.populateBond(this.tabs.getPanelDOM('Bond'));\n        this.populateGeometry(this.tabs.getPanelDOM('Geometry'));\n        this.populateQuery(this.tabs.getPanelDOM('Query'));\n        this.populateExtra(this.tabs.getPanelDOM('Extra'));\n        let focusable = body.findAll('input,textarea');\n        if (focusable.length > 0)\n            focusable[0].grabFocus(true);\n        for (let dom of focusable) {\n            dom.css({ 'font': 'inherit' });\n            dom.onKeyDown((event) => {\n                if (event.key == \"Enter\")\n                    this.applyChanges();\n                else if (event.key == \"Escape\")\n                    this.close();\n                else if (event.key == \"PageUp\") {\n                    this.tabs.rotateSelected(-1);\n                    this.selectedTab(this.tabs.getSelectedIndex());\n                    event.preventDefault();\n                }\n                else if (event.key == \"PageDown\") {\n                    this.tabs.rotateSelected(1);\n                    this.selectedTab(this.tabs.getSelectedIndex());\n                    event.preventDefault();\n                }\n                event.stopPropagation();\n            });\n        }\n    }\n    close() {\n        this.proxyClip.popHandler();\n        super.close();\n    }\n    applyChanges() {\n        this.mol.keepTransient = true;\n        this.updateMolecule();\n        if (this.tabs.getSelectedValue() == 'Geometry')\n            this.updateGeometry();\n        if (this.tabs.getSelectedValue() == 'Query')\n            this.updateQuery();\n        if (this.tabs.getSelectedValue() == 'Extra')\n            this.updateExtra();\n        this.mol.keepTransient = false;\n        if (this.callbackApply)\n            this.callbackApply(this);\n    }\n    populateBond(panel) {\n        const { mol, bond } = this;\n        let grid = (0,_util_dom__WEBPACK_IMPORTED_MODULE_4__.dom)('<div/>').appendTo(panel);\n        grid.css({ 'display': 'grid', 'align-items': 'center', 'justify-content': 'start' });\n        grid.css({ 'grid-row-gap': '0.5em', 'grid-column-gap': '0.5em' });\n        grid.css({ 'grid-template-columns': '[start col0] auto [col1] auto [col2] auto [col3] auto [col4 end]' });\n        (0,_util_dom__WEBPACK_IMPORTED_MODULE_4__.dom)('<div/>').appendTo(grid).css({ 'grid-area': '1 / col0' }).setText('Order');\n        let ordersHTML = [];\n        for (let o = 0; o <= 4; o++)\n            ordersHTML.push(`&nbsp;&nbsp;${o}&nbsp;&nbsp;`);\n        this.optionOrder = new _ui_OptionList__WEBPACK_IMPORTED_MODULE_2__.OptionList(ordersHTML);\n        this.optionOrder.htmlLabels = true;\n        this.optionOrder.setSelectedIndex(mol.bondOrder(bond));\n        this.optionOrder.render((0,_util_dom__WEBPACK_IMPORTED_MODULE_4__.dom)('<div/>').appendTo(grid).css({ 'grid-column': 'col1 / col4', 'grid-row': '1' }));\n        (0,_util_dom__WEBPACK_IMPORTED_MODULE_4__.dom)('<div/>').appendTo(grid).css({ 'grid-area': '2 / col0' }).setText('Stereo');\n        this.optionStereo = new _ui_OptionList__WEBPACK_IMPORTED_MODULE_2__.OptionList(['None', 'Up', 'Down', 'Unknown']);\n        this.optionStereo.setSelectedIndex(mol.bondType(bond));\n        this.optionStereo.render((0,_util_dom__WEBPACK_IMPORTED_MODULE_4__.dom)('<div/>').appendTo(grid).css({ 'grid-column': 'col1 / col4', 'grid-row': '2' }));\n        (0,_util_dom__WEBPACK_IMPORTED_MODULE_4__.dom)('<div/>').appendTo(grid).css({ 'grid-area': '3 / col0' }).setText('From');\n        this.inputFrom = (0,_util_dom__WEBPACK_IMPORTED_MODULE_4__.dom)('<input size=\"6\"/>').appendTo(grid).css({ 'grid-area': '3 / col1', 'font': 'inherit' });\n        this.inputFrom.elInput.readOnly = true;\n        this.inputFrom.setValue(mol.bondFrom(bond).toString());\n        (0,_util_dom__WEBPACK_IMPORTED_MODULE_4__.dom)('<div/>').appendTo(grid).css({ 'grid-area': '3 / col2' }).setText('To');\n        this.inputTo = (0,_util_dom__WEBPACK_IMPORTED_MODULE_4__.dom)('<input size=\"6\"/>').appendTo(grid).css({ 'grid-area': '3 / col3', 'font': 'inherit' });\n        this.inputTo.elInput.readOnly = true;\n        this.inputTo.setValue(mol.bondTo(bond).toString());\n        (0,_util_dom__WEBPACK_IMPORTED_MODULE_4__.dom)('<div/>').appendTo(grid).css({ 'grid-area': '4 / col2' }).setText('Index');\n        this.inputIndex = (0,_util_dom__WEBPACK_IMPORTED_MODULE_4__.dom)('<input size=\"6\"/>').appendTo(grid).css({ 'grid-area': '4 / col3', 'font': 'inherit' });\n        this.inputIndex.elInput.readOnly = true;\n        this.inputIndex.setValue(bond.toString());\n    }\n    populateGeometry(panel) {\n        const { mol, bond } = this;\n        let divContainer1 = (0,_util_dom__WEBPACK_IMPORTED_MODULE_4__.dom)('<div/>').appendTo(panel).css({ 'text-align': 'center' });\n        let divContainer2 = (0,_util_dom__WEBPACK_IMPORTED_MODULE_4__.dom)('<div/>').appendTo(divContainer1).css({ 'display': 'inline-block' });\n        let grid = (0,_util_dom__WEBPACK_IMPORTED_MODULE_4__.dom)('<div/>').appendTo(divContainer2);\n        grid.css({ 'display': 'grid', 'align-items': 'center', 'justify-content': 'start' });\n        grid.css({ 'grid-row-gap': '0.5em', 'grid-column-gap': '0.5em' });\n        grid.css({ 'grid-template-columns': '[start col0] auto [col1] auto [col2]' });\n        this.geomWidget = new _GeomWidget__WEBPACK_IMPORTED_MODULE_7__.GeomWidget(_GeomWidget__WEBPACK_IMPORTED_MODULE_7__.GeomWidgetType.Bond, mol, bond);\n        this.geomWidget.render((0,_util_dom__WEBPACK_IMPORTED_MODULE_4__.dom)('<div/>').appendTo(grid).css({ 'grid-area': '1 / col0 / auto / col2', 'text-align': 'center' }));\n        let label1 = (0,_util_dom__WEBPACK_IMPORTED_MODULE_4__.dom)('<div/>').appendTo(grid).css({ 'grid-area': '2 / col0' });\n        this.inputGeom1 = (0,_util_dom__WEBPACK_IMPORTED_MODULE_4__.dom)('<input type=\"number\" size=\"8\"/>').appendTo(grid).css({ 'grid-area': '2 / col1' });\n        this.geomWidget.callbackSelect = (sel) => {\n            if (sel.type == _GeomWidget__WEBPACK_IMPORTED_MODULE_7__.GeomWidgetSelType.Link) {\n                let a1 = mol.bondFrom(bond), a2 = mol.bondTo(bond);\n                let dx = mol.atomX(a2) - mol.atomX(a1), dy = mol.atomY(a2) - mol.atomY(a1);\n                label1.setText('Distance');\n                this.inputGeom1.setValue(this.refGeom1 = (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.norm_xy)(dx, dy).toFixed(3));\n            }\n        };\n        this.geomWidget.callbackSelect(this.geomWidget.selected);\n    }\n    populateQuery(panel) {\n        this.queryWidget = new _QueryFieldsWidget__WEBPACK_IMPORTED_MODULE_9__.QueryFieldsWidget(this.mol, 0, this.bond);\n        this.queryWidget.render(panel);\n    }\n    populateExtra(panel) {\n        let fields = [...this.mol.bondExtra(this.bond), ...this.mol.bondTransient(this.bond)];\n        this.fieldsWidget = new _ExtraFieldsWidget__WEBPACK_IMPORTED_MODULE_6__.ExtraFieldsWidget(fields);\n        this.fieldsWidget.render(panel);\n    }\n    updateMolecule() {\n        let { mol, bond } = this;\n        mol.setBondOrder(bond, this.optionOrder.getSelectedIndex());\n        mol.setBondType(bond, this.optionStereo.getSelectedIndex());\n    }\n    updateGeometry() {\n        let strval1 = this.inputGeom1.getValue();\n        if (this.refGeom1 == strval1)\n            return;\n        const { mol } = this;\n        let sel = this.geomWidget.selected, atoms = this.geomWidget.selectionAtoms(sel);\n        if (sel.type == _GeomWidget__WEBPACK_IMPORTED_MODULE_7__.GeomWidgetSelType.Link) {\n            if (this.refGeom1 != strval1) {\n                let dist = parseFloat(strval1);\n                if (isNaN(dist) || Math.abs(dist) > 100)\n                    return;\n                let instate = { 'mol': mol, 'currentAtom': 0, 'currentBond': mol.findBond(atoms[0], atoms[1]), 'selectedMask': null };\n                let molact = new _MoleculeActivity__WEBPACK_IMPORTED_MODULE_8__.MoleculeActivity(instate, _MoleculeActivity__WEBPACK_IMPORTED_MODULE_8__.ActivityType.BondDist, { 'dist': dist });\n                molact.execute();\n                this.mol = molact.output.mol;\n                return;\n            }\n        }\n    }\n    updateQuery() {\n        this.queryWidget.updateBond();\n    }\n    updateExtra() {\n        this.mol.setBondExtra(this.bond, this.fieldsWidget.getExtraFields());\n        this.mol.setBondTransient(this.bond, this.fieldsWidget.getTransientFields());\n    }\n    selectedTab(idx) {\n        if (idx == 0)\n            this.inputFrom.grabFocus();\n        else if (idx == 1)\n            this.inputGeom1.grabFocus();\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/sketcher/EditBond.ts?");

/***/ }),

/***/ "./src/sketcher/EditPolymer.ts":
/*!*************************************!*\
  !*** ./src/sketcher/EditPolymer.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EditPolymer\": () => (/* binding */ EditPolymer)\n/* harmony export */ });\n/* harmony import */ var _data_MolUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/MolUtil */ \"./src/data/MolUtil.ts\");\n/* harmony import */ var _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/PolymerBlock */ \"./src/data/PolymerBlock.ts\");\n/* harmony import */ var _dialog_Dialog__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dialog/Dialog */ \"./src/dialog/Dialog.ts\");\n/* harmony import */ var _gfx_ArrangeMeasurement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../gfx/ArrangeMeasurement */ \"./src/gfx/ArrangeMeasurement.ts\");\n/* harmony import */ var _gfx_ArrangeMolecule__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../gfx/ArrangeMolecule */ \"./src/gfx/ArrangeMolecule.ts\");\n/* harmony import */ var _gfx_DrawMolecule__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../gfx/DrawMolecule */ \"./src/gfx/DrawMolecule.ts\");\n/* harmony import */ var _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../gfx/MetaVector */ \"./src/gfx/MetaVector.ts\");\n/* harmony import */ var _gfx_Rendering__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../gfx/Rendering */ \"./src/gfx/Rendering.ts\");\n/* harmony import */ var _ui_ClipboardProxy__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../ui/ClipboardProxy */ \"./src/ui/ClipboardProxy.ts\");\n/* harmony import */ var _ui_OptionList__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../ui/OptionList */ \"./src/ui/OptionList.ts\");\n/* harmony import */ var _util_dom__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../util/dom */ \"./src/util/dom.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst CHAR_LOW_A = 'a'.charCodeAt(0), CHAR_UP_A = 'A'.charCodeAt(0);\nfunction indexToAtomLabel(idx) { return String.fromCharCode(CHAR_UP_A + Math.min(26, Math.max(0, idx)) - 1); }\nfunction indexToBondLabel(idx) { return String.fromCharCode(CHAR_LOW_A + Math.min(26, Math.max(0, idx)) - 1); }\nclass EditPolymer extends _dialog_Dialog__WEBPACK_IMPORTED_MODULE_2__.Dialog {\n    constructor(mol, atoms, proxyClip, callbackApply) {\n        super();\n        this.atoms = atoms;\n        this.proxyClip = proxyClip;\n        this.callbackApply = callbackApply;\n        this.optionConnect = null;\n        this.optionBondConn = null;\n        this.currentID = 0;\n        this.unit = null;\n        this.borderAtoms = [];\n        this.outBonds = [];\n        this.outAtoms = [];\n        this.initMol = mol;\n        this.mol = mol.clone();\n        this.title = 'Polymer Block';\n        this.minPortionWidth = 20;\n        this.maxPortionWidth = 95;\n        this.polymer = new _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_1__.PolymerBlock(this.mol);\n        atoms = _util_Vec__WEBPACK_IMPORTED_MODULE_11__.Vec.sorted(atoms);\n        for (let id of this.polymer.getIDList()) {\n            let look = this.polymer.getUnit(id);\n            if (_util_Vec__WEBPACK_IMPORTED_MODULE_11__.Vec.equals(atoms, look.atoms)) {\n                this.currentID = id;\n                this.unit = look;\n                break;\n            }\n        }\n        if (!this.unit)\n            this.unit = new _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_1__.PolymerBlockUnit(atoms);\n        let umol = this.umol = this.mol.clone();\n        let mask = _util_Vec__WEBPACK_IMPORTED_MODULE_11__.Vec.booleanArray(false, this.umol.numAtoms);\n        for (let n = 1; n <= this.mol.numBonds; n++) {\n            let bfr = this.mol.bondFrom(n), bto = this.mol.bondTo(n);\n            let in1 = this.atoms.includes(bfr), in2 = this.atoms.includes(bto);\n            if (in1 || in2)\n                mask[bfr - 1] = mask[bto - 1] = true;\n            if (in1 && !in2) {\n                this.borderAtoms.push(bfr);\n                this.outBonds.push(n);\n                this.outAtoms.push(bto);\n            }\n            if (in2 && !in1) {\n                this.borderAtoms.push(bto);\n                this.outBonds.push(n);\n                this.outAtoms.push(bfr);\n            }\n        }\n        this.borderAtoms = _util_Vec__WEBPACK_IMPORTED_MODULE_11__.Vec.sortedUnique(this.borderAtoms);\n        this.umap = _util_Vec__WEBPACK_IMPORTED_MODULE_11__.Vec.maskMap(mask);\n        this.umol = _data_MolUtil__WEBPACK_IMPORTED_MODULE_0__.MolUtil.subgraphMask(this.umol, mask);\n        new _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_1__.PolymerBlock(this.umol).removeAll();\n    }\n    populate() {\n        this.proxyClip.pushHandler(new _ui_ClipboardProxy__WEBPACK_IMPORTED_MODULE_8__.ClipboardProxyHandler());\n        let buttons = this.buttonsDOM(), body = this.bodyDOM();\n        this.btnApply = (0,_util_dom__WEBPACK_IMPORTED_MODULE_10__.dom)('<button class=\"wmk-button wmk-button-primary\">Apply</button>').appendTo(buttons).css({ 'margin-left': '0.5em' });\n        if (this.currentID == 0)\n            this.btnApply.setText('Create');\n        this.btnApply.onClick(() => this.applyChanges());\n        if (this.currentID > 0) {\n            this.btnRemove = (0,_util_dom__WEBPACK_IMPORTED_MODULE_10__.dom)('<button class=\"wmk-button wmk-button-default\">Remove</button>').appendTo(buttons).css({ 'margin-left': '0.5em' });\n            this.btnRemove.onClick(() => this.applyRemove());\n        }\n        let grid = (0,_util_dom__WEBPACK_IMPORTED_MODULE_10__.dom)('<div/>').appendTo(body);\n        grid.css({ 'display': 'grid', 'align-items': 'center', 'justify-content': 'start' });\n        grid.css({ 'grid-row-gap': '0.5em', 'grid-column-gap': '0.5em' });\n        grid.css({ 'grid-template-columns': '[start col0] auto [col1] auto [col2] auto [col3] auto [col4] auto [end]' });\n        (0,_util_dom__WEBPACK_IMPORTED_MODULE_10__.dom)('<div/>').appendTo(grid).css({ 'grid-area': '1 / col0' }).setText('# Atoms');\n        let inputNAtoms = (0,_util_dom__WEBPACK_IMPORTED_MODULE_10__.dom)('<input size=\"5\"/>').appendTo((0,_util_dom__WEBPACK_IMPORTED_MODULE_10__.dom)('<div/>').appendTo(grid).css({ 'grid-area': '1 / col1' }));\n        inputNAtoms.elInput.readOnly = true;\n        inputNAtoms.setValue(this.unit.atoms.length.toString());\n        (0,_util_dom__WEBPACK_IMPORTED_MODULE_10__.dom)('<div/>').appendTo(grid).css({ 'grid-area': '1 / col2' }).setText('Out-bonds');\n        let inputNBond = (0,_util_dom__WEBPACK_IMPORTED_MODULE_10__.dom)('<input size=\"5\"/>').appendTo((0,_util_dom__WEBPACK_IMPORTED_MODULE_10__.dom)('<div/>').appendTo(grid).css({ 'grid-area': '1 / col3' }));\n        inputNBond.elInput.readOnly = true;\n        inputNBond.setValue(this.outBonds.length.toString());\n        let row = 1;\n        if (this.outBonds.length == 2) {\n            row++;\n            (0,_util_dom__WEBPACK_IMPORTED_MODULE_10__.dom)('<div/>').appendTo(grid).css({ 'grid-area': `${row} / col0` }).setText('Connectivity');\n            this.optionConnect = new _ui_OptionList__WEBPACK_IMPORTED_MODULE_9__.OptionList(['Unknown', 'Head-to-Tail', 'Head-to-Head', 'Random']);\n            this.optionConnect.render((0,_util_dom__WEBPACK_IMPORTED_MODULE_10__.dom)('<div/>').appendTo(grid).css({ 'grid-area': `${row} / col1 / auto / col4` }));\n            if (this.unit.connect == _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_1__.PolymerBlockConnectivity.HeadToTail)\n                this.optionConnect.setSelectedIndex(1);\n            else if (this.unit.connect == _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_1__.PolymerBlockConnectivity.HeadToHead)\n                this.optionConnect.setSelectedIndex(2);\n            else if (this.unit.connect == _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_1__.PolymerBlockConnectivity.Random)\n                this.optionConnect.setSelectedIndex(3);\n        }\n        if (this.outBonds.length == 4 && _util_Vec__WEBPACK_IMPORTED_MODULE_11__.Vec.uniqueUnstable(this.outAtoms).length == 4) {\n            row++;\n            (0,_util_dom__WEBPACK_IMPORTED_MODULE_10__.dom)('<div/>').appendTo(grid).css({ 'grid-area': `${row} / col0` }).setText('2x2 Connectivity');\n            this.populate2x2Conn((0,_util_dom__WEBPACK_IMPORTED_MODULE_10__.dom)('<div/>').appendTo(grid).css({ 'grid-area': `${row} / col1 / auto / end` }));\n        }\n        let getList = (str) => {\n            if (!str)\n                return null;\n            let list = [];\n            for (let bit of str.split(',')) {\n                let v = parseInt(bit);\n                if (v > 0)\n                    list.push(v);\n                else\n                    return undefined;\n            }\n            return list;\n        };\n        for (let n = 0; n < this.borderAtoms.length; n++) {\n            row++;\n            let domLabel = (0,_util_dom__WEBPACK_IMPORTED_MODULE_10__.dom)('<div/>').appendTo(grid).css({ 'grid-area': `${row} / col0`, 'text-align': 'right', 'padding-right': '0.5em' });\n            if (n == 0)\n                domLabel.setText('Name ');\n            (0,_util_dom__WEBPACK_IMPORTED_MODULE_10__.dom)('<span/>').appendTo(domLabel).css({ 'color': '#008000' }).setText(indexToAtomLabel(n + 1));\n            let input = (0,_util_dom__WEBPACK_IMPORTED_MODULE_10__.dom)('<input size=\"20\"/>').appendTo((0,_util_dom__WEBPACK_IMPORTED_MODULE_10__.dom)('<div/>').appendTo(grid).css({ 'grid-area': `${row} / col1 / auto / end`, 'width': '100%' }));\n            let atom = this.borderAtoms[n];\n            let nvals = this.unit.atomName.get(atom);\n            if (nvals)\n                input.setValue(nvals.join(','));\n            input.onInput(() => {\n                let list = getList(input.getValue());\n                if (list !== undefined)\n                    this.unit.atomName.set(atom, list);\n            });\n        }\n        for (let n = 0; n < this.outAtoms.length; n++) {\n            row++;\n            let domLabel = (0,_util_dom__WEBPACK_IMPORTED_MODULE_10__.dom)('<div/>').appendTo(grid).css({ 'grid-area': `${row} / col0`, 'text-align': 'right', 'padding-right': '0.5em' });\n            if (n == 0)\n                domLabel.setText('Link ');\n            (0,_util_dom__WEBPACK_IMPORTED_MODULE_10__.dom)('<span/>').appendTo(domLabel).css({ 'color': '#800080' }).setText(indexToBondLabel(n + 1));\n            (0,_util_dom__WEBPACK_IMPORTED_MODULE_10__.dom)('<div/>').appendTo(grid).css({ 'grid-area': `${row} / col1` }).setText('Include');\n            let inputIncl = (0,_util_dom__WEBPACK_IMPORTED_MODULE_10__.dom)('<input size=\"10\"/>').appendTo((0,_util_dom__WEBPACK_IMPORTED_MODULE_10__.dom)('<div/>').appendTo(grid).css({ 'grid-area': `${row} / col2`, 'width': '100%' }));\n            (0,_util_dom__WEBPACK_IMPORTED_MODULE_10__.dom)('<div/>').appendTo(grid).css({ 'grid-area': `${row} / col3` }).setText('Exclude');\n            let inputExcl = (0,_util_dom__WEBPACK_IMPORTED_MODULE_10__.dom)('<input size=\"10\"/>').appendTo((0,_util_dom__WEBPACK_IMPORTED_MODULE_10__.dom)('<div/>').appendTo(grid).css({ 'grid-area': `${row} / col4`, 'width': '100%' }));\n            let bond = this.outBonds[n];\n            let ivals = this.unit.bondIncl.get(bond), evals = this.unit.bondExcl.get(bond);\n            if (ivals)\n                inputIncl.setValue(ivals.join(','));\n            if (evals)\n                inputExcl.setValue(evals.join(','));\n            inputIncl.onInput(() => {\n                let list = getList(inputIncl.getValue());\n                if (list !== undefined)\n                    this.unit.bondIncl.set(bond, list);\n            });\n            inputExcl.onInput(() => {\n                let list = getList(inputExcl.getValue());\n                if (list !== undefined)\n                    this.unit.bondExcl.set(bond, list);\n            });\n        }\n        row++;\n        this.populateUncap((0,_util_dom__WEBPACK_IMPORTED_MODULE_10__.dom)('<div/>').appendTo(grid).css({ 'grid-area': `${row} / col0 / auto / col4`, 'text-align': 'center' }));\n        row++;\n        this.divPreview = (0,_util_dom__WEBPACK_IMPORTED_MODULE_10__.dom)('<div/>').appendTo(grid).css({ 'grid-area': `${row} / col0 / auto / col4`, 'text-align': 'center' });\n        this.renderUnit();\n        let focusable = body.findAll('input,textarea');\n        if (focusable.length > 0)\n            focusable[0].grabFocus(true);\n        for (let dom of focusable) {\n            dom.css({ 'font': 'inherit' });\n            dom.onKeyDown((event) => {\n                let keyCode = event.keyCode || event.which;\n                if (keyCode == 13)\n                    this.applyChanges();\n                if (keyCode == 27)\n                    this.close();\n            });\n        }\n    }\n    close() {\n        this.proxyClip.popHandler();\n        super.close();\n    }\n    populate2x2Conn(div) {\n        const perms = [[0, 1, 2, 3], [0, 1, 3, 2], [0, 2, 1, 3], [0, 2, 3, 1], [0, 3, 1, 2], [0, 3, 2, 1]];\n        let bondConnOptions = [null];\n        let optionList = ['None'];\n        let selidx = 0;\n        for (let perm of perms) {\n            let bonds = _util_Vec__WEBPACK_IMPORTED_MODULE_11__.Vec.idxGet(this.outBonds, perm);\n            if (_util_Vec__WEBPACK_IMPORTED_MODULE_11__.Vec.equals(bonds, this.unit.bondConn))\n                selidx = optionList.length;\n            bondConnOptions.push(bonds);\n            optionList.push(`${perm[0] + 1},${perm[1] + 1}:${perm[2] + 1},${perm[3] + 1}`);\n        }\n        this.optionBondConn = new _ui_OptionList__WEBPACK_IMPORTED_MODULE_9__.OptionList(optionList);\n        this.optionBondConn.setSelectedIndex(selidx);\n        this.optionBondConn.render(div);\n        this.optionBondConn.onSelect((idx) => {\n            this.unit.bondConn = bondConnOptions[idx];\n            this.renderUnit();\n        });\n    }\n    populateUncap(div) {\n        let uncapAtoms = [];\n        skip: for (let a of this.outAtoms)\n            if (this.mol.atomAdjCount(a) == 1 && this.mol.atomElement(a) != '*') {\n                for (let unit of this.polymer.getUnits())\n                    if (unit.atoms.includes(a))\n                        continue skip;\n                uncapAtoms.push(a);\n            }\n        if (uncapAtoms.length == 0)\n            return;\n        let btnUncap = (0,_util_dom__WEBPACK_IMPORTED_MODULE_10__.dom)('<button class=\"wmk-button wmk-button-default\">Uncap Exterior</button>').appendTo(div);\n        btnUncap.onClick(() => {\n            btnUncap.elInput.disabled = true;\n            for (let a of uncapAtoms)\n                this.mol.setAtomElement(a, '*');\n        });\n    }\n    applyChanges() {\n        if (this.optionConnect) {\n            let sel = this.optionConnect.getSelectedIndex();\n            if (sel == 0)\n                this.unit.connect = null;\n            else if (sel == 1)\n                this.unit.connect = _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_1__.PolymerBlockConnectivity.HeadToTail;\n            else if (sel == 2)\n                this.unit.connect = _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_1__.PolymerBlockConnectivity.HeadToHead;\n            else if (sel == 3)\n                this.unit.connect = _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_1__.PolymerBlockConnectivity.Random;\n        }\n        if (this.currentID)\n            this.polymer.removeUnit(this.currentID);\n        this.currentID = this.polymer.createUnit(this.unit.clone());\n        this.polymer.rewriteMolecule();\n        this.callbackApply(this);\n    }\n    applyRemove() {\n        if (this.currentID)\n            this.polymer.removeUnit(this.currentID);\n        this.callbackApply(this);\n    }\n    renderUnit() {\n        let umol = this.umol.clone();\n        let policy = _gfx_Rendering__WEBPACK_IMPORTED_MODULE_7__.RenderPolicy.defaultColourOnWhite(20);\n        let measure = new _gfx_ArrangeMeasurement__WEBPACK_IMPORTED_MODULE_3__.OutlineMeasurement(0, 0, policy.data.pointScale);\n        let effects = new _gfx_Rendering__WEBPACK_IMPORTED_MODULE_7__.RenderEffects();\n        effects.atomCircleSz = _util_Vec__WEBPACK_IMPORTED_MODULE_11__.Vec.numberArray(0, umol.numAtoms);\n        effects.atomCircleCol = _util_Vec__WEBPACK_IMPORTED_MODULE_11__.Vec.numberArray(0, umol.numAtoms);\n        effects.atomDecoText = _util_Vec__WEBPACK_IMPORTED_MODULE_11__.Vec.stringArray(null, umol.numAtoms);\n        effects.atomDecoCol = _util_Vec__WEBPACK_IMPORTED_MODULE_11__.Vec.numberArray(null, umol.numAtoms);\n        effects.atomDecoSize = _util_Vec__WEBPACK_IMPORTED_MODULE_11__.Vec.numberArray(null, umol.numAtoms);\n        let borderAtoms = this.borderAtoms.map((atom) => this.umap[atom - 1] + 1);\n        let outAtoms = this.outAtoms.map((atom) => this.umap[atom - 1] + 1);\n        for (let n = 1; n <= umol.numAtoms; n++) {\n            let bidx = borderAtoms.indexOf(n), oidx = outAtoms.indexOf(n);\n            if (bidx >= 0) {\n                effects.atomDecoText[n - 1] = indexToAtomLabel(bidx + 1);\n                effects.atomDecoCol[n - 1] = 0x008000;\n                effects.atomDecoSize[n - 1] = 0.5;\n            }\n            if (oidx >= 0) {\n                umol.setAtomCharge(n, 0);\n                umol.setAtomUnpaired(n, 0);\n                umol.setAtomIsotope(n, 0);\n                effects.atomCircleSz[n - 1] = 0.1;\n                effects.atomCircleCol[n - 1] = 0xFF00FF;\n                effects.atomDecoText[n - 1] = indexToBondLabel(oidx + 1);\n                effects.atomDecoCol[n - 1] = 0x800080;\n                effects.atomDecoSize[n - 1] = 0.5;\n                umol.setAtomElement(n, 'C');\n            }\n        }\n        let layout = new _gfx_ArrangeMolecule__WEBPACK_IMPORTED_MODULE_4__.ArrangeMolecule(umol, measure, policy, effects);\n        layout.arrange();\n        layout.squeezeInto(0, 0, 300, 300);\n        let gfx = new _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_6__.MetaVector();\n        if (this.unit.bondConn) {\n            const LINES = [\n                [0, 1, 0xC86D08, 2, false], [2, 3, 0xC86D08, 2, false],\n                [0, 2, 0xC0C86D08, 1, true], [1, 3, 0xC0C86D08, 1, true]\n            ];\n            for (let [i1, i2, col, sz, circle] of LINES) {\n                let a1 = this.outAtoms[this.outBonds.indexOf(this.unit.bondConn[i1])];\n                let a2 = this.outAtoms[this.outBonds.indexOf(this.unit.bondConn[i2])];\n                let p1 = layout.getPoint(a1 - 1), p2 = layout.getPoint(a2 - 1);\n                gfx.drawLine(p1.oval.cx, p1.oval.cy, p2.oval.cx, p2.oval.cy, col, sz);\n                if (circle) {\n                    for (let f of [0.2, 0.4, 0.6, 0.8]) {\n                        let mx = p1.oval.cx + f * (p2.oval.cx - p1.oval.cx), my = p1.oval.cy + f * (p2.oval.cy - p1.oval.cy);\n                        gfx.drawOval(mx, my, 2, 2, col, sz, null);\n                    }\n                }\n            }\n        }\n        new _gfx_DrawMolecule__WEBPACK_IMPORTED_MODULE_5__.DrawMolecule(layout, gfx).draw();\n        gfx.normalise();\n        this.divPreview.empty();\n        (0,_util_dom__WEBPACK_IMPORTED_MODULE_10__.dom)(gfx.createSVG()).appendTo(this.divPreview).css({ 'pointer-events': 'none' });\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/sketcher/EditPolymer.ts?");

/***/ }),

/***/ "./src/sketcher/ExtraFieldsWidget.ts":
/*!*******************************************!*\
  !*** ./src/sketcher/ExtraFieldsWidget.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ExtraFieldsWidget\": () => (/* binding */ ExtraFieldsWidget)\n/* harmony export */ });\n/* harmony import */ var _data_Molecule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/Molecule */ \"./src/data/Molecule.ts\");\n/* harmony import */ var _ui_Widget__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ui/Widget */ \"./src/ui/Widget.ts\");\n/* harmony import */ var _util_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/dom */ \"./src/util/dom.ts\");\n\n\n\nclass ExtraFieldsWidget extends _ui_Widget__WEBPACK_IMPORTED_MODULE_1__.Widget {\n    constructor(fields) {\n        super();\n        this.fields = fields;\n    }\n    render(parent) {\n        super.render(parent);\n        this.divFields = (0,_util_dom__WEBPACK_IMPORTED_MODULE_2__.dom)('<div/>').appendTo(this.contentDOM);\n        this.fillTable();\n        let divButtons = (0,_util_dom__WEBPACK_IMPORTED_MODULE_2__.dom)('<div/>').appendTo(this.contentDOM).css({ 'text-align': 'center' });\n        let btnExtra = (0,_util_dom__WEBPACK_IMPORTED_MODULE_2__.dom)('<button class=\"wmk-button wmk-button-default\">Extra</button>').appendTo(divButtons);\n        btnExtra.onClick(() => {\n            this.fields.push(_data_Molecule__WEBPACK_IMPORTED_MODULE_0__.Molecule.PREFIX_EXTRA);\n            this.fillTable();\n        });\n        let btnTransient = (0,_util_dom__WEBPACK_IMPORTED_MODULE_2__.dom)('<button class=\"wmk-button wmk-button-default\">Transient</button>').appendTo(divButtons).css({ 'margin-left': '0.5em' });\n        btnTransient.onClick(() => {\n            this.fields.push(_data_Molecule__WEBPACK_IMPORTED_MODULE_0__.Molecule.PREFIX_TRANSIENT);\n            this.fillTable();\n        });\n    }\n    getExtraFields() {\n        let extra = [];\n        for (let field of this.fields)\n            if (!field.startsWith(_data_Molecule__WEBPACK_IMPORTED_MODULE_0__.Molecule.PREFIX_TRANSIENT) && field.length > 1)\n                extra.push(field);\n        return extra;\n    }\n    getTransientFields() {\n        let transient = [];\n        for (let field of this.fields)\n            if (field.startsWith(_data_Molecule__WEBPACK_IMPORTED_MODULE_0__.Molecule.PREFIX_TRANSIENT) && field.length > 1)\n                transient.push(field);\n        return transient;\n    }\n    fillTable() {\n        this.divFields.empty();\n        if (this.fields.length == 0)\n            return;\n        let table = (0,_util_dom__WEBPACK_IMPORTED_MODULE_2__.dom)('<table/>').appendTo(this.divFields).css({ 'width': '100%' });\n        let tr = (0,_util_dom__WEBPACK_IMPORTED_MODULE_2__.dom)('<tr/>').appendTo(table);\n        (0,_util_dom__WEBPACK_IMPORTED_MODULE_2__.dom)('<td/>').appendTo(tr).css({ 'text-align': 'right', 'font-weight': 'bold', 'text-decoration': 'underline' }).setText('Type');\n        (0,_util_dom__WEBPACK_IMPORTED_MODULE_2__.dom)('<td/>').appendTo(tr).css({ 'font-weight': 'bold', 'text-decoration': 'underline' }).setText('Value');\n        for (let n = 0; n < this.fields.length; n++) {\n            let strType = '?', strValue = '';\n            if (this.fields[n].length > 0) {\n                strType = this.fields[n].charAt(0);\n                strValue = this.fields[n].substring(1);\n            }\n            tr = (0,_util_dom__WEBPACK_IMPORTED_MODULE_2__.dom)('<tr/>').appendTo(table);\n            let tdType = (0,_util_dom__WEBPACK_IMPORTED_MODULE_2__.dom)('<td/>').appendTo(tr).css({ 'text-align': 'right' }), tdValue = (0,_util_dom__WEBPACK_IMPORTED_MODULE_2__.dom)('<td/>').appendTo(tr), tdButton = (0,_util_dom__WEBPACK_IMPORTED_MODULE_2__.dom)('<td/>').appendTo(tr);\n            (0,_util_dom__WEBPACK_IMPORTED_MODULE_2__.dom)('<span/>').appendTo(tdType).css({ 'padding': '0.2em', 'border': '1px solid black', 'background-color': '#C0C0C0' }).setText(strType);\n            let input = (0,_util_dom__WEBPACK_IMPORTED_MODULE_2__.dom)('<input size=\"20\"/>').appendTo(tdValue).css({ 'width': '100%', 'font': 'inherit' });\n            input.setValue(strValue);\n            input.onInput(() => { this.fields[n] = strType + input.getValue(); });\n            let btnDelete = (0,_util_dom__WEBPACK_IMPORTED_MODULE_2__.dom)('<button class=\"wmk-button wmk-button-small wmk-button-default\">\\u{2716}</button>').appendTo(tdButton).css({ 'margin-left': '0.5em' });\n            btnDelete.onClick(() => {\n                this.fields.splice(n, 1);\n                this.fillTable();\n            });\n        }\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/sketcher/ExtraFieldsWidget.ts?");

/***/ }),

/***/ "./src/sketcher/GeomWidget.ts":
/*!************************************!*\
  !*** ./src/sketcher/GeomWidget.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GeomWidget\": () => (/* binding */ GeomWidget),\n/* harmony export */   \"GeomWidgetSelType\": () => (/* binding */ GeomWidgetSelType),\n/* harmony export */   \"GeomWidgetType\": () => (/* binding */ GeomWidgetType)\n/* harmony export */ });\n/* harmony import */ var _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../gfx/MetaVector */ \"./src/gfx/MetaVector.ts\");\n/* harmony import */ var _ui_Widget__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ui/Widget */ \"./src/ui/Widget.ts\");\n/* harmony import */ var _util_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/dom */ \"./src/util/dom.ts\");\n/* harmony import */ var _util_Geom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Geom */ \"./src/util/Geom.ts\");\n/* harmony import */ var _util_Theme__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Theme */ \"./src/util/Theme.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n\n\n\n\n\n\n\nvar GeomWidgetType;\n(function (GeomWidgetType) {\n    GeomWidgetType[GeomWidgetType[\"Atom\"] = 0] = \"Atom\";\n    GeomWidgetType[GeomWidgetType[\"Bond\"] = 1] = \"Bond\";\n})(GeomWidgetType || (GeomWidgetType = {}));\nvar GeomWidgetSelType;\n(function (GeomWidgetSelType) {\n    GeomWidgetSelType[GeomWidgetSelType[\"Position\"] = 0] = \"Position\";\n    GeomWidgetSelType[GeomWidgetSelType[\"Link\"] = 1] = \"Link\";\n    GeomWidgetSelType[GeomWidgetSelType[\"Torsion\"] = 2] = \"Torsion\";\n})(GeomWidgetSelType || (GeomWidgetSelType = {}));\nclass GeomWidget extends _ui_Widget__WEBPACK_IMPORTED_MODULE_1__.Widget {\n    constructor(type, mol, idx) {\n        super();\n        this.type = type;\n        this.mol = mol;\n        this.idx = idx;\n        this.posX = [];\n        this.posY = [];\n        this.linkA = [];\n        this.linkB = [];\n        this.torsA = [];\n        this.torsB = [];\n        this.hovered = null;\n        if (type == GeomWidgetType.Atom) {\n            const atom = idx;\n            let adj = mol.atomAdjList(atom);\n            this.atomSubset = [atom, ...adj];\n            for (let b of mol.atomAdjBonds(atom)) {\n                this.linkA.push(0);\n                this.linkB.push(this.atomSubset.indexOf(mol.bondOther(b, atom)));\n            }\n            let theta = [];\n            for (let a of adj)\n                theta.push(Math.atan2(-(mol.atomY(a) - mol.atomY(atom)), mol.atomX(a) - mol.atomX(atom)));\n            let order = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.idxSort(theta);\n            for (let n = 0; n < order.length; n++) {\n                this.torsA.push(order[n] + 1);\n                this.torsB.push(order[n < order.length - 1 ? n + 1 : 0] + 1);\n            }\n            this.selected = { 'type': GeomWidgetSelType.Position, 'idx': 0 };\n        }\n        else {\n            const bond = idx;\n            let a1 = mol.bondFrom(bond), a2 = mol.bondTo(bond);\n            this.atomSubset = [...mol.atomAdjList(a1), ...mol.atomAdjList(a2)];\n            let link = (a1, a2) => {\n                this.linkA.push(this.atomSubset.indexOf(a1));\n                this.linkB.push(this.atomSubset.indexOf(a2));\n            };\n            link(a1, a2);\n            for (let a of mol.atomAdjList(a1))\n                if (a != a2)\n                    link(a1, a);\n            for (let a of mol.atomAdjList(a2))\n                if (a != a1)\n                    link(a2, a);\n            this.selected = { 'type': GeomWidgetSelType.Link, 'idx': 0 };\n        }\n    }\n    render(parent) {\n        super.render(parent);\n        let divOuter = (0,_util_dom__WEBPACK_IMPORTED_MODULE_2__.dom)('<div/>').appendTo(this.contentDOM).css({ 'text-align': 'center' });\n        this.divDiagram = (0,_util_dom__WEBPACK_IMPORTED_MODULE_2__.dom)('<div/>').appendTo(divOuter).css({ 'display': 'inline-block' });\n        this.contentDOM.onClick((event) => this.mouseClick((0,_util_util__WEBPACK_IMPORTED_MODULE_5__.eventCoords)(event, this.divDiagram)));\n        this.contentDOM.onMouseMove((event) => this.mouseMove((0,_util_util__WEBPACK_IMPORTED_MODULE_5__.eventCoords)(event, this.divDiagram)));\n        this.redraw();\n    }\n    selectionAtoms(sel) {\n        const atoms = this.atomSubset;\n        if (sel.type == GeomWidgetSelType.Position)\n            return [atoms[sel.idx]];\n        if (sel.type == GeomWidgetSelType.Link)\n            return [atoms[this.linkA[sel.idx]], atoms[this.linkB[sel.idx]]];\n        if (sel.type == GeomWidgetSelType.Torsion)\n            return [atoms[0], atoms[this.torsA[sel.idx]], atoms[this.torsB[sel.idx]]];\n        return null;\n    }\n    redraw() {\n        this.divDiagram.empty();\n        let w = 250, h = 250;\n        this.posX = [];\n        this.posY = [];\n        const ANG_RAD = 0.25;\n        for (let a of this.atomSubset) {\n            this.posX.push(this.mol.atomX(a));\n            this.posY.push(this.mol.atomY(a));\n        }\n        let loX = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.min(this.posX) - ANG_RAD, hiX = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.max(this.posX) + ANG_RAD;\n        let loY = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.min(this.posY) - ANG_RAD, hiY = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.max(this.posY) + ANG_RAD;\n        this.scale = Math.min(40, Math.min((w - 4) / (hiX - loX), (h - 4) / (hiY - loY)));\n        let dx = 0.5 * (w - (hiX - loX) * this.scale), dy = 0.5 * (h - (hiY - loY) * this.scale);\n        for (let n = 0; n < this.atomSubset.length; n++) {\n            this.posX[n] = dx + (this.posX[n] - loX) * this.scale;\n            this.posY[n] = h - (dy + (this.posY[n] - loY) * this.scale);\n        }\n        this.posRad = ANG_RAD * this.scale;\n        let gfx = new _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_0__.MetaVector();\n        gfx.setSize(w, h);\n        let fg = _util_Theme__WEBPACK_IMPORTED_MODULE_4__.Theme.foreground, bg = _util_Theme__WEBPACK_IMPORTED_MODULE_4__.Theme.background, outerSel = 0x008FD1, innerSel = 0x47D5D2;\n        for (let n = 0; n < this.atomSubset.length; n++) {\n            if (this.hovered && this.hovered.type == GeomWidgetSelType.Position && this.hovered.idx == n)\n                gfx.drawOval(this.posX[n], this.posY[n], this.posRad, this.posRad, fg, 1, bg);\n            else if (this.selected && this.selected.type == GeomWidgetSelType.Position && this.selected.idx == n)\n                gfx.drawOval(this.posX[n], this.posY[n], this.posRad, this.posRad, outerSel, 1, innerSel);\n            else\n                gfx.drawOval(this.posX[n], this.posY[n], this.posRad, this.posRad, _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_0__.MetaVector.NOCOLOUR, 0, fg);\n        }\n        for (let showsel of [1, 2, 3])\n            for (let n = 0; n < this.linkA.length; n++) {\n                let x1 = this.posX[this.linkA[n]], y1 = this.posY[this.linkA[n]];\n                let x2 = this.posX[this.linkB[n]], y2 = this.posY[this.linkB[n]];\n                if (this.hovered && this.hovered.type == GeomWidgetSelType.Link && this.hovered.idx == n) {\n                    if (showsel == 3) {\n                        gfx.drawLine(x1, y1, x2, y2, fg, this.scale * 0.1 + 2);\n                        gfx.drawLine(x1, y1, x2, y2, bg, this.scale * 0.1);\n                    }\n                }\n                else if (this.selected && this.selected.type == GeomWidgetSelType.Link && this.selected.idx == n) {\n                    if (showsel == 2) {\n                        gfx.drawLine(x1, y1, x2, y2, outerSel, this.scale * 0.1 + 2);\n                        gfx.drawLine(x1, y1, x2, y2, innerSel, this.scale * 0.1);\n                    }\n                }\n                else {\n                    if (showsel == 1)\n                        gfx.drawLine(x1, y1, x2, y2, fg, this.scale * 0.1);\n                }\n            }\n        for (let n = 0; n < this.torsA.length; n++) {\n            let cx = this.posX[0], cy = this.posY[0];\n            let dx1 = 0.5 * (this.posX[this.torsA[n]] - cx), dy1 = 0.5 * (this.posY[this.torsA[n]] - cy);\n            let dx2 = 0.5 * (this.posX[this.torsB[n]] - cx), dy2 = 0.5 * (this.posY[this.torsB[n]] - cy);\n            let rad = 0.5 * ((0,_util_util__WEBPACK_IMPORTED_MODULE_5__.norm_xy)(dx1, dy1) + (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.norm_xy)(dx2, dy2));\n            let theta1 = Math.atan2(dy1, dx1) + 10 * _util_util__WEBPACK_IMPORTED_MODULE_5__.DEGRAD, theta2 = Math.atan2(dy2, dx2) - 10 * _util_util__WEBPACK_IMPORTED_MODULE_5__.DEGRAD, dtheta = (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.angleDiff)(theta2, theta1);\n            let ox1 = rad * Math.cos(theta1), oy1 = rad * Math.sin(theta1), ox2 = rad * Math.cos(theta2), oy2 = rad * Math.sin(theta2);\n            let px, py, pf;\n            if (dtheta > 0) {\n                let [ax1, ay1, ax2, ay2] = _util_Geom__WEBPACK_IMPORTED_MODULE_3__.GeomUtil.arcControlPoints(rad, ox1, oy1, ox2, oy2);\n                px = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.add([ox1, ax1, ax2, ox2], cx);\n                py = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.add([oy1, ay1, ay2, oy2], cy);\n                pf = [false, true, true, false];\n            }\n            else {\n                let thetaM = theta1 + 0.5 * (dtheta + _util_util__WEBPACK_IMPORTED_MODULE_5__.TWOPI);\n                let oxM = rad * Math.cos(thetaM), oyM = rad * Math.sin(thetaM);\n                let [ax1, ay1, ax2, ay2] = _util_Geom__WEBPACK_IMPORTED_MODULE_3__.GeomUtil.arcControlPoints(rad, ox1, oy1, oxM, oyM);\n                let [ax3, ay3, ax4, ay4] = _util_Geom__WEBPACK_IMPORTED_MODULE_3__.GeomUtil.arcControlPoints(rad, oxM, oyM, ox2, oy2);\n                px = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.add([ox1, ax1, ax2, oxM, ax3, ax4, ox2], cx);\n                py = _util_Vec__WEBPACK_IMPORTED_MODULE_6__.Vec.add([oy1, ay1, ay2, oyM, ay3, ay4, oy2], cy);\n                pf = [false, true, true, false, true, true, false];\n            }\n            if (this.hovered && this.hovered.type == GeomWidgetSelType.Torsion && this.hovered.idx == n) {\n                gfx.drawPath(px, py, pf, false, fg, this.scale * 0.1 + 2, _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_0__.MetaVector.NOCOLOUR, false);\n                gfx.drawPath(px, py, pf, false, bg, this.scale * 0.1, _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_0__.MetaVector.NOCOLOUR, false);\n            }\n            else if (this.selected && this.selected.type == GeomWidgetSelType.Torsion && this.selected.idx == n) {\n                gfx.drawPath(px, py, pf, false, outerSel, this.scale * 0.1 + 2, _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_0__.MetaVector.NOCOLOUR, false);\n                gfx.drawPath(px, py, pf, false, innerSel, this.scale * 0.1, _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_0__.MetaVector.NOCOLOUR, false);\n            }\n            else\n                gfx.drawPath(px, py, pf, false, fg, this.scale * 0.1, _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_0__.MetaVector.NOCOLOUR, false);\n        }\n        this.divDiagram.empty();\n        let svg = (0,_util_dom__WEBPACK_IMPORTED_MODULE_2__.dom)(gfx.createSVG()).appendTo(this.divDiagram).css({ 'pointer-events': 'none' });\n    }\n    mouseClick(xy) {\n        event.stopPropagation();\n        if (this.type == GeomWidgetType.Bond)\n            return;\n        let which = this.whichSelection(xy[0], xy[1]);\n        if (!which)\n            return;\n        if (!this.sameSelection(this.selected, which)) {\n            this.selected = which;\n            this.hovered = null;\n            this.redraw();\n            this.callbackSelect(which);\n        }\n    }\n    mouseMove(xy) {\n        if (this.type == GeomWidgetType.Bond)\n            return;\n        let which = this.whichSelection(xy[0], xy[1]);\n        if (which && this.sameSelection(which, this.selected))\n            which = null;\n        if (!this.sameSelection(this.hovered, which)) {\n            this.hovered = which;\n            this.redraw();\n        }\n    }\n    whichSelection(x, y) {\n        let cx = this.posX[0], cy = this.posY[0];\n        if ((0,_util_util__WEBPACK_IMPORTED_MODULE_5__.norm_xy)(x - cx, y - cy) <= this.posRad)\n            return { 'type': GeomWidgetSelType.Position, 'idx': 0 };\n        let maxRad = 0;\n        for (let n = 1; n < this.atomSubset.length; n++)\n            maxRad = Math.max(maxRad, (0,_util_util__WEBPACK_IMPORTED_MODULE_5__.norm_xy)(this.posX[n] - cx, this.posY[n] - cy) + this.posRad);\n        if ((0,_util_util__WEBPACK_IMPORTED_MODULE_5__.norm_xy)(x - cx, y - cy) > maxRad)\n            return null;\n        let theta = Math.atan2(y - cy, x - cx);\n        let closeSel = null, closeDelta = Number.POSITIVE_INFINITY;\n        for (let n = 0; n < this.linkB.length; n++) {\n            let delta = Math.abs((0,_util_util__WEBPACK_IMPORTED_MODULE_5__.angleDiff)(Math.atan2(this.posY[this.linkB[n]] - cy, this.posX[this.linkB[n]] - cx), theta));\n            if (delta < 10 * _util_util__WEBPACK_IMPORTED_MODULE_5__.DEGRAD && delta < closeDelta) {\n                closeSel = { 'type': GeomWidgetSelType.Link, 'idx': n };\n                closeDelta = delta;\n            }\n        }\n        for (let n = 0; n < this.torsA.length; n++) {\n            let theta1 = Math.atan2(this.posY[this.torsA[n]] - cy, this.posX[this.torsA[n]] - cx);\n            let theta2 = Math.atan2(this.posY[this.torsB[n]] - cy, this.posX[this.torsB[n]] - cx);\n            let midtheta = theta1 + 0.5 * ((0,_util_util__WEBPACK_IMPORTED_MODULE_5__.angleDiff)(theta2, theta1));\n            let delta = Math.abs((0,_util_util__WEBPACK_IMPORTED_MODULE_5__.angleDiff)(midtheta, theta));\n            if (delta < closeDelta) {\n                closeSel = { 'type': GeomWidgetSelType.Torsion, 'idx': n };\n                closeDelta = delta;\n            }\n        }\n        return closeSel;\n    }\n    sameSelection(sel1, sel2) {\n        if (sel1 == null && sel2 == null)\n            return true;\n        if (sel1 == null || sel2 == null)\n            return false;\n        return sel1.type == sel2.type && sel1.idx == sel2.idx;\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/sketcher/GeomWidget.ts?");

/***/ }),

/***/ "./src/sketcher/MetalLigate.ts":
/*!*************************************!*\
  !*** ./src/sketcher/MetalLigate.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MetalLigate\": () => (/* binding */ MetalLigate)\n/* harmony export */ });\n/* harmony import */ var _data_Graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/Graph */ \"./src/data/Graph.ts\");\n/* harmony import */ var _data_Molecule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/Molecule */ \"./src/data/Molecule.ts\");\n/* harmony import */ var _data_MolUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data/MolUtil */ \"./src/data/MolUtil.ts\");\n/* harmony import */ var _util_Geom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Geom */ \"./src/util/Geom.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n\n\n\n\n\n\nclass MetalLigate {\n    constructor(mol, metalAtom, ligandAttach) {\n        this.metalAtom = metalAtom;\n        this.ligandAttach = ligandAttach;\n        this.ligands = [];\n        this.mol = mol.clone();\n    }\n    generate() {\n        const { mol, metalAtom, ligandAttach, ligands } = this;\n        let g = _data_Graph__WEBPACK_IMPORTED_MODULE_0__.Graph.fromMolecule(mol);\n        g.isolateNode(metalAtom - 1);\n        for (let cc of g.calculateComponentGroups()) {\n            _util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.addTo(cc, 1);\n            let anything = false;\n            for (let a of ligandAttach)\n                if (cc.indexOf(a) >= 0) {\n                    anything = true;\n                    break;\n                }\n            if (!anything)\n                continue;\n            let lig = { 'atoms': cc, 'attach': [] };\n            lig.atoms = cc;\n            let anyAttached = false;\n            for (let a of lig.atoms)\n                if (mol.findBond(a, metalAtom) > 0) {\n                    anyAttached = true;\n                    break;\n                }\n            for (let a of lig.atoms) {\n                let bonded = mol.findBond(a, metalAtom) > 0;\n                if (bonded || (!anyAttached && ligandAttach.includes(a)))\n                    lig.attach.push(a);\n            }\n            ligands.push(lig);\n            for (let a of lig.attach)\n                if (mol.findBond(a, metalAtom) == 0)\n                    this.makeLigandBond(a);\n        }\n        if (ligands.length == 0)\n            throw new Error('No ligand atoms');\n        let otherLigands = mol.atomAdjList(metalAtom);\n        for (let lig of ligands)\n            otherLigands = _util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.exclude(otherLigands, lig.attach);\n        let mx = mol.atomX(metalAtom), my = mol.atomY(metalAtom);\n        let otherTheta = new Array(otherLigands.length);\n        for (let n = 0; n < otherLigands.length; n++)\n            otherTheta[n] = Math.atan2(mol.atomY(otherLigands[n]) - my, mol.atomX(otherLigands[n]) - mx);\n        for (let lig of ligands) {\n            if (lig.attach.length == 1) {\n                let a = lig.attach[0];\n                lig.avgTheta = Math.atan2(mol.atomY(a) - my, mol.atomX(a) - mx);\n                this.orientLigand(lig);\n            }\n            else {\n                let theta = new Array(lig.attach.length);\n                for (let n = 0; n < lig.attach.length; n++) {\n                    let a = lig.attach[n];\n                    theta[n] = Math.atan2(mol.atomY(a) - my, mol.atomX(a) - mx);\n                }\n                theta = _util_Geom__WEBPACK_IMPORTED_MODULE_3__.GeomUtil.sortAngles(theta);\n                let base = theta[0];\n                for (let n = 0; n < theta.length; n++)\n                    theta[n] = (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.angleDiffPos)(theta[n], base);\n                lig.avgTheta = base + _util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.sum(theta) / theta.length;\n                this.orientLigand(lig);\n            }\n        }\n        if (otherLigands.length == 0) {\n            ligands.sort((l1, l2) => (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.signum)(l1.avgTheta - l2.avgTheta));\n            this.arrangeLigandsFree(ligands);\n        }\n        else if (otherLigands.length == 1) {\n            ligands.sort((l1, l2) => {\n                let diff1 = (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.angleDiffPos)(l1.avgTheta, otherTheta[0]);\n                let diff2 = (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.angleDiffPos)(l2.avgTheta, otherTheta[0]);\n                return (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.signum)(diff1 - diff2);\n            });\n            this.arrangeLigandsRange(ligands, otherTheta[0], _util_util__WEBPACK_IMPORTED_MODULE_4__.TWOPI, true);\n        }\n        else {\n            let otherOrder = _util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.idxSort(otherTheta);\n            for (let n = 0; n < otherOrder.length; n++) {\n                let nn = (n + 1) % otherOrder.length;\n                let theta = otherTheta[otherOrder[n]];\n                let extent = (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.angleDiffPos)(otherTheta[otherOrder[nn]], theta);\n                let batch = [];\n                for (let lig of ligands) {\n                    let diff = (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.angleDiffPos)(lig.avgTheta, theta);\n                    if (diff < extent)\n                        batch.push(lig);\n                }\n                if (batch.length == 0)\n                    continue;\n                batch.sort((l1, l2) => {\n                    let diff1 = (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.angleDiffPos)(l1.avgTheta, theta);\n                    let diff2 = (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.angleDiffPos)(l2.avgTheta, theta);\n                    return (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.signum)(diff1 - diff2);\n                });\n                this.arrangeLigandsRange(batch, theta, extent, true);\n            }\n        }\n        this.resolveClashes();\n        return mol;\n    }\n    makeLigandBond(ligAtom) {\n        const { mol, metalAtom } = this;\n        let mchg = mol.atomCharge(metalAtom), lchg = mol.atomCharge(ligAtom);\n        if (mchg > 0 && lchg < 0) {\n            mol.setAtomCharge(metalAtom, mchg - 1);\n            mol.setAtomCharge(ligAtom, lchg + 1);\n            mol.addBond(metalAtom, ligAtom, 1);\n            return;\n        }\n        if (mchg < 0 && lchg > 0) {\n            mol.setAtomCharge(metalAtom, mchg + 1);\n            mol.setAtomCharge(ligAtom, lchg - 1);\n            mol.addBond(metalAtom, ligAtom, 1);\n            return;\n        }\n        let order = 0;\n        if (mol.atomHExplicit(ligAtom) == _data_Molecule__WEBPACK_IMPORTED_MODULE_1__.Molecule.HEXPLICIT_UNKNOWN && mol.atomHydrogens(ligAtom) > 0)\n            order = 1;\n        mol.addBond(metalAtom, ligAtom, order);\n    }\n    orientLigand(lig) {\n        const { mol, metalAtom } = this;\n        let mx = mol.atomX(metalAtom), my = mol.atomY(metalAtom);\n        let lsz = lig.atoms.length, asz = lig.attach.length;\n        let idxAttach = new Array(asz);\n        for (let n = 0; n < asz; n++)\n            idxAttach[n] = lig.atoms.indexOf(lig.attach[n]);\n        let lx = new Array(lsz), ly = new Array(lsz);\n        let ax = _data_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.arrayAtomX(mol), ay = _data_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.arrayAtomY(mol);\n        let molExtent = _util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.max(ax) - _util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.min(ax) + _util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.max(ay) - _util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.min(ay);\n        let dx = molExtent * Math.cos(lig.avgTheta), dy = molExtent * Math.sin(lig.avgTheta);\n        for (let n = 0; n < lsz; n++) {\n            lx[n] = mol.atomX(lig.atoms[n]) + dx;\n            ly[n] = mol.atomY(lig.atoms[n]) + dy;\n        }\n        let cx = _util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.sum(lx) / lsz, cy = _util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.sum(ly) / lsz;\n        let weight = [];\n        for (let n = 0; n < lsz; n++) {\n            let closest = Number.POSITIVE_INFINITY;\n            for (let idx of idxAttach)\n                closest = Math.min(closest, (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.norm2_xy)(lx[n] - lx[idx], ly[n] - ly[idx]));\n            weight.push(1.0 / (1 + Math.sqrt(closest)));\n        }\n        let bestScore = Number.POSITIVE_INFINITY;\n        let bestLX = null, bestLY = null;\n        for (let theta = 0; theta < 360; theta += 15) {\n            let cosTheta = Math.cos(theta * _util_util__WEBPACK_IMPORTED_MODULE_4__.DEGRAD), sinTheta = Math.sin(theta * _util_util__WEBPACK_IMPORTED_MODULE_4__.DEGRAD);\n            let rx = new Array(lsz), ry = new Array(lsz);\n            let score = 0;\n            for (let n = 0; n < lsz; n++) {\n                let x = lx[n] - cx, y = ly[n] - cy;\n                rx[n] = cx + x * cosTheta - y * sinTheta;\n                ry[n] = cy + x * sinTheta + y * cosTheta;\n                let dist = (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.norm_xy)(rx[n] - mx, ry[n] - my);\n                if (lig.attach.indexOf(lig.atoms[n]) >= 0)\n                    score += dist;\n                else\n                    score -= dist * weight[n];\n            }\n            if (score < bestScore) {\n                bestScore = score;\n                bestLX = rx;\n                bestLY = ry;\n            }\n        }\n        lx = bestLX;\n        ly = bestLY;\n        if (asz == 1) {\n            dx = _data_Molecule__WEBPACK_IMPORTED_MODULE_1__.Molecule.IDEALBOND * Math.cos(lig.avgTheta);\n            dy = _data_Molecule__WEBPACK_IMPORTED_MODULE_1__.Molecule.IDEALBOND * Math.sin(lig.avgTheta);\n            _util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.addTo(lx, mx + dx - lx[idxAttach[0]]);\n            _util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.addTo(ly, my + dy - ly[idxAttach[0]]);\n        }\n        else {\n            let attTheta = new Array(asz), attDist = _util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.numberArray(0, asz), attDX = _util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.numberArray(0, asz), attDY = _util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.numberArray(0, asz);\n            for (let n = 0; n < asz; n++) {\n                let ox = lx[idxAttach[n]] - mx, oy = ly[idxAttach[n]] - my;\n                attTheta[n] = Math.atan2(oy, ox);\n                if (asz > 2) {\n                    attDist[n] = (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.norm_xy)(ox, oy);\n                    attDX[n] = ox / attDist[n];\n                    attDY[n] = oy / attDist[n];\n                }\n            }\n            _util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.addTo(attDist, -_util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.min(attDist));\n            let orderAttach = _util_Geom__WEBPACK_IMPORTED_MODULE_3__.GeomUtil.idxSortAngles(attTheta);\n            let srcX = new Array(asz), srcY = new Array(asz);\n            let dstX = new Array(asz), dstY = new Array(asz);\n            let dtheta = 45 * _util_util__WEBPACK_IMPORTED_MODULE_4__.DEGRAD / (asz - 1), theta = lig.avgTheta - 0.5 * dtheta;\n            for (let n = 0; n < asz; n++) {\n                srcX[n] = lx[idxAttach[orderAttach[n]]];\n                srcY[n] = ly[idxAttach[orderAttach[n]]];\n                dstX[n] = mx + _data_Molecule__WEBPACK_IMPORTED_MODULE_1__.Molecule.IDEALBOND * Math.cos(theta) + attDist[n] * attDX[n];\n                dstY[n] = my + _data_Molecule__WEBPACK_IMPORTED_MODULE_1__.Molecule.IDEALBOND * Math.sin(theta) + attDist[n] * attDY[n];\n                theta += dtheta / (asz - 1);\n            }\n            let tfm = _util_Geom__WEBPACK_IMPORTED_MODULE_3__.GeomUtil.superimpose(srcX, srcY, dstX, dstY);\n            for (let n = 0; n < lsz; n++) {\n                let [x, y] = _util_Geom__WEBPACK_IMPORTED_MODULE_3__.GeomUtil.applyAffine(lx[n], ly[n], tfm);\n                lx[n] = x;\n                ly[n] = y;\n            }\n        }\n        for (let n = 0; n < lsz; n++)\n            mol.setAtomPos(lig.atoms[n], lx[n], ly[n]);\n    }\n    arrangeLigandsFree(batch) {\n        if (batch.length == 1)\n            return;\n        let refTheta = _util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.last(batch).avgTheta;\n        refTheta += 0.5 * (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.angleDiffPos)(_util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.first(batch).avgTheta, refTheta);\n        this.arrangeLigandsRange(batch, refTheta, _util_util__WEBPACK_IMPORTED_MODULE_4__.TWOPI, false);\n    }\n    arrangeLigandsRange(batch, refTheta, refSpan, bounded) {\n        const { mol, metalAtom } = this;\n        let mx = mol.atomX(metalAtom), my = mol.atomY(metalAtom);\n        let bsz = batch.length;\n        let thetaMin = new Array(bsz), thetaSpan = new Array(bsz);\n        let ligandSpan = 0;\n        for (let n = 0; n < bsz; n++) {\n            let [theta1, theta2] = this.determineThetaBounds(batch[n]);\n            thetaMin[n] = theta1;\n            thetaSpan[n] = (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.angleDiffPos)(theta2, theta1);\n            ligandSpan += thetaSpan[n];\n        }\n        let residual = (refSpan - ligandSpan) / (bsz + (bounded ? 1 : 0));\n        let theta = refTheta + (bounded ? residual : 0.5 * residual);\n        for (let n = 0; n < bsz; n++) {\n            let rotTheta = theta - thetaMin[n];\n            let cosTheta = Math.cos(rotTheta), sinTheta = Math.sin(rotTheta);\n            for (let a of batch[n].atoms) {\n                let x = mol.atomX(a) - mx, y = mol.atomY(a) - my;\n                mol.setAtomPos(a, mx + x * cosTheta - y * sinTheta, my + x * sinTheta + y * cosTheta);\n            }\n            theta += thetaSpan[n] + residual;\n        }\n    }\n    determineThetaBounds(lig) {\n        const { mol, metalAtom } = this;\n        let theta = [];\n        let mx = mol.atomX(metalAtom), my = mol.atomY(metalAtom);\n        for (let n = 0; n < lig.attach.length; n++) {\n            let x = mol.atomX(lig.attach[n]) - mx;\n            let y = mol.atomY(lig.attach[n]) - my;\n            theta.push(Math.atan2(y, x));\n        }\n        _util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.sort(theta);\n        let bestScore = Number.POSITIVE_INFINITY, bestMin = 0, bestMax = 0;\n        for (let n = 0; n < theta.length; n++) {\n            let score = 0;\n            for (let i = 0; i < theta.length - 1; i++)\n                score += (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.angleDiffPos)(theta[i + 1], theta[i]);\n            if (score < bestScore) {\n                bestScore = score;\n                bestMin = _util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.first(theta);\n                bestMax = _util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.last(theta);\n            }\n            theta.push(theta.shift());\n        }\n        return [bestMin, bestMax];\n    }\n    resolveClashes() {\n        const { mol, metalAtom, ligands } = this;\n        const na = mol.numAtoms, nb = mol.numBonds, lsz = this.ligands.length;\n        let ablk = _util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.numberArray(-1, na), bblk = _util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.numberArray(-1, nb);\n        for (let n = 1; n <= na; n++)\n            if (mol.atomConnComp(n) == mol.atomConnComp(metalAtom))\n                ablk[n - 1] = 0;\n        for (let n = 0; n < lsz; n++)\n            for (let a of ligands[n].atoms)\n                ablk[a - 1] = n + 1;\n        for (let n = 1; n <= nb; n++) {\n            let blk1 = ablk[mol.bondFrom(n) - 1], blk2 = ablk[mol.bondTo(n) - 1];\n            if (blk1 < 0 || blk2 < 0) { }\n            else if (blk1 == blk2)\n                bblk[n - 1] = blk1;\n        }\n        let bumpDX = new Array(lsz), bumpDY = new Array(lsz);\n        let mx = mol.atomX(metalAtom), my = mol.atomY(metalAtom);\n        for (let n = 0; n < lsz; n++) {\n            let lig = ligands[n];\n            let dx = 0, dy = 0;\n            for (let a of lig.attach) {\n                dx += mol.atomX(a) - mx;\n                dy += mol.atomY(a) - my;\n            }\n            dx /= lig.attach.length;\n            dy /= lig.attach.length;\n            let invDist = 1.0 / (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.norm_xy)(dx, dy);\n            bumpDX[n] = dx * 0.5 * invDist;\n            bumpDY[n] = dy * 0.5 * invDist;\n        }\n        const CLOSE_SQ = (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.sqr)(0.5);\n        for (let count = 0; count < 12; count++) {\n            let tainted = _util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.booleanArray(false, lsz);\n            outer: for (let i = 0; i < na - 1; i++) {\n                if (ablk[i] < 0)\n                    continue;\n                for (let j = i + 1; j < na; j++)\n                    if (ablk[j] >= 0 && ablk[j] != ablk[i]) {\n                        if ((0,_util_util__WEBPACK_IMPORTED_MODULE_4__.norm2_xy)(mol.atomX(i + 1) - mol.atomX(j + 1), mol.atomY(i + 1) - mol.atomY(j + 1)) < CLOSE_SQ) {\n                            if (ablk[i] > 0)\n                                tainted[ablk[i] - 1] = true;\n                            if (ablk[j] > 0)\n                                tainted[ablk[j] - 1] = true;\n                        }\n                        if (_util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.allTrue(tainted))\n                            break outer;\n                    }\n            }\n            if (_util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.anyFalse(tainted))\n                outer: for (let i = 0; i < nb - 1; i++) {\n                    if (bblk[i] < 0)\n                        continue;\n                    let x1 = mol.atomX(mol.bondFrom(i + 1)), y1 = mol.atomY(mol.bondFrom(i + 1));\n                    let x2 = mol.atomX(mol.bondTo(i + 1)), y2 = mol.atomY(mol.bondTo(i + 1));\n                    for (let j = i + 1; j < nb; j++)\n                        if (bblk[j] >= 0 && bblk[j] != bblk[i]) {\n                            let x3 = mol.atomX(mol.bondFrom(j + 1)), y3 = mol.atomY(mol.bondFrom(j + 1));\n                            let x4 = mol.atomX(mol.bondTo(j + 1)), y4 = mol.atomY(mol.bondTo(j + 1));\n                            if (_util_Geom__WEBPACK_IMPORTED_MODULE_3__.GeomUtil.doLineSegsIntersect(x1, y1, x2, y2, x3, y3, x4, y4)) {\n                                if (bblk[i] > 0)\n                                    tainted[bblk[i] - 1] = true;\n                                if (bblk[j] > 0)\n                                    tainted[bblk[j] - 1] = true;\n                            }\n                            if (_util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.allTrue(tainted))\n                                break outer;\n                        }\n                }\n            if (_util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.allFalse(tainted))\n                break;\n            for (let n = 0; n < lsz; n++)\n                if (tainted[n]) {\n                    for (let a of ligands[n].atoms) {\n                        mol.setAtomPos(a, mol.atomX(a) + bumpDX[n], mol.atomY(a) + bumpDY[n]);\n                    }\n                }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/sketcher/MetalLigate.ts?");

/***/ }),

/***/ "./src/sketcher/MoleculeActivity.ts":
/*!******************************************!*\
  !*** ./src/sketcher/MoleculeActivity.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ActivityType\": () => (/* binding */ ActivityType),\n/* harmony export */   \"MoleculeActivity\": () => (/* binding */ MoleculeActivity)\n/* harmony export */ });\n/* harmony import */ var _data_BondArtifact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/BondArtifact */ \"./src/data/BondArtifact.ts\");\n/* harmony import */ var _data_Chemistry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/Chemistry */ \"./src/data/Chemistry.ts\");\n/* harmony import */ var _data_CoordUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data/CoordUtil */ \"./src/data/CoordUtil.ts\");\n/* harmony import */ var _data_Graph__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../data/Graph */ \"./src/data/Graph.ts\");\n/* harmony import */ var _data_Molecule__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../data/Molecule */ \"./src/data/Molecule.ts\");\n/* harmony import */ var _data_MolUtil__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../data/MolUtil */ \"./src/data/MolUtil.ts\");\n/* harmony import */ var _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../data/PolymerBlock */ \"./src/data/PolymerBlock.ts\");\n/* harmony import */ var _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../data/QueryUtil */ \"./src/data/QueryUtil.ts\");\n/* harmony import */ var _data_SketchUtil__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../data/SketchUtil */ \"./src/data/SketchUtil.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _MetalLigate__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./MetalLigate */ \"./src/sketcher/MetalLigate.ts\");\n/* harmony import */ var _TemplateFusion__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./TemplateFusion */ \"./src/sketcher/TemplateFusion.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar ActivityType;\n(function (ActivityType) {\n    ActivityType[ActivityType[\"Delete\"] = 1] = \"Delete\";\n    ActivityType[ActivityType[\"Clear\"] = 2] = \"Clear\";\n    ActivityType[ActivityType[\"Copy\"] = 3] = \"Copy\";\n    ActivityType[ActivityType[\"Cut\"] = 4] = \"Cut\";\n    ActivityType[ActivityType[\"SelectAll\"] = 5] = \"SelectAll\";\n    ActivityType[ActivityType[\"SelectNone\"] = 6] = \"SelectNone\";\n    ActivityType[ActivityType[\"SelectPrevComp\"] = 7] = \"SelectPrevComp\";\n    ActivityType[ActivityType[\"SelectNextComp\"] = 8] = \"SelectNextComp\";\n    ActivityType[ActivityType[\"SelectSide\"] = 9] = \"SelectSide\";\n    ActivityType[ActivityType[\"SelectGrow\"] = 10] = \"SelectGrow\";\n    ActivityType[ActivityType[\"SelectShrink\"] = 11] = \"SelectShrink\";\n    ActivityType[ActivityType[\"SelectChain\"] = 12] = \"SelectChain\";\n    ActivityType[ActivityType[\"SelectSmRing\"] = 13] = \"SelectSmRing\";\n    ActivityType[ActivityType[\"SelectRingBlk\"] = 14] = \"SelectRingBlk\";\n    ActivityType[ActivityType[\"SelectCurElement\"] = 15] = \"SelectCurElement\";\n    ActivityType[ActivityType[\"SelectToggle\"] = 16] = \"SelectToggle\";\n    ActivityType[ActivityType[\"SelectUnCurrent\"] = 17] = \"SelectUnCurrent\";\n    ActivityType[ActivityType[\"Element\"] = 18] = \"Element\";\n    ActivityType[ActivityType[\"AtomPos\"] = 19] = \"AtomPos\";\n    ActivityType[ActivityType[\"Charge\"] = 20] = \"Charge\";\n    ActivityType[ActivityType[\"Connect\"] = 21] = \"Connect\";\n    ActivityType[ActivityType[\"Disconnect\"] = 22] = \"Disconnect\";\n    ActivityType[ActivityType[\"MetalLigate\"] = 23] = \"MetalLigate\";\n    ActivityType[ActivityType[\"BondOrder\"] = 24] = \"BondOrder\";\n    ActivityType[ActivityType[\"BondType\"] = 25] = \"BondType\";\n    ActivityType[ActivityType[\"BondGeom\"] = 26] = \"BondGeom\";\n    ActivityType[ActivityType[\"BondAtom\"] = 27] = \"BondAtom\";\n    ActivityType[ActivityType[\"BondSwitch\"] = 28] = \"BondSwitch\";\n    ActivityType[ActivityType[\"BondRotate\"] = 29] = \"BondRotate\";\n    ActivityType[ActivityType[\"BondAddTwo\"] = 30] = \"BondAddTwo\";\n    ActivityType[ActivityType[\"BondInsert\"] = 31] = \"BondInsert\";\n    ActivityType[ActivityType[\"Join\"] = 32] = \"Join\";\n    ActivityType[ActivityType[\"Nudge\"] = 33] = \"Nudge\";\n    ActivityType[ActivityType[\"NudgeLots\"] = 34] = \"NudgeLots\";\n    ActivityType[ActivityType[\"NudgeFar\"] = 35] = \"NudgeFar\";\n    ActivityType[ActivityType[\"Flip\"] = 36] = \"Flip\";\n    ActivityType[ActivityType[\"Scale\"] = 37] = \"Scale\";\n    ActivityType[ActivityType[\"Rotate\"] = 38] = \"Rotate\";\n    ActivityType[ActivityType[\"BondDist\"] = 39] = \"BondDist\";\n    ActivityType[ActivityType[\"AlignAngle\"] = 40] = \"AlignAngle\";\n    ActivityType[ActivityType[\"AlignRegular\"] = 41] = \"AlignRegular\";\n    ActivityType[ActivityType[\"AdjustTorsion\"] = 42] = \"AdjustTorsion\";\n    ActivityType[ActivityType[\"Move\"] = 43] = \"Move\";\n    ActivityType[ActivityType[\"Ring\"] = 44] = \"Ring\";\n    ActivityType[ActivityType[\"TemplateFusion\"] = 45] = \"TemplateFusion\";\n    ActivityType[ActivityType[\"AbbrevTempl\"] = 46] = \"AbbrevTempl\";\n    ActivityType[ActivityType[\"AbbrevGroup\"] = 47] = \"AbbrevGroup\";\n    ActivityType[ActivityType[\"AbbrevFormula\"] = 48] = \"AbbrevFormula\";\n    ActivityType[ActivityType[\"AbbrevClear\"] = 49] = \"AbbrevClear\";\n    ActivityType[ActivityType[\"AbbrevExpand\"] = 50] = \"AbbrevExpand\";\n    ActivityType[ActivityType[\"BondArtifactPath\"] = 51] = \"BondArtifactPath\";\n    ActivityType[ActivityType[\"BondArtifactRing\"] = 52] = \"BondArtifactRing\";\n    ActivityType[ActivityType[\"BondArtifactArene\"] = 53] = \"BondArtifactArene\";\n    ActivityType[ActivityType[\"BondArtifactClear\"] = 54] = \"BondArtifactClear\";\n    ActivityType[ActivityType[\"PolymerBlock\"] = 55] = \"PolymerBlock\";\n    ActivityType[ActivityType[\"AddHydrogens\"] = 56] = \"AddHydrogens\";\n    ActivityType[ActivityType[\"RemoveHydrogens\"] = 57] = \"RemoveHydrogens\";\n    ActivityType[ActivityType[\"QueryClear\"] = 58] = \"QueryClear\";\n    ActivityType[ActivityType[\"QueryCopy\"] = 59] = \"QueryCopy\";\n    ActivityType[ActivityType[\"QueryPaste\"] = 60] = \"QueryPaste\";\n    ActivityType[ActivityType[\"QuerySetAtom\"] = 61] = \"QuerySetAtom\";\n    ActivityType[ActivityType[\"QuerySetBond\"] = 62] = \"QuerySetBond\";\n    ActivityType[ActivityType[\"QueryBondAny\"] = 63] = \"QueryBondAny\";\n})(ActivityType || (ActivityType = {}));\nclass MoleculeActivity {\n    constructor(input, activity, param, owner) {\n        this.input = input;\n        this.activity = activity;\n        this.param = param;\n        this.owner = owner;\n        this.toClipboard = null;\n        this.output =\n            {\n                'mol': null,\n                'currentAtom': -1,\n                'currentBond': -1,\n                'selectedMask': null\n            };\n        let na = this.input.mol.numAtoms;\n        if (this.input.selectedMask == null)\n            this.input.selectedMask = _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.booleanArray(false, na);\n        while (this.input.selectedMask.length < na)\n            this.input.selectedMask.push(false);\n        this.subjectMask = this.input.selectedMask.slice(0);\n        this.subjectLength = _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.maskCount(this.subjectMask);\n        this.subjectIndex = [];\n        this.hasSelected = this.subjectLength > 0;\n        if (this.subjectLength == 0) {\n            if (this.input.currentAtom > 0) {\n                this.subjectLength = 1;\n                this.subjectMask[this.input.currentAtom - 1] = true;\n                this.subjectIndex = [this.input.currentAtom];\n            }\n            else if (this.input.currentBond > 0) {\n                let bfr = this.input.mol.bondFrom(this.input.currentBond), bto = this.input.mol.bondTo(this.input.currentBond);\n                let b1 = Math.min(bfr, bto), b2 = Math.max(bfr, bto);\n                this.subjectLength = 2;\n                this.subjectMask[b1 - 1] = true;\n                this.subjectMask[b2 - 1] = true;\n                this.subjectIndex = [b1, b2];\n            }\n        }\n        else {\n            this.subjectIndex = _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.maskIdx(this.subjectMask);\n            _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.addTo(this.subjectIndex, 1);\n        }\n    }\n    setOwner(owner) {\n        this.owner = owner;\n    }\n    evaluate() {\n        return true;\n    }\n    execute() {\n        let param = this.param;\n        if (this.activity == ActivityType.Delete)\n            this.execDelete();\n        else if (this.activity == ActivityType.Clear)\n            this.execClear();\n        else if (this.activity == ActivityType.Copy)\n            this.execCopy(false);\n        else if (this.activity == ActivityType.Cut)\n            this.execCopy(true);\n        else if (this.activity == ActivityType.SelectAll)\n            this.execSelectAll(true);\n        else if (this.activity == ActivityType.SelectNone)\n            this.execSelectAll(false);\n        else if (this.activity == ActivityType.SelectPrevComp)\n            this.execSelectComp(-1);\n        else if (this.activity == ActivityType.SelectNextComp)\n            this.execSelectComp(1);\n        else if (this.activity == ActivityType.SelectSide)\n            this.execSelectSide();\n        else if (this.activity == ActivityType.SelectGrow)\n            this.execSelectGrow();\n        else if (this.activity == ActivityType.SelectShrink)\n            this.execSelectShrink();\n        else if (this.activity == ActivityType.SelectChain)\n            this.execSelectChain();\n        else if (this.activity == ActivityType.SelectSmRing)\n            this.execSelectSmRing();\n        else if (this.activity == ActivityType.SelectRingBlk)\n            this.execSelectRingBlk();\n        else if (this.activity == ActivityType.SelectCurElement)\n            this.execSelectCurElement();\n        else if (this.activity == ActivityType.SelectToggle)\n            this.execSelectToggle();\n        else if (this.activity == ActivityType.SelectUnCurrent)\n            this.execSelectUnCurrent();\n        else if (this.activity == ActivityType.Element)\n            this.execElement(param.element, param.positionX, param.positionY, param.keepAbbrev);\n        else if (this.activity == ActivityType.Charge)\n            this.execCharge(param.delta);\n        else if (this.activity == ActivityType.Connect)\n            this.execConnect(1, _data_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_NORMAL);\n        else if (this.activity == ActivityType.Disconnect)\n            this.execDisconnect();\n        else if (this.activity == ActivityType.MetalLigate)\n            this.execMetalLigate();\n        else if (this.activity == ActivityType.BondOrder)\n            this.execBond(param.order, _data_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_NORMAL);\n        else if (this.activity == ActivityType.BondType)\n            this.execBond(1, param.type);\n        else if (this.activity == ActivityType.BondGeom)\n            this.execBondGeom(param.geom);\n        else if (this.activity == ActivityType.BondAtom)\n            this.execBondAtom(param.order, param.type, param.element, param.x1, param.y1, param.x2, param.y2);\n        else if (this.activity == ActivityType.BondSwitch)\n            this.execBondSwitch();\n        else if (this.activity == ActivityType.BondRotate)\n            this.execBondRotate();\n        else if (this.activity == ActivityType.BondAddTwo)\n            this.execBondAddTwo();\n        else if (this.activity == ActivityType.BondInsert)\n            this.execBondInsert();\n        else if (this.activity == ActivityType.Join)\n            this.execJoin();\n        else if (this.activity == ActivityType.Nudge)\n            this.execNudge(param.dir, 0.1);\n        else if (this.activity == ActivityType.NudgeLots)\n            this.execNudge(param.dir, 1);\n        else if (this.activity == ActivityType.NudgeFar)\n            this.execNudgeFar(param.dir);\n        else if (this.activity == ActivityType.Flip)\n            this.execFlip(param.axis);\n        else if (this.activity == ActivityType.Scale)\n            this.execScale(param.mag);\n        else if (this.activity == ActivityType.Rotate)\n            this.execRotate(param.theta, param.centreX, param.centreY);\n        else if (this.activity == ActivityType.BondDist)\n            this.execBondDist(param.dist);\n        else if (this.activity == ActivityType.AlignAngle)\n            this.execAlignAngle(param.angle);\n        else if (this.activity == ActivityType.AlignRegular)\n            this.execAlignRegular();\n        else if (this.activity == ActivityType.AdjustTorsion)\n            this.execAdjustTorsion(param.angle);\n        else if (this.activity == ActivityType.Move)\n            this.execMove(param.refAtom, param.deltaX, param.deltaY);\n        else if (this.activity == ActivityType.Ring)\n            this.execRing(param.ringX, param.ringY, param.aromatic);\n        else if (this.activity == ActivityType.TemplateFusion) {\n            this.execTemplateFusion(_data_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.fromString(param.fragNative));\n            if (this.owner)\n                this.owner.setPermutations(this.output.permutations);\n            return;\n        }\n        else if (this.activity == ActivityType.AbbrevTempl)\n            this.execAbbrevTempl();\n        else if (this.activity == ActivityType.AbbrevGroup)\n            this.execAbbrevGroup();\n        else if (this.activity == ActivityType.AbbrevFormula)\n            this.execAbbrevFormula();\n        else if (this.activity == ActivityType.AbbrevClear)\n            this.execAbbrevClear();\n        else if (this.activity == ActivityType.AbbrevExpand)\n            this.execAbbrevExpand();\n        else if (this.activity == ActivityType.BondArtifactPath || this.activity == ActivityType.BondArtifactRing ||\n            this.activity == ActivityType.BondArtifactArene || this.activity == ActivityType.BondArtifactClear)\n            this.execBondArtifact(this.activity);\n        else if (this.activity == ActivityType.PolymerBlock)\n            this.execPolymerBlock();\n        else if (this.activity == ActivityType.AddHydrogens)\n            this.execAddHydrogens();\n        else if (this.activity == ActivityType.RemoveHydrogens)\n            this.execRemoveHydrogens();\n        else if (this.activity == ActivityType.QueryClear)\n            this.execQueryClear();\n        else if (this.activity == ActivityType.QueryCopy)\n            this.execQueryCopy();\n        else if (this.activity == ActivityType.QueryPaste)\n            this.execQueryPaste();\n        else if (this.activity == ActivityType.QuerySetAtom)\n            this.execQuerySetAtom();\n        else if (this.activity == ActivityType.QuerySetBond)\n            this.execQuerySetBond();\n        else if (this.activity == ActivityType.QueryBondAny)\n            this.execQueryBondAny();\n        this.finish();\n    }\n    finish() {\n        if (!this.owner)\n            return;\n        if (this.output.mol != null || this.output.currentAtom >= 0 || this.output.currentBond >= 0 || this.output.selectedMask != null) {\n            this.owner.setState(this.output, true);\n            if (this.errmsg != null)\n                this.owner.showMessage(this.errmsg, false);\n        }\n        else {\n            if (this.errmsg != null)\n                this.owner.showMessage(this.errmsg, true);\n        }\n    }\n    execDelete() {\n        if (!this.requireSubject())\n            return;\n        let mol = this.input.mol;\n        this.output.mol = mol.clone();\n        this.zapSubject();\n        if (this.input.currentBond > 0 && !this.hasSelected) {\n            this.output.mol.deleteBond(this.input.currentBond);\n            this.output.currentBond = 0;\n            return;\n        }\n        if (this.subjectLength == 1 && this.subjectIndex[0] == this.input.currentAtom) {\n            let adj = mol.atomAdjList(this.input.currentAtom);\n            if (adj.length == 1) {\n                this.output.currentAtom = adj[0];\n                if (this.output.currentAtom > this.input.currentAtom)\n                    this.output.currentAtom--;\n            }\n        }\n        for (let n = this.subjectLength - 1; n >= 0; n--)\n            this.output.mol.deleteAtomAndBonds(this.subjectIndex[n]);\n    }\n    execCopy(withCut) {\n        let mol = this.input.mol;\n        if (this.subjectLength > 0)\n            mol = _data_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.subgraphWithAttachments(mol, this.subjectMask);\n        if (this.owner)\n            this.owner.performCopy(mol);\n        else\n            this.toClipboard = mol.toString();\n        if (withCut) {\n            this.zapSubject();\n            this.output.mol = _data_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.subgraphMask(this.input.mol, _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.notMask(this.subjectMask));\n        }\n    }\n    execClear() {\n        this.output.mol = new _data_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule();\n        this.zapSubject();\n    }\n    execSelectAll(all) {\n        let same = true;\n        for (let n = 0; n < this.input.mol.numAtoms; n++)\n            if (this.subjectMask[n] != all) {\n                same = false;\n                break;\n            }\n        if (same) {\n            this.errmsg = all ? 'All atoms already selected.' : 'All atoms already deselected.';\n            return;\n        }\n        this.output.selectedMask = _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.booleanArray(all, this.input.mol.numAtoms);\n    }\n    execSelectComp(dir) {\n        let cclist = _data_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.componentList(this.input.mol);\n        if (cclist.length == 1 && this.hasSelected && this.subjectLength == this.input.mol.numAtoms) {\n            this.errmsg = 'All atoms already selected.';\n            return;\n        }\n        let sel = this.pickSelectedGroup(cclist, dir);\n        this.output.selectedMask = _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.booleanArray(false, this.input.mol.numAtoms);\n        for (let n = 0; n < cclist[sel].length; n++)\n            this.output.selectedMask[cclist[sel][n] - 1] = true;\n    }\n    execSelectSide() {\n        if (!this.requireCurrent())\n            return;\n        let mol = this.input.mol, currentAtom = this.input.currentAtom, currentBond = this.input.currentBond;\n        if (currentAtom > 0 && mol.atomAdjCount(currentAtom) == 0) {\n            this.errmsg = 'Current atom has no neighbours.';\n            return;\n        }\n        if (currentBond > 0 && mol.atomAdjCount(mol.bondFrom(currentBond)) == 1 && mol.atomAdjCount(mol.bondTo(currentBond)) == 1) {\n            this.errmsg = 'Current bond has no neighbours.';\n            return;\n        }\n        let sides = currentAtom > 0 ? _data_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.getAtomSides(mol, currentAtom) : _data_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.getBondSides(mol, currentBond);\n        let sel = this.pickSelectedGroup(sides, 1);\n        this.output.selectedMask = _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.booleanArray(false, mol.numAtoms);\n        for (let n = 0; n < sides[sel].length; n++)\n            this.output.selectedMask[sides[sel][n] - 1] = true;\n    }\n    execSelectGrow() {\n        if (!this.requireSubject())\n            return;\n        let mol = this.input.mol, currentAtom = this.input.currentAtom, currentBond = this.input.currentBond;\n        this.output.selectedMask = this.input.selectedMask.slice(0);\n        if (!this.hasSelected) {\n            if (currentAtom > 0) {\n                this.output.selectedMask[currentAtom - 1] = true;\n            }\n            else {\n                this.output.selectedMask[mol.bondFrom(currentBond) - 1] = true;\n                this.output.selectedMask[mol.bondTo(currentBond) - 1] = true;\n            }\n        }\n        else {\n            for (let n = 1; n <= mol.numBonds; n++) {\n                let bfr = mol.bondFrom(n) - 1, bto = mol.bondTo(n) - 1;\n                if (this.input.selectedMask[bfr] && !this.input.selectedMask[bto])\n                    this.output.selectedMask[bto] = true;\n                else if (this.input.selectedMask && !this.input.selectedMask[bfr])\n                    this.output.selectedMask[bfr] = true;\n            }\n        }\n    }\n    execSelectShrink() {\n        if (!this.requireSelected())\n            return;\n        let mol = this.input.mol;\n        let count = _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.numberArray(0, mol.numAtoms);\n        for (let n = 1; n <= mol.numBonds; n++) {\n            let bfr = mol.bondFrom(n) - 1, bto = mol.bondTo(n) - 1;\n            if (!this.input.selectedMask[bfr] || !this.input.selectedMask[bto])\n                continue;\n            count[bfr]++;\n            count[bto]++;\n        }\n        this.output.selectedMask = this.input.selectedMask.slice(0);\n        for (let n = 0; n < mol.numAtoms; n++)\n            this.output.selectedMask[n] = this.input.selectedMask[n] && count[n] >= 2;\n    }\n    execSelectChain() {\n        if (!this.requireSubject())\n            return;\n        let mol = this.input.mol;\n        this.output.selectedMask = this.input.selectedMask.slice(0);\n        for (let n = 1; n <= mol.numBonds; n++) {\n            let bfr = mol.bondFrom(n) - 1, bto = mol.bondTo(n) - 1;\n            if (this.input.selectedMask[bfr] && !this.input.selectedMask[bto] && mol.atomRingBlock(bto + 1) == 0)\n                this.output.selectedMask[bto] = true;\n            else if (this.input.selectedMask[bto] && !this.input.selectedMask[bfr] && mol.atomRingBlock(bfr + 1) == 0)\n                this.output.selectedMask[bfr] = true;\n        }\n    }\n    execSelectSmRing() {\n        if (!this.requireSubject())\n            return;\n        this.output.selectedMask = this.input.selectedMask.slice(0);\n        for (let r = 3; r <= 8; r++) {\n            let rings = this.input.mol.findRingsOfSize(r);\n            for (let i = 0; i < rings.length; i++) {\n                let any = false;\n                for (let j = 0; j < rings[i].length; j++)\n                    if (this.subjectMask[rings[i][j] - 1]) {\n                        any = true;\n                        break;\n                    }\n                if (any)\n                    for (let j = 0; j < rings[i].length; j++)\n                        this.output.selectedMask[rings[i][j] - 1] = true;\n            }\n        }\n    }\n    execSelectRingBlk() {\n        if (!this.requireSubject())\n            return;\n        let mol = this.input.mol;\n        this.output.selectedMask = this.input.selectedMask.slice(0);\n        let maxRB = 0;\n        for (let n = 1; n <= mol.numAtoms; n++)\n            maxRB = Math.max(maxRB, mol.atomRingBlock(n));\n        if (maxRB == 0)\n            return;\n        let gotRB = _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.booleanArray(false, maxRB);\n        for (let n = 1; n <= mol.numAtoms; n++) {\n            let rb = mol.atomRingBlock(n);\n            if (rb > 0 && this.subjectMask[n - 1])\n                gotRB[rb - 1] = true;\n        }\n        for (let n = 1; n <= mol.numAtoms; n++) {\n            let rb = mol.atomRingBlock(n);\n            if (rb > 0 && gotRB[rb - 1])\n                this.output.selectedMask[n - 1] = true;\n        }\n    }\n    execSelectCurElement() {\n        if (!this.requireCurrent())\n            return;\n        let mol = this.input.mol;\n        this.output.selectedMask = this.input.selectedMask.slice(0);\n        let el1 = '', el2 = '';\n        if (this.input.currentAtom > 0) {\n            el1 = mol.atomElement(this.input.currentAtom);\n        }\n        else {\n            el1 = mol.atomElement(mol.bondFrom(this.input.currentBond));\n            el2 = mol.atomElement(mol.bondTo(this.input.currentBond));\n        }\n        for (let n = 1; n <= mol.numAtoms; n++)\n            if (mol.atomElement(n) == el1 || mol.atomElement(n) == el2)\n                this.output.selectedMask[n - 1] = true;\n    }\n    execSelectToggle() {\n        if (!this.requireCurrent())\n            return;\n        this.output.selectedMask = this.input.selectedMask.slice(0);\n        if (this.input.currentAtom > 0) {\n            this.output.selectedMask[this.input.currentAtom - 1] = !this.output.selectedMask[this.input.currentAtom - 1];\n        }\n        else {\n            let bfr = this.input.mol.bondFrom(this.input.currentBond), bto = this.input.mol.bondTo(this.input.currentBond);\n            let sel = !this.input.selectedMask[bfr - 1] || !this.input.selectedMask[bto - 1];\n            this.output.selectedMask[bfr - 1] = sel;\n            this.output.selectedMask[bto - 1] = sel;\n        }\n    }\n    execSelectUnCurrent() {\n        if (!this.requireCurrent())\n            return;\n        this.output.selectedMask = this.input.selectedMask.slice(0);\n        if (this.input.currentAtom > 0) {\n            this.output.selectedMask[this.input.currentAtom - 1] = false;\n        }\n        else {\n            this.output.selectedMask[this.input.mol.bondFrom(this.input.currentBond) - 1] = false;\n            this.output.selectedMask[this.input.mol.bondTo(this.input.currentBond) - 1] = false;\n        }\n    }\n    execElement(element, positionX, positionY, keepAbbrev) {\n        const QUERY_ELEMENTS = ['A', 'X', 'Y', 'Z', 'Q', 'M', 'T', 'E', 'R'];\n        if (this.subjectLength > 0 && !QUERY_ELEMENTS.includes(element)) {\n            let anyChange = false;\n            for (let n = 0; n < this.subjectLength; n++)\n                if (this.input.mol.atomElement(this.subjectIndex[n]) != element) {\n                    anyChange = true;\n                    break;\n                }\n            if (!anyChange) {\n                this.errmsg = 'Elements not changed.';\n                return;\n            }\n        }\n        let mol = this.output.mol = this.input.mol.clone();\n        let applyQuery = (atom) => {\n            if (element == 'A') {\n                _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryUtil.setQueryAtomElementsNot(mol, atom, ['H']);\n                _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryUtil.deleteQueryAtom(mol, atom, _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryTypeAtom.Elements);\n            }\n            else if (element == 'X') {\n                _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryUtil.setQueryAtomElements(mol, atom, ['F', 'Cl', 'Br', 'I']);\n                _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryUtil.deleteQueryAtom(mol, atom, _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryTypeAtom.ElementsNot);\n            }\n            else if (element == 'Y') {\n                _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryUtil.setQueryAtomElements(mol, atom, ['O', 'S', 'Se', 'Te']);\n                _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryUtil.deleteQueryAtom(mol, atom, _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryTypeAtom.ElementsNot);\n            }\n            else if (element == 'Z') {\n                _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryUtil.setQueryAtomElements(mol, atom, ['F', 'Cl', 'Br', 'O', 'S']);\n                _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryUtil.deleteQueryAtom(mol, atom, _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryTypeAtom.ElementsNot);\n            }\n            else if (element == 'Q') {\n                _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryUtil.setQueryAtomElementsNot(mol, atom, ['H', 'C']);\n                _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryUtil.deleteQueryAtom(mol, atom, _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryTypeAtom.Elements);\n            }\n            else if (element == 'M') {\n                const NON_METALS = ['H', 'B', 'C', 'N', 'O', 'F', 'Si', 'P', 'S', 'Cl', 'As', 'Se', 'Br', 'Te', 'I'];\n                _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryUtil.setQueryAtomElementsNot(mol, atom, NON_METALS);\n                _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryUtil.deleteQueryAtom(mol, atom, _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryTypeAtom.Elements);\n            }\n            else if (element == 'T') {\n                const TRANSITION_METALS = [\n                    'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn',\n                    'Y', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd',\n                    'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg',\n                    'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu',\n                    'Ac', 'Th', 'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', 'Md', 'No', 'Lr'\n                ];\n                _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryUtil.setQueryAtomElements(mol, atom, TRANSITION_METALS);\n                _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryUtil.deleteQueryAtom(mol, atom, _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryTypeAtom.ElementsNot);\n            }\n            else if (element == 'E') {\n                const MAIN_GROUPS = [\n                    'B', 'N', 'O', 'F',\n                    'Al', 'Si', 'P', 'S', 'Cl',\n                    'Zn', 'Ga', 'Se', 'As', 'Se', 'Br',\n                    'Cd', 'In', 'Sn', 'Sb', 'Te', 'I',\n                    'Hg', 'Tl', 'Pb', 'Bi', 'Pb', 'At'\n                ];\n                _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryUtil.setQueryAtomElements(mol, atom, MAIN_GROUPS);\n                _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryUtil.deleteQueryAtom(mol, atom, _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryTypeAtom.ElementsNot);\n            }\n            else if (element == 'R') {\n                _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryUtil.setQueryAtomElements(mol, atom, ['C', 'N', 'O', 'S', 'P', 'H']);\n                _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryUtil.deleteQueryAtom(mol, atom, _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryTypeAtom.ElementsNot);\n            }\n        };\n        if (mol.numAtoms == 0) {\n            mol.addAtom(element, 0, 0);\n            applyQuery(mol.numAtoms);\n        }\n        else if (this.subjectLength == 0) {\n            if (positionX != null && positionY != null)\n                mol.addAtom(element, positionX, positionY);\n            else\n                _data_SketchUtil__WEBPACK_IMPORTED_MODULE_8__.SketchUtil.placeNewAtom(mol, element);\n            applyQuery(mol.numAtoms);\n        }\n        else {\n            for (let n = 0; n < this.subjectLength; n++) {\n                if (keepAbbrev)\n                    mol.setAtomElement(this.subjectIndex[n], element);\n                else\n                    _data_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.setAtomElement(mol, this.subjectIndex[n], element);\n                applyQuery(this.subjectIndex[n]);\n            }\n        }\n    }\n    execCharge(delta) {\n        if (!this.requireSubject())\n            return;\n        this.output.mol = this.input.mol.clone();\n        for (let n = 0; n < this.subjectLength; n++) {\n            let chg = Math.max(-20, Math.min(20, this.input.mol.atomCharge(this.subjectIndex[n]) + delta));\n            this.output.mol.setAtomCharge(this.subjectIndex[n], chg);\n        }\n    }\n    execConnect(order, type) {\n        if (!this.requireSubject())\n            return;\n        let conn = _data_SketchUtil__WEBPACK_IMPORTED_MODULE_8__.SketchUtil.pickAtomsToConnect(this.input.mol, this.subjectIndex);\n        if (conn == null) {\n            this.errmsg = 'Subject atoms contain no bonds suitable for connection.';\n            return;\n        }\n        this.output.mol = this.input.mol.clone();\n        for (let n = 0; n < conn.length; n += 2)\n            _data_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.addBond(this.output.mol, conn[n], conn[n + 1], order, type);\n    }\n    execDisconnect() {\n        let zap = [];\n        let mol = this.input.mol;\n        if (this.hasSelected) {\n            for (let n = 1; n <= mol.numBonds; n++)\n                if (this.subjectMask[mol.bondFrom(n) - 1] && this.subjectMask[mol.bondTo(n) - 1])\n                    zap.push(n);\n        }\n        else if (this.input.currentAtom > 0) {\n            for (let a of mol.atomAdjBonds(this.input.currentAtom))\n                zap.push(a);\n        }\n        else if (this.input.currentBond > 0) {\n            zap.push(this.input.currentBond);\n        }\n        if (zap.length == 0) {\n            this.errmsg = 'Subject atoms contain no bonds suitable for disconnection.';\n            return;\n        }\n        let killmask = _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.booleanArray(false, mol.numBonds);\n        for (let b of zap)\n            killmask[b - 1] = true;\n        this.output.mol = this.input.mol.clone();\n        for (let n = mol.numBonds; n >= 1; n--)\n            if (killmask[n - 1])\n                this.output.mol.deleteBond(n);\n    }\n    execMetalLigate() {\n        if (!this.requireSubject())\n            return;\n        let mol = this.input.mol;\n        let ligAtoms = this.subjectIndex.slice(0);\n        let metalAtom = this.input.currentAtom;\n        if (metalAtom == 0) {\n            for (let a of this.subjectIndex) {\n                let atno = mol.atomicNumber(a);\n                if (_data_Chemistry__WEBPACK_IMPORTED_MODULE_1__.Chemistry.ELEMENT_BLOCKS[atno] >= 3) {\n                    metalAtom = a;\n                    break;\n                }\n            }\n        }\n        if (metalAtom == 0) {\n            for (let a of this.subjectIndex) {\n                let atno = mol.atomicNumber(a);\n                if (_data_Chemistry__WEBPACK_IMPORTED_MODULE_1__.Chemistry.ELEMENT_ROWS[atno] >= 3) {\n                    metalAtom = a;\n                    break;\n                }\n            }\n        }\n        if (metalAtom == 0) {\n            this.errmsg = 'Unsure which is the metal atom: try indicating as current.';\n            return;\n        }\n        let i = ligAtoms.indexOf(metalAtom);\n        if (i >= 0)\n            ligAtoms.splice(i, 1);\n        if (ligAtoms.length == 0)\n            ligAtoms = mol.atomAdjList(metalAtom);\n        if (ligAtoms.length == 0) {\n            this.errmsg = 'Metal centre has no attachments: try selecting atom join-points.';\n            return;\n        }\n        mol = new _MetalLigate__WEBPACK_IMPORTED_MODULE_11__.MetalLigate(mol, metalAtom, ligAtoms).generate();\n        this.output.mol = mol;\n        this.output.currentAtom = metalAtom;\n        this.output.currentBond = -1;\n        this.output.selectedMask = _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.booleanArray(false, mol.numAtoms);\n        for (let a of ligAtoms)\n            this.output.selectedMask[a - 1] = true;\n    }\n    execBond(order, type) {\n        if (!this.requireSubject())\n            return;\n        if (this.subjectLength == 1) {\n            this.performBondNew(this.subjectIndex[0], order, type);\n            return;\n        }\n        let ccmol = _data_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.subgraphMask(this.input.mol, this.subjectMask);\n        let oneComp = true;\n        for (let n = ccmol.numAtoms; n >= 1; n--)\n            if (ccmol.atomConnComp(n) != 1) {\n                oneComp = false;\n                break;\n            }\n        if (oneComp)\n            this.performBondChange(order, type);\n        else\n            this.execConnect(order, type);\n    }\n    execBondGeom(geom) {\n        let bond = this.subjectLength == 2 ? this.input.mol.findBond(this.subjectIndex[0], this.subjectIndex[1]) : 0;\n        if (this.subjectLength == 0 || this.subjectLength > 2 || (this.subjectLength == 2 && bond == 0)) {\n            this.errmsg = 'The subject must be a single atom or bond.';\n            return;\n        }\n        if (this.subjectLength == 1)\n            this.performBondGeomAtom(geom, this.subjectIndex[0]);\n        else\n            this.performBondGeomBond(geom, bond);\n    }\n    execBondAtom(order, type, element, x1, y1, x2, y2) {\n        let mol = this.input.mol;\n        let a1 = _data_CoordUtil__WEBPACK_IMPORTED_MODULE_2__.CoordUtil.atomAtPoint(mol, x1, y1, 0.01), a2 = _data_CoordUtil__WEBPACK_IMPORTED_MODULE_2__.CoordUtil.atomAtPoint(mol, x2, y2, 0.01);\n        if (a1 > 0 && a1 == a2)\n            return;\n        if (a1 > 0 && a2 > 0 && mol.findBond(a1, a2) > 0)\n            return;\n        this.output.mol = mol.clone();\n        if (a1 == 0)\n            a1 = this.output.mol.addAtom('C', x1, y1);\n        if (a2 == 0)\n            a2 = this.output.mol.addAtom(element, x2, y2);\n        this.output.mol.addBond(a1, a2, order, type);\n    }\n    execBondSwitch() {\n        if (!this.requireSubject())\n            return;\n        let mol = this.input.mol;\n        let src = 0, dst = [];\n        if (this.subjectLength == 1) {\n            src = this.subjectIndex[0];\n            let adj = mol.atomAdjList(src);\n            for (let n = 0; n < adj.length; n++)\n                if (mol.atomAdjCount(adj[n]) == 1)\n                    dst.push(adj[n]);\n        }\n        else if (this.subjectLength == 2 && mol.findBond(this.subjectIndex[0], this.subjectIndex[1]) > 0) {\n            let ac1 = mol.atomAdjCount(this.subjectIndex[0]), ac2 = mol.atomAdjCount(this.subjectIndex[1]);\n            if (ac1 > 1 && ac2 == 1) {\n                src = this.subjectIndex[0];\n                dst.push(this.subjectIndex[1]);\n            }\n            else if (ac1 == 1 && ac2 > 1) {\n                src = this.subjectIndex[1];\n                dst.push(this.subjectIndex[0]);\n            }\n        }\n        if (src == 0 || dst.length == 0) {\n            this.errmsg = 'Subject must include a terminal bond.';\n            return;\n        }\n        let geoms = _data_SketchUtil__WEBPACK_IMPORTED_MODULE_8__.SketchUtil.guessAtomGeometry(mol, src, 1);\n        if (geoms.length == 0) {\n            this.errmsg = 'No alternative geometries identified.';\n            return;\n        }\n        this.output.mol = _data_SketchUtil__WEBPACK_IMPORTED_MODULE_8__.SketchUtil.switchAtomGeometry(mol, src, dst, geoms);\n        if (this.output.mol == null) {\n            this.errmsg = 'No alternative geometries identified.';\n        }\n    }\n    execBondRotate() {\n        let bond = this.input.currentBond;\n        if (bond == 0) {\n            this.errmsg = 'There must be a current bond.';\n            return;\n        }\n        let mol = this.input.mol;\n        if (mol.bondInRing(bond)) {\n            this.errmsg = 'Cannot rotate a ring-bond.';\n            return;\n        }\n        if (mol.atomAdjCount(mol.bondFrom(bond)) == 1 || mol.atomAdjCount(mol.bondTo(bond)) == 1) {\n            this.errmsg = 'Terminal bonds do not rotate.';\n            return;\n        }\n        mol = mol.clone();\n        let [atom1, atom2, side] = this.mobileSide(bond);\n        let cx = mol.atomX(atom1), cy = mol.atomY(atom1);\n        let theta = Math.atan2(mol.atomY(atom1) - mol.atomY(atom2), mol.atomX(atom1) - mol.atomX(atom2));\n        for (let a of side)\n            if (a != atom1) {\n                let dx = mol.atomX(a) - cx, dy = mol.atomY(a) - cy, dist = (0,_util_util__WEBPACK_IMPORTED_MODULE_9__.norm_xy)(dx, dy);\n                let dtheta = Math.atan2(dy, dx);\n                dtheta = theta - (0,_util_util__WEBPACK_IMPORTED_MODULE_9__.angleDiff)(dtheta, theta);\n                mol.setAtomPos(a, cx + dist * Math.cos(dtheta), cy + dist * Math.sin(dtheta));\n            }\n        let mask = _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.idxMask(_util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.add(side, -1), mol.numAtoms);\n        for (let b = 1; b <= mol.numBonds; b++)\n            if (mask[mol.bondFrom(b) - 1] && mask[mol.bondTo(b) - 1]) {\n                let bt = mol.bondType(b);\n                if (bt == _data_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_INCLINED)\n                    mol.setBondType(b, _data_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_DECLINED);\n                else if (bt == _data_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_DECLINED)\n                    mol.setBondType(b, _data_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_INCLINED);\n            }\n        if (_data_CoordUtil__WEBPACK_IMPORTED_MODULE_2__.CoordUtil.sketchEquivalent(this.input.mol, mol)) {\n            this.errmsg = 'Rotation has no effect.';\n            return;\n        }\n        this.output.mol = mol;\n    }\n    execBondAddTwo() {\n        if (this.subjectLength != 1) {\n            this.errmsg = 'Subject must be a single atom.';\n            return;\n        }\n        let atom = this.subjectIndex[0];\n        if (this.input.mol.atomAdjCount(atom) < 2) {\n            this.errmsg = 'Subject atom must already have at least 2 bonds.';\n            return;\n        }\n        let ang = _data_SketchUtil__WEBPACK_IMPORTED_MODULE_8__.SketchUtil.calculateNewBondAngles(this.input.mol, atom, 1);\n        if (ang.length == 0)\n            ang = _data_SketchUtil__WEBPACK_IMPORTED_MODULE_8__.SketchUtil.exitVectors(this.input.mol, atom);\n        if (ang.length == 0) {\n            this.errmsg = 'Could not find a suitable geometry for new substituents.';\n            return;\n        }\n        let baseAng = ang[0];\n        let cx = this.input.mol.atomX(atom), cy = this.input.mol.atomY(atom);\n        if (ang.length > 1) {\n            let best = 0;\n            for (let n = 0; n < ang.length; n++) {\n                let x = cx + _data_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.IDEALBOND * Math.cos(ang[n]);\n                let y = cy + _data_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.IDEALBOND * Math.sin(ang[n]);\n                let score = _data_CoordUtil__WEBPACK_IMPORTED_MODULE_2__.CoordUtil.congestionPoint(this.input.mol, x, y);\n                if (n == 0 || score < best) {\n                    best = score;\n                    baseAng = ang[n];\n                }\n            }\n        }\n        let ang1 = baseAng - 30.0 * _util_util__WEBPACK_IMPORTED_MODULE_9__.DEGRAD, ang2 = baseAng + 30.0 * _util_util__WEBPACK_IMPORTED_MODULE_9__.DEGRAD;\n        let mol = this.input.mol.clone();\n        let a1 = mol.addAtom('C', cx + _data_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.IDEALBOND * Math.cos(ang1), cy + _data_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.IDEALBOND * Math.sin(ang1));\n        let a2 = mol.addAtom('C', cx + _data_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.IDEALBOND * Math.cos(ang2), cy + _data_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.IDEALBOND * Math.sin(ang2));\n        mol.addBond(atom, a1, 1);\n        mol.addBond(atom, a2, 1);\n        this.output.mol = mol;\n    }\n    execBondInsert() {\n        let mol = this.input.mol, bond = this.input.currentBond;\n        if (bond == 0) {\n            this.errmsg = 'There must be a current bond.';\n            return;\n        }\n        if (mol.bondInRing(bond)) {\n            this.errmsg = 'Cannot insert into a ring-bond.';\n            return;\n        }\n        let [alink, _, side] = this.mobileSide(bond);\n        mol = mol.clone();\n        mol.setBondOrder(bond, 1);\n        let fragmask = _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.booleanArray(false, mol.numAtoms);\n        for (let a of side)\n            fragmask[a - 1] = true;\n        let frag = _data_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.subgraphWithAttachments(mol, fragmask);\n        for (let n = mol.numAtoms; n >= 1; n--)\n            if (fragmask[n - 1] && n != alink) {\n                mol.deleteAtomAndBonds(n);\n                if (n < alink)\n                    alink -= 1;\n            }\n        mol.setAtomElement(alink, 'C');\n        mol.setAtomCharge(alink, 0);\n        mol.setAtomUnpaired(alink, 0);\n        mol.setAtomHExplicit(alink, _data_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.HEXPLICIT_UNKNOWN);\n        mol.setAtomIsotope(alink, _data_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.ISOTOPE_NATURAL);\n        mol.setAtomMapNum(alink, 0);\n        mol.setAtomExtra(alink, []);\n        mol.setAtomTransient(alink, []);\n        let fusion = new _TemplateFusion__WEBPACK_IMPORTED_MODULE_12__.TemplateFusion(mol, frag, '');\n        fusion.withGuideOnly = true;\n        fusion.permuteAtom(alink);\n        if (fusion.perms.length == 0) {\n            this.errmsg = 'Unable to insert.';\n            return;\n        }\n        this.output.mol = fusion.perms[0].mol;\n        this.zapSubject();\n        this.output.currentAtom = alink;\n    }\n    execJoin() {\n        if (!this.requireSubject())\n            return;\n        this.output.mol = _data_SketchUtil__WEBPACK_IMPORTED_MODULE_8__.SketchUtil.joinOverlappingAtoms(this.input.mol, this.subjectMask);\n        if (this.output.mol == null) {\n            this.errmsg = 'Subject contains no overlapping atoms.';\n        }\n        else {\n            this.zapSubject();\n        }\n    }\n    execNudge(dir, extent) {\n        if (!this.requireSubject())\n            return;\n        let dx = extent * (dir == 'left' ? -1 : dir == 'right' ? 1 : 0);\n        let dy = extent * (dir == 'down' ? -1 : dir == 'up' ? 1 : 0);\n        this.output.mol = this.input.mol.clone();\n        for (let n = 0; n < this.subjectLength; n++) {\n            let x = this.output.mol.atomX(this.subjectIndex[n]), y = this.output.mol.atomY(this.subjectIndex[n]);\n            this.output.mol.setAtomPos(this.subjectIndex[n], x + dx, y + dy);\n        }\n    }\n    execNudgeFar(dir) {\n        if (!this.requireSubject())\n            return;\n        if (this.subjectLength == this.input.mol.numAtoms) {\n            this.errmsg = 'Cannot apply to entire molecule.';\n            return;\n        }\n        let dx = dir == 'left' ? -1 : dir == 'right' ? 1 : 0;\n        let dy = dir == 'down' ? -1 : dir == 'up' ? 1 : 0;\n        this.output.mol = _data_SketchUtil__WEBPACK_IMPORTED_MODULE_8__.SketchUtil.moveToEdge(this.input.mol, this.subjectMask, dx, dy);\n        if (this.output.mol == null) {\n            this.execNudge(dir, 1);\n        }\n    }\n    execFlip(axis) {\n        if (this.input.mol.numAtoms < 2) {\n            this.errmsg = 'At least 2 atoms are required.';\n            return;\n        }\n        let isVertical = axis == 'ver';\n        let cx = 0, cy = 0;\n        let mask = this.subjectMask, mol = this.input.mol;\n        if (this.input.currentAtom > 0) {\n            cx = mol.atomX(this.input.currentAtom);\n            cy = mol.atomY(this.input.currentAtom);\n            if (!this.hasSelected) {\n                mask = _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.booleanArray(false, mol.numAtoms);\n                let cc = mol.atomConnComp(this.input.currentAtom);\n                for (let n = 1; n <= mol.numAtoms; n++)\n                    mask[n - 1] = mol.atomConnComp(n) == cc;\n            }\n        }\n        else if (this.input.currentBond > 0) {\n            let bfr = mol.bondFrom(this.input.currentBond), bto = mol.bondTo(this.input.currentBond);\n            cx = 0.5 * (mol.atomX(bfr) + mol.atomX(bto));\n            cy = 0.5 * (mol.atomY(bfr) + mol.atomY(bto));\n            if (!this.hasSelected) {\n                mask = _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.booleanArray(false, mol.numAtoms);\n                let cc = mol.atomConnComp(bfr);\n                for (let n = 1; n <= mol.numAtoms; n++)\n                    mask[n - 1] = mol.atomConnComp(n) == cc;\n            }\n        }\n        else if (this.subjectLength == 0) {\n            let box = mol.boundary();\n            cx = 0.5 * (box.minX() + box.maxX());\n            cy = 0.5 * (box.minY() + box.maxY());\n            mask = _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.booleanArray(true, mol.numAtoms);\n        }\n        else {\n            for (let n = 0; n < this.subjectLength; n++) {\n                cx += mol.atomX(this.subjectIndex[n]);\n                cy += mol.atomY(this.subjectIndex[n]);\n            }\n            let invSz = 1.0 / this.subjectLength;\n            cx *= invSz;\n            cy *= invSz;\n        }\n        this.output.mol = mol.clone();\n        for (let n = 1; n <= mol.numAtoms; n++)\n            if (mask[n - 1]) {\n                if (!isVertical)\n                    this.output.mol.setAtomX(n, 2 * cx - this.output.mol.atomX(n));\n                else\n                    this.output.mol.setAtomY(n, 2 * cy - this.output.mol.atomY(n));\n            }\n    }\n    execScale(mag) {\n        const { mol, currentAtom, currentBond } = this.input;\n        if (mol.numAtoms < 2) {\n            this.errmsg = 'At least 2 atoms are required.';\n            return;\n        }\n        if (currentAtom > 0) {\n            let connAtoms = [];\n            for (let a of this.subjectIndex)\n                if (a != currentAtom && mol.findBond(currentAtom, a) > 0)\n                    connAtoms.push(a);\n            let g = _data_Graph__WEBPACK_IMPORTED_MODULE_3__.Graph.fromMolecule(mol);\n            g.isolateNode(currentAtom - 1);\n            let anything = false;\n            for (let cc of g.calculateComponentGroups()) {\n                _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.addTo(cc, 1);\n                let sz = 0, dx = 0, dy = 0;\n                for (let a of cc)\n                    if (connAtoms.includes(a)) {\n                        dx += mol.atomX(a) - mol.atomX(currentAtom);\n                        dy += mol.atomY(a) - mol.atomY(currentAtom);\n                        sz++;\n                    }\n                if (sz == 0)\n                    continue;\n                [dx, dy] = [dx / sz, dy / sz];\n                if (Math.abs(dx) < 0.1 && Math.abs(dy) < 0.1)\n                    continue;\n                [dx, dy] = [dx * (mag - 1), dy * (mag - 1)];\n                if (!this.output.mol)\n                    this.output.mol = mol.clone();\n                for (let a of cc)\n                    this.output.mol.setAtomPos(a, this.output.mol.atomX(a) + dx, this.output.mol.atomY(a) + dy);\n                anything = true;\n            }\n            if (anything)\n                return;\n        }\n        let b;\n        if (this.subjectLength == 2 && (b = mol.findBond(this.subjectIndex[0], this.subjectIndex[1])) > 0 && !mol.bondInRing(b)) {\n            let a1 = this.subjectIndex[0], a2 = this.subjectIndex[1];\n            let ccmol = mol.clone();\n            ccmol.deleteBond(b);\n            let idx1 = [], idx2 = [];\n            for (let n = 1; n <= ccmol.numAtoms; n++) {\n                if (ccmol.atomConnComp(n) == ccmol.atomConnComp(a1))\n                    idx1.push(n);\n                else if (ccmol.atomConnComp(n) == ccmol.atomConnComp(a2))\n                    idx2.push(n);\n            }\n            let dx = (mol.atomX(a2) - mol.atomX(a1)) * (mag - 1);\n            let dy = (mol.atomY(a2) - mol.atomY(a1)) * (mag - 1);\n            if (idx1.length == idx2.length) {\n                dx *= 0.5;\n                dy *= 0.5;\n            }\n            this.output.mol = mol.clone();\n            if (idx1.length <= idx2.length)\n                for (let n = 0; n < idx1.length; n++) {\n                    let a = idx1[n];\n                    this.output.mol.setAtomPos(a, this.output.mol.atomX(a) - dx, this.output.mol.atomY(a) - dy);\n                }\n            if (idx2.length <= idx1.length)\n                for (let n = 0; n < idx2.length; n++) {\n                    let a = idx2[n];\n                    this.output.mol.setAtomPos(a, this.output.mol.atomX(a) + dx, this.output.mol.atomY(a) + dy);\n                }\n            return;\n        }\n        let cx = 0, cy = 0;\n        if (currentAtom > 0) {\n            cx = mol.atomX(currentAtom);\n            cy = mol.atomY(currentAtom);\n        }\n        else if (currentBond > 0) {\n            let bfr = mol.bondFrom(currentBond), bto = mol.bondTo(currentBond);\n            cx = 0.5 * (mol.atomX(bfr) + mol.atomX(bto));\n            cy = 0.5 * (mol.atomY(bfr) + mol.atomY(bto));\n        }\n        else {\n            for (let n = 0; n < this.subjectLength; n++) {\n                cx += mol.atomX(this.subjectIndex[n]);\n                cy += mol.atomY(this.subjectIndex[n]);\n            }\n            let invSz = 1.0 / this.subjectLength;\n            cx *= invSz;\n            cy *= invSz;\n        }\n        this.output.mol = mol.clone();\n        for (let n = 0; n < this.subjectLength; n++) {\n            let x = this.output.mol.atomX(this.subjectIndex[n]);\n            let y = this.output.mol.atomY(this.subjectIndex[n]);\n            this.output.mol.setAtomPos(this.subjectIndex[n], (x - cx) * mag + cx, (y - cy) * mag + cy);\n        }\n    }\n    execRotate(theta, centreX, centreY) {\n        theta *= _util_util__WEBPACK_IMPORTED_MODULE_9__.DEGRAD;\n        let mol = this.input.mol;\n        if (centreX != null && centreY != null) {\n            this.output.mol = mol.clone();\n            let mask = this.subjectLength == 0 ? _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.booleanArray(true, mol.numAtoms) : this.subjectMask;\n            _data_CoordUtil__WEBPACK_IMPORTED_MODULE_2__.CoordUtil.rotateAtoms(this.output.mol, mask, centreX, centreY, theta);\n            return;\n        }\n        if (mol.numAtoms < 2) {\n            this.errmsg = 'At least 2 atoms are required.';\n            return;\n        }\n        let cx = 0, cy = 0;\n        let mask = this.subjectMask;\n        if (this.input.currentAtom > 0) {\n            cx = mol.atomX(this.input.currentAtom);\n            cy = mol.atomY(this.input.currentAtom);\n            if (!this.hasSelected) {\n                mask = _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.booleanArray(false, mol.numAtoms);\n                let cc = mol.atomConnComp(this.input.currentAtom);\n                for (let n = 1; n <= mol.numAtoms; n++)\n                    mask[n - 1] = mol.atomConnComp(n) == cc;\n            }\n            if (_util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.maskCount(mask) == 1 && mask[this.input.currentAtom - 1]) {\n                this.errmsg = 'Component is isolated.';\n                return;\n            }\n        }\n        else if (this.input.currentBond > 0) {\n            let bfr = mol.bondFrom(this.input.currentBond), bto = mol.bondTo(this.input.currentBond);\n            cx = 0.5 * (mol.atomX(bfr) + mol.atomX(bto));\n            cy = 0.5 * (mol.atomY(bfr) + mol.atomY(bto));\n            if (!this.hasSelected) {\n                mask = _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.booleanArray(false, mol.numAtoms);\n                let cc = mol.atomConnComp(bfr);\n                for (let n = 1; n <= mol.numAtoms; n++)\n                    mask[n - 1] = mol.atomConnComp(n) == cc;\n            }\n        }\n        else if (this.subjectLength == 0) {\n            let box = mol.boundary();\n            cx = 0.5 * (box.minX() + box.maxX());\n            cy = 0.5 * (box.minY() + box.maxY());\n            mask = _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.booleanArray(true, mol.numAtoms);\n        }\n        else {\n            if (this.subjectLength == 1) {\n                this.errmsg = 'Component is isolated.';\n                return;\n            }\n            for (let n = 0; n < this.subjectLength; n++) {\n                cx += mol.atomX(this.subjectIndex[n]);\n                cy += mol.atomY(this.subjectIndex[n]);\n            }\n            let invSz = 1.0 / this.subjectLength;\n            cx *= invSz;\n            cy *= invSz;\n        }\n        this.output.mol = mol.clone();\n        _data_CoordUtil__WEBPACK_IMPORTED_MODULE_2__.CoordUtil.rotateAtoms(this.output.mol, mask, cx, cy, theta);\n    }\n    execBondDist(dist) {\n        let bond = this.input.currentBond;\n        if (bond == 0) {\n            this.errmsg = 'There must be a current bond.';\n            return;\n        }\n        let mol = this.input.mol.clone();\n        if (mol.bondInRing(bond)) {\n            let atom1 = mol.bondFrom(bond), atom2 = mol.bondTo(bond);\n            let dx = mol.atomX(atom2) - mol.atomX(atom1), dy = mol.atomY(atom2) - mol.atomY(atom1), curDist = (0,_util_util__WEBPACK_IMPORTED_MODULE_9__.norm_xy)(dx, dy), inv = 1.0 / curDist;\n            let sel1 = this.isSelected(atom1), sel2 = this.isSelected(atom2);\n            let ox = dx * (dist - curDist) * inv, oy = dy * (dist - curDist) * inv;\n            if (sel1 && !sel2) {\n                mol.setAtomPos(atom1, mol.atomX(atom1) - ox, mol.atomY(atom1) - oy);\n            }\n            else if (sel2 && !sel1) {\n                mol.setAtomPos(atom2, mol.atomX(atom2) + ox, mol.atomY(atom2) + oy);\n            }\n            else {\n                mol.setAtomPos(atom1, mol.atomX(atom1) - 0.5 * ox, mol.atomY(atom1) - 0.5 * oy);\n                mol.setAtomPos(atom2, mol.atomX(atom2) + 0.5 * ox, mol.atomY(atom2) + 0.5 * oy);\n            }\n        }\n        else {\n            let [atom1, atom2, side] = this.mobileSide(bond);\n            let dx = mol.atomX(atom2) - mol.atomX(atom1), dy = mol.atomY(atom2) - mol.atomY(atom1);\n            let curDist = (0,_util_util__WEBPACK_IMPORTED_MODULE_9__.norm_xy)(dx, dy), inv = 1.0 / curDist;\n            let ox = dx * (dist - curDist) * inv, oy = dy * (dist - curDist) * inv;\n            for (let a of side)\n                mol.setAtomPos(a, mol.atomX(a) - ox, mol.atomY(a) - oy);\n        }\n        this.output.mol = mol;\n    }\n    execAlignAngle(angle) {\n        let bond = this.input.currentBond;\n        if (bond == 0) {\n            this.errmsg = 'There must be a current bond.';\n            return;\n        }\n        let mol = this.input.mol.clone();\n        if (mol.bondInRing(bond)) {\n            this.errmsg = 'Cannot align a ring-bond.';\n            return;\n        }\n        let [atom1, atom2, side] = this.mobileSide(bond);\n        let cx = mol.atomX(atom2), cy = mol.atomY(atom2);\n        let delta = angle - Math.atan2(mol.atomY(atom1) - cy, mol.atomX(atom1) - cx);\n        let cosTheta = Math.cos(delta), sinTheta = Math.sin(delta);\n        for (let a of side) {\n            let x = mol.atomX(a) - cx, y = mol.atomY(a) - cy;\n            mol.setAtomPos(a, cx + x * cosTheta - y * sinTheta, cy + x * sinTheta + y * cosTheta);\n        }\n        this.output.mol = mol;\n    }\n    execAlignRegular() {\n        let bond = this.input.currentBond;\n        if (bond == 0) {\n            this.errmsg = 'There must be a current bond.';\n            return;\n        }\n        let mol = this.input.mol.clone();\n        let bfr = mol.bondFrom(this.input.currentBond), bto = mol.bondTo(this.input.currentBond);\n        let theta = Math.atan2(mol.atomY(bto) - mol.atomY(bfr), mol.atomX(bto) - mol.atomX(bfr)) * _util_util__WEBPACK_IMPORTED_MODULE_9__.RADDEG;\n        if (theta < 0)\n            theta += 360;\n        let snap = Math.round(theta / 30) * 30;\n        if (Math.abs(theta - snap) < 0.001)\n            return;\n        let delta = (snap - theta) * _util_util__WEBPACK_IMPORTED_MODULE_9__.DEGRAD;\n        let mask = this.input.selectedMask;\n        if (_util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.allFalse(mask)) {\n            let cc = mol.atomConnComp(bfr);\n            for (let n = 1; n <= mol.numAtoms; n++)\n                mask[n - 1] = cc == mol.atomConnComp(n);\n        }\n        let cx = 0.5 * (mol.atomX(bfr) + mol.atomX(bto)), cy = 0.5 * (mol.atomY(bfr) + mol.atomY(bto));\n        for (let n = 1; n <= mol.numAtoms; n++)\n            if (mask[n - 1]) {\n                let dx = mol.atomX(n) - cx, dy = mol.atomY(n) - cy;\n                let th = Math.atan2(dy, dx) + delta, dist = (0,_util_util__WEBPACK_IMPORTED_MODULE_9__.norm_xy)(dx, dy);\n                mol.setAtomPos(n, cx + dist * Math.cos(th), cy + dist * Math.sin(th));\n            }\n        this.output.mol = mol;\n    }\n    execAdjustTorsion(angle) {\n        if (this.input.currentAtom == 0 || _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.maskCount(this.input.selectedMask) != 3) {\n            this.errmsg = 'Must be 3 selected atoms and a current atom.';\n            return;\n        }\n        let mol = this.input.mol.clone();\n        let a1 = this.input.currentAtom;\n        let atoms = [];\n        for (let n = 1; n <= mol.numAtoms; n++)\n            if (n != a1 && this.input.selectedMask[n - 1])\n                atoms.push(n);\n        let a2 = mol.findBond(a1, atoms[0]) > 0 ? atoms.shift() :\n            mol.findBond(a1, atoms[1]) > 0 ? atoms.pop() : 0;\n        if (a2 == 0 || mol.findBond(a2, atoms[0]) == 0) {\n            this.errmsg = 'Selected atoms must be consecutive.';\n            return;\n        }\n        let a3 = atoms[0];\n        let cx = mol.atomX(a2), cy = mol.atomY(a2);\n        let theta1 = Math.atan2(mol.atomY(a1) - cy, mol.atomX(a1) - cx);\n        let theta3 = Math.atan2(mol.atomY(a3) - cy, mol.atomX(a3) - cx);\n        let delta = angle - (0,_util_util__WEBPACK_IMPORTED_MODULE_9__.angleDiff)(theta3, theta1);\n        let group1 = [], group3 = [];\n        if (mol.atomRingBlock(a1) == 0 || mol.atomRingBlock(a1) != mol.atomRingBlock(a3)) {\n            let g = _data_Graph__WEBPACK_IMPORTED_MODULE_3__.Graph.fromMolecule(mol);\n            g.removeEdge(a2 - 1, a1 - 1);\n            g.removeEdge(a2 - 1, a3 - 1);\n            let cc = g.calculateComponents();\n            for (let n = 0; n < g.numNodes; n++) {\n                if (cc[n] == cc[a1 - 1])\n                    group1.push(n + 1);\n                else if (cc[n] == cc[a3 - 1])\n                    group3.push(n + 1);\n            }\n        }\n        if (mol.atomRingBlock(a1) > 0 && mol.atomRingBlock(a1) == mol.atomRingBlock(a2))\n            group1 = [a1];\n        if (mol.atomRingBlock(a3) > 0 && mol.atomRingBlock(a3) == mol.atomRingBlock(a2))\n            group3 = [a3];\n        _data_CoordUtil__WEBPACK_IMPORTED_MODULE_2__.CoordUtil.rotateAtoms(mol, _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.idxMask(_util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.add(group1, -1), mol.numAtoms), cx, cy, -0.5 * delta);\n        _data_CoordUtil__WEBPACK_IMPORTED_MODULE_2__.CoordUtil.rotateAtoms(mol, _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.idxMask(_util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.add(group3, -1), mol.numAtoms), cx, cy, 0.5 * delta);\n        this.output.mol = mol;\n    }\n    execMove(refAtom, deltaX, deltaY) {\n        let subj = this.subjectIndex;\n        if (_util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.len(subj) == 0) {\n            if (refAtom == 0)\n                return;\n            subj = [refAtom];\n        }\n        this.output.mol = this.input.mol.clone();\n        for (let a of subj)\n            this.output.mol.setAtomPos(a, this.output.mol.atomX(a) + deltaX, this.output.mol.atomY(a) + deltaY);\n    }\n    execRing(ringX, ringY, aromatic) {\n        let rsz = ringX.length;\n        let atoms = _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.numberArray(0, rsz), bonds = _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.numberArray(0, rsz);\n        let outmol = this.input.mol.clone();\n        for (let n = 0; n < rsz; n++) {\n            atoms[n] = _data_CoordUtil__WEBPACK_IMPORTED_MODULE_2__.CoordUtil.atomAtPoint(outmol, ringX[n], ringY[n]);\n            if (atoms[n] == 0)\n                atoms[n] = outmol.addAtom('C', ringX[n], ringY[n]);\n        }\n        for (let n = 0; n < rsz; n++) {\n            let nn = n < rsz - 1 ? n + 1 : 0;\n            bonds[n] = outmol.findBond(atoms[n], atoms[nn]);\n            if (bonds[n] == 0)\n                bonds[n] = outmol.addBond(atoms[n], atoms[nn], 1);\n        }\n        if (aromatic) {\n            let valence = _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.numberArray(0, rsz);\n            let pi = _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.booleanArray(false, rsz);\n            for (let n = 0; n < rsz; n++) {\n                valence[n] = _data_Chemistry__WEBPACK_IMPORTED_MODULE_1__.Chemistry.ELEMENT_BONDING[outmol.atomicNumber(atoms[n])] + outmol.atomCharge(atoms[n]);\n                if (outmol.atomHExplicit(atoms[n]) != _data_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.HEXPLICIT_UNKNOWN)\n                    valence[n] -= outmol.atomHExplicit(atoms[n]);\n                for (let b of outmol.atomAdjBonds(atoms[n]))\n                    valence[n] -= outmol.bondOrder(b);\n                if (outmol.bondOrder(bonds[n]) >= 2) {\n                    pi[n] = true;\n                    if (n < rsz - 1) {\n                        pi[n] = true;\n                        n++;\n                    }\n                    else\n                        pi[0] = true;\n                }\n            }\n            for (let n = 0; n < rsz; n++) {\n                let nn = n < rsz - 1 ? n + 1 : 0;\n                if (pi[n] || pi[nn])\n                    continue;\n                if (valence[n] > 0 && valence[nn] > 0) {\n                    outmol.setBondOrder(bonds[n], 2);\n                    pi[n] = true;\n                    pi[nn] = true;\n                    valence[n]--;\n                    valence[nn]--;\n                }\n            }\n        }\n        this.output.mol = outmol;\n    }\n    execTemplateFusion(frag) {\n        let mol = this.input.mol;\n        let fusion = new _TemplateFusion__WEBPACK_IMPORTED_MODULE_12__.TemplateFusion(mol, frag, '');\n        if (this.subjectLength == 0)\n            fusion.permuteNone();\n        else if (this.subjectLength == 1)\n            fusion.permuteAtom(this.subjectIndex[0]);\n        else if (this.subjectLength == 2 && mol.findBond(this.subjectIndex[0], this.subjectIndex[1]) > 0)\n            fusion.permuteBond(this.subjectIndex[0], this.subjectIndex[1]);\n        else\n            fusion.permuteMulti(this.subjectIndex);\n        let permutations = [];\n        for (let perm of fusion.perms) {\n            let obj = {};\n            obj['mol'] = perm.mol.toString();\n            obj['display'] = perm.display.toString();\n            obj['molidx'] = perm.molidx;\n            obj['temidx'] = perm.temidx;\n            obj['srcidx'] = perm.srcidx;\n            permutations.push(obj);\n        }\n        this.output.permutations = permutations;\n    }\n    execAbbrevTempl() {\n    }\n    execAbbrevGroup() {\n        if (!this.requireSubject())\n            return;\n        if (!this.checkAbbreviationReady())\n            return;\n        let mol = _data_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.convertToAbbrev(this.input.mol, _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.notMask(this.subjectMask), '?');\n        if (mol == null) {\n            this.errmsg = 'Inline abbreviations must be terminal with exactly one attachment point.';\n            return;\n        }\n        this.output.mol = mol;\n        this.zapSubject();\n        this.output.currentAtom = mol.numAtoms;\n    }\n    execAbbrevFormula() {\n        if (!this.requireSubject())\n            return;\n        if (!this.checkAbbreviationReady())\n            return;\n        let fixed = this.input.mol.clone();\n        for (let n = 1; n <= fixed.numAtoms; n++)\n            fixed.setAtomHExplicit(n, fixed.atomHydrogens(n));\n        let abv = _data_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.subgraphMask(fixed, this.subjectMask);\n        let formula = _data_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.molecularFormula(abv, true);\n        let mol = _data_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.convertToAbbrev(this.input.mol, _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.notMask(this.subjectMask), formula);\n        if (mol == null) {\n            this.errmsg = 'Inline abbreviations must be terminal with exactly one attachment point.';\n            return;\n        }\n        this.output.mol = mol;\n        this.zapSubject();\n        this.output.currentAtom = mol.numAtoms;\n    }\n    execAbbrevClear() {\n        let idx = [];\n        for (let n of this.subjectIndex)\n            if (_data_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.hasAbbrev(this.input.mol, n))\n                idx.push(n);\n        if (idx.length == 0) {\n            this.errmsg = 'No abbreviations to clear.';\n            return;\n        }\n        let mol = this.input.mol.clone();\n        for (let n of idx)\n            _data_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.clearAbbrev(mol, n);\n        this.output.mol = mol;\n    }\n    execAbbrevExpand() {\n        let idx = [];\n        for (let n of this.subjectIndex)\n            if (_data_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.hasAbbrev(this.input.mol, n))\n                idx.push(n);\n        if (idx.length == 0) {\n            this.errmsg = 'No abbreviations to expand.';\n            return;\n        }\n        let mol = this.input.mol.clone();\n        for (let n of idx)\n            _data_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.expandOneAbbrev(mol, n, true);\n        this.output.mol = mol;\n        this.zapSubject();\n    }\n    execBondArtifact(activity) {\n        if (!this.requireAtoms() || !this.requireSubject())\n            return;\n        let artif = new _data_BondArtifact__WEBPACK_IMPORTED_MODULE_0__.BondArtifact(this.input.mol.clone());\n        let subject = this.subjectIndex.slice(0), curAtom = this.input.currentAtom;\n        if (curAtom > 0 && subject.indexOf(curAtom) < 0)\n            subject.push(curAtom);\n        if (activity == ActivityType.BondArtifactPath) {\n            if (!artif.createPath(subject)) {\n                this.errmsg = 'Path artifact not suitable.';\n                return;\n            }\n        }\n        else if (activity == ActivityType.BondArtifactRing) {\n            if (!artif.createRing(subject)) {\n                this.errmsg = 'Ring artifact not suitable.';\n                return;\n            }\n        }\n        else if (activity == ActivityType.BondArtifactArene) {\n            if (!artif.createArene(subject)) {\n                this.errmsg = 'Arene artifact not suitable.';\n                return;\n            }\n        }\n        else if (activity == ActivityType.BondArtifactClear) {\n            if (!artif.removeArtifact(subject)) {\n                if (this.removePolymerBlock(subject))\n                    return;\n                this.errmsg = 'No artifact removed.';\n                return;\n            }\n        }\n        artif.rewriteMolecule();\n        this.output.mol = artif.mol;\n    }\n    execPolymerBlock() {\n        if (!this.requireAtoms() || !this.requireSubject())\n            return;\n        if (this.owner)\n            this.owner.performPolymerBlock(this.subjectIndex);\n    }\n    execAddHydrogens() {\n        let mol = this.input.mol.clone();\n        if (!this.requireAtoms())\n            return;\n        let atoms = this.subjectIndex;\n        if (atoms.length == 0)\n            atoms = _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.identity1(mol.numAtoms);\n        for (let a of atoms) {\n            let hc = mol.atomHydrogens(a);\n            if (hc > 0)\n                _data_SketchUtil__WEBPACK_IMPORTED_MODULE_8__.SketchUtil.placeAdditionalHydrogens(mol, a, hc);\n        }\n        if (mol.numAtoms == this.input.mol.numAtoms) {\n            this.errmsg = 'Nothing needs to be added.';\n            return;\n        }\n        this.output.mol = mol;\n    }\n    execRemoveHydrogens() {\n        if (!this.requireAtoms())\n            return;\n        let mol = this.input.mol;\n        let selmask = this.subjectMask;\n        if (_util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.allFalse(selmask))\n            selmask = _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.booleanArray(true, mol.numAtoms);\n        let keepmask = _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.booleanArray(true, mol.numAtoms);\n        for (let n = 1; n <= mol.numAtoms; n++)\n            if (_data_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.boringHydrogen(mol, n)) {\n                let nbr = mol.atomAdjList(n)[0];\n                if (selmask[n - 1] || selmask[nbr - 1])\n                    keepmask[n - 1] = false;\n            }\n        if (_util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.allTrue(keepmask)) {\n            this.errmsg = 'Nothing to be deleted.';\n            return;\n        }\n        this.output.mol = _data_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.subgraphMask(mol, keepmask);\n    }\n    execQueryClear() {\n        if (!this.requireSubject())\n            return;\n        let mol = this.input.mol.clone();\n        const { currentBond } = this.input;\n        if (currentBond > 0 && _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryUtil.hasAnyQueryBond(mol, currentBond)) {\n            _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryUtil.deleteQueryBondAll(mol, currentBond);\n            this.output.mol = mol;\n            return;\n        }\n        let anything = false;\n        for (let a of this.subjectIndex)\n            if (_data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryUtil.hasAnyQueryAtom(mol, a)) {\n                _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryUtil.deleteQueryAtomAll(mol, a);\n                anything = true;\n            }\n        for (let b = 1; b <= mol.numBonds; b++)\n            if (this.subjectMask[mol.bondFrom(b) - 1] && this.subjectMask[mol.bondTo(b) - 1] && _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryUtil.hasAnyQueryBond(mol, b)) {\n                _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryUtil.deleteQueryBondAll(mol, b);\n                anything = true;\n            }\n        if (anything)\n            this.output.mol = mol;\n        else\n            this.errmsg = 'No query terms to clear.';\n    }\n    execQueryCopy() {\n        if (!this.requireSubject())\n            return;\n        const { mol, currentBond } = this.input;\n        if (currentBond > 0) {\n            if (!_data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryUtil.hasAnyQueryBond(mol, currentBond)) {\n                this.errmsg = 'Bond has no query terms.';\n                return;\n            }\n            let qmol = new _data_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule();\n            qmol.addAtom('*', 0, 0);\n            qmol.addAtom('*', _data_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.IDEALBOND, 0);\n            qmol.addBond(1, 2, 1);\n            qmol.setBondExtra(1, mol.bondExtra(currentBond).filter((xtra) => xtra.startsWith('q')));\n            this.toClipboard = qmol.toString();\n        }\n        else if (this.subjectLength == 1) {\n            let atom = this.subjectIndex[0];\n            if (!_data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryUtil.hasAnyQueryAtom(mol, atom)) {\n                this.errmsg = 'Atom has no query terms.';\n                return;\n            }\n            let qmol = new _data_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule();\n            qmol.addAtom('*', 0, 0);\n            qmol.setAtomExtra(1, mol.atomExtra(atom).filter((xtra) => xtra.startsWith('q')));\n            this.toClipboard = qmol.toString();\n        }\n        else\n            this.errmsg = 'Subject has to be a single atom or bond.';\n    }\n    execQueryPaste() {\n        if (!this.requireSubject())\n            return;\n        let qmol = this.param.qmol;\n        if (!qmol) { }\n        else if (qmol.numAtoms == 1 && qmol.atomElement(1) == '*' && _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryUtil.hasAnyQueryAtom(qmol, 1)) {\n            let mol = this.output.mol = this.input.mol.clone();\n            let qterms = qmol.atomExtra(1).filter((xtra) => xtra.startsWith('q'));\n            for (let a of this.subjectIndex) {\n                let aterms = mol.atomExtra(a).filter((xtra) => xtra.startsWith('q'));\n                mol.setAtomExtra(a, [...aterms, ...qterms]);\n            }\n            return;\n        }\n        else if (qmol.numAtoms == 2 && qmol.atomElement(1) == '*' && qmol.atomElement(2) == '*' &&\n            qmol.numBonds == 1 && _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryUtil.hasAnyQueryBond(qmol, 1)) {\n            let mol = this.output.mol = this.input.mol.clone();\n            let qterms = qmol.bondExtra(1).filter((xtra) => xtra.startsWith('q'));\n            for (let b = 1; b <= mol.numBonds; b++)\n                if (this.subjectMask[mol.bondFrom(b) - 1] && this.subjectMask[mol.bondTo(b) - 1]) {\n                    let bterms = mol.bondExtra(b).filter((xtra) => xtra.startsWith('q'));\n                    mol.setBondExtra(b, [...bterms, ...qterms]);\n                }\n            return;\n        }\n        this.errmsg = 'Unable to paste query terms.';\n    }\n    execQuerySetAtom() {\n    }\n    execQuerySetBond() {\n    }\n    execQueryBondAny() {\n        if (!this.requireSubject())\n            return;\n        const { mol, currentBond } = this.input;\n        let bonds = [];\n        for (let n = 1; n <= mol.numBonds; n++)\n            if (this.subjectMask[mol.bondFrom(n) - 1] && this.subjectMask[mol.bondTo(n) - 1])\n                bonds.push(n);\n        if (bonds.length == 0) {\n            this.errmsg = 'Must select at least one bond.';\n            return;\n        }\n        this.output.mol = this.input.mol.clone();\n        for (let b of bonds) {\n            this.output.mol.setBondOrder(b, 0);\n            _data_QueryUtil__WEBPACK_IMPORTED_MODULE_7__.QueryUtil.setQueryBondOrders(this.output.mol, b, [-1, 0, 1, 2, 3, 4]);\n        }\n    }\n    requireSubject() {\n        if (this.subjectLength == 0)\n            this.errmsg = 'Subject required: current atom/bond or selected atoms.';\n        return this.subjectLength > 0;\n    }\n    requireAtoms() {\n        if (this.input.mol.numAtoms == 0)\n            this.errmsg = 'There are no atoms.';\n        return this.input.mol.numAtoms > 0;\n    }\n    requireCurrent() {\n        if (this.input.currentAtom == 0 && this.input.currentBond == 0) {\n            this.errmsg = 'There must be a current atom or bond.';\n            return false;\n        }\n        return true;\n    }\n    requireSelected() {\n        if (!this.hasSelected)\n            this.errmsg = 'No atoms are selected.';\n        return this.hasSelected;\n    }\n    pickSelectedGroup(groups, dir) {\n        if (this.subjectLength == 0)\n            return 0;\n        for (let i = 0; i < groups.length; i++) {\n            let g = groups[i];\n            let all = true;\n            for (let j = 0; j < g.length; j++)\n                if (!this.subjectMask[g[j] - 1]) {\n                    all = false;\n                    break;\n                }\n            if (all) {\n                i += dir;\n                return i < 0 ? i + groups.length : i >= groups.length ? i - groups.length : i;\n            }\n        }\n        for (let i = 0; i < groups.length; i++) {\n            let g = groups[i];\n            for (let j = 0; j < g.length; j++)\n                if (this.subjectMask[g[j] - 1])\n                    return i;\n        }\n        return 0;\n    }\n    zapSubject() {\n        this.output.currentAtom = 0;\n        this.output.currentBond = 0;\n        this.output.selectedMask = _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.booleanArray(false, this.input.mol.numAtoms);\n    }\n    performBondNew(atom, order, type) {\n        let mol = this.input.mol;\n        let ang = _data_SketchUtil__WEBPACK_IMPORTED_MODULE_8__.SketchUtil.calculateNewBondAngles(mol, atom, order);\n        if (ang.length == 0)\n            ang = _data_SketchUtil__WEBPACK_IMPORTED_MODULE_8__.SketchUtil.exitVectors(mol, atom);\n        if (ang.length == 0) {\n            this.errmsg = 'Could not find a suitable geometry for a new substituent.';\n            return;\n        }\n        let bx = 0, by = 0, best = 0;\n        for (let n = 0; n < ang.length; n++) {\n            let x = mol.atomX(atom) + _data_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.IDEALBOND * Math.cos(ang[n]);\n            let y = mol.atomY(atom) + _data_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.IDEALBOND * Math.sin(ang[n]);\n            let score = _data_CoordUtil__WEBPACK_IMPORTED_MODULE_2__.CoordUtil.congestionPoint(mol, x, y);\n            if (_data_Chemistry__WEBPACK_IMPORTED_MODULE_1__.Chemistry.ELEMENT_BLOCKS[mol.atomicNumber(atom)] <= 2)\n                score += Math.abs((0,_util_util__WEBPACK_IMPORTED_MODULE_9__.angleNorm)(ang[n])) * 1E-8;\n            else\n                score += Math.abs((0,_util_util__WEBPACK_IMPORTED_MODULE_9__.angleDiff)(0.5 * Math.PI, ang[n])) * 1E-8;\n            if (n == 0 || score < best) {\n                best = score;\n                bx = x;\n                by = y;\n            }\n        }\n        this.output.mol = mol.clone();\n        let anum = _data_CoordUtil__WEBPACK_IMPORTED_MODULE_2__.CoordUtil.atomAtPoint(this.output.mol, bx, by);\n        if (anum == 0)\n            anum = this.output.mol.addAtom('C', bx, by);\n        _data_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.addBond(this.output.mol, atom, anum, order, type);\n    }\n    performBondChange(order, type) {\n        let mol = this.input.mol;\n        let bonds = [];\n        for (let n = 1; n <= mol.numBonds; n++)\n            if (this.subjectMask[mol.bondFrom(n) - 1] && this.subjectMask[mol.bondTo(n) - 1])\n                bonds.push(n);\n        let switchType = type == _data_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_DECLINED || type == _data_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_INCLINED;\n        let stereoType = switchType || type == _data_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_UNKNOWN;\n        let anyChange = switchType;\n        for (let n = 0; n < bonds.length && !anyChange; n++) {\n            let b = bonds[n];\n            if (mol.bondOrder(b) != order && type == _data_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_NORMAL)\n                anyChange = true;\n            else if (mol.bondType(b) != type)\n                anyChange = true;\n        }\n        if (!anyChange) {\n            this.errmsg = 'No bond changes made.';\n            return;\n        }\n        this.output.mol = mol.clone();\n        for (let n = 0; n < bonds.length; n++) {\n            let b = bonds[n], bfr = this.output.mol.bondFrom(b), bto = this.output.mol.bondTo(b);\n            if (switchType && this.output.mol.bondType(b) == type) {\n                this.output.mol.setBondFromTo(b, bto, bfr);\n            }\n            else if (this.output.mol.bondOrder(b) != order || this.output.mol.bondType(b) != type) {\n                if (!stereoType && order != this.output.mol.bondOrder(b))\n                    this.output.mol.setBondOrder(b, order);\n                else\n                    this.output.mol.setBondType(b, type);\n            }\n            else if (switchType) {\n                this.output.mol.setBondFromTo(b, bto, bfr);\n            }\n        }\n    }\n    performBondGeomAtom(geom, atom) {\n        let mol = this.input.mol;\n        let adj = mol.atomAdjList(atom);\n        let asz = adj.length, gsz = _data_SketchUtil__WEBPACK_IMPORTED_MODULE_8__.SketchUtil.GEOM_ANGLES[geom].length;\n        if (asz > gsz) {\n            this.errmsg = 'The current atom has more bonds than does the selected geometry.';\n            return;\n        }\n        if (asz == 0) {\n            this.performBondNew(atom, 1, _data_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.BONDTYPE_NORMAL);\n            return;\n        }\n        if (asz == gsz) {\n            this.output.mol = _data_SketchUtil__WEBPACK_IMPORTED_MODULE_8__.SketchUtil.refitAtomGeometry(mol, atom, geom);\n            if (this.output.mol == null)\n                this.errmsg = 'Could not re-fit the atom geometry.';\n            return;\n        }\n        let ang = _data_CoordUtil__WEBPACK_IMPORTED_MODULE_2__.CoordUtil.atomBondAngles(mol, atom);\n        let newang = _data_SketchUtil__WEBPACK_IMPORTED_MODULE_8__.SketchUtil.mapAngleSubstituent(geom, ang);\n        if (newang == null) {\n            this.output.mol = _data_SketchUtil__WEBPACK_IMPORTED_MODULE_8__.SketchUtil.refitAtomGeometry(mol, atom, geom);\n            if (this.output.mol == null)\n                this.errmsg = 'Could not re-fit the atom geometry.';\n            return;\n        }\n        this.output.mol = mol.clone();\n        let theta = _data_SketchUtil__WEBPACK_IMPORTED_MODULE_8__.SketchUtil.pickNewAtomDirection(mol, atom, newang);\n        let x = this.output.mol.atomX(atom) + _data_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.IDEALBOND * Math.cos(theta);\n        let y = this.output.mol.atomY(atom) + _data_Molecule__WEBPACK_IMPORTED_MODULE_4__.Molecule.IDEALBOND * Math.sin(theta);\n        let anum = _data_CoordUtil__WEBPACK_IMPORTED_MODULE_2__.CoordUtil.atomAtPoint(this.output.mol, x, y);\n        if (anum == 0)\n            anum = this.output.mol.addAtom('C', x, y);\n        _data_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.addBond(this.output.mol, atom, anum, 1);\n    }\n    performBondGeomBond(geom, bond) {\n        let mol = this.input.mol;\n        let bfr = mol.bondFrom(bond), bto = mol.bondTo(bond);\n        let ac1 = mol.atomAdjCount(bfr), ac2 = mol.atomAdjCount(bto);\n        if (ac1 > 1 && ac2 == 1) { }\n        else if (ac1 == 1 && ac2 > 1) {\n            let t = ac1;\n            ac1 = ac2;\n            ac2 = t;\n        }\n        else {\n            this.errmsg = 'One end of the bond must be terminal.';\n            return;\n        }\n        let adj = mol.atomAdjList(bfr);\n        let x1 = mol.atomX(bfr), y1 = mol.atomY(bfr);\n        let x2 = mol.atomX(bto), y2 = mol.atomY(bto);\n        let ang = [];\n        for (let n = 0, p = 0; n < adj.length; n++)\n            if (adj[n] != bto) {\n                ang.push(Math.atan2(mol.atomY(adj[n]) - y1, mol.atomX(adj[n]) - x1));\n            }\n        let newang = _data_SketchUtil__WEBPACK_IMPORTED_MODULE_8__.SketchUtil.mapAngleSubstituent(geom, ang);\n        if (newang == null) {\n            this.errmsg = 'No alternative geometries identified.';\n            return;\n        }\n        let bestAng = _util_util__WEBPACK_IMPORTED_MODULE_9__.TWOPI + 1, bestX = 0, bestY = 0;\n        let curth = Math.atan2(y2 - y1, x2 - x1), r = (0,_util_util__WEBPACK_IMPORTED_MODULE_9__.norm_xy)(x2 - x1, y2 - y1);\n        for (let n = 0; n < newang.length; n++) {\n            let th = (0,_util_util__WEBPACK_IMPORTED_MODULE_9__.angleDiff)(newang[n], curth);\n            if (th < 0)\n                th += _util_util__WEBPACK_IMPORTED_MODULE_9__.TWOPI;\n            if (n > 0 && th > bestAng)\n                continue;\n            let x = x1 + r * Math.cos(th + curth);\n            let y = y1 + r * Math.sin(th + curth);\n            if (_data_CoordUtil__WEBPACK_IMPORTED_MODULE_2__.CoordUtil.atomAtPoint(mol, x, y) > 0)\n                continue;\n            bestAng = th;\n            bestX = x;\n            bestY = y;\n        }\n        if (bestAng > _util_util__WEBPACK_IMPORTED_MODULE_9__.TWOPI) {\n            this.errmsg = 'No alternative geometries identified.';\n            return;\n        }\n        this.output.mol = mol.clone();\n        this.output.mol.setAtomPos(bto, bestX, bestY);\n    }\n    checkAbbreviationReady() {\n        let junction = 0;\n        let mol = this.input.mol, subjmask = this.subjectMask;\n        for (let n = 1; n <= mol.numBonds; n++) {\n            let b1 = mol.bondFrom(n), b2 = mol.bondTo(n);\n            let atom = 0;\n            if ((subjmask[b1 - 1] && !subjmask[b2 - 1] && _data_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.hasAbbrev(mol, b1)) ||\n                (subjmask[b2 - 1] && !subjmask[b1 - 1] && _data_MolUtil__WEBPACK_IMPORTED_MODULE_5__.MolUtil.hasAbbrev(mol, b2))) {\n                this.errmsg = 'Already an abbreviation.';\n                return false;\n            }\n            if (subjmask[b1 - 1] && !subjmask[b2 - 1])\n                atom = b1;\n            else if (subjmask[b2 - 1] && !subjmask[b1 - 1])\n                atom = b2;\n            if (atom == 0 || atom == junction) { }\n            else if (junction == 0)\n                junction = atom;\n            else {\n                this.errmsg = 'The selected group must be terminal.';\n                return false;\n            }\n        }\n        return true;\n    }\n    mobileSide(bond) {\n        let { mol } = this.input;\n        let atom1 = mol.bondFrom(bond), atom2 = mol.bondTo(bond);\n        let g = _data_Graph__WEBPACK_IMPORTED_MODULE_3__.Graph.fromMolecule(mol);\n        g.removeEdge(atom1 - 1, atom2 - 1);\n        let side1 = [], side2 = [];\n        for (let grp of g.calculateComponentGroups()) {\n            if (grp.includes(atom1 - 1))\n                side1 = _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.add(grp, 1);\n            if (grp.includes(atom2 - 1))\n                side2 = _util_Vec__WEBPACK_IMPORTED_MODULE_10__.Vec.add(grp, 1);\n        }\n        let weight1 = side1.length * (mol.atomRingBlock(atom1) > 0 ? 2 : 1);\n        let weight2 = side2.length * (mol.atomRingBlock(atom2) > 0 ? 2 : 1);\n        let sel1 = false, sel2 = false;\n        for (let a of side1)\n            if (this.isSelected(a)) {\n                sel1 = true;\n                break;\n            }\n        for (let a of side2)\n            if (this.isSelected(a)) {\n                sel2 = true;\n                break;\n            }\n        if (sel1 && !sel2) { }\n        else if ((sel2 && !sel1) || weight2 < weight1)\n            return [atom2, atom1, side2];\n        return [atom1, atom2, side1];\n    }\n    isSelected(atom) {\n        let mask = this.input.selectedMask;\n        return mask ? mask[atom - 1] : false;\n    }\n    removePolymerBlock(atoms) {\n        let polymer = new _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_6__.PolymerBlock(this.input.mol.clone());\n        for (let id of polymer.getIDList()) {\n            let unit = polymer.getUnit(id);\n            for (let atom of atoms)\n                if (unit.atoms.includes(atom)) {\n                    polymer.removeUnit(id);\n                    polymer.rewriteMolecule();\n                    this.output.mol = polymer.mol;\n                    return true;\n                }\n        }\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/sketcher/MoleculeActivity.ts?");

/***/ }),

/***/ "./src/sketcher/PeriodicTableWidget.ts":
/*!*********************************************!*\
  !*** ./src/sketcher/PeriodicTableWidget.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PeriodicTableWidget\": () => (/* binding */ PeriodicTableWidget)\n/* harmony export */ });\n/* harmony import */ var _data_Chemistry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/Chemistry */ \"./src/data/Chemistry.ts\");\n/* harmony import */ var _ui_Widget__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ui/Widget */ \"./src/ui/Widget.ts\");\n/* harmony import */ var _util_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/dom */ \"./src/util/dom.ts\");\n/* harmony import */ var _util_Theme__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Theme */ \"./src/util/Theme.ts\");\n\n\n\n\nconst POSITION_TABLE_Y = [\n    1, 1,\n    2, 2, 2, 2, 2, 2, 2, 2,\n    3, 3, 3, 3, 3, 3, 3, 3,\n    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n    6, 6,\n    8.5, 8.5, 8.5, 8.5, 8.5, 8.5, 8.5, 8.5, 8.5, 8.5, 8.5, 8.5, 8.5, 8.5,\n    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n    7, 7,\n    9.5, 9.5, 9.5, 9.5, 9.5, 9.5, 9.5, 9.5, 9.5, 9.5, 9.5, 9.5, 9.5, 9.5,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7\n];\nconst POSITION_TABLE_X = [\n    1, 18,\n    1, 2, 13, 14, 15, 16, 17, 18,\n    1, 2, 13, 14, 15, 16, 17, 18,\n    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,\n    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,\n    1, 2,\n    3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.5, 11.5, 12.5, 13.5, 14.5, 15.5, 16.5,\n    3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,\n    1, 2,\n    3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.5, 11.5, 12.5, 13.5, 14.5, 15.5, 16.5,\n    3, 4, 5, 6, 7, 8, 9, 10, 11, 12\n];\nconst CSS_PERIODICTABLE = `\n\t*.wmk-periodictable-element\n\t{\n\t\tborder: 1px solid black;\n\t\tborder-radius: 2px;\n\t\tmargin: 0;\n\t\tmin-width: 2em;\n\t\tpadding: 0.4em 0 0.3em 0;\n\t\ttext-align: center;\n\t\tcolor: #FFFFFF;\n\t\tcursor: pointer;\n\t}\n\t*.wmk-periodictable-block1\n\t{\n\t\tbackground-color: #313062;\n\t}\n\t*.wmk-periodictable-block2\n\t{\n\t\tbackground-color: #205224;\n\t}\n\t*.wmk-periodictable-block3\n\t{\n\t\tbackground-color: #522818;\n\t}\n\t*.wmk-periodictable-block4\n\t{\n\t\tbackground-color: #575212;\n\t}\n\t*.wmk-periodictable-selected\n\t{\n\t\tbackground-color: #FFFFFF;\n\t\tcolor: #000000;\n\t\tcursor: default;\n\t}\n`;\nclass PeriodicTableWidget extends _ui_Widget__WEBPACK_IMPORTED_MODULE_1__.Widget {\n    constructor() {\n        super();\n        this.divList = [];\n        this.selectedAtno = 0;\n        (0,_util_Theme__WEBPACK_IMPORTED_MODULE_3__.installInlineCSS)('periodictable', CSS_PERIODICTABLE);\n    }\n    render(parent) {\n        super.render(parent);\n        let grid = (0,_util_dom__WEBPACK_IMPORTED_MODULE_2__.dom)('<div/>').appendTo(this.contentDOM).css({ 'display': 'grid' });\n        grid.css({ 'align-items': 'center', 'justify-content': 'start', 'gap': '1px' });\n        let row = POSITION_TABLE_Y.map((y) => Math.round(2 * y) + 1);\n        let col = POSITION_TABLE_X.map((x) => Math.round(2 * x) + 1);\n        let num = row.length;\n        for (let n = 0; n < num; n++) {\n            let div = (0,_util_dom__WEBPACK_IMPORTED_MODULE_2__.dom)('<div/>').appendTo(grid);\n            div.css({ 'grid-row': `${row[n]} / span 2`, 'grid-column': `${col[n]} / span 2` });\n            div.addClass('wmk-periodictable-element');\n            let blk = _data_Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENT_BLOCKS[n + 1];\n            if (blk == 1)\n                div.addClass('wmk-periodictable-block1');\n            else if (blk == 2)\n                div.addClass('wmk-periodictable-block2');\n            else if (blk == 3)\n                div.addClass('wmk-periodictable-block3');\n            else if (blk == 4)\n                div.addClass('wmk-periodictable-block4');\n            let el = _data_Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENTS[n + 1];\n            div.setText(el);\n            this.divList.push(div);\n            div.onClick(() => {\n                this.changeElement(el);\n                this.callbackSelect(el);\n            });\n            div.onDblClick((event) => {\n                this.callbackDoubleClick();\n                event.preventDefault();\n                event.stopPropagation();\n            });\n        }\n    }\n    onSelect(callback) {\n        this.callbackSelect = callback;\n    }\n    onDoubleClick(callback) {\n        this.callbackDoubleClick = callback;\n    }\n    changeElement(element) {\n        let atno = _data_Chemistry__WEBPACK_IMPORTED_MODULE_0__.Chemistry.ELEMENTS.indexOf(element);\n        if (atno == this.selectedAtno)\n            return;\n        if (this.selectedAtno > 0)\n            this.divList[this.selectedAtno - 1].removeClass('wmk-periodictable-selected');\n        this.selectedAtno = atno;\n        if (this.selectedAtno > 0)\n            this.divList[this.selectedAtno - 1].addClass('wmk-periodictable-selected');\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/sketcher/PeriodicTableWidget.ts?");

/***/ }),

/***/ "./src/sketcher/QueryFieldsWidget.ts":
/*!*******************************************!*\
  !*** ./src/sketcher/QueryFieldsWidget.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"QueryFieldsWidget\": () => (/* binding */ QueryFieldsWidget)\n/* harmony export */ });\n/* harmony import */ var _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/QueryUtil */ \"./src/data/QueryUtil.ts\");\n/* harmony import */ var _ui_OptionList__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ui/OptionList */ \"./src/ui/OptionList.ts\");\n/* harmony import */ var _ui_Widget__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ui/Widget */ \"./src/ui/Widget.ts\");\n/* harmony import */ var _util_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/dom */ \"./src/util/dom.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n\n\n\n\n\nclass QueryFieldsWidget extends _ui_Widget__WEBPACK_IMPORTED_MODULE_2__.Widget {\n    constructor(mol, atom, bond) {\n        super();\n        this.mol = mol;\n        this.atom = atom;\n        this.bond = bond;\n    }\n    render(parent) {\n        super.render(parent);\n        let grid = (0,_util_dom__WEBPACK_IMPORTED_MODULE_3__.dom)('<div/>').appendTo(this.contentDOM);\n        grid.css({ 'display': 'grid', 'align-items': 'center', 'justify-content': 'start' });\n        grid.css({ 'grid-row-gap': '0.5em', 'grid-column-gap': '0.5em' });\n        grid.css({ 'grid-template-columns': '[title] auto [value] auto [end]' });\n        let row = 0;\n        let makeInput = () => {\n            let input = (0,_util_dom__WEBPACK_IMPORTED_MODULE_3__.dom)('<input size=\"20\"/>').appendTo(grid).css({ 'grid-area': `${row} / value` });\n            return input;\n        };\n        let makeToggleInput = () => {\n            let div = (0,_util_dom__WEBPACK_IMPORTED_MODULE_3__.dom)('<div/>').appendTo(grid).css({ 'grid-area': `${row} / value`, 'dispkay': 'flex' });\n            let lbl = (0,_util_dom__WEBPACK_IMPORTED_MODULE_3__.dom)('<label/>').appendTo(div).css({ 'margin-right': '0.5em' });\n            let chk = (0,_util_dom__WEBPACK_IMPORTED_MODULE_3__.dom)('<input type=\"checkbox\"/>').appendTo(lbl);\n            lbl.appendText('Not');\n            let input = (0,_util_dom__WEBPACK_IMPORTED_MODULE_3__.dom)('<input size=\"20\"/>').appendTo(div).css({ 'flex-grow': '1' });\n            return [chk, input];\n        };\n        if (this.atom > 0) {\n            (0,_util_dom__WEBPACK_IMPORTED_MODULE_3__.dom)('<div>Charges</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });\n            this.inputCharges = makeInput();\n            (0,_util_dom__WEBPACK_IMPORTED_MODULE_3__.dom)('<div>Aromatic</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });\n            this.optAromatic = new _ui_OptionList__WEBPACK_IMPORTED_MODULE_1__.OptionList(['Maybe', 'Yes', 'No']);\n            this.optAromatic.render((0,_util_dom__WEBPACK_IMPORTED_MODULE_3__.dom)('<div/>').appendTo(grid).css({ 'grid-area': `${row} / value` }));\n            (0,_util_dom__WEBPACK_IMPORTED_MODULE_3__.dom)('<div>Elements</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });\n            [this.chkNotElements, this.inputElements] = makeToggleInput();\n            (0,_util_dom__WEBPACK_IMPORTED_MODULE_3__.dom)('<div>Ring Sizes</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });\n            [this.chkNotRingSizes, this.inputRingSizes] = makeToggleInput();\n            (0,_util_dom__WEBPACK_IMPORTED_MODULE_3__.dom)('<div>Ring Block</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });\n            this.optRingBlock = new _ui_OptionList__WEBPACK_IMPORTED_MODULE_1__.OptionList(['Maybe', 'Yes', 'No']);\n            this.optRingBlock.render((0,_util_dom__WEBPACK_IMPORTED_MODULE_3__.dom)('<div/>').appendTo(grid).css({ 'grid-area': `${row} / value` }));\n            (0,_util_dom__WEBPACK_IMPORTED_MODULE_3__.dom)('<div># Small Rings</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });\n            this.inputNumRings = makeInput();\n            (0,_util_dom__WEBPACK_IMPORTED_MODULE_3__.dom)('<div>Adjacency</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });\n            this.inputAdjacency = makeInput();\n            (0,_util_dom__WEBPACK_IMPORTED_MODULE_3__.dom)('<div>Bond Sums</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });\n            this.inputBondSums = makeInput();\n            (0,_util_dom__WEBPACK_IMPORTED_MODULE_3__.dom)('<div>Valences</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });\n            this.inputValences = makeInput();\n            (0,_util_dom__WEBPACK_IMPORTED_MODULE_3__.dom)('<div>Hydrogens</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });\n            this.inputHydrogens = makeInput();\n            (0,_util_dom__WEBPACK_IMPORTED_MODULE_3__.dom)('<div>Isotopes</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });\n            this.inputIsotopes = makeInput();\n            this.setupAtom();\n        }\n        else {\n            (0,_util_dom__WEBPACK_IMPORTED_MODULE_3__.dom)('<div>Ring Sizes</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });\n            [this.chkNotRingSizes, this.inputRingSizes] = makeToggleInput();\n            (0,_util_dom__WEBPACK_IMPORTED_MODULE_3__.dom)('<div>Ring Block</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });\n            this.optRingBlock = new _ui_OptionList__WEBPACK_IMPORTED_MODULE_1__.OptionList(['Maybe', 'Yes', 'No']);\n            this.optRingBlock.render((0,_util_dom__WEBPACK_IMPORTED_MODULE_3__.dom)('<div/>').appendTo(grid).css({ 'grid-area': `${row} / value` }));\n            (0,_util_dom__WEBPACK_IMPORTED_MODULE_3__.dom)('<div># Small Rings</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });\n            this.inputNumRings = makeInput();\n            (0,_util_dom__WEBPACK_IMPORTED_MODULE_3__.dom)('<div>Num Rings</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });\n            this.inputNumRings = makeInput();\n            (0,_util_dom__WEBPACK_IMPORTED_MODULE_3__.dom)('<div>Bond Orders</div>').appendTo(grid).css({ 'grid-area': `${++row} / title` });\n            this.inputOrders = makeInput();\n            this.setupBond();\n        }\n    }\n    updateAtom() {\n        const { mol, atom } = this;\n        _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.deleteQueryAtomAll(mol, atom);\n        let chg = this.splitNumbers(this.inputCharges.getValue());\n        if (chg)\n            _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.setQueryAtomCharges(mol, atom, chg);\n        let arom = this.optAromatic.getSelectedIndex();\n        if (arom > 0)\n            _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.setQueryAtomAromatic(mol, atom, arom == 1);\n        let elem = this.splitStrings(this.inputElements.getValue());\n        if (elem) {\n            if (!this.chkNotElements.elInput.checked)\n                _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.setQueryAtomElements(mol, atom, elem);\n            else\n                _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.setQueryAtomElementsNot(mol, atom, elem);\n        }\n        let ringsz = this.splitNumbers(this.inputRingSizes.getValue());\n        if (ringsz) {\n            if (!this.chkNotRingSizes.elInput.checked)\n                _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.setQueryAtomRingSizes(mol, atom, ringsz);\n            else\n                _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.setQueryAtomRingSizesNot(mol, atom, ringsz);\n        }\n        let ringblk = this.optRingBlock.getSelectedIndex();\n        if (ringblk > 0)\n            _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.setQueryAtomRingBlock(mol, atom, ringblk == 1);\n        let nring = this.splitNumbers(this.inputNumRings.getValue());\n        if (nring)\n            _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.setQueryAtomNumRings(mol, atom, nring);\n        let adj = this.splitNumbers(this.inputAdjacency.getValue());\n        if (adj)\n            _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.setQueryAtomAdjacency(mol, atom, adj);\n        let bond = this.splitNumbers(this.inputBondSums.getValue());\n        if (bond)\n            _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.setQueryAtomBondSums(mol, atom, bond);\n        let val = this.splitNumbers(this.inputValences.getValue());\n        if (val)\n            _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.setQueryAtomValences(mol, atom, val);\n        let hyd = this.splitNumbers(this.inputHydrogens.getValue());\n        if (hyd)\n            _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.setQueryAtomHydrogens(mol, atom, hyd);\n        let iso = this.splitNumbers(this.inputIsotopes.getValue());\n        if (iso)\n            _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.setQueryAtomIsotope(mol, atom, iso);\n    }\n    updateBond() {\n        const { mol, bond } = this;\n        _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.deleteQueryBondAll(mol, bond);\n        let ringsz = this.splitNumbers(this.inputRingSizes.getValue());\n        if (ringsz) {\n            if (!this.chkNotRingSizes.elInput.checked)\n                _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.setQueryBondRingSizes(mol, bond, ringsz);\n            else\n                _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.setQueryBondRingSizesNot(mol, bond, ringsz);\n        }\n        let ringblk = this.optRingBlock.getSelectedIndex();\n        if (ringblk > 0)\n            _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.setQueryBondRingBlock(mol, bond, ringblk == 1);\n        let nring = this.splitNumbers(this.inputNumRings.getValue());\n        if (nring)\n            _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.setQueryBondNumRings(mol, bond, nring);\n        let order = this.splitNumbers(this.inputOrders.getValue());\n        if (order)\n            _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.setQueryBondOrders(mol, bond, order);\n    }\n    setupAtom() {\n        const { mol, atom } = this;\n        let chg = _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.queryAtomCharges(mol, atom);\n        let arom = _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.queryAtomAromatic(mol, atom);\n        let elem = _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.queryAtomElements(mol, atom);\n        let elemNot = _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.queryAtomElementsNot(mol, atom);\n        let ringsz = _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.queryAtomRingSizes(mol, atom);\n        let ringszNot = _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.queryAtomRingSizesNot(mol, atom);\n        let ringblk = _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.queryAtomRingBlock(mol, atom);\n        let nring = _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.queryAtomNumRings(mol, atom);\n        let adj = _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.queryAtomAdjacency(mol, atom);\n        let bond = _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.queryAtomBondSums(mol, atom);\n        let val = _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.queryAtomValences(mol, atom);\n        let hyd = _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.queryAtomHydrogens(mol, atom);\n        let iso = _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.queryAtomIsotope(mol, atom);\n        let frag = _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.queryAtomSubFrags(mol, atom);\n        let fragNot = _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.queryAtomSubFragsNot(mol, atom);\n        this.inputCharges.setValue(_util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.notBlank(chg) ? chg.join(',') : '');\n        this.optAromatic.setSelectedIndex(arom == null ? 0 : arom ? 1 : 2);\n        this.chkNotElements.elInput.checked = _util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.isBlank(elem) && _util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.notBlank(elemNot);\n        this.inputElements.setValue(_util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.notBlank(elem) ? elem.join(',') : _util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.notBlank(elemNot) ? elemNot.join(',') : '');\n        this.chkNotRingSizes.elInput.checked = _util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.isBlank(ringsz) && _util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.notBlank(ringszNot);\n        this.inputRingSizes.setValue(_util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.notBlank(ringsz) ? ringsz.join(',') : _util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.notBlank(ringszNot) ? ringszNot.join(',') : '');\n        this.optRingBlock.setSelectedIndex(ringblk == null ? 0 : ringblk ? 1 : 2);\n        this.inputNumRings.setValue(_util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.notBlank(nring) ? nring.join(',') : '');\n        this.inputAdjacency.setValue(_util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.notBlank(adj) ? adj.join(',') : '');\n        this.inputBondSums.setValue(_util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.notBlank(bond) ? bond.join(',') : '');\n        this.inputValences.setValue(_util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.notBlank(val) ? val.join(',') : '');\n        this.inputHydrogens.setValue(_util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.notBlank(hyd) ? hyd.join(',') : '');\n        this.inputIsotopes.setValue(_util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.notBlank(iso) ? iso.join(',') : '');\n    }\n    setupBond() {\n        const { mol, bond } = this;\n        let ringsz = _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.queryBondRingSizes(mol, bond);\n        let ringszNot = _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.queryBondRingSizesNot(mol, bond);\n        let ringblk = _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.queryBondRingBlock(mol, bond);\n        let nring = _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.queryBondNumRings(mol, bond);\n        let order = _data_QueryUtil__WEBPACK_IMPORTED_MODULE_0__.QueryUtil.queryBondOrders(mol, bond);\n        this.chkNotRingSizes.elInput.checked = _util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.isBlank(ringsz) && _util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.notBlank(ringszNot);\n        this.inputRingSizes.setValue(_util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.notBlank(ringsz) ? ringsz.join(',') : _util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.notBlank(ringszNot) ? ringszNot.join(',') : '');\n        this.optRingBlock.setSelectedIndex(ringblk == null ? 0 : ringblk ? 1 : 2);\n        this.inputNumRings.setValue(_util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.notBlank(nring) ? nring.join(',') : '');\n        this.inputOrders.setValue(_util_Vec__WEBPACK_IMPORTED_MODULE_4__.Vec.notBlank(order) ? order.join(',') : '');\n    }\n    splitStrings(str) {\n        let list = [];\n        if (str)\n            for (let bit of str.split(/[\\s\\,\\;]+/))\n                if (bit)\n                    list.push(bit);\n        return list.length ? list : null;\n    }\n    splitNumbers(str) {\n        let list = [];\n        if (str)\n            for (let bit of str.split(/[\\s\\,\\;]+/)) {\n                if (bit.startsWith('+'))\n                    bit = bit.substring(1);\n                let num = parseInt(bit);\n                if (!isNaN(num))\n                    list.push(num);\n            }\n        return list.length ? list : null;\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/sketcher/QueryFieldsWidget.ts?");

/***/ }),

/***/ "./src/sketcher/Sketcher.ts":
/*!**********************************!*\
  !*** ./src/sketcher/Sketcher.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Sketcher\": () => (/* binding */ Sketcher)\n/* harmony export */ });\n/* harmony import */ var _data_CoordUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/CoordUtil */ \"./src/data/CoordUtil.ts\");\n/* harmony import */ var _data_DataSheetStream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/DataSheetStream */ \"./src/data/DataSheetStream.ts\");\n/* harmony import */ var _data_Molecule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data/Molecule */ \"./src/data/Molecule.ts\");\n/* harmony import */ var _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../data/MoleculeStream */ \"./src/data/MoleculeStream.ts\");\n/* harmony import */ var _data_MolUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../data/MolUtil */ \"./src/data/MolUtil.ts\");\n/* harmony import */ var _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../data/PolymerBlock */ \"./src/data/PolymerBlock.ts\");\n/* harmony import */ var _data_SketchUtil__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../data/SketchUtil */ \"./src/data/SketchUtil.ts\");\n/* harmony import */ var _gfx_ArrangeMolecule__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../gfx/ArrangeMolecule */ \"./src/gfx/ArrangeMolecule.ts\");\n/* harmony import */ var _gfx_DrawMolecule__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../gfx/DrawMolecule */ \"./src/gfx/DrawMolecule.ts\");\n/* harmony import */ var _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../gfx/MetaVector */ \"./src/gfx/MetaVector.ts\");\n/* harmony import */ var _gfx_Rendering__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../gfx/Rendering */ \"./src/gfx/Rendering.ts\");\n/* harmony import */ var _ui_ButtonView__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../ui/ButtonView */ \"./src/ui/ButtonView.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _CommandBank__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./CommandBank */ \"./src/sketcher/CommandBank.ts\");\n/* harmony import */ var _ContextSketch__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./ContextSketch */ \"./src/sketcher/ContextSketch.ts\");\n/* harmony import */ var _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./DrawCanvas */ \"./src/sketcher/DrawCanvas.ts\");\n/* harmony import */ var _EditAtom__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./EditAtom */ \"./src/sketcher/EditAtom.ts\");\n/* harmony import */ var _EditBond__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./EditBond */ \"./src/sketcher/EditBond.ts\");\n/* harmony import */ var _EditPolymer__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./EditPolymer */ \"./src/sketcher/EditPolymer.ts\");\n/* harmony import */ var _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./MoleculeActivity */ \"./src/sketcher/MoleculeActivity.ts\");\n/* harmony import */ var _TemplateBank__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./TemplateBank */ \"./src/sketcher/TemplateBank.ts\");\n/* harmony import */ var _ToolBank__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./ToolBank */ \"./src/sketcher/ToolBank.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Sketcher extends _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DrawCanvas {\n    constructor() {\n        super();\n        this.inDialog = false;\n        this.initialFocus = true;\n        this.useToolBank = true;\n        this.lowerToolBank = false;\n        this.useCommandBank = true;\n        this.lowerCommandBank = false;\n        this.useTemplateBank = true;\n        this.lowerTemplateBank = false;\n        this.debugOutput = undefined;\n        this.beenSetup = false;\n        this.undoStack = [];\n        this.redoStack = [];\n        this.fadeWatermark = 0;\n        this.toolView = null;\n        this.commandView = null;\n        this.templateView = null;\n        this.proxyClip = null;\n        this.proxyMenu = null;\n    }\n    setSize(width, height) {\n        this.width = width;\n        this.height = height;\n    }\n    defineMolecule(mol, withAutoScale = true, withStashUndo = false, keepSelect = false) {\n        if (mol.compareTo(this.mol) == 0)\n            return;\n        if (withStashUndo)\n            this.stashUndo();\n        this.stopTemplateFusion();\n        this.mol = mol.clone();\n        if (this.onChangeMolecule)\n            this.onChangeMolecule(this.mol);\n        this.guidelines = [];\n        for (let n = 1; n <= this.mol.numAtoms; n++) {\n            for (let sprout of _data_SketchUtil__WEBPACK_IMPORTED_MODULE_6__.SketchUtil.guidelineSprouts(this.mol, n))\n                this.guidelines.push(sprout);\n        }\n        if (!this.beenSetup)\n            return;\n        if (!keepSelect) {\n            this.currentAtom = this.currentBond = 0;\n            this.selectedMask = null;\n        }\n        this.stereo = null;\n        this.hoverAtom = 0;\n        this.hoverBond = 0;\n        if (!withAutoScale)\n            this.renderMolecule();\n        else\n            this.autoScale();\n    }\n    defineClipboard(proxy) {\n        this.proxyClip = proxy;\n    }\n    defineContext(proxy) {\n        this.proxyMenu = proxy;\n    }\n    defineMoleculeString(molsk, withAutoScale, withStashUndo) {\n        this.defineMolecule(_data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.fromString(molsk), withAutoScale, withStashUndo);\n    }\n    defineRenderPolicy(policy) {\n        this.policy = policy;\n        this.pointScale = policy.data.pointScale;\n    }\n    defineBackground(borderCol, borderRad, bgCol) {\n        if (borderCol != null)\n            this.border = borderCol;\n        if (borderRad != null)\n            this.borderRadius = borderRad;\n        if (bgCol != null)\n            this.background = bgCol;\n    }\n    clearMolecule() { this.defineMolecule(new _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule(), true, true); }\n    getMolecule() { return this.mol.clone(); }\n    setup(callback) {\n        this.beenSetup = true;\n        if (this.mol == null)\n            this.mol = new _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule();\n        if (this.policy == null) {\n            this.policy = _gfx_Rendering__WEBPACK_IMPORTED_MODULE_10__.RenderPolicy.defaultColourOnWhite();\n            this.pointScale = this.policy.data.pointScale;\n        }\n        this.layoutMolecule();\n        this.centreAndShrink();\n        this.redrawMetaVector();\n        if (callback)\n            callback();\n    }\n    setupAsync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve) => this.setup(() => resolve()));\n        });\n    }\n    render(parent) {\n        super.render(parent);\n        this.centreAndShrink();\n        this.redraw();\n        let reserveHeight = 0;\n        if (this.useCommandBank) {\n            this.commandView = new _ui_ButtonView__WEBPACK_IMPORTED_MODULE_11__.ButtonView(_ui_ButtonView__WEBPACK_IMPORTED_MODULE_11__.ButtonViewPosition.Bottom, 0, 0, this.width, this.height);\n            if (this.lowerCommandBank)\n                this.commandView.lowerBank();\n            this.commandView.setHasBigButtons(false);\n            this.commandView.pushBank(new _CommandBank__WEBPACK_IMPORTED_MODULE_14__.CommandBank(this));\n            this.commandView.render(this.container);\n            reserveHeight = this.commandView.height;\n        }\n        if (this.useToolBank) {\n            this.toolView = new _ui_ButtonView__WEBPACK_IMPORTED_MODULE_11__.ButtonView(_ui_ButtonView__WEBPACK_IMPORTED_MODULE_11__.ButtonViewPosition.Left, 0, 0, this.width, this.height - reserveHeight);\n            if (this.lowerToolBank)\n                this.toolView.lowerBank();\n            this.toolView.setHasBigButtons(false);\n            this.toolView.pushBank(new _ToolBank__WEBPACK_IMPORTED_MODULE_22__.ToolBank(this));\n            this.toolView.render(this.container);\n        }\n        if (this.useTemplateBank) {\n            this.templateView = new _ui_ButtonView__WEBPACK_IMPORTED_MODULE_11__.ButtonView(_ui_ButtonView__WEBPACK_IMPORTED_MODULE_11__.ButtonViewPosition.Right, 0, 0, this.width, this.height - reserveHeight);\n            if (this.lowerTemplateBank)\n                this.templateView.lowerBank();\n            this.templateView.setHasBigButtons(true);\n            this.templateView.pushBank(new _TemplateBank__WEBPACK_IMPORTED_MODULE_21__.TemplateBank(this, null));\n            this.templateView.render(this.container);\n        }\n        this.container.onClick((event) => this.mouseClick(event));\n        this.container.onDblClick((event) => this.mouseDoubleClick(event));\n        this.container.onMouseDown((event) => this.mouseDown(event));\n        this.container.onMouseUp((event) => this.mouseUp(event));\n        this.container.onMouseOver((event) => this.mouseOver(event));\n        this.container.onMouseLeave((event) => this.mouseOut(event));\n        this.container.onMouseMove((event) => this.mouseMove(event));\n        this.container.onKeyPress((event) => this.keyPressed(event));\n        this.container.onKeyDown((event) => this.keyDown(event));\n        this.container.onKeyUp((event) => this.keyUp(event));\n        this.container.onTouchStart((event) => this.touchStart(event));\n        this.container.onTouchMove((event) => this.touchMove(event));\n        this.container.onTouchCancel((event) => this.touchCancel(event));\n        this.container.onTouchEnd((event) => this.touchEnd(event));\n        this.contentDOM.onContextMenu((event) => this.contextMenu(event));\n        this.container.el.addEventListener('dragover', (event) => {\n            event.stopPropagation();\n            event.preventDefault();\n            event.dataTransfer.dropEffect = 'copy';\n        });\n        this.container.el.addEventListener('drop', (event) => {\n            event.stopPropagation();\n            event.preventDefault();\n            this.dropInto(event.dataTransfer);\n        });\n        if (this.initialFocus)\n            this.grabFocus();\n    }\n    get decoration() { return this.viewOpt.decoration; }\n    set decoration(decoration) { if (this.viewOpt.decoration != decoration) {\n        this.viewOpt.decoration = decoration;\n        this.renderMolecule();\n    } }\n    get showOxState() { return this.viewOpt.showOxState; }\n    set showOxState(showOxState) { if (this.viewOpt.showOxState != showOxState) {\n        this.viewOpt.showOxState = showOxState;\n        this.renderMolecule();\n    } }\n    get showQuery() { return this.viewOpt.showQuery; }\n    set showQuery(showQuery) { if (this.viewOpt.showQuery != showQuery) {\n        this.viewOpt.showQuery = showQuery;\n        this.renderMolecule();\n    } }\n    get showArtifacts() { return this.viewOpt.showArtifacts; }\n    set showArtifacts(showArtifacts) { if (this.viewOpt.showArtifacts != showArtifacts) {\n        this.viewOpt.showArtifacts = showArtifacts;\n        this.renderMolecule();\n    } }\n    changeSize(width, height) {\n        if (width == this.width && height == this.height)\n            return;\n        this.width = width;\n        this.height = height;\n        for (let widget of [this.container, this.canvasUnder, this.canvasMolecule, this.canvasOver]) {\n            widget.css({ 'width': `${width}px`, 'height': `${height}px` });\n        }\n        for (let btnv of [this.commandView, this.toolView, this.templateView])\n            if (btnv) {\n                btnv.setParentSize(width, height);\n                btnv.refreshBank();\n            }\n        this.autoScale();\n    }\n    showMessage(msg, isError = false) {\n        let watermark = ++this.fadeWatermark;\n        this.divMessage.css({ 'color': isError ? '#FF0000' : '#008000' });\n        this.divMessage.setText(msg);\n        let szLeft = (this.toolView == null ? 0 : this.toolView.width) + 2;\n        let szRight = (this.templateView == null ? 0 : this.templateView.width) + 2;\n        let szBottom = (this.commandView == null ? 0 : this.commandView.height) + 2;\n        this.divMessage.css({ 'left': szLeft + 'px' });\n        this.divMessage.css({ 'width': (this.width - szLeft - szRight) + 'px' });\n        this.divMessage.css({ 'height': (this.height - szBottom) + 'px' });\n        window.setTimeout(() => {\n            if (watermark == this.fadeWatermark)\n                this.divMessage.setText('');\n        }, 5000);\n    }\n    clearMessage() {\n        if (this.divMessage.getText() == '')\n            return;\n        this.fadeWatermark++;\n        this.divMessage.setText('');\n    }\n    autoScale() {\n        this.pointScale = this.policy.data.pointScale;\n        this.layoutMolecule();\n        this.centreAndShrink();\n        this.redrawMetaVector();\n        this.layoutTemplatePerm();\n        this.delayedRedraw();\n    }\n    anySelected() {\n        if (this.selectedMask == null)\n            return false;\n        for (let n = 0; n < this.selectedMask.length; n++)\n            if (this.selectedMask[n])\n                return true;\n        return false;\n    }\n    setSelected(atom, sel) {\n        if (this.selectedMask == null) {\n            this.selectedMask = new Array(this.mol.numAtoms);\n            for (let n = this.selectedMask.length - 1; n >= 0; n--)\n                this.selectedMask[n] = false;\n        }\n        while (this.selectedMask.length < this.mol.numAtoms) {\n            this.selectedMask.push(false);\n        }\n        this.selectedMask[atom - 1] = sel;\n        this.delayedRedraw();\n    }\n    changeCurrentAtom(atom) {\n        if (this.currentAtom == atom)\n            return;\n        this.currentAtom = atom;\n        this.currentBond = 0;\n        this.delayedRedraw();\n    }\n    changeCurrentBond(bond) {\n        if (this.currentBond == bond)\n            return;\n        this.currentBond = bond;\n        this.currentAtom = 0;\n        this.delayedRedraw();\n    }\n    clearSubject() {\n        if (this.currentAtom == 0 && this.currentBond == 0 && _util_Vec__WEBPACK_IMPORTED_MODULE_13__.Vec.allFalse(this.selectedMask))\n            return;\n        this.currentAtom = 0;\n        this.currentBond = 0;\n        this.selectedMask = _util_Vec__WEBPACK_IMPORTED_MODULE_13__.Vec.booleanArray(false, this.mol.numAtoms);\n        this.delayedRedraw();\n    }\n    setState(state, withStashUndo = true) {\n        this.stopTemplateFusion();\n        if (state.mol != null)\n            this.defineMolecule(state.mol.clone(), false, withStashUndo, true);\n        if (state.currentAtom >= 0)\n            this.currentAtom = state.currentAtom;\n        if (state.currentBond >= 0)\n            this.currentBond = state.currentBond;\n        if (state.selectedMask != null)\n            this.selectedMask = state.selectedMask == null ? null : state.selectedMask.slice(0);\n        this.delayedRedraw();\n    }\n    stashUndo() {\n        if (this.undoStack.length == 0 && this.mol.numAtoms == 0)\n            return;\n        let state = this.getState();\n        this.undoStack.push(state);\n        while (this.undoStack.length > Sketcher.UNDO_SIZE) {\n            this.undoStack.splice(0, 1);\n        }\n        this.redoStack = [];\n    }\n    setPermutations(perms) {\n        this.templatePerms = perms;\n        this.pickTemplatePermutation(0);\n        this.fusionBank = new _TemplateBank__WEBPACK_IMPORTED_MODULE_21__.FusionBank(this);\n        this.templateView.pushBank(this.fusionBank);\n        if (this.mol.numAtoms == 0)\n            this.centreAndShrink();\n    }\n    stopTemplateFusion() {\n        if (this.fusionBank != null)\n            this.templateView.popBank();\n    }\n    clearPermutations() {\n        if (this.templatePerms == null)\n            return;\n        this.templatePerms = null;\n        this.delayedRedraw();\n        this.fusionBank = null;\n    }\n    templateAccept() {\n        let mol = _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.fromString(this.templatePerms[this.currentPerm].mol);\n        this.templateView.popBank();\n        this.defineMolecule(mol, false, true, false);\n    }\n    templateRotate(dir) {\n        let idx = (this.currentPerm + dir) % this.templatePerms.length;\n        if (idx < 0)\n            idx += this.templatePerms.length;\n        this.pickTemplatePermutation(idx);\n    }\n    canUndo() { return this.undoStack.length > 0; }\n    canRedo() { return this.redoStack.length > 0; }\n    performUndo() {\n        if (this.undoStack.length == 0)\n            return;\n        let state = this.getState();\n        this.redoStack.push(state);\n        this.setState(this.undoStack.pop(), false);\n    }\n    performRedo() {\n        if (this.redoStack.length == 0)\n            return;\n        let state = this.getState();\n        this.undoStack.push(state);\n        this.setState(this.redoStack.pop(), false);\n    }\n    performCopy(mol) {\n        if (!mol)\n            mol = this.getMolecule();\n        if (this.proxyClip)\n            this.proxyClip.setString(mol.toString());\n    }\n    performCopySelection(andCut) {\n        new _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.MoleculeActivity(this.getState(), andCut ? _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.ActivityType.Cut : _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.ActivityType.Copy, {}, this).execute();\n    }\n    performPaste() {\n        if (this.proxyClip && this.proxyClip.canAlwaysGet()) {\n            let txt = this.proxyClip.getString();\n            this.pasteText(txt);\n        }\n    }\n    performActivity(activity, param = {}) {\n        new _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.MoleculeActivity(this.getState(), activity, param, this).execute();\n    }\n    zoom(mag) {\n        let cx = 0.5 * this.width, cy = 0.5 * this.height;\n        let newScale = Math.min(10 * this.policy.data.pointScale, Math.max(0.1 * this.policy.data.pointScale, this.pointScale * mag));\n        if (newScale == this.pointScale)\n            return;\n        this.offsetX = cx - (newScale / this.pointScale) * (cx - this.offsetX);\n        this.offsetY = cy - (newScale / this.pointScale) * (cy - this.offsetY);\n        this.pointScale = newScale;\n        this.layoutMolecule();\n        this.redrawMetaVector();\n        this.layoutTemplatePerm();\n        this.delayedRedraw();\n    }\n    editCurrent() {\n        if (this.currentAtom > 0)\n            this.editAtom(this.currentAtom);\n        else if (this.currentBond > 0)\n            this.editBond(this.currentBond);\n    }\n    pasteText(str) {\n        let mol = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_3__.MoleculeStream.readUnknown(str);\n        if (!mol) {\n            let ds = _data_DataSheetStream__WEBPACK_IMPORTED_MODULE_1__.DataSheetStream.readXML(str);\n            if (ds) {\n                outer: for (let r = 0; r < ds.numRows; r++)\n                    for (let c = 0; c < ds.numCols; c++)\n                        if (ds.colType(c) == \"molecule\" && ds.notNull(r, c)) {\n                            mol = ds.getMolecule(r, c);\n                            break outer;\n                        }\n            }\n        }\n        if (mol != null)\n            this.pasteMolecule(mol);\n        else\n            alert('Text from clipboard is not a valid molecule.');\n    }\n    pasteMolecule(mol) {\n        if (this.mol.numAtoms == 0) {\n            this.defineMolecule(mol, true, true, true);\n            return;\n        }\n        let molact = new _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.MoleculeActivity(this.getState(), _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.ActivityType.QueryPaste, { 'qmol': mol });\n        molact.execute();\n        if (molact.output.mol) {\n            this.defineMolecule(molact.output.mol, false, true, true);\n            return;\n        }\n        let param = { 'fragNative': mol.toString() };\n        new _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.MoleculeActivity(this.getState(), _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.ActivityType.TemplateFusion, param, this).execute();\n    }\n    pickTemplatePermutation(idx) {\n        let perm = this.templatePerms[idx];\n        this.currentPerm = idx;\n        this.layoutTemplatePerm();\n        this.delayedRedraw();\n    }\n    performPolymerBlock(atoms) {\n        let dlg = new _EditPolymer__WEBPACK_IMPORTED_MODULE_19__.EditPolymer(this.mol, atoms, this.proxyClip, () => {\n            if (this.mol.compareTo(dlg.mol) != 0)\n                this.defineMolecule(dlg.mol, false, true, true);\n            dlg.close();\n        });\n        dlg.callbackClose = () => {\n            this.inDialog = false;\n            this.grabFocus();\n        };\n        this.inDialog = true;\n        dlg.open();\n    }\n    grabFocus() {\n        this.container.grabFocus();\n    }\n    hasFocus() {\n        return this.container.hasFocus();\n    }\n    centreAndShrink() {\n        if (this.mol.numAtoms == 0 || this.layout == null) {\n            this.offsetX = 0.5 * this.width;\n            this.offsetY = 0.5 * this.height;\n            this.pointScale = this.policy.data.pointScale;\n            return;\n        }\n        let bounds = this.layout.determineBoundary(0);\n        let limW = this.width - 6, limH = this.height - 6;\n        let natW = bounds[2] - bounds[0], natH = bounds[3] - bounds[1];\n        let scale = 1;\n        if (natW > limW) {\n            let down = limW / natW;\n            scale *= down;\n            natW *= down;\n            natH *= down;\n        }\n        if (natH > limH) {\n            let down = limH / natH;\n            scale *= down;\n            natW *= down;\n            natH *= down;\n        }\n        if (scale < 1) {\n            this.pointScale *= scale;\n            this.layout.offsetEverything(this.offsetX * scale, this.offsetY * scale);\n            this.layout.scaleEverything(scale);\n            bounds = this.layout.determineBoundary(0);\n        }\n        let dx = 0.5 * (limW - natW) - bounds[0], dy = 0.5 * (limH - natH) - bounds[1];\n        this.offsetX += dx;\n        this.offsetY += dy;\n        this.layout.offsetEverything(dx, dy);\n    }\n    layoutTemplatePerm() {\n        if (this.currentPerm < 0 || this.templatePerms == null)\n            return;\n        let perm = this.templatePerms[this.currentPerm];\n        let tpolicy = new _gfx_Rendering__WEBPACK_IMPORTED_MODULE_10__.RenderPolicy(this.policy.data);\n        tpolicy.data.foreground = 0x808080;\n        tpolicy.data.atomCols = tpolicy.data.atomCols.slice(0);\n        for (let n in tpolicy.data.atomCols)\n            tpolicy.data.atomCols[n] = 0x808080;\n        let effects = new _gfx_Rendering__WEBPACK_IMPORTED_MODULE_10__.RenderEffects();\n        let layout = new _gfx_ArrangeMolecule__WEBPACK_IMPORTED_MODULE_7__.ArrangeMolecule(_data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.fromString(perm.display), this, tpolicy, effects);\n        layout.arrange();\n        perm.metavec = new _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_9__.MetaVector();\n        new _gfx_DrawMolecule__WEBPACK_IMPORTED_MODULE_8__.DrawMolecule(layout, perm.metavec).draw();\n    }\n    renderMolecule() {\n        this.layoutMolecule();\n        this.redrawMetaVector();\n        this.delayedRedraw();\n    }\n    pickObjectCanvas(x, y) {\n        if (this.layout == null)\n            return 0;\n        if (this.toolView != null) {\n            let pos1 = this.container.offset(), pos2 = this.toolView.contentDOM.offset();\n            if (this.toolView.withinOutline(x + pos1.x - pos2.x, y + pos1.y - pos2.y))\n                return null;\n        }\n        if (this.commandView != null) {\n            let pos1 = this.container.offset(), pos2 = this.commandView.contentDOM.offset();\n            if (this.commandView.withinOutline(x + pos1.x - pos2.x, y + pos1.y - pos2.y))\n                return null;\n        }\n        if (this.templateView != null) {\n            let pos1 = this.container.offset(), pos2 = this.templateView.contentDOM.offset();\n            if (this.templateView.withinOutline(x + pos1.x - pos2.x, y + pos1.y - pos2.y))\n                return null;\n        }\n        return super.pickObjectCanvas(x, y);\n    }\n    updateHoverCursor(x, y) {\n        let tool = this.toolView ? this.toolView.selectedButton : '';\n        let toolApplies = tool && tool != _ToolBank__WEBPACK_IMPORTED_MODULE_22__.ToolBankItem.Pan && tool != _ToolBank__WEBPACK_IMPORTED_MODULE_22__.ToolBankItem.Rotate;\n        let mouseObj = 0;\n        if (this.dragType == _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.None && toolApplies) {\n            mouseObj = this.pickObject(x, y);\n        }\n        let mouseAtom = mouseObj > 0 ? mouseObj : 0, mouseBond = mouseObj < 0 ? -mouseObj : 0;\n        let abbrevThen = this.hoverAtom > 0 && _data_MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.hasAbbrev(this.mol, this.hoverAtom) ? this.hoverAtom : 0;\n        let abbrevNow = mouseAtom > 0 && _data_MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.hasAbbrev(this.mol, mouseAtom) ? mouseAtom : 0;\n        if (mouseAtom != this.hoverAtom || mouseBond != this.hoverBond) {\n            this.hoverAtom = mouseAtom;\n            this.hoverBond = mouseBond;\n            if (abbrevThen != abbrevNow) {\n                this.layoutMolecule();\n                this.redrawMetaVector();\n            }\n            this.delayedRedraw();\n        }\n    }\n    determineDragGuide(order) {\n        if (this.opAtom == 0 || this.mol.atomAdjCount(this.opAtom) == 0) {\n            let g = {\n                'atom': this.opAtom,\n                'orders': [order],\n                'x': [],\n                'y': [],\n                'sourceX': this.opAtom == 0 ? this.clickX : this.angToX(this.mol.atomX(this.opAtom)),\n                'sourceY': this.opAtom == 0 ? this.clickY : this.angToY(this.mol.atomY(this.opAtom)),\n                'destX': [],\n                'destY': []\n            };\n            let mx = this.opAtom == 0 ? this.xToAng(this.clickX) : this.mol.atomX(this.opAtom);\n            let my = this.opAtom == 0 ? this.yToAng(this.clickY) : this.mol.atomY(this.opAtom);\n            for (let n = 0; n < 12; n++) {\n                let theta = _util_util__WEBPACK_IMPORTED_MODULE_12__.TWOPI * n / 12;\n                let dx = _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.IDEALBOND * Math.cos(theta), dy = _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.IDEALBOND * Math.sin(theta);\n                g.x.push(mx + dx);\n                g.y.push(my + dy);\n                g.destX.push(g.sourceX + dx * this.pointScale);\n                g.destY.push(g.sourceY - dy * this.pointScale);\n            }\n            return [g];\n        }\n        if (this.guidelines == null)\n            return null;\n        let best = null, single = null;\n        for (let n = 0; n < this.guidelines.length; n++) {\n            let g = this.guidelines[n];\n            if (g.atom != this.opAtom)\n                continue;\n            if (g.orders.indexOf(order) >= 0) {\n                best = g;\n                break;\n            }\n            if (g.orders.indexOf(1) >= 0)\n                single = g;\n        }\n        if (best == null)\n            best = single;\n        if (best == null)\n            return [];\n        let g = (0,_util_util__WEBPACK_IMPORTED_MODULE_12__.clone)(best);\n        g.sourceX = this.angToX(this.mol.atomX(g.atom));\n        g.sourceY = this.angToY(this.mol.atomY(g.atom));\n        g.destX = [];\n        g.destY = [];\n        for (let n = 0; n < g.x.length; n++) {\n            g.destX.push(this.angToX(g.x[n]));\n            g.destY.push(this.angToY(g.y[n]));\n        }\n        return [g];\n    }\n    determineMoveGuide() {\n        let subj = this.subjectAtoms(false, true);\n        if (subj.length == 0 || subj.length == this.mol.numAtoms)\n            return null;\n        let guides = [];\n        for (let n = 0; n < this.guidelines.length; n++) {\n            let g = this.guidelines[n];\n            if (g.orders.indexOf(1) < 0 || subj.indexOf(g.atom) >= 0)\n                continue;\n            g = (0,_util_util__WEBPACK_IMPORTED_MODULE_12__.clone)(g);\n            g.sourceX = this.angToX(this.mol.atomX(g.atom));\n            g.sourceY = this.angToY(this.mol.atomY(g.atom));\n            g.destX = [];\n            g.destY = [];\n            for (let i = 0; i < g.x.length; i++) {\n                g.destX.push(this.angToX(g.x[i]));\n                g.destY.push(this.angToY(g.y[i]));\n            }\n            guides.push(g);\n        }\n        return guides;\n    }\n    editAtom(atom) {\n        if (atom == 0)\n            return;\n        let dlg = new _EditAtom__WEBPACK_IMPORTED_MODULE_17__.EditAtom(this.mol, atom, this.proxyClip, () => {\n            if (this.mol.compareTo(dlg.mol) != 0)\n                this.defineMolecule(dlg.mol, false, true, true);\n            dlg.close();\n        });\n        dlg.callbackClose = () => {\n            this.inDialog = false;\n            this.grabFocus();\n        };\n        this.inDialog = true;\n        dlg.open();\n    }\n    editBond(bond) {\n        if (bond == 0)\n            return;\n        let dlg = new _EditBond__WEBPACK_IMPORTED_MODULE_18__.EditBond(this.mol, bond, this.proxyClip, () => {\n            if (this.mol.compareTo(dlg.mol) != 0)\n                this.defineMolecule(dlg.mol, false, true, true);\n            dlg.close();\n        });\n        dlg.callbackClose = () => {\n            this.inDialog = false;\n            this.grabFocus();\n        };\n        this.inDialog = true;\n        dlg.open();\n    }\n    hitArrowKey(dx, dy) {\n        let watermark = ++this.cursorWatermark;\n        this.cursorDX += dx;\n        this.cursorDY += dy;\n        setTimeout(() => {\n            if (watermark == this.cursorWatermark)\n                this.cursorJumpDirection();\n        }, 100);\n    }\n    cursorJumpDirection() {\n        let theta = Math.atan2(this.cursorDY, this.cursorDX);\n        if (this.currentAtom > 0)\n            this.jumpFromCurrentAtom(theta);\n        else if (this.currentBond > 0)\n            this.jumpFromCurrentBond(theta);\n        else\n            this.jumpFromNowhere(theta);\n        this.cursorDX = 0;\n        this.cursorDY = 0;\n        this.cursorWatermark = 0;\n    }\n    jumpFromCurrentAtom(theta) {\n        let adj = this.mol.atomAdjList(this.currentAtom);\n        let closest = 0, closestDelta = Number.MAX_VALUE;\n        for (let a of adj) {\n            let dx = this.mol.atomX(a) - this.mol.atomX(this.currentAtom), dy = this.mol.atomY(a) - this.mol.atomY(this.currentAtom);\n            let adjTheta = Math.atan2(dy, dx), delta = Math.abs((0,_util_util__WEBPACK_IMPORTED_MODULE_12__.angleDiff)(adjTheta, theta));\n            if (delta < 35.0 * _util_util__WEBPACK_IMPORTED_MODULE_12__.DEGRAD && delta < closestDelta)\n                [closest, closestDelta] = [a, delta];\n        }\n        if (closest > 0) {\n            this.changeCurrentBond(this.mol.findBond(this.currentAtom, closest));\n            return;\n        }\n        let best = 0, bestScore = Number.MIN_VALUE;\n        for (let n = 1; n <= this.mol.numAtoms; n++)\n            if (n != this.currentAtom && adj.indexOf(n) < 0) {\n                let dx = this.mol.atomX(n) - this.mol.atomX(this.currentAtom), dy = this.mol.atomY(n) - this.mol.atomY(this.currentAtom);\n                let adjTheta = Math.atan2(dy, dx), delta = Math.abs((0,_util_util__WEBPACK_IMPORTED_MODULE_12__.angleDiff)(adjTheta, theta));\n                if (delta > 45.0 * _util_util__WEBPACK_IMPORTED_MODULE_12__.DEGRAD)\n                    continue;\n                let cosdelta = Math.cos(delta);\n                let score = Math.pow(cosdelta, 2) / ((0,_util_util__WEBPACK_IMPORTED_MODULE_12__.norm2_xy)(dx, dy) + 0.001);\n                if (score > bestScore)\n                    [best, bestScore] = [n, score];\n            }\n        if (best > 0)\n            this.changeCurrentAtom(best);\n    }\n    jumpFromCurrentBond(theta) {\n        let [bfr, bto] = this.mol.bondFromTo(this.currentBond);\n        let bondTheta = Math.atan2(this.mol.atomY(bto) - this.mol.atomY(bfr), this.mol.atomX(bto) - this.mol.atomX(bfr));\n        if (Math.abs((0,_util_util__WEBPACK_IMPORTED_MODULE_12__.angleDiff)(theta, bondTheta)) < 50.0 * _util_util__WEBPACK_IMPORTED_MODULE_12__.DEGRAD)\n            this.changeCurrentAtom(bto);\n        if (Math.abs((0,_util_util__WEBPACK_IMPORTED_MODULE_12__.angleDiff)(theta, bondTheta + Math.PI)) < 50.0 * _util_util__WEBPACK_IMPORTED_MODULE_12__.DEGRAD)\n            this.changeCurrentAtom(bfr);\n    }\n    jumpFromNowhere(theta) {\n        if (this.mol.numAtoms == 0)\n            return;\n        if (this.mol.numAtoms == 1) {\n            this.changeCurrentAtom(1);\n            return;\n        }\n        let cx = 0, cy = 0;\n        for (let n = 1; n <= this.mol.numAtoms; n++) {\n            cx += this.mol.atomX(n);\n            cy += this.mol.atomY(n);\n        }\n        let inv = 1.0 / this.mol.numAtoms;\n        cx *= inv;\n        cy *= inv;\n        let best = 0, bestScore = Number.MIN_VALUE;\n        for (let n = 1; n <= this.mol.numAtoms; n++) {\n            let dx = this.mol.atomX(n) - cx, dy = this.mol.atomY(n) - cy, atheta = Math.atan2(dy, dx);\n            let cosdelta = Math.cos(Math.abs((0,_util_util__WEBPACK_IMPORTED_MODULE_12__.angleDiff)(theta + Math.PI, atheta)));\n            let score = cosdelta * (0,_util_util__WEBPACK_IMPORTED_MODULE_12__.norm_xy)(dx, dy);\n            if (score > bestScore)\n                [best, bestScore] = [n, score];\n        }\n        if (best > 0)\n            this.changeCurrentAtom(best);\n    }\n    createRing(rsz, aromatic) {\n        const { mol } = this;\n        let rx = null, ry = null;\n        if (this.currentAtom > 0) {\n            let dx = 0, dy = 0, adj = mol.atomAdjList(this.currentAtom);\n            let x0 = mol.atomX(this.currentAtom), y0 = mol.atomY(this.currentAtom);\n            for (let a of adj) {\n                dx -= mol.atomX(a) - x0;\n                dy -= mol.atomY(a) - y0;\n            }\n            if (Math.abs(dx) < 0.001 && Math.abs(dy) < 0.001) {\n                if (adj.length >= 2) {\n                    let theta = adj.map((a) => Math.atan2(mol.atomY(a) - x0, mol.atomX(a) - y0));\n                    _util_Vec__WEBPACK_IMPORTED_MODULE_13__.Vec.sort(theta);\n                    let best = Number.POSITIVE_INFINITY;\n                    for (let n = 0; n < theta.length; n++) {\n                        let th = (0,_util_util__WEBPACK_IMPORTED_MODULE_12__.angleDiff)(theta[(n + 1) % theta.length], theta[n]);\n                        let lx = Math.cos(th), ly = Math.sin(th), score = _data_CoordUtil__WEBPACK_IMPORTED_MODULE_0__.CoordUtil.congestionPoint(mol, x0 + lx, y0 + ly);\n                        if (score < best)\n                            [best, dx, dy] = [score, lx, ly];\n                    }\n                }\n                else\n                    [dx, dy] = [1, 0];\n            }\n            [rx, ry] = _data_SketchUtil__WEBPACK_IMPORTED_MODULE_6__.SketchUtil.proposeAtomRing(this.mol, rsz, this.currentAtom, dx, dy);\n        }\n        else if (this.currentBond > 0) {\n            let a1 = mol.bondFrom(this.currentBond), a2 = mol.bondTo(this.currentBond);\n            let x1 = mol.atomX(a1), y1 = mol.atomY(a1), x2 = mol.atomX(a2), y2 = mol.atomY(a2);\n            let cx = 0.5 * (x1 + x2), cy = 0.5 * (y1 + y2), ox = y1 - y2, oy = x2 - x1;\n            let [dx, dy] = _data_CoordUtil__WEBPACK_IMPORTED_MODULE_0__.CoordUtil.congestionPoint(mol, cx - ox, cy - oy) < _data_CoordUtil__WEBPACK_IMPORTED_MODULE_0__.CoordUtil.congestionPoint(mol, cx + ox, cy + oy) ? [-ox, -oy] : [ox, oy];\n            [rx, ry] = _data_SketchUtil__WEBPACK_IMPORTED_MODULE_6__.SketchUtil.proposeBondRing(this.mol, rsz, this.currentBond, dx, dy);\n        }\n        else {\n            let x = 0, y = 0;\n            if (mol.numAtoms > 0) {\n                let bound = mol.boundary();\n                [x, y] = [bound.maxX() + _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.IDEALBOND, bound.midY()];\n            }\n            [rx, ry] = _data_SketchUtil__WEBPACK_IMPORTED_MODULE_6__.SketchUtil.proposeNewRing(this.mol, rsz, x, y, 1, 0, false);\n        }\n        if (!rx)\n            return;\n        let param = {\n            'ringX': rx,\n            'ringY': ry,\n            'aromatic': aromatic\n        };\n        let molact = new _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.MoleculeActivity(this.getState(), _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.ActivityType.Ring, param, this);\n        molact.execute();\n    }\n    mouseClick(event) {\n        event.stopPropagation();\n        this.grabFocus();\n        return false;\n    }\n    mouseDoubleClick(event) {\n        event.stopPropagation();\n        event.preventDefault();\n        if (this.toolView.selectedButton != _ToolBank__WEBPACK_IMPORTED_MODULE_22__.ToolBankItem.Arrow)\n            return;\n        let xy = (0,_util_util__WEBPACK_IMPORTED_MODULE_12__.eventCoords)(event, this.container);\n        let clickObj = this.pickObject(xy[0], xy[1]);\n        if (clickObj > 0) {\n            let atom = clickObj;\n            this.editAtom(atom);\n        }\n        else {\n            let bond = -clickObj;\n            this.editBond(bond);\n        }\n        return false;\n    }\n    mouseDown(event) {\n        event.stopPropagation();\n        event.preventDefault();\n        this.clearMessage();\n        if (event.ctrlKey && !event.shiftKey && !event.altKey) {\n            this.contextMenu(event);\n            return;\n        }\n        let [x, y] = (0,_util_util__WEBPACK_IMPORTED_MODULE_12__.eventCoords)(event, this.container);\n        this.interactStart(x, y, event.shiftKey, event.ctrlKey, event.altKey);\n        return false;\n    }\n    mouseUp(event) {\n        event.stopPropagation();\n        let [x, y] = (0,_util_util__WEBPACK_IMPORTED_MODULE_12__.eventCoords)(event, this.container);\n        this.interactEnd(x, y);\n        return false;\n    }\n    mouseOver(event) {\n        event.stopPropagation();\n        let [x, y] = (0,_util_util__WEBPACK_IMPORTED_MODULE_12__.eventCoords)(event, this.container);\n        this.updateHoverCursor(x, y);\n        this.updateLasso(x, y);\n        return false;\n    }\n    mouseOut(event) {\n        event.stopPropagation();\n        let [x, y] = (0,_util_util__WEBPACK_IMPORTED_MODULE_12__.eventCoords)(event, this.container);\n        this.updateHoverCursor(x, y);\n        this.updateLasso(x, y);\n        return false;\n    }\n    mouseMove(event) {\n        event.stopPropagation();\n        let [x, y] = (0,_util_util__WEBPACK_IMPORTED_MODULE_12__.eventCoords)(event, this.container);\n        this.updateHoverCursor(x, y);\n        if (this.dragType == _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.None)\n            return;\n        this.interactDrag(x, y);\n        return false;\n    }\n    keyPressed(event) {\n    }\n    keyDown(event) {\n        let key = event.key;\n        if (key == \"Escape\") {\n            for (let view of [this.templateView, this.commandView, this.toolView])\n                if (view != null && view.stackSize > 1) {\n                    view.popBank();\n                    event.preventDefault();\n                    event.stopPropagation();\n                    return;\n                }\n        }\n        let mod = (event.shiftKey ? 'S' : '') + (event.ctrlKey || event.metaKey ? 'C' : '') + (event.altKey ? 'A' : '');\n        let nomod = !event.shiftKey && !event.ctrlKey && !event.altKey && !event.metaKey;\n        if (key == \"Enter\")\n            this.editCurrent();\n        else if (key == \"ArrowLeft\" && nomod)\n            this.hitArrowKey(-1, 0);\n        else if (key == \"ArrowRight\" && nomod)\n            this.hitArrowKey(1, 0);\n        else if (key == \"ArrowUp\" && nomod)\n            this.hitArrowKey(0, 1);\n        else if (key == \"ArrowDown\" && nomod)\n            this.hitArrowKey(0, -1);\n        else if (key == 'z' && mod == 'C')\n            this.performUndo();\n        else if (key == 'Z' && mod == 'SC')\n            this.performRedo();\n        else if (key == 'z' && nomod)\n            this.toolView.cycleSelected(-1);\n        else if (key == 'x' && nomod)\n            this.toolView.cycleSelected(1);\n        else if (this.toolView != null && this.toolView.topBank.claimKey(event)) { }\n        else if (this.commandView != null && this.commandView.topBank.claimKey(event)) { }\n        else if (this.templateView != null && this.templateView.topBank.claimKey(event)) { }\n        else if (key == '#' && mod == 'SC')\n            this.createRing(3, false);\n        else if (key == '$' && mod == 'SC')\n            this.createRing(4, false);\n        else if (key == '%' && mod == 'SC')\n            this.createRing(5, false);\n        else if (key == '^' && mod == 'SC')\n            this.createRing(6, false);\n        else if (key == '&' && mod == 'SC')\n            this.createRing(7, false);\n        else if (key == '3' && mod == 'CA')\n            this.createRing(3, true);\n        else if (key == '4' && mod == 'CA')\n            this.createRing(4, true);\n        else if (key == '5' && mod == 'CA')\n            this.createRing(5, true);\n        else if (key == '6' && mod == 'CA')\n            this.createRing(6, true);\n        else if (key == '7' && mod == 'CA')\n            this.createRing(7, true);\n        else if (key == 'c' && mod == 'C' && this.proxyClip)\n            this.proxyClip.triggerCopy(false);\n        else if (key == 'x' && mod == 'C' && this.proxyClip)\n            this.proxyClip.triggerCopy(true);\n        else if (key == 'v' && mod == 'C' && this.proxyClip && this.proxyClip.canAlwaysGet())\n            this.proxyClip.triggerPaste();\n        else\n            return;\n        event.preventDefault();\n        event.stopPropagation();\n    }\n    keyUp(event) {\n    }\n    touchStart(event) {\n        let [x, y] = (0,_util_util__WEBPACK_IMPORTED_MODULE_12__.eventCoords)(event.touches[0], this.container);\n        if (this.pickObjectCanvas(x, y) == null)\n            return;\n        this.interactStart(x, y, event.shiftKey, event.ctrlKey, event.altKey);\n        event.preventDefault();\n    }\n    touchMove(event) {\n        if (this.dragType != _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.None) {\n            let [x, y] = (0,_util_util__WEBPACK_IMPORTED_MODULE_12__.eventCoords)(event.touches[0], this.container);\n            this.interactDrag(x, y);\n        }\n        event.preventDefault();\n    }\n    touchCancel(event) {\n    }\n    touchEnd(event) {\n        if (this.dragType != _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.None) {\n            let [x, y] = [this.mouseX, this.mouseY];\n            this.interactEnd(x, y);\n            event.preventDefault();\n        }\n    }\n    mouseWheel(event) {\n    }\n    contextMenu(event) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.dragType = _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.None;\n        if (!this.proxyMenu)\n            return;\n        let [x, y] = (0,_util_util__WEBPACK_IMPORTED_MODULE_12__.eventCoords)(event, this.container);\n        let clickObj = this.pickObject(x, y);\n        if (clickObj > 0)\n            this.changeCurrentAtom(clickObj);\n        else if (clickObj < 0)\n            this.changeCurrentBond(-clickObj);\n        let state = this.getState();\n        let ctx = new _ContextSketch__WEBPACK_IMPORTED_MODULE_15__.ContextSketch(state, this, this.proxyClip);\n        let menu = ctx.populate();\n        this.proxyMenu.openContextMenu(menu, event);\n    }\n    interactStart(x, y, shiftKey, ctrlKey, altKey) {\n        this.dragType = _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Press;\n        this.opBudged = false;\n        this.dragGuides = null;\n        this.mouseX = x;\n        this.mouseY = y;\n        this.clickX = x;\n        this.clickY = y;\n        let clickObj = this.pickObject(x, y);\n        this.opAtom = clickObj > 0 ? clickObj : 0;\n        this.opBond = clickObj < 0 ? -clickObj : 0;\n        this.opShift = shiftKey;\n        this.opCtrl = ctrlKey;\n        this.opAlt = altKey;\n        let tool = '';\n        if (this.toolView != null)\n            tool = this.toolView.selectedButton;\n        if (tool == _ToolBank__WEBPACK_IMPORTED_MODULE_22__.ToolBankItem.Arrow) {\n            if (!this.opShift && !this.opCtrl && !this.opAlt) {\n                this.dragType = _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Press;\n            }\n            else if (!this.opShift && !this.opCtrl && this.opAlt) {\n                this.dragType = _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Pan;\n            }\n            else if (!this.opShift && this.opCtrl && this.opAlt) {\n                this.dragType = _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Zoom;\n            }\n        }\n        else if (tool == _ToolBank__WEBPACK_IMPORTED_MODULE_22__.ToolBankItem.Rotate) {\n            this.dragType = _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Rotate;\n            this.toolRotateIncr = this.opShift ? 0 : 15 * _util_util__WEBPACK_IMPORTED_MODULE_12__.DEGRAD;\n        }\n        else if (tool == _ToolBank__WEBPACK_IMPORTED_MODULE_22__.ToolBankItem.Pan) {\n            this.dragType = _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Pan;\n        }\n        else if (tool == _ToolBank__WEBPACK_IMPORTED_MODULE_22__.ToolBankItem.Drag) {\n            this.dragType = _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Move;\n            if (this.opAtom > 0)\n                this.dragGuides = this.determineMoveGuide();\n            this.delayedRedraw();\n        }\n        else if (tool == _ToolBank__WEBPACK_IMPORTED_MODULE_22__.ToolBankItem.Erasor) {\n            this.dragType = _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Erasor;\n            this.lassoX = [x];\n            this.lassoY = [y];\n            this.lassoMask = [];\n        }\n        else if (tool == _ToolBank__WEBPACK_IMPORTED_MODULE_22__.ToolBankItem.RingAliph) {\n            this.dragType = _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Ring;\n            this.toolRingArom = false;\n            this.toolRingFreeform = this.opShift;\n        }\n        else if (tool == _ToolBank__WEBPACK_IMPORTED_MODULE_22__.ToolBankItem.RingArom) {\n            this.dragType = _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Ring;\n            this.toolRingArom = true;\n            this.toolRingFreeform = this.opShift;\n        }\n        else if (tool == _ToolBank__WEBPACK_IMPORTED_MODULE_22__.ToolBankItem.AtomPlus) {\n            this.dragType = _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Charge;\n            this.toolChargeDelta = 1;\n        }\n        else if (tool == _ToolBank__WEBPACK_IMPORTED_MODULE_22__.ToolBankItem.AtomMinus) {\n            this.dragType = _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Charge;\n            this.toolChargeDelta = -1;\n        }\n        else if (tool.startsWith(_ToolBank__WEBPACK_IMPORTED_MODULE_22__.ToolBankItem.BondPfx)) {\n            this.dragType = _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Bond;\n            this.toolBondOrder = 1;\n            this.toolBondType = _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.BONDTYPE_NORMAL;\n            if (tool == _ToolBank__WEBPACK_IMPORTED_MODULE_22__.ToolBankItem.BondOrder0)\n                this.toolBondOrder = 0;\n            else if (tool == _ToolBank__WEBPACK_IMPORTED_MODULE_22__.ToolBankItem.BondOrder2)\n                this.toolBondOrder = 2;\n            else if (tool == _ToolBank__WEBPACK_IMPORTED_MODULE_22__.ToolBankItem.BondOrder3)\n                this.toolBondOrder = 3;\n            else if (tool == _ToolBank__WEBPACK_IMPORTED_MODULE_22__.ToolBankItem.BondUnknown)\n                this.toolBondType = _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.BONDTYPE_UNKNOWN;\n            else if (tool == _ToolBank__WEBPACK_IMPORTED_MODULE_22__.ToolBankItem.BondInclined)\n                this.toolBondType = _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.BONDTYPE_INCLINED;\n            else if (tool == _ToolBank__WEBPACK_IMPORTED_MODULE_22__.ToolBankItem.BondDeclined)\n                this.toolBondType = _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.BONDTYPE_DECLINED;\n            if (this.opBond > 0) {\n                let [bfr, bto] = this.mol.bondFromTo(this.opBond), inPoly = false;\n                for (let poly of new _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_5__.PolymerBlock(this.mol).getUnits()) {\n                    let in1 = poly.atoms.includes(bfr), in2 = poly.atoms.includes(bto);\n                    if ((in1 && !in2) || (in2 && !in1)) {\n                        inPoly = true;\n                        break;\n                    }\n                }\n                if (inPoly) {\n                    this.toolBondOrder = 0;\n                    this.toolBondType = _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.BONDTYPE_NORMAL;\n                }\n            }\n            if (this.opBond == 0)\n                this.dragGuides = this.determineDragGuide(this.toolBondOrder);\n        }\n        else if (tool.startsWith(_ToolBank__WEBPACK_IMPORTED_MODULE_22__.ToolBankItem.ElementPfx)) {\n            this.dragType = _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Atom;\n            this.toolAtomSymbol = tool.substring(_ToolBank__WEBPACK_IMPORTED_MODULE_22__.ToolBankItem.ElementPfx.length);\n            this.dragGuides = this.determineDragGuide(1);\n        }\n    }\n    interactDrag(x, y) {\n        if (!this.opBudged) {\n            let dx = x - this.clickX, dy = y - this.clickY;\n            if (dx * dx + dy * dy > 2 * 2)\n                this.opBudged = true;\n        }\n        if (this.dragType == _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Press && this.opAtom == 0 && this.opBond == 0 && this.opBudged) {\n            this.dragType = _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Lasso;\n            this.lassoX = [x];\n            this.lassoY = [y];\n            this.lassoMask = [];\n        }\n        if (this.dragType == _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Lasso || this.dragType == _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Erasor) {\n            this.updateLasso(x, y);\n        }\n        else if (this.dragType == _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Pan) {\n            let dx = x - this.mouseX, dy = y - this.mouseY;\n            if (dx != 0 || dy != 0) {\n                this.offsetX += dx;\n                this.offsetY += dy;\n                this.layout.offsetEverything(dx, dy);\n                this.metavec.transformPrimitives(dx, dy, 1, 1);\n                if (this.currentPerm >= 0 && this.templatePerms != null) {\n                    let perm = this.templatePerms[this.currentPerm];\n                    perm.metavec.transformPrimitives(dx, dy, 1, 1);\n                }\n                this.delayedRedraw();\n            }\n            this.mouseX = x;\n            this.mouseY = y;\n        }\n        else if (this.dragType == _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Zoom) {\n            let dy = y - this.mouseY;\n            if (dy != 0) {\n                dy = Math.min(50, Math.max(-50, dy));\n                let newScale = this.pointScale * (1 - dy * 0.01);\n                newScale = Math.min(10, Math.max(0.1, newScale));\n                let newOX = this.clickX - (newScale / this.pointScale) * (this.clickX - this.offsetX);\n                let newOY = this.clickY - (newScale / this.pointScale) * (this.clickY - this.offsetY);\n                this.pointScale = newScale;\n                this.offsetX = newOX;\n                this.offsetY = newOY;\n                this.delayedRedraw();\n            }\n            this.mouseX = x;\n            this.mouseY = y;\n        }\n        else if (this.dragType == _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Rotate ||\n            this.dragType == _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Move ||\n            this.dragType == _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Atom ||\n            this.dragType == _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Bond ||\n            this.dragType == _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Ring) {\n            this.mouseX = x;\n            this.mouseY = y;\n            this.delayedRedraw();\n        }\n    }\n    interactEnd(x, y) {\n        if (this.opBudged)\n            this.interactEndDrag(x, y);\n        else\n            this.interactEndClick(x, y);\n        this.dragType = _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.None;\n        this.lassoX = null;\n        this.lassoY = null;\n        this.lassoMask = null;\n        this.dragGuides = null;\n        this.delayedRedraw();\n    }\n    interactEndClick(x, y) {\n        let clickObj = this.pickObject(x, y);\n        let clickAtom = clickObj > 0 ? clickObj : 0, clickBond = clickObj < 0 ? -clickObj : 0;\n        if (this.dragType == _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Press) {\n            if (!this.opShift && !this.opCtrl && !this.opAlt) {\n                if (clickAtom == 0 && clickBond == 0) {\n                    if (_util_Vec__WEBPACK_IMPORTED_MODULE_13__.Vec.anyTrue(this.selectedMask))\n                        this.selectedMask = null;\n                    else if (this.currentAtom > 0)\n                        this.currentAtom = 0;\n                    else if (this.currentBond > 0)\n                        this.currentBond = 0;\n                }\n                else if (clickAtom != this.currentAtom || clickBond != this.currentBond) {\n                    this.currentAtom = clickAtom;\n                    this.currentBond = clickBond;\n                }\n                else if (clickAtom == 0 && clickBond == 0 && this.anySelected()) {\n                    this.selectedMask = null;\n                }\n            }\n            else if (this.opShift && !this.opCtrl && !this.opAlt) {\n                if (clickAtom > 0)\n                    this.setSelected(clickAtom, !this.getSelected(clickAtom));\n            }\n        }\n        else if (this.dragType == _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Move) {\n            if (clickObj == 0) {\n                if (_util_Vec__WEBPACK_IMPORTED_MODULE_13__.Vec.anyTrue(this.selectedMask))\n                    this.selectedMask = null;\n                else if (this.currentAtom > 0)\n                    this.currentAtom = 0;\n                else if (this.currentBond > 0)\n                    this.currentBond = 0;\n            }\n        }\n        else if (this.dragType == _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Erasor) {\n            if (this.opAtom > 0 || this.opBond > 0) {\n                let state = Object.assign(Object.assign({}, this.getState()), { 'currentAtom': this.opAtom, 'currentBond': this.opBond, 'selectedMask': [] });\n                let molact = new _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.MoleculeActivity(state, _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.ActivityType.Delete, {}, this);\n                molact.execute();\n            }\n        }\n        else if (this.dragType == _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Atom) {\n            let element = this.toolAtomSymbol;\n            if (element == 'A') {\n                let dlg = new _EditAtom__WEBPACK_IMPORTED_MODULE_17__.EditAtom(this.mol, this.opAtom, this.proxyClip, () => {\n                    let autoscale = this.mol.numAtoms == 0;\n                    if (this.mol.compareTo(dlg.mol) != 0)\n                        this.defineMolecule(dlg.mol, autoscale, true);\n                    dlg.close();\n                });\n                if (this.opAtom == 0) {\n                    dlg.newX = this.xToAng(this.clickX);\n                    dlg.newY = this.yToAng(this.clickY);\n                }\n                dlg.callbackClose = () => {\n                    this.inDialog = false;\n                    this.grabFocus();\n                };\n                this.inDialog = true;\n                dlg.open();\n            }\n            else if (element) {\n                let param = { 'element': element, 'keepAbbrev': true };\n                if (this.opAtom == 0) {\n                    let x = this.xToAng(this.clickX), y = this.yToAng(this.clickY);\n                    if (this.mol.numAtoms == 0) {\n                        this.offsetX = this.clickX;\n                        this.offsetY = this.clickY;\n                        x = 0;\n                        y = 0;\n                    }\n                    param.positionX = x;\n                    param.positionY = y;\n                }\n                let state = Object.assign(Object.assign({}, this.getState()), { 'currentAtom': this.opAtom, 'currentBond': 0, 'selectedMask': null });\n                let molact = new _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.MoleculeActivity(state, _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.ActivityType.Element, param, this);\n                molact.execute();\n            }\n        }\n        else if (this.dragType == _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Charge) {\n            if (this.opAtom > 0 || this.opBond > 0) {\n                let state = Object.assign(Object.assign({}, this.getState()), { 'currentAtom': this.opAtom, 'currentBond': this.opBond, 'selectedMask': null });\n                let molact = new _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.MoleculeActivity(state, _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.ActivityType.Charge, { 'delta': this.toolChargeDelta }, this);\n                molact.execute();\n            }\n        }\n        else if (this.dragType == _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Bond) {\n            let state = Object.assign(Object.assign({}, this.getState()), { 'currentAtom': this.opAtom, 'currentBond': this.opBond, 'selectedMask': null });\n            let molact;\n            if (this.toolBondType == _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.BONDTYPE_NORMAL)\n                molact = new _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.MoleculeActivity(state, _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.ActivityType.BondOrder, { 'order': this.toolBondOrder }, this);\n            else\n                molact = new _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.MoleculeActivity(state, _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.ActivityType.BondType, { 'type': this.toolBondType }, this);\n            molact.execute();\n        }\n    }\n    interactEndDrag(x, y) {\n        if (this.dragType == _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Lasso) {\n            if (this.lassoX.length >= 2) {\n                this.calculateLassoMask();\n                for (let n = 1; n <= this.mol.numAtoms; n++)\n                    if (this.getLassoed(n) && !this.getSelected(n))\n                        this.setSelected(n, true);\n            }\n            this.lassoX = null;\n            this.lassoY = null;\n            this.lassoMask = null;\n            this.delayedRedraw();\n        }\n        else if (this.dragType == _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Erasor) {\n            let any = false;\n            for (let n = 0; n < this.lassoMask.length; n++)\n                if (this.lassoMask[n]) {\n                    any = true;\n                    break;\n                }\n            if (any) {\n                let state = Object.assign(Object.assign({}, this.getState()), { 'currentAtom': 0, 'currentBond': 0, 'selectedMask': this.lassoMask });\n                let molact = new _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.MoleculeActivity(state, _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.ActivityType.Delete, {}, this);\n                molact.execute();\n            }\n        }\n        else if (this.dragType == _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Rotate) {\n            let [x0, y0, theta, magnitude] = this.determineDragTheta();\n            let degrees = -theta * _util_util__WEBPACK_IMPORTED_MODULE_12__.RADDEG;\n            let mx = this.xToAng(x0), my = this.yToAng(y0);\n            let molact = new _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.MoleculeActivity(this.getState(), _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.ActivityType.Rotate, { 'theta': degrees, 'centreX': mx, 'centreY': my }, this);\n            molact.execute();\n        }\n        else if (this.dragType == _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Move) {\n            let [dx, dy] = this.determineMoveDelta();\n            let scale = this.pointScale;\n            let molact = new _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.MoleculeActivity(this.getState(), _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.ActivityType.Move, { 'refAtom': this.opAtom, 'deltaX': dx / scale, 'deltaY': -dy / scale }, this);\n            molact.execute();\n        }\n        else if (this.dragType == _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Ring) {\n            let [ringX, ringY] = this.determineFauxRing();\n            if (ringX != null) {\n                let param = {\n                    'ringX': ringX,\n                    'ringY': ringY,\n                    'aromatic': this.toolRingArom\n                };\n                let molact = new _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.MoleculeActivity(this.getState(), _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.ActivityType.Ring, param, this);\n                molact.execute();\n            }\n        }\n        else if (this.dragType == _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Atom && this.opAtom > 0) {\n            let x2 = this.mouseX, y2 = this.mouseY;\n            let snapTo = this.snapToGuide(x2, y2);\n            if (snapTo != null)\n                [x2, y2] = snapTo;\n            let param = {\n                'order': 1,\n                'type': _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.BONDTYPE_NORMAL,\n                'element': this.toolAtomSymbol,\n                'x1': this.mol.atomX(this.opAtom),\n                'y1': this.mol.atomY(this.opAtom),\n                'x2': this.xToAng(x2),\n                'y2': this.yToAng(y2)\n            };\n            if (this.toolAtomSymbol == 'A')\n                param.element = window.prompt('Enter element symbol:', '');\n            if (param.element != '') {\n                let molact = new _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.MoleculeActivity(this.getState(), _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.ActivityType.BondAtom, param, this);\n                molact.execute();\n            }\n        }\n        else if (this.dragType == _DrawCanvas__WEBPACK_IMPORTED_MODULE_16__.DraggingTool.Bond) {\n            let x2 = this.mouseX, y2 = this.mouseY;\n            let snapTo = this.snapToGuide(x2, y2);\n            if (snapTo != null) {\n                [x2, y2] = snapTo;\n                if (this.opBond > 0) {\n                    let toObj = this.pickObject(x2, y2, { 'noAtoms': true });\n                    if (toObj < 0) {\n                        this.connectPolymerBlock(this.opBond, -toObj);\n                        return;\n                    }\n                }\n            }\n            let param = {\n                'order': this.toolBondOrder,\n                'type': this.toolBondType,\n                'element': 'C',\n                'x1': this.opAtom == 0 ? this.xToAng(this.clickX) : this.mol.atomX(this.opAtom),\n                'y1': this.opAtom == 0 ? this.yToAng(this.clickY) : this.mol.atomY(this.opAtom),\n                'x2': this.xToAng(x2),\n                'y2': this.yToAng(y2)\n            };\n            let molact = new _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.MoleculeActivity(this.getState(), _MoleculeActivity__WEBPACK_IMPORTED_MODULE_20__.ActivityType.BondAtom, param, this);\n            molact.execute();\n        }\n    }\n    dropInto(transfer) {\n        let items = transfer.items, files = transfer.files;\n        const SUFFIXES = ['.el', '.mol'];\n        const MIMES = ['text/plain', 'chemical/x-sketchel', 'x-mdl-molfile'];\n        for (let n = 0; n < items.length; n++) {\n            if (items[n].kind == 'string' && MIMES.indexOf(items[n].type) >= 0) {\n                items[n].getAsString((str) => {\n                    let mol = _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.fromString(str);\n                    if (mol != null) {\n                        this.defineMolecule(mol, true, true, true);\n                    }\n                    else\n                        console.log('Dragged data is not a SketchEl molecule: ' + str);\n                });\n                return;\n            }\n        }\n        for (let n = 0; n < files.length; n++) {\n            for (let sfx of SUFFIXES)\n                if (files[n].name.endsWith(sfx)) {\n                    let reader = new FileReader();\n                    reader.onload = (event) => {\n                        let str = reader.result;\n                        let mol = _data_MoleculeStream__WEBPACK_IMPORTED_MODULE_3__.MoleculeStream.readUnknown(str.toString());\n                        if (mol != null) {\n                            this.defineMolecule(mol, true, true);\n                        }\n                        else\n                            console.log('Dragged file is not a recognised molecule: ' + str);\n                    };\n                    reader.readAsText(files[n]);\n                    return;\n                }\n        }\n    }\n    connectPolymerBlock(bond1, bond2) {\n        let [atomIn1, atomOut1] = this.mol.bondFromTo(bond1), [atomIn2, atomOut2] = this.mol.bondFromTo(bond2);\n        let state = this.getState();\n        let polymer = new _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_5__.PolymerBlock(state.mol);\n        let poly1 = null, poly2 = null;\n        let highName = 0;\n        for (let poly of polymer.getUnits()) {\n            if (!poly1 || poly.atoms.length < poly1.atoms.length) {\n                let ina = poly.atoms.includes(atomIn1), inb = poly.atoms.includes(atomOut1);\n                if (ina && !inb)\n                    poly1 = poly;\n                else if (inb && !ina)\n                    [poly1, atomIn1, atomOut1] = [poly, atomOut1, atomIn1];\n            }\n            if (!poly2 || poly.atoms.length < poly2.atoms.length) {\n                let ina = poly.atoms.includes(atomIn2), inb = poly.atoms.includes(atomOut2);\n                if (ina && !inb)\n                    poly2 = poly;\n                else if (inb && !ina)\n                    [poly2, atomIn2, atomOut2] = [poly, atomOut2, atomIn2];\n            }\n            for (let nameList of poly.atomName.values())\n                highName = Math.max(highName, _util_Vec__WEBPACK_IMPORTED_MODULE_13__.Vec.max(nameList));\n        }\n        if (!poly1 || !poly2)\n            return false;\n        let name1 = _util_Vec__WEBPACK_IMPORTED_MODULE_13__.Vec.first(poly1.atomName.get(atomIn1));\n        if (!name1) {\n            name1 = ++highName;\n            poly1.atomName.set(atomIn1, [name1]);\n        }\n        let name2 = _util_Vec__WEBPACK_IMPORTED_MODULE_13__.Vec.first(poly2.atomName.get(atomIn2));\n        if (!name2) {\n            name2 = ++highName;\n            poly2.atomName.set(atomIn2, [name2]);\n        }\n        poly1.bondIncl.set(bond1, _util_Vec__WEBPACK_IMPORTED_MODULE_13__.Vec.append(poly1.bondIncl.get(bond1), name2));\n        poly2.bondIncl.set(bond2, _util_Vec__WEBPACK_IMPORTED_MODULE_13__.Vec.append(poly2.bondIncl.get(bond2), name1));\n        polymer.rewriteMolecule();\n        this.setState(state);\n    }\n}\nSketcher.UNDO_SIZE = 20;\n\n\n//# sourceURL=webpack://WebMolKit/./src/sketcher/Sketcher.ts?");

/***/ }),

/***/ "./src/sketcher/TemplateBank.ts":
/*!**************************************!*\
  !*** ./src/sketcher/TemplateBank.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FusionBank\": () => (/* binding */ FusionBank),\n/* harmony export */   \"TemplateBank\": () => (/* binding */ TemplateBank)\n/* harmony export */ });\n/* harmony import */ var _data_AbbrevContainer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/AbbrevContainer */ \"./src/data/AbbrevContainer.ts\");\n/* harmony import */ var _data_DataSheetStream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/DataSheetStream */ \"./src/data/DataSheetStream.ts\");\n/* harmony import */ var _data_MolUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data/MolUtil */ \"./src/data/MolUtil.ts\");\n/* harmony import */ var _gfx_ArrangeMeasurement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../gfx/ArrangeMeasurement */ \"./src/gfx/ArrangeMeasurement.ts\");\n/* harmony import */ var _gfx_ArrangeMolecule__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../gfx/ArrangeMolecule */ \"./src/gfx/ArrangeMolecule.ts\");\n/* harmony import */ var _gfx_DrawMolecule__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../gfx/DrawMolecule */ \"./src/gfx/DrawMolecule.ts\");\n/* harmony import */ var _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../gfx/MetaVector */ \"./src/gfx/MetaVector.ts\");\n/* harmony import */ var _gfx_Rendering__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../gfx/Rendering */ \"./src/gfx/Rendering.ts\");\n/* harmony import */ var _ui_ButtonBank__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../ui/ButtonBank */ \"./src/ui/ButtonBank.ts\");\n/* harmony import */ var _util_Theme__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../util/Theme */ \"./src/util/Theme.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _MoleculeActivity__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./MoleculeActivity */ \"./src/sketcher/MoleculeActivity.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\n\n\nclass TemplateBank extends _ui_ButtonBank__WEBPACK_IMPORTED_MODULE_8__.ButtonBank {\n    constructor(owner, group) {\n        super();\n        this.owner = owner;\n        this.group = group;\n        this.subgroups = null;\n        this.templates = null;\n    }\n    init() {\n        let policy = _gfx_Rendering__WEBPACK_IMPORTED_MODULE_7__.RenderPolicy.defaultBlackOnWhite();\n        policy.data.pointScale = 10;\n        policy.data.lineSize *= 1.5;\n        policy.data.bondSep *= 1.5;\n        (() => __awaiter(this, void 0, void 0, function* () {\n            if (TemplateBank.resourceData.length == 0)\n                yield this.loadResourceData();\n            if (this.group == null)\n                this.prepareSubGroups();\n            else\n                this.prepareTemplates();\n        }))();\n    }\n    update() {\n        if (this.subgroups == null && this.templates == null)\n            return;\n        this.buttons = [];\n        if (this.group == null)\n            this.populateGroups();\n        else\n            this.populateTemplates();\n    }\n    populateGroups() {\n        let groups = this.subgroups.groups, titles = this.subgroups.titles, preview = this.subgroups.preview;\n        for (let n = 0; n < groups.length; n++) {\n            this.buttons.push({ 'id': groups[n], 'metavec': preview[n], 'helpText': titles[n] });\n        }\n    }\n    populateTemplates() {\n        let names = this.templates.names, abbrev = this.templates.abbrev, mnemonic = this.templates.mnemonic, preview = this.templates.preview;\n        for (let n = 0; n < names.length; n++) {\n            this.buttons.push({ 'id': n.toString(), 'metavec': preview[n], 'helpText': names[n] });\n        }\n    }\n    hitButton(id) {\n        if (this.group == null) {\n            this.buttonView.pushBank(new TemplateBank(this.owner, id));\n        }\n        else {\n            let idx = parseInt(id);\n            let param = { 'fragNative': this.templates.molecules[idx] };\n            new _MoleculeActivity__WEBPACK_IMPORTED_MODULE_11__.MoleculeActivity(this.owner.getState(), _MoleculeActivity__WEBPACK_IMPORTED_MODULE_11__.ActivityType.TemplateFusion, param, this.owner).execute();\n        }\n    }\n    loadResourceData() {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (let fn of _data_AbbrevContainer__WEBPACK_IMPORTED_MODULE_0__.TEMPLATE_FILES) {\n                let url = _util_Theme__WEBPACK_IMPORTED_MODULE_9__.Theme.RESOURCE_URL + '/data/templates/' + fn + '.ds';\n                let dsstr = yield (0,_util_util__WEBPACK_IMPORTED_MODULE_10__.readTextURL)(url);\n                TemplateBank.resourceList.push(fn);\n                TemplateBank.resourceData.push(_data_DataSheetStream__WEBPACK_IMPORTED_MODULE_1__.DataSheetStream.readXML(dsstr));\n            }\n        });\n    }\n    prepareSubGroups() {\n        this.subgroups = { 'groups': TemplateBank.resourceList, 'titles': [], 'preview': [] };\n        let sz = this.buttonView.idealSize, msz = 0.5 * (sz - 2);\n        let policy = _gfx_Rendering__WEBPACK_IMPORTED_MODULE_7__.RenderPolicy.defaultBlackOnWhite();\n        policy.data.pointScale = 10;\n        let effects = new _gfx_Rendering__WEBPACK_IMPORTED_MODULE_7__.RenderEffects();\n        let measure = new _gfx_ArrangeMeasurement__WEBPACK_IMPORTED_MODULE_3__.OutlineMeasurement(0, 0, policy.data.pointScale);\n        for (let ds of TemplateBank.resourceData) {\n            this.subgroups.titles.push(ds.title);\n            let colMol = ds.firstColOfType(\"molecule\");\n            let metavec = new _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_6__.MetaVector();\n            for (let n = 0, idx = 0; idx < 4 && n < ds.numRows; n++) {\n                let mol = ds.getMolecule(n, colMol);\n                if (_data_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.isBlank(mol))\n                    continue;\n                let layout = new _gfx_ArrangeMolecule__WEBPACK_IMPORTED_MODULE_4__.ArrangeMolecule(mol, measure, policy, effects);\n                layout.arrange();\n                let col = (idx % 2), row = Math.floor(idx / 2);\n                layout.squeezeInto(1 + col * msz, 1 + row * msz, msz, msz, 1);\n                new _gfx_DrawMolecule__WEBPACK_IMPORTED_MODULE_5__.DrawMolecule(layout, metavec).draw();\n                idx++;\n            }\n            metavec.width = sz;\n            metavec.height = sz;\n            this.subgroups.preview.push(metavec);\n        }\n        this.buttonView.refreshBank();\n    }\n    prepareTemplates() {\n        let idx = TemplateBank.resourceList.indexOf(this.group);\n        let ds = TemplateBank.resourceData[idx];\n        this.templates = { 'molecules': [], 'names': [], 'abbrev': [], 'mnemonic': [], 'preview': [] };\n        let sz = this.buttonView.idealSize;\n        let policy = _gfx_Rendering__WEBPACK_IMPORTED_MODULE_7__.RenderPolicy.defaultBlackOnWhite();\n        policy.data.pointScale = 12;\n        let effects = new _gfx_Rendering__WEBPACK_IMPORTED_MODULE_7__.RenderEffects();\n        let measure = new _gfx_ArrangeMeasurement__WEBPACK_IMPORTED_MODULE_3__.OutlineMeasurement(0, 0, policy.data.pointScale);\n        let colMol = ds.findColByName('Molecule');\n        let colName = ds.findColByName('Name');\n        let colAbbrev = ds.findColByName('Abbrev');\n        let colMnemonic = ds.findColByName('Mnemonic');\n        for (let n = 0; n < ds.numRows; n++) {\n            let mol = ds.getMolecule(n, colMol);\n            this.templates.molecules.push(mol.toString());\n            this.templates.names.push(ds.getString(n, colName));\n            this.templates.abbrev.push(ds.getString(n, colAbbrev));\n            this.templates.mnemonic.push(ds.getString(n, colMnemonic));\n            let layout = new _gfx_ArrangeMolecule__WEBPACK_IMPORTED_MODULE_4__.ArrangeMolecule(mol, measure, policy, effects);\n            layout.arrange();\n            layout.squeezeInto(0, 0, sz, sz, 2);\n            let metavec = new _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_6__.MetaVector();\n            new _gfx_DrawMolecule__WEBPACK_IMPORTED_MODULE_5__.DrawMolecule(layout, metavec).draw();\n            metavec.width = sz;\n            metavec.height = sz;\n            this.templates.preview.push(metavec);\n        }\n        this.buttonView.refreshBank();\n    }\n}\nTemplateBank.resourceList = [];\nTemplateBank.resourceData = [];\nclass FusionBank extends _ui_ButtonBank__WEBPACK_IMPORTED_MODULE_8__.ButtonBank {\n    constructor(owner) {\n        super();\n        this.owner = owner;\n    }\n    update() {\n        this.buttons = [];\n        this.buttons.push({ 'id': 'accept', 'imageFN': 'GenericAccept', 'helpText': 'Apply this template.' });\n        this.buttons.push({ 'id': 'prev', 'imageFN': 'TemplatePrev', 'helpText': 'Show previous fusion option.' });\n        this.buttons.push({ 'id': 'next', 'imageFN': 'TemplateNext', 'helpText': 'Show next fusion option.' });\n    }\n    hitButton(id) {\n        if (id == 'accept')\n            this.owner.templateAccept();\n        else if (id == 'prev')\n            this.owner.templateRotate(-1);\n        else if (id == 'next')\n            this.owner.templateRotate(1);\n    }\n    bankClosed() {\n        this.owner.clearPermutations();\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/sketcher/TemplateBank.ts?");

/***/ }),

/***/ "./src/sketcher/TemplateFusion.ts":
/*!****************************************!*\
  !*** ./src/sketcher/TemplateFusion.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FusionPermutation\": () => (/* binding */ FusionPermutation),\n/* harmony export */   \"TemplateFusion\": () => (/* binding */ TemplateFusion)\n/* harmony export */ });\n/* harmony import */ var _data_BondArtifact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/BondArtifact */ \"./src/data/BondArtifact.ts\");\n/* harmony import */ var _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/CoordUtil */ \"./src/data/CoordUtil.ts\");\n/* harmony import */ var _data_Graph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data/Graph */ \"./src/data/Graph.ts\");\n/* harmony import */ var _data_Molecule__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../data/Molecule */ \"./src/data/Molecule.ts\");\n/* harmony import */ var _data_MolUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../data/MolUtil */ \"./src/data/MolUtil.ts\");\n/* harmony import */ var _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../data/PolymerBlock */ \"./src/data/PolymerBlock.ts\");\n/* harmony import */ var _data_SketchUtil__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../data/SketchUtil */ \"./src/data/SketchUtil.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n\n\n\n\n\n\n\n\n\nclass FusionPermutation {\n    constructor() {\n        this.attdist = 0;\n        this.guided = false;\n        this.bridged = false;\n        this.scoreModifier = 0;\n        this.chainSelect = 0;\n    }\n}\nclass TemplateFusion {\n    constructor(mol, templ, abbrev) {\n        this.mol = mol;\n        this.templ = templ;\n        this.abbrev = abbrev;\n        this.perms = [];\n        this.numAttach = 0;\n        this.withGuideOnly = false;\n        this.guidetempl = null;\n        this.guideidx = [];\n        this.guideadj = [];\n        this.timeLimit = 5.0;\n        let artif1 = new _data_BondArtifact__WEBPACK_IMPORTED_MODULE_0__.BondArtifact(mol), artif2 = new _data_BondArtifact__WEBPACK_IMPORTED_MODULE_0__.BondArtifact(templ);\n        artif2.harmoniseNumbering(artif1);\n        artif2.rewriteMolecule();\n        let poly1 = new _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_5__.PolymerBlock(mol), poly2 = new _data_PolymerBlock__WEBPACK_IMPORTED_MODULE_5__.PolymerBlock(templ);\n        poly2.harmoniseNumbering(poly1);\n        poly2.rewriteMolecule();\n        this.huntForGuides();\n    }\n    permuteNone() {\n        let numAttach = 0;\n        let oldmol = this.mol.clone(), newmol = this.templ.clone();\n        if (oldmol.numAtoms > 0) {\n            let oldbox = oldmol.boundary(), newbox = newmol.boundary();\n            let dx = oldbox.maxX() + 1 - newbox.minX();\n            let dy = 0.5 * (oldbox.minY() + oldbox.maxY()) - 0.5 * (newbox.minY() + newbox.maxY());\n            _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.translateMolecule(newmol, dx, dy);\n        }\n        else {\n            let newbox = newmol.boundary();\n            _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.translateMolecule(newmol, -newbox.midX(), -newbox.midY());\n        }\n        let oldbox = oldmol.boundary(), newbox = newmol.boundary();\n        let cx = newbox.midX(), cy = newbox.midY();\n        let ROTN = [0, 30, 45, 60, 90, 120, 135, 150, 180, 210, 225, 240, 270, 300, 315, 330];\n        duplicate: for (let n = 0; n < ROTN.length; n++) {\n            let rotmol = newmol.clone();\n            _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.rotateMolecule(rotmol, -ROTN[n] * _util_util__WEBPACK_IMPORTED_MODULE_7__.DEGRAD, cx, cy);\n            for (let i = 0; i < this.perms.length; i++)\n                if (_data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.sketchEquivalent(rotmol, this.perms[i].display))\n                    continue duplicate;\n            let p = new FusionPermutation();\n            p.mol = oldmol.clone();\n            p.mol.append(rotmol);\n            p.display = rotmol;\n            p.srcidx = this.sourceIndex(p.mol, oldmol);\n            p.attdist = 0;\n            p.guided = false;\n            this.perms.push(p);\n        }\n    }\n    permuteAtom(atom) {\n        this.numAttach = 1;\n        let timeStart = new Date().getTime();\n        let oldmol = this.mol.clone(), newmol = this.templ.clone();\n        let newperms = [];\n        if (this.guidetempl != null) {\n            let fliptempl = _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.mirrorImage(this.guidetempl.clone());\n            for (let n = 0; n < this.guideidx.length; n++) {\n                if (new Date().getTime() - timeStart > this.timeLimit * 1000)\n                    break;\n                this.composeGuidedOne(newperms, oldmol, this.guidetempl, atom, this.guideidx[n]);\n                this.composeGuidedOne(newperms, oldmol, fliptempl, atom, this.guideidx[n]);\n            }\n        }\n        if (!this.withGuideOnly) {\n            let flipmol = newmol.clone();\n            _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.mirrorImage(flipmol);\n            for (let n = 1; n <= newmol.numAtoms; n++) {\n                if (new Date().getTime() - timeStart > this.timeLimit * 1000)\n                    break;\n                this.composeDirectOne(newperms, oldmol, newmol, atom, n);\n                this.composeDirectOne(newperms, oldmol, flipmol, atom, n);\n                this.composeBridge(newperms, oldmol, newmol, atom, n);\n                this.composeBridge(newperms, oldmol, flipmol, atom, n);\n            }\n        }\n        this.affixRawPermutations(newperms);\n    }\n    permuteBond(a1, a2) {\n        this.numAttach = 2;\n        let timeStart = new Date().getTime();\n        let oldmol = this.mol.clone(), newmol = this.templ.clone();\n        let newperms = [];\n        if (this.guidetempl != null) {\n            let fliptempl = _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.mirrorImage(this.guidetempl.clone());\n            for (let i = 0; i < this.guideidx.length; i++) {\n                if (new Date().getTime() - timeStart > this.timeLimit * 1000)\n                    break;\n                let g1 = this.guideidx[i];\n                let adj = this.guidetempl.atomAdjList(g1);\n                for (let j = 0; j < adj.length; j++) {\n                    let g2 = adj[j];\n                    this.composeGuidedTwo(newperms, oldmol, this.guidetempl, a1, a2, g1, g2, true);\n                    this.composeGuidedTwo(newperms, oldmol, this.guidetempl, a2, a1, g1, g2, true);\n                    this.composeGuidedTwo(newperms, oldmol, fliptempl, a1, a2, g1, g2, true);\n                    this.composeGuidedTwo(newperms, oldmol, fliptempl, a2, a1, g1, g2, true);\n                    this.composeGuidedTwo(newperms, oldmol, this.guidetempl, a1, a2, g1, g2, false);\n                    this.composeGuidedTwo(newperms, oldmol, this.guidetempl, a2, a1, g1, g2, false);\n                    this.composeGuidedTwo(newperms, oldmol, fliptempl, a1, a2, g1, g2, false);\n                    this.composeGuidedTwo(newperms, oldmol, fliptempl, a2, a1, g1, g2, false);\n                }\n            }\n        }\n        if (!this.withGuideOnly) {\n            let flipmol = newmol.clone();\n            _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.mirrorImage(flipmol);\n            for (let n = 1; n <= newmol.numBonds; n++) {\n                if (new Date().getTime() - timeStart > this.timeLimit * 1000)\n                    break;\n                let nfr = newmol.bondFrom(n), nto = newmol.bondTo(n);\n                this.composeDirectTwo(newperms, oldmol, newmol, a1, a2, nfr, nto);\n                this.composeDirectTwo(newperms, oldmol, flipmol, a1, a2, nfr, nto);\n                this.composeDirectTwo(newperms, oldmol, newmol, a1, a2, nto, nfr);\n                this.composeDirectTwo(newperms, oldmol, flipmol, a1, a2, nto, nfr);\n            }\n        }\n        this.affixRawPermutations(newperms);\n    }\n    permuteMulti(atoms) {\n        this.numAttach = atoms.length;\n        let timeStart = new Date().getTime();\n        let oldmol = this.mol.clone(), newmol = this.templ.clone();\n        let newperms = [];\n        if (this.guidetempl != null) {\n            let fliptempl = _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.mirrorImage(this.guidetempl.clone());\n            if (this.guideidx.length == atoms.length) {\n                this.composeGuidedMulti(newperms, oldmol, this.guidetempl, atoms, this.guideidx, true);\n                this.composeGuidedMulti(newperms, oldmol, fliptempl, atoms, this.guideidx, true);\n            }\n            if (this.guideadj.length == atoms.length) {\n                this.composeGuidedMulti(newperms, oldmol, this.guidetempl, atoms, this.guideadj, false);\n                this.composeGuidedMulti(newperms, oldmol, fliptempl, atoms, this.guideadj, false);\n            }\n        }\n        if (!this.withGuideOnly) {\n            let flipmol = newmol.clone();\n            _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.mirrorImage(flipmol);\n            for (let n = 1; n <= newmol.numAtoms; n++) {\n                if (new Date().getTime() - timeStart > this.timeLimit * 1000)\n                    break;\n                this.composeDirectMulti(newperms, oldmol, newmol, atoms, n);\n                this.composeDirectMulti(newperms, oldmol, flipmol, atoms, n);\n            }\n        }\n        this.affixRawPermutations(newperms);\n    }\n    huntForGuides() {\n        this.guideidx = [];\n        this.guideadj = [];\n        for (let n = 1; n <= this.templ.numAtoms; n++)\n            if (this.templ.atomElement(n) == 'X' && this.templ.atomAdjCount(n) > 0) {\n                this.guideidx.push(n);\n                let adj = this.templ.atomAdjList(n);\n                for (let i = 0; i < adj.length; i++)\n                    if (this.guideadj.indexOf(adj[i]) < 0)\n                        this.guideadj.push(adj[i]);\n            }\n        if (this.guideidx.length > 0) {\n            this.guidetempl = this.templ.clone();\n            for (let n = this.guideidx.length - 1; n >= 0; n--)\n                this.templ.deleteAtomAndBonds(this.guideidx[n]);\n        }\n    }\n    composeDirectOne(list, oldmol, newmol, o1, n1) {\n        let otheta = _data_SketchUtil__WEBPACK_IMPORTED_MODULE_6__.SketchUtil.primeDirections(oldmol, o1);\n        let ntheta = _data_SketchUtil__WEBPACK_IMPORTED_MODULE_6__.SketchUtil.primeDirections(newmol, n1);\n        let ocurrent = _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.atomBondAngles(oldmol, o1);\n        let ncurrent = _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.atomBondAngles(newmol, n1);\n        let theta1 = [], theta2 = [], scoreMod = [];\n        for (let i = 0; i < ocurrent.length; i++)\n            for (let j = 0; j < ntheta.length; j++) {\n                theta1.push(ocurrent[i]);\n                theta2.push(ntheta[j]);\n                scoreMod.push(-51);\n            }\n        for (let i = 0; i < otheta.length; i++)\n            for (let j = 0; j < ncurrent.length; j++) {\n                theta1.push(otheta[i]);\n                theta2.push(ncurrent[j]);\n                scoreMod.push(0);\n            }\n        for (let i = 0; i < otheta.length; i++)\n            for (let j = 0; j < ntheta.length; j++) {\n                theta1.push(otheta[i]);\n                theta2.push(ntheta[j]);\n                scoreMod.push(0);\n            }\n        let bfs = _data_Graph__WEBPACK_IMPORTED_MODULE_2__.Graph.fromMolecule(newmol).calculateBFS(0);\n        let ox = oldmol.atomX(o1), oy = oldmol.atomY(o1), nx = newmol.atomX(n1), ny = newmol.atomY(n1);\n        for (let n = 0; n < theta1.length; n++) {\n            let dth = (0,_util_util__WEBPACK_IMPORTED_MODULE_7__.angleDiff)(theta1[n], theta2[n]);\n            let frag = newmol.clone();\n            _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.translateMolecule(frag, ox - nx, oy - ny);\n            _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.rotateMolecule(frag, dth, ox, oy);\n            let pmol = oldmol.clone();\n            let osz = pmol.numAtoms;\n            pmol.append(frag);\n            let srcidx = this.sourceIndex(pmol, oldmol);\n            _data_SketchUtil__WEBPACK_IMPORTED_MODULE_6__.SketchUtil.mergeFragmentsMask(pmol, this.asMask(srcidx));\n            if (pmol.numAtoms == osz)\n                continue;\n            let p = new FusionPermutation();\n            p.mol = pmol;\n            p.display = frag;\n            p.srcidx = srcidx;\n            p.molidx = [o1];\n            p.temidx = [n1];\n            p.attdist = bfs[n1 - 1];\n            p.guided = false;\n            p.scoreModifier = scoreMod[n];\n            this.removeExtraGuides(p, oldmol);\n            list.push(p);\n        }\n    }\n    composeDirectTwo(list, oldmol, newmol, o1, o2, n1, n2) {\n        let oth = Math.atan2(oldmol.atomY(o2) - oldmol.atomY(o1), oldmol.atomX(o2) - oldmol.atomX(o1));\n        let nth = Math.atan2(newmol.atomY(n2) - newmol.atomY(n1), newmol.atomX(n2) - newmol.atomX(n1));\n        let cx = 0.5 * (oldmol.atomX(o1) + oldmol.atomX(o2)), cy = 0.5 * (oldmol.atomY(o1) + oldmol.atomY(o2));\n        let frag = newmol.clone();\n        _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.translateMolecule(frag, cx - 0.5 * (newmol.atomX(n1) + newmol.atomX(n2)), cy - 0.5 * (newmol.atomY(n1) + newmol.atomY(n2)));\n        _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.rotateMolecule(frag, oth - nth, cx, cy);\n        frag.setAtomPos(n1, oldmol.atomX(o1), oldmol.atomY(o1));\n        frag.setAtomPos(n2, oldmol.atomX(o2), oldmol.atomY(o2));\n        let pmol = oldmol.clone();\n        let osz = pmol.numAtoms;\n        pmol.append(frag);\n        let srcidx = this.sourceIndex(pmol, oldmol);\n        _data_SketchUtil__WEBPACK_IMPORTED_MODULE_6__.SketchUtil.mergeFragmentsMask(pmol, this.asMask(srcidx));\n        if (pmol.numAtoms == osz)\n            return;\n        let bfs = _data_Graph__WEBPACK_IMPORTED_MODULE_2__.Graph.fromMolecule(newmol).calculateBFS(0);\n        let p = new FusionPermutation();\n        p.mol = pmol;\n        p.display = frag;\n        p.srcidx = srcidx;\n        p.molidx = [o1, o2];\n        p.temidx = [n1, n2];\n        p.attdist = Math.min(bfs[n1 - 1], bfs[n2 - 1]);\n        p.guided = false;\n        this.removeExtraGuides(p, oldmol);\n        list.push(p);\n    }\n    composeDirectMulti(list, oldmol, newmol, oidx, n1) {\n        let frag = newmol.clone();\n        let x0 = oldmol.atomX(oidx[0]), y0 = oldmol.atomY(oidx[0]);\n        _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.translateMolecule(frag, x0 - frag.atomX(n1), y0 - frag.atomY(n1));\n        let ox = oldmol.atomX(oidx[1]) - x0, oy = oldmol.atomY(oidx[1]) - y0;\n        let otheta = Math.atan2(oy, ox), orad = (0,_util_util__WEBPACK_IMPORTED_MODULE_7__.norm_xy)(ox, oy);\n        let bfs = _data_Graph__WEBPACK_IMPORTED_MODULE_2__.Graph.fromMolecule(newmol).calculateBFS(1);\n        let nidx = [];\n        for (let n2 = 1; n2 <= frag.numAtoms; n2++)\n            if (n1 != n2) {\n                let nx = frag.atomX(n2) - frag.atomX(n1), ny = frag.atomY(n2) - frag.atomY(n1), nrad = (0,_util_util__WEBPACK_IMPORTED_MODULE_7__.norm_xy)(nx, ny);\n                if (Math.abs(nrad - orad) > 0.1)\n                    continue;\n                let ntheta = Math.atan2(ny, nx);\n                _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.rotateMolecule(frag, otheta - ntheta, x0, y0);\n                nidx = [n1, n2];\n                for (let i = 2; i < oidx.length; i++) {\n                    let hit = false;\n                    for (let j = 1; j <= frag.numAtoms; j++)\n                        if (nidx.indexOf(j) < 0)\n                            if ((0,_util_util__WEBPACK_IMPORTED_MODULE_7__.norm_xy)(oldmol.atomX(oidx[i]) - frag.atomX(j), oldmol.atomY(oidx[i]) - frag.atomY(j)) < 0.1 * 0.1) {\n                                hit = true;\n                                nidx.push(j);\n                                break;\n                            }\n                    if (!hit)\n                        break;\n                }\n                if (nidx.length < oidx.length)\n                    continue;\n                let lowbfs = bfs.length;\n                for (let n = 0; n < nidx.length; n++)\n                    lowbfs = Math.min(lowbfs, bfs[nidx[n] - 1]);\n                let dx = 0, dy = 0;\n                for (let n = 0; n < oidx.length; n++) {\n                    dx += oldmol.atomX(oidx[n]) - frag.atomX(nidx[n]);\n                    dy += oldmol.atomY(oidx[n]) - frag.atomY(nidx[n]);\n                }\n                let invsz = 1.0 / oidx.length;\n                dx *= invsz;\n                dy *= invsz;\n                _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.translateMolecule(frag, dx, dy);\n                let pmol = oldmol.clone();\n                let osz = pmol.numAtoms;\n                pmol.append(frag);\n                let srcidx = this.sourceIndex(pmol, oldmol);\n                for (let n = 0; n < nidx.length; n++) {\n                    let x = pmol.atomX(oidx[n]), y = pmol.atomY(oidx[n]);\n                    pmol.setAtomPos(osz + nidx[n], x, y);\n                }\n                _data_SketchUtil__WEBPACK_IMPORTED_MODULE_6__.SketchUtil.mergeFragmentsMask(pmol, this.asMask(srcidx));\n                if (pmol.numAtoms == osz)\n                    continue;\n                let p = new FusionPermutation();\n                p.mol = pmol;\n                p.display = frag.clone();\n                p.srcidx = srcidx;\n                p.molidx = oidx.slice(0);\n                p.temidx = nidx.slice(0);\n                p.attdist = Math.min(bfs[n1 - 1], bfs[n2 - 1]);\n                p.guided = false;\n                this.removeExtraGuides(p, oldmol);\n                list.push(p);\n            }\n    }\n    composeBridge(list, oldmol, newmol, o1, n1) {\n        let busy1 = oldmol.atomRingBlock(o1) != 0 || oldmol.atomAdjCount(o1) >= 3;\n        let busy2 = newmol.atomRingBlock(n1) != 0 || newmol.atomAdjCount(n1) >= 3;\n        if (!busy1 || !busy2)\n            return;\n        let otheta = _data_SketchUtil__WEBPACK_IMPORTED_MODULE_6__.SketchUtil.primeDirections(oldmol, o1);\n        let ntheta = _data_SketchUtil__WEBPACK_IMPORTED_MODULE_6__.SketchUtil.primeDirections(newmol, n1);\n        let bfs = _data_Graph__WEBPACK_IMPORTED_MODULE_2__.Graph.fromMolecule(newmol).calculateBFS(0);\n        for (let i = 0; i < otheta.length; i++)\n            for (let j = 0; j < ntheta.length; j++) {\n                let ox = oldmol.atomX(o1), oy = oldmol.atomY(o1), nx = newmol.atomX(n1), ny = newmol.atomY(n1);\n                let dx = _data_Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule.IDEALBOND * Math.cos(otheta[i]), dy = _data_Molecule__WEBPACK_IMPORTED_MODULE_3__.Molecule.IDEALBOND * Math.sin(otheta[i]);\n                let dth = (0,_util_util__WEBPACK_IMPORTED_MODULE_7__.angleDiff)(otheta[i], Math.PI + ntheta[j]);\n                let frag = newmol.clone();\n                _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.translateMolecule(frag, ox - nx + dx, oy - ny + dy);\n                _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.rotateMolecule(frag, dth, ox + dx, oy + dy);\n                let pmol = oldmol.clone();\n                let att = pmol.numAtoms + n1, osz = pmol.numAtoms;\n                pmol.append(frag);\n                let srcidx = this.sourceIndex(pmol, oldmol);\n                pmol.addBond(o1, att, 1);\n                att = frag.addAtom('C', ox, oy);\n                frag.addBond(n1, att, 1);\n                _data_SketchUtil__WEBPACK_IMPORTED_MODULE_6__.SketchUtil.mergeFragmentsMask(pmol, this.asMask(srcidx));\n                if (pmol.numAtoms == osz)\n                    continue;\n                let p = new FusionPermutation();\n                p.mol = pmol;\n                p.display = frag;\n                p.srcidx = srcidx;\n                p.molidx = [o1];\n                p.temidx = [att];\n                p.attdist = bfs[n1 - 1];\n                p.bridged = true;\n                p.guided = false;\n                this.removeExtraGuides(p, oldmol);\n                list.push(p);\n            }\n    }\n    composeGuidedOne(list, oldmol, newmol, oidx, gidx) {\n        if (newmol.atomAdjCount(gidx) == 0)\n            return;\n        let otheta = _data_SketchUtil__WEBPACK_IMPORTED_MODULE_6__.SketchUtil.primeDirections(oldmol, oidx);\n        if (newmol.atomAdjCount(gidx) > 1 && oldmol.atomAdjCount(oidx) > 0) {\n            let ox = 0, oy = 0;\n            let adj = oldmol.atomAdjList(oidx);\n            for (let n = 0; n < adj.length; n++) {\n                ox += oldmol.atomX(adj[n]) - oldmol.atomX(oidx);\n                oy += oldmol.atomY(adj[n]) - oldmol.atomY(oidx);\n            }\n            let ang = Math.atan2(oy, ox);\n            let unique = true;\n            for (let n = 0; n < otheta.length; n++)\n                if (Math.abs((0,_util_util__WEBPACK_IMPORTED_MODULE_7__.angleDiff)(ang, otheta[n])) < 3 * _util_util__WEBPACK_IMPORTED_MODULE_7__.RADDEG) {\n                    unique = false;\n                    break;\n                }\n            if (unique)\n                otheta.push(ang);\n        }\n        let gx = newmol.atomX(gidx), gy = newmol.atomY(gidx);\n        let dx = 0, dy = 0;\n        let adj = newmol.atomAdjList(gidx);\n        for (let n = 0; n < adj.length; n++) {\n            dx += newmol.atomX(adj[n]) - gx;\n            dy += newmol.atomY(adj[n]) - gy;\n        }\n        dx /= adj.length;\n        dy /= adj.length;\n        let ntheta = Math.atan2(dy, dx);\n        let homoPenalty = 0;\n        if (adj.length == 1) {\n            let oel = oldmol.atomElement(oidx), nel = newmol.atomElement(adj[0]);\n            if (oel != 'C' && oel == nel)\n                homoPenalty = 1;\n        }\n        for (let n = 0; n < otheta.length; n++) {\n            let frag = newmol.clone();\n            if (this.guideidx.length == 2) {\n                for (let i = 1; i <= frag.numAtoms; i++)\n                    if (i != gidx && frag.atomElement(i) == 'X') {\n                        frag.setAtomElement(i, TemplateFusion.RESERVED_GUIDESYMBOL);\n                        break;\n                    }\n            }\n            _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.rotateMolecule(frag, otheta[n] - ntheta, gx, gy);\n            _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.translateMolecule(frag, oldmol.atomX(oidx) - gx, oldmol.atomY(oidx) - gy);\n            let pmol = oldmol.clone();\n            let osz = pmol.numAtoms;\n            pmol.append(frag);\n            let srcidx = this.sourceIndex(pmol, oldmol);\n            _data_SketchUtil__WEBPACK_IMPORTED_MODULE_6__.SketchUtil.mergeFragmentsMask(pmol, this.asMask(srcidx));\n            if (pmol.numAtoms == osz)\n                continue;\n            let sel = 0;\n            for (let i = 1; i <= pmol.numAtoms; i++)\n                if (pmol.atomElement(i) == TemplateFusion.RESERVED_GUIDESYMBOL) {\n                    let padj = pmol.atomAdjList(i);\n                    if (padj.length == 1) {\n                        sel = padj[0];\n                        if (sel > i)\n                            sel--;\n                    }\n                    pmol.deleteAtomAndBonds(i);\n                    srcidx.splice(i - 1, 1);\n                    break;\n                }\n            let p = new FusionPermutation();\n            p.mol = pmol;\n            p.display = frag;\n            p.srcidx = srcidx;\n            p.molidx = [oidx];\n            p.temidx = [gidx];\n            p.attdist = 0;\n            p.guided = true;\n            p.scoreModifier = homoPenalty;\n            p.chainSelect = sel;\n            this.removeExtraGuides(p, oldmol);\n            list.push(p);\n        }\n    }\n    composeGuidedTwo(list, oldmol, newmol, o1, o2, gidx, nidx, snapToGuide) {\n        let ox = oldmol.atomX(o1), oy = oldmol.atomY(o1);\n        let gx = newmol.atomX(gidx), gy = newmol.atomY(gidx);\n        let nx = newmol.atomX(nidx), ny = newmol.atomY(nidx);\n        let otheta = Math.atan2(oldmol.atomY(o2) - oy, oldmol.atomX(o2) - ox);\n        let gtheta = Math.atan2(ny - gy, nx - gx);\n        let isGuideOnTerminal = oldmol.atomAdjCount(o1) == 1;\n        let pmol = oldmol.clone(), frag = newmol.clone();\n        _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.rotateMolecule(frag, otheta - gtheta, gx, gy);\n        if (snapToGuide) {\n            _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.translateMolecule(frag, ox - gx, oy - gy);\n            pmol.setAtomPos(o2, frag.atomX(nidx), frag.atomY(nidx));\n        }\n        else {\n            _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.translateMolecule(frag, oldmol.atomX(o2) - frag.atomX(nidx), oldmol.atomY(o2) - frag.atomY(nidx));\n            frag.setAtomPos(gidx, ox, oy);\n        }\n        let osz = pmol.numAtoms;\n        pmol.append(frag);\n        let srcidx = this.sourceIndex(pmol, oldmol);\n        _data_SketchUtil__WEBPACK_IMPORTED_MODULE_6__.SketchUtil.mergeFragmentsMask(pmol, this.asMask(srcidx));\n        if (pmol.numAtoms == osz)\n            return;\n        let p = new FusionPermutation();\n        p.mol = pmol;\n        p.display = frag;\n        p.srcidx = srcidx;\n        p.molidx = [o1, o2];\n        p.temidx = [gidx, nidx];\n        p.attdist = isGuideOnTerminal ? 1 : 0;\n        p.guided = true;\n        this.removeExtraGuides(p, oldmol);\n        list.push(p);\n    }\n    composeGuidedMulti(list, oldmol, newmol, oidx, gidx, nudgenew) {\n        let cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0;\n        for (let n = 0; n < oidx.length; n++) {\n            cx1 += oldmol.atomX(oidx[n]);\n            cy1 += oldmol.atomY(oidx[n]);\n        }\n        for (let n = 0; n < gidx.length; n++) {\n            cx2 += newmol.atomX(gidx[n]);\n            cy2 += newmol.atomY(gidx[n]);\n        }\n        cx1 /= oidx.length;\n        cy1 /= oidx.length;\n        cx2 /= gidx.length;\n        cy2 /= gidx.length;\n        let osz = oldmol.numAtoms;\n        for (let i = 0; i < oidx.length; i++)\n            for (let j = 0; j < gidx.length; j++) {\n                let pmol = oldmol.clone(), frag = newmol.clone();\n                let th1 = Math.atan2(pmol.atomY(oidx[i]) - cy1, pmol.atomX(oidx[i]) - cx1);\n                let th2 = Math.atan2(frag.atomY(gidx[j]) - cy2, frag.atomX(gidx[j]) - cx2);\n                _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.rotateMolecule(frag, th1 - th2, cx2, cy2);\n                _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.translateMolecule(frag, cx1 - cx2, cy1 - cy2);\n                pmol.append(frag);\n                let srcidx = this.sourceIndex(pmol, oldmol);\n                let midx = _util_Vec__WEBPACK_IMPORTED_MODULE_8__.Vec.numberArray(0, gidx.length), tidx = gidx.slice(0);\n                _util_Vec__WEBPACK_IMPORTED_MODULE_8__.Vec.sort(tidx);\n                let mask = _util_Vec__WEBPACK_IMPORTED_MODULE_8__.Vec.booleanArray(false, osz);\n                for (let g = tidx.length - 1; g >= 0; g--) {\n                    let gatom = tidx[g] + osz;\n                    let closest = 0, closeDSQ = 0;\n                    for (let n = 0; n < oidx.length; n++)\n                        if (!mask[oidx[n] - 1]) {\n                            let dx = pmol.atomX(oidx[n]) - pmol.atomX(gatom), dy = pmol.atomY(oidx[n]) - pmol.atomY(gatom);\n                            let dsq = (0,_util_util__WEBPACK_IMPORTED_MODULE_7__.norm_xy)(dx, dy);\n                            if (closest == 0 || dsq < closeDSQ) {\n                                closest = oidx[n];\n                                closeDSQ = dsq;\n                            }\n                        }\n                    if (!nudgenew) {\n                        let dsq = (0,_util_util__WEBPACK_IMPORTED_MODULE_7__.norm_xy)(pmol.atomX(gatom) - pmol.atomX(closest), pmol.atomY(gatom) - pmol.atomY(closest));\n                        if (dsq > 0.1 * 0.1) {\n                            let num = frag.addAtom('C', pmol.atomX(closest), pmol.atomY(closest));\n                            frag.addBond(num, tidx[g], 0);\n                        }\n                        pmol.setAtomPos(closest, pmol.atomX(gatom), pmol.atomY(gatom));\n                    }\n                    midx[g] = closest;\n                    mask[closest - 1] = true;\n                    let adj = pmol.atomAdjList(gatom);\n                    for (let n = 0; n < adj.length; n++) {\n                        let b = pmol.findBond(gatom, adj[n]);\n                        pmol.addBond(closest, adj[n], pmol.bondOrder(b), pmol.bondType(b));\n                    }\n                    pmol.deleteAtomAndBonds(gatom);\n                    srcidx.splice(gatom - 1, 1);\n                    frag.setAtomPos(tidx[g], pmol.atomX(closest), pmol.atomY(closest));\n                }\n                for (let n = pmol.numAtoms; n > osz; n--)\n                    if (pmol.atomElement(n) == 'X') {\n                        pmol.deleteAtomAndBonds(n);\n                        srcidx.splice(n - 1, 1);\n                        for (let k = 0; k < tidx.length; k++)\n                            if (n < tidx[k])\n                                tidx[k]--;\n                    }\n                for (let n = frag.numAtoms; n >= 1; n--)\n                    if (frag.atomElement(n) == 'X') {\n                        frag.setAtomElement(n, 'C');\n                    }\n                let p = new FusionPermutation();\n                p.mol = pmol;\n                p.display = frag;\n                p.srcidx = srcidx;\n                p.molidx = midx;\n                p.temidx = tidx;\n                p.attdist = 0;\n                p.guided = true;\n                this.removeExtraGuides(p, oldmol);\n                list.push(p);\n            }\n    }\n    affixRawPermutations(list) {\n        let npsz = list.length;\n        if (npsz == 0)\n            return;\n        let umask = _util_Vec__WEBPACK_IMPORTED_MODULE_8__.Vec.booleanArray(true, npsz);\n        for (let i = 0; i < npsz - 1; i++)\n            if (umask[i]) {\n                let p1 = list[i];\n                for (let j = i + 1; j < npsz; j++)\n                    if (umask[j]) {\n                        let p2 = list[j];\n                        if (_data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.sketchEquivalent(p1.mol, p2.mol)) {\n                            if (p1.scoreModifier + p1.attdist > p2.scoreModifier + p2.attdist) {\n                                list[i] = p2;\n                                list[j] = p1;\n                            }\n                            umask[j] = false;\n                        }\n                    }\n            }\n        let score = _util_Vec__WEBPACK_IMPORTED_MODULE_8__.Vec.numberArray(0, npsz);\n        let numKeep = 0;\n        for (let n = 0; n < npsz; n++) {\n            if (umask[n]) {\n                score[n] = this.scorePermutation(list[n]);\n                if (score[n] < 1000)\n                    numKeep++;\n            }\n            else\n                score[n] = 0;\n        }\n        if (numKeep > 0)\n            for (let n = 0; n < npsz; n++)\n                if (umask[n] && score[n] >= 1000)\n                    umask[n] = false;\n        let uscore = [], uidx = [];\n        for (let n = 0; n < npsz; n++)\n            if (umask[n]) {\n                uscore.push(score[n]);\n                uidx.push(n);\n            }\n        let sidx = _util_Vec__WEBPACK_IMPORTED_MODULE_8__.Vec.idxSort(uscore);\n        for (let n = 0; n < sidx.length; n++) {\n            let p = list[uidx[sidx[n]]];\n            if (p.guided) {\n                this.perms.push(p);\n            }\n        }\n        for (let n = 0; n < sidx.length; n++) {\n            let p = list[uidx[sidx[n]]];\n            if (!p.guided) {\n                this.perms.push(p);\n            }\n        }\n    }\n    removeExtraGuides(perm, oldmol) {\n        _data_MolUtil__WEBPACK_IMPORTED_MODULE_4__.MolUtil.removeDuplicateBonds(perm.mol);\n        for (let n = perm.temidx.length - 1; n >= 0; n--) {\n            let el = perm.display.atomElement(perm.temidx[n]);\n            if (el != 'X' && el != TemplateFusion.RESERVED_GUIDESYMBOL)\n                continue;\n            perm.molidx.splice(n, 1);\n            perm.temidx.splice(n, 1);\n        }\n        for (let n = perm.display.numAtoms; n >= 1; n--) {\n            let el = perm.display.atomElement(n);\n            if (el != 'X' && el != TemplateFusion.RESERVED_GUIDESYMBOL)\n                continue;\n            let a = _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.atomAtPoint(oldmol, perm.display.atomX(n), perm.display.atomY(n));\n            if (a > 0)\n                perm.display.setAtomElement(n, 'C');\n            else {\n                perm.display.deleteAtomAndBonds(n);\n                for (let i = 0; i < perm.temidx.length; i++)\n                    if (perm.temidx[i] > n)\n                        perm.temidx[i]--;\n            }\n        }\n    }\n    scorePermutation(perm) {\n        let mol = this.mol, tmol = perm.display, tunion = perm.mol;\n        let score = 0.2 * perm.attdist + perm.scoreModifier;\n        score += _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.congestionMolecule(tunion, 1e-3);\n        score -= tunion.numAtoms;\n        let sz1 = mol.numAtoms, sz2 = tmol.numAtoms;\n        let mx1 = [], my1 = [], mx2 = [], my2 = [];\n        for (let n = 0; n < sz1; n++) {\n            mx1.push(mol.atomX(n + 1));\n            my1.push(mol.atomY(n + 1));\n        }\n        for (let n = 0; n < sz2; n++) {\n            mx2.push(tmol.atomX(n + 1));\n            my2.push(tmol.atomY(n + 1));\n        }\n        for (let i = 0; i < sz1; i++)\n            for (let j = 0; j < sz2; j++) {\n                if ((0,_util_util__WEBPACK_IMPORTED_MODULE_7__.norm_xy)(mx1[i] - mx2[j], my1[i] - my2[j]) > _data_CoordUtil__WEBPACK_IMPORTED_MODULE_1__.CoordUtil.OVERLAP_THRESHOLD_SQ)\n                    continue;\n                let contained = false;\n                for (let k = 0; k < perm.molidx.length; k++)\n                    if (perm.molidx[k] == i + 1 && perm.temidx[k] == j + 1) {\n                        contained = true;\n                        break;\n                    }\n                if (contained)\n                    continue;\n                score += 100;\n            }\n        if (!perm.guided)\n            for (let n = 0; n < perm.molidx.length; n++) {\n                let el = mol.atomElement(perm.molidx[n]);\n                if (el == 'C' || el == 'O' || el == 'S' || el == 'N' || el == 'P')\n                    continue;\n                let adj1 = mol.atomAdjList(perm.molidx[n]), adj2 = tmol.atomAdjList(perm.temidx[n]);\n                if (adj1.length + adj2.length >= 4)\n                    continue;\n                for (let i = 0; i < adj1.length; i++)\n                    for (let j = 0; j < adj2.length; j++) {\n                        let ai = adj1[i], aj = adj2[j];\n                        let bo1 = mol.bondOrder(mol.findBond(perm.molidx[n], ai));\n                        let bo2 = tmol.bondOrder(tmol.findBond(perm.temidx[n], aj));\n                        let wantTheta = 0;\n                        if ((bo1 == 1 && bo2 == 1) || (bo1 == 1 && bo2 == 2) || (bo1 == 2 && bo2 == 1))\n                            wantTheta = 120;\n                        else if ((bo1 == 2 && bo2 == 2) || (bo1 == 1 && bo2 == 3) || (bo1 == 3 && bo2 == 1))\n                            wantTheta = 180;\n                        else\n                            continue;\n                        let dx1 = mx1[ai - 1] - mx1[perm.molidx[n] - 1];\n                        let dy1 = my1[ai - 1] - my1[perm.molidx[n] - 1];\n                        let dx2 = mx2[aj - 1] - mx2[perm.temidx[n] - 1];\n                        let dy2 = my2[aj - 1] - my2[perm.temidx[n] - 1];\n                        let theta = Math.abs((0,_util_util__WEBPACK_IMPORTED_MODULE_7__.angleDiff)(Math.atan2(dy1, dx1), Math.atan2(dy2, dx2))) * _util_util__WEBPACK_IMPORTED_MODULE_7__.RADDEG;\n                        if (Math.abs(theta - wantTheta) > 5)\n                            score += 50;\n                    }\n            }\n        for (let n = 1; n <= tunion.numAtoms; n++)\n            if (tunion.atomElement(n) == 'C' || tunion.atomElement(n) == 'N') {\n                let adjb = tunion.atomAdjBonds(n);\n                let totalBO = 0;\n                for (let i = 0; i < adjb.length; i++) {\n                    let bo = tunion.bondOrder(adjb[i]);\n                    totalBO += bo;\n                    if (bo == 0) {\n                        totalBO = 0;\n                        break;\n                    }\n                }\n                if (totalBO > 4)\n                    score += 1000;\n            }\n        if (perm.molidx.length >= 2) {\n            let mmask = _util_Vec__WEBPACK_IMPORTED_MODULE_8__.Vec.booleanArray(false, sz1);\n            for (let n = 0; n < perm.molidx.length; n++)\n                mmask[perm.molidx[n] - 1] = true;\n            for (let n = 1; n <= mol.numBonds; n++) {\n                let bfr = mol.bondFrom(n), bto = mol.bondTo(n);\n                if (!mmask[bfr - 1] || !mmask[bto - 1])\n                    continue;\n                let tfr = perm.molidx.indexOf(bfr), tto = perm.molidx.indexOf(bto);\n                let tn = tmol.findBond(perm.temidx[tfr], perm.temidx[tto]);\n                if (tn == 0)\n                    continue;\n                if (mol.bondOrder(n) != tmol.bondOrder(tn))\n                    score += 1;\n            }\n        }\n        return score;\n    }\n    sourceIndex(xmol, wmol) {\n        let idx = _util_Vec__WEBPACK_IMPORTED_MODULE_8__.Vec.numberArray(0, xmol.numAtoms);\n        for (let n = wmol.numAtoms; n >= 1; n--)\n            idx[n - 1] = n;\n        return idx;\n    }\n    asMask(imask) {\n        let ret = _util_Vec__WEBPACK_IMPORTED_MODULE_8__.Vec.booleanArray(false, imask.length);\n        for (let n = 0; n < imask.length; n++)\n            ret[n] = imask[n] != 0;\n        return ret;\n    }\n}\nTemplateFusion.RESERVED_GUIDESYMBOL = 'XXX';\n\n\n//# sourceURL=webpack://WebMolKit/./src/sketcher/TemplateFusion.ts?");

/***/ }),

/***/ "./src/sketcher/ToolBank.ts":
/*!**********************************!*\
  !*** ./src/sketcher/ToolBank.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ToolBank\": () => (/* binding */ ToolBank),\n/* harmony export */   \"ToolBankItem\": () => (/* binding */ ToolBankItem)\n/* harmony export */ });\n/* harmony import */ var _ui_ButtonBank__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ui/ButtonBank */ \"./src/ui/ButtonBank.ts\");\n\nvar ToolBankItem;\n(function (ToolBankItem) {\n    ToolBankItem[\"Arrow\"] = \"arrow\";\n    ToolBankItem[\"Rotate\"] = \"rotate\";\n    ToolBankItem[\"Pan\"] = \"pan\";\n    ToolBankItem[\"Drag\"] = \"drag\";\n    ToolBankItem[\"Erasor\"] = \"erasor\";\n    ToolBankItem[\"BondOrder0\"] = \"bond:Order0\";\n    ToolBankItem[\"BondOrder1\"] = \"bond:Order1\";\n    ToolBankItem[\"BondOrder2\"] = \"bond:Order2\";\n    ToolBankItem[\"BondOrder3\"] = \"bond:Order3\";\n    ToolBankItem[\"BondUnknown\"] = \"bond:Unknown\";\n    ToolBankItem[\"BondInclined\"] = \"bond:Inclined\";\n    ToolBankItem[\"BondDeclined\"] = \"bond:Declined\";\n    ToolBankItem[\"RingAliph\"] = \"ringAliph\";\n    ToolBankItem[\"RingArom\"] = \"ringArom\";\n    ToolBankItem[\"AtomPlus\"] = \"atomPlus\";\n    ToolBankItem[\"AtomMinus\"] = \"atomMinus\";\n    ToolBankItem[\"BondPfx\"] = \"bond:\";\n    ToolBankItem[\"ElementPfx\"] = \"element:\";\n})(ToolBankItem || (ToolBankItem = {}));\nconst TOOLS_MAIN = [\n    { 'id': ToolBankItem.Arrow, 'imageFN': 'ToolSelect', 'helpText': 'Selection tool.', 'mnemonic': 'Escape' },\n    { 'id': ToolBankItem.Rotate, 'imageFN': 'ToolRotate', 'helpText': 'Rotate subject atoms.', 'mnemonic': '' },\n    { 'id': ToolBankItem.Pan, 'imageFN': 'ToolPan', 'helpText': 'Pan the viewport around the screen.', 'mnemonic': '' },\n    { 'id': ToolBankItem.Drag, 'imageFN': 'ToolDrag', 'helpText': 'Drag selected atoms to new positions.', 'mnemonic': '' },\n    { 'id': ToolBankItem.Erasor, 'imageFN': 'ToolErasor', 'helpText': 'Delete atoms or bonds by selecting.', 'mnemonic': 'Delete' },\n    { 'id': ToolBankItem.BondOrder0, 'imageFN': 'BondZero', 'helpText': 'Create or change a bond to zero order.', 'mnemonic': 'Shift+0', 'key': ')' },\n    { 'id': ToolBankItem.BondOrder1, 'imageFN': 'BondOne', 'helpText': 'Create or change a bond to single.', 'mnemonic': 'Shift+1', 'key': '!' },\n    { 'id': ToolBankItem.BondOrder2, 'imageFN': 'BondTwo', 'helpText': 'Create or change a bond to double.', 'mnemonic': 'Shift+2', 'key': '@' },\n    { 'id': ToolBankItem.BondOrder3, 'imageFN': 'BondThree', 'helpText': 'Create or change a bond to triple.', 'mnemonic': 'Shift+3', 'key': '#' },\n    { 'id': ToolBankItem.BondUnknown, 'imageFN': 'BondSquig', 'helpText': 'Create or change a bond to unknown stereochemistry.', 'mnemonic': 'Shift+4', 'key': '$' },\n    { 'id': ToolBankItem.BondInclined, 'imageFN': 'BondUp', 'helpText': 'Create or change a bond to up-wedge.', 'mnemonic': 'Shift+5', 'key': '%' },\n    { 'id': ToolBankItem.BondDeclined, 'imageFN': 'BondDown', 'helpText': 'Create or change a bond to down-wedge.', 'mnemonic': 'Shift+6', 'key': '^' },\n    { 'id': ToolBankItem.RingAliph, 'imageFN': 'ToolRing', 'helpText': 'Create plain ring.', 'mnemonic': 'Shift+7', 'key': '&' },\n    { 'id': ToolBankItem.RingArom, 'imageFN': 'ToolArom', 'helpText': 'Create aromatic ring.', 'mnemonic': 'Shift+8', 'key': '*' },\n    { 'id': ToolBankItem.AtomPlus, 'imageFN': 'AtomPlus', 'helpText': 'Increase charge on atom.', 'mnemonic': '' },\n    { 'id': ToolBankItem.AtomMinus, 'imageFN': 'AtomMinus', 'helpText': 'Decrease charge on atom.', 'mnemonic': '' },\n    { 'id': ToolBankItem.ElementPfx + 'C', 'text': 'C', 'helpText': 'Change elements to Carbon.', 'mnemonic': '' },\n    { 'id': ToolBankItem.ElementPfx + 'N', 'text': 'N', 'helpText': 'Change elements to Nitrogen.', 'mnemonic': '' },\n    { 'id': ToolBankItem.ElementPfx + 'O', 'text': 'O', 'helpText': 'Change elements to Oxygen.', 'mnemonic': '' },\n    { 'id': ToolBankItem.ElementPfx + 'S', 'text': 'S', 'helpText': 'Change elements to Sulfur.', 'mnemonic': '' },\n    { 'id': ToolBankItem.ElementPfx + 'P', 'text': 'P', 'helpText': 'Change elements to Phosphorus.', 'mnemonic': '' },\n    { 'id': ToolBankItem.ElementPfx + 'H', 'text': 'H', 'helpText': 'Change elements to Hydrogen.', 'mnemonic': '' },\n    { 'id': ToolBankItem.ElementPfx + 'F', 'text': 'F', 'helpText': 'Change elements to Fluorine.', 'mnemonic': '' },\n    { 'id': ToolBankItem.ElementPfx + 'Cl', 'text': 'Cl', 'helpText': 'Change elements to Chlorine.', 'mnemonic': '' },\n    { 'id': ToolBankItem.ElementPfx + 'Br', 'text': 'Br', 'helpText': 'Change elements to Bromine.', 'mnemonic': '' },\n    { 'id': ToolBankItem.ElementPfx + 'A', 'text': 'A', 'helpText': 'Pick other element.', 'mnemonic': '' }\n];\nclass ToolBank extends _ui_ButtonBank__WEBPACK_IMPORTED_MODULE_0__.ButtonBank {\n    constructor(owner) {\n        super();\n        this.owner = owner;\n    }\n    update() {\n        for (let btn of TOOLS_MAIN)\n            this.buttons.push(btn);\n        this.buttonView.setSelectedButton('arrow');\n    }\n    hitButton(id) {\n        this.buttonView.setSelectedButton(id);\n    }\n    claimKey(event) {\n        for (let item of TOOLS_MAIN) {\n            if (_ui_ButtonBank__WEBPACK_IMPORTED_MODULE_0__.ButtonBank.matchKey(event, item.mnemonic, item.key)) {\n                this.hitButton(item.id);\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/sketcher/ToolBank.ts?");

/***/ }),

/***/ "./src/ui/ButtonBank.ts":
/*!******************************!*\
  !*** ./src/ui/ButtonBank.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ButtonBank\": () => (/* binding */ ButtonBank)\n/* harmony export */ });\nclass ButtonBank {\n    constructor() {\n        this.isSubLevel = false;\n        this.buttons = [];\n    }\n    init() { }\n    claimKey(event) { return false; }\n    bankClosed() { }\n    static matchKey(event, mnemonic, key) {\n        if (mnemonic == null || mnemonic == '')\n            return false;\n        let mshift = false, mctrl = false, malt = false, mmeta = false, mkey = mnemonic;\n        while (true) {\n            if (mkey.startsWith('Shift+')) {\n                mshift = true;\n                mkey = mkey.substring(6);\n            }\n            else if (mkey.startsWith('Ctrl+')) {\n                mctrl = true;\n                mkey = mkey.substring(5);\n            }\n            else if (mkey.startsWith('Alt+')) {\n                malt = true;\n                mkey = mkey.substring(4);\n            }\n            else if (mkey.startsWith('Cmd+')) {\n                mmeta = true;\n                mkey = mkey.substring(4);\n            }\n            else\n                break;\n        }\n        if (mshift != event.shiftKey)\n            return false;\n        if (mctrl != event.ctrlKey)\n            return false;\n        if (malt != event.altKey)\n            return false;\n        if (mmeta != event.metaKey)\n            return false;\n        if (key)\n            mkey = key;\n        return mkey.toLowerCase() == event.key.toLowerCase();\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/ui/ButtonBank.ts?");

/***/ }),

/***/ "./src/ui/ButtonView.ts":
/*!******************************!*\
  !*** ./src/ui/ButtonView.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ButtonView\": () => (/* binding */ ButtonView),\n/* harmony export */   \"ButtonViewPosition\": () => (/* binding */ ButtonViewPosition)\n/* harmony export */ });\n/* harmony import */ var _gfx_FontData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../gfx/FontData */ \"./src/gfx/FontData.ts\");\n/* harmony import */ var _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../gfx/MetaVector */ \"./src/gfx/MetaVector.ts\");\n/* harmony import */ var _util_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/dom */ \"./src/util/dom.ts\");\n/* harmony import */ var _util_Theme__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Theme */ \"./src/util/Theme.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _Widget__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Widget */ \"./src/ui/Widget.ts\");\n\n\n\n\n\n\n\nvar ButtonViewPosition;\n(function (ButtonViewPosition) {\n    ButtonViewPosition[ButtonViewPosition[\"Left\"] = 0] = \"Left\";\n    ButtonViewPosition[ButtonViewPosition[\"Right\"] = 1] = \"Right\";\n    ButtonViewPosition[ButtonViewPosition[\"Top\"] = 2] = \"Top\";\n    ButtonViewPosition[ButtonViewPosition[\"Bottom\"] = 3] = \"Bottom\";\n    ButtonViewPosition[ButtonViewPosition[\"Centre\"] = 4] = \"Centre\";\n})(ButtonViewPosition || (ButtonViewPosition = {}));\nclass ButtonView extends _Widget__WEBPACK_IMPORTED_MODULE_6__.Widget {\n    constructor(position, parentX, parentY, parentWidth, parentHeight) {\n        super();\n        this.position = position;\n        this.parentX = parentX;\n        this.parentY = parentY;\n        this.parentWidth = parentWidth;\n        this.parentHeight = parentHeight;\n        this.idealSize = 50;\n        this.width = 0;\n        this.height = 0;\n        this.selectedButton = null;\n        this.highlightButton = null;\n        this.maxButtonColumns = 0;\n        this.maxButtonRows = 0;\n        this.border = 0x808080;\n        this.background = 0xFFFFFF;\n        this.buttonColNorm1 = 0x47D5D2;\n        this.buttonColNorm2 = 0x008FD1;\n        this.buttonColActv1 = 0x30FF69;\n        this.buttonColActv2 = 0x008650;\n        this.buttonColSel1 = 0xFFFFFF;\n        this.buttonColSel2 = 0xE0E0E0;\n        this.canvas = null;\n        this.stack = [];\n        this.display = [];\n        this.hasBigButtons = true;\n        this.prefabImgSize = 44;\n        this.gripHeight = 30;\n        this.gripWidth = 50;\n        this.isRaised = true;\n        this.outPadding = 2;\n        this.inPadding = 2;\n        this.x = 0;\n        this.y = 0;\n        this.isMacLike = false;\n        this.isMacLike = !!navigator.platform.match(/(Mac|iPhone|iPod|iPad)/i);\n    }\n    setParentSize(width, height) {\n        this.parentWidth = width;\n        this.parentHeight = height;\n    }\n    get topBank() {\n        return this.stack.length > 0 ? this.stack[this.stack.length - 1] : null;\n    }\n    get stackSize() { return this.stack.length; }\n    render(parent) {\n        super.render(parent);\n        this.contentDOM.css({ 'position': 'absolute', 'width': `${this.width}px`, 'height': `${this.height}px` });\n        this.contentDOM.addClass('no_selection');\n        this.layoutButtons();\n        let canvasStyle = 'position: absolute; left: 0; top: 0;';\n        canvasStyle += 'pointer-events: none;';\n        this.canvas = (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.newElement)(this.contentDOM.el, 'canvas', { 'width': this.width, 'height': this.height, 'style': canvasStyle });\n        this.canvas.style.width = this.width + 'px';\n        this.canvas.style.height = this.height + 'px';\n        this.applyOffset();\n        this.redraw();\n        this.contentDOM.onClick((event) => this.mouseClick(event));\n        this.contentDOM.onDblClick((event) => this.mouseDoubleClick(event));\n        this.contentDOM.onMouseDown((event) => { event.preventDefault(); this.mouseDown(event); });\n        this.contentDOM.onMouseUp((event) => this.mouseUp(event));\n        this.contentDOM.onMouseOver((event) => this.mouseOver(event));\n        this.contentDOM.onMouseLeave((event) => this.mouseOut(event));\n        this.contentDOM.onMouseMove((event) => this.mouseMove(event));\n    }\n    pushBank(bank) {\n        bank.buttonView = this;\n        bank.isSubLevel = this.stack.length > 0;\n        bank.init();\n        this.stack.push(bank);\n        if (this.canvas != null) {\n            this.layoutButtons();\n            this.replaceCanvas();\n            this.applyOffset();\n            this.redraw();\n        }\n    }\n    popBank() {\n        if (this.stack.length == 0)\n            return;\n        _util_Vec__WEBPACK_IMPORTED_MODULE_5__.Vec.last(this.stack).bankClosed();\n        this.stack.length--;\n        if (this.canvas != null) {\n            this.layoutButtons();\n            this.replaceCanvas();\n            this.applyOffset();\n            this.redraw();\n        }\n    }\n    refreshBank() {\n        if (this.canvas != null) {\n            this.layoutButtons();\n            this.replaceCanvas();\n            this.applyOffset();\n            this.redraw();\n        }\n    }\n    getSelectedButton() {\n        return this.selectedButton;\n    }\n    setSelectedButton(id) {\n        if (id != this.selectedButton) {\n            this.selectedButton = id;\n            this.redraw();\n        }\n    }\n    cycleSelected(dir) {\n        let sorted = this.display.filter((s) => s.id != '*');\n        sorted.sort((d1, d2) => (d1.y * 10000 + d1.x) - (d2.y * 10000 + d2.x));\n        let idx = 0, sz = sorted.length;\n        for (let n = 0; n < sz; n++)\n            if (sorted[n].id == this.selectedButton) {\n                idx = n;\n                break;\n            }\n        this.selectedButton = sorted[(idx + dir + sz) % sz].id;\n        this.redraw();\n    }\n    raiseBank() {\n        if (this.isRaised)\n            return;\n        this.isRaised = true;\n        if (this.contentDOM) {\n            this.layoutButtons();\n            this.replaceCanvas();\n            this.applyOffset();\n            this.redraw();\n        }\n    }\n    lowerBank() {\n        if (!this.isRaised)\n            return;\n        this.isRaised = false;\n        if (this.contentDOM) {\n            this.layoutButtons();\n            this.replaceCanvas();\n            this.applyOffset();\n            this.redraw();\n        }\n    }\n    getHasBigButtons() {\n        return this.hasBigButtons;\n    }\n    setHasBigButtons(flag) {\n        this.hasBigButtons = flag;\n        this.prefabImgSize = flag ? 44 : 36;\n        this.idealSize = flag ? 50 : 40;\n    }\n    withinOutline(x, y) {\n        let w = this.width, h = this.height;\n        if (x < 0 || x > w || y < 0 || y > h)\n            return false;\n        if (this.position == ButtonViewPosition.Centre || this.stack.length == 0)\n            return true;\n        if (this.position == ButtonViewPosition.Left) {\n            let my = 0.5 * h - 1, gw = this.gripHeight, hg = 0.5 * this.gripWidth;\n            return x < w - gw || (y > my - hg && y < my + hg);\n        }\n        else if (this.position == ButtonViewPosition.Right) {\n            let my = 0.5 * h - 1, gw = this.gripHeight, hg = 0.5 * this.gripWidth;\n            return x > gw || (y > my - hg && y < my + hg);\n        }\n        else if (this.position == ButtonViewPosition.Top) {\n            let mx = 0.5 * w - 1, gh = this.gripHeight, hg = 0.5 * this.gripWidth;\n            return y < h - gh || (x > mx - hg && x < mx + hg);\n        }\n        else if (this.position == ButtonViewPosition.Bottom) {\n            let mx = 0.5 * w - 1, gh = this.gripHeight, hg = 0.5 * this.gripWidth;\n            return y > gh || (x > mx - hg && x < mx + hg);\n        }\n        return true;\n    }\n    gripSize() {\n        return this.gripHeight;\n    }\n    sizeForButtons(nbtn) {\n        return this.idealSize * nbtn + this.inPadding * (nbtn - 1) + 2 * this.outPadding;\n    }\n    layoutButtons() {\n        if (this.contentDOM == null)\n            return;\n        let outPadding = this.outPadding, inPadding = this.inPadding;\n        this.removeDisplayButtons();\n        if (this.stack.length == 0) {\n            this.width = 10;\n            this.height = 10;\n            if (this.position == ButtonViewPosition.Left || this.position == ButtonViewPosition.Right)\n                this.height = this.parentHeight;\n            else if (this.position == ButtonViewPosition.Top || this.position == ButtonViewPosition.Bottom)\n                this.width = this.parentWidth;\n            return;\n        }\n        if (!this.isRaised) {\n            if (this.position == ButtonViewPosition.Left || this.position == ButtonViewPosition.Right) {\n                this.width = this.gripHeight;\n                this.height = this.gripWidth + 2 * outPadding;\n            }\n            else if (this.position == ButtonViewPosition.Top || this.position == ButtonViewPosition.Bottom) {\n                this.width = this.gripWidth + 2 * outPadding;\n                this.height = this.gripHeight;\n            }\n            this.addGripButton();\n            return;\n        }\n        let bank = this.stack[this.stack.length - 1];\n        bank.buttons = [];\n        bank.update();\n        let popWidth = 0, popHeight = 0;\n        if (this.stack.length == 1) { }\n        else if (this.position == ButtonViewPosition.Left || this.position == ButtonViewPosition.Right)\n            popHeight = this.gripHeight + inPadding;\n        else if (this.position == ButtonViewPosition.Top || this.position == ButtonViewPosition.Bottom)\n            popWidth = this.gripHeight + inPadding;\n        let bestLayout = null, bestScore = null;\n        if (this.position == ButtonViewPosition.Left || this.position == ButtonViewPosition.Right) {\n            let maxSlotHeight = Math.floor((this.parentHeight - 2 * outPadding - inPadding) / (this.idealSize + inPadding));\n            let minSlotHeight = Math.ceil(0.5 * maxSlotHeight);\n            for (let i = maxSlotHeight; i >= minSlotHeight; i--) {\n                let slotWidth = Math.ceil(bank.buttons.length / i);\n                for (let j = slotWidth; j <= slotWidth + 1; j++) {\n                    let layout = this.layoutMaxHeight(bank, i, j);\n                    let score = this.scoreLayout(layout) + 1 * layout[0].length;\n                    if (bestLayout == null || score < bestScore) {\n                        bestLayout = layout;\n                        bestScore = score;\n                    }\n                }\n            }\n        }\n        else if (this.position == ButtonViewPosition.Top || this.position == ButtonViewPosition.Bottom) {\n            let maxSlotWidth = Math.floor((this.parentWidth - 2 * outPadding - inPadding - popWidth) / (this.idealSize + inPadding));\n            let minSlotWidth = Math.ceil(0.5 * maxSlotWidth);\n            for (let n = maxSlotWidth; n >= minSlotWidth; n--) {\n                let layout = this.layoutMaxWidth(bank, n);\n                let score = this.scoreLayout(layout) + 1 * layout.length;\n                if (bestLayout == null || score < bestScore) {\n                    bestLayout = layout;\n                    bestScore = score;\n                }\n            }\n        }\n        else {\n        }\n        let ncols = bestLayout[0].length, nrows = bestLayout.length;\n        this.width = 2 * outPadding + inPadding + (this.idealSize + inPadding) * ncols + popWidth;\n        this.height = 2 * outPadding + inPadding + (this.idealSize + inPadding) * nrows + popHeight;\n        if (this.position == ButtonViewPosition.Left || this.position == ButtonViewPosition.Right)\n            this.width += this.gripHeight;\n        else if (this.position == ButtonViewPosition.Top || this.position == ButtonViewPosition.Bottom)\n            this.height += this.gripHeight;\n        this.addGripButton();\n        if (popWidth > 0 || popHeight > 0) {\n            let d = {\n                'id': '!',\n                'x': outPadding + inPadding,\n                'y': outPadding + inPadding,\n                'width': popWidth - inPadding,\n                'height': popHeight - inPadding\n            };\n            if (this.position == ButtonViewPosition.Right)\n                d.x += this.gripHeight;\n            else if (this.position == ButtonViewPosition.Bottom)\n                d.y += this.gripHeight;\n            if (popWidth == 0)\n                d.width = ncols * this.idealSize + inPadding * (ncols - 1);\n            if (popHeight == 0)\n                d.height = nrows * this.idealSize + inPadding * (nrows - 1);\n            this.display.push(d);\n        }\n        for (let y = 0; y < nrows; y++)\n            for (let x = 0; x < ncols; x++) {\n                for (let n = 0; n < bank.buttons.length; n++)\n                    if (bestLayout[y][x] == bank.buttons[n].id) {\n                        let b = bank.buttons[n], d = { 'id': b.id };\n                        d.x = outPadding + inPadding + popWidth + (this.idealSize + inPadding) * x;\n                        d.y = outPadding + inPadding + popHeight + (this.idealSize + inPadding) * y;\n                        if (this.position == ButtonViewPosition.Right)\n                            d.x += this.gripHeight;\n                        else if (this.position == ButtonViewPosition.Bottom)\n                            d.y += this.gripHeight;\n                        d.width = this.idealSize;\n                        d.height = this.idealSize;\n                        this.display.push(d);\n                    }\n            }\n    }\n    addGripButton() {\n        if (this.position == ButtonViewPosition.Centre)\n            return;\n        let d = { 'id': '*' }, spc = 3;\n        if (this.position == ButtonViewPosition.Left) {\n            d.width = this.gripHeight - spc;\n            d.height = this.gripWidth - 2 * spc;\n            d.x = this.width - d.width - spc - 1;\n            d.y = 0.5 * (this.height - d.height);\n        }\n        else if (this.position == ButtonViewPosition.Right) {\n            d.width = this.gripHeight - spc;\n            d.height = this.gripWidth - 2 * spc;\n            d.x = spc + 1;\n            d.y = 0.5 * (this.height - d.height);\n        }\n        else if (this.position == ButtonViewPosition.Top) {\n            d.width = this.gripWidth - 2 * spc;\n            d.height = this.gripHeight - spc;\n            d.x = 0.5 * (this.width - d.width);\n            d.y = this.height - d.height - spc - 1;\n        }\n        else if (this.position == ButtonViewPosition.Bottom) {\n            d.width = this.gripWidth - 2 * spc;\n            d.height = this.gripHeight - spc;\n            d.x = 0.5 * (this.width - d.width);\n            d.y = spc + 1;\n        }\n        this.display.push(d);\n    }\n    replaceCanvas() {\n        this.contentDOM.empty();\n        for (let n = 0; n < this.display.length; n++) {\n            this.display[n].imgDOM = null;\n            this.display[n].helpSpan = null;\n        }\n        let canvasStyle = 'position: absolute; left: 0; top: 0;';\n        canvasStyle += 'pointer-events: none;';\n        this.canvas = (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.newElement)(this.contentDOM.el, 'canvas', { 'width': this.width, 'height': this.height, 'style': canvasStyle });\n    }\n    removeDisplayButtons() {\n        this.contentDOM.empty();\n        this.display = [];\n    }\n    applyOffset() {\n        let x, y;\n        if (this.position == ButtonViewPosition.Left) {\n            x = 0;\n            y = 0.5 * (this.parentHeight - this.height);\n        }\n        else if (this.position == ButtonViewPosition.Right) {\n            x = this.parentWidth - this.width;\n            y = 0.5 * (this.parentHeight - this.height);\n        }\n        else if (this.position == ButtonViewPosition.Top) {\n            x = 0.5 * (this.parentWidth - this.width);\n            y = 0;\n        }\n        else if (this.position == ButtonViewPosition.Bottom) {\n            x = 0.5 * (this.parentWidth - this.width);\n            y = this.parentHeight - this.height;\n        }\n        else {\n            x = 0.5 * (this.parentWidth - this.width);\n            y = 0.5 * (this.parentHeight - this.height);\n        }\n        this.x = this.parentX + x;\n        this.y = this.parentY + y;\n        this.contentDOM.css({ 'position': 'absolute' });\n        (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.setBoundaryPixels)(this.contentDOM, this.x, this.y, this.width, this.height);\n    }\n    redraw() {\n        if (!this.contentDOM || !this.canvas)\n            return;\n        let density = (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.pixelDensity)();\n        this.canvas.width = this.width * density;\n        this.canvas.height = this.height * density;\n        this.canvas.style.width = this.width + 'px';\n        this.canvas.style.height = this.height + 'px';\n        let ctx = this.canvas.getContext('2d');\n        ctx.save();\n        ctx.scale(density, density);\n        ctx.clearRect(0, 0, this.width, this.height);\n        let path = this.traceOutline();\n        ctx.fillStyle = (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.colourCanvas)(this.background);\n        ctx.fill(path);\n        ctx.strokeStyle = (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.colourCanvas)(this.border);\n        ctx.lineWidth = 1;\n        ctx.stroke(path);\n        let bank = this.stack.length > 0 ? this.stack[this.stack.length - 1] : null;\n        this.contentDOM.css({ 'width': this.width + 'px', 'height': this.height + 'px' });\n        for (let n = 0; n < this.display.length; n++) {\n            const d = this.display[n], b = this.buttonFromID(d.id);\n            let col1, col2;\n            if (this.highlightButton != null && d.id == this.highlightButton) {\n                col1 = this.buttonColActv1;\n                col2 = this.buttonColActv2;\n            }\n            else if (this.selectedButton != null && d.id == this.selectedButton) {\n                col1 = this.buttonColSel1;\n                col2 = this.buttonColSel2;\n            }\n            else {\n                col1 = this.buttonColNorm1;\n                col2 = this.buttonColNorm2;\n            }\n            ctx.save();\n            path = (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.pathRoundedRect)(d.x + 0.5, d.y + 0.5, d.x + d.width - 1, d.y + d.height - 1, 5);\n            if (col2 != null) {\n                let grad = ctx.createLinearGradient(d.x, d.y, d.x + d.width, d.y + d.height);\n                grad.addColorStop(0, (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.colourCanvas)(col1));\n                grad.addColorStop(1, (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.colourCanvas)(col2));\n                ctx.fillStyle = grad;\n            }\n            else\n                ctx.fillStyle = (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.colourCanvas)(col1);\n            ctx.fill(path);\n            ctx.strokeStyle = (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.colourCanvas)(this.border);\n            ctx.lineWidth = 0.5;\n            ctx.stroke(path);\n            ctx.restore();\n            if (d.imgDOM != null) {\n                d.imgDOM.remove();\n                d.imgDOM = null;\n            }\n            if (b != null) {\n                if (d.helpSpan == null) {\n                    d.helpSpan = (0,_util_dom__WEBPACK_IMPORTED_MODULE_2__.dom)('<span style=\"position: absolute;\"/>').appendTo(this.contentDOM);\n                    let txt = b.helpText;\n                    if (b.mnemonic) {\n                        while (txt.endsWith('.'))\n                            txt = txt.substring(0, txt.length - 1);\n                        let keyText = b.mnemonic;\n                        let match = keyText.match(/^(.*)CmdOrCtrl(.*)$/);\n                        if (match)\n                            keyText = match[1] + (this.isMacLike ? 'Cmd' : 'Ctrl') + match[2];\n                        txt += ' [' + keyText + ']';\n                    }\n                    this.addTooltip(d.helpSpan.el.outerHTML, txt);\n                }\n                (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.setBoundaryPixels)(d.helpSpan, d.x, d.y, d.width, d.height);\n            }\n            if (b == null) { }\n            else if (b.imageFN != null && d.imgDOM == null) {\n                d.imgDOM = (0,_util_dom__WEBPACK_IMPORTED_MODULE_2__.dom)('<img/>').appendTo(this.contentDOM).css({ 'position': 'absolute', 'pointer-events': 'none' });\n                d.imgDOM.setAttr('src', _util_Theme__WEBPACK_IMPORTED_MODULE_3__.Theme.RESOURCE_URL + '/img/actions/' + b.imageFN + '.svg');\n                const sz = this.prefabImgSize;\n                const bx = d.x + Math.floor(0.5 * (d.width - sz));\n                const by = d.y + Math.floor(0.5 * (d.height - sz));\n                (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.setBoundaryPixels)(d.imgDOM, bx, by, sz, sz);\n            }\n            else if (b.metavec != null) {\n                let draw = b.metavec instanceof _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_1__.MetaVector ? b.metavec : new _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_1__.MetaVector(b.metavec);\n                draw.offsetX = d.x + Math.floor(0.5 * (d.width - draw.width));\n                draw.offsetY = d.y + Math.floor(0.5 * (d.height - draw.height));\n                draw.renderContext(ctx);\n            }\n            else if (b.text != null) {\n                let sz = this.idealSize;\n                let draw = new _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_1__.MetaVector({ 'size': [sz, sz] });\n                let fsz = sz * 0.6;\n                let wad = _gfx_FontData__WEBPACK_IMPORTED_MODULE_0__.FontData.main.measureText(b.text, fsz);\n                if (wad[1] + wad[2] > sz) {\n                    fsz *= sz / (wad[1] + wad[2]);\n                    wad = _gfx_FontData__WEBPACK_IMPORTED_MODULE_0__.FontData.main.measureText(b.text, fsz);\n                }\n                if (wad[0] > sz) {\n                    fsz *= sz / wad[0];\n                    wad = _gfx_FontData__WEBPACK_IMPORTED_MODULE_0__.FontData.main.measureText(b.text, fsz);\n                }\n                let x = 0.5 * (sz - wad[0]), y = 0.5 * (sz + wad[1]);\n                draw.drawText(x - 1, y, b.text, fsz, 0x000000);\n                draw.drawText(x + 1, y, b.text, fsz, 0x000000);\n                draw.drawText(x, y - 1, b.text, fsz, 0x000000);\n                draw.drawText(x, y + 1, b.text, fsz, 0x000000);\n                draw.drawText(x, y, b.text, fsz, 0xFFFFFF);\n                draw.offsetX = d.x + Math.floor(0.5 * (d.width - draw.width));\n                draw.offsetY = d.y + Math.floor(0.5 * (d.height - draw.height));\n                draw.renderContext(ctx);\n            }\n            if (b != null && b.isSubMenu) {\n                ctx.save();\n                let sx = d.x + d.width - 3, sy = d.y + d.height - 3;\n                ctx.beginPath();\n                ctx.moveTo(sx, sy);\n                ctx.lineTo(sx - 6, sy);\n                ctx.lineTo(sx, sy - 6);\n                ctx.closePath();\n                ctx.fillStyle = 'black';\n                ctx.fill();\n                ctx.restore();\n            }\n            if (d.id == '*') {\n                ctx.save();\n                path = new Path2D();\n                let px, py, flip = this.isRaised;\n                if (this.position == ButtonViewPosition.Left || this.position == ButtonViewPosition.Right) {\n                    px = [0.2, 0.7, 0.7];\n                    py = [0.5, 0.3, 0.7];\n                    if (this.position == ButtonViewPosition.Left)\n                        flip = !flip;\n                }\n                else if (this.position == ButtonViewPosition.Top || this.position == ButtonViewPosition.Bottom) {\n                    px = [0.5, 0.3, 0.7];\n                    py = [0.2, 0.7, 0.7];\n                    if (this.position == ButtonViewPosition.Top)\n                        flip = !flip;\n                }\n                if (flip) {\n                    px = [1 - px[0], 1 - px[1], 1 - px[2]];\n                    py = [1 - py[0], 1 - py[1], 1 - py[2]];\n                }\n                path.moveTo(d.x + d.width * px[0], d.y + d.height * py[0]);\n                path.lineTo(d.x + d.width * px[1], d.y + d.height * py[1]);\n                path.lineTo(d.x + d.width * px[2], d.y + d.height * py[2]);\n                path.closePath();\n                ctx.fillStyle = 'white';\n                ctx.strokeStyle = 'black';\n                ctx.lineWidth = 0;\n                ctx.fill(path);\n                ctx.stroke(path);\n                ctx.restore();\n            }\n            else if (d.id == '!') {\n                ctx.save();\n                let path1 = new Path2D(), path2 = new Path2D();\n                let inset = 5;\n                let w = d.width - inset * 2, h = d.height - inset * 2;\n                for (let z = 5; z < w + h - 1; z += 12) {\n                    let x1 = 0, y1 = z, x2 = z, y2 = 0;\n                    if (y1 > h) {\n                        let delta = y1 - h;\n                        x1 += delta;\n                        y1 -= delta;\n                    }\n                    if (x2 > w) {\n                        let delta = x2 - w;\n                        x2 -= delta;\n                        y2 += delta;\n                    }\n                    path1.moveTo(d.x + inset + x1, d.y + inset + y1);\n                    path1.lineTo(d.x + inset + x2, d.y + inset + y2);\n                    path2.moveTo(d.x + inset + x1 + 1, d.y + inset + y1);\n                    path2.lineTo(d.x + inset + x2 + 1, d.y + inset + y2);\n                }\n                ctx.lineWidth = 1;\n                ctx.strokeStyle = '#404040';\n                ctx.stroke(path1);\n                ctx.strokeStyle = 'white';\n                ctx.stroke(path2);\n                ctx.restore();\n            }\n        }\n        ctx.restore();\n    }\n    delayedRedraw() {\n        window.setTimeout(() => this.redraw(), 100);\n    }\n    buttonFromID(id) {\n        let bank = this.stack[this.stack.length - 1];\n        for (let n = 0; n < bank.buttons.length; n++)\n            if (bank.buttons[n].id == id)\n                return bank.buttons[n];\n        return null;\n    }\n    displayFromID(id) {\n        for (let n = 0; n < this.display.length; n++)\n            if (this.display[n].id == id)\n                return this.display[n];\n        return null;\n    }\n    traceOutline() {\n        let w = this.width, h = this.height, uw = w - 1, uh = h - 1, r = 8;\n        if (this.position == ButtonViewPosition.Centre || this.stack.length == 0)\n            return (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.pathRoundedRect)(0.5, 0.5, w - 0.5, h - 0.5, r);\n        let path = new Path2D();\n        if (this.position == ButtonViewPosition.Left) {\n            let my = 0.5 * h - 1, gw = this.gripHeight, hg = 0.5 * this.gripWidth;\n            path.moveTo(0.5, 0.5);\n            path.lineTo(0.5 + uw - gw - r, 0.5);\n            path.bezierCurveTo(0.5 + uw - gw, 0.5, 0.5 + uw - gw, 0.5, 0.5 + uw - gw, 0.5 + r);\n            path.lineTo(0.5 + uw - gw, 0.5 + my - hg);\n            path.lineTo(0.5 + uw - r, 0.5 + my - hg);\n            path.bezierCurveTo(0.5 + uw, 0.5 + my - hg, 0.5 + uw, 0.5 + my - hg, 0.5 + uw, 0.5 + my - hg + r);\n            path.lineTo(0.5 + uw, 0.5 + my + hg - r);\n            path.bezierCurveTo(0.5 + uw, 0.5 + my + hg, 0.5 + uw, 0.5 + my + hg, 0.5 + uw - r, 0.5 + my + hg);\n            path.lineTo(0.5 + uw - gw, 0.5 + my + hg);\n            path.lineTo(0.5 + uw - gw, 0.5 + uh - r);\n            path.bezierCurveTo(0.5 + uw - gw, 0.5 + uh, 0.5 + uw - gw, 0.5 + uh, 0.5 + uw - gw - r, 0.5 + uh);\n            path.lineTo(0.5, 0.5 + uh);\n        }\n        else if (this.position == ButtonViewPosition.Right) {\n            let my = 0.5 * h - 1, gw = this.gripHeight, hg = 0.5 * this.gripWidth;\n            path.moveTo(w - 0.5, 0.5);\n            path.lineTo(w - (0.5 + uw - gw - r), 0.5);\n            path.bezierCurveTo(w - (0.5 + uw - gw), 0.5, w - (0.5 + uw - gw), 0.5, w - (0.5 + uw - gw), 0.5 + r);\n            path.lineTo(w - (0.5 + uw - gw), 0.5 + my - hg);\n            path.lineTo(w - (0.5 + uw - r), 0.5 + my - hg);\n            path.bezierCurveTo(w - (0.5 + uw), 0.5 + my - hg, w - (0.5 + uw), 0.5 + my - hg, w - (0.5 + uw), 0.5 + my - hg + r);\n            path.lineTo(w - (0.5 + uw), 0.5 + my + hg - r);\n            path.bezierCurveTo(w - (0.5 + uw), 0.5 + my + hg, w - (0.5 + uw), 0.5 + my + hg, w - (0.5 + uw - r), 0.5 + my + hg);\n            path.lineTo(w - (0.5 + uw - gw), 0.5 + my + hg);\n            path.lineTo(w - (0.5 + uw - gw), 0.5 + uh - r);\n            path.bezierCurveTo(w - (0.5 + uw - gw), 0.5 + uh, w - (0.5 + uw - gw), 0.5 + uh, w - (0.5 + uw - gw - r), 0.5 + uh);\n            path.lineTo(w - 0.5, 0.5 + uh);\n        }\n        else if (this.position == ButtonViewPosition.Top) {\n            let mx = 0.5 * w - 1, gh = this.gripHeight, hg = 0.5 * this.gripWidth;\n            path.moveTo(0.5, h - (0.5 + uh));\n            path.lineTo(0.5, h - (0.5 + gh + r));\n            path.bezierCurveTo(0.5, h - (0.5 + gh), 0.5, h - (0.5 + gh), 0.5 + r, h - (0.5 + gh));\n            path.lineTo(0.5 + mx - hg, h - (0.5 + gh));\n            path.lineTo(0.5 + mx - hg, h - (0.5 + r));\n            path.bezierCurveTo(0.5 + mx - hg, h - 0.5, 0.5 + mx - hg, h - 0.5, 0.5 + mx - hg + r, h - 0.5);\n            path.lineTo(0.5 + mx + hg - r, h - 0.5);\n            path.bezierCurveTo(0.5 + mx + hg, h - 0.5, 0.5 + mx + hg, h - 0.5, 0.5 + mx + hg, h - (0.5 + r));\n            path.lineTo(0.5 + mx + hg, h - (0.5 + gh));\n            path.lineTo(0.5 + uw - r, h - (0.5 + gh));\n            path.bezierCurveTo(0.5 + uw, h - (0.5 + gh), 0.5 + uw, h - (0.5 + gh), 0.5 + uw, h - (0.5 + gh + r));\n            path.lineTo(0.5 + uw, h - (0.5 + uh));\n        }\n        else if (this.position == ButtonViewPosition.Bottom) {\n            let mx = 0.5 * w - 1, gh = this.gripHeight, hg = 0.5 * this.gripWidth;\n            path.moveTo(0.5, 0.5 + uh);\n            path.lineTo(0.5, 0.5 + gh + r);\n            path.bezierCurveTo(0.5, 0.5 + gh, 0.5, 0.5 + gh, 0.5 + r, 0.5 + gh);\n            path.lineTo(0.5 + mx - hg, 0.5 + gh);\n            path.lineTo(0.5 + mx - hg, 0.5 + r);\n            path.bezierCurveTo(0.5 + mx - hg, 0.5, 0.5 + mx - hg, 0.5, 0.5 + mx - hg + r, 0.5);\n            path.lineTo(0.5 + mx + hg - r, 0.5);\n            path.bezierCurveTo(0.5 + mx + hg, 0.5, 0.5 + mx + hg, 0.5, 0.5 + mx + hg, 0.5 + r);\n            path.lineTo(0.5 + mx + hg, 0.5 + gh);\n            path.lineTo(0.5 + uw - r, 0.5 + gh);\n            path.bezierCurveTo(0.5 + uw, 0.5 + gh, 0.5 + uw, 0.5 + gh, 0.5 + uw, 0.5 + gh + r);\n            path.lineTo(0.5 + uw, 0.5 + uh);\n        }\n        return path;\n    }\n    layoutMaxWidth(bank, slotWidth) {\n        if (bank.buttons.length == 0)\n            return [[null]];\n        let bx = new Array(bank.buttons.length), by = new Array(bank.buttons.length);\n        let x = 0, y = 0, w = 0, h = 0;\n        for (let n = 0; n < bank.buttons.length; n++) {\n            w = Math.max(x + 1, w);\n            h = Math.max(y + 1, h);\n            bx[n] = x;\n            by[n] = y;\n            x++;\n            if (x >= slotWidth) {\n                x = 0;\n                y++;\n            }\n        }\n        let slot = new Array(h);\n        for (let n = 0; n < h; n++)\n            slot[n] = new Array(w);\n        for (let n = 0; n < bank.buttons.length; n++) {\n            slot[by[n]][bx[n]] = bank.buttons[n].id;\n        }\n        return slot;\n    }\n    layoutMaxHeight(bank, slotHeight, slotWidth) {\n        if (bank.buttons.length == 0)\n            return [[null]];\n        let bx = new Array(bank.buttons.length), by = new Array(bank.buttons.length);\n        let x = 0, y = 0, w = 0, h = 0;\n        for (let n = 0; n < bank.buttons.length; n++) {\n            w = Math.max(x + 1, w);\n            h = Math.max(y + 1, h);\n            bx[n] = x;\n            by[n] = y;\n            x++;\n            if (x >= slotWidth) {\n                x = 0;\n                y++;\n            }\n        }\n        let slot = new Array(h);\n        for (let n = 0; n < h; n++)\n            slot[n] = new Array(w);\n        for (let n = 0; n < bank.buttons.length; n++) {\n            slot[by[n]][bx[n]] = bank.buttons[n].id;\n        }\n        return slot;\n    }\n    scoreLayout(slots) {\n        let score = 0;\n        let nrows = slots.length, ncols = slots[0].length;\n        for (let y = 0; y < nrows; y++)\n            for (let x = 0; x < ncols; x++) {\n                if (slots[y][x] == null)\n                    score++;\n            }\n        if (this.maxButtonRows > 0 && nrows > this.maxButtonRows)\n            score += (nrows - this.maxButtonRows) * 100;\n        if (this.maxButtonColumns > 0 && ncols > this.maxButtonColumns)\n            score += (ncols - this.maxButtonColumns) * 100;\n        return score;\n    }\n    pickButtonIndex(x, y) {\n        for (let n = 0; n < this.display.length; n++) {\n            let d = this.display[n];\n            if (x >= d.x && y >= d.y && x < d.x + d.width && y < d.y + d.height)\n                return n;\n        }\n        return -1;\n    }\n    pickButtonID(x, y) {\n        let idx = this.pickButtonIndex(x, y);\n        if (idx < 0)\n            return undefined;\n        return this.display[idx].id;\n    }\n    triggerButton(id) {\n        if (id == '*') {\n            if (this.isRaised)\n                this.lowerBank();\n            else\n                this.raiseBank();\n            return;\n        }\n        else if (id == '!') {\n            this.popBank();\n            return;\n        }\n        let bank = this.stack[this.stack.length - 1];\n        bank.hitButton(id);\n    }\n    mouseClick(event) {\n    }\n    mouseDoubleClick(event) {\n        event.stopImmediatePropagation();\n    }\n    mouseDown(event) {\n        this.contentDOM.parent().grabFocus();\n        let xy = (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.eventCoords)(event, this.contentDOM);\n        if (!this.withinOutline(xy[0], xy[1]))\n            return;\n        let id = this.pickButtonID(xy[0], xy[1]);\n        if (id != this.highlightButton) {\n            this.highlightButton = id;\n            this.redraw();\n        }\n        event.stopPropagation();\n    }\n    mouseUp(event) {\n        let xy = (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.eventCoords)(event, this.contentDOM);\n        if (!this.withinOutline(xy[0], xy[1]))\n            return;\n        let id = this.pickButtonID(xy[0], xy[1]);\n        if (id != null && this.highlightButton == id) {\n            this.highlightButton = undefined;\n            this.triggerButton(id);\n            this.delayedRedraw();\n        }\n        else {\n            this.highlightButton = undefined;\n            this.delayedRedraw();\n        }\n        event.stopPropagation();\n    }\n    mouseOver(event) {\n        let xy = (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.eventCoords)(event, this.contentDOM);\n        if (!this.withinOutline(xy[0], xy[1]))\n            return;\n        event.stopPropagation();\n    }\n    mouseOut(event) {\n        let xy = (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.eventCoords)(event, this.contentDOM);\n        if (!this.withinOutline(xy[0], xy[1])) {\n            if (this.highlightButton != null) {\n                this.highlightButton = null;\n                this.delayedRedraw();\n            }\n            return;\n        }\n        if (this.highlightButton != null) {\n            let xy = (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.eventCoords)(event, this.contentDOM);\n            let id = this.pickButtonID(xy[0], xy[1]);\n            if (id != this.highlightButton) {\n                this.highlightButton = null;\n                this.delayedRedraw();\n            }\n        }\n        event.stopPropagation();\n    }\n    mouseMove(event) {\n        let xy = (0,_util_util__WEBPACK_IMPORTED_MODULE_4__.eventCoords)(event, this.contentDOM);\n        if (!this.withinOutline(xy[0], xy[1]))\n            return;\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/ui/ButtonView.ts?");

/***/ }),

/***/ "./src/ui/ClipboardProxy.ts":
/*!**********************************!*\
  !*** ./src/ui/ClipboardProxy.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ClipboardProxy\": () => (/* binding */ ClipboardProxy),\n/* harmony export */   \"ClipboardProxyHandler\": () => (/* binding */ ClipboardProxyHandler),\n/* harmony export */   \"ClipboardProxyWeb\": () => (/* binding */ ClipboardProxyWeb)\n/* harmony export */ });\n/* harmony import */ var _util_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/dom */ \"./src/util/dom.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n\n\nclass ClipboardProxyHandler {\n    copyEvent(andCut, proxy) { return false; }\n    pasteEvent(proxy) { return false; }\n}\nclass ClipboardProxy {\n    constructor() {\n        this.handlers = [new ClipboardProxyHandler()];\n    }\n    pushHandler(handler) {\n        this.handlers.push(handler);\n    }\n    popHandler() {\n        this.handlers.pop();\n    }\n    currentHandler() {\n        return _util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.last(this.handlers);\n    }\n    triggerCopy(andCut) {\n        if (this.currentHandler().copyEvent(andCut, this))\n            return;\n        document.execCommand(andCut ? 'cut' : 'copy');\n    }\n    triggerPaste() {\n        if (this.currentHandler().pasteEvent(this))\n            return;\n        document.execCommand('paste');\n    }\n    getString() { return null; }\n    setString(str) { }\n    setImage(blob) { }\n    canSetHTML() { return false; }\n    setHTML(html) { }\n    canAlwaysGet() { return false; }\n    downloadString(str, fn) { }\n}\nclass ClipboardProxyWeb extends ClipboardProxy {\n    constructor() {\n        super();\n        this.lastContent = null;\n        this.fakeTextArea = null;\n        this.busy = false;\n        document.addEventListener('copy', (event) => {\n            if (this.busy)\n                return null;\n            if (this.currentHandler().copyEvent(false, this)) {\n                event.preventDefault();\n                return false;\n            }\n        });\n        document.addEventListener('cut', (event) => {\n            if (this.busy)\n                return null;\n            if (this.currentHandler().copyEvent(true, this)) {\n                event.preventDefault();\n                return false;\n            }\n        });\n        document.addEventListener('paste', (event) => {\n            let wnd = window;\n            this.lastContent = null;\n            if (wnd.clipboardData && wnd.clipboardData.getData)\n                this.lastContent = wnd.clipboardData.getData('Text');\n            else if (event.clipboardData && event.clipboardData.getData)\n                this.lastContent = event.clipboardData.getData('text/plain');\n            let consumed = this.currentHandler().pasteEvent(this);\n            this.lastContent = null;\n            if (consumed) {\n                event.preventDefault();\n                return false;\n            }\n            return true;\n        });\n    }\n    getString() {\n        return this.lastContent;\n    }\n    setString(str) {\n        let fallbackWorkaround = () => {\n            if (this.fakeTextArea == null) {\n                this.fakeTextArea = document.createElement('textarea');\n                this.fakeTextArea.style.fontSize = '12pt';\n                this.fakeTextArea.style.border = '0';\n                this.fakeTextArea.style.padding = '0';\n                this.fakeTextArea.style.margin = '0';\n                this.fakeTextArea.style.position = 'fixed';\n                this.fakeTextArea.style['left'] = '-9999px';\n                this.fakeTextArea.style.top = (window.pageYOffset || document.documentElement.scrollTop) + 'px';\n                this.fakeTextArea.setAttribute('readonly', '');\n                document.body.appendChild(this.fakeTextArea);\n            }\n            this.fakeTextArea.value = str;\n            this.fakeTextArea.select();\n            this.busy = true;\n            document.execCommand('copy');\n            this.busy = false;\n        };\n        if (navigator.clipboard) {\n            navigator.clipboard.writeText(str).then(() => { }, fallbackWorkaround);\n        }\n        else\n            fallbackWorkaround();\n    }\n    setImage(blob) {\n        this.busy = true;\n        let rdr = new FileReader();\n        rdr.onload = (event) => {\n            let dataURL = event.target.result.toString();\n            if (!dataURL)\n                return;\n            let img = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<img/>').attr({ 'src': dataURL });\n            img.el.addEventListener('load', () => {\n                let r = document.createRange();\n                r.setStartBefore(img.el);\n                r.setEndAfter(img.el);\n                r.selectNode(img.el);\n                let sel = window.getSelection();\n                sel.addRange(r);\n                document.execCommand('copy');\n                img.remove();\n                this.busy = false;\n            });\n            img.appendTo(document.body);\n        };\n        rdr.readAsDataURL(blob);\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/ui/ClipboardProxy.ts?");

/***/ }),

/***/ "./src/ui/EmbedChemistry.ts":
/*!**********************************!*\
  !*** ./src/ui/EmbedChemistry.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EmbedChemistry\": () => (/* binding */ EmbedChemistry)\n/* harmony export */ });\n/* harmony import */ var _gfx_Rendering__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../gfx/Rendering */ \"./src/gfx/Rendering.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _Widget__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Widget */ \"./src/ui/Widget.ts\");\n\n\n\nclass EmbedChemistry extends _Widget__WEBPACK_IMPORTED_MODULE_2__.Widget {\n    constructor() {\n        super();\n        this.padding = 4;\n        this.borderCol = 0xD0D0D0;\n        this.borderRadius = 8;\n        this.backgroundCol1 = 0xFFFFFF;\n        this.backgroundCol2 = 0xF0F0F0;\n        this.policy = _gfx_Rendering__WEBPACK_IMPORTED_MODULE_0__.RenderPolicy.defaultColourOnWhite();\n    }\n    clearBackground() { this.backgroundCol1 = null; this.backgroundCol2 = null; }\n    setBackground(bg) { this.backgroundCol1 = bg; this.backgroundCol2 = null; }\n    setBackgroundGradient(bg1, bg2) { this.backgroundCol1 = bg1; this.backgroundCol2 = bg2; }\n    render(parent) {\n        super.render(parent);\n        let content = this.contentDOM;\n        if (this.borderCol != null)\n            content.setCSS('border', '1px solid ' + (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.colourCanvas)(this.borderCol));\n        if (this.borderRadius > 0)\n            content.setCSS('border-radius', this.borderRadius + 'px');\n        let bg1 = this.backgroundCol1, bg2 = this.backgroundCol2;\n        if (bg1 != null && bg2 != null) {\n            let cols = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.colourCanvas)(bg1) + ',' + (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.colourCanvas)(bg2);\n            content.setCSS('background-image', 'linear-gradient(to bottom right, ' + cols + ')');\n        }\n        else if (bg1 != null) {\n            content.setCSS('background-color', (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.colourCanvas)(bg1));\n        }\n        content.css({ 'padding': this.padding + 'px', 'margin': '0' });\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/ui/EmbedChemistry.ts?");

/***/ }),

/***/ "./src/ui/EmbedCollection.ts":
/*!***********************************!*\
  !*** ./src/ui/EmbedCollection.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EmbedCollection\": () => (/* binding */ EmbedCollection)\n/* harmony export */ });\n/* harmony import */ var _aspect_Aspect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../aspect/Aspect */ \"./src/aspect/Aspect.ts\");\n/* harmony import */ var _aspect_AspectList__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../aspect/AspectList */ \"./src/aspect/AspectList.ts\");\n/* harmony import */ var _data_DataSheetStream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data/DataSheetStream */ \"./src/data/DataSheetStream.ts\");\n/* harmony import */ var _data_MDLReader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../data/MDLReader */ \"./src/data/MDLReader.ts\");\n/* harmony import */ var _gfx_ArrangeMeasurement__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../gfx/ArrangeMeasurement */ \"./src/gfx/ArrangeMeasurement.ts\");\n/* harmony import */ var _gfx_ArrangeMolecule__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../gfx/ArrangeMolecule */ \"./src/gfx/ArrangeMolecule.ts\");\n/* harmony import */ var _gfx_DrawMolecule__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../gfx/DrawMolecule */ \"./src/gfx/DrawMolecule.ts\");\n/* harmony import */ var _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../gfx/MetaVector */ \"./src/gfx/MetaVector.ts\");\n/* harmony import */ var _gfx_Rendering__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../gfx/Rendering */ \"./src/gfx/Rendering.ts\");\n/* harmony import */ var _util_dom__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../util/dom */ \"./src/util/dom.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _util_Vec__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _EmbedChemistry__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./EmbedChemistry */ \"./src/ui/EmbedChemistry.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass EmbedCollection extends _EmbedChemistry__WEBPACK_IMPORTED_MODULE_12__.EmbedChemistry {\n    constructor(datastr, options) {\n        super();\n        this.datastr = datastr;\n        this.ds = null;\n        this.failmsg = '';\n        this.tight = false;\n        if (!options)\n            options = {};\n        if (options.encoding == 'base64')\n            datastr = (0,_util_util__WEBPACK_IMPORTED_MODULE_10__.fromUTF8)(atob(datastr.trim()));\n        let ds = null, name = options.name;\n        if (options.format == 'datasheet' || options.format == 'chemical/x-datasheet') {\n            ds = _data_DataSheetStream__WEBPACK_IMPORTED_MODULE_2__.DataSheetStream.readXML(datastr);\n        }\n        else if (options.format == 'sdfile' || options.format == 'chemical/x-mdl-sdfile') {\n            try {\n                let mdl = new _data_MDLReader__WEBPACK_IMPORTED_MODULE_3__.MDLSDFReader(datastr);\n                ds = mdl.parse();\n            }\n            catch (ex) {\n                this.failmsg = ex;\n            }\n        }\n        else {\n            try {\n                ds = _data_DataSheetStream__WEBPACK_IMPORTED_MODULE_2__.DataSheetStream.readXML(datastr);\n            }\n            catch (ex) { }\n            if (ds == null) {\n                try {\n                    let mdl = new _data_MDLReader__WEBPACK_IMPORTED_MODULE_3__.MDLSDFReader(datastr);\n                    ds = mdl.parse();\n                }\n                catch (ex) { }\n            }\n        }\n        if (ds == null)\n            return;\n        if (options.padding)\n            this.padding = options.padding;\n        if (options.background == 'transparent')\n            this.clearBackground();\n        else if (options.background) {\n            let bg = options.background, comma = bg.indexOf(',');\n            if (comma < 0)\n                this.setBackground((0,_util_util__WEBPACK_IMPORTED_MODULE_10__.htmlToRGB)(bg));\n            else\n                this.setBackgroundGradient((0,_util_util__WEBPACK_IMPORTED_MODULE_10__.htmlToRGB)(bg.substring(0, comma)), (0,_util_util__WEBPACK_IMPORTED_MODULE_10__.htmlToRGB)(bg.substring(comma + 1)));\n        }\n        if (options.border == 'transparent')\n            this.borderCol = _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_7__.MetaVector.NOCOLOUR;\n        else if (options.border)\n            this.borderCol = (0,_util_util__WEBPACK_IMPORTED_MODULE_10__.htmlToRGB)(options.border);\n        if (options.radius != null)\n            this.borderRadius = parseInt(options.radius);\n        if (options.scheme == 'wob')\n            this.policy = _gfx_Rendering__WEBPACK_IMPORTED_MODULE_8__.RenderPolicy.defaultWhiteOnBlack();\n        else if (options.scheme == 'cob')\n            this.policy = _gfx_Rendering__WEBPACK_IMPORTED_MODULE_8__.RenderPolicy.defaultColourOnBlack();\n        else if (options.scheme == 'bow')\n            this.policy = _gfx_Rendering__WEBPACK_IMPORTED_MODULE_8__.RenderPolicy.defaultBlackOnWhite();\n        else if (options.scheme == 'cow')\n            this.policy = _gfx_Rendering__WEBPACK_IMPORTED_MODULE_8__.RenderPolicy.defaultColourOnWhite();\n        if (options.scale)\n            this.policy.data.pointScale = options.scale;\n        if (options.tight == true || options.tight == 'true')\n            this.tight = true;\n        this.ds = ds;\n    }\n    render(parent) {\n        this.tagType = 'span';\n        super.render(parent);\n        let span = this.contentDOM, ds = this.ds, policy = this.policy;\n        span.css({ 'display': 'inline-block', 'line-height': '0' });\n        if (!this.tight)\n            span.setCSS('margin-bottom', '1.5em');\n        if (ds != null) {\n            let aspects = new _aspect_AspectList__WEBPACK_IMPORTED_MODULE_1__.AspectList(ds).enumerate();\n            let columns = this.determineColumns(aspects);\n            let table = (0,_util_dom__WEBPACK_IMPORTED_MODULE_9__.dom)('<table/>').appendTo(span);\n            table.css({ 'font-family': '\"HelveticaNeue-Light\", \"Helvetica Neue Light\", \"Helvetica Neue\", Helvetica, Arial, \"Lucida Grande\", sans-serif' });\n            table.css({ 'border-collapse': 'collapse', 'line-height': '1', 'margin': '2px', 'border': '0' });\n            let tr = (0,_util_dom__WEBPACK_IMPORTED_MODULE_9__.dom)('<tr/>').appendTo(table).css({ 'line-height': '1' });\n            for (let n = 0; n < columns.length; n++) {\n                let th = (0,_util_dom__WEBPACK_IMPORTED_MODULE_9__.dom)('<th/>').appendTo(tr);\n                th.css({ 'white-space': 'nowrap', 'font-weight': '600', 'text-decoration': 'underline', 'text-align': 'center' });\n                th.css({ 'padding': '0.2em 0.5em 0.2em 0.5em', 'color': 'black', 'border': '0' });\n                th.setText(columns[n].name);\n            }\n            for (let row = 0; row < ds.numRows;) {\n                let blksz = 1;\n                for (let aspect of aspects)\n                    blksz = Math.max(blksz, aspect.rowBlockCount(row));\n                tr = (0,_util_dom__WEBPACK_IMPORTED_MODULE_9__.dom)('<tr/>').appendTo(table).css({ 'line-height': '1' });\n                for (let col = 0; col < columns.length; col++) {\n                    let td = (0,_util_dom__WEBPACK_IMPORTED_MODULE_9__.dom)('<td/>').appendTo(tr);\n                    td.css({ 'border': '1px solid #D0D0D0', 'padding': '0.2em', 'vertical-align': 'middle' });\n                    let spec = columns[col];\n                    if (spec.aspect == null) {\n                        if (ds.isNull(row, spec.idx))\n                            td.setText(' ');\n                        else if (ds.colType(spec.idx) == \"molecule\")\n                            this.renderMolecule(td, row, spec.idx);\n                        else\n                            this.renderPrimitive(td, row, spec.idx);\n                    }\n                    else if (spec.type == 'text')\n                        this.renderTextAspect(td, row, spec.aspect, spec.idx);\n                    else if (spec.type == 'graphic')\n                        this.renderGraphicAspect(td, row, spec.aspect, spec.idx);\n                }\n                row += blksz;\n            }\n        }\n        else {\n            span.css({ 'color': 'red' });\n            span.setText('Unable to parse datasheet: ' + this.failmsg);\n            let pre = (0,_util_dom__WEBPACK_IMPORTED_MODULE_9__.dom)('<pre/>').appendTo(span);\n            pre.css({ 'line-height': '1.1' });\n            pre.setText(this.datastr);\n            console.log('Unparseable datasheet source string:\\n[' + this.datastr + ']');\n        }\n    }\n    determineColumns(aspects) {\n        let ds = this.ds;\n        let columns = [];\n        let reserved = _util_Vec__WEBPACK_IMPORTED_MODULE_11__.Vec.booleanArray(false, ds.numCols);\n        let names = [];\n        for (let n = 0; n < ds.numCols; n++)\n            names.push(ds.colName(n));\n        for (let aspect of aspects) {\n            if (ds.numRows > 0)\n                for (let n = 0, num = aspect.numTextRenderings(0); n < num; n++) {\n                    let title = aspect.produceTextRendering(0, n).name;\n                    columns.push({ 'name': title, 'aspect': aspect, 'type': 'text', 'idx': n });\n                }\n            if (ds.numRows > 0)\n                for (let n = 0, num = aspect.numGraphicRenderings(0); n < num; n++) {\n                    let title = aspect.produceGraphicRendering(0, n, this.policy).name;\n                    columns.push({ 'name': title, 'aspect': aspect, 'type': 'graphic', 'idx': n });\n                }\n            let claimed = aspect.areColumnsReserved(names);\n            for (let n = 0; n < names.length; n++)\n                reserved[n] = reserved[n] || claimed[n];\n        }\n        for (let n = 0; n < ds.numCols; n++)\n            if (!reserved[n] && ds.colType(n) != \"extend\") {\n                columns.push({ 'name': ds.colName(n), 'aspect': null, 'type': null, 'idx': n });\n            }\n        return columns;\n    }\n    renderPrimitive(td, row, col) {\n        let txt = '', ct = this.ds.colType(col), align = 'center';\n        if (ct == \"string\") {\n            txt = this.ds.getString(row, col);\n            align = 'left';\n        }\n        else if (ct == \"integer\")\n            txt = this.ds.getInteger(row, col).toString();\n        else if (ct == \"real\")\n            txt = this.ds.getReal(row, col).toString();\n        else if (ct == \"boolean\")\n            txt = this.ds.getBoolean(row, col) ? 'true' : 'false';\n        td.setText(txt);\n        td.css({ 'text-align': align });\n    }\n    renderMolecule(td, row, col) {\n        td.css({ 'text-align': 'center' });\n        let effects = new _gfx_Rendering__WEBPACK_IMPORTED_MODULE_8__.RenderEffects();\n        let measure = new _gfx_ArrangeMeasurement__WEBPACK_IMPORTED_MODULE_4__.OutlineMeasurement(0, 0, this.policy.data.pointScale);\n        let layout = new _gfx_ArrangeMolecule__WEBPACK_IMPORTED_MODULE_5__.ArrangeMolecule(this.ds.getMolecule(row, col), measure, this.policy, effects);\n        layout.arrange();\n        let metavec = new _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_7__.MetaVector();\n        new _gfx_DrawMolecule__WEBPACK_IMPORTED_MODULE_6__.DrawMolecule(layout, metavec).draw();\n        metavec.normalise();\n        (0,_util_dom__WEBPACK_IMPORTED_MODULE_9__.dom)(metavec.createSVG()).appendTo(td);\n    }\n    renderTextAspect(td, row, aspect, idx) {\n        let rend = aspect.produceTextRendering(row, idx);\n        if (!rend.text)\n            td.setText(' ');\n        else if (rend.type == _aspect_Aspect__WEBPACK_IMPORTED_MODULE_0__.Aspect.TEXT_PLAIN)\n            td.setText(rend.text);\n        else if (rend.type == _aspect_Aspect__WEBPACK_IMPORTED_MODULE_0__.Aspect.TEXT_LINK) {\n            let ahref = (0,_util_dom__WEBPACK_IMPORTED_MODULE_9__.dom)('<a target=\"_blank\"/>').appendTo(td);\n            ahref.setAttr('href', rend.text);\n            ahref.setText(rend.text);\n        }\n        else if (rend.type == _aspect_Aspect__WEBPACK_IMPORTED_MODULE_0__.Aspect.TEXT_HTML)\n            td.setHTML(rend.text);\n    }\n    renderGraphicAspect(td, row, aspect, idx) {\n        let metavec = aspect.produceGraphicRendering(row, idx, this.policy).metavec;\n        if (metavec == null) {\n            td.setText(' ');\n            return;\n        }\n        td.css({ 'text-align': 'center' });\n        metavec.normalise();\n        (0,_util_dom__WEBPACK_IMPORTED_MODULE_9__.dom)(metavec.createSVG()).appendTo(td);\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/ui/EmbedCollection.ts?");

/***/ }),

/***/ "./src/ui/EmbedMolecule.ts":
/*!*********************************!*\
  !*** ./src/ui/EmbedMolecule.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EmbedMolecule\": () => (/* binding */ EmbedMolecule)\n/* harmony export */ });\n/* harmony import */ var _data_CoordUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/CoordUtil */ \"./src/data/CoordUtil.ts\");\n/* harmony import */ var _data_MDLReader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/MDLReader */ \"./src/data/MDLReader.ts\");\n/* harmony import */ var _data_Molecule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data/Molecule */ \"./src/data/Molecule.ts\");\n/* harmony import */ var _gfx_ArrangeMeasurement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../gfx/ArrangeMeasurement */ \"./src/gfx/ArrangeMeasurement.ts\");\n/* harmony import */ var _gfx_ArrangeMolecule__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../gfx/ArrangeMolecule */ \"./src/gfx/ArrangeMolecule.ts\");\n/* harmony import */ var _gfx_DrawMolecule__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../gfx/DrawMolecule */ \"./src/gfx/DrawMolecule.ts\");\n/* harmony import */ var _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../gfx/MetaVector */ \"./src/gfx/MetaVector.ts\");\n/* harmony import */ var _gfx_Rendering__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../gfx/Rendering */ \"./src/gfx/Rendering.ts\");\n/* harmony import */ var _util_dom__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/dom */ \"./src/util/dom.ts\");\n/* harmony import */ var _util_Geom__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../util/Geom */ \"./src/util/Geom.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _EmbedChemistry__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./EmbedChemistry */ \"./src/ui/EmbedChemistry.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\nclass EmbedMolecule extends _EmbedChemistry__WEBPACK_IMPORTED_MODULE_11__.EmbedChemistry {\n    constructor(molstr, options) {\n        super();\n        this.molstr = molstr;\n        this.mol = null;\n        this.name = '';\n        this.failmsg = '';\n        this.maxWidth = 0;\n        this.maxHeight = 0;\n        this.boxSize = null;\n        this.tight = false;\n        if (!options)\n            options = {};\n        let mol = null, name = options.name;\n        if (options.format == 'sketchel' || options.format == 'chemical/x-sketchel') {\n            mol = _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.fromString(molstr);\n        }\n        else if (options.format == 'molfile' || options.format == 'chemical/x-mdl-molfile') {\n            try {\n                let mdl = new _data_MDLReader__WEBPACK_IMPORTED_MODULE_1__.MDLMOLReader(molstr);\n                mol = mdl.parse();\n                if (mol != null && name == null)\n                    name = mdl.molName;\n            }\n            catch (ex) {\n                this.failmsg = ex;\n            }\n        }\n        else {\n            mol = _data_Molecule__WEBPACK_IMPORTED_MODULE_2__.Molecule.fromString(molstr);\n            if (mol == null) {\n                try {\n                    let mdl = new _data_MDLReader__WEBPACK_IMPORTED_MODULE_1__.MDLMOLReader(molstr);\n                    mol = mdl.parse();\n                    if (mol != null && name == null)\n                        name = mdl.molName;\n                }\n                catch (ex) { }\n            }\n        }\n        if (mol == null)\n            return;\n        if (options.invert)\n            mol = _data_CoordUtil__WEBPACK_IMPORTED_MODULE_0__.CoordUtil.mirrorImage(mol);\n        if (options.rotate)\n            _data_CoordUtil__WEBPACK_IMPORTED_MODULE_0__.CoordUtil.rotateMolecule(mol, options.rotate * _util_util__WEBPACK_IMPORTED_MODULE_10__.DEGRAD);\n        if (options.padding)\n            this.padding = options.padding;\n        if (options.background == 'transparent')\n            this.clearBackground();\n        else if (options.background) {\n            let bg = options.background, comma = bg.indexOf(',');\n            if (comma < 0)\n                this.setBackground((0,_util_util__WEBPACK_IMPORTED_MODULE_10__.htmlToRGB)(bg));\n            else\n                this.setBackgroundGradient((0,_util_util__WEBPACK_IMPORTED_MODULE_10__.htmlToRGB)(bg.substring(0, comma)), (0,_util_util__WEBPACK_IMPORTED_MODULE_10__.htmlToRGB)(bg.substring(comma + 1)));\n        }\n        if (options.border == 'transparent')\n            this.borderCol = _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_6__.MetaVector.NOCOLOUR;\n        else if (options.border)\n            this.borderCol = (0,_util_util__WEBPACK_IMPORTED_MODULE_10__.htmlToRGB)(options.border);\n        if (options.radius != null)\n            this.borderRadius = parseInt(options.radius);\n        if (options.width)\n            this.maxWidth = options.width;\n        if (options.height)\n            this.maxHeight = options.height;\n        if (options.box) {\n            let box = options.box, comma = box.indexOf(',');\n            this.boxSize = new _util_Geom__WEBPACK_IMPORTED_MODULE_9__.Size(parseInt(box.substring(0, comma)), parseInt(box.substring(comma + 1)));\n        }\n        if (options.scheme == 'wob')\n            this.policy = _gfx_Rendering__WEBPACK_IMPORTED_MODULE_7__.RenderPolicy.defaultWhiteOnBlack();\n        else if (options.scheme == 'cob')\n            this.policy = _gfx_Rendering__WEBPACK_IMPORTED_MODULE_7__.RenderPolicy.defaultColourOnBlack();\n        else if (options.scheme == 'bow')\n            this.policy = _gfx_Rendering__WEBPACK_IMPORTED_MODULE_7__.RenderPolicy.defaultBlackOnWhite();\n        else if (options.scheme == 'cow')\n            this.policy = _gfx_Rendering__WEBPACK_IMPORTED_MODULE_7__.RenderPolicy.defaultColourOnWhite();\n        if (options.scale)\n            this.policy.data.pointScale = options.scale;\n        if (options.tight == true || options.tight == 'true')\n            this.tight = true;\n        this.mol = mol;\n        this.name = name;\n    }\n    render(parent) {\n        this.tagType = 'span';\n        super.render(parent);\n        let span = this.contentDOM, mol = this.mol, policy = this.policy;\n        span.css({ 'display': 'inline-block', 'line-height': '0' });\n        if (!this.tight)\n            span.setCSS('margin-bottom', '1.5em');\n        if (mol != null && mol.numAtoms > 0) {\n            span.setCSS('text-align', 'center');\n            let effects = new _gfx_Rendering__WEBPACK_IMPORTED_MODULE_7__.RenderEffects();\n            let measure = new _gfx_ArrangeMeasurement__WEBPACK_IMPORTED_MODULE_3__.OutlineMeasurement(0, 0, policy.data.pointScale);\n            let layout = new _gfx_ArrangeMolecule__WEBPACK_IMPORTED_MODULE_4__.ArrangeMolecule(mol, measure, policy, effects);\n            layout.arrange();\n            if (this.boxSize)\n                layout.squeezeInto(0, 0, this.boxSize.w, this.boxSize.h);\n            else if (this.maxWidth > 0 || this.maxHeight > 0) {\n                let bounds = layout.determineBoundary();\n                let w = bounds[2] - bounds[0], h = bounds[3] - bounds[1];\n                let limW = this.maxWidth == 0 ? w : Math.min(w, this.maxWidth);\n                let limH = this.maxHeight == 0 ? h : Math.min(h, this.maxHeight);\n                if (limW != w || limH != h)\n                    layout.squeezeInto(0, 0, limW, limH);\n            }\n            let metavec = new _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_6__.MetaVector();\n            new _gfx_DrawMolecule__WEBPACK_IMPORTED_MODULE_5__.DrawMolecule(layout, metavec).draw();\n            if (this.boxSize == null)\n                metavec.normalise();\n            else\n                metavec.setSize(this.boxSize.w, this.boxSize.h);\n            let svg = (0,_util_dom__WEBPACK_IMPORTED_MODULE_8__.dom)(metavec.createSVG()).appendTo(span);\n            if (this.name) {\n                let p = (0,_util_dom__WEBPACK_IMPORTED_MODULE_8__.dom)('<p/>').appendTo(span);\n                p.css({ 'padding': '0.2em 0 0 0', 'margin': '0', 'width': '100%', 'color': '#606060', 'line-height': '1' });\n                p.css({ 'font-family': '\"HelveticaNeue-Light\", \"Helvetica Neue Light\", \"Helvetica Neue\", Helvetica, Arial, \"Lucida Grande\", sans-serif' });\n                p.setText(this.name);\n            }\n        }\n        else {\n            span.css({ 'color': 'red' });\n            span.setText('Unable to parse molecule: ' + this.failmsg);\n            let pre = (0,_util_dom__WEBPACK_IMPORTED_MODULE_8__.dom)('<pre/>').appendTo(span);\n            pre.css({ 'line-height': '1.1' });\n            pre.setText(this.molstr);\n            console.log('Unparseable molecule source string:\\n[' + this.molstr + ']');\n        }\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/ui/EmbedMolecule.ts?");

/***/ }),

/***/ "./src/ui/EmbedReaction.ts":
/*!*********************************!*\
  !*** ./src/ui/EmbedReaction.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EmbedReaction\": () => (/* binding */ EmbedReaction),\n/* harmony export */   \"EmbedReactionFacet\": () => (/* binding */ EmbedReactionFacet)\n/* harmony export */ });\n/* harmony import */ var _aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../aspect/Experiment */ \"./src/aspect/Experiment.ts\");\n/* harmony import */ var _data_DataSheetStream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/DataSheetStream */ \"./src/data/DataSheetStream.ts\");\n/* harmony import */ var _data_MolUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data/MolUtil */ \"./src/data/MolUtil.ts\");\n/* harmony import */ var _data_QuantityCalc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../data/QuantityCalc */ \"./src/data/QuantityCalc.ts\");\n/* harmony import */ var _gfx_ArrangeExperiment__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../gfx/ArrangeExperiment */ \"./src/gfx/ArrangeExperiment.ts\");\n/* harmony import */ var _gfx_ArrangeMeasurement__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../gfx/ArrangeMeasurement */ \"./src/gfx/ArrangeMeasurement.ts\");\n/* harmony import */ var _gfx_ArrangeMolecule__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../gfx/ArrangeMolecule */ \"./src/gfx/ArrangeMolecule.ts\");\n/* harmony import */ var _gfx_DrawExperiment__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../gfx/DrawExperiment */ \"./src/gfx/DrawExperiment.ts\");\n/* harmony import */ var _gfx_DrawMolecule__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../gfx/DrawMolecule */ \"./src/gfx/DrawMolecule.ts\");\n/* harmony import */ var _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../gfx/MetaVector */ \"./src/gfx/MetaVector.ts\");\n/* harmony import */ var _gfx_Rendering__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../gfx/Rendering */ \"./src/gfx/Rendering.ts\");\n/* harmony import */ var _util_dom__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../util/dom */ \"./src/util/dom.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _EmbedChemistry__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./EmbedChemistry */ \"./src/ui/EmbedChemistry.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar EmbedReactionFacet;\n(function (EmbedReactionFacet) {\n    EmbedReactionFacet[\"HEADER\"] = \"header\";\n    EmbedReactionFacet[\"SCHEME\"] = \"scheme\";\n    EmbedReactionFacet[\"QUANTITY\"] = \"quantity\";\n    EmbedReactionFacet[\"METRICS\"] = \"metrics\";\n})(EmbedReactionFacet || (EmbedReactionFacet = {}));\nclass EmbedReaction extends _EmbedChemistry__WEBPACK_IMPORTED_MODULE_13__.EmbedChemistry {\n    constructor(datastr, options) {\n        super();\n        this.datastr = datastr;\n        this.row = 0;\n        this.entry = null;\n        this.failmsg = '';\n        this.tight = false;\n        this.facet = 'scheme';\n        this.limitTotalW = 800;\n        this.includeStoich = true;\n        this.includeAnnot = false;\n        if (!options)\n            options = {};\n        if (options.encoding == 'base64')\n            datastr = (0,_util_util__WEBPACK_IMPORTED_MODULE_12__.fromUTF8)(atob(datastr.trim()));\n        let xs = null;\n        if (options.format == 'datasheet' || options.format == 'chemical/x-datasheet') {\n            let ds = _data_DataSheetStream__WEBPACK_IMPORTED_MODULE_1__.DataSheetStream.readXML(datastr);\n            if (ds == null) {\n                this.failmsg = 'Unable to parse raw XML datasheet.';\n                return;\n            }\n            if (_aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__.Experiment.isExperiment(ds))\n                xs = new _aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__.Experiment(ds);\n        }\n        else {\n            let ds = _data_DataSheetStream__WEBPACK_IMPORTED_MODULE_1__.DataSheetStream.readXML(datastr);\n            if (ds == null) {\n                this.failmsg = 'Unable to parse raw XML datasheet.';\n                return;\n            }\n            if (_aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__.Experiment.isExperiment(ds))\n                xs = new _aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__.Experiment(ds);\n        }\n        if (xs == null) {\n            this.failmsg = 'Unable to instantiate Experiment aspect.';\n            return;\n        }\n        if (xs.ds.numRows == 0) {\n            this.failmsg = 'Experiment datasheet has no rows.';\n            return;\n        }\n        if (options.row)\n            this.row = options.row;\n        if (this.row < 0 || this.row >= xs.ds.numRows) {\n            this.failmsg = 'Requested row ' + this.row + ' out of bounds.';\n            return;\n        }\n        this.entry = xs.getEntry(this.row);\n        if (options.facet)\n            this.facet = options.facet;\n        if (options.padding)\n            this.padding = options.padding;\n        if (options.background == 'transparent')\n            this.clearBackground();\n        else if (options.background) {\n            let bg = options.background, comma = bg.indexOf(',');\n            if (comma < 0)\n                this.setBackground((0,_util_util__WEBPACK_IMPORTED_MODULE_12__.htmlToRGB)(bg));\n            else\n                this.setBackgroundGradient((0,_util_util__WEBPACK_IMPORTED_MODULE_12__.htmlToRGB)(bg.substring(0, comma)), (0,_util_util__WEBPACK_IMPORTED_MODULE_12__.htmlToRGB)(bg.substring(comma + 1)));\n        }\n        if (options.border == 'transparent')\n            this.borderCol = _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_9__.MetaVector.NOCOLOUR;\n        else if (options.border)\n            this.borderCol = (0,_util_util__WEBPACK_IMPORTED_MODULE_12__.htmlToRGB)(options.border);\n        if (options.radius != null)\n            this.borderRadius = parseInt(options.radius);\n        if (options.scheme == 'wob')\n            this.policy = _gfx_Rendering__WEBPACK_IMPORTED_MODULE_10__.RenderPolicy.defaultWhiteOnBlack();\n        else if (options.scheme == 'cob')\n            this.policy = _gfx_Rendering__WEBPACK_IMPORTED_MODULE_10__.RenderPolicy.defaultColourOnBlack();\n        else if (options.scheme == 'bow')\n            this.policy = _gfx_Rendering__WEBPACK_IMPORTED_MODULE_10__.RenderPolicy.defaultBlackOnWhite();\n        else if (options.scheme == 'cow')\n            this.policy = _gfx_Rendering__WEBPACK_IMPORTED_MODULE_10__.RenderPolicy.defaultColourOnWhite();\n        if (options.scale)\n            this.policy.data.pointScale = options.scale;\n        if (options.tight == true || options.tight == 'true')\n            this.tight = true;\n        if (options.maximumwidth > 0)\n            this.limitTotalW = options.maximumwidth;\n        if (options.stoichiometry == false || options.stoichiometry == 'false')\n            this.includeStoich = true;\n        if (options.annotations == true || options.annotations == 'true')\n            this.includeAnnot = true;\n    }\n    render(parent) {\n        this.tagType = 'span';\n        super.render(parent);\n        let span = this.contentDOM;\n        span.css({ 'display': 'inline-block', 'line-height': '0' });\n        if (!this.tight)\n            span.setCSS('margin-bottom', '1.5em');\n        if (this.entry != null) {\n            if (this.facet == EmbedReactionFacet.HEADER)\n                this.renderHeader(span);\n            else if (this.facet == EmbedReactionFacet.SCHEME)\n                this.renderScheme(span);\n            else if (this.facet == EmbedReactionFacet.QUANTITY)\n                this.renderQuantity(span);\n            else if (this.facet == EmbedReactionFacet.METRICS)\n                this.renderMetrics(span);\n        }\n        else {\n            span.css({ 'color': 'red' });\n            span.setText('Failure to acquire data: ' + this.failmsg);\n            let pre = (0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)('<pre/>').appendTo(span).css({ 'line-height': '1.1' });\n            pre.setText(this.datastr);\n            console.log('Unparseable datasheet source string:\\n[' + this.datastr + ']');\n        }\n    }\n    renderHeader(span) {\n        let table = (0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)('<table/>').appendTo(span);\n        table.css({ 'font-family': '\"HelveticaNeue-Light\", \"Helvetica Neue Light\", \"Helvetica Neue\", Helvetica, Arial, \"Lucida Grande\", sans-serif' });\n        table.css({ 'border-collapse': 'collapse', 'line-height': '1', 'margin': '2px', 'border': '0' });\n        let titles = ['Title', 'Created', 'Modified', 'DOI'];\n        for (let n = 0; n < 4; n++) {\n            if (n == 3 && !this.entry.doi)\n                continue;\n            let tr = (0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)('<tr/>').appendTo(table).css({ 'line-height': '1' });\n            let th = (0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)('<th/>').appendTo(tr);\n            th.css({ 'white-space': 'nowrap', 'font-weight': '600', 'color': 'black', 'text-align': 'left', 'vertical-align': 'middle' });\n            th.css({ 'padding': '0.2em 0.5em 0.2em 0.5em', 'border': '1px solid #D0D0D0' });\n            th.setText(titles[n]);\n            let td = (0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)('<td/>').appendTo(tr);\n            td.css({ 'border': '1px solid #D0D0D0', 'padding': '0.2em', 'vertical-align': 'middle' });\n            if (n == 0) {\n                if (!this.entry.title)\n                    td.setCSS('font-style', 'italic');\n                td.setText(this.entry.title ? this.entry.title : '(none)');\n            }\n            else if (n == 1 || n == 2) {\n                let date = n == 1 ? this.entry.createDate : this.entry.modifyDate;\n                if (date == null)\n                    td.setCSS('font-style', 'italic');\n                td.setText(date == null ? '(none)' : date.toLocaleString());\n            }\n            else if (n == 3) {\n                let url = this.doiToLink(this.entry.doi);\n                if (url != null && (url.startsWith('http://') || url.startsWith('https://'))) {\n                    let ahref = (0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)('<a target=\"_blank\"/>').appendTo(td);\n                    ahref.setAttr('href', url);\n                    ahref.setText(this.entry.doi);\n                }\n                else\n                    td.setText(this.entry.doi);\n            }\n        }\n    }\n    renderScheme(span) {\n        let measure = new _gfx_ArrangeMeasurement__WEBPACK_IMPORTED_MODULE_5__.OutlineMeasurement(0, 0, this.policy.data.pointScale);\n        let layout = new _gfx_ArrangeExperiment__WEBPACK_IMPORTED_MODULE_4__.ArrangeExperiment(this.entry, measure, this.policy);\n        layout.limitTotalW = this.limitTotalW;\n        layout.includeStoich = this.includeStoich;\n        layout.includeAnnot = this.includeAnnot;\n        layout.arrange();\n        let metavec = new _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_9__.MetaVector();\n        new _gfx_DrawExperiment__WEBPACK_IMPORTED_MODULE_7__.DrawExperiment(layout, metavec).draw();\n        metavec.normalise();\n        let svg = (0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)(metavec.createSVG()).appendTo(span);\n    }\n    renderQuantity(span) {\n        let quant = new _data_QuantityCalc__WEBPACK_IMPORTED_MODULE_3__.QuantityCalc(this.entry);\n        quant.calculate();\n        let table = (0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)('<table/>').appendTo(span);\n        table.css({ 'font-family': '\"HelveticaNeue-Light\", \"Helvetica Neue Light\", \"Helvetica Neue\", Helvetica, Arial, \"Lucida Grande\", sans-serif' });\n        table.css({ 'border-collapse': 'collapse', 'line-height': '1', 'margin': '2px', 'border': '0' });\n        let effects = new _gfx_Rendering__WEBPACK_IMPORTED_MODULE_10__.RenderEffects();\n        let measure = new _gfx_ArrangeMeasurement__WEBPACK_IMPORTED_MODULE_5__.OutlineMeasurement(0, 0, this.policy.data.pointScale);\n        for (let n = 0; n < quant.numQuantities; n++) {\n            let qc = quant.getQuantity(n);\n            let tr = (0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)('<tr/>').appendTo(table).css({ 'line-height': '1' });\n            let td = (0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)('<td/>').appendTo(tr);\n            td.css({ 'border': '1px solid #D0D0D0', 'padding': '0.2em', 'text-align': 'center', 'vertical-align': 'middle' });\n            if (_data_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.notBlank(qc.comp.mol)) {\n                let layout = new _gfx_ArrangeMolecule__WEBPACK_IMPORTED_MODULE_6__.ArrangeMolecule(qc.comp.mol, measure, this.policy, effects);\n                layout.arrange();\n                let metavec = new _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_9__.MetaVector();\n                new _gfx_DrawMolecule__WEBPACK_IMPORTED_MODULE_8__.DrawMolecule(layout, metavec).draw();\n                metavec.normalise();\n                let svg = (0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)(metavec.createSVG()).appendTo(td);\n            }\n            td = (0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)('<td/>').appendTo(tr);\n            td.css({ 'border': '1px solid #D0D0D0', 'padding': '0.2em', 'text-align': 'left', 'vertical-align': 'top' });\n            this.renderComponentText(td, qc);\n        }\n    }\n    renderComponentText(parent, qc) {\n        let title = [], content = [];\n        if (qc.comp.name) {\n            title.push('Name');\n            content.push('<i>' + (0,_util_util__WEBPACK_IMPORTED_MODULE_12__.escapeHTML)(qc.comp.name) + '</i>');\n        }\n        if (_data_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.notBlank(qc.comp.mol)) {\n            let mw = _data_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.molecularWeight(qc.comp.mol);\n            title.push('Weight');\n            content.push(mw.toFixed(4));\n            let mf = _data_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.molecularFormula(qc.comp.mol, ['<sub>', '</sub>', '<sup>', '</sup>']);\n            title.push('Formula');\n            content.push(mf);\n        }\n        if (qc.valueEquiv > 0) {\n            let text = qc.valueEquiv.toString(), stat = qc.statEquiv;\n            if (stat == 2)\n                text = '<i>(' + text + ')</i>';\n            else if (stat == 3)\n                text += ' (conflicting)';\n            title.push('Stoichiometry');\n            content.push(text);\n        }\n        if (qc.valueMass > 0) {\n            let text = _data_QuantityCalc__WEBPACK_IMPORTED_MODULE_3__.QuantityCalc.formatMass(qc.valueMass), stat = qc.statMass;\n            if (stat == 2)\n                text = '<i>(' + text + ')</i>';\n            else if (stat == 3)\n                text += ' (conflicting)';\n            title.push('Mass');\n            content.push(text);\n        }\n        if (qc.valueVolume > 0) {\n            let text = _data_QuantityCalc__WEBPACK_IMPORTED_MODULE_3__.QuantityCalc.formatVolume(qc.valueVolume), stat = qc.statVolume;\n            if (stat == 2)\n                text = '<i>(' + text + ')</i>';\n            else if (stat == 3)\n                text += ' (conflicting)';\n            title.push('Volume');\n            content.push(text);\n        }\n        if (qc.valueMoles > 0) {\n            let text = _data_QuantityCalc__WEBPACK_IMPORTED_MODULE_3__.QuantityCalc.formatMoles(qc.valueMoles), stat = qc.statMoles;\n            if (stat == 2)\n                text = '<i>(' + text + ')</i>';\n            else if (stat == 3)\n                text += ' (conflicting)';\n            title.push('Moles');\n            content.push(text);\n        }\n        if (qc.valueDensity > 0) {\n            let text = _data_QuantityCalc__WEBPACK_IMPORTED_MODULE_3__.QuantityCalc.formatDensity(qc.valueDensity), stat = qc.statDensity;\n            if (stat == 2)\n                text = '<i>(' + text + ')</i>';\n            else if (stat == 3)\n                text += ' (conflicting)';\n            title.push('Density');\n            content.push(text);\n        }\n        if (qc.valueConc > 0) {\n            let text = _data_QuantityCalc__WEBPACK_IMPORTED_MODULE_3__.QuantityCalc.formatConc(qc.valueConc), stat = qc.statConc;\n            if (stat == 2)\n                text = '<i>(' + text + ')</i>';\n            else if (stat == 3)\n                text += ' (conflicting)';\n            title.push('Concentration');\n            content.push(text);\n        }\n        if (qc.valueYield > 0 && !qc.comp.waste) {\n            let text = _data_QuantityCalc__WEBPACK_IMPORTED_MODULE_3__.QuantityCalc.formatPercent(qc.valueYield), stat = qc.statYield;\n            if (stat == 2)\n                text = '<i>(' + text + ')</i>';\n            else if (stat == 3)\n                text += ' (conflicting)';\n            title.push('Yield');\n            content.push(text);\n        }\n        for (let n = 0; n < title.length; n++) {\n            let p = (0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)('<p/>').appendTo(parent);\n            p.setCSS('margin', '0.1em');\n            p.append((0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)('<b>' + title[n] + '</b>'));\n            p.appendText(': ');\n            p.appendHTML(content[n]);\n        }\n    }\n    renderMetrics(span) {\n        let quant = new _data_QuantityCalc__WEBPACK_IMPORTED_MODULE_3__.QuantityCalc(this.entry);\n        quant.calculate();\n        let table = (0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)('<table/>').appendTo(span);\n        table.css({ 'font-family': '\"HelveticaNeue-Light\", \"Helvetica Neue Light\", \"Helvetica Neue\", Helvetica, Arial, \"Lucida Grande\", sans-serif' });\n        table.css({ 'border-collapse': 'collapse', 'line-height': '1', 'margin': '2px', 'border': '0' });\n        let effects = new _gfx_Rendering__WEBPACK_IMPORTED_MODULE_10__.RenderEffects();\n        let measure = new _gfx_ArrangeMeasurement__WEBPACK_IMPORTED_MODULE_5__.OutlineMeasurement(0, 0, this.policy.data.pointScale);\n        if (quant.numGreenMetrics > 0)\n            for (let n = 0; n < 3; n++) {\n                let tr = (0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)('<tr/>').appendTo(table).css({ 'line-height': '1' });\n                let th = (0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)('<th/>').appendTo(tr);\n                th.css({ 'border': '1px solid #D0D0D0', 'padding': '0.5em', 'font-weight': 'bold' });\n                th.css({ 'text-align': 'right', 'vertical-align': 'middle', 'white-space': 'nowrap' });\n                th.setText(n == 0 ? 'All Reactants' : n == 1 ? 'All Products' : 'All Waste');\n                let td = (0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)('<td/>').appendTo(tr);\n                td.css({ 'border': '1px solid #D0D0D0', 'padding': '0.5em', 'white-space': 'nowrap' });\n                td.css({ 'text-align': 'left', 'vertical-align': 'middle' });\n                if (n == 0) {\n                    td.setText(this.combineQuant(quant.getAllMassReact(), 'g') + ' = ' + this.sumQuant(quant.getAllMassReact(), 'g', true));\n                }\n                else if (n == 1) {\n                    td.setText(this.combineQuant(quant.getAllMassProd(), 'g') + ' = ' + this.sumQuant(quant.getAllMassProd(), 'g', true));\n                }\n                else if (n == 2) {\n                    if (quant.getAllMassWaste().length > 0)\n                        td.setText(this.combineQuant(quant.getAllMassWaste(), 'g') + ' = ' + this.sumQuant(quant.getAllMassWaste(), 'g', false));\n                    else\n                        td.setText('none');\n                }\n            }\n        else {\n            let tr = (0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)('<tr/>').appendTo(table);\n            let td = (0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)('<td/>').appendTo(tr);\n            td.setText('No metrics to show.');\n        }\n        for (let n = 0; n < quant.numGreenMetrics; n++) {\n            let gm = quant.getGreenMetrics(n);\n            let qc = quant.getQuantity(gm.idx);\n            let tr = (0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)('<tr/>').appendTo(table).css({ 'line-height': '1' });\n            let td = (0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)('<td/>').appendTo(tr);\n            td.css({ 'border': '1px solid #D0D0D0', 'padding': '0.2em', 'text-align': 'center', 'vertical-align': 'middle' });\n            if (_data_MolUtil__WEBPACK_IMPORTED_MODULE_2__.MolUtil.notBlank(qc.comp.mol)) {\n                let layout = new _gfx_ArrangeMolecule__WEBPACK_IMPORTED_MODULE_6__.ArrangeMolecule(qc.comp.mol, measure, this.policy, effects);\n                layout.arrange();\n                let metavec = new _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_9__.MetaVector();\n                new _gfx_DrawMolecule__WEBPACK_IMPORTED_MODULE_8__.DrawMolecule(layout, metavec).draw();\n                metavec.normalise();\n                (0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)(metavec.createSVG()).appendTo(td);\n            }\n            td = (0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)('<td/>').appendTo(tr);\n            td.css({ 'border': '1px solid #D0D0D0', 'padding': '0.5em', 'text-align': 'left', 'vertical-align': 'top' });\n            let pmi1 = this.combineQuant(gm.massReact, 'g'), pmi2 = this.combineQuant(gm.massProd, 'g');\n            let pmi3 = this.sumQuantExt(gm.massReact, gm.massProd, 1, Number.NaN, null);\n            let vg = this.drawTotals('PMI', pmi1, pmi2, pmi3);\n            vg.normalise();\n            let para = (0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)('<p/>').appendTo(td);\n            (0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)(vg.createSVG()).appendTo(para);\n            let ef1 = this.combineQuant(gm.massWaste, 'g'), ef2 = this.combineQuant(gm.massProd, 'g');\n            let ef3 = this.sumQuantExt(gm.massWaste, gm.massProd, 1, Number.NaN, null);\n            vg = this.drawTotals('E-factor', ef1, ef2, ef3);\n            vg.normalise();\n            para = (0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)('<p/>').appendTo(td);\n            (0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)(vg.createSVG()).appendTo(para);\n            let ae1 = this.combineQuant(gm.molwProd, null), ae2 = this.combineQuant(gm.molwReact, null);\n            let ae3 = this.sumQuantExt(gm.molwProd, gm.molwReact, 100, 100, '%');\n            vg = this.drawTotals('Atom-E', ae1, ae2, ae3);\n            vg.normalise();\n            para = (0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)('<p/>').appendTo(td);\n            (0,_util_dom__WEBPACK_IMPORTED_MODULE_11__.dom)(vg.createSVG()).appendTo(para);\n        }\n    }\n    combineQuant(values, units) {\n        if (values.length == 0)\n            return '?';\n        let str = '';\n        for (let n = 0; n < values.length; n++) {\n            if (n > 0)\n                str += ' + ';\n            if (values[n] == _data_QuantityCalc__WEBPACK_IMPORTED_MODULE_3__.QuantityCalc.UNSPECIFIED) {\n                str += '?';\n            }\n            else {\n                str += (0,_util_util__WEBPACK_IMPORTED_MODULE_12__.formatDouble)(values[n], 4);\n                if (units)\n                    str += ' ' + units;\n            }\n        }\n        return str;\n    }\n    sumQuant(values, units, requireSomething) {\n        if (values.length == 0)\n            return requireSomething ? '?' : '0';\n        let sum = 0;\n        for (let n = 0; n < values.length; n++) {\n            if (values[n] == _data_QuantityCalc__WEBPACK_IMPORTED_MODULE_3__.QuantityCalc.UNSPECIFIED)\n                return '?';\n            sum += values[n];\n        }\n        let ret = (0,_util_util__WEBPACK_IMPORTED_MODULE_12__.formatDouble)(sum, 4);\n        if (units)\n            ret += ' ' + units;\n        return ret;\n    }\n    sumQuantExt(numer, denom, mul, max, units) {\n        if (numer.length == 0 || denom.length == 0)\n            return '?';\n        let sum1 = 0, sum2 = 0;\n        for (let n = 0; n < numer.length; n++) {\n            if (numer[n] == _data_QuantityCalc__WEBPACK_IMPORTED_MODULE_3__.QuantityCalc.UNSPECIFIED)\n                return '?';\n            sum1 += numer[n];\n        }\n        for (let n = 0; n < denom.length; n++) {\n            if (denom[n] == _data_QuantityCalc__WEBPACK_IMPORTED_MODULE_3__.QuantityCalc.UNSPECIFIED)\n                return '?';\n            sum2 += denom[n];\n        }\n        if (sum2 <= 0)\n            return '?';\n        let val = mul * sum1 / sum2;\n        if (!Number.isNaN(max))\n            val = Math.min(val, max);\n        let ret = (0,_util_util__WEBPACK_IMPORTED_MODULE_12__.formatDouble)(val, 4);\n        if (units)\n            ret += ' ' + units;\n        return ret;\n    }\n    drawTotals(heading, over, under, answer) {\n        let vg = new _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_9__.MetaVector();\n        let measure = new _gfx_ArrangeMeasurement__WEBPACK_IMPORTED_MODULE_5__.OutlineMeasurement(0, 0, this.policy.data.pointScale);\n        let sep = ' = ';\n        let fsz = this.policy.data.pointScale * 0.8;\n        let wadHeading = measure.measureText(heading, fsz);\n        let wadOver = measure.measureText(over, fsz), wadUnder = measure.measureText(under, fsz);\n        let wadAnswer = measure.measureText(answer, fsz);\n        let wadSep = measure.measureText(sep, fsz);\n        let x = 0;\n        vg.drawText(x, 0, heading, fsz, 0x000000, _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_9__.TextAlign.Left | _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_9__.TextAlign.Middle);\n        x += wadHeading[0];\n        vg.drawText(x, 0, sep, fsz, 0x000000, _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_9__.TextAlign.Left | _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_9__.TextAlign.Middle);\n        x += wadSep[0];\n        vg.drawText(x, 0, answer, fsz, 0x000000, _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_9__.TextAlign.Left | _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_9__.TextAlign.Middle);\n        x += wadAnswer[0];\n        vg.drawText(x, 0, sep, fsz, 0x000000, _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_9__.TextAlign.Left | _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_9__.TextAlign.Middle);\n        x += wadSep[0];\n        let lw = Math.max(wadOver[0], wadUnder[0]);\n        vg.drawLine(x, 0, x + lw, 0, 0x000000, 1);\n        vg.drawText(x + 0.5 * lw, -2, over, fsz, 0x000000, _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_9__.TextAlign.Centre | _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_9__.TextAlign.Bottom);\n        vg.drawText(x + 0.5 * lw, 2, under, fsz, 0x000000, _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_9__.TextAlign.Centre | _gfx_MetaVector__WEBPACK_IMPORTED_MODULE_9__.TextAlign.Top);\n        return vg;\n    }\n    doiToLink(doi) {\n        if (doi.startsWith('http://') || doi.startsWith('https://'))\n            return doi;\n        let m = EmbedReaction.PTN_DOI1.exec(doi);\n        if (m)\n            return 'http://dx.doi.org/' + m[1];\n        m = EmbedReaction.PTN_DOI2.exec(doi);\n        if (m)\n            return 'http://dx.doi.org/' + m[1];\n        m = EmbedReaction.PTN_ISBN.exec(doi);\n        if (m)\n            return 'ISBN: ' + m[1];\n        return null;\n    }\n}\nEmbedReaction.PTN_DOI1 = /^doi:(\\d+\\.\\d+\\/.*)$/;\nEmbedReaction.PTN_DOI2 = /^(\\d+\\.\\d+\\/.*)$/;\nEmbedReaction.PTN_ISBN = /^(\\d+-\\d+-\\d+-\\d+-\\d+)$/;\n\n\n//# sourceURL=webpack://WebMolKit/./src/ui/EmbedReaction.ts?");

/***/ }),

/***/ "./src/ui/MenuProxy.ts":
/*!*****************************!*\
  !*** ./src/ui/MenuProxy.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MenuProxy\": () => (/* binding */ MenuProxy),\n/* harmony export */   \"MenuProxyWeb\": () => (/* binding */ MenuProxyWeb)\n/* harmony export */ });\n/* harmony import */ var _util_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/dom */ \"./src/util/dom.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _Popup__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Popup */ \"./src/ui/Popup.ts\");\n\n\n\nclass MenuProxy {\n    hasContextMenu() { return false; }\n    openContextMenu(menuItems, event) { }\n}\nclass MenuProxyWeb extends MenuProxy {\n    hasContextMenu() { return true; }\n    openContextMenu(menuItems, event) {\n        let [x, y] = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.eventCoords)(event, document.body);\n        let divCursor = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<div/>').appendTo(document.body).css({ 'position': 'absolute', 'user-select': 'none' });\n        (0,_util_util__WEBPACK_IMPORTED_MODULE_1__.setBoundaryPixels)(divCursor, x - 5, y - 5, 10, 10);\n        let currentFocus = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)(document.activeElement);\n        let popup = new _Popup__WEBPACK_IMPORTED_MODULE_2__.Popup(divCursor);\n        popup.callbackPopulate = () => {\n            popup.bodyDOM().css({ 'user-select': 'none', 'font-size': '16px' });\n            for (let menuItem of menuItems) {\n                let div = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<div/>').appendTo(popup.bodyDOM());\n                if (menuItem == null) {\n                    div.appendHTML('<hr/>');\n                }\n                else if (menuItem.subMenu) {\n                    div.setText(menuItem.label + ' \\u{25B8}');\n                    div.css({ 'cursor': 'pointer' });\n                    let fcn = (event) => {\n                        event.preventDefault();\n                        popup.close();\n                        this.openContextMenu(menuItem.subMenu, event);\n                    };\n                    div.onClick(fcn);\n                    div.onContextMenu(fcn);\n                }\n                else if (menuItem.click) {\n                    div.setText(menuItem.label);\n                    div.onMouseEnter(() => { div.css({ 'background-color': '#D0D0D0' }); });\n                    div.onMouseLeave(() => { div.css({ 'background-color': 'transparent' }); });\n                    div.css({ 'cursor': 'pointer' });\n                    div.onClick(() => {\n                        popup.close();\n                        menuItem.click();\n                    });\n                }\n                else {\n                    div.css({ 'color': '#808080' });\n                    div.setText(menuItem.label);\n                }\n            }\n        };\n        popup.callbackClose = () => {\n            divCursor.remove();\n            currentFocus.grabFocus();\n        };\n        popup.open();\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/ui/MenuProxy.ts?");

/***/ }),

/***/ "./src/ui/OptionList.ts":
/*!******************************!*\
  !*** ./src/ui/OptionList.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"OptionList\": () => (/* binding */ OptionList)\n/* harmony export */ });\n/* harmony import */ var _util_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/dom */ \"./src/util/dom.ts\");\n/* harmony import */ var _util_Theme__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Theme */ \"./src/util/Theme.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _Widget__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Widget */ \"./src/ui/Widget.ts\");\n\n\n\n\nclass OptionList extends _Widget__WEBPACK_IMPORTED_MODULE_3__.Widget {\n    constructor(options, isVertical = false) {\n        super();\n        this.options = options;\n        this.isVertical = isVertical;\n        this.padding = 6;\n        this.htmlLabels = false;\n        this.numCols = 0;\n        this.selidx = 0;\n        this.buttonDiv = [];\n        this.auxCell = [];\n        this.callbackSelect = null;\n        if (options.length == 0)\n            throw 'molsync.ui.OptionList: must provide a list of option labels.';\n        if (!(0,_util_Theme__WEBPACK_IMPORTED_MODULE_1__.hasInlineCSS)('option'))\n            (0,_util_Theme__WEBPACK_IMPORTED_MODULE_1__.installInlineCSS)('option', this.composeCSS());\n    }\n    getSelectedIndex() {\n        return this.selidx;\n    }\n    getSelectedValue() {\n        return this.options[this.selidx];\n    }\n    getAuxiliaryCell(idx) {\n        return this.auxCell[idx].el;\n    }\n    onSelect(callback) {\n        this.callbackSelect = callback;\n    }\n    render(parent) {\n        super.render(parent);\n        this.contentDOM.css({ 'display': 'inline-block', 'baseline-shift': '1.5em' });\n        this.buttonDiv = [];\n        this.auxCell = [];\n        let table = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<table class=\"wmk-option-table\"/>').appendTo(this.contentDOM);\n        let tr = this.isVertical ? null : (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<tr/>').appendTo(table);\n        for (let n = 0; n < this.options.length; n++) {\n            if (this.isVertical || (this.numCols > 0 && n > 0 && n % this.numCols == 0))\n                tr = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<tr/>').appendTo(table);\n            let td = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<td class=\"wmk-option-cell\"/>').appendTo(tr);\n            let div = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<div class=\"wmk-option\"/>').appendTo(td);\n            div.css({ 'padding': `${this.padding}px` });\n            div.onClick(() => this.clickButton(n));\n            this.buttonDiv.push(div);\n            if (this.isVertical) {\n                td = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<td style=\"vertical-align: middle;\"/>').appendTo(tr);\n                this.auxCell.push(td);\n            }\n        }\n        this.updateButtons();\n    }\n    clickButton(idx) {\n        if (idx == this.selidx)\n            return;\n        this.setSelectedIndex(idx);\n        if (this.callbackSelect)\n            this.callbackSelect(idx, this);\n    }\n    setSelectedIndex(idx) {\n        if (this.selidx == idx)\n            return;\n        this.selidx = idx;\n        this.updateButtons();\n    }\n    setSelectedValue(val) {\n        let idx = this.options.indexOf(val);\n        if (idx >= 0)\n            this.setSelectedIndex(idx);\n    }\n    updateButtons() {\n        for (let n = 0; n < this.options.length && n < this.buttonDiv.length; n++) {\n            let div = this.buttonDiv[n];\n            let txt = this.options[n];\n            if (txt.length == 0 && n == this.selidx)\n                div.setText('\\u00A0\\u2716\\u00A0');\n            else if (txt.length == 0)\n                div.setText('\\u00A0\\u00A0\\u00A0');\n            else if (this.htmlLabels)\n                div.setHTML(txt);\n            else\n                div.setText(txt);\n            div.removeClass('wmk-option-unselected wmk-option-selected');\n            if (n != this.selidx)\n                div.addClass('wmk-option-unselected');\n            else\n                div.addClass('wmk-option-selected');\n        }\n    }\n    composeCSS() {\n        let lowlight = (0,_util_util__WEBPACK_IMPORTED_MODULE_2__.colourCode)(_util_Theme__WEBPACK_IMPORTED_MODULE_1__.Theme.lowlight), lowlightEdge1 = (0,_util_util__WEBPACK_IMPORTED_MODULE_2__.colourCode)(_util_Theme__WEBPACK_IMPORTED_MODULE_1__.Theme.lowlightEdge1), lowlightEdge2 = (0,_util_util__WEBPACK_IMPORTED_MODULE_2__.colourCode)(_util_Theme__WEBPACK_IMPORTED_MODULE_1__.Theme.lowlightEdge2);\n        let highlight = (0,_util_util__WEBPACK_IMPORTED_MODULE_2__.colourCode)(_util_Theme__WEBPACK_IMPORTED_MODULE_1__.Theme.highlight), highlightEdge1 = (0,_util_util__WEBPACK_IMPORTED_MODULE_2__.colourCode)(_util_Theme__WEBPACK_IMPORTED_MODULE_1__.Theme.highlightEdge1), highlightEdge2 = (0,_util_util__WEBPACK_IMPORTED_MODULE_2__.colourCode)(_util_Theme__WEBPACK_IMPORTED_MODULE_1__.Theme.highlightEdge2);\n        return `\n\t\t\t.wmk-option\n\t\t\t{\n\t\t\t\tmargin-bottom: 0;\n\t\t\t\tfont-family: 'Open Sans', sans-serif;\n\t\t\t\tfont-size: 14px;\n\t\t\t\tfont-weight: normal;\n\t\t\t\ttext-align: center;\n\t\t\t\twhite-space: nowrap;\n\t\t\t\tline-height: 1.2em;\n\t\t\t\tcursor: pointer;\n\t\t\t}\n\t\t\t.wmk-option-selected\n\t\t\t{\n\t\t\t\tcolor: white;\n\t\t\t\tbackground-color: #008FD2;\n\t\t\t\tbackground-image: linear-gradient(to right bottom, ${lowlightEdge1}, ${lowlightEdge2});\n\t\t\t}\n\t\t\t.wmk-option-unselected\n\t\t\t{\n\t\t\t\tcolor: #333;\n\t\t\t\tbackground-color: white;\n\t\t\t\tbackground-image: linear-gradient(to right bottom, #FFFFFF, #E0E0E0);\n\t\t\t}\n\t\t\t.wmk-option-unselected:hover\n\t\t\t{\n\t\t\t\tbackground-color: #808080;\n\t\t\t\tbackground-image: linear-gradient(to right bottom, #F0F0F0, #D0D0D0);\n\t\t\t}\n\t\t\t.wmk-option-unselected:active\n\t\t\t{\n\t\t\t\tcolor: white;\n\t\t\t\tbackground-color: #00C000;\n\t\t\t\tbackground-image: linear-gradient(to right bottom, ${highlightEdge1}, ${highlightEdge2});\n\t\t\t}\n\t\t\t.wmk-option-table\n\t\t\t{\n\t\t\t\tmargin: 1px;\n\t\t\t\tpadding: 0;\n\t\t\t\tborder-width: 0;\n\t\t\t\tborder-collapse: collapse;\n\t\t\t}\n\t\t\t.wmk-option-cell\n\t\t\t{\n\t\t\t\tmargin: 0;\n\t\t\t\tpadding: 0;\n\t\t\t\tborder-width: 0;\n\t\t\t\tborder-width: 1px;\n\t\t\t\tborder-style: solid;\n\t\t\t\tborder-color: #808080;\n\t\t\t}\n\t\t`;\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/ui/OptionList.ts?");

/***/ }),

/***/ "./src/ui/Popup.ts":
/*!*************************!*\
  !*** ./src/ui/Popup.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Popup\": () => (/* binding */ Popup)\n/* harmony export */ });\n/* harmony import */ var _util_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/dom */ \"./src/util/dom.ts\");\n/* harmony import */ var _util_Theme__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Theme */ \"./src/util/Theme.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _Tooltip__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Tooltip */ \"./src/ui/Tooltip.ts\");\n\n\n\n\nconst CSS_POPUP = `\n\t*.wmk-popup\n\t{\n\t\tfont-family: 'Open Sans', sans-serif;\n\t}\n`;\nclass Popup {\n    constructor(parent) {\n        this.popupBackground = 'white';\n        this.callbackClose = null;\n        this.callbackPopulate = null;\n        this.parent = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.domLegacy)(parent);\n        (0,_util_Theme__WEBPACK_IMPORTED_MODULE_1__.installInlineCSS)('popup', CSS_POPUP);\n    }\n    onClose(callback) {\n        this.callbackClose = callback;\n    }\n    open() {\n        let body = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)(document.documentElement);\n        let zindex = 21000;\n        let bg = this.domObscureBackground = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<div/>').appendTo(body);\n        bg.css({ 'position': 'fixed', 'z-index': zindex });\n        bg.css({ 'left': '0', 'right': '0', 'top': '0', 'bottom': '0' });\n        bg.css({ 'background-color': 'black', 'opacity': 0.2 });\n        let fg = this.domObscureForeground = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<div/>').appendTo(body);\n        fg.css({ 'position': 'fixed', 'z-index': zindex + 1 });\n        fg.css({ 'left': '0', 'right': '0', 'top': '0', 'bottom': '0' });\n        fg.onClick(() => this.close());\n        let pb = this.domPanelBoundary = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<div class=\"wmk-popup\"/>').appendTo(fg);\n        pb.onClick((event) => event.stopPropagation());\n        pb.css({ 'background-color': this.popupBackground, 'border': '1px solid black' });\n        pb.css({ 'position': 'absolute', 'overflow': 'auto' });\n        this.domBody = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<div/>').appendTo(pb).css({ 'padding': '5px' });\n        this.populate();\n        this.positionAndShow();\n    }\n    close() {\n        this.domPanelBoundary.remove();\n        this.domObscureBackground.remove();\n        this.domObscureForeground.remove();\n        if (this.callbackClose)\n            this.callbackClose(this);\n        (0,_Tooltip__WEBPACK_IMPORTED_MODULE_3__.clearTooltip)();\n    }\n    bump() {\n        this.positionAndShow();\n    }\n    bodyDOM() { return this.domBody; }\n    populate() {\n        if (this.callbackPopulate)\n            this.callbackPopulate(this);\n        else\n            this.bodyDOM().setText('Empty popup.');\n    }\n    positionAndShow() {\n        (0,_Tooltip__WEBPACK_IMPORTED_MODULE_3__.clearTooltip)();\n        let winW = window.innerWidth, winH = window.innerHeight;\n        const GAP = 2;\n        let client = this.parent.el.getBoundingClientRect();\n        let wx1 = client.left, wy1 = client.top, wx2 = client.right, wy2 = client.bottom;\n        let pb = this.domPanelBoundary;\n        let maxW = Math.max(wx1, winW - wx2) - 4;\n        pb.css({ 'max-width': maxW + 'px' });\n        let scrollSize = (0,_util_util__WEBPACK_IMPORTED_MODULE_2__.empiricalScrollerSize)();\n        let setPosition = () => {\n            let popW = pb.width(), popH = pb.height();\n            let posX = 0, posY = 0;\n            if (wy2 + GAP + popH < winH)\n                posY = wy2 + GAP;\n            else if (wy1 - GAP - popH > 0)\n                posY = wy1 - GAP - popH;\n            else if (winH - wy2 > wy1) {\n                posY = wy2 + GAP;\n                popH = winH - posY - GAP;\n            }\n            else {\n                posY = GAP;\n                popH = wy1 - posY - GAP;\n            }\n            if (pb.height() > popH)\n                popW += scrollSize.w + 10;\n            if (wx1 + popW < winW)\n                posX = wx1;\n            else if (popW < wx2)\n                posX = wx2 - popW;\n            (0,_util_util__WEBPACK_IMPORTED_MODULE_2__.setBoundaryPixels)(pb, posX, posY, popW, popH);\n        };\n        setPosition();\n        window.setTimeout(() => setPosition());\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/ui/Popup.ts?");

/***/ }),

/***/ "./src/ui/TabBar.ts":
/*!**************************!*\
  !*** ./src/ui/TabBar.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TabBar\": () => (/* binding */ TabBar)\n/* harmony export */ });\n/* harmony import */ var _util_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/dom */ \"./src/util/dom.ts\");\n/* harmony import */ var _util_Theme__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Theme */ \"./src/util/Theme.ts\");\n/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _Widget__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Widget */ \"./src/ui/Widget.ts\");\n\n\n\n\nclass TabBar extends _Widget__WEBPACK_IMPORTED_MODULE_3__.Widget {\n    constructor(options) {\n        super();\n        this.options = options;\n        this.unionHeight = false;\n        this.selidx = 0;\n        this.buttonDiv = [];\n        this.panelDiv = [];\n        this.padding = 6;\n        this.callbackSelect = null;\n        if (!(0,_util_Theme__WEBPACK_IMPORTED_MODULE_1__.hasInlineCSS)('tabbar'))\n            (0,_util_Theme__WEBPACK_IMPORTED_MODULE_1__.installInlineCSS)('tabbar', this.composeCSS());\n    }\n    onSelect(callback) {\n        this.callbackSelect = callback;\n    }\n    getSelectedIndex() {\n        return this.selidx;\n    }\n    getSelectedValue() {\n        return this.options[this.selidx];\n    }\n    getPanelDOM(idxOrName) {\n        let idx = typeof idxOrName == 'number' ? idxOrName : this.options.indexOf(idxOrName);\n        if (idx < 0)\n            return null;\n        return this.panelDiv[idx];\n    }\n    render(parent) {\n        super.render(parent);\n        let grid = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<div/>').appendTo(this.contentDOM).css({ 'display': 'grid' });\n        grid.css({ 'align-items': 'center', 'justify-content': 'start', 'grid-row-gap': '0.5em' });\n        let columns = '[start] 1fr ';\n        for (let n = 0; n < this.options.length; n++)\n            columns += '[btn' + n + '] auto ';\n        columns += '[btnX] 1fr [end]';\n        grid.css({ 'grid-template-columns': columns });\n        let underline = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<div/>').appendTo(grid);\n        underline.css({ 'grid-column': 'start / end', 'grid-row': '1', 'height': '100%' });\n        underline.css({ 'border-bottom': '1px solid #C0C0C0' });\n        for (let n = 0; n < this.options.length; n++) {\n            let outline = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<div class=\"wmk-tabbar-cell\"/>').appendTo(grid);\n            outline.css({ 'grid-column': 'btn' + n, 'grid-row': '1' });\n            let btn = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<div class=\"wmk-tabbar\"/>').appendTo(outline);\n            btn.css({ 'padding': `${this.padding}px` });\n            btn.onClick(() => this.clickButton(n));\n            this.buttonDiv.push(btn);\n            let panel = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<div/>').appendTo(grid);\n            panel.css({ 'grid-column': 'start / end', 'grid-row': '2' });\n            panel.css({ 'align-self': 'start', 'justify-self': 'center', 'width': '100%' });\n            this.panelDiv.push(panel);\n        }\n        this.updateButtons();\n    }\n    clickButton(idx) {\n        if (idx == this.selidx)\n            return;\n        this.setSelectedIndex(idx);\n        if (this.callbackSelect)\n            this.callbackSelect(idx, this);\n    }\n    setSelectedIndex(idx) {\n        if (this.selidx == idx)\n            return;\n        this.selidx = idx;\n        let dom = this.contentDOM;\n        dom.setCSS('min-width', `${dom.width()}px`);\n        this.updateButtons();\n    }\n    setSelectedValue(val) {\n        let idx = this.options.indexOf(val);\n        if (idx >= 0)\n            this.setSelectedIndex(idx);\n    }\n    rotateSelected(dir) {\n        this.setSelectedIndex((this.selidx + dir + this.options.length) % this.options.length);\n    }\n    updateButtons() {\n        for (let n = 0; n < this.options.length && n < this.buttonDiv.length; n++) {\n            let div = this.buttonDiv[n];\n            let txt = this.options[n];\n            if (txt.length == 0 && n == this.selidx)\n                div.setText('\\u00A0\\u2716\\u00A0');\n            else if (txt.length == 0)\n                div.setText('\\u00A0\\u00A0\\u00A0');\n            else\n                div.setText(txt);\n            div.removeClass('wmk-tabbar-unselected wmk-tabbar-selected');\n            if (n != this.selidx)\n                div.addClass('wmk-tabbar-unselected');\n            else\n                div.addClass('wmk-tabbar-selected');\n            if (this.unionHeight)\n                this.panelDiv[n].setCSS('visibility', n == this.selidx ? 'visible' : 'hidden');\n            else\n                this.panelDiv[n].setCSS('display', n == this.selidx ? 'block' : 'none');\n        }\n    }\n    composeCSS() {\n        let lowlight = (0,_util_util__WEBPACK_IMPORTED_MODULE_2__.colourCode)(_util_Theme__WEBPACK_IMPORTED_MODULE_1__.Theme.lowlight), lowlightEdge1 = (0,_util_util__WEBPACK_IMPORTED_MODULE_2__.colourCode)(_util_Theme__WEBPACK_IMPORTED_MODULE_1__.Theme.lowlightEdge1), lowlightEdge2 = (0,_util_util__WEBPACK_IMPORTED_MODULE_2__.colourCode)(_util_Theme__WEBPACK_IMPORTED_MODULE_1__.Theme.lowlightEdge2);\n        let highlight = (0,_util_util__WEBPACK_IMPORTED_MODULE_2__.colourCode)(_util_Theme__WEBPACK_IMPORTED_MODULE_1__.Theme.highlight), highlightEdge1 = (0,_util_util__WEBPACK_IMPORTED_MODULE_2__.colourCode)(_util_Theme__WEBPACK_IMPORTED_MODULE_1__.Theme.highlightEdge1), highlightEdge2 = (0,_util_util__WEBPACK_IMPORTED_MODULE_2__.colourCode)(_util_Theme__WEBPACK_IMPORTED_MODULE_1__.Theme.highlightEdge2);\n        return `\n\t\t\t.wmk-tabbar\n\t\t\t{\n\t\t\t\tmargin-bottom: 0;\n\t\t\t\tfont-family: 'Open Sans', sans-serif;\n\t\t\t\tfont-size: 14px;\n\t\t\t\tfont-weight: normal;\n\t\t\t\ttext-align: center;\n\t\t\t\twhite-space: nowrap;\n\t\t\t\tvertical-align: middle;\n\t\t\t\tcursor: pointer;\n\t\t\t}\n\t\t\t.wmk-tabbar-selected\n\t\t\t{\n\t\t\t\tcolor: white;\n\t\t\t\tbackground-color: #008FD2;\n\t\t\t\tbackground-image: linear-gradient(to right bottom, ${lowlightEdge1}, ${lowlightEdge2});\n\t\t\t}\n\t\t\t.wmk-tabbar-unselected\n\t\t\t{\n\t\t\t\tcolor: #333;\n\t\t\t\tbackground-color: white;\n\t\t\t\tbackground-image: linear-gradient(to right bottom, #FFFFFF, #E0E0E0);\n\t\t\t}\n\t\t\t.wmk-tabbar-unselected:hover\n\t\t\t{\n\t\t\t\tbackground-color: #808080;\n\t\t\t\tbackground-image: linear-gradient(to right bottom, #F0F0F0, #D0D0D0);\n\t\t\t}\n\t\t\t.wmk-tabbar-unselected:active\n\t\t\t{\n\t\t\t\tcolor: white;\n\t\t\t\tbackground-color: #00C000;\n\t\t\t\tbackground-image: linear-gradient(to right bottom, ${highlightEdge1}, ${highlightEdge2});\n\t\t\t}\n\t\t\t.wmk-tabbar-table\n\t\t\t{\n\t\t\t\tmargin: 1px;\n\t\t\t\tpadding: 0;\n\t\t\t\tborder-width: 0;\n\t\t\t\tborder-collapse: collapse;\n\t\t\t}\n\t\t\t.wmk-tabbar-cell\n\t\t\t{\n\t\t\t\tmargin: 0 -1px -1px 0;\n\t\t\t\tpadding: 0;\n\t\t\t\tborder-width: 0;\n\t\t\t\tborder-width: 1px;\n\t\t\t\tborder-style: solid;\n\t\t\t\tborder-color: #808080;\n\t\t\t}\n\t\t`;\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/ui/TabBar.ts?");

/***/ }),

/***/ "./src/ui/Tooltip.ts":
/*!***************************!*\
  !*** ./src/ui/Tooltip.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Tooltip\": () => (/* binding */ Tooltip),\n/* harmony export */   \"addTooltip\": () => (/* binding */ addTooltip),\n/* harmony export */   \"clearTooltip\": () => (/* binding */ clearTooltip),\n/* harmony export */   \"raiseToolTip\": () => (/* binding */ raiseToolTip)\n/* harmony export */ });\n/* harmony import */ var _util_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/dom */ \"./src/util/dom.ts\");\n\nlet globalPopover = null;\nlet globalTooltip = null;\nlet globalPopWatermark = 0;\nfunction addTooltip(parent, bodyHTML, titleHTML, delay) {\n    Tooltip.ensureGlobal();\n    if (parent.jquery)\n        parent = parent[0];\n    let widget = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)(parent);\n    let tooltip = new Tooltip(widget, bodyHTML, titleHTML, delay == null ? 1000 : delay);\n    widget.onMouseEnter(() => tooltip.start());\n    widget.onMouseLeave(() => tooltip.stop());\n}\nfunction raiseToolTip(parent, avoid, bodyHTML, titleHTML) {\n    if (parent.jquery)\n        parent = parent[0];\n    clearTooltip();\n    Tooltip.ensureGlobal();\n    new Tooltip((0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)(parent), bodyHTML, titleHTML, 0).raise(avoid);\n}\nfunction clearTooltip() {\n    if (globalTooltip == null)\n        return;\n    globalPopWatermark++;\n    globalTooltip.lower();\n}\nclass Tooltip {\n    constructor(widget, bodyHTML, titleHTML, delay) {\n        this.widget = widget;\n        this.bodyHTML = bodyHTML;\n        this.titleHTML = titleHTML;\n        this.delay = delay;\n    }\n    static ensureGlobal() {\n        if (globalPopover == null) {\n            globalPopover = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<div/>').css({ 'position': 'absolute', 'z-index': 22000, 'display': 'none' });\n            globalPopover.css({ 'background-color': '#F0F0FF', 'background-image': 'linear-gradient(to right bottom, #FFFFFF, #D0D0FF)' });\n            globalPopover.css({ 'color': 'black', 'border': '1px solid black', 'border-radius': '4px' });\n            globalPopover.appendTo(document.body);\n        }\n    }\n    start() {\n        globalPopover.setCSS('display', 'none');\n        this.watermark = ++globalPopWatermark;\n        window.setTimeout(() => {\n            if (this.watermark == globalPopWatermark)\n                this.raise();\n        }, this.delay);\n    }\n    stop() {\n        if (this.watermark == globalPopWatermark)\n            this.lower();\n        globalPopWatermark++;\n    }\n    raise(avoid) {\n        if (!this.widget.exists())\n            return;\n        globalTooltip = this;\n        let pop = globalPopover;\n        pop.css({ 'max-width': '20em' });\n        pop.empty();\n        let div = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<div/>').appendTo(pop).css({ 'padding': '0.3em' });\n        let hasTitle = this.titleHTML != null && this.titleHTML.length > 0, hasBody = this.bodyHTML != null && this.bodyHTML.length > 0;\n        if (hasTitle)\n            (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<div/>').appendTo(div).setHTML('<b>' + this.titleHTML + '</b>');\n        if (hasTitle && hasBody)\n            div.appendHTML('<hr/>');\n        if (hasBody)\n            (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<div/>').appendTo(div).setHTML(this.bodyHTML);\n        let winW = window.innerWidth, winH = window.innerHeight;\n        const GAP = 2;\n        let boundDiv = this.widget.el.getBoundingClientRect();\n        let wx1 = boundDiv.left, wy1 = boundDiv.top;\n        let wx2 = wx1 + boundDiv.width, wy2 = wy1 + boundDiv.height;\n        if (avoid) {\n            wx1 += avoid.x;\n            wy1 += avoid.y;\n            wx2 = wx1 + avoid.w;\n            wy2 = wy1 + avoid.h;\n        }\n        let setPosition = () => {\n            let popW = pop.width(), popH = pop.height();\n            let posX = 0, posY = 0;\n            if (wx1 + popW < winW)\n                posX = wx1;\n            else if (popW < wx2)\n                posX = wx2 - popW;\n            if (wy2 + GAP + popH < winH)\n                posY = wy2 + GAP;\n            else if (wy1 - GAP - popH > 0)\n                posY = wy1 - GAP - popH;\n            else\n                posY = wy2 + GAP;\n            posX += window.pageXOffset;\n            posY += window.pageYOffset;\n            pop.css({ 'left': `${posX}px`, 'top': `${posY}px` });\n        };\n        setPosition();\n        pop.setCSS('display', 'block');\n        setTimeout(() => setPosition(), 1);\n        let checkParent = () => {\n            if (this.watermark != globalPopWatermark)\n                return;\n            if (!this.widget.isVisible())\n                pop.setCSS('display', 'none');\n            else\n                setTimeout(checkParent, 100);\n        };\n        setTimeout(checkParent, 100);\n    }\n    lower() {\n        let pop = globalPopover;\n        pop.setCSS('display', 'none');\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/ui/Tooltip.ts?");

/***/ }),

/***/ "./src/ui/Widget.ts":
/*!**************************!*\
  !*** ./src/ui/Widget.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Widget\": () => (/* binding */ Widget)\n/* harmony export */ });\n/* harmony import */ var _util_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/dom */ \"./src/util/dom.ts\");\n/* harmony import */ var _Tooltip__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Tooltip */ \"./src/ui/Tooltip.ts\");\n\n\nclass Widget {\n    constructor() {\n        this.tagType = 'div';\n        this.domContent = null;\n    }\n    get contentDOM() { return this.domContent; }\n    render(parent) {\n        if (parent.jquery)\n            parent = parent[0];\n        let tag = this.tagType;\n        this.domContent = (0,_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)(`<${tag}/>`).appendTo(parent);\n    }\n    remove() {\n        if (this.domContent)\n            this.domContent.remove();\n        this.domContent = null;\n    }\n    addTooltip(bodyHTML, titleHTML) {\n        (0,_Tooltip__WEBPACK_IMPORTED_MODULE_1__.addTooltip)(this.contentDOM, bodyHTML, titleHTML);\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/ui/Widget.ts?");

/***/ }),

/***/ "./src/util/Geom.ts":
/*!**************************!*\
  !*** ./src/util/Geom.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Box\": () => (/* binding */ Box),\n/* harmony export */   \"GeomUtil\": () => (/* binding */ GeomUtil),\n/* harmony export */   \"Line\": () => (/* binding */ Line),\n/* harmony export */   \"Oval\": () => (/* binding */ Oval),\n/* harmony export */   \"Pos\": () => (/* binding */ Pos),\n/* harmony export */   \"QuickHull\": () => (/* binding */ QuickHull),\n/* harmony export */   \"RollingBall\": () => (/* binding */ RollingBall),\n/* harmony export */   \"Size\": () => (/* binding */ Size)\n/* harmony export */ });\n/* harmony import */ var _Matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Matrix */ \"./src/util/Matrix.ts\");\n/* harmony import */ var _Triangulation2D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Triangulation2D */ \"./src/util/Triangulation2D.ts\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ \"./src/util/util.ts\");\n/* harmony import */ var _Vec__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Vec */ \"./src/util/Vec.ts\");\n\n\n\n\nclass GeomUtil {\n    static pointInPolygon(x, y, px, py) {\n        if (x < (0,_util__WEBPACK_IMPORTED_MODULE_2__.minArray)(px) || x > (0,_util__WEBPACK_IMPORTED_MODULE_2__.maxArray)(px) || y < (0,_util__WEBPACK_IMPORTED_MODULE_2__.minArray)(py) || y > (0,_util__WEBPACK_IMPORTED_MODULE_2__.maxArray)(py))\n            return false;\n        let sz = px.length;\n        for (let n = 0; n < sz; n++)\n            if (px[n] == x && py[n] == y)\n                return true;\n        let phase = false;\n        for (let n = 0; n < sz; n++) {\n            let x1 = px[n], y1 = py[n], x2 = px[n + 1 < sz ? n + 1 : 0], y2 = py[n + 1 < sz ? n + 1 : 0];\n            if (y > Math.min(y1, y2) && y <= Math.max(y1, y2) && x <= Math.max(x1, x2) && y1 != y2) {\n                let intr = (y - y1) * (x2 - x1) / (y2 - y1) + x1;\n                if (x1 == x2 || x <= intr)\n                    phase = !phase;\n            }\n        }\n        return phase;\n    }\n    static areLinesParallel(x1, y1, x2, y2, x3, y3, x4, y4) {\n        let dxa = x2 - x1, dxb = x4 - x3, dya = y2 - y1, dyb = y4 - y3;\n        return ((0,_util__WEBPACK_IMPORTED_MODULE_2__.realEqual)(dxa, dxb) && (0,_util__WEBPACK_IMPORTED_MODULE_2__.realEqual)(dya, dyb)) || ((0,_util__WEBPACK_IMPORTED_MODULE_2__.realEqual)(dxa, -dxb) && (0,_util__WEBPACK_IMPORTED_MODULE_2__.realEqual)(dya, -dyb));\n    }\n    static lineIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {\n        let u = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));\n        return [x1 + u * (x2 - x1), y1 + u * (y2 - y1)];\n    }\n    static isPointOnLineSeg(px, py, x1, y1, x2, y2) {\n        if (px < Math.min(x1, x2) || px > Math.max(x1, x2) || py < Math.min(y1, y2) || py > Math.max(y1, y2))\n            return false;\n        if ((px == x1 && py == y1) || (px == x2 && py == y2))\n            return true;\n        let dx = x2 - x1, dy = y2 - y1;\n        if (Math.abs(dx) > Math.abs(dy))\n            return (0,_util__WEBPACK_IMPORTED_MODULE_2__.realEqual)(py, (dy / dx) * (px - x1) + y1);\n        else\n            return (0,_util__WEBPACK_IMPORTED_MODULE_2__.realEqual)(px, (dx / dy) * (py - y1) + x1);\n    }\n    static pointLineDistance(px, py, x1, y1, x2, y2) {\n        let dx = x2 - x1, dy = y2 - y1;\n        return Math.abs(dy * px - dx * py + x2 * y1 - y2 * x1) / (0,_util__WEBPACK_IMPORTED_MODULE_2__.norm_xy)(dx, dy);\n    }\n    static pointLineSegDistance(px, py, x1, y1, x2, y2) {\n        let dx = x2 - x1, dy = y2 - y1;\n        let t = ((px - x1) * dx + (py - y1) * dy) / (0,_util__WEBPACK_IMPORTED_MODULE_2__.norm2_xy)(dx, dy);\n        t = Math.max(0, Math.min(1, t));\n        let tx = x1 + t * dx, ty = y1 + t * dy;\n        return (0,_util__WEBPACK_IMPORTED_MODULE_2__.norm_xy)(px - tx, py - ty);\n    }\n    static doLineSegsIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {\n        if (Math.max(x1, x2) < Math.min(x3, x4) || Math.max(y1, y2) < Math.min(y3, y4))\n            return false;\n        if (Math.min(x1, x2) > Math.max(x3, x4) || Math.min(y1, y2) > Math.max(y3, y4))\n            return false;\n        if ((x1 == x3 && y1 == y3) || (x1 == x4 && y1 == y4) || (x2 == x3 && y2 == y3) || (x2 == x4 && y2 == y4))\n            return true;\n        if ((x1 == x2 || x3 == x4) && (x1 == x3 || x1 == x4 || x2 == x3 || x2 == x4))\n            return true;\n        if ((y1 == y2 || y3 == y4) && (y1 == y3 || y1 == y4 || y2 == y3 || y2 == y4))\n            return true;\n        let x4_x3 = x4 - x3, y4_y3 = y4 - y3, x2_x1 = x2 - x1, y2_y1 = y2 - y1, x1_x3 = x1 - x3, y1_y3 = y1 - y3;\n        let nx = x4_x3 * y1_y3 - y4_y3 * x1_x3;\n        let ny = x2_x1 * y1_y3 - y2_y1 * x1_x3;\n        let dn = y4_y3 * x2_x1 - x4_x3 * y2_y1;\n        if (dn == 0)\n            return false;\n        if (dn < 0) {\n            dn = -dn;\n            nx = -nx;\n            ny = -ny;\n        }\n        return nx >= 0 && nx <= dn && ny >= 0 && ny <= dn;\n    }\n    static rectsIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {\n        if (x1 <= x2 && x1 + w1 >= x2 + w2 && y1 <= y2 && y1 + h1 >= y2 + h2)\n            return true;\n        if (x2 <= x1 && x2 + w2 >= x1 + w1 && y2 <= y1 && y2 + h2 >= y1 + h1)\n            return true;\n        if (x1 + w1 < x2 || x2 + w2 < x1 || y1 + h1 < y2 || y2 + h2 < y1)\n            return false;\n        return true;\n    }\n    static sortAngles(theta) {\n        if (theta == null || theta.length < 2)\n            return theta;\n        theta = theta.slice(0);\n        for (let n = 0; n < theta.length; n++)\n            theta[n] = (0,_util__WEBPACK_IMPORTED_MODULE_2__.angleNorm)(theta[n]);\n        if (theta.length == 2) {\n            if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.angleDiffPos)(theta[1], theta[0]) > Math.PI)\n                return [theta[1], theta[0]];\n            return theta;\n        }\n        _Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.sort(theta);\n        while (true) {\n            let a = theta[theta.length - 1], b = theta[0], c = theta[1];\n            if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.angleDiff)(b, a) <= (0,_util__WEBPACK_IMPORTED_MODULE_2__.angleDiff)(c, b))\n                break;\n            for (let n = theta.length - 1; n > 0; n--)\n                theta[n] = theta[n - 1];\n            theta[0] = a;\n        }\n        return theta;\n    }\n    static idxSortAngles(theta) {\n        const sz = _Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.len(theta);\n        if (theta == null || sz < 2)\n            return _Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.identity0(sz);\n        if (sz == 2) {\n            if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.angleDiffPos)(theta[1], theta[0]) > Math.PI)\n                return [1, 0];\n            else\n                return [0, 1];\n        }\n        theta = _Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.duplicate(theta);\n        for (let n = 0; n < sz; n++)\n            theta[n] = (0,_util__WEBPACK_IMPORTED_MODULE_2__.angleNorm)(theta[n]);\n        let idx = _Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.idxSort(theta);\n        while (true) {\n            let a = theta[idx[sz - 1]], b = theta[idx[0]], c = theta[idx[1]];\n            if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.angleDiff)(b, a) <= (0,_util__WEBPACK_IMPORTED_MODULE_2__.angleDiff)(c, b))\n                break;\n            let last = idx.pop();\n            idx.unshift(last);\n        }\n        return idx;\n    }\n    static uniqueAngles(theta, threshold) {\n        let ang = GeomUtil.sortAngles(theta), ret = [];\n        ret.push(ang[0]);\n        for (let n = 1; n < ang.length; n++) {\n            if (Math.abs((0,_util__WEBPACK_IMPORTED_MODULE_2__.angleDiff)(ang[n], ang[n - 1])) > threshold)\n                ret.push(ang[n]);\n        }\n        return ret;\n    }\n    static thetaObtuse(th1, th2) {\n        let dth = th2 - th1;\n        while (dth < -Math.PI)\n            dth += 2 * Math.PI;\n        while (dth > Math.PI)\n            dth -= 2 * Math.PI;\n        return dth > 0 ? th1 - 0.5 * (2 * Math.PI - dth) : th1 + 0.5 * (2 * Math.PI + dth);\n    }\n    static emergentAngle(theta) {\n        let len = theta.length;\n        if (len == 1)\n            return theta[0];\n        if (len == 2)\n            return 0.5 * (theta[0] + theta[1]);\n        _Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.sort(theta);\n        let bottom = 0;\n        let behind = (0,_util__WEBPACK_IMPORTED_MODULE_2__.angleDiffPos)(theta[0], theta[len - 1]);\n        for (let n = 1; n < len; n++) {\n            let delta = (0,_util__WEBPACK_IMPORTED_MODULE_2__.angleDiffPos)(theta[n], theta[n - 1]);\n            if (delta > behind) {\n                bottom = n;\n                behind = delta;\n            }\n        }\n        let sum = 0;\n        for (let n = 0; n < len; n++) {\n            let delta = theta[n] - theta[bottom];\n            if (delta < 0)\n                delta += _util__WEBPACK_IMPORTED_MODULE_2__.TWOPI;\n            sum += delta;\n        }\n        return sum / len + theta[bottom];\n    }\n    static dotProduct(v1, v2) {\n        return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];\n    }\n    static crossProduct(v1, v2) {\n        const x = v1[1] * v2[2] - v1[2] * v2[1];\n        const y = v1[2] * v2[0] - v1[0] * v2[2];\n        const z = v1[0] * v2[1] - v1[1] * v2[0];\n        return [x, y, z];\n    }\n    static affineTranslate(dx, dy) {\n        return [[1, 0, dx], [0, 1, dy], [0, 0, 1]];\n    }\n    static affineMirror(xaxis, yaxis) {\n        return [[xaxis ? -1 : 1, 0, 0], [0, yaxis ? -1 : 1, 0], [0, 0, 1]];\n    }\n    static affineScale(sx, sy) {\n        return [[sx, 0, 0], [0, sy, 0], [0, 0, 1]];\n    }\n    static affineRotate(theta) {\n        let cos = Math.cos(theta), sin = Math.sin(theta);\n        return [[cos, -sin, 0], [sin, cos, 0], [0, 0, 1]];\n    }\n    static affineCompose(A, B) {\n        let tfm = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];\n        let Acol = [0, 0, 0];\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++)\n                Acol[k] = A[k][j];\n            for (let i = 0; i < 3; i++) {\n                let Brow = B[i];\n                let s = 0;\n                for (let k = 0; k < 3; k++)\n                    s += Acol[k] * Brow[k];\n                tfm[i][j] = s;\n            }\n        }\n        return tfm;\n    }\n    static applyAffine(x, y, tfm) {\n        return [x * tfm[0][0] + y * tfm[0][1] + tfm[0][2], x * tfm[1][0] + y * tfm[1][1] + tfm[1][2]];\n    }\n    static isAffineMirror(tfm) {\n        let a = tfm[0][0], b = tfm[0][1], c = tfm[0][2];\n        let d = tfm[1][0], e = tfm[1][1], f = tfm[1][2];\n        let g = tfm[2][0], h = tfm[2][1], i = tfm[2][2];\n        return a * e * i + b * f * g + c * d * h - c * e * g - b * d * i - a * f * h < 0;\n    }\n    static magnitude2(v) {\n        return v[0] * v[0] + v[1] * v[1] + v[2] * v[2];\n    }\n    static magnitude(v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);\n    }\n    static dist2(v1, v2) {\n        let dx = v1[0] - v2[0], dy = v1[1] - v2[1], dz = v1[2] - v2[2];\n        return dx * dx + dy * dy + dz * dz;\n    }\n    static dist(v1, v2) {\n        let dx = v1[0] - v2[0], dy = v1[1] - v2[1], dz = v1[2] - v2[2];\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n    static normalise(v) {\n        const dsq = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];\n        if (dsq == 0)\n            return;\n        const inv = 1.0 / Math.sqrt(dsq);\n        v[0] *= inv;\n        v[1] *= inv;\n        v[2] *= inv;\n    }\n    static normalised(v) {\n        let ret = v.slice(0);\n        this.normalise(ret);\n        return ret;\n    }\n    static acuteAngle(v1, v2) {\n        let mag1 = this.magnitude(v1), mag2 = this.magnitude(v2);\n        if (mag1 == 0 || mag2 == 0)\n            return 0;\n        let dot = this.dotProduct(v1, v2);\n        let cosTheta = dot / (mag1 * mag2);\n        cosTheta = Math.max(-1, Math.min(1, cosTheta));\n        return Math.acos(cosTheta);\n    }\n    static arcControlPoints(rad, x1, y1, x2, y2) {\n        let t1x = -y1, t1y = x1;\n        let t2x = y2, t2y = -x2;\n        let dx = 0.5 * (x1 + x2);\n        let dy = 0.5 * (y1 + y2);\n        let tx = 3 / 8 * (t1x + t2x);\n        let ty = 3 / 8 * (t1y + t2y);\n        let a = tx * tx + ty * ty;\n        let b = dx * tx + dy * ty;\n        let c = dx * dx + dy * dy - rad * rad;\n        let D = b * b - a * c;\n        let k = (Math.sqrt(D) - b) / a;\n        return [x1 + k * t1x, y1 + k * t1y, x2 + k * t2x, y2 + k * t2y];\n    }\n    static fitCircle(x, y) {\n        let dsq = Number.POSITIVE_INFINITY;\n        for (let n = 0; n < x.length; n++)\n            dsq = Math.min(dsq, (0,_util__WEBPACK_IMPORTED_MODULE_2__.norm2_xy)(x[n], y[n]));\n        return Math.sqrt(dsq);\n    }\n    static fitEllipse(px, py, minX, minY, maxX, maxY) {\n        let bestW = 0.5 * this.fitCircle(px, py), bestH = bestW, bestScore = bestW * bestH;\n        let x = _Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.concat(px, [minX, maxX, 0, 0]);\n        let y = _Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.concat(py, [0, 0, minY, maxY]);\n        const sz = x.length;\n        let shrinkToFit = (whs) => {\n            let dmin = Number.POSITIVE_INFINITY;\n            let invW2 = 1.0 / (whs[0] * whs[0]), invH2 = 1.0 / (whs[1] * whs[1]);\n            for (let n = 0; n < sz; n++)\n                dmin = Math.min(dmin, Math.sqrt(x[n] * x[n] * invW2 + y[n] * y[n] * invH2));\n            if (dmin < 1) {\n                whs[0] *= dmin;\n                whs[1] *= dmin;\n            }\n            whs[2] = whs[0] * whs[1];\n        };\n        let mul = 1;\n        let whsX = [0, 0, 0], whsY = [0, 0, 0];\n        while (mul > 0.001) {\n            whsX[0] = bestW * (1 + mul);\n            whsX[1] = bestH;\n            shrinkToFit(whsX);\n            whsY[0] = bestW;\n            whsY[1] = bestH * (1 + mul);\n            shrinkToFit(whsY);\n            let anything = false;\n            if (whsX[2] > bestScore) {\n                bestW = whsX[0];\n                bestH = whsX[1];\n                bestScore = whsX[2];\n                anything = true;\n            }\n            if (whsY[2] > bestScore) {\n                bestW = whsY[0];\n                bestH = whsY[1];\n                bestScore = whsY[2];\n                anything = true;\n            }\n            if (!anything)\n                mul *= 0.6;\n        }\n        return [bestW, bestH];\n    }\n    static superimpose(ax, ay, bx, by) {\n        let sz = ax.length;\n        if (sz == 1) {\n            let dx = bx[0] - ax[0], dy = by[0] - ay[0];\n            return [[1, 0, dx], [0, 1, dy], [0, 0, 1]];\n        }\n        if (sz == 2) {\n            let thetaA = Math.atan2(ay[1] - ay[0], ax[1] - ax[0]), thetaB = Math.atan2(by[1] - by[0], bx[1] - bx[0]);\n            let delta = (0,_util__WEBPACK_IMPORTED_MODULE_2__.angleDiff)(thetaB, thetaA), cos = Math.cos(delta), sin = Math.sin(delta);\n            let rot00 = cos, rot01 = -sin;\n            let rot10 = sin, rot11 = cos;\n            let acx = 0.5 * (ax[0] + ax[1]), acy = 0.5 * (ay[0] + ay[1]);\n            let bcx = 0.5 * (bx[0] + bx[1]), bcy = 0.5 * (by[0] + by[1]);\n            let rax = rot00 * acx + rot01 * acy;\n            let ray = rot10 * acx + rot11 * acy;\n            return [[rot00, rot01, bcx - rax], [rot10, rot11, bcy - ray], [0, 0, 1]];\n        }\n        let invsz = 1.0 / sz;\n        let acx = _Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.sum(ax) * invsz, acy = _Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.sum(ay) * invsz;\n        let bcx = _Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.sum(bx) * invsz, bcy = _Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.sum(by) * invsz;\n        let mtxA = new _Matrix__WEBPACK_IMPORTED_MODULE_0__.Matrix(3, sz), mtxB = new _Matrix__WEBPACK_IMPORTED_MODULE_0__.Matrix(3, sz);\n        for (let n = 0; n < sz; n++) {\n            mtxA.set(0, n, ax[n] - acx);\n            mtxA.set(1, n, ay[n] - acy);\n            mtxA.set(2, n, 0);\n            mtxB.set(0, n, bx[n] - bcx);\n            mtxB.set(1, n, by[n] - bcy);\n            mtxB.set(2, n, 0);\n        }\n        let cov = mtxA.times(mtxB.transpose());\n        let svd = new _Matrix__WEBPACK_IMPORTED_MODULE_0__.SingularValueDecomposition(cov);\n        let rotate = svd.getV().times(svd.getU().transpose());\n        let rot00 = rotate.get(0, 0), rot01 = rotate.get(0, 1);\n        let rot10 = rotate.get(1, 0), rot11 = rotate.get(1, 1);\n        let rax = rot00 * acx + rot01 * acy;\n        let ray = rot10 * acx + rot11 * acy;\n        return [[rot00, rot01, bcx - rax], [rot10, rot11, bcy - ray], [0, 0, 1]];\n    }\n    static convexHull(x, y, flatness) {\n        let algo = new QuickHull(x, y, (0,_util__WEBPACK_IMPORTED_MODULE_2__.sqr)(flatness * 0.1));\n        return [algo.hullX, algo.hullY];\n    }\n    static outlinePolygon(x, y, diameter) {\n        let del = new _Triangulation2D__WEBPACK_IMPORTED_MODULE_1__.Triangulation2D(x, y);\n        let concave = del.trimConcave(diameter);\n        let idx = del.traceOutline(concave);\n        return [_Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.idxGet(x, idx), _Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.idxGet(y, idx)];\n    }\n}\nclass QuickHull {\n    constructor(x, y, threshSq) {\n        this.x = x;\n        this.y = y;\n        this.threshSq = threshSq;\n        this.hsz = 0;\n        this.hullX = [];\n        this.hullY = [];\n        const sz = x.length;\n        let l = 0, r = 0;\n        for (let n = 0; n < sz; n++) {\n            if (x[r] > x[n] || (x[r] == x[n] && y[r] > y[n]))\n                r = n;\n            if (x[l] < x[n] || (x[l] == x[n] && y[l] < y[n]))\n                l = n;\n        }\n        let al1 = [], al2 = [];\n        for (let n = 0; n < sz; n++) {\n            if (n != l && n != r) {\n                if (this.right(r, l, n) > 0)\n                    al1.push(n);\n                else\n                    al2.push(n);\n            }\n        }\n        this.hullX.push(x[r]);\n        this.hullY.push(y[r]);\n        this.quickHull(r, l, al1);\n        this.hullX.push(x[l]);\n        this.hullY.push(y[l]);\n        this.quickHull(l, r, al2);\n        for (let n = 0; n < this.hullX.length - 1;) {\n            if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.norm2_xy)(this.hullX[n] - this.hullY[n + 1], this.hullY[n] - this.hullY[n + 1]) < threshSq) {\n                this.hullX.splice(n + 1, 1);\n                this.hullY.splice(n + 1, 1);\n            }\n            else\n                n++;\n        }\n    }\n    quickHull(a, b, al) {\n        if (al.length == 0)\n            return;\n        let c = this.furthestPoint(a, b, al);\n        let al1 = [], al2 = [];\n        for (let n = 0; n < al.length; n++) {\n            let p = al[n];\n            if (p == a || p == b)\n                continue;\n            if (this.right(a, c, p) > 0)\n                al1.push(p);\n            else if (this.right(c, b, p) > 0)\n                al2.push(p);\n        }\n        this.quickHull(a, c, al1);\n        this.hullX.push(this.x[c]);\n        this.hullY.push(this.y[c]);\n        this.quickHull(c, b, al2);\n    }\n    right(a, b, p) {\n        const x = this.x, y = this.y;\n        return (x[a] - x[b]) * (y[p] - y[b]) - (x[p] - x[b]) * (y[a] - y[b]);\n    }\n    distance(a, b, p) {\n        const x = this.x, y = this.y;\n        let u = ((x[p] - x[a]) * (x[b] - x[a]) + (y[p] - y[a]) * (y[b] - y[a])) / ((x[b] - x[a]) * (x[b] - x[a]) + (y[b] - y[a]) * (y[b] - y[a]));\n        let ux = x[a] + u * (x[b] - x[a]);\n        let uy = y[a] + u * (y[b] - y[a]);\n        return ((ux - x[p]) * (ux - x[p]) + (uy - y[p]) * (uy - y[p]));\n    }\n    furthestPoint(a, b, al) {\n        let maxDist = -1;\n        let maxPos = -1;\n        for (let n = 0; n < al.length; n++) {\n            let p = al[n];\n            if (p == a || p == b)\n                continue;\n            let dist = this.distance(a, b, p);\n            if (dist > maxDist) {\n                maxDist = dist;\n                maxPos = p;\n            }\n        }\n        return maxPos;\n    }\n}\nclass RollingBall {\n    constructor(x, y, diameter) {\n        this.x = x;\n        this.y = y;\n        this.sequence = [];\n        const sz = x.length;\n        const threshSq = diameter * diameter;\n        let first = _Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.idxMax(x), latest = first;\n        let direction = 0.0;\n        let visited = _Vec__WEBPACK_IMPORTED_MODULE_3__.Vec.booleanArray(false, sz);\n        this.sequence.push(first);\n        let roll = () => {\n            let bestIdx = -1;\n            let bestDelta = 0, bestTheta = 0;\n            for (let n = 0; n < sz; n++)\n                if (n != latest && !visited[n]) {\n                    let dx = x[n] - x[latest], dy = y[n] - y[latest];\n                    let dsq = (0,_util__WEBPACK_IMPORTED_MODULE_2__.norm2_xy)(dx, dy);\n                    if (dsq == 0 || dsq > threshSq)\n                        continue;\n                    let theta = Math.atan2(dy, dx), delta = (0,_util__WEBPACK_IMPORTED_MODULE_2__.angleDiffPos)(theta, direction);\n                    if (bestIdx < 0 || delta < bestDelta) {\n                        bestIdx = n;\n                        bestDelta = delta;\n                        bestTheta = theta;\n                    }\n                }\n            if (bestIdx < 0)\n                return -1;\n            direction = (0,_util__WEBPACK_IMPORTED_MODULE_2__.angleNorm)(bestTheta - 0.5 * Math.PI);\n            visited[bestIdx] = true;\n            return bestIdx;\n        };\n        while (true) {\n            let next = roll();\n            if (next < 0) {\n                this.sequence = null;\n                return;\n            }\n            if (next == first)\n                break;\n            this.sequence.push(next);\n            latest = next;\n        }\n    }\n    sequencePos() {\n        if (!this.sequence)\n            return null;\n        let posList = [];\n        for (let n of this.sequence)\n            posList.push(new Pos(this.x[n], this.y[n]));\n        return posList;\n    }\n    sequenceXY() {\n        if (!this.sequence)\n            return [null, null];\n        let px = [], py = [];\n        for (let n of this.sequence) {\n            px.push(this.x[n]);\n            py.push(this.y[n]);\n        }\n        return [px, py];\n    }\n}\nclass Pos {\n    constructor(x, y) {\n        this.x = x == null ? 0 : x;\n        this.y = y == null ? 0 : y;\n    }\n    static zero() { return new Pos(); }\n    static fromArray(src) { return new Pos(src[0], src[1]); }\n    clone() { return new Pos(this.x, this.y); }\n    equals(other) { return this.x == other.x && this.y == other.y; }\n    scaleBy(mag) {\n        if (mag == 1)\n            return;\n        this.x *= mag;\n        this.y *= mag;\n    }\n    offsetBy(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n    }\n    withScaleBy(mag) {\n        return new Pos(this.x * mag, this.y * mag);\n    }\n    withOffsetBy(dx, dy) {\n        return new Pos(this.x + dx, this.y + dy);\n    }\n    toString() { return '[' + this.x + ',' + this.y + ']'; }\n}\nclass Size {\n    constructor(w, h) {\n        this.w = w == null ? 0 : w;\n        this.h = h == null ? 0 : h;\n    }\n    static zero() { return new Size(); }\n    static fromArray(src) { return new Size(src[0], src[1]); }\n    clone() { return new Size(this.w, this.h); }\n    equals(other) { return this.w == other.w && this.h == other.h; }\n    isZero() { return this.w == 0 && this.h == 0; }\n    scaleBy(mag) {\n        if (mag == 1)\n            return;\n        this.w *= mag;\n        this.h *= mag;\n    }\n    fitInto(maxW, maxH) {\n        let scale = 1;\n        if (this.w > maxW)\n            scale = maxW / this.w;\n        if (this.h > maxH)\n            scale = Math.min(scale, maxH / this.h);\n        if (scale < 1)\n            this.scaleBy(scale);\n    }\n    withScaleBy(mag) {\n        return new Size(this.w * mag, this.h * mag);\n    }\n    toString() { return '[' + this.w + ',' + this.h + ']'; }\n}\nclass Box {\n    constructor(x, y, w, h) {\n        this.x = x == null ? 0 : x;\n        this.y = y == null ? 0 : y;\n        this.w = w == null ? 0 : w;\n        this.h = h == null ? 0 : h;\n    }\n    static zero() { return new Box(); }\n    static fromSize(sz) { return new Box(0, 0, sz.w, sz.h); }\n    static fromOval(oval) { return new Box(oval.cx - oval.rw, oval.cy - oval.rh, 2 * oval.rw, 2 * oval.rh); }\n    static fromArray(src) { return new Box(src[0], src[1], src[2], src[3]); }\n    clone() { return new Box(this.x, this.y, this.w, this.h); }\n    equals(other) { return this.x == other.x && this.y == other.y && this.w == other.w && this.h == other.h; }\n    getPos() { return new Pos(this.x, this.y); }\n    setPos(pos) {\n        this.x = pos.x;\n        this.y = pos.y;\n    }\n    getSize() { return new Size(this.w, this.h); }\n    setSize(sz) {\n        this.w = sz.w;\n        this.h = sz.h;\n    }\n    isZero() { return this.w == 0 && this.h == 0; }\n    minX() { return this.x; }\n    minY() { return this.y; }\n    midX() { return this.x + 0.5 * this.w; }\n    midY() { return this.y + 0.5 * this.h; }\n    maxX() { return this.x + this.w; }\n    maxY() { return this.y + this.h; }\n    area() { return this.w * this.h; }\n    scaleBy(mag) {\n        if (mag == 1)\n            return;\n        this.x *= mag;\n        this.y *= mag;\n        this.w *= mag;\n        this.h *= mag;\n    }\n    offsetBy(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n    }\n    grow(bx, by) {\n        this.x -= bx;\n        this.y -= by;\n        this.w += 2 * bx;\n        this.h += 2 * by;\n    }\n    withScaleBy(mag) {\n        return new Box(this.x * mag, this.y * mag, this.w * mag, this.h * mag);\n    }\n    withOffsetBy(dx, dy) {\n        return new Box(this.x + dx, this.y + dy, this.w, this.h);\n    }\n    withGrow(bx, by) {\n        return new Box(this.x - bx, this.y - by, this.w + 2 * bx, this.h + 2 * by);\n    }\n    intersects(other) {\n        return GeomUtil.rectsIntersect(this.x, this.y, this.w, this.h, other.x, other.y, other.w, other.h);\n    }\n    intersection(other) {\n        let x1 = this.x, x2 = x1 + this.w, y1 = this.y, y2 = y1 + this.h;\n        let x3 = other.x, x4 = x3 + other.w, y3 = other.y, y4 = y3 + other.h;\n        let x5 = Math.max(x1, x3), y5 = Math.max(y1, y3), x6 = Math.min(x2, x4), y6 = Math.min(y2, y4);\n        return new Box(x5, y5, x6 - x5, y6 - y5);\n    }\n    contains(x, y) {\n        return x >= this.x && x < this.x + this.w && y >= this.y && y < this.y + this.h;\n    }\n    union(other) {\n        let x1 = Math.min(this.x, other.x), x2 = Math.max(this.x + this.w, other.x + other.w);\n        let y1 = Math.min(this.y, other.y), y2 = Math.max(this.y + this.h, other.y + other.h);\n        return new Box(x1, y1, x2 - x1, y2 - y1);\n    }\n    isEmpty() { return this.w == 0 && this.h == 0; }\n    notEmpty() { return this.w > 0 || this.h > 0; }\n    toString() { return '[' + this.x + ',' + this.y + ';' + this.w + ',' + this.h + ']'; }\n}\nclass Oval {\n    constructor(cx, cy, rw, rh) {\n        this.cx = cx == null ? 0 : cx;\n        this.cy = cy == null ? 0 : cy;\n        this.rw = rw == null ? 0 : rw;\n        this.rh = rh == null ? 0 : rh;\n    }\n    static zero() { return new Oval(); }\n    static fromBox(box) { return new Oval(box.x + 0.5 * box.w, box.y + 0.5 * box.h, 0.5 * box.w, 0.5 * box.h); }\n    static fromArray(src) { return new Oval(src[0], src[1], src[2], src[3]); }\n    clone() { return new Oval(this.cx, this.cy, this.rw, this.rh); }\n    setCentre(pos) {\n        this.cx = pos.x;\n        this.cy = pos.y;\n    }\n    setRadius(sz) {\n        this.rw = sz.w;\n        this.rh = sz.h;\n    }\n    minX() { return this.cx - this.rw; }\n    minY() { return this.cy - this.rh; }\n    maxX() { return this.cx + this.rw; }\n    maxY() { return this.cy + this.rh; }\n    scaleBy(mag) {\n        if (mag == 1)\n            return;\n        this.cx *= mag;\n        this.cy *= mag;\n        this.rw *= mag;\n        this.rh *= mag;\n    }\n    offsetBy(dx, dy) {\n        this.cx += dx;\n        this.cy += dy;\n    }\n    withScaleBy(mag) {\n        return new Oval(this.cx * mag, this.cy * mag, this.rw * mag, this.rh * mag);\n    }\n    withOffsetBy(dx, dy) {\n        return new Oval(this.cx + dx, this.cy + dy, this.rw, this.rh);\n    }\n    toString() { return '[' + this.cx + ',' + this.cy + ';' + this.rw + ',' + this.rh + ']'; }\n}\nclass Line {\n    constructor(x1, y1, x2, y2) {\n        this.x1 = x1 == null ? 0 : x1;\n        this.y1 = y1 == null ? 0 : y1;\n        this.x2 = x2 == null ? 0 : x2;\n        this.y2 = y2 == null ? 0 : y2;\n    }\n    static zero() { return new Line(); }\n    clone() { return new Line(this.x1, this.y1, this.x2, this.y2); }\n    setPos1(pos) {\n        this.x1 = pos.x;\n        this.y1 = pos.y;\n    }\n    setPos2(pos) {\n        this.x2 = pos.x;\n        this.y2 = pos.y;\n    }\n    minX() { return Math.min(this.x1, this.x2); }\n    minY() { return Math.min(this.y1, this.y2); }\n    maxX() { return Math.max(this.x1, this.x2); }\n    maxY() { return Math.max(this.y1, this.y2); }\n    scaleBy(mag) {\n        if (mag == 1)\n            return;\n        this.x1 *= mag;\n        this.y1 *= mag;\n        this.x2 *= mag;\n        this.y2 *= mag;\n    }\n    offsetBy(dx, dy) {\n        this.x1 += dx;\n        this.y1 += dy;\n        this.x2 += dx;\n        this.y2 += dy;\n    }\n    toString() { return '[' + this.x1 + ',' + this.y1 + ';' + this.x2 + ',' + this.y2 + ']'; }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/util/Geom.ts?");

/***/ }),

/***/ "./src/util/Matrix.ts":
/*!****************************!*\
  !*** ./src/util/Matrix.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Matrix\": () => (/* binding */ Matrix),\n/* harmony export */   \"SingularValueDecomposition\": () => (/* binding */ SingularValueDecomposition)\n/* harmony export */ });\n/* harmony import */ var _Vec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vec */ \"./src/util/Vec.ts\");\n\nclass Matrix {\n    constructor(m, n, s = 0) {\n        this.m = m;\n        this.n = n;\n        if (m == 0)\n            return;\n        this.A = new Array(m);\n        for (let i = 0; i < m; i++)\n            this.A[i] = _Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.numberArray(s, n);\n    }\n    static fromArray(A) {\n        let mtx = new Matrix(0, 0);\n        mtx.A = A;\n        mtx.m = A.length;\n        mtx.n = A[0].length;\n        return mtx;\n    }\n    clone() {\n        const { A, m, n } = this;\n        let mtx = new Matrix(m, n);\n        for (let i = 0; i < m; i++)\n            for (let j = 0; j < n; j++)\n                mtx.A[i][j] = A[i][j];\n        return mtx;\n    }\n    get numRows() { return this.m; }\n    get numCols() { return this.n; }\n    get(i, j) { return this.A[i][j]; }\n    set(i, j, v) { this.A[i][j] = v; }\n    transpose() {\n        const { A, m, n } = this;\n        let X = new Matrix(n, m);\n        const C = X.A;\n        for (let i = 0; i < m; i++)\n            for (let j = 0; j < n; j++)\n                C[j][i] = A[i][j];\n        return X;\n    }\n    norm1() {\n        const { A, m, n } = this;\n        let f = 0;\n        for (let j = 0; j < n; j++) {\n            let s = 0;\n            for (let i = 0; i < m; i++)\n                s += Math.abs(A[i][j]);\n            f = Math.max(f, s);\n        }\n        return f;\n    }\n    normInf() {\n        const { A, m, n } = this;\n        let f = 0;\n        for (let i = 0; i < m; i++) {\n            let s = 0;\n            for (let j = 0; j < n; j++)\n                s += Math.abs(A[i][j]);\n            f = Math.max(f, s);\n        }\n        return f;\n    }\n    uminus() {\n        const { A, m, n } = this;\n        let X = new Matrix(m, n), C = X.A;\n        for (let i = 0; i < m; i++)\n            for (let j = 0; j < n; j++)\n                C[i][j] = -A[i][j];\n        return X;\n    }\n    plus(B) {\n        const { A, m, n } = this;\n        let X = new Matrix(m, n), C = X.A;\n        for (let i = 0; i < m; i++)\n            for (let j = 0; j < n; j++)\n                C[i][j] = A[i][j] + B.A[i][j];\n        return X;\n    }\n    plusEquals(B) {\n        const { A, m, n } = this;\n        for (let i = 0; i < m; i++)\n            for (let j = 0; j < n; j++)\n                A[i][j] = A[i][j] + B.A[i][j];\n        return this;\n    }\n    minus(B) {\n        const { A, m, n } = this;\n        let X = new Matrix(m, n), C = A;\n        for (let i = 0; i < m; i++)\n            for (let j = 0; j < n; j++)\n                C[i][j] = A[i][j] - B.A[i][j];\n        return X;\n    }\n    minusEquals(B) {\n        const { A, m, n } = this;\n        for (let i = 0; i < m; i++)\n            for (let j = 0; j < n; j++)\n                A[i][j] = A[i][j] - B.A[i][j];\n        return this;\n    }\n    arrayTimes(B) {\n        const { A, m, n } = this;\n        let X = new Matrix(m, n), C = X.A;\n        for (let i = 0; i < m; i++)\n            for (let j = 0; j < n; j++)\n                C[i][j] = A[i][j] * B.A[i][j];\n        return X;\n    }\n    arrayTimesEquals(B) {\n        const { A, m, n } = this;\n        for (let i = 0; i < m; i++)\n            for (let j = 0; j < n; j++)\n                A[i][j] = A[i][j] * B.A[i][j];\n        return this;\n    }\n    arrayRightDivide(B) {\n        const { A, m, n } = this;\n        let X = new Matrix(m, n), C = X.A;\n        for (let i = 0; i < m; i++)\n            for (let j = 0; j < n; j++)\n                C[i][j] = A[i][j] / B.A[i][j];\n        return X;\n    }\n    arrayRightDivideEquals(B) {\n        const { A, m, n } = this;\n        for (let i = 0; i < m; i++)\n            for (let j = 0; j < n; j++)\n                A[i][j] = A[i][j] / B.A[i][j];\n        return this;\n    }\n    arrayLeftDivide(B) {\n        const { A, m, n } = this;\n        let X = new Matrix(m, n), C = X.A;\n        for (let i = 0; i < m; i++)\n            for (let j = 0; j < n; j++)\n                C[i][j] = B.A[i][j] / A[i][j];\n        return X;\n    }\n    arrayLeftDivideEquals(B) {\n        const { A, m, n } = this;\n        for (let i = 0; i < m; i++)\n            for (let j = 0; j < n; j++)\n                A[i][j] = B.A[i][j] / A[i][j];\n        return this;\n    }\n    scalarTimes(s) {\n        const { A, m, n } = this;\n        let X = new Matrix(m, n), C = X.A;\n        for (let i = 0; i < m; i++)\n            for (let j = 0; j < n; j++)\n                C[i][j] = s * A[i][j];\n        return X;\n    }\n    scalarTimesEquals(s) {\n        const { A, m, n } = this;\n        for (let i = 0; i < m; i++)\n            for (let j = 0; j < n; j++)\n                A[i][j] = s * A[i][j];\n        return this;\n    }\n    times(B) {\n        const { A, m, n } = this;\n        let X = new Matrix(m, B.n);\n        let C = X.A, Bcolj = new Array(n);\n        for (let j = 0; j < B.n; j++) {\n            for (let k = 0; k < n; k++)\n                Bcolj[k] = B.A[k][j];\n            for (let i = 0; i < m; i++) {\n                let Arowi = A[i];\n                let s = 0;\n                for (let k = 0; k < n; k++)\n                    s += Arowi[k] * Bcolj[k];\n                C[i][j] = s;\n            }\n        }\n        return X;\n    }\n    rank() {\n        return new SingularValueDecomposition(this).rank();\n    }\n    cond() {\n        return new SingularValueDecomposition(this).cond();\n    }\n    trace() {\n        const { A, m, n } = this;\n        let t = 0;\n        for (let i = 0; i < Math.min(m, n); i++) {\n            t += A[i][i];\n        }\n        return t;\n    }\n    static identity(m, n) {\n        let mtx = new Matrix(m, n);\n        let A = mtx.A;\n        for (let i = 0; i < m; i++)\n            for (let j = 0; j < n; j++)\n                A[i][j] = (i == j ? 1.0 : 0.0);\n        return mtx;\n    }\n    toString() {\n        let lines = ['['];\n        for (let row of this.A)\n            lines.push(JSON.stringify(row));\n        lines.push(']');\n        return lines.join('\\n');\n    }\n}\nclass SingularValueDecomposition {\n    constructor(mtx) {\n        let A = mtx.A;\n        let m = this.m = mtx.m;\n        let n = this.n = mtx.n;\n        let nu = Math.min(m, n);\n        let s = this.s = new Array(Math.min(m + 1, n));\n        let U = this.U = new Array(m);\n        let V = this.V = new Array(n);\n        for (let i = 0; i < m; i++)\n            U[i] = _Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.numberArray(0, nu);\n        for (let j = 0; j < n; j++)\n            V[j] = _Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.numberArray(0, n);\n        let e = new Array(n);\n        let work = new Array(m);\n        let wantu = true, wantv = true;\n        let nct = Math.min(m - 1, n);\n        let nrt = Math.max(0, Math.min(n - 2, m));\n        for (let k = 0; k < Math.max(nct, nrt); k++) {\n            if (k < nct) {\n                s[k] = 0;\n                for (let i = k; i < m; i++)\n                    s[k] = SingularValueDecomposition.hypot(s[k], A[i][k]);\n                if (s[k] != 0.0) {\n                    if (A[k][k] < 0.0)\n                        s[k] = -s[k];\n                    for (let i = k; i < m; i++)\n                        A[i][k] /= s[k];\n                    A[k][k] += 1.0;\n                }\n                s[k] = -s[k];\n            }\n            for (let j = k + 1; j < n; j++) {\n                if ((k < nct) && (s[k] != 0.0)) {\n                    let t = 0;\n                    for (let i = k; i < m; i++)\n                        t += A[i][k] * A[i][j];\n                    t = -t / A[k][k];\n                    for (let i = k; i < m; i++)\n                        A[i][j] += t * A[i][k];\n                }\n                e[j] = A[k][j];\n            }\n            if (wantu && (k < nct)) {\n                for (let i = k; i < m; i++)\n                    U[i][k] = A[i][k];\n            }\n            if (k < nrt) {\n                e[k] = 0;\n                for (let i = k + 1; i < n; i++)\n                    e[k] = SingularValueDecomposition.hypot(e[k], e[i]);\n                if (e[k] != 0.0) {\n                    if (e[k + 1] < 0.0)\n                        e[k] = -e[k];\n                    for (let i = k + 1; i < n; i++)\n                        e[i] /= e[k];\n                    e[k + 1] += 1.0;\n                }\n                e[k] = -e[k];\n                if ((k + 1 < m) && (e[k] != 0.0)) {\n                    for (let i = k + 1; i < m; i++)\n                        work[i] = 0.0;\n                    for (let j = k + 1; j < n; j++)\n                        for (let i = k + 1; i < m; i++)\n                            work[i] += e[j] * A[i][j];\n                    for (let j = k + 1; j < n; j++) {\n                        let t = -e[j] / e[k + 1];\n                        for (let i = k + 1; i < m; i++)\n                            A[i][j] += t * work[i];\n                    }\n                }\n                if (wantv) {\n                    for (let i = k + 1; i < n; i++)\n                        V[i][k] = e[i];\n                }\n            }\n        }\n        let p = Math.min(n, m + 1);\n        if (nct < n)\n            s[nct] = A[nct][nct];\n        if (m < p)\n            s[p - 1] = 0.0;\n        if (nrt + 1 < p)\n            e[nrt] = A[nrt][p - 1];\n        e[p - 1] = 0.0;\n        if (wantu) {\n            for (let j = nct; j < nu; j++) {\n                for (let i = 0; i < m; i++)\n                    U[i][j] = 0.0;\n                U[j][j] = 1.0;\n            }\n            for (let k = nct - 1; k >= 0; k--) {\n                if (s[k] != 0.0) {\n                    for (let j = k + 1; j < nu; j++) {\n                        let t = 0;\n                        for (let i = k; i < m; i++)\n                            t += U[i][k] * U[i][j];\n                        t = -t / U[k][k];\n                        for (let i = k; i < m; i++)\n                            U[i][j] += t * U[i][k];\n                    }\n                    for (let i = k; i < m; i++)\n                        U[i][k] = -U[i][k];\n                    U[k][k] = 1.0 + U[k][k];\n                    for (let i = 0; i < k - 1; i++)\n                        U[i][k] = 0.0;\n                }\n                else {\n                    for (let i = 0; i < m; i++)\n                        U[i][k] = 0.0;\n                    U[k][k] = 1.0;\n                }\n            }\n        }\n        if (wantv) {\n            for (let k = n - 1; k >= 0; k--) {\n                if ((k < nrt) && (e[k] != 0.0)) {\n                    for (let j = k + 1; j < nu; j++) {\n                        let t = 0;\n                        for (let i = k + 1; i < n; i++)\n                            t += V[i][k] * V[i][j];\n                        t = -t / V[k + 1][k];\n                        for (let i = k + 1; i < n; i++)\n                            V[i][j] += t * V[i][k];\n                    }\n                }\n                for (let i = 0; i < n; i++)\n                    V[i][k] = 0.0;\n                V[k][k] = 1.0;\n            }\n        }\n        let pp = p - 1;\n        let iter = 0;\n        let eps = Math.pow(2.0, -52.0);\n        let tiny = Math.pow(2.0, -966.0);\n        while (p > 0) {\n            let k, kase;\n            for (k = p - 2; k >= -1; k--) {\n                if (k == -1)\n                    break;\n                if (Math.abs(e[k]) <= tiny + eps * (Math.abs(s[k]) + Math.abs(s[k + 1]))) {\n                    e[k] = 0.0;\n                    break;\n                }\n            }\n            if (k == p - 2) {\n                kase = 4;\n            }\n            else {\n                let ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k)\n                        break;\n                    let t = (ks != p ? Math.abs(e[ks]) : 0.) + (ks != k + 1 ? Math.abs(e[ks - 1]) : 0.);\n                    if (Math.abs(s[ks]) <= tiny + eps * t) {\n                        s[ks] = 0.0;\n                        break;\n                    }\n                }\n                if (ks == k)\n                    kase = 3;\n                else if (ks == p - 1)\n                    kase = 1;\n                else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            if (kase == 1) {\n                let f = e[p - 2];\n                e[p - 2] = 0.0;\n                for (let j = p - 2; j >= k; j--) {\n                    let t = SingularValueDecomposition.hypot(s[j], f);\n                    let cs = s[j] / t;\n                    let sn = f / t;\n                    s[j] = t;\n                    if (j != k) {\n                        f = -sn * e[j - 1];\n                        e[j - 1] = cs * e[j - 1];\n                    }\n                    if (wantv) {\n                        for (let i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n            }\n            else if (kase == 2) {\n                let f = e[k - 1];\n                e[k - 1] = 0.0;\n                for (let j = k; j < p; j++) {\n                    let t = SingularValueDecomposition.hypot(s[j], f);\n                    let cs = s[j] / t;\n                    let sn = f / t;\n                    s[j] = t;\n                    f = -sn * e[j];\n                    e[j] = cs * e[j];\n                    if (wantu) {\n                        for (let i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n            }\n            else if (kase == 3) {\n                let scale = Math.max(Math.max(Math.max(Math.max(Math.abs(s[p - 1]), Math.abs(s[p - 2])), Math.abs(e[p - 2])), Math.abs(s[k])), Math.abs(e[k]));\n                let sp = s[p - 1] / scale;\n                let spm1 = s[p - 2] / scale;\n                let epm1 = e[p - 2] / scale;\n                let sk = s[k] / scale;\n                let ek = e[k] / scale;\n                let b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                let c = (sp * epm1) * (sp * epm1);\n                let shift = 0.0;\n                if ((b != 0.0) || (c != 0.0)) {\n                    shift = Math.sqrt(b * b + c);\n                    if (b < 0.0)\n                        shift = -shift;\n                    shift = c / (b + shift);\n                }\n                let f = (sk + sp) * (sk - sp) + shift;\n                let g = sk * ek;\n                for (let j = k; j < p - 1; j++) {\n                    let t = SingularValueDecomposition.hypot(f, g);\n                    let cs = f / t;\n                    let sn = g / t;\n                    if (j != k)\n                        e[j - 1] = t;\n                    f = cs * s[j] + sn * e[j];\n                    e[j] = cs * e[j] - sn * s[j];\n                    g = sn * s[j + 1];\n                    s[j + 1] = cs * s[j + 1];\n                    if (wantv) {\n                        for (let i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                    }\n                    t = SingularValueDecomposition.hypot(f, g);\n                    cs = f / t;\n                    sn = g / t;\n                    s[j] = t;\n                    f = cs * e[j] + sn * s[j + 1];\n                    s[j + 1] = -sn * e[j] + cs * s[j + 1];\n                    g = sn * e[j + 1];\n                    e[j + 1] = cs * e[j + 1];\n                    if (wantu && (j < m - 1)) {\n                        for (let i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][j + 1];\n                            U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                e[p - 2] = f;\n                iter = iter + 1;\n            }\n            else if (kase == 4) {\n                if (s[k] <= 0.0) {\n                    s[k] = (s[k] < 0.0 ? -s[k] : 0.0);\n                    if (wantv) {\n                        for (let i = 0; i <= pp; i++)\n                            V[i][k] = -V[i][k];\n                    }\n                }\n                while (k < pp) {\n                    if (s[k] >= s[k + 1])\n                        break;\n                    let t = s[k];\n                    s[k] = s[k + 1];\n                    s[k + 1] = t;\n                    if (wantv && (k < n - 1)) {\n                        for (let i = 0; i < n; i++) {\n                            t = V[i][k + 1];\n                            V[i][k + 1] = V[i][k];\n                            V[i][k] = t;\n                        }\n                    }\n                    if (wantu && (k < m - 1)) {\n                        for (let i = 0; i < m; i++) {\n                            t = U[i][k + 1];\n                            U[i][k + 1] = U[i][k];\n                            U[i][k] = t;\n                        }\n                    }\n                    k++;\n                }\n                iter = 0;\n                p--;\n            }\n        }\n    }\n    getU() {\n        return Matrix.fromArray(this.U);\n    }\n    getV() {\n        return Matrix.fromArray(this.V);\n    }\n    getSingularValues() {\n        return this.s;\n    }\n    getS() {\n        const { n } = this;\n        let X = new Matrix(n, n, 0);\n        let S = X.A;\n        for (let i = 0; i < n; i++)\n            S[i][i] = this.s[i];\n        return X;\n    }\n    norm2() {\n        return this.s[0];\n    }\n    cond() {\n        const { m, n, s } = this;\n        return s[0] / s[Math.min(m, n) - 1];\n    }\n    rank() {\n        const { m, n, s } = this;\n        let eps = Math.pow(2.0, -52.0);\n        let tol = Math.max(m, n) * s[0] * eps;\n        let r = 0;\n        for (let i = 0; i < s.length; i++)\n            if (s[i] > tol)\n                r++;\n        return r;\n    }\n    static hypot(a, b) {\n        let r;\n        if (Math.abs(a) > Math.abs(b)) {\n            r = b / a;\n            r = Math.abs(a) * Math.sqrt(1 + r * r);\n        }\n        else if (b != 0) {\n            r = a / b;\n            r = Math.abs(b) * Math.sqrt(1 + r * r);\n        }\n        else {\n            r = 0.0;\n        }\n        return r;\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/util/Matrix.ts?");

/***/ }),

/***/ "./src/util/Random.ts":
/*!****************************!*\
  !*** ./src/util/Random.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Random\": () => (/* binding */ Random)\n/* harmony export */ });\n/* harmony import */ var _Vec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vec */ \"./src/util/Vec.ts\");\n\nclass Random {\n    constructor(seed = null) {\n        this.seed = seed;\n        this.m = 0x8000000;\n        this.invMN = 1.0 / (this.m - 1);\n        this.a = 1103515245;\n        this.c = 5425153011;\n        if (seed == null)\n            this.state = Math.floor(Math.random() * (this.m - 1));\n        else\n            this.state = seed;\n    }\n    next() {\n        this.state = (this.a * this.state + this.c) % this.m;\n        return this.state;\n    }\n    int(max) {\n        return max <= 0 ? 0 : this.next() % max;\n    }\n    float() {\n        return this.next() * this.invMN;\n    }\n    index(arr) {\n        if (_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.isBlank(arr))\n            return null;\n        return this.int(arr.length);\n    }\n    peek(arr) {\n        if (_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.isBlank(arr))\n            return null;\n        return arr[this.int(arr.length)];\n    }\n    pull(arr) {\n        if (_Vec__WEBPACK_IMPORTED_MODULE_0__.Vec.isBlank(arr))\n            return null;\n        let idx = this.int(arr.length), val = arr[idx];\n        arr.splice(idx, 1);\n        return val;\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/util/Random.ts?");

/***/ }),

/***/ "./src/util/Theme.ts":
/*!***************************!*\
  !*** ./src/util/Theme.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Theme\": () => (/* binding */ Theme),\n/* harmony export */   \"hasInlineCSS\": () => (/* binding */ hasInlineCSS),\n/* harmony export */   \"initWebMolKit\": () => (/* binding */ initWebMolKit),\n/* harmony export */   \"installInlineCSS\": () => (/* binding */ installInlineCSS)\n/* harmony export */ });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ \"./src/util/util.ts\");\n\nclass Theme {\n}\nTheme.BASE_URL = null;\nTheme.RESOURCE_URL = null;\nTheme.foreground = 0x000000;\nTheme.background = 0xFFFFFF;\nTheme.lowlight = 0x24D0D0;\nTheme.lowlightEdge1 = 0x47D5D2;\nTheme.lowlightEdge2 = 0x008FD1;\nTheme.highlight = 0x00FF00;\nTheme.highlightEdge1 = 0x00CA59;\nTheme.highlightEdge2 = 0x008650;\nTheme.error = 0xFF0000;\nfunction initWebMolKit(resourcePath) {\n    Theme.RESOURCE_URL = resourcePath;\n    try {\n        let _ = document;\n    }\n    catch (e) {\n        return;\n    }\n    if (document)\n        installInlineCSS('main', composeMainCSS());\n}\nlet cssTagsInstalled = new Set();\nfunction hasInlineCSS(tag) { return cssTagsInstalled.has(tag); }\nfunction installInlineCSS(tag, css) {\n    if (cssTagsInstalled.has(tag))\n        return false;\n    let el = document.createElement('style');\n    el.innerHTML = css;\n    document.head.appendChild(el);\n    cssTagsInstalled.add(tag);\n    return true;\n}\nfunction composeMainCSS() {\n    let lowlight = (0,_util__WEBPACK_IMPORTED_MODULE_0__.colourCode)(Theme.lowlight), lowlightEdge1 = (0,_util__WEBPACK_IMPORTED_MODULE_0__.colourCode)(Theme.lowlightEdge1), lowlightEdge2 = (0,_util__WEBPACK_IMPORTED_MODULE_0__.colourCode)(Theme.lowlightEdge2);\n    let highlight = (0,_util__WEBPACK_IMPORTED_MODULE_0__.colourCode)(Theme.highlight), highlightEdge1 = (0,_util__WEBPACK_IMPORTED_MODULE_0__.colourCode)(Theme.highlightEdge1), highlightEdge2 = (0,_util__WEBPACK_IMPORTED_MODULE_0__.colourCode)(Theme.highlightEdge2);\n    return `\n\t\t.wmk-button\n\t\t{\n\t\t\tdisplay: inline-block;\n\t\t\tpadding: 6px 12px;\n\t\t\tmargin-bottom: 0;\n\t\t\tfont-family: 'Open Sans', sans-serif;\n\t\t\tfont-size: 14px;\n\t\t\tfont-weight: normal;\n\t\t\tline-height: 1.42857143;\n\t\t\ttext-align: center;\n\t\t\twhite-space: nowrap;\n\t\t\tvertical-align: middle;\n\t\t\tcursor: pointer;\n\t\t\tbackground-image: none;\n\t\t\tborder: 1px solid transparent;\n\t\t\tborder-radius: 4px;\n\t\t\t-ms-touch-action: manipulation; touch-action: manipulation;\n\t\t\t-webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;\n\t\t}\n\t\t.wmk-button:focus,\n\t\t.wmk-button:active:focus,\n\t\t.wmk-button.active:focus,\n\t\t.wmk-button.focus,\n\t\t.wmk-button:active.focus,\n\t\t.wmk-button.active.focus\n\t\t{\n\t\t\toutline: thin dotted;\n\t\t\toutline: 5px auto -webkit-focus-ring-color;\n\t\t\toutline-offset: -2px;\n\t\t}\n\t\t.wmk-button:hover,\n\t\t.wmk-button:focus,\n\t\t.wmk-button.focus\n\t\t{\n\t\t\tcolor: #333;\n\t\t\ttext-decoration: none;\n\t\t}\n\t\t.wmk-button:active,\n\t\t.wmk-button.active\n\t\t{\n\t\t\tbackground-image: none;\n\t\t\toutline: 0;\n\t\t\t-webkit-box-shadow: inset 0 3px 5px rgba(0, 0, 0, .125);\n\t\t\tbox-shadow: inset 0 3px 5px rgba(0, 0, 0, .125);\n\t\t}\n\t\t.wmk-button.disabled,\n\t\t.wmk-button[disabled],\n\t\tfieldset[disabled] .wmk-button\n\t\t{\n\t\t\tcursor: not-allowed;\n\t\t\tfilter: alpha(opacity=65);\n\t\t\t-webkit-box-shadow: none;\n\t\t\tbox-shadow: none;\n\t\t\topacity: .65;\n\t\t}\n\t\ta.wmk-button.disabled,\n\t\tfieldset[disabled] a.wmk-button\n\t\t{\n\t\t\tpointer-events: none;\n\t\t}\n\n\t\t/* shrunken button */\n\n\t\t.wmk-button-small\n\t\t{\n\t\t\tpadding: 2px 4px;\n\t\t\tline-height: 1;\n\t\t\tfont-size: 12px;\n\t\t}\n\n\t\t/* default button */\n\n\t\t.wmk-button-default\n\t\t{\n\t\t\tcolor: #333;\n\t\t\tbackground-color: #fff;\n\t\t\tbackground-image: linear-gradient(to right bottom, #FFFFFF, #E0E0E0);\n\t\t\tborder-color: #ccc;\n\t\t}\n\t\t.wmk-button-default:focus,\n\t\t.wmk-button-default.focus\n\t\t{\n\t\t\tcolor: #333;\n\t\t\tbackground-color: #e6e6e6;\n\t\t\tborder-color: #8c8c8c;\n\t\t}\n\t\t.wmk-button-default:hover\n\t\t{\n\t\t\tcolor: #333;\n\t\t\tbackground-color: #e6e6e6;\n\t\t\tborder-color: #adadad;\n\t\t}\n\t\t.wmk-button-default:active,\n\t\t.wmk-button-default.active,\n\t\t.open > .dropdown-toggle.wmk-button-default\n\t\t{\n\t\t\tcolor: #333;\n\t\t\tbackground-color: #e6e6e6;\n\t\t\tborder-color: #adadad;\n\t\t}\n\t\t.wmk-button-default:active:hover,\n\t\t.wmk-button-default.active:hover,\n\t\t.open > .dropdown-toggle.wmk-button-default:hover,\n\t\t.wmk-button-default:active:focus,\n\t\t.wmk-button-default.active:focus,\n\t\t.open > .dropdown-toggle.wmk-button-default:focus,\n\t\t.wmk-button-default:active.focus,\n\t\t.wmk-button-default.active.focus,\n\t\t.open > .dropdown-toggle.wmk-button-default.focus\n\t\t{\n\t\t\tcolor: #333;\n\t\t\tbackground-color: #d4d4d4;\n\t\t\tborder-color: #8c8c8c;\n\t\t}\n\t\t.wmk-button-default:active,\n\t\t.wmk-button-default.active,\n\t\t.open > .dropdown-toggle.wmk-button-default\n\t\t{\n\t\t\tbackground-image: none;\n\t\t}\n\t\t.wmk-button-default.disabled:hover,\n\t\t.wmk-button-default[disabled]:hover,\n\t\tfieldset[disabled] .wmk-button-default:hover,\n\t\t.wmk-button-default.disabled:focus,\n\t\t.wmk-button-default[disabled]:focus,\n\t\tfieldset[disabled] .wmk-button-default:focus,\n\t\t.wmk-button-default.disabled.focus,\n\t\t.wmk-button-default[disabled].focus,\n\t\tfieldset[disabled] .wmk-button-default.focus\n\t\t{\n\t\t\tbackground-color: #fff;\n\t\t\tborder-color: #ccc;\n\t\t}\n\t\t.wmk-button-default .badge\n\t\t{\n\t\t\tcolor: #fff;\n\t\t\tbackground-color: #333;\n\t\t}\n\n\t\t/* primary button */\n\n\t\t.wmk-button-primary\n\t\t{\n\t\t\tcolor: #fff;\n\t\t\tbackground-color: #008FD2;\n\t\t\tbackground-image: linear-gradient(to right bottom, ${lowlightEdge1}, ${lowlightEdge2});\n\t\t\tborder-color: #00C0C0;\n\t\t}\n\t\t.wmk-button-primary:focus,\n\t\t.wmk-button-primary.focus\n\t\t{\n\t\t\tcolor: #fff;\n\t\t\tbackground-color: ${lowlight};\n\t\t\tborder-color: #122b40;\n\t\t}\n\t\t.wmk-button-primary:hover\n\t\t{\n\t\t\tcolor: #fff;\n\t\t\tbackground-color: #286090;\n\t\t\tborder-color: #204d74;\n\t\t}\n\t\t.wmk-button-primary:active,\n\t\t.wmk-button-primary.active,\n\t\t.open > .dropdown-toggle.wmk-button-primary\n\t\t{\n\t\t\tcolor: #fff;\n\t\t\tbackground-color: #286090;\n\t\t\tborder-color: #20744d;\n\t\t}\n\t\t.wmk-button-primary:active:hover,\n\t\t.wmk-button-primary.active:hover,\n\t\t.open > .dropdown-toggle.wmk-button-primary:hover,\n\t\t.wmk-button-primary:active:focus,\n\t\t.wmk-button-primary.active:focus,\n\t\t.open > .dropdown-toggle.wmk-button-primary:focus,\n\t\t.wmk-button-primary:active.focus,\n\t\t.wmk-button-primary.active.focus,\n\t\t.open > .dropdown-toggle.wmk-button-primary.focus\n\t\t{\n\t\t\tcolor: #fff;\n\t\t\tbackground-color: ${highlight};\n\t\t\tbackground-image: linear-gradient(to right bottom, ${highlightEdge1}, ${highlightEdge2});\n\t\t\tborder-color: #12802b;\n\t\t}\n\t\t.wmk-button-primary:active,\n\t\t.wmk-button-primary.active,\n\t\t.open > .dropdown-toggle.wmk-button-primary\n\t\t{\n\t\t\tbackground-image: none;\n\t\t}\n\t\t.wmk-button-primary.disabled:hover,\n\t\t.wmk-button-primary[disabled]:hover,\n\t\tfieldset[disabled] .wmk-button-primary:hover,\n\t\t.wmk-button-primary.disabled:focus,\n\t\t.wmk-button-primary[disabled]:focus,\n\t\tfieldset[disabled] .wmk-button-primary:focus,\n\t\t.wmk-button-primary.disabled.focus,\n\t\t.wmk-button-primary[disabled].focus,\n\t\tfieldset[disabled] .wmk-button-primary.focus\n\t\t{\n\t\t\tbackground-color: #337ab7;\n\t\t\tborder-color: #2ea46d;\n\t\t}\n\t\t.wmk-button-primary .badge\n\t\t{\n\t\t\tcolor: #337ab7;\n\t\t\tbackground-color: #fff;\n\t\t}\n\t`;\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/util/Theme.ts?");

/***/ }),

/***/ "./src/util/Triangulation2D.ts":
/*!*************************************!*\
  !*** ./src/util/Triangulation2D.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Triangulation2D\": () => (/* binding */ Triangulation2D)\n/* harmony export */ });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ \"./src/util/util.ts\");\n/* harmony import */ var _Vec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vec */ \"./src/util/Vec.ts\");\n\n\nconst EPSILON = Math.pow(2, -52);\nclass Triangulation2D {\n    constructor(px, py) {\n        this.px = px;\n        this.py = py;\n        this.numTriangles = 0;\n        this.edgeStack = _Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.numberArray(0, 512);\n        this.hull = null;\n        this.px = px;\n        this.py = py;\n        this.sz = px.length;\n        let maxTriangles = Math.max(2 * this.sz - 5, 0);\n        this.triangles = new Array(maxTriangles * 3);\n        this.halfedges = new Array(maxTriangles * 3);\n        this.hashSize = Math.ceil(Math.sqrt(this.sz));\n        this.hullPrev = new Array(this.sz);\n        this.hullNext = new Array(this.sz);\n        this.hullTri = new Array(this.sz);\n        this.hullHash = _Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.numberArray(-1, this.hashSize);\n        this.ids = new Array(this.sz);\n        this.dists = new Array(this.sz);\n        this.update();\n    }\n    trimConcave(threshold) {\n        const threshSq = (0,_util__WEBPACK_IMPORTED_MODULE_0__.sqr)(threshold);\n        const { sz, px, py } = this;\n        let tri = this.triangles.slice(0);\n        let edgeCount = new Map();\n        while (true) {\n            const ntri = tri.length / 3;\n            edgeCount.clear();\n            for (let n = 0, i = 0; n < ntri; n++, i += 3) {\n                const e1 = sz * Math.min(tri[i + 0], tri[i + 1]) + Math.max(tri[i + 0], tri[i + 1]);\n                const e2 = sz * Math.min(tri[i + 0], tri[i + 2]) + Math.max(tri[i + 0], tri[i + 2]);\n                const e3 = sz * Math.min(tri[i + 1], tri[i + 2]) + Math.max(tri[i + 1], tri[i + 2]);\n                edgeCount.set(e1, (edgeCount.get(e1) || 0) + 1);\n                edgeCount.set(e2, (edgeCount.get(e2) || 0) + 1);\n                edgeCount.set(e3, (edgeCount.get(e3) || 0) + 1);\n            }\n            let mask = _Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.booleanArray(true, ntri);\n            for (let n = 0, i = 0; n < ntri; n++, i += 3) {\n                const i1 = tri[i], i2 = tri[i + 1], i3 = tri[i + 2];\n                const e1 = sz * Math.min(i1, i2) + Math.max(i1, i2);\n                const e2 = sz * Math.min(i1, i3) + Math.max(i1, i3);\n                const e3 = sz * Math.min(i2, i3) + Math.max(i2, i3);\n                const c1 = edgeCount.get(e1), c2 = edgeCount.get(e2), c3 = edgeCount.get(e3);\n                if (c1 == 1 && c2 != 1 && c3 != 1)\n                    mask[n] = (0,_util__WEBPACK_IMPORTED_MODULE_0__.norm2_xy)(px[i1] - px[i2], py[i1] - py[i2]) < threshSq;\n                else if (c1 != 1 && c2 == 1 && c3 != 1)\n                    mask[n] = (0,_util__WEBPACK_IMPORTED_MODULE_0__.norm2_xy)(px[i1] - px[i3], py[i1] - py[i3]) < threshSq;\n                else if (c1 != 1 && c2 != 1 && c3 == 1)\n                    mask[n] = (0,_util__WEBPACK_IMPORTED_MODULE_0__.norm2_xy)(px[i2] - px[i3], py[i2] - py[i3]) < threshSq;\n            }\n            if (_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.allTrue(mask))\n                break;\n            let rep = new Array(_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.maskCount(mask) * 3);\n            for (let n = 0, i = 0, j = 0; n < ntri; n++, i += 3)\n                if (mask[n]) {\n                    rep[j++] = tri[i];\n                    rep[j++] = tri[i + 1];\n                    rep[j++] = tri[i + 2];\n                }\n            tri = rep;\n        }\n        return tri;\n    }\n    traceOutline(tri) {\n        const ntri = tri.length / 3;\n        const { sz, px, py } = this;\n        let edgeCount = new Map();\n        for (let n = 0, i = 0; n < ntri; n++, i += 3) {\n            const e1 = sz * Math.min(tri[i + 0], tri[i + 1]) + Math.max(tri[i + 0], tri[i + 1]);\n            const e2 = sz * Math.min(tri[i + 0], tri[i + 2]) + Math.max(tri[i + 0], tri[i + 2]);\n            const e3 = sz * Math.min(tri[i + 1], tri[i + 2]) + Math.max(tri[i + 1], tri[i + 2]);\n            edgeCount.set(e1, (edgeCount.get(e1) || 0) + 1);\n            edgeCount.set(e2, (edgeCount.get(e2) || 0) + 1);\n            edgeCount.set(e3, (edgeCount.get(e3) || 0) + 1);\n        }\n        let edges = [];\n        for (let entry of edgeCount.entries())\n            if (entry[1] == 1) {\n                const e = entry[0];\n                const i1 = Math.floor(e / sz), i2 = e % sz;\n                edges.push(i1);\n                edges.push(i2);\n            }\n        const idx = _Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.uniqueUnstable(edges);\n        const isz = idx.length;\n        const idxMap = new Map();\n        for (let n = 0; n < isz; n++)\n            idxMap.set(idx[n], n);\n        let g1 = _Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.numberArray(-1, isz), g2 = _Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.numberArray(-1, isz);\n        for (let n = 0; n < edges.length; n += 2) {\n            const i1 = idxMap.get(edges[n]), i2 = idxMap.get(edges[n + 1]);\n            if (g1[i1] < 0)\n                g1[i1] = i2;\n            else\n                g2[i1] = i2;\n            if (g1[i2] < 0)\n                g1[i2] = i1;\n            else\n                g2[i2] = i1;\n        }\n        let mask = _Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.booleanArray(false, isz);\n        let sequence = new Array(isz);\n        sequence[0] = 0;\n        mask[0] = true;\n        for (let n = 1; n < isz; n++) {\n            const i = sequence[n - 1];\n            if (!mask[g1[i]])\n                sequence[n] = g1[i];\n            else\n                sequence[n] = g2[i];\n            mask[sequence[n]] = true;\n        }\n        return _Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.idxGet(idx, sequence);\n    }\n    update() {\n        const sz = this.sz;\n        let { px, py, ids, dists, triangles, halfedges } = this;\n        const minX = _Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.min(px), minY = _Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.min(py);\n        const maxX = _Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.max(px), maxY = _Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.max(py);\n        for (let n = 0; n < sz; n++)\n            ids[n] = n;\n        this.centreX = 0.5 * (minX + maxX);\n        this.centreY = 0.5 * (minY + maxY);\n        let i0 = 0, i1 = 0, i2 = 0;\n        let minDist = Number.POSITIVE_INFINITY;\n        for (let n = 0; n < sz; n++) {\n            const d = (0,_util__WEBPACK_IMPORTED_MODULE_0__.norm_xy)(this.centreX - px[n], this.centreY - py[n]);\n            if (d < minDist) {\n                i0 = n;\n                minDist = d;\n            }\n        }\n        const i0x = px[i0], i0y = py[i0];\n        minDist = Number.POSITIVE_INFINITY;\n        for (let n = 0; n < sz; n++) {\n            if (n == i0)\n                continue;\n            const d = (0,_util__WEBPACK_IMPORTED_MODULE_0__.norm_xy)(i0x - px[n], i0y - py[n]);\n            if (d < minDist && d > 0) {\n                i1 = n;\n                minDist = d;\n            }\n        }\n        let i1x = px[i1], i1y = py[i1];\n        let minRadius = Number.POSITIVE_INFINITY;\n        for (let n = 0; n < sz; n++) {\n            if (n == i0 || n == i1)\n                continue;\n            let r = this.circumRadius(i0x, i0y, i1x, i1y, px[n], py[n]);\n            if (r < minRadius) {\n                i2 = n;\n                minRadius = r;\n            }\n        }\n        let i2x = px[i2], i2y = py[i2];\n        if (!Number.isFinite(minRadius)) {\n            for (let n = 0; n < sz; n++) {\n                dists[n] = px[n] - px[0];\n                if (dists[n] == 0)\n                    dists[n] = py[n] - py[0];\n            }\n            this.quicksort(0, sz - 1);\n            let hull = new Array(sz);\n            let j = 0;\n            let d0 = Number.NEGATIVE_INFINITY;\n            for (let n = 0; n < sz; n++) {\n                let id = ids[n];\n                if (dists[id] > d0) {\n                    hull[j++] = id;\n                    d0 = dists[id];\n                }\n            }\n            this.hull = hull.slice(0, j);\n            triangles = [];\n            halfedges = [];\n            return;\n        }\n        if (this.orient(i0x, i0y, i1x, i1y, i2x, i2y)) {\n            let i = i1;\n            let x = i1x, y = i1y;\n            i1 = i2;\n            i1x = i2x;\n            i1y = i2y;\n            i2 = i;\n            i2x = x;\n            i2y = y;\n        }\n        this.pickCircumCentre(i0x, i0y, i1x, i1y, i2x, i2y);\n        for (let n = 0; n < sz; n++)\n            dists[n] = (0,_util__WEBPACK_IMPORTED_MODULE_0__.norm_xy)(px[n] - this.centreX, py[n] - this.centreY);\n        this.quicksort(0, sz - 1);\n        this.hullStart = i0;\n        let hullSize = 3;\n        const { hullNext, hullPrev, hullTri, hullHash, hashSize } = this;\n        hullNext[i0] = hullPrev[i2] = i1;\n        hullNext[i1] = hullPrev[i0] = i2;\n        hullNext[i2] = hullPrev[i1] = i0;\n        hullTri[i0] = 0;\n        hullTri[i1] = 1;\n        hullTri[i2] = 2;\n        hullHash.fill(-1);\n        hullHash[this.hashKey(i0x, i0y)] = i0;\n        hullHash[this.hashKey(i1x, i1y)] = i1;\n        hullHash[this.hashKey(i2x, i2y)] = i2;\n        this.numTriangles = 0;\n        this.addTriangle(i0, i1, i2, -1, -1, -1);\n        let xp = 0, yp = 0;\n        for (let k = 0; k < ids.length; k++) {\n            let i = ids[k];\n            let x = px[i], y = py[i];\n            if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON)\n                continue;\n            xp = x;\n            yp = y;\n            if (i == i0 || i == i1 || i == i2)\n                continue;\n            let start = 0;\n            for (let j = 0, key = this.hashKey(x, y); j < hashSize; j++) {\n                start = hullHash[(key + j) % hashSize];\n                if (start >= 0 && start != hullNext[start])\n                    break;\n            }\n            start = hullPrev[start];\n            let e = start, q = hullNext[e];\n            while (!this.orient(x, y, px[e], py[e], px[q], py[q])) {\n                e = q;\n                if (e == start) {\n                    e = -1;\n                    break;\n                }\n                q = hullNext[e];\n            }\n            if (e < 0)\n                continue;\n            let t = this.addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);\n            hullTri[i] = this.legalise(t + 2);\n            hullTri[e] = t;\n            hullSize++;\n            let n = hullNext[e];\n            q = hullNext[n];\n            while (this.orient(x, y, px[n], py[n], px[q], py[q])) {\n                t = this.addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);\n                hullTri[i] = this.legalise(t + 2);\n                hullNext[n] = n;\n                hullSize--;\n                n = q;\n                q = hullNext[n];\n            }\n            if (e == start) {\n                q = hullPrev[e];\n                while (this.orient(x, y, px[q], py[q], px[e], py[e])) {\n                    t = this.addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);\n                    this.legalise(t + 2);\n                    hullTri[q] = t;\n                    hullNext[e] = e;\n                    hullSize--;\n                    e = q;\n                    q = hullPrev[e];\n                }\n            }\n            this.hullStart = hullPrev[i] = e;\n            hullNext[e] = hullPrev[n] = i;\n            hullNext[i] = n;\n            hullHash[this.hashKey(x, y)] = i;\n            hullHash[this.hashKey(px[e], py[e])] = e;\n        }\n        this.hull = new Array(hullSize);\n        for (let n = 0, e = this.hullStart; n < hullSize; n++) {\n            this.hull[n] = e;\n            e = hullNext[e];\n        }\n        this.triangles = triangles.slice(0, this.numTriangles);\n        this.halfedges = halfedges.slice(0, this.numTriangles);\n    }\n    hashKey(x, y) {\n        return Math.floor(this.pseudoAngle(x - this.centreX, y - this.centreY) * this.hashSize) % this.hashSize;\n    }\n    legalise(a) {\n        let i = 0;\n        let ar = 0;\n        while (true) {\n            let b = this.halfedges[a];\n            let a0 = a - a % 3;\n            ar = a0 + (a + 2) % 3;\n            if (b < 0) {\n                if (i == 0)\n                    break;\n                a = this.edgeStack[--i];\n                continue;\n            }\n            const b0 = b - b % 3;\n            const al = a0 + (a + 1) % 3;\n            const bl = b0 + (b + 2) % 3;\n            const { px, py, triangles, halfedges } = this;\n            const p0 = triangles[ar];\n            const pr = triangles[a];\n            const pl = triangles[al];\n            const p1 = triangles[bl];\n            let illegal = this.inCircle(px[p0], py[p0], px[pr], py[pr], px[pl], py[pl], px[p1], py[p1]);\n            if (illegal) {\n                this.triangles[a] = p1;\n                this.triangles[b] = p0;\n                const hbl = halfedges[bl];\n                if (hbl < 0) {\n                    let e = this.hullStart;\n                    do {\n                        if (this.hullTri[e] == bl) {\n                            this.hullTri[e] = a;\n                            break;\n                        }\n                        e = this.hullPrev[e];\n                    } while (e != this.hullStart);\n                }\n                this.link(a, hbl);\n                this.link(b, halfedges[ar]);\n                this.link(ar, bl);\n                const br = b0 + (b + 1) % 3;\n                if (i < this.edgeStack.length)\n                    this.edgeStack[i++] = br;\n            }\n            else {\n                if (i == 0)\n                    break;\n                a = this.edgeStack[--i];\n            }\n        }\n        return ar;\n    }\n    link(a, b) {\n        this.halfedges[a] = b;\n        if (b >= 0)\n            this.halfedges[b] = a;\n    }\n    addTriangle(i0, i1, i2, a, b, c) {\n        const t = this.numTriangles;\n        this.triangles[t] = i0;\n        this.triangles[t + 1] = i1;\n        this.triangles[t + 2] = i2;\n        this.link(t, a);\n        this.link(t + 1, b);\n        this.link(t + 2, c);\n        this.numTriangles += 3;\n        return t;\n    }\n    pseudoAngle(dx, dy) {\n        const p = dx / (Math.abs(dx) + Math.abs(dy));\n        return (dy > 0 ? 3 - p : 1 + p) / 4;\n    }\n    orientIfSure(px, py, rx, ry, qx, qy) {\n        const l = (ry - py) * (qx - px);\n        const r = (rx - px) * (qy - py);\n        return Math.abs(l - r) >= 3.3306690738754716e-16 * Math.abs(l + r) ? l - r : 0;\n    }\n    orient(rx, ry, qx, qy, px, py) {\n        let o = this.orientIfSure(px, py, rx, ry, qx, qy);\n        if (o != 0)\n            return o < 0;\n        o = this.orientIfSure(rx, ry, qx, qy, px, py);\n        if (o != 0)\n            return o < 0;\n        o = this.orientIfSure(qx, qy, px, py, rx, ry);\n        return o < 0;\n    }\n    inCircle(ax, ay, bx, by, cx, cy, px, py) {\n        const dx = ax - px;\n        const dy = ay - py;\n        const ex = bx - px;\n        const ey = by - py;\n        const fx = cx - px;\n        const fy = cy - py;\n        const ap = dx * dx + dy * dy;\n        const bp = ex * ex + ey * ey;\n        const cp = fx * fx + fy * fy;\n        return dx * (ey * cp - bp * fy) -\n            dy * (ex * cp - bp * fx) +\n            ap * (ex * fy - ey * fx) < 0;\n    }\n    circumRadius(ax, ay, bx, by, cx, cy) {\n        const dx = bx - ax;\n        const dy = by - ay;\n        const ex = cx - ax;\n        const ey = cy - ay;\n        const bl = dx * dx + dy * dy;\n        const cl = ex * ex + ey * ey;\n        const d = 0.5 / (dx * ey - dy * ex);\n        const x = (ey * bl - dy * cl) * d;\n        const y = (dx * cl - ex * bl) * d;\n        return x * x + y * y;\n    }\n    pickCircumCentre(ax, ay, bx, by, cx, cy) {\n        const dx = bx - ax;\n        const dy = by - ay;\n        const ex = cx - ax;\n        const ey = cy - ay;\n        const bl = dx * dx + dy * dy;\n        const cl = ex * ex + ey * ey;\n        const d = 0.5 / (dx * ey - dy * ex);\n        this.centreX = ax + (ey * bl - dy * cl) * d;\n        this.centreY = ay + (dx * cl - ex * bl) * d;\n    }\n    quicksort(left, right) {\n        const { ids, dists } = this;\n        if (right - left <= 20) {\n            for (let i = left + 1; i <= right; i++) {\n                const temp = ids[i];\n                const tempDist = dists[temp];\n                let j = i - 1;\n                while (j >= left && dists[ids[j]] > tempDist)\n                    ids[j + 1] = ids[j--];\n                ids[j + 1] = temp;\n            }\n        }\n        else {\n            let median = (left + right) >> 1;\n            let i = left + 1;\n            let j = right;\n            _Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.swap(ids, median, i);\n            if (dists[ids[left]] > dists[ids[right]])\n                _Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.swap(ids, left, right);\n            if (dists[ids[i]] > dists[ids[right]])\n                _Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.swap(ids, i, right);\n            if (dists[ids[left]] > dists[ids[i]])\n                _Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.swap(ids, left, i);\n            let temp = ids[i];\n            const tempDist = dists[temp];\n            while (true) {\n                do\n                    i++;\n                while (dists[ids[i]] < tempDist);\n                do\n                    j--;\n                while (dists[ids[j]] > tempDist);\n                if (j < i)\n                    break;\n                _Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.swap(ids, i, j);\n            }\n            ids[left + 1] = ids[j];\n            ids[j] = temp;\n            if (right - i + 1 >= j - left) {\n                this.quicksort(i, right);\n                this.quicksort(left, j - 1);\n            }\n            else {\n                this.quicksort(left, j - 1);\n                this.quicksort(i, right);\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/util/Triangulation2D.ts?");

/***/ }),

/***/ "./src/util/Vec.ts":
/*!*************************!*\
  !*** ./src/util/Vec.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Permutation\": () => (/* binding */ Permutation),\n/* harmony export */   \"Vec\": () => (/* binding */ Vec)\n/* harmony export */ });\nclass Vec {\n    static isBlank(arr) { return arr == null || arr.length == 0; }\n    static notBlank(arr) { return arr != null && arr.length > 0; }\n    static safeArray(arr) { return arr == null ? [] : arr; }\n    static len(arr) { return arr == null ? 0 : arr.length; }\n    static arrayLength(arr) { return arr == null ? 0 : arr.length; }\n    static anyTrue(arr) {\n        if (arr == null)\n            return false;\n        for (let v of arr)\n            if (v)\n                return true;\n        return false;\n    }\n    static allTrue(arr) {\n        if (arr == null)\n            return true;\n        for (let v of arr)\n            if (!v)\n                return false;\n        return true;\n    }\n    static anyFalse(arr) {\n        if (arr == null)\n            return false;\n        for (let v of arr)\n            if (!v)\n                return true;\n        return false;\n    }\n    static allFalse(arr) {\n        if (arr == null)\n            return true;\n        for (let v of arr)\n            if (v)\n                return false;\n        return true;\n    }\n    static iterAnyTrue(arr, callback) {\n        for (let v of arr)\n            if (callback(v))\n                return true;\n        return false;\n    }\n    static iterAllTrue(arr, callback) {\n        for (let v of arr)\n            if (!callback(v))\n                return false;\n        return true;\n    }\n    static iterAnyFalse(arr, callback) {\n        for (let v of arr)\n            if (!callback(v))\n                return true;\n        return false;\n    }\n    static iterAllFalse(arr, callback) {\n        for (let v of arr)\n            if (callback(v))\n                return false;\n        return true;\n    }\n    static swap(arr, idx1, idx2) {\n        let v = arr[idx1];\n        arr[idx1] = arr[idx2];\n        arr[idx2] = v;\n    }\n    static duplicate(arr) {\n        return arr == null ? [] : arr.slice(0);\n    }\n    static append(arr, item) {\n        if (arr == null || arr.length == 0)\n            return [item];\n        arr = arr.slice(0);\n        arr.push(item);\n        return arr;\n    }\n    static prepend(arr, item) {\n        if (arr == null || arr.length == 0)\n            return [item];\n        arr = arr.slice(0);\n        arr.unshift(item);\n        return arr;\n    }\n    static concat(arr1, arr2) {\n        if (arr1 == null && arr2 == null)\n            return [];\n        if (arr1 == null)\n            return arr2.slice(0);\n        if (arr2 == null)\n            return arr1.slice(0);\n        return arr1.concat(arr2);\n    }\n    static remove(arr, idx) {\n        arr = arr.slice(0);\n        arr.splice(idx, 1);\n        return arr;\n    }\n    static flatten(mtx) {\n        let ret = [];\n        for (let vec of mtx)\n            ret.push(...vec);\n        return ret;\n    }\n    static transpose(mtx) {\n        let sz1 = mtx.length, sz2 = mtx[0].length;\n        let ret = Vec.anyArray(null, sz2);\n        for (let j = 0; j < sz2; j++) {\n            ret[j] = Vec.anyArray(null, sz1);\n            for (let i = 0; i < sz1; i++)\n                ret[j][i] = mtx[i][j];\n        }\n        return ret;\n    }\n    static equals(arr1, arr2) {\n        if (arr1 == null && arr2 == null)\n            return true;\n        if (arr1 == null || arr2 == null)\n            return false;\n        if (arr1.length != arr2.length)\n            return false;\n        for (let n = 0; n < arr1.length; n++)\n            if (arr1[n] != arr2[n])\n                return false;\n        return true;\n    }\n    static equivalent(arr1, arr2) {\n        const len1 = arr1 == null ? 0 : arr1.length, len2 = arr2 == null ? 0 : arr2.length;\n        if (len1 != len2)\n            return false;\n        for (let n = 0; n < len1; n++)\n            if (arr1[n] != arr2[n])\n                return false;\n        return true;\n    }\n    static compareTo(arr1, arr2) {\n        const sz = Math.max(arr1.length, arr2.length);\n        for (let n = 0; n < sz; n++) {\n            if (arr1[n] < arr2[n])\n                return -1;\n            if (arr1[n] > arr2[n])\n                return 1;\n        }\n        return 0;\n    }\n    static booleanArray(val, sz) {\n        let arr = new Array(sz);\n        arr.fill(val);\n        return arr;\n    }\n    static numberArray(val, sz) {\n        let arr = new Array(sz);\n        arr.fill(val);\n        return arr;\n    }\n    static stringArray(val, sz) {\n        let arr = new Array(sz);\n        arr.fill(val);\n        return arr;\n    }\n    static anyArray(val, sz) {\n        let arr = new Array(sz);\n        arr.fill(val);\n        return arr;\n    }\n    static genericArray(val, sz) {\n        let arr = new Array(sz);\n        arr.fill(val);\n        return arr;\n    }\n    static genericBlankArrays(sz) {\n        let arr = new Array(sz);\n        for (let n = 0; n < sz; n++)\n            arr[n] = [];\n        return arr;\n    }\n    static funcArray(sz, func) {\n        let arr = new Array(sz);\n        for (let n = 0; n < sz; n++)\n            arr[n] = func(n);\n        return arr;\n    }\n    static first(arr) { return arr == null || arr.length == 0 ? null : arr[0]; }\n    static last(arr) { return arr == null || arr.length == 0 ? null : arr[arr.length - 1]; }\n    static min(arr) {\n        if (arr == null || arr.length == 0)\n            return Number.MAX_VALUE;\n        let v = arr[0];\n        for (let n = 1; n < arr.length; n++)\n            v = Math.min(v, arr[n]);\n        return v;\n    }\n    static max(arr) {\n        if (arr == null || arr.length == 0)\n            return Number.MIN_VALUE;\n        let v = arr[0];\n        for (let n = 1; n < arr.length; n++)\n            v = Math.max(v, arr[n]);\n        return v;\n    }\n    static idxMin(arr) {\n        if (arr == null || arr.length == 0)\n            return -1;\n        let idx = 0;\n        for (let n = 1; n < arr.length; n++)\n            if (arr[n] < arr[idx])\n                idx = n;\n        return idx;\n    }\n    static idxMax(arr) {\n        if (arr == null || arr.length == 0)\n            return -1;\n        let idx = 0;\n        for (let n = 1; n < arr.length; n++)\n            if (arr[n] > arr[idx])\n                idx = n;\n        return idx;\n    }\n    static range(arr) {\n        if (arr == null || arr.length == 0)\n            return 0;\n        let lo = arr[0], hi = arr[0];\n        for (let n = 1; n < arr.length; n++) {\n            if (arr[n] < lo)\n                lo = arr[n];\n            if (arr[n] > hi)\n                hi = arr[n];\n        }\n        return hi - lo;\n    }\n    static reverse(arr) {\n        let ret = [];\n        for (let n = arr.length - 1; n >= 0; n--)\n            ret.push(arr[n]);\n        return ret;\n    }\n    static identity0(sz) {\n        let ret = new Array(sz);\n        for (let n = 0; n < sz; n++)\n            ret[n] = n;\n        return ret;\n    }\n    static identity1(sz) {\n        let ret = new Array(sz);\n        for (let n = 0; n < sz; n++)\n            ret[n] = n + 1;\n        return ret;\n    }\n    static identityN(start, sz) {\n        let ret = new Array(sz);\n        for (let n = 0; n < sz; n++)\n            ret[n] = n + start;\n        return ret;\n    }\n    static notMask(mask) {\n        let ret = new Array(mask.length);\n        for (let n = mask.length - 1; n >= 0; n--)\n            ret[n] = !mask[n];\n        return ret;\n    }\n    static idxGet(arr, idx) {\n        let ret = [];\n        for (let n = 0; n < idx.length; n++)\n            ret.push(arr[idx[n]]);\n        return ret;\n    }\n    static maskCount(mask) {\n        if (!mask)\n            return 0;\n        let c = 0;\n        for (let n = mask.length - 1; n >= 0; n--)\n            if (mask[n])\n                c++;\n        return c;\n    }\n    static maskIdx(mask) {\n        let idx = [];\n        for (let n = 0; n < mask.length; n++)\n            if (mask[n])\n                idx.push(n);\n        return idx;\n    }\n    static idxMask(idx, sz) {\n        let mask = Vec.booleanArray(false, sz);\n        for (let n of idx)\n            mask[n] = true;\n        return mask;\n    }\n    static maskMap(mask) {\n        let ret = [];\n        for (let n = 0, pos = 0; n < mask.length; n++)\n            ret.push(mask[n] ? pos++ : -1);\n        return ret;\n    }\n    static maskGet(arr, mask) {\n        let ret = [];\n        for (let n = 0, p = 0; n < arr.length; n++)\n            if (mask[n])\n                ret.push(arr[n]);\n        return ret;\n    }\n    static maskEqual(arr1, val) {\n        let ret = [];\n        if (val.constructor === Array) {\n            let arr2 = val;\n            for (let n = 0; n < arr1.length; n++)\n                ret.push(arr1[n] == arr2[n]);\n        }\n        else {\n            for (let n = 0; n < arr1.length; n++)\n                ret.push(arr1[n] == val);\n        }\n        return ret;\n    }\n    static sum(arr) {\n        if (arr == null || arr.length == 0)\n            return 0;\n        let t = arr[0];\n        for (let n = 1; n < arr.length; n++)\n            t += arr[n];\n        return t;\n    }\n    static add(arr1, val) {\n        let ret = [];\n        if (val.constructor === Array) {\n            let arr2 = val;\n            for (let n = 0; n < arr1.length; n++)\n                ret.push(arr1[n] + arr2[n]);\n        }\n        else {\n            for (let n = 0; n < arr1.length; n++)\n                ret.push(arr1[n] + val);\n        }\n        return ret;\n    }\n    static sub(arr1, val) {\n        let ret = [];\n        if (val.constructor === Array) {\n            let arr2 = val;\n            for (let n = 0; n < arr1.length; n++)\n                ret.push(arr1[n] - arr2[n]);\n        }\n        else {\n            for (let n = 0; n < arr1.length; n++)\n                ret.push(arr1[n] - val);\n        }\n        return ret;\n    }\n    static mul(arr1, val) {\n        let ret = [];\n        if (val.constructor === Array) {\n            let arr2 = val;\n            for (let n = 0; n < arr1.length; n++)\n                ret.push(arr1[n] * arr2[n]);\n        }\n        else {\n            for (let n = 0; n < arr1.length; n++)\n                ret.push(arr1[n] * val);\n        }\n        return ret;\n    }\n    static neg(arr) {\n        let ret = arr.slice(0);\n        for (let n = ret.length - 1; n >= 0; n--)\n            ret[n] *= -1;\n        return ret;\n    }\n    static setTo(arr, val) { for (let n = arr == null ? -1 : arr.length - 1; n >= 0; n--)\n        arr[n] = val; }\n    static addTo(arr, val) { for (let n = arr == null ? -1 : arr.length - 1; n >= 0; n--)\n        arr[n] += val; }\n    static mulBy(arr, val) { for (let n = arr == null ? -1 : arr.length - 1; n >= 0; n--)\n        arr[n] *= val; }\n    static addToArray(arr, val) { for (let n = arr == null ? -1 : arr.length - 1; n >= 0; n--)\n        arr[n] += val[n]; }\n    static subFromArray(arr, val) { for (let n = arr == null ? -1 : arr.length - 1; n >= 0; n--)\n        arr[n] -= val[n]; }\n    static mulByArray(arr, val) { for (let n = arr == null ? -1 : arr.length - 1; n >= 0; n--)\n        arr[n] *= val[n]; }\n    static divByArray(arr, val) { for (let n = arr == null ? -1 : arr.length - 1; n >= 0; n--)\n        arr[n] /= val[n]; }\n    static idxSort(arr) {\n        let idx = new Array(arr.length);\n        for (let n = 0; n < arr.length; n++)\n            idx[n] = n;\n        idx.sort((a, b) => arr[a] < arr[b] ? -1 : arr[a] > arr[b] ? 1 : 0);\n        return idx;\n    }\n    static sort(arr) {\n        arr.sort((v1, v2) => v1 - v2);\n    }\n    static sorted(arr) {\n        arr = arr.slice(0);\n        this.sort(arr);\n        return arr;\n    }\n    static sortedUnique(arr) {\n        if (arr == null || arr.length == 0)\n            return [];\n        let unique = Vec.uniqueUnstable(arr);\n        if (typeof arr[0] == 'number')\n            this.sort(unique);\n        else\n            unique.sort();\n        return unique;\n    }\n    static uniqueUnstable(arr) {\n        return Array.from(new Set(arr));\n    }\n    static uniqueStable(arr) {\n        let set = new Set(arr), ret = [];\n        for (let v of arr)\n            if (set.has(v)) {\n                ret.push(v);\n                set.delete(v);\n            }\n        return ret;\n    }\n    static maskUnique(arr) {\n        let set = new Set(arr), ret = this.booleanArray(false, arr.length);\n        for (let n = 0; n < arr.length; n++)\n            if (set.has(arr[n])) {\n                ret[n] = true;\n                set.delete(arr[n]);\n            }\n        return ret;\n    }\n    static idxUnique(arr) {\n        let set = new Set(arr), ret = [];\n        for (let n = 0; n < arr.length; n++)\n            if (set.has(arr[n])) {\n                ret.push(n);\n                set.delete(arr[n]);\n            }\n        return ret;\n    }\n    static exclude(arr, excl) {\n        const sz = Vec.len(arr);\n        if (sz == 0)\n            return [];\n        let mask = new Array(sz);\n        let count = 0;\n        for (let n = 0; n < arr.length; n++) {\n            mask[n] = excl.indexOf(arr[n]) < 0;\n            if (mask[n])\n                count++;\n        }\n        if (count == sz)\n            return arr;\n        return Vec.maskGet(arr, mask);\n    }\n}\nclass Permutation {\n    static parityPerms(idx) {\n        let v = Vec.booleanArray(false, idx.length);\n        let p = 0;\n        for (let i = idx.length - 1; i >= 0; i--) {\n            if (v[i])\n                p++;\n            else {\n                let j = i;\n                do {\n                    j = idx[j];\n                    v[j] = true;\n                } while (j != i);\n            }\n        }\n        return p;\n    }\n    static parityIdentity(idx) {\n        return this.parityPerms(idx) & 1;\n    }\n    static parityOrder(src) {\n        if (src.length <= 1)\n            return 0;\n        else if (src.length == 2)\n            return src[0] < src[1] ? 0 : 1;\n        else if (src.length == 3) {\n            let p = 1;\n            if (src[0] < src[1])\n                p++;\n            if (src[0] < src[2])\n                p++;\n            if (src[1] < src[2])\n                p++;\n            return p & 1;\n        }\n        else if (src.length == 4) {\n            let p = 0;\n            if (src[0] < src[1])\n                p++;\n            if (src[0] < src[2])\n                p++;\n            if (src[0] < src[3])\n                p++;\n            if (src[1] < src[2])\n                p++;\n            if (src[1] < src[3])\n                p++;\n            if (src[2] < src[3])\n                p++;\n            return p & 1;\n        }\n        let idx = [], sorted = src.slice(0);\n        sorted.sort();\n        for (let n = 0; n < src.length; n++)\n            idx.push(sorted.indexOf(src[n]));\n        return this.parityIdentity(idx);\n    }\n    static smallPermutation(sz) {\n        if (sz == 1)\n            return this.PERM1;\n        else if (sz == 2)\n            return this.PERM2;\n        else if (sz == 3)\n            return this.PERM3;\n        else if (sz == 4)\n            return this.PERM4;\n        else\n            return null;\n    }\n    static allPermutations(sz) {\n        if (sz <= this.SMALL_PERMS)\n            return this.smallPermutation(sz);\n        while (this.PERM_CACHE.length < this.MAX_CACHE - this.SMALL_PERMS)\n            this.PERM_CACHE.push(null);\n        if (sz < this.MAX_CACHE && this.PERM_CACHE[sz - this.SMALL_PERMS] != null)\n            return this.PERM_CACHE[sz - this.SMALL_PERMS];\n        let nperms = 1;\n        for (let n = 2; n <= sz; n++)\n            nperms *= n;\n        let perms = [];\n        let idx = Vec.identity0(sz);\n        perms.push(idx.slice(0));\n        let mask = Vec.booleanArray(false, sz);\n        for (let n = 1; n < nperms; n++) {\n            nonunique: while (idx[0] < sz) {\n                idx[sz - 1]++;\n                for (let i = sz - 1; i > 0; i--) {\n                    if (idx[i] < sz)\n                        break;\n                    idx[i] = 0;\n                    idx[i - 1]++;\n                }\n                Vec.setTo(mask, false);\n                for (let i of idx) {\n                    if (mask[i])\n                        continue nonunique;\n                    mask[i] = true;\n                }\n                perms[n] = idx.slice(0);\n                break;\n            }\n        }\n        if (sz < this.MAX_CACHE)\n            this.PERM_CACHE[sz - this.SMALL_PERMS] = perms;\n        return perms;\n    }\n}\nPermutation.PERM1 = [[0]];\nPermutation.PERM2 = [[0, 1], [1, 0]];\nPermutation.PERM3 = [[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]];\nPermutation.PERM4 = [\n    [0, 1, 2, 3], [0, 1, 3, 2], [0, 2, 1, 3], [0, 2, 3, 1], [0, 3, 1, 2], [0, 3, 2, 1],\n    [1, 0, 2, 3], [1, 0, 3, 2], [1, 2, 0, 3], [1, 2, 3, 0], [1, 3, 0, 2], [1, 3, 2, 0],\n    [2, 0, 1, 3], [2, 0, 3, 1], [2, 1, 0, 3], [2, 1, 3, 0], [2, 3, 0, 1], [2, 3, 1, 0],\n    [3, 0, 1, 2], [3, 0, 2, 1], [3, 1, 0, 2], [3, 1, 2, 0], [3, 2, 0, 1], [3, 2, 1, 0]\n];\nPermutation.SMALL_PERMS = 4;\nPermutation.MAX_CACHE = 8;\nPermutation.PERM_CACHE = [];\n\n\n//# sourceURL=webpack://WebMolKit/./src/util/Vec.ts?");

/***/ }),

/***/ "./src/util/XML.ts":
/*!*************************!*\
  !*** ./src/util/XML.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"XML\": () => (/* binding */ XML)\n/* harmony export */ });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ \"./src/util/util.ts\");\n\nclass XML {\n    static parseXML(strXML) {\n        let xmlDoc;\n        if (this.customParser)\n            xmlDoc = new this.customParser().parseFromString(strXML, 'application/xml');\n        else\n            xmlDoc = new DOMParser().parseFromString(strXML, 'application/xml');\n        if (xmlDoc == null)\n            return null;\n        return xmlDoc;\n    }\n    static toString(doc) {\n        if (this.customSerial)\n            return new this.customSerial().serializeToString(doc.documentElement);\n        else\n            return new XMLSerializer().serializeToString(doc.documentElement);\n    }\n    static toPrettyString(doc) {\n        let xslt = [\n            '<xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">',\n            '  <xsl:strip-space elements=\"*\"/>',\n            '  <xsl:template match=\"para[content-style][not(text())]\">',\n            '    <xsl:value-of select=\"normalize-space(.)\"/>',\n            '  </xsl:template>',\n            '  <xsl:template match=\"node()|@*\">',\n            '    <xsl:copy><xsl:apply-templates select=\"node()|@*\"/></xsl:copy>',\n            '  </xsl:template>',\n            '  <xsl:output indent=\"yes\"/>',\n            '</xsl:stylesheet>',\n        ].join('\\n');\n        let xsltDoc = this.parseXML(xslt);\n        let xsltProc = new XSLTProcessor();\n        xsltProc.importStylesheet(xsltDoc);\n        let resultDoc = xsltProc.transformToDocument(doc);\n        return new XMLSerializer().serializeToString(resultDoc);\n    }\n    static nodeText(el) {\n        let text = '';\n        for (let child of Array.from(el.childNodes)) {\n            if (child.nodeType == Node.TEXT_NODE || child.nodeType == Node.CDATA_SECTION_NODE)\n                text += child.nodeValue;\n        }\n        return text;\n    }\n    static childText(parent, tagName) {\n        if (parent == null)\n            return null;\n        let el = this.findElement(parent, tagName);\n        if (el == null)\n            return null;\n        return (0,_util__WEBPACK_IMPORTED_MODULE_0__.nodeText)(el);\n    }\n    static appendElement(parent, name) {\n        let el = parent.ownerDocument.createElement(name);\n        parent.appendChild(el);\n        return el;\n    }\n    static appendElementAfter(presib, name) {\n        let el = presib.ownerDocument.createElement(name);\n        let postsib = presib.nextSibling;\n        if (postsib == null)\n            presib.parentNode.appendChild(el);\n        else\n            presib.parentNode.insertBefore(el, postsib);\n        return el;\n    }\n    static appendText(parent, text, isCDATA = false) {\n        if (text == null || text.length == 0)\n            return;\n        if (!isCDATA)\n            parent.appendChild(parent.ownerDocument.createTextNode(text));\n        else\n            parent.appendChild(parent.ownerDocument.createCDATASection(text));\n    }\n    static createTextChild(parent, name, text, isCDATA = false) {\n        let el = parent.ownerDocument.createElement(name);\n        parent.appendChild(el);\n        if (!isCDATA)\n            el.textContent = text;\n        else\n            el.appendChild(parent.ownerDocument.createCDATASection(text));\n    }\n    static setText(parent, text, isCDATA = false) {\n        while (parent.firstChild != null)\n            parent.removeChild(parent.firstChild);\n        this.appendText(parent, text, isCDATA);\n    }\n    static findElement(parent, tagName) {\n        if (parent == null)\n            return null;\n        let node = parent.firstChild;\n        while (node != null) {\n            if (node.nodeType == Node.ELEMENT_NODE && node.nodeName == tagName)\n                return node;\n            node = node.nextSibling;\n        }\n        return null;\n    }\n    static findChildElements(parent, tagName) {\n        if (parent == null)\n            return [];\n        let list = [];\n        let node = parent.firstChild;\n        while (node != null) {\n            if (node.nodeType == Node.ELEMENT_NODE && node.nodeName === tagName)\n                list.push(node);\n            node = node.nextSibling;\n        }\n        return list;\n    }\n    static childElements(parent) {\n        if (parent == null)\n            return [];\n        let list = [];\n        let node = parent.firstChild;\n        while (node != null) {\n            if (node.nodeType == Node.ELEMENT_NODE)\n                list.push(node);\n            node = node.nextSibling;\n        }\n        return list;\n    }\n}\nXML.customParser = null;\nXML.customSerial = null;\n\n\n//# sourceURL=webpack://WebMolKit/./src/util/XML.ts?");

/***/ }),

/***/ "./src/util/dom.ts":
/*!*************************!*\
  !*** ./src/util/dom.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DOM\": () => (/* binding */ DOM),\n/* harmony export */   \"dom\": () => (/* binding */ dom),\n/* harmony export */   \"domLegacy\": () => (/* binding */ domLegacy)\n/* harmony export */ });\n/* harmony import */ var _Geom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Geom */ \"./src/util/Geom.ts\");\n/* harmony import */ var _XML__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./XML */ \"./src/util/XML.ts\");\n\n\nfunction dom(obj) {\n    if (typeof obj == 'string')\n        return DOM.parse(obj);\n    if (obj instanceof DOM)\n        return obj;\n    return new DOM(obj);\n}\nfunction domLegacy(obj) {\n    if (obj == null)\n        return null;\n    if (obj.jquery)\n        return dom(obj[0]);\n    return dom(obj);\n}\nclass DOM {\n    constructor(el) {\n        this.el = el;\n    }\n    get elHTML() { return this.el; }\n    get elInput() { return this.el; }\n    get elCanvas() { return this.el; }\n    static parse(xhtml) {\n        let xml = _XML__WEBPACK_IMPORTED_MODULE_1__.XML.parseXML(xhtml);\n        if (xml == null)\n            throw 'Invalid XHTML string: ' + xhtml;\n        let html = xml.documentElement.outerHTML;\n        let template = document.createElement('template');\n        template.innerHTML = html;\n        return new DOM(template.content.firstChild);\n    }\n    static find(selector) {\n        let el = document.querySelector(selector);\n        return el ? new DOM(el) : null;\n    }\n    static findAll(selector) {\n        let nodeList = document.querySelectorAll(selector);\n        let domList = [];\n        for (let n = 0; n < nodeList.length; n++)\n            domList.push(new DOM(nodeList.item(n)));\n        return domList;\n    }\n    parent() {\n        let parent = this.el.parentElement;\n        return parent ? new DOM(parent) : null;\n    }\n    ancestor(selector) {\n        let el = this.el.closest(selector);\n        return el ? new DOM(el) : null;\n    }\n    children(tag) {\n        let domList = [];\n        for (let child = this.el.firstElementChild; child; child = child.nextElementSibling) {\n            if (tag && child.tagName != tag)\n                continue;\n            domList.push(new DOM(child));\n        }\n        return domList;\n    }\n    find(selector) {\n        let el = this.el.querySelector(selector);\n        return el ? new DOM(el) : null;\n    }\n    findAll(selector) {\n        let nodeList = this.el.querySelectorAll(selector);\n        let domList = [];\n        for (let n = 0; n < nodeList.length; n++)\n            domList.push(new DOM(nodeList.item(n)));\n        return domList;\n    }\n    exists() {\n        return document.documentElement.contains(this.el);\n    }\n    isVisible() {\n        return this.elHTML.offsetWidth > 0 || this.elHTML.offsetHeight > 0 || this.elHTML.getClientRects().length > 0;\n    }\n    append(child) {\n        this.el.append(child.el);\n    }\n    appendTo(parent) {\n        if (parent instanceof DOM)\n            parent.el.append(this.el);\n        else\n            parent.appendChild(this.el);\n        return this;\n    }\n    prepend(child) {\n        this.el.prepend(child.el);\n    }\n    prependTo(parent) {\n        if (parent instanceof DOM)\n            parent.el.prepend(this.el);\n        else\n            parent.append(this.el);\n        return this;\n    }\n    insertBefore(ref) {\n        ref.el.parentElement.insertBefore(this.el, ref.el);\n        return this;\n    }\n    insertAfter(ref) {\n        let before = ref.el.nextElementSibling;\n        if (before)\n            ref.el.parentElement.insertBefore(this.el, before);\n        else\n            ref.el.parentElement.append(this.el);\n        return this;\n    }\n    remove() {\n        this.el.remove();\n    }\n    empty() {\n        this.el.innerHTML = '';\n    }\n    getHTML() {\n        return this.el.innerHTML;\n    }\n    setHTML(html) {\n        this.el.innerHTML = html;\n    }\n    appendHTML(xhtml) {\n        let xml = _XML__WEBPACK_IMPORTED_MODULE_1__.XML.parseXML('<z>' + xhtml + '</z>');\n        if (xml == null)\n            throw 'Invalid XHTML string: ' + xhtml;\n        let html = xml.documentElement.innerHTML;\n        this.el.insertAdjacentHTML('beforeend', html);\n    }\n    getText() {\n        return this.el.textContent;\n    }\n    setText(text) {\n        this.el.textContent = text;\n    }\n    appendText(text) {\n        let content = document.createTextNode(text);\n        this.el.appendChild(content);\n    }\n    getValue() {\n        return this.el.value;\n    }\n    setValue(str) {\n        this.el.value = str || '';\n    }\n    getCSS(key) {\n        return this.elHTML.style.getPropertyValue(key);\n    }\n    setCSS(key, value) {\n        this.elHTML.style.setProperty(key, value);\n    }\n    css(dict) {\n        for (let key in dict)\n            this.setCSS(key, dict[key].toString());\n        return this;\n    }\n    getAttr(key) {\n        if (!this.el.hasAttribute(key))\n            return null;\n        return this.el.getAttribute(key);\n    }\n    setAttr(key, value) {\n        this.el.setAttribute(key, value);\n    }\n    attr(dict) {\n        for (let key in dict)\n            this.setAttr(key, dict[key].toString());\n        return this;\n    }\n    addClass(clsnames) {\n        for (let cls of clsnames.split(' '))\n            if (cls)\n                this.elHTML.classList.add(cls);\n    }\n    removeClass(clsnames) {\n        for (let cls of clsnames.split(' '))\n            if (cls)\n                this.elHTML.classList.remove(cls);\n    }\n    hasClass(clsname) {\n        return this.elHTML.classList.contains(clsname);\n    }\n    setClass(clsname, flag) {\n        if (flag)\n            this.addClass(clsname);\n        else\n            this.removeClass(clsname);\n    }\n    class(clsname) {\n        this.addClass(clsname);\n        return this;\n    }\n    toggleClass(dict) {\n        for (let key in dict) {\n            if (dict[key])\n                this.elHTML.classList.add(key);\n            else\n                this.elHTML.classList.remove(key);\n        }\n    }\n    width() {\n        return this.elHTML.offsetWidth;\n    }\n    height() {\n        return this.elHTML.offsetHeight;\n    }\n    offset() {\n        let rect = this.el.getBoundingClientRect();\n        let win = this.el.ownerDocument.defaultView;\n        return new _Geom__WEBPACK_IMPORTED_MODULE_0__.Pos(rect.left + win.pageXOffset, rect.top + win.pageYOffset);\n    }\n    size() {\n        return new _Geom__WEBPACK_IMPORTED_MODULE_0__.Size(this.width(), this.height());\n    }\n    setBoundaryPixels(x, y, w, h) {\n        this.css({ 'left': `${x}px`, 'top': `${y}px`, 'width': `${w}px`, 'height': `${h}px` });\n    }\n    hasFocus() {\n        return this.el === document.activeElement;\n    }\n    grabFocus(delay = false) {\n        if (delay)\n            setTimeout(() => this.grabFocus(), 10);\n        else\n            this.elHTML.focus();\n    }\n    removeEvent(id, callback) {\n        this.el.removeEventListener(id, callback);\n    }\n    onKeyDown(callback) {\n        this.el.addEventListener('keydown', callback);\n    }\n    onKeyUp(callback) {\n        this.el.addEventListener('keyup', callback);\n    }\n    onKeyPress(callback) {\n        this.el.addEventListener('keypress', callback);\n    }\n    onScroll(callback) {\n        this.el.addEventListener('scroll', callback);\n    }\n    onWheel(callback) {\n        this.el.addEventListener('wheel', callback);\n    }\n    onClick(callback) {\n        this.el.addEventListener('click', callback);\n    }\n    onContextMenu(callback) {\n        this.el.addEventListener('contextmenu', callback);\n    }\n    onDblClick(callback) {\n        this.el.addEventListener('dblclick', callback);\n    }\n    onMouseDown(callback) {\n        this.el.addEventListener('mousedown', callback);\n    }\n    onMouseUp(callback) {\n        this.el.addEventListener('mouseup', callback);\n    }\n    onMouseEnter(callback) {\n        this.el.addEventListener('mouseenter', callback);\n    }\n    onMouseLeave(callback) {\n        this.el.addEventListener('mouseleave', callback);\n    }\n    onMouseMove(callback) {\n        this.el.addEventListener('mousemove', callback);\n    }\n    onMouseOver(callback) {\n        this.el.addEventListener('mouseover', callback);\n    }\n    onChange(callback) {\n        this.el.addEventListener('change', callback);\n    }\n    onInput(callback) {\n        this.el.addEventListener('input', callback);\n    }\n    onTouchStart(callback) {\n        this.el.addEventListener('touchstart', callback);\n    }\n    onTouchMove(callback) {\n        this.el.addEventListener('touchmove', callback);\n    }\n    onTouchCancel(callback) {\n        this.el.addEventListener('touchcancel', callback);\n    }\n    onTouchEnd(callback) {\n        this.el.addEventListener('touchend', callback);\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/util/dom.ts?");

/***/ }),

/***/ "./src/util/util.ts":
/*!**************************!*\
  !*** ./src/util/util.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ASCENT_FUDGE\": () => (/* binding */ ASCENT_FUDGE),\n/* harmony export */   \"DEGRAD\": () => (/* binding */ DEGRAD),\n/* harmony export */   \"INV_TWOPI\": () => (/* binding */ INV_TWOPI),\n/* harmony export */   \"KeyCode\": () => (/* binding */ KeyCode),\n/* harmony export */   \"RADDEG\": () => (/* binding */ RADDEG),\n/* harmony export */   \"TWOPI\": () => (/* binding */ TWOPI),\n/* harmony export */   \"addText\": () => (/* binding */ addText),\n/* harmony export */   \"angleDiff\": () => (/* binding */ angleDiff),\n/* harmony export */   \"angleDiffPos\": () => (/* binding */ angleDiffPos),\n/* harmony export */   \"angleNorm\": () => (/* binding */ angleNorm),\n/* harmony export */   \"blendRGB\": () => (/* binding */ blendRGB),\n/* harmony export */   \"clone\": () => (/* binding */ clone),\n/* harmony export */   \"colourAlpha\": () => (/* binding */ colourAlpha),\n/* harmony export */   \"colourCanvas\": () => (/* binding */ colourCanvas),\n/* harmony export */   \"colourCode\": () => (/* binding */ colourCode),\n/* harmony export */   \"deepClone\": () => (/* binding */ deepClone),\n/* harmony export */   \"dictValues\": () => (/* binding */ dictValues),\n/* harmony export */   \"drawLine\": () => (/* binding */ drawLine),\n/* harmony export */   \"empiricalScrollerSize\": () => (/* binding */ empiricalScrollerSize),\n/* harmony export */   \"escapeHTML\": () => (/* binding */ escapeHTML),\n/* harmony export */   \"eventCoords\": () => (/* binding */ eventCoords),\n/* harmony export */   \"findNode\": () => (/* binding */ findNode),\n/* harmony export */   \"findNodes\": () => (/* binding */ findNodes),\n/* harmony export */   \"fltEqual\": () => (/* binding */ fltEqual),\n/* harmony export */   \"fontSansSerif\": () => (/* binding */ fontSansSerif),\n/* harmony export */   \"formatDate\": () => (/* binding */ formatDate),\n/* harmony export */   \"formatDouble\": () => (/* binding */ formatDouble),\n/* harmony export */   \"fromUTF8\": () => (/* binding */ fromUTF8),\n/* harmony export */   \"getBoundaryPixelsDOM\": () => (/* binding */ getBoundaryPixelsDOM),\n/* harmony export */   \"getOffsetPixelsDOM\": () => (/* binding */ getOffsetPixelsDOM),\n/* harmony export */   \"htmlToRGB\": () => (/* binding */ htmlToRGB),\n/* harmony export */   \"invZ\": () => (/* binding */ invZ),\n/* harmony export */   \"isDef\": () => (/* binding */ isDef),\n/* harmony export */   \"jsonPrettyPrint\": () => (/* binding */ jsonPrettyPrint),\n/* harmony export */   \"maxArray\": () => (/* binding */ maxArray),\n/* harmony export */   \"minArray\": () => (/* binding */ minArray),\n/* harmony export */   \"newElement\": () => (/* binding */ newElement),\n/* harmony export */   \"nodeText\": () => (/* binding */ nodeText),\n/* harmony export */   \"norm2_xy\": () => (/* binding */ norm2_xy),\n/* harmony export */   \"norm2_xyz\": () => (/* binding */ norm2_xyz),\n/* harmony export */   \"norm_xy\": () => (/* binding */ norm_xy),\n/* harmony export */   \"norm_xyz\": () => (/* binding */ norm_xyz),\n/* harmony export */   \"notDef\": () => (/* binding */ notDef),\n/* harmony export */   \"orBlank\": () => (/* binding */ orBlank),\n/* harmony export */   \"pathRoundedRect\": () => (/* binding */ pathRoundedRect),\n/* harmony export */   \"pixelDensity\": () => (/* binding */ pixelDensity),\n/* harmony export */   \"plural\": () => (/* binding */ plural),\n/* harmony export */   \"postJSONURL\": () => (/* binding */ postJSONURL),\n/* harmony export */   \"randomInt\": () => (/* binding */ randomInt),\n/* harmony export */   \"readTextURL\": () => (/* binding */ readTextURL),\n/* harmony export */   \"realEqual\": () => (/* binding */ realEqual),\n/* harmony export */   \"safeFloat\": () => (/* binding */ safeFloat),\n/* harmony export */   \"safeInt\": () => (/* binding */ safeInt),\n/* harmony export */   \"setBoundaryPixels\": () => (/* binding */ setBoundaryPixels),\n/* harmony export */   \"signum\": () => (/* binding */ signum),\n/* harmony export */   \"sortAngles\": () => (/* binding */ sortAngles),\n/* harmony export */   \"sqr\": () => (/* binding */ sqr),\n/* harmony export */   \"toUTF8\": () => (/* binding */ toUTF8),\n/* harmony export */   \"uniqueAngles\": () => (/* binding */ uniqueAngles),\n/* harmony export */   \"yieldDOM\": () => (/* binding */ yieldDOM),\n/* harmony export */   \"zip\": () => (/* binding */ zip)\n/* harmony export */ });\n/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom */ \"./src/util/dom.ts\");\n/* harmony import */ var _Geom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Geom */ \"./src/util/Geom.ts\");\n/* harmony import */ var _Vec__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Vec */ \"./src/util/Vec.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nfunction safeInt(str, def = 0) {\n    if (str == null || str.length == 0)\n        return def;\n    let val = str.startsWith('0x') ? parseInt(str.substring(2), 16) :\n        str.startsWith('#') ? parseInt(str.substring(1), 16) : parseInt(str);\n    return isNaN(val) ? def : val;\n}\nfunction safeFloat(str, def = 0) {\n    if (str == null || str.length == 0)\n        return def;\n    let val = parseFloat(str);\n    return isNaN(val) ? def : val;\n}\nfunction newElement(parent, tag, attr) {\n    let domNew = (0,_dom__WEBPACK_IMPORTED_MODULE_0__.dom)(`<${tag}/>`);\n    if (attr)\n        domNew.attr(attr);\n    (0,_dom__WEBPACK_IMPORTED_MODULE_0__.domLegacy)(parent).append(domNew);\n    return domNew.el;\n}\nfunction addText(parent, text) {\n    parent.appendChild(document.createTextNode(text));\n}\nfunction plural(count) {\n    return count == 1 ? '' : 's';\n}\nfunction formatDouble(value, sigfig) {\n    if (value == null)\n        return '';\n    let str = value.toPrecision(sigfig);\n    if (str.indexOf('.') > 0) {\n        while (str.endsWith('0'))\n            str = str.substring(0, str.length - 1);\n        if (str.endsWith('.'))\n            str = str.substring(0, str.length - 1);\n    }\n    return str;\n}\nfunction htmlToRGB(col) {\n    if (col == null || col.charAt(0) != '#' || col.length != 7)\n        return null;\n    return parseInt(col.substring(1), 16);\n}\nfunction colourCode(col) {\n    let hex = (col & 0xFFFFFF).toString(16);\n    while (hex.length < 6)\n        hex = '0' + hex;\n    return '#' + hex;\n}\nfunction colourAlpha(col) {\n    let transp = (col >>> 24) & 0xFF;\n    return transp == 0 ? 1 : transp == 0xFF ? 0 : 1 - (transp * (1.0 / 255));\n}\nconst ONE_OVER_255 = 1.0 / 255;\nfunction colourCanvas(col) {\n    if (col == 0xFFFFFF)\n        return 'white';\n    if (col == 0x000000)\n        return 'black';\n    if (col == -1)\n        return null;\n    if (col >= 0 && col <= 0xFFFFFF)\n        return colourCode(col);\n    const t = ((col >> 24) & 0xFF) * ONE_OVER_255;\n    const r = ((col >> 16) & 0xFF);\n    const g = ((col >> 8) & 0xFF);\n    const b = (col & 0xFF);\n    return 'rgba(' + r + ',' + g + ',' + b + ',' + (1 - t) + ')';\n}\nfunction blendRGB(fract, rgb1, rgb2, rgb3) {\n    fract = Math.max(0, Math.min(1, fract));\n    let r1 = ((rgb1 >> 16) & 0xFF) * ONE_OVER_255, g1 = ((rgb1 >> 8) & 0xFF) * ONE_OVER_255, b1 = (rgb1 & 0xFF) * ONE_OVER_255;\n    let r2 = ((rgb2 >> 16) & 0xFF) * ONE_OVER_255, g2 = ((rgb2 >> 8) & 0xFF) * ONE_OVER_255, b2 = (rgb2 & 0xFF) * ONE_OVER_255;\n    let R, G, B;\n    if (rgb3 == null) {\n        let f1 = 1 - fract, f2 = fract;\n        R = Math.round(0xFF * (f1 * r1 + f2 * r2));\n        G = Math.round(0xFF * (f1 * g1 + f2 * g2));\n        B = Math.round(0xFF * (f1 * b1 + f2 * b2));\n    }\n    else {\n        let r3 = ((rgb3 >> 16) & 0xFF) * ONE_OVER_255, g3 = ((rgb3 >> 8) & 0xFF) * ONE_OVER_255, b3 = (rgb3 & 0xFF) * ONE_OVER_255;\n        if (fract < 0.5) {\n            let f2 = fract * 2, f1 = 1 - f2;\n            R = Math.round(0xFF * (f1 * r1 + f2 * r2));\n            G = Math.round(0xFF * (f1 * g1 + f2 * g2));\n            B = Math.round(0xFF * (f1 * b1 + f2 * b2));\n        }\n        else {\n            let f2 = (fract - 0.5) * 2, f1 = 1 - f2;\n            R = Math.round(0xFF * (f1 * r2 + f2 * r3));\n            G = Math.round(0xFF * (f1 * g2 + f2 * g3));\n            B = Math.round(0xFF * (f1 * b2 + f2 * b3));\n        }\n    }\n    return (R << 16) | (G << 8) | B;\n}\nfunction formatDate(date) {\n    const MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n    let day = date.getDate(), mon = date.getMonth(), year = date.getFullYear();\n    return day + '-' + MONTHS[mon] + '-' + year;\n}\nfunction nodeText(node) {\n    let ret = '';\n    if (!node)\n        return '';\n    node = node.firstChild;\n    while (node) {\n        if (node.nodeType == 3 || node.nodeType == 4)\n            ret += node.nodeValue;\n        node = node.nextSibling;\n    }\n    return ret;\n}\nfunction isDef(v) {\n    return !(v === null || typeof v === 'undefined');\n}\nfunction notDef(v) {\n    return v === null || typeof v === 'undefined';\n}\nfunction eventCoords(event, container) {\n    let pos = (0,_dom__WEBPACK_IMPORTED_MODULE_0__.domLegacy)(container).offset();\n    let relX = event.pageX - pos.x;\n    let relY = event.pageY - pos.y;\n    return [relX, relY];\n}\nfunction setBoundaryPixels(dom, x, y, w, h) {\n    dom.css({ 'left': x + 'px', 'top': y + 'px', 'width': w + 'px', 'height': h + 'px' });\n}\nfunction getBoundaryPixelsDOM(dom) {\n    let offset = dom.offset();\n    return [offset.x, offset.y, dom.width(), dom.height()];\n}\nfunction getOffsetPixelsDOM(dom) {\n    return [dom.elHTML.offsetLeft, dom.elHTML.offsetTop, dom.elHTML.offsetWidth, dom.elHTML.offsetHeight];\n}\nfunction norm_xy(dx, dy) {\n    return Math.sqrt(dx * dx + dy * dy);\n}\nfunction norm_xyz(dx, dy, dz) {\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n}\nfunction norm2_xy(dx, dy) {\n    return dx * dx + dy * dy;\n}\nfunction norm2_xyz(dx, dy, dz) {\n    return dx * dx + dy * dy + dz * dz;\n}\nfunction signum(v) {\n    return v < 0 ? -1 : v > 0 ? 1 : 0;\n}\nfunction sqr(v) {\n    return v * v;\n}\nfunction invZ(v) { return v == 0 ? 0 : 1.0 / v; }\nfunction fltEqual(v1, v2) { return v1 == v2 || Math.abs(v1 - v2) <= 1E-7 * Math.max(v1, v2); }\nfunction realEqual(v1, v2) { return v1 == v2 || Math.abs(v1 - v2) <= 1E-14 * Math.max(v1, v2); }\nfunction randomInt(size) {\n    if (size <= 1)\n        return 0;\n    return Math.floor(Math.random() * size);\n}\nconst TWOPI = 2 * Math.PI;\nconst INV_TWOPI = 1.0 / TWOPI;\nconst DEGRAD = Math.PI / 180;\nconst RADDEG = 180 / Math.PI;\nfunction angleNorm(th) {\n    if (th == -Math.PI)\n        return Math.PI;\n    if (th < -Math.PI) {\n        let mod = Math.ceil((-th - Math.PI) * INV_TWOPI);\n        return th + mod * TWOPI;\n    }\n    if (th > Math.PI) {\n        let mod = Math.ceil((th - Math.PI) * INV_TWOPI);\n        return th - mod * TWOPI;\n    }\n    return th;\n}\nfunction angleDiff(th1, th2) {\n    let theta = angleNorm(th1) - angleNorm(th2);\n    return theta - (theta > Math.PI ? TWOPI : 0) + (theta <= -Math.PI ? TWOPI : 0);\n}\nfunction angleDiffPos(th1, th2) {\n    let theta = angleNorm(th1) - angleNorm(th2);\n    return theta + (theta < 0 ? TWOPI : 0);\n}\nfunction sortAngles(theta) {\n    if (theta == null || theta.length < 2)\n        return theta;\n    theta = theta.slice(0);\n    for (let n = 0; n < theta.length; n++)\n        theta[n] = angleNorm(theta[n]);\n    _Vec__WEBPACK_IMPORTED_MODULE_2__.Vec.sort(theta);\n    while (true) {\n        let a = theta[theta.length - 1], b = theta[0], c = theta[1];\n        if (angleDiff(b, a) <= angleDiff(c, b))\n            break;\n        for (let n = theta.length - 1; n > 0; n--)\n            theta[n] = theta[n - 1];\n        theta[0] = a;\n    }\n    return theta;\n}\nfunction uniqueAngles(theta, threshold) {\n    theta = sortAngles(theta);\n    for (let n = 1; n < theta.length; n++) {\n        if (Math.abs(angleDiff(theta[n], theta[n - 1])) <= threshold) {\n            theta.splice(n, 1);\n            n--;\n        }\n    }\n    return theta;\n}\nfunction minArray(a) {\n    if (a == null || a.length == 0)\n        return 0;\n    let v = a[0];\n    for (let n = 1; n < a.length; n++)\n        v = Math.min(v, a[n]);\n    return v;\n}\nfunction maxArray(a) {\n    if (a == null || a.length == 0)\n        return 0;\n    let v = a[0];\n    for (let n = 1; n < a.length; n++)\n        v = Math.max(v, a[n]);\n    return v;\n}\nfunction findNode(parent, name) {\n    if (parent == null)\n        return null;\n    let node = parent.firstChild;\n    while (node) {\n        if (node.nodeName == name)\n            return node;\n        node = node.nextSibling;\n    }\n    return null;\n}\nfunction findNodes(parent, name) {\n    if (parent == null)\n        return null;\n    let node = parent.firstChild;\n    let list = [];\n    while (node) {\n        if (node.nodeName == name)\n            list.push(node);\n        node = node.nextSibling;\n    }\n    return list;\n}\nfunction pathRoundedRect(x1, y1, x2, y2, rad) {\n    let path = new Path2D();\n    path.moveTo(x2 - rad, y1);\n    path.quadraticCurveTo(x2, y1, x2, y1 + rad);\n    path.lineTo(x2, y2 - rad);\n    path.quadraticCurveTo(x2, y2, x2 - rad, y2);\n    path.lineTo(x1 + rad, y2);\n    path.quadraticCurveTo(x1, y2, x1, y2 - rad);\n    path.lineTo(x1, y1 + rad);\n    path.quadraticCurveTo(x1, y1, x1 + rad, y1);\n    path.closePath();\n    return path;\n}\nfunction drawLine(ctx, x1, y1, x2, y2) {\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n}\nconst ASCENT_FUDGE = 1.4;\nfunction fontSansSerif(ascent) { return `${ascent * ASCENT_FUDGE}px sans-serif`; }\nfunction pixelDensity() {\n    if ('devicePixelRatio' in window && window.devicePixelRatio > 1)\n        return window.devicePixelRatio;\n    return 1;\n}\nfunction clone(data) {\n    if (data == null)\n        return null;\n    if (Array.isArray(data))\n        return data.slice(0);\n    if (typeof data != 'object')\n        return data;\n    let result = {};\n    for (let key in data)\n        result[key] = data[key];\n    return result;\n}\nfunction deepClone(data) {\n    if (data == null)\n        return null;\n    if (typeof data == 'function')\n        return null;\n    if (typeof data != 'object')\n        return data;\n    let result = Array.isArray(data) ? [] : {};\n    for (let key in data) {\n        let val = data[key];\n        result[key] = typeof val === 'object' ? deepClone(val) : val;\n    }\n    return result;\n}\nfunction escapeHTML(text) {\n    if (!text)\n        return '';\n    const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '\"': '&quot;', \"'\": '&#039;' };\n    return text.replace(/[&<>\"']/g, (m) => map[m]);\n}\nfunction orBlank(str) { return str == null ? '' : str; }\nfunction dictValues(dict) {\n    let list = [];\n    for (let key in dict)\n        list.push(dict[key]);\n    return list;\n}\nfunction zip(u, v) {\n    return u.map((a, i) => [a, v[i]]);\n}\nfunction toUTF8(str) {\n    let data = [], stripe = '';\n    const sz = str.length;\n    for (let n = 0; n < sz; n++) {\n        let charcode = str.charCodeAt(n);\n        if (charcode < 0x80)\n            stripe += str.charAt(n);\n        else if (charcode < 0x800) {\n            stripe += String.fromCharCode(0xc0 | (charcode >> 6));\n            stripe += String.fromCharCode(0x80 | (charcode & 0x3F));\n        }\n        else if (charcode < 0xd800 || charcode >= 0xe000) {\n            stripe += String.fromCharCode(0xe0 | (charcode >> 12));\n            stripe += String.fromCharCode(0x80 | ((charcode >> 6) & 0x3F));\n            stripe += String.fromCharCode(0x80 | (charcode & 0x3F));\n        }\n        else {\n            n++;\n            charcode = 0x10000 + (((charcode & 0x3FF) << 10) | (str.charCodeAt(n) & 0x3FF));\n            stripe += String.fromCharCode(0xf0 | (charcode >> 18));\n            stripe += String.fromCharCode(0x80 | ((charcode >> 12) & 0x3F));\n            stripe += String.fromCharCode(0x80 | ((charcode >> 6) & 0x3F));\n            stripe += String.fromCharCode(0x80 | (charcode & 0x3F));\n        }\n        if (stripe.length > 100) {\n            data.push(stripe);\n            stripe = '';\n        }\n    }\n    data.push(stripe);\n    return data.join('');\n}\nfunction fromUTF8(str) {\n    let data = [], stripe = '';\n    const sz = str.length;\n    for (let n = 0; n < sz; n++) {\n        let value = str.charCodeAt(n);\n        if (value < 0x80)\n            stripe += str.charAt(n);\n        else if (value > 0xBF && value < 0xE0) {\n            stripe += String.fromCharCode((value & 0x1F) << 6 | str.charCodeAt(n + 1) & 0x3F);\n            n++;\n        }\n        else if (value > 0xDF && value < 0xF0) {\n            str += String.fromCharCode((value & 0x0F) << 12 | (str.charCodeAt(n + 1) & 0x3F) << 6 | str.charCodeAt(n + 2) & 0x3F);\n            n += 2;\n        }\n        else {\n            let charCode = ((value & 0x07) << 18 | (str.charCodeAt(n + 1) & 0x3F) << 12 | (str.charCodeAt(n + 2) & 0x3F) << 6 | str.charCodeAt(n + 3) & 0x3F) - 0x010000;\n            stripe += String.fromCharCode(charCode >> 10 | 0xD800, charCode & 0x03FF | 0xDC00);\n            n += 3;\n        }\n        if (stripe.length > 100) {\n            data.push(stripe);\n            stripe = '';\n        }\n    }\n    data.push(stripe);\n    return data.join('');\n}\nfunction jsonPrettyPrint(json) {\n    let lines = JSON.stringify(json, null, 1).split(/\\n/);\n    for (let n = 0; n < lines.length; n++) {\n        lines[n] = lines[n].trim();\n        if (lines[n].length > 1 && (lines[n].endsWith('{') || lines[n].endsWith('['))) {\n            let ch = lines[n].charAt(lines[n].length - 1);\n            lines[n] = lines[n].substring(0, lines[n].length - 1);\n            lines.splice(n + 1, 0, ch);\n            n--;\n        }\n    }\n    let indent = 0;\n    for (let n = 0; n < lines.length; n++) {\n        let orig = lines[n];\n        if (orig == ']' || orig == '}' || orig == '],' || orig == '},')\n            indent--;\n        lines[n] = '\\t'.repeat(indent) + orig;\n        if (orig == '[' || orig == '{')\n            indent++;\n    }\n    return lines.join('\\n');\n}\nvar KeyCode;\n(function (KeyCode) {\n    KeyCode[\"Backspace\"] = \"Backspace\";\n    KeyCode[\"Tab\"] = \"Tab\";\n    KeyCode[\"Enter\"] = \"Enter\";\n    KeyCode[\"Escape\"] = \"Escape\";\n    KeyCode[\"Space\"] = \" \";\n    KeyCode[\"PageUp\"] = \"PageUp\";\n    KeyCode[\"PageDown\"] = \"PageDown\";\n    KeyCode[\"End\"] = \"End\";\n    KeyCode[\"Home\"] = \"Home\";\n    KeyCode[\"Left\"] = \"ArrowLeft\";\n    KeyCode[\"Right\"] = \"ArrowRight\";\n    KeyCode[\"Up\"] = \"ArrowUp\";\n    KeyCode[\"Down\"] = \"ArrowDown\";\n    KeyCode[\"Delete\"] = \"Delete\";\n    KeyCode[\"Insert\"] = \"Insert\";\n})(KeyCode || (KeyCode = {}));\nfunction readTextURL(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n            let request = new XMLHttpRequest();\n            request.open('GET', url.toString(), true);\n            request.responseType = 'text';\n            request.onload = () => resolve(request.response.toString());\n            request.onerror = () => resolve(null);\n            request.send();\n        });\n    });\n}\nfunction postJSONURL(url, params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n            let request = new XMLHttpRequest();\n            request.open('POST', url.toString(), true);\n            request.responseType = 'text';\n            request.onload = () => {\n                try {\n                    resolve(JSON.parse(request.response.toString()));\n                }\n                catch (ex) {\n                    reject('JSON parsing error on result:' + ex);\n                }\n            };\n            request.onerror = () => reject('Failed to request URL: ' + url);\n            request.send(JSON.stringify(params));\n        });\n    });\n}\nfunction yieldDOM() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve) => setTimeout(() => resolve()));\n    });\n}\nlet staticScrollerSize = null;\nfunction empiricalScrollerSize() {\n    if (staticScrollerSize)\n        return staticScrollerSize;\n    let outer = (0,_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<div/>').css({ 'visibility': 'hidden', 'width': '100px', 'height': '100px', 'overflow': 'scroll' }).appendTo((0,_dom__WEBPACK_IMPORTED_MODULE_0__.dom)(document.body));\n    let inner = (0,_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<div/>').css({ 'width': '100%', 'height': '100%' }).appendTo(outer);\n    staticScrollerSize = new _Geom__WEBPACK_IMPORTED_MODULE_1__.Size(100 - inner.elHTML.offsetWidth, 100 - inner.elHTML.offsetHeight);\n    outer.remove();\n    return staticScrollerSize;\n}\n\n\n//# sourceURL=webpack://WebMolKit/./src/util/util.ts?");

/***/ }),

/***/ "./val/src/Validation.ts":
/*!*******************************!*\
  !*** ./val/src/Validation.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Validation\": () => (/* binding */ Validation)\n/* harmony export */ });\n/* harmony import */ var _src_util_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/util/util */ \"./src/util/util.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nclass Validation {\n    constructor() {\n        this.tests = [];\n        this.setupError = null;\n        this.rec = {};\n    }\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n        });\n    }\n    deinit() {\n        return __awaiter(this, void 0, void 0, function* () {\n        });\n    }\n    add(title, func) {\n        this.tests.push({ 'title': title, 'func': func });\n    }\n    get count() { return this.tests.length; }\n    getTitle(idx) { return this.tests[idx].title; }\n    runTest(idx) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.recentSuccess = true;\n            this.recentError = null;\n            let timeStarted = new Date().getTime();\n            try {\n                yield this.tests[idx].func.call(this);\n            }\n            catch (e) {\n                this.recentSuccess = false;\n                if (this.recentError == null) {\n                    this.recentError = 'Exception: ' + (e.message || e);\n                    if (e.fileName)\n                        this.recentError += ', file: ' + e.fileName;\n                    if (e.lineNumber)\n                        this.recentError += ', line: ' + e.lineNumber;\n                    console.log('Unhandled exception in validation:');\n                    console.log(e);\n                }\n            }\n            let timeFinished = new Date().getTime();\n            this.recentTimeTaken = (timeFinished - timeStarted) / 1000;\n            yield this.gasp();\n            return [this.recentSuccess, this.recentError, this.recentTimeTaken];\n        });\n    }\n    gasp() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield (0,_src_util_util__WEBPACK_IMPORTED_MODULE_0__.yieldDOM)();\n        });\n    }\n    assert(condition, message) {\n        if (condition)\n            return;\n        this.recentError = message;\n        throw '!';\n    }\n    assertEqual(thing1, thing2, message) {\n        if (thing1 == thing2)\n            return;\n        this.recentError = message;\n        throw '!';\n    }\n    assertNull(thing, message) {\n        if (thing == null)\n            return;\n        this.recentError = message;\n        throw '!';\n    }\n    assertNotNull(thing, message) {\n        if (thing != null)\n            return;\n        this.recentError = message;\n        throw '!';\n    }\n    fail(message) {\n        this.recentError = message;\n        throw '!';\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./val/src/Validation.ts?");

/***/ }),

/***/ "./val/src/ValidationHeadlessBasic.ts":
/*!********************************************!*\
  !*** ./val/src/ValidationHeadlessBasic.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ValidationHeadlessBasic\": () => (/* binding */ ValidationHeadlessBasic)\n/* harmony export */ });\n/* harmony import */ var _src_gfx_AxisLabeller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/gfx/AxisLabeller */ \"./src/gfx/AxisLabeller.ts\");\n/* harmony import */ var _src_util_Vec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _Validation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Validation */ \"./val/src/Validation.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nclass ValidationHeadlessBasic extends _Validation__WEBPACK_IMPORTED_MODULE_2__.Validation {\n    constructor() {\n        super();\n        this.add('Vector index sort', this.vectorIndexSort);\n        this.add('Axis labeller', this.axisLabeller);\n    }\n    vectorIndexSort() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let array = ['b', 'c', 'a'];\n            let idx = _src_util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.idxSort(array);\n            this.assert(_src_util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.equals(idx, [2, 0, 1]));\n        });\n    }\n    axisLabeller() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let textWidth = (str) => str.length * 4;\n            let tfUnity = (val) => val, tfNegLog = (val) => -Math.log10(val), tfBackLog = (val) => Math.pow(10, -val);\n            const TESTCASES = [\n                [1, 100, false, ['10', '100']],\n                [0, 1, false, ['0', '1']],\n                [0.01, 0.02, false, ['0.01', '0.02']],\n                [0.008, 0.022, false, ['0.008', '0.022']],\n                [0.00798, 0.0221, false, ['0.008', '0.022']],\n                [1E-5, 1E4, true, ['1e+4', '0.00001']],\n                [0.03162277660168379, 100, true, ['100', '0.03162']]\n            ];\n            for (let test of TESTCASES) {\n                let low = test[0], high = test[1];\n                let asLog = test[2];\n                if (asLog)\n                    [low, high] = [tfNegLog(high), tfNegLog(low)];\n                let axis = new _src_gfx_AxisLabeller__WEBPACK_IMPORTED_MODULE_0__.AxisLabeller(100, low, high, textWidth, asLog ? tfBackLog : tfUnity);\n                axis.calculate();\n                let wanted = test[3];\n                let got = [];\n                for (let notch of axis.notches)\n                    got.push(notch.label);\n                if (wanted.length == 0 || !_src_util_Vec__WEBPACK_IMPORTED_MODULE_1__.Vec.equals(wanted, got)) {\n                    console.log('Test:' + JSON.stringify(test));\n                    console.log('Notches:' + JSON.stringify(axis.notches));\n                    console.log('Wanted:' + JSON.stringify(wanted));\n                    console.log('Got:' + JSON.stringify(got));\n                    this.fail('Did not get the expected axis labels.');\n                }\n            }\n        });\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./val/src/ValidationHeadlessBasic.ts?");

/***/ }),

/***/ "./val/src/ValidationHeadlessMolecule.ts":
/*!***********************************************!*\
  !*** ./val/src/ValidationHeadlessMolecule.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ValidationHeadlessMolecule\": () => (/* binding */ ValidationHeadlessMolecule)\n/* harmony export */ });\n/* harmony import */ var _src_calc_CircularFingerprints__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/calc/CircularFingerprints */ \"./src/calc/CircularFingerprints.ts\");\n/* harmony import */ var _src_data_DataSheetStream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/data/DataSheetStream */ \"./src/data/DataSheetStream.ts\");\n/* harmony import */ var _src_data_MDLReader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../src/data/MDLReader */ \"./src/data/MDLReader.ts\");\n/* harmony import */ var _src_data_MDLWriter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../src/data/MDLWriter */ \"./src/data/MDLWriter.ts\");\n/* harmony import */ var _src_data_MetaMolecule__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../src/data/MetaMolecule */ \"./src/data/MetaMolecule.ts\");\n/* harmony import */ var _src_data_Molecule__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../src/data/Molecule */ \"./src/data/Molecule.ts\");\n/* harmony import */ var _src_data_MoleculeStream__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../src/data/MoleculeStream */ \"./src/data/MoleculeStream.ts\");\n/* harmony import */ var _src_data_Stereochemistry__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../src/data/Stereochemistry */ \"./src/data/Stereochemistry.ts\");\n/* harmony import */ var _src_util_util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../src/util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _src_util_Vec__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../src/util/Vec */ \"./src/util/Vec.ts\");\n/* harmony import */ var _Validation__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Validation */ \"./val/src/Validation.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\n\nclass ValidationHeadlessMolecule extends _Validation__WEBPACK_IMPORTED_MODULE_10__.Validation {\n    constructor(urlBase) {\n        super();\n        this.urlBase = urlBase;\n        this.add('Parse SketchEl molecule (native format)', this.parseSketchEl);\n        this.add('Parse MDL Molfile', this.parseMolfile);\n        this.add('Parse DataSheet XML', this.parseDataXML);\n        this.add('Parse MDL SDfile', this.parseSDfile);\n        this.add('Calculate strict aromaticity', this.calcStrictArom);\n        this.add('Calculate stereochemistry', this.calcStereoChem);\n        this.add('Circular ECFP6 fingerprints', this.calcFingerprints);\n        this.add('Molfile Round-trip', this.molfileRoundTrip);\n    }\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.strSketchEl = yield (0,_src_util_util__WEBPACK_IMPORTED_MODULE_8__.readTextURL)(this.urlBase + 'molecule.el');\n            this.strMolfile = yield (0,_src_util_util__WEBPACK_IMPORTED_MODULE_8__.readTextURL)(this.urlBase + 'molecule.mol');\n            this.strDataXML = yield (0,_src_util_util__WEBPACK_IMPORTED_MODULE_8__.readTextURL)(this.urlBase + 'datasheet.ds');\n            this.strSDfile = yield (0,_src_util_util__WEBPACK_IMPORTED_MODULE_8__.readTextURL)(this.urlBase + 'datasheet.sdf');\n            this.molStereo = _src_data_Molecule__WEBPACK_IMPORTED_MODULE_5__.Molecule.fromString(yield (0,_src_util_util__WEBPACK_IMPORTED_MODULE_8__.readTextURL)(this.urlBase + 'stereo.el'));\n            this.dsCircular = _src_data_DataSheetStream__WEBPACK_IMPORTED_MODULE_1__.DataSheetStream.readXML(yield (0,_src_util_util__WEBPACK_IMPORTED_MODULE_8__.readTextURL)(this.urlBase + 'circular.ds'));\n            this.dsRoundtrip = _src_data_DataSheetStream__WEBPACK_IMPORTED_MODULE_1__.DataSheetStream.readXML(yield (0,_src_util_util__WEBPACK_IMPORTED_MODULE_8__.readTextURL)(this.urlBase + 'roundtrip.ds'));\n        });\n    }\n    parseSketchEl() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.assert(!!this.strSketchEl, 'molecule not loaded');\n            let mol = _src_data_MoleculeStream__WEBPACK_IMPORTED_MODULE_6__.MoleculeStream.readNative(this.strSketchEl);\n            this.assert(mol != null, 'parsing failed');\n            this.assert(mol.numAtoms == 10 && mol.numBonds == 10, 'wrong atom/bond count');\n        });\n    }\n    parseMolfile() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.assert(!!this.strMolfile, 'molecule not loaded');\n            let mol = _src_data_MoleculeStream__WEBPACK_IMPORTED_MODULE_6__.MoleculeStream.readMDLMOL(this.strMolfile);\n            this.assert(mol != null, 'parsing failed');\n            this.assert(mol.numAtoms == 10 && mol.numBonds == 10, 'wrong atom/bond count');\n        });\n    }\n    parseDataXML() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.assert(!!this.strDataXML, 'datasheet not loaded');\n            let ds = _src_data_DataSheetStream__WEBPACK_IMPORTED_MODULE_1__.DataSheetStream.readXML(this.strDataXML);\n            this.assert(ds != null, 'parsing failed');\n            this.assert(ds.numRows == 2 && ds.numCols == 5, 'wrong row/column count');\n            let colTypes = [\"molecule\", \"string\", \"integer\", \"real\", \"boolean\"];\n            for (let n = 0; n < colTypes.length; n++)\n                this.assert(ds.colType(n) == colTypes[n], 'column#' + (n + 1) + ' wrong type');\n            this.assert(ds.getMolecule(0, 0).numAtoms == 1, 'row 1: invalid molecule');\n            this.assert(ds.getString(0, 1) == 'string', 'row 1: invalid string');\n            this.assert(ds.getInteger(0, 2) == 1, 'row 1: invalid integer');\n            this.assert(ds.getReal(0, 3) == 1.5, 'row 1: invalid real');\n            this.assert(ds.getBoolean(0, 4) == true, 'row 1: invalid boolean');\n            this.assert(ds.getMolecule(1, 0).numAtoms == 1, 'row 2: invalid molecule');\n            for (let n = 1; n < ds.numCols; n++)\n                this.assert(ds.isNull(1, n), 'row 2, column#' + (n + 1) + ' supposed to be null');\n        });\n    }\n    parseSDfile() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.assert(!!this.strSDfile, 'datasheet not loaded');\n            let rdr = new _src_data_MDLReader__WEBPACK_IMPORTED_MODULE_2__.MDLSDFReader(this.strSDfile);\n            rdr.parse();\n            let ds = rdr.ds;\n            this.assert(ds != null, 'parsing failed');\n            this.assert(ds.numRows == 2 && ds.numCols == 5, 'wrong row/column count');\n            let colTypes = [\"molecule\", \"string\", \"integer\", \"real\", \"boolean\"];\n            for (let n = 0; n < colTypes.length; n++)\n                this.assert(ds.colType(n) == colTypes[n], 'column#' + (n + 1) + ' wrong type');\n            this.assert(ds.getMolecule(0, 0).numAtoms == 1, 'row 1: invalid molecule');\n            this.assert(ds.getString(0, 1) == 'string', 'row 1: invalid string');\n            this.assert(ds.getInteger(0, 2) == 1, 'row 1: invalid integer');\n            this.assert(ds.getReal(0, 3) == 1.5, 'row 1: invalid real');\n            this.assert(ds.getBoolean(0, 4) == true, 'row 1: invalid boolean');\n            this.assert(ds.getMolecule(1, 0).numAtoms == 1, 'row 2: invalid molecule');\n            for (let n = 1; n < ds.numCols; n++)\n                this.assert(ds.isNull(1, n), 'row 2, column#' + (n + 1) + ' supposed to be null');\n        });\n    }\n    calcStrictArom() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.assert(this.molStereo != null, 'molecule not loaded');\n            let meta = _src_data_MetaMolecule__WEBPACK_IMPORTED_MODULE_4__.MetaMolecule.createStrict(this.molStereo);\n            this.assert(meta.atomArom != null, 'no aromaticity obtained');\n            for (let n = 1; n <= 10; n++)\n                this.assert(meta.isAtomAromatic(n), 'atom #' + n + ' supposed to be aromatic');\n            for (let n = 1; n <= 10; n++)\n                this.assert(meta.isBondAromatic(n), 'bond #' + n + ' supposed to be aromatic');\n        });\n    }\n    calcStereoChem() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.assert(this.molStereo != null, 'molecule not loaded');\n            let meta = _src_data_MetaMolecule__WEBPACK_IMPORTED_MODULE_4__.MetaMolecule.createStrictRubric(this.molStereo);\n            this.assert(meta.rubricTetra != null, 'no tetrahedral rubric obtained');\n            this.assert(meta.rubricSides != null, 'no cis/trans rubric obtained');\n            let stereo = _src_data_Stereochemistry__WEBPACK_IMPORTED_MODULE_7__.Stereochemistry.create(meta);\n            let tet11 = stereo.atomTetraChirality(11);\n            this.assert(tet11 == _src_data_Stereochemistry__WEBPACK_IMPORTED_MODULE_7__.Stereochemistry.STEREO_NEG, 'atom 11: incorrect stereochemistry, got ' + tet11);\n            let tet19 = stereo.atomTetraChirality(19);\n            this.assert(tet19 == _src_data_Stereochemistry__WEBPACK_IMPORTED_MODULE_7__.Stereochemistry.STEREO_POS, 'atom 19: incorrect stereochemistry, got ' + tet19);\n            let tet20 = stereo.atomTetraChirality(20);\n            this.assert(tet20 == _src_data_Stereochemistry__WEBPACK_IMPORTED_MODULE_7__.Stereochemistry.STEREO_POS, 'atom 20: incorrect stereochemistry, got ' + tet20);\n            let side26 = stereo.bondSideStereo(26);\n            this.assert(side26 == _src_data_Stereochemistry__WEBPACK_IMPORTED_MODULE_7__.Stereochemistry.STEREO_NEG, 'bond 26: incorrect stereochemistry, got ' + side26);\n        });\n    }\n    calcFingerprints() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.assert(this.dsCircular != null, 'datasheet not loaded');\n            const ds = this.dsCircular;\n            for (let n = 0; n < ds.numRows; n++) {\n                let mol = ds.getMolecule(n, 'Molecule');\n                let ecfp0 = [], ecfp2 = [], ecfp4 = [], ecfp6 = [];\n                for (let fp of ds.getString(n, 'ECFP0').split(','))\n                    if (fp.length > 0)\n                        ecfp0.push(parseInt(fp));\n                for (let fp of ds.getString(n, 'ECFP2').split(','))\n                    if (fp.length > 0)\n                        ecfp2.push(parseInt(fp));\n                for (let fp of ds.getString(n, 'ECFP4').split(','))\n                    if (fp.length > 0)\n                        ecfp4.push(parseInt(fp));\n                for (let fp of ds.getString(n, 'ECFP6').split(','))\n                    if (fp.length > 0)\n                        ecfp6.push(parseInt(fp));\n                _src_util_Vec__WEBPACK_IMPORTED_MODULE_9__.Vec.sort(ecfp0);\n                _src_util_Vec__WEBPACK_IMPORTED_MODULE_9__.Vec.sort(ecfp2);\n                _src_util_Vec__WEBPACK_IMPORTED_MODULE_9__.Vec.sort(ecfp4);\n                _src_util_Vec__WEBPACK_IMPORTED_MODULE_9__.Vec.sort(ecfp6);\n                let circ = _src_calc_CircularFingerprints__WEBPACK_IMPORTED_MODULE_0__.CircularFingerprints.create(mol, _src_calc_CircularFingerprints__WEBPACK_IMPORTED_MODULE_0__.CircularFingerprints.CLASS_ECFP6);\n                let got = [[], [], [], []];\n                for (let fp of circ.getFingerprints())\n                    if (got[fp.iteration].indexOf(fp.hashCode) < 0)\n                        got[fp.iteration].push(fp.hashCode);\n                for (let ecfp of got)\n                    _src_util_Vec__WEBPACK_IMPORTED_MODULE_9__.Vec.sort(ecfp);\n                this.assert(_src_util_Vec__WEBPACK_IMPORTED_MODULE_9__.Vec.equals(ecfp0, got[0]), 'row#' + (n + 1) + ', iter#0: wanted ' + ecfp0 + ', got ' + got[0]);\n                this.assert(_src_util_Vec__WEBPACK_IMPORTED_MODULE_9__.Vec.equals(ecfp2, got[1]), 'row#' + (n + 1) + ', iter#1: wanted ' + ecfp2 + ', got ' + got[1]);\n                this.assert(_src_util_Vec__WEBPACK_IMPORTED_MODULE_9__.Vec.equals(ecfp4, got[2]), 'row#' + (n + 1) + ', iter#2: wanted ' + ecfp4 + ', got ' + got[2]);\n                this.assert(_src_util_Vec__WEBPACK_IMPORTED_MODULE_9__.Vec.equals(ecfp6, got[3]), 'row#' + (n + 1) + ', iter#3: wanted ' + ecfp6 + ', got ' + got[3]);\n            }\n        });\n    }\n    molfileRoundTrip() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const ds = this.dsRoundtrip;\n            for (let n = 0; n < ds.numRows; n++) {\n                let strRow = 'row#' + (n + 1);\n                let mol = ds.getMolecule(n, 'Molecule');\n                let mdl = new _src_data_MDLWriter__WEBPACK_IMPORTED_MODULE_3__.MDLMOLWriter(mol).write();\n                let alt = new _src_data_MDLReader__WEBPACK_IMPORTED_MODULE_2__.MDLMOLReader(mdl).parse();\n                this.assert(mol.numAtoms == alt.numAtoms && mol.numBonds == alt.numBonds, strRow + ', atom/bond count differs');\n                let problems = [];\n                for (let i = 1; i <= mol.numAtoms; i++) {\n                    if (mol.atomElement(i) != alt.atomElement(i))\n                        problems.push(strRow + '/atom #' + i + ': elements different');\n                    if (mol.atomCharge(i) != alt.atomCharge(i))\n                        problems.push(strRow + '/atom #' + i + ': charges different');\n                    if (mol.atomUnpaired(i) != alt.atomUnpaired(i))\n                        problems.push(strRow + '/atom #' + i + ': unpaired different');\n                    if (mol.atomIsotope(i) != alt.atomIsotope(i))\n                        problems.push(strRow + '/atom #' + i + ': isotope different');\n                    if (mol.atomMapNum(i) != alt.atomMapNum(i))\n                        problems.push(strRow + '/atom #' + i + ': mapnum different');\n                    if (mol.atomHydrogens(i) != alt.atomHydrogens(i))\n                        problems.push(strRow + '/atom #' + i + ': hydrogens different');\n                    if (mol.atomHExplicit(i) != alt.atomHExplicit(i))\n                        problems.push(strRow + '/atom #' + i + ': explicitH different');\n                }\n                for (let i = 1; i <= mol.numBonds; i++) {\n                    if (mol.bondOrder(i) != alt.bondOrder(i))\n                        problems.push(strRow + '/bond #' + i + ': bond orders different');\n                    if (mol.bondType(i) != alt.bondType(i))\n                        problems.push(strRow + '/bond #' + i + ': bond types different');\n                }\n                if (problems.length > 0) {\n                    console.log('Round trip problems:');\n                    for (let p of problems)\n                        console.log(p);\n                    console.log('Original molecule:\\n' + mol);\n                    console.log('MDL Molfile CTAB:\\n' + mdl);\n                    console.log('Parsed back molecule:\\n' + alt);\n                }\n                this.assert(problems.length == 0, problems.join('; '));\n                let wantMDL = ds.getString(n, 'Molfile');\n                if (mdl.trim() != (0,_src_util_util__WEBPACK_IMPORTED_MODULE_8__.orBlank)(wantMDL).trim()) {\n                    if (wantMDL)\n                        console.log('Molfile missing from validation data.');\n                    else\n                        console.log('Desired Molfile:\\n' + wantMDL);\n                    console.log('Got Molfile:\\n' + mdl);\n                    this.assert(false, strRow + ': initial Molfile invalid');\n                }\n            }\n        });\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./val/src/ValidationHeadlessMolecule.ts?");

/***/ }),

/***/ "./val/src/ValidationHeadlessReaction.ts":
/*!***********************************************!*\
  !*** ./val/src/ValidationHeadlessReaction.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ValidationHeadlessReaction\": () => (/* binding */ ValidationHeadlessReaction)\n/* harmony export */ });\n/* harmony import */ var _src_aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/aspect/Experiment */ \"./src/aspect/Experiment.ts\");\n/* harmony import */ var _src_data_DataSheetStream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/data/DataSheetStream */ \"./src/data/DataSheetStream.ts\");\n/* harmony import */ var _src_util_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../src/util/util */ \"./src/util/util.ts\");\n/* harmony import */ var _Validation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Validation */ \"./val/src/Validation.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\nclass ValidationHeadlessReaction extends _Validation__WEBPACK_IMPORTED_MODULE_3__.Validation {\n    constructor(urlBase) {\n        super();\n        this.urlBase = urlBase;\n        this.add('Experiment aspect', this.confirmAspect);\n    }\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.strExperiment = yield (0,_src_util_util__WEBPACK_IMPORTED_MODULE_2__.readTextURL)(this.urlBase + 'experiment.ds');\n        });\n    }\n    confirmAspect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.assert(!!this.strExperiment, 'datasheet not loaded');\n            let ds = _src_data_DataSheetStream__WEBPACK_IMPORTED_MODULE_1__.DataSheetStream.readXML(this.strExperiment);\n            this.assert(ds != null, 'parsing failed');\n            this.assert(_src_aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__.Experiment.isExperiment(ds), 'aspect claimed not an Experiment');\n            let xs = new _src_aspect_Experiment__WEBPACK_IMPORTED_MODULE_0__.Experiment(ds);\n            let entry = xs.getEntry(0);\n            this.assert(entry != null, 'null entry returned');\n            this.assert(entry.steps.length == 2, 'reaction supposed to be 2 steps, got ' + entry.steps.length);\n            this.assert(entry.steps[0].reactants.length == 1, 'require step 1: #reactants = 1');\n            this.assert(entry.steps[0].reagents.length == 3, 'require step 1: #reagents = 3');\n            this.assert(entry.steps[0].products.length == 2, 'require step 1: #products = 2');\n            this.assert(entry.steps[1].reactants.length == 0, 'require step 2: #reactants = 0');\n            this.assert(entry.steps[1].reagents.length == 1, 'require step 2: #reagents = 1');\n            this.assert(entry.steps[1].products.length == 2, 'require step 2: #products = 2');\n        });\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./val/src/ValidationHeadlessReaction.ts?");

/***/ }),

/***/ "./val/src/WebValExec.ts":
/*!*******************************!*\
  !*** ./val/src/WebValExec.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WebValExec\": () => (/* binding */ WebValExec)\n/* harmony export */ });\n/* harmony import */ var _src_util_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/util/dom */ \"./src/util/dom.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nclass WebValExec {\n    constructor(validation) {\n        this.validation = validation;\n    }\n    runTests(parent) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let domParent = (0,_src_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)(parent);\n            domParent.empty();\n            if (this.validation.setupError) {\n                let div = (0,_src_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<div/>').appendTo(domParent).css({ 'color': 'red' });\n                div.setText('Setup failed: ' + this.validation.setupError);\n                return;\n            }\n            let table = (0,_src_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<table/>').appendTo(domParent);\n            let tdStatus = [], tdInfo = [];\n            for (let n = 0; n < this.validation.count; n++) {\n                let tr = (0,_src_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<tr/>').appendTo(table);\n                let td = (0,_src_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<td valign=\"top\"/>').appendTo(tr);\n                tdStatus.push(td);\n                td = (0,_src_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<td valign=\"top\"></td>').appendTo(tr);\n                td.setText(this.validation.getTitle(n));\n                tdInfo.push(td);\n            }\n            for (let n = 0; n < this.validation.count; n++) {\n                tdStatus[n].setHTML('&#9744;');\n                let [success, message, time] = yield this.validation.runTest(n);\n                if (success) {\n                    tdStatus[n].setHTML('&#9745;');\n                    if (time >= 0.001) {\n                        let span = (0,_src_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<span style=\"color: #909090;\"/>').appendTo(tdInfo[n]);\n                        span.setText(' (' + time.toFixed(3) + ' sec)');\n                    }\n                }\n                else {\n                    tdStatus[n].setHTML('<span style=\"color: red;\">&#9746;</span>');\n                    let para = (0,_src_util_dom__WEBPACK_IMPORTED_MODULE_0__.dom)('<p style=\"color: purple; margin-top: 0;\"/>').appendTo(tdInfo[n]);\n                    para.setText(message ? message : 'failed');\n                    tdStatus[n].setCSS('background-color', '#FFF0F0');\n                    tdInfo[n].setCSS('background-color', '#FFF0F0');\n                }\n            }\n        });\n    }\n}\n\n\n//# sourceURL=webpack://WebMolKit/./val/src/WebValExec.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./dist/index-val.ts");
/******/ 	WebMolKit = __webpack_exports__;
/******/ 	
/******/ })()
;